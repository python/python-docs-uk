# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Programming FAQ"
msgstr "FAQ з програмування"

msgid "Contents"
msgstr "Зміст"

msgid "General Questions"
msgstr "Загальні питання"

msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"Чи існує налагоджувач рівня вихідного коду з точками зупинки, однокроковим "
"режимом тощо?"

msgid "Yes."
msgstr "Так."

msgid ""
"Several debuggers for Python are described below, and the built-in function :"
"func:`breakpoint` allows you to drop into any of them."
msgstr ""
"Нижче описано кілька налагоджувачів для Python, і вбудована функція :func:"
"`breakpoint` дозволяє вам перейти до будь-якого з них."

msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It "
"is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"Модуль pdb — це простий, але адекватний налагоджувач у консольному режимі "
"для Python. Це частина стандартної бібліотеки Python і :mod:`задокументована "
"в Library Reference Manual <pdb>`. Ви також можете написати власний "
"налагоджувач, використовуючи код для pdb як приклад."

msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as Tools/scripts/idle), includes a "
"graphical debugger."
msgstr ""
"Інтерактивне середовище розробки IDLE, яке є частиною стандартного "
"дистрибутива Python (зазвичай доступне як Tools/scripts/idle), включає "
"графічний налагоджувач."

msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such "
"as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin — це середовище розробки Python, яке містить налагоджувач "
"графічного інтерфейсу на основі pdb. Налагоджувач PythonWin забарвлює точки "
"зупину та має чимало цікавих функцій, таких як налагодження програм, які не "
"належать до PythonWin. PythonWin доступний як частина проекту `pywin32 "
"<https://github.com/mhammond/pywin32>`_ і як частина дистрибутива "
"`ActivePython <https://www.activestate.com/products/python/>`_."

msgid ""
"`Eric <http://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <http://eric-ide.python-projects.org/>`_ — це IDE, побудоване на PyQt "
"і компоненті редагування Scintilla."

msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ є gdb-подібним "
"налагоджувачем."

msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ — це середовище "
"розробки з інструментами налагодження, яке інтегрується з програмним "
"забезпеченням для керування версіями."

msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Існує кілька комерційних Python IDE, які містять графічні налагоджувачі. "
"Вони включають:"

msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"Чи існують інструменти, які допомагають знайти помилки або виконати "
"статичний аналіз?"

msgid ""
"`Pylint <https://www.pylint.org/>`_ and `Pyflakes <https://github.com/PyCQA/"
"pyflakes>`_ do basic checking that will help you catch bugs sooner."
msgstr ""

msgid ""
"Static type checkers such as `Mypy <http://mypy-lang.org/>`_, `Pyre <https://"
"pyre-check.org/>`_, and `Pytype <https://github.com/google/pytype>`_ can "
"check type hints in Python source code."
msgstr ""
"Засоби перевірки статичних типів, такі як `Mypy <http://mypy-lang.org/>`_, "
"`Pyre <https://pyre-check.org/>`_ і `Pytype <https://github.com/google/"
"pytype>`_, можуть перевіряти підказки типу у вихідному коді Python."

msgid "How can I create a stand-alone binary from a Python script?"
msgstr "Як я можу створити автономний двійковий файл зі сценарію Python?"

msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"Вам не потрібна можливість компілювати код Python до C, якщо все, що вам "
"потрібно, це окрема програма, яку користувачі можуть завантажити та "
"запустити без попередньої інсталяції дистрибутива Python. Існує ряд "
"інструментів, які визначають набір модулів, необхідних для програми, і "
"зв’язують ці модулі з двійковим файлом Python для створення єдиного "
"виконуваного файлу."

msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as ``Tools/freeze``. It converts Python byte code to C arrays; with a C "
"compiler you can embed all your modules into a new program, which is then "
"linked with the standard Python modules."
msgstr ""
"Один з них — скористатися інструментом заморожування, який включено до "
"дерева вихідних кодів Python як ``Tools/freeze``. Він перетворює байт-код "
"Python на масиви C; за допомогою компілятора C ви можете вбудувати всі свої "
"модулі в нову програму, яка потім зв’язується зі стандартними модулями "
"Python."

msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in "
"the source directory (for built-in modules).  It then turns the bytecode for "
"modules written in Python into C code (array initializers that can be turned "
"into code objects using the marshal module) and creates a custom-made config "
"file that only contains those built-in modules which are actually used in "
"the program.  It then compiles the generated C code and links it with the "
"rest of the Python interpreter to form a self-contained binary which acts "
"exactly like your script."
msgstr ""
"Він працює шляхом рекурсивного сканування джерела на наявність інструкцій "
"імпорту (в обох формах) і пошуку модулів у стандартному шляху Python, а "
"також у вихідному каталозі (для вбудованих модулів). Потім він перетворює "
"байт-код для модулів, написаних на Python, у код C (ініціалізатори масивів, "
"які можна перетворити на об’єкти коду за допомогою модуля marshal) і створює "
"спеціальний файл конфігурації, який містить лише ті вбудовані модулі, які "
"фактично використовуються в програма. Потім він компілює згенерований код C "
"і пов’язує його з рештою інтерпретатора Python, щоб сформувати самодостатній "
"двійковий файл, який діє точно так само, як ваш сценарій."

msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Наступні пакети можуть допомогти зі створенням консолі та виконуваних файлів "
"графічного інтерфейсу користувача:"

msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (Кросплатформенний)"

msgid "`PyInstaller <http://www.pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <http://www.pyinstaller.org/>`_ (Кросплатформенний)"

msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(Кросплатформенний)"

msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ "
"(Кросплатформенний)"

msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ (лише для macOS)"

msgid "`py2exe <http://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <http://www.py2exe.org/>`_ (лише Windows)"

msgid "Are there coding standards or a style guide for Python programs?"
msgstr ""
"Чи існують стандарти кодування чи керівництво по стилю для програм Python?"

msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Так. Стиль кодування, необхідний для модулів стандартної бібліотеки, "
"задокументовано як :pep:`8`."

msgid "Core Language"
msgstr "Основна мова"

msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "Чому я отримую помилку UnboundLocalError, коли змінна має значення?"

msgid ""
"It can be a surprise to get the UnboundLocalError in previously working code "
"when it is modified by adding an assignment statement somewhere in the body "
"of a function."
msgstr ""
"Може бути несподіванкою отримати помилку UnboundLocalError у попередньому "
"робочому коді, коли його змінено шляхом додавання оператора призначення десь "
"у тілі функції."

msgid "This code:"
msgstr "Цей код:"

msgid "works, but this code:"
msgstr "працює, але цей код:"

msgid "results in an UnboundLocalError:"
msgstr "призводить до UnboundLocalError:"

msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Це пояснюється тим, що коли ви робите призначення змінній в області "
"видимості, ця змінна стає локальною для цієї області і затьмарює будь-яку "
"змінну з подібним іменем у зовнішній області. Оскільки останній оператор у "
"foo присвоює нове значення ``x``, компілятор розпізнає його як локальну "
"змінну. Отже, коли попередній ``print(x)`` намагається надрукувати "
"неініціалізовану локальну змінну, виникає помилка."

msgid ""
"In the example above you can access the outer scope variable by declaring it "
"global:"
msgstr ""
"У наведеному вище прикладі ви можете отримати доступ до зовнішньої змінної "
"області видимості, оголосивши її глобальною:"

msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you "
"are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Ця явна декларація потрібна, щоб нагадати вам, що (на відміну від зовнішньо "
"аналогічної ситуації зі змінними класу та екземпляра) ви фактично змінюєте "
"значення змінної у зовнішній області:"

msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Ви можете зробити подібне у вкладеній області, використовуючи ключове слово :"
"keyword:`nonlocal`:"

msgid "What are the rules for local and global variables in Python?"
msgstr "Які правила для локальних і глобальних змінних у Python?"

msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"У Python змінні, на які посилаються лише всередині функції, є неявно "
"глобальними. Якщо змінній присвоєно значення будь-де в тілі функції, вона "
"вважається локальною, якщо вона явно не оголошена як глобальна."

msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time.  "
"You'd have to declare as global every reference to a built-in function or to "
"a component of an imported module.  This clutter would defeat the usefulness "
"of the ``global`` declaration for identifying side-effects."
msgstr ""
"Хоча це трохи дивно спочатку, мить міркування пояснює це. З одного боку, "
"вимога :keyword:`global` для призначених змінних забезпечує захист від "
"ненавмисних побічних ефектів. З іншого боку, якби ``global`` був потрібний "
"для всіх глобальних посилань, ви б використовували ``global`` весь час. Ви "
"повинні оголосити як глобальне кожне посилання на вбудовану функцію або на "
"компонент імпортованого модуля. Цей безлад перекреслив би корисність "
"оголошення ``global`` для визначення побічних ефектів."

msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"Чому всі лямбда-вирази, визначені в циклі з різними значеннями, повертають "
"однаковий результат?"

msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Припустімо, що ви використовуєте цикл for для визначення кількох різних "
"лямбда-виразів (або навіть простих функцій), наприклад::"

msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Це дає вам список, який містить 5 лямбда-виразів, які обчислюють ``x**2``. "
"Можна очікувати, що під час виклику вони повертатимуть, відповідно, ``0``, "
"``1``, ``4``, ``9`` і ``16``. Однак, коли ви насправді спробуєте, ви "
"побачите, що всі вони повертають ``16``::"

msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by "
"changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Це відбувається тому, що ``x`` не є локальним для лямбда-вираз, а визначено "
"у зовнішній області видимості, і доступ до нього здійснюється під час "
"виклику лямбда-виразки --- а не тоді, коли вона визначена. Наприкінці циклу "
"значення ``x`` дорівнює ``4``, тому всі функції тепер повертають ``4**2``, "
"тобто ``16``. Ви також можете перевірити це, змінивши значення ``x`` і "
"подивившись, як змінюються результати лямбда-виражень:"

msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"Щоб уникнути цього, вам потрібно зберегти значення в змінних, локальних для "
"лямбда-виразів, щоб вони не покладалися на значення глобального ``x``::"

msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in "
"the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Тут ``n=x`` створює нову змінну ``n``, локальну для лямбда-виразу, яка "
"обчислюється, коли лямбда-визначення визначено таким чином, щоб воно мало те "
"саме значення, яке ``x`` мав у цій точці циклу. Це означає, що значення "
"``n`` буде ``0`` у першому лямбда, ``1`` у другому, ``2`` у третьому, і так "
"далі. Тому кожна лямбда тепер повертатиме правильний результат::"

msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Зауважте, що ця поведінка не властива лямбда-виразам, але також стосується "
"звичайних функцій."

msgid "How do I share global variables across modules?"
msgstr "Як поділитися глобальними змінними між модулями?"

msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then "
"becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected "
"everywhere.  For example:"
msgstr ""
"Канонічний спосіб обміну інформацією між модулями в одній програмі полягає у "
"створенні спеціального модуля (часто називається config або cfg). Просто "
"імпортуйте модуль конфігурації в усі модулі вашої програми; потім модуль "
"стає доступним як глобальне ім'я. Оскільки існує лише один екземпляр кожного "
"модуля, будь-які зміни, внесені до об’єкта модуля, відображаються всюди. "
"Наприклад:"

msgid "config.py::"
msgstr "config.py::"

msgid "mod.py::"
msgstr "mod.py::"

msgid "main.py::"
msgstr "main.py::"

msgid ""
"Note that using a module is also the basis for implementing the Singleton "
"design pattern, for the same reason."
msgstr ""
"Зверніть увагу, що використання модуля також є основою для реалізації "
"шаблону проектування Singleton з тієї ж причини."

msgid "What are the \"best practices\" for using import in a module?"
msgstr "Які \"найкращі практики\" використання імпорту в модулі?"

msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"Загалом, не використовуйте ``from modulename import *``. Це захаращує "
"простір імен імпортера, і значно ускладнює для лінтерів виявлення "
"невизначених імен."

msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Імпорт модулів у верхній частині файлу. Це дає зрозуміти, які інші модулі "
"вимагає ваш код, і уникає запитань про те, чи входить ім’я модуля в область "
"видимості. Використання одного імпорту на рядок полегшує додавання та "
"видалення імпортованих модулів, але використання кількох імпортів на рядок "
"займає менше місця на екрані."

msgid "It's good practice if you import modules in the following order:"
msgstr "Доцільно імпортувати модулі в такому порядку:"

msgid "standard library modules -- e.g. ``sys``, ``os``, ``getopt``, ``re``"
msgstr ""
"модулі стандартної бібліотеки -- напр. ``sys``, ``os``, ``getopt``, ``re``"

msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. mx.DateTime, ZODB, PIL.Image, etc."
msgstr ""
"модулі сторонніх бібліотек (все, що встановлено в каталозі пакетів сайтів "
"Python) -- напр. mx.DateTime, ZODB, PIL.Image тощо."

msgid "locally-developed modules"
msgstr "модулі локальної розробки"

msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"Іноді необхідно перемістити імпорт до функції чи класу, щоб уникнути проблем "
"із циклічним імпортом. Гордон Макміллан каже:"

msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level.  "
"That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"Циклічний імпорт підходить, якщо обидва модулі використовують форму імпорту "
"\"import <module>\". Вони зазнають невдачі, коли 2-й модуль хоче отримати "
"ім’я з першого (\"з імені імпорту модуля\"), а імпорт здійснюється на "
"верхньому рівні. Це тому, що імена в 1-му ще недоступні, оскільки перший "
"модуль зайнятий імпортом 2-го."

msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"У цьому випадку, якщо другий модуль використовується лише в одній функції, "
"імпорт можна легко перемістити в цю функцію. До моменту виклику імпорту "
"перший модуль завершить ініціалізацію, і другий модуль зможе виконувати свій "
"імпорт."

msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be "
"possible to import all of the modules at the top of the file.  In this case, "
"importing the correct modules in the corresponding platform-specific code is "
"a good option."
msgstr ""
"Також може знадобитися перемістити імпорт із верхнього рівня коду, якщо "
"деякі модулі залежать від платформи. У цьому випадку може бути навіть "
"неможливо імпортувати всі модулі у верхній частині файлу. У цьому випадку "
"хорошим варіантом є імпорт правильних модулів у відповідний специфічний для "
"платформи код."

msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is "
"especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module "
"the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Переміщуйте імпорт у локальну область, наприклад, у визначення функції, лише "
"якщо це необхідно для вирішення проблеми, як-от уникнення циклічного імпорту "
"або намагання скоротити час ініціалізації модуля. Ця техніка особливо "
"корисна, якщо багато імпортів непотрібні залежно від того, як виконується "
"програма. Ви також можете перемістити імпорт у функцію, якщо модулі "
"використовуються лише в цій функції. Зауважте, що завантаження модуля вперше "
"може бути дорогим через одноразову ініціалізацію модуля, але багаторазове "
"завантаження модуля практично безкоштовне, коштуючи лише кількох пошуків у "
"словнику. Навіть якщо назва модуля вийшла за межі видимості, модуль, "
"імовірно, доступний у :data:`sys.modules`."

msgid "Why are default values shared between objects?"
msgstr "Чому значення за замовчуванням є спільними між об’єктами?"

msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Цей тип помилок зазвичай кусає програмістів-неофітів. Розглянемо цю функцію::"

msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins "
"executing, ``mydict`` starts out with an item already in it."
msgstr ""
"Під час першого виклику цієї функції ``mydict`` містить один елемент. "
"Другого разу ``mydict`` містить два елементи, тому що коли ``foo()`` починає "
"виконуватися, ``mydict`` починає з елементом, який уже є в ньому."

msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"Часто очікується, що виклик функції створює нові об’єкти для значень за "
"замовчуванням. Такого не буває. Значення за замовчуванням створюються рівно "
"один раз під час визначення функції. Якщо цей об’єкт змінено, як і словник у "
"цьому прикладі, наступні виклики функції посилатимуться на цей змінений "
"об’єкт."

msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"За визначенням, незмінні об’єкти, такі як числа, рядки, кортежі та ``None``, "
"захищені від змін. Зміни змінних об’єктів, таких як словники, списки та "
"екземпляри класів, можуть призвести до плутанини."

msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"Через цю функцію хороша практика програмування не використовувати змінні "
"об’єкти як значення за замовчуванням. Натомість використовуйте ``None`` як "
"значення за замовчуванням і всередині функції перевірте, чи параметр "
"``None``, і створіть новий список/словник/що завгодно, якщо він є. "
"Наприклад, не пишіть::"

msgid "but::"
msgstr "але ::"

msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Ця функція може бути корисною. Якщо у вас є функція, обчислення якої "
"потребує багато часу, поширеною технікою є кешування параметрів і "
"результуючого значення кожного виклику функції та повернення кешованого "
"значення, якщо те саме значення запитується знову. Це називається "
"\"запам'ятовування\" і може бути реалізовано так:"

msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Ви можете використовувати глобальну змінну, що містить словник, замість "
"значення за замовчуванням; це справа смаку."

msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"Як я можу передати необов’язкові або ключові параметри з однієї функції в "
"іншу?"

msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Зберіть аргументи за допомогою специфікаторів ``*`` і ``**`` у списку "
"параметрів функції; це дає вам позиційні аргументи як кортеж і ключові "
"аргументи як словник. Потім ви можете передати ці аргументи під час виклику "
"іншої функції за допомогою ``*`` і ``**``::"

msgid "What is the difference between arguments and parameters?"
msgstr "Яка різниця між аргументами та параметрами?"

msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what types "
"of arguments a function can accept.  For example, given the function "
"definition::"
msgstr ""

msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling "
"``func``, for example::"
msgstr ""
"*foo*, *bar* і *kwargs* є параметрами ``func``. Однак під час виклику "
"``func``, наприклад::"

msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "значення ``42``, ``314`` і ``somevar`` є аргументами."

msgid "Why did changing list 'y' also change list 'x'?"
msgstr "Чому зміна списку 'y' також змінила список 'x'?"

msgid "If you wrote code like::"
msgstr "Якщо ви написали такий код::"

msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"можливо, вам буде цікаво, чому додавання елемента до ``y`` також змінило "
"``x``."

msgid "There are two factors that produce this result:"
msgstr "Є два чинники, які призводять до такого результату:"

msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"Змінні - це просто імена, які посилаються на об'єкти. Виконання ``y = x`` не "
"створює копію списку — воно створює нову змінну ``y``, яка посилається на "
"той самий об’єкт, на який посилається ``x``. Це означає, що є лише один "
"об’єкт (список), і як ``x``, так і ``y`` посилаються на нього."

msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Списки :term:`mutable`, що означає, що ви можете змінювати їхній вміст."

msgid ""
"After the call to :meth:`~list.append`, the content of the mutable object "
"has changed from ``[]`` to ``[10]``.  Since both the variables refer to the "
"same object, using either name accesses the modified value ``[10]``."
msgstr ""
"Після виклику :meth:`~list.append` вміст змінного об’єкта змінився з ``[]`` "
"на ``[10]``. Оскільки обидві змінні посилаються на той самий об’єкт, "
"використання будь-якої назви дає доступ до зміненого значення ``[10]``."

msgid "If we instead assign an immutable object to ``x``::"
msgstr "Якщо натомість ми призначимо незмінний об’єкт ``x``::"

msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is "
"because integers are :term:`immutable`, and when we do ``x = x + 1`` we are "
"not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"ми бачимо, що в цьому випадку ``x`` і ``y`` більше не рівні. Це тому, що "
"цілі числа :term:`immutable`, і коли ми робимо ``x = x + 1``, ми не змінюємо "
"int ``5``, збільшуючи його значення; натомість ми створюємо новий об’єкт "
"(int ``6``) і призначаємо його ``x`` (тобто змінюємо, на який об’єкт "
"посилається ``x``). Після цього призначення ми маємо два об’єкти (цілі ``6`` "
"і ``5``) і дві змінні, які посилаються на них (``x`` тепер посилається на "
"``6``, але ``y`` все ще посилається на ``5``)."

msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and ``sorted(y)``) create a new object.  In general in Python (and in "
"all cases in the standard library) a method that mutates an object will "
"return ``None`` to help avoid getting the two types of operations confused.  "
"So if you mistakenly write ``y.sort()`` thinking it will give you a sorted "
"copy of ``y``, you'll instead end up with ``None``, which will likely cause "
"your program to generate an easily diagnosed error."
msgstr ""
"Деякі операції (наприклад, ``y.append(10)`` і ``y.sort()``) змінюють об’єкт, "
"тоді як зовні схожі операції (наприклад ``y = y + [10]`` і ``sorted(y)``) "
"створити новий об’єкт. Загалом у Python (і в усіх випадках у стандартній "
"бібліотеці) метод, який змінює об’єкт, повертатиме ``None``, щоб уникнути "
"плутанини між двома типами операцій. Отже, якщо ви помилково напишете ``y."
"sort()``, думаючи, що це дасть вам відсортовану копію ``y``, натомість ви "
"отримаєте ``None``, що, швидше за все, призведе до того, що ваша програма "
"згенерує легко діагностована помилка."

msgid ""
"However, there is one class of operations where the same operation sometimes "
"has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"Однак існує один клас операцій, де одна й та сама операція іноді має різну "
"поведінку з різними типами: розширені оператори присвоєння. Наприклад, "
"``+=`` змінює списки, але не кортежі чи цілі (``a_list += [1, 2, 3]`` "
"еквівалентно ``a_list.extend([1, 2, 3])`` і змінює ``a_list``, тоді як "
"``some_tuple += (1, 2, 3)`` і ``some_int += 1`` створюють нові об’єкти)."

msgid "In other words:"
msgstr "Іншими словами:"

msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Якщо у нас є змінний об’єкт (:class:`list`, :class:`dict`, :class:`set` "
"тощо), ми можемо використати певні операції, щоб змінити його, і всі змінні, "
"які посилаються на нього, будуть побачити зміни."

msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Якщо у нас є незмінний об’єкт (:class:`str`, :class:`int`, :class:`tuple` "
"тощо), усі змінні, які посилаються на нього, завжди бачитимуть те саме "
"значення, але операції, що перетворюють це значення в нове значення завжди "
"повертає новий об’єкт."

msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Якщо ви хочете знати, чи дві змінні посилаються на той самий об’єкт, ви "
"можете скористатися оператором :keyword:`is` або вбудованою функцією :func:"
"`id`."

msgid "How do I write a function with output parameters (call by reference)?"
msgstr "Як написати функцію з вихідними параметрами (виклик за посиланням)?"

msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se.  "
"You can achieve the desired effect in a number of ways."
msgstr ""
"Пам’ятайте, що в Python аргументи передаються шляхом присвоєння. Оскільки "
"присвоєння лише створює посилання на об’єкти, немає псевдоніма між ім’ям "
"аргументу у викликаючому та викликаному, а тому немає виклику за посиланням "
"як такого. Бажаного ефекту можна досягти кількома способами."

msgid "By returning a tuple of the results::"
msgstr "Повертаючи кортеж результатів::"

msgid "This is almost always the clearest solution."
msgstr "Це майже завжди найясніше рішення."

msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"За допомогою глобальних змінних. Це небезпечно для потоків і не "
"рекомендується."

msgid "By passing a mutable (changeable in-place) object::"
msgstr "Передаючи змінний (змінний на місці) об’єкт::"

msgid "By passing in a dictionary that gets mutated::"
msgstr "Передаючи словник, який мутується::"

msgid "Or bundle up values in a class instance::"
msgstr "Або об'єднайте значення в екземпляр класу::"

msgid "There's almost never a good reason to get this complicated."
msgstr "Майже ніколи не буває вагомих причин ускладнювати це."

msgid "Your best choice is to return a tuple containing the multiple results."
msgstr "Ваш найкращий вибір — повернути кортеж, що містить кілька результатів."

msgid "How do you make a higher order function in Python?"
msgstr "Як створити функцію вищого порядку в Python?"

msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested "
"scopes::"
msgstr ""
"У вас є два варіанти: ви можете використовувати вкладені області або ви "
"можете використовувати викликані об’єкти. Наприклад, припустімо, що ви "
"хочете визначити ``linear(a,b)``, яка повертає функцію ``f(x)``, яка "
"обчислює значення ``a*x+b``. Використання вкладених областей::"

msgid "Or using a callable object::"
msgstr "Або за допомогою викликаного об'єкта::"

msgid "In both cases, ::"
msgstr "В обох випадках ::"

msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "дає викликуваний об’єкт, де ``taxes(10e6) == 0,3 * 10e6 + 2``."

msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"Підхід викликаного об’єкта має той недолік, що він трохи повільніший і "
"призводить до трохи довшого коду. Однак зауважте, що колекція викликів може "
"ділитися своїм підписом через успадкування::"

msgid "Object can encapsulate state for several methods::"
msgstr "Об'єкт може інкапсулювати стан кількома методами:"

msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the "
"same counting variable."
msgstr ""
"Тут ``inc()``, ``dec()`` і ``reset()`` діють як функції, які спільно "
"використовують ту саму змінну підрахунку."

msgid "How do I copy an object in Python?"
msgstr "Як скопіювати об’єкт у Python?"

msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"Загалом, спробуйте :func:`copy.copy` або :func:`copy.deepcopy` для "
"загального випадку. Не всі об'єкти можна скопіювати, але більшість можна."

msgid ""
"Some objects can be copied more easily.  Dictionaries have a :meth:`~dict."
"copy` method::"
msgstr ""
"Деякі об'єкти можна легше скопіювати. Словники мають метод :meth:`~dict."
"copy`::"

msgid "Sequences can be copied by slicing::"
msgstr "Послідовності можна скопіювати шляхом нарізки:"

msgid "How can I find the methods or attributes of an object?"
msgstr "Як я можу знайти методи або атрибути об’єкта?"

msgid ""
"For an instance x of a user-defined class, ``dir(x)`` returns an "
"alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"Для екземпляра x визначеного користувачем класу ``dir(x)`` повертає "
"алфавітний список імен, що містять атрибути екземпляра та методи та "
"атрибути, визначені його класом."

msgid "How can my code discover the name of an object?"
msgstr "Як мій код може виявити назву об’єкта?"

msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"Загалом, не може, тому що об’єкти насправді не мають назв. По суті, "
"присвоєння завжди прив’язує ім’я до значення; те саме стосується операторів "
"``def`` і ``class``, але в цьому випадку значення є викликаним. Розглянемо "
"наступний код::"

msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name B the created instance is still reported as an "
"instance of class A.  However, it is impossible to say whether the "
"instance's name is a or b, since both names are bound to the same value."
msgstr ""
"Можна стверджувати, що клас має ім’я: навіть незважаючи на те, що він "
"прив’язаний до двох імен і викликається через ім’я B, створений екземпляр "
"все одно повідомляється як екземпляр класу A. Однак неможливо сказати, ім’я "
"екземпляра a чи b, оскільки обидва імена прив’язані до одного значення."

msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"Взагалі кажучи, вашому коду не потрібно \"знати імена\" певних значень. Якщо "
"ви не навмисне пишете інтроспективні програми, це зазвичай свідчить про те, "
"що зміна підходу може бути корисною."

msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"У comp.lang.python Фредрік Лунд якось дав чудову аналогію у відповідь на це "
"запитання:"

msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"Так само, як ви отримуєте ім’я того кота, якого знайшли на своєму під’їзді: "
"кіт (об’єкт) сам не може назвати вам своє ім’я, і йому це не дуже важливо, "
"тому єдиний спосіб дізнатися, як його звуть, це запитайте всіх своїх сусідів "
"(простір імен), чи це їхній кіт (об’єкт)..."

msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
"....і не дивуйтеся, якщо ви побачите, що він відомий під багатьма іменами "
"або взагалі без назви!"

msgid "What's up with the comma operator's precedence?"
msgstr "Що трапилося з пріоритетом оператора коми?"

msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "Кома не є оператором у Python. Розгляньте цю сесію::"

msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Оскільки кома є не оператором, а роздільником між виразами, наведене вище "
"оцінюється так, ніби ви ввели::"

msgid "not::"
msgstr "ні ::"

msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"Те саме стосується різних операторів присвоювання (``=``, ``+=`` тощо). Вони "
"насправді не є операторами, а синтаксичними роздільниками в операторах "
"присвоєння."

msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "Чи існує еквівалент потрійного оператора C \"?:\"?"

msgid "Yes, there is. The syntax is as follows::"
msgstr "Так, є. Синтаксис такий::"

msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"До появи цього синтаксису в Python 2.5 поширеною ідіомою було використання "
"логічних операторів::"

msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"Однак ця ідіома небезпечна, оскільки може дати неправильні результати, якщо "
"*on_true* має хибне логічне значення. Тому завжди краще використовувати "
"форму ``... if ... else ...``."

msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "Чи можна написати обфусковані однорядкові тексти на Python?"

msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`!"
"lambda`.  See the following three examples, due to Ulf Bartelt::"
msgstr ""
"Так. Зазвичай це робиться шляхом вкладення :keyword:`lambda` в :keyword:`!"
"lambda`. Перегляньте наступні три приклади, створені Ульфом Бартельтом:"

msgid "Don't try this at home, kids!"
msgstr "Не пробуйте цього вдома, діти!"

msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "Що означає коса риска (/) у списку параметрів функції?"

msgid ""
"A slash in the argument list of a function denotes that the parameters prior "
"to it are positional-only.  Positional-only parameters are the ones without "
"an externally-usable name.  Upon calling a function that accepts positional-"
"only parameters, arguments are mapped to parameters based solely on their "
"position. For example, :func:`divmod` is a function that accepts positional-"
"only parameters. Its documentation looks like this::"
msgstr ""
"Слеш у списку аргументів функції вказує на те, що параметри перед нею є лише "
"позиційними. Лише позиційні параметри – це ті параметри, які не мають назви "
"для зовнішнього використання. Після виклику функції, яка приймає лише "
"позиційні параметри, аргументи відображаються на параметри виключно на "
"основі їх позиції. Наприклад, :func:`divmod` — це функція, яка приймає лише "
"позиційні параметри. Його документація виглядає так:"

msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"Слеш у кінці списку параметрів означає, що обидва параметри є лише "
"позиційними. Таким чином, виклик :func:`divmod` з ключовими аргументами "
"призведе до помилки::"

msgid "Numbers and strings"
msgstr "Числа та рядки"

msgid "How do I specify hexadecimal and octal integers?"
msgstr "Як вказати шістнадцяткові та вісімкові цілі числа?"

msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"Щоб вказати вісімкову цифру, поставте перед вісімковим значенням нуль, а "
"потім малу або велику літеру \"o\". Наприклад, щоб встановити змінну \"a\" у "
"вісімкове значення \"10\" (8 у десятковій системі), введіть::"

msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"Шістнадцяткове так само легко. Просто поставте перед шістнадцятковим числом "
"нуль, а потім малий або великий регістр \"x\". Шістнадцяткові цифри можна "
"вказувати як у нижньому, так і у верхньому регістрі. Наприклад, в "
"інтерпретаторі Python::"

msgid "Why does -22 // 10 return -3?"
msgstr "Чому -22 // 10 повертає -3?"

msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"Головним чином це зумовлено бажанням, щоб ``i % j`` мав той самий знак, що "
"``j``. Якщо ви цього хочете, а також хочете::"

msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"тоді цілочисельне ділення має повернути підлогу. C також вимагає збереження "
"цієї ідентичності, а потім компіляторам, які скорочують ``i // j``, потрібно "
"зробити так, щоб ``i % j`` мав той самий знак, що і ``i``."

msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Є кілька реальних випадків використання ``i % j``, коли ``j`` є від'ємним. "
"Коли ``j`` додатне, їх багато, і практично в усіх з них корисніше, щоб ``i % "
"j`` було ``>= 0``. Якщо годинник показує 10 зараз, що він показував 200 "
"годин тому? ``-190 % 12 == 2`` є корисним; ``-190 % 12 == -10`` - це "
"помилка, яка чекає, щоб вкусити."

msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "Як отримати атрибут int literal замість SyntaxError?"

msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a "
"syntax error because the period is seen as a decimal point::"
msgstr ""
"Спроба пошуку літерального атрибута ``int`` у звичайний спосіб призводить до "
"синтаксичної помилки, оскільки крапка розглядається як десяткова крапка::"

msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr ""
"Рішення полягає в тому, щоб відокремити літерал від крапки пробілом або "
"дужками."

msgid "How do I convert a string to a number?"
msgstr "Як перетворити рядок на число?"

msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to floating-point, "
"e.g. ``float('144') == 144.0``."
msgstr ""
"Для цілих чисел використовуйте вбудований конструктор типу :func:`int`, "
"напр. ``int('144') == 144``. Так само :func:`float` перетворює на число з "
"плаваючою комою, наприклад. ``float('144') == 144.0``."

msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"За замовчуванням вони інтерпретують число як десяткове, так що ``int('0144') "
"== 144`` залишається істинним, а ``int('0x144')`` викликає :exc:"
"`ValueError`. ``int(string, base)`` бере основу для перетворення як другий "
"необов’язковий аргумент, тому ``int( '0x144', 16) == 324``. Якщо основа "
"вказана як 0, число інтерпретується за правилами Python: \"0o\" на початку "
"означає вісімкове число, а \"0x\" означає шістнадцяткове число."

msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"Не використовуйте вбудовану функцію :func:`eval`, якщо вам потрібно лише "
"перетворити рядки на числа. :func:`eval` буде значно повільніше, і це "
"становить ризик для безпеки: хтось може передати вам вираз Python, який може "
"мати небажані побічні ефекти. Наприклад, хтось може передати "
"``__import__('os').system(\"rm -rf $HOME\")``, що стерло б ваш домашній "
"каталог."

msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python "
"does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` також має ефект інтерпретації чисел як виразів Python, так що, "
"наприклад, ``eval('09')`` дає синтаксичну помилку, оскільки Python не "
"дозволяє починати '0' у десятковому числі (окрім '0')."

msgid "How do I convert a number to a string?"
msgstr "Як перетворити число на рядок?"

msgid ""
"To convert, e.g., the number 144 to the string '144', use the built-in type "
"constructor :func:`str`.  If you want a hexadecimal or octal representation, "
"use the built-in functions :func:`hex` or :func:`oct`.  For fancy "
"formatting, see the :ref:`f-strings` and :ref:`formatstrings` sections, e.g. "
"``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\"."
"format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"Щоб перетворити, наприклад, число 144 на рядок '144', використовуйте "
"вбудований конструктор типу :func:`str`. Якщо вам потрібне шістнадцяткове чи "
"вісімкове представлення, використовуйте вбудовані функції :func:`hex` або :"
"func:`oct`. Для цікавого форматування див. розділи :ref:`f-strings` і :ref:"
"`formatstrings`, напр. ``\"{:04d}\".format(144)`` дає ``'0144'``, а "
"``\"{:.3f}\".format(1.0/3.0)`` дає ``'0.333'`` ."

msgid "How do I modify a string in place?"
msgstr "Як змінити рядок на місці?"

msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it "
"from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"Ви не можете, тому що рядки незмінні. У більшості ситуацій вам слід просто "
"побудувати нову струну з різних частин, з яких ви хочете її зібрати. Однак, "
"якщо вам потрібен об’єкт із можливістю змінювати дані Unicode на місці, "
"спробуйте використати об’єкт :class:`io.StringIO` або модуль :mod:`array`::"

msgid "How do I use strings to call functions/methods?"
msgstr "Як використовувати рядки для виклику функцій/методів?"

msgid "There are various techniques."
msgstr "Існують різні техніки."

msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary "
"advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"Найкраще використовувати словник, який відображає рядки на функції. Основна "
"перевага цього методу полягає в тому, що рядки не повинні збігатися з "
"назвами функцій. Це також основна техніка, яка використовується для емуляції "
"конструкції case:"

msgid "Use the built-in function :func:`getattr`::"
msgstr "Використовуйте вбудовану функцію :func:`getattr`::"

msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Зауважте, що :func:`getattr` працює з будь-яким об’єктом, включаючи класи, "
"екземпляри класів, модулі тощо."

msgid "This is used in several places in the standard library, like this::"
msgstr ""
"Це використовується в кількох місцях стандартної бібліотеки, наприклад:"

msgid "Use :func:`locals` to resolve the function name::"
msgstr "Використовуйте :func:`locals` для визначення імені функції::"

msgid ""
"Is there an equivalent to Perl's chomp() for removing trailing newlines from "
"strings?"
msgstr ""
"Чи існує еквівалент Perl chomp() для видалення завершальних символів нового "
"рядка з рядків?"

msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several "
"empty lines at the end, the line terminators for all the blank lines will be "
"removed::"
msgstr ""
"Ви можете використовувати ``S.rstrip(\"\\r\\n\")``, щоб видалити всі "
"входження будь-якого термінатора рядка з кінця рядка ``S``, не видаляючи "
"інші пробіли в кінці. Якщо рядок ``S`` представляє більше одного рядка з "
"кількома порожніми рядками в кінці, кінцеві знаки для всіх порожніх рядків "
"буде видалено:"

msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Оскільки це зазвичай бажано лише під час читання тексту по одному рядку, "
"використання ``S.rstrip()`` цей спосіб працює добре."

msgid "Is there a scanf() or sscanf() equivalent?"
msgstr "Чи існує еквівалент scanf() або sscanf()?"

msgid "Not as such."
msgstr "Не як такої."

msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using :"
"func:`int` or :func:`float`.  ``split()`` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"Для простого синтаксичного аналізу введення найпростішим підходом є "
"розділення рядка на слова, розділені пробілами, за допомогою методу рядкових "
"об’єктів :meth:`~str.split`, а потім перетворення десяткових рядків на "
"числові значення за допомогою :func:`int` або :func:`float`. ``split()`` "
"підтримує необов'язковий параметр \"sep\", який корисний, якщо в рядку як "
"роздільник використовується щось інше, ніж пробіли."

msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's :c:func:`sscanf` and better suited for the task."
msgstr ""
"Для складнішого синтаксичного аналізу введення регулярні вирази є "
"потужнішими, ніж :c:func:`sscanf` і краще підходять для цього завдання."

msgid "What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?"
msgstr "Що означає помилка \"UnicodeDecodeError\" або \"UnicodeEncodeError\"?"

msgid "See the :ref:`unicode-howto`."
msgstr "Перегляньте :ref:`unicode-howto`."

msgid "Performance"
msgstr "Продуктивність"

msgid "My program is too slow. How do I speed it up?"
msgstr "Моя програма надто повільна. Як це прискорити?"

msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Загалом, це важко. По-перше, ось список речей, які слід запам’ятати перед "
"подальшим зануренням:"

msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"Характеристики продуктивності відрізняються в різних реалізаціях Python. Цей "
"FAQ присвячений :term:`CPython`."

msgid ""
"Behaviour can vary across operating systems, especially when talking about I/"
"O or multi-threading."
msgstr ""
"Поведінка може відрізнятися в різних операційних системах, особливо коли "
"мова йде про введення-виведення або багатопотоковість."

msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Ви завжди повинні знаходити гарячі точки у своїй програмі *перед* спробою "
"оптимізувати будь-який код (дивіться модуль :mod:`profile`)."

msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Написання тестових сценаріїв дозволить вам швидко виконувати ітерації під "
"час пошуку покращень (дивіться модуль :mod:`timeit`)."

msgid ""
"It is highly recommended to have good code coverage (through unit testing or "
"any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"Настійно рекомендується добре охопити код (через модульне тестування або "
"будь-яку іншу техніку), перш ніж потенційно вводити регресії, приховані в "
"складних оптимізаціях."

msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"З огляду на це, існує багато прийомів, щоб пришвидшити код Python. Ось "
"кілька загальних принципів, які допоможуть досягти прийнятного рівня "
"продуктивності:"

msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"Пришвидшення ваших алгоритмів (або заміна на швидші) може дати набагато "
"більші переваги, ніж спроба розсипати трюки мікрооптимізації по всьому коду."

msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Використовуйте правильні структури даних. Навчальна документація для "
"модулів :ref:`bltin-types` і :mod:`collections`."

msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the :"
"meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"Коли стандартна бібліотека надає примітив для виконання чогось, швидше за "
"все (хоча це не гарантовано) буде швидше, ніж будь-яка альтернатива, яку ви "
"можете придумати. Це подвійно вірно для примітивів, написаних на C, таких як "
"вбудовані модулі та деякі типи розширень. Наприклад, обов’язково "
"використовуйте або вбудований метод :meth:`list.sort`, або пов’язану "
"функцію :func:`sorted` для виконання сортування (і перегляньте :ref:"
"`sortinghowto` для прикладів помірно просунутого використання )."

msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done, "
"your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often "
"detrimental to readability)."
msgstr ""
"Абстракції, як правило, створюють непрямість і змушують перекладача "
"працювати більше. Якщо рівень опосередкованості переважає обсяг виконаної "
"корисної роботи, ваша програма працюватиме повільніше. Вам слід уникати "
"надмірної абстракції, особливо у формі крихітних функцій або методів (які "
"також часто шкодять читабельності)."

msgid ""
"If you have reached the limit of what pure Python can allow, there are tools "
"to take you further away.  For example, `Cython <http://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Якщо ви досягли межі того, що може дозволити чистий Python, є інструменти, "
"які допоможуть вам у цьому. Наприклад, `Cython <http://cython.org>`_ може "
"скомпілювати дещо змінену версію коду Python у розширення C і може "
"використовуватися на багатьох різних платформах. Cython може скористатися "
"компіляцією (і необов’язковими анотаціями типу), щоб зробити ваш код значно "
"швидшим, ніж інтерпретований. Якщо ви впевнені у своїх навичках "
"програмування на C, ви також можете :ref:`написати модуль розширення C "
"<extending-index>` самостійно."

msgid ""
"The wiki page devoted to `performance tips <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."
msgstr ""
"Вікі-сторінка, присвячена `порадам щодо продуктивності <https://wiki.python."
"org/moin/PythonSpeed/PerformanceTips>`_."

msgid "What is the most efficient way to concatenate many strings together?"
msgstr "Який найефективніший спосіб об’єднати багато рядків?"

msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
"Об’єкти :class:`str` і :class:`bytes` є незмінними, тому конкатенація "
"багатьох рядків разом неефективна, оскільки кожна конкатенація створює новий "
"об’єкт. У загальному випадку загальна вартість виконання є квадратичною щодо "
"загальної довжини рядка."

msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"Щоб накопичити багато об’єктів :class:`str`, рекомендована ідіома полягає в "
"тому, щоб помістити їх у список і викликати :meth:`str.join` в кінці::"

msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr "(іншою досить ефективною ідіомою є використання :class:`io.StringIO`)"

msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"Щоб накопичити багато об’єктів :class:`bytes`, рекомендована ідіома полягає "
"в тому, щоб розширити об’єкт :class:`bytearray` за допомогою конкатенації на "
"місці (оператор ``+=``):"

msgid "Sequences (Tuples/Lists)"
msgstr "Послідовності (кортежі/списки)"

msgid "How do I convert between tuples and lists?"
msgstr "Як конвертувати між кортежами та списками?"

msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"Конструктор типу ``tuple(seq)`` перетворює будь-яку послідовність (фактично, "
"будь-яку ітерацію) у кортеж з тими самими елементами в тому самому порядку."

msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Наприклад, ``tuple([1, 2, 3])`` дає ``(1, 2, 3)``, ``tuple('abc')`` дає "
"``('a', 'b ', 'c')``. Якщо аргумент є кортежем, він не створює копію, а "
"повертає той самий об’єкт, тому дешево викликати :func:`tuple`, коли ви не "
"впевнені, що об’єкт уже є кортежем."

msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"Конструктор типу ``list(seq)`` перетворює будь-яку послідовність або "
"ітерацію в список з тими самими елементами в тому самому порядку. Наприклад, "
"``list((1, 2, 3))`` дає ``[1, 2, 3]``, а ``list('abc')`` дає ``['a', 'b ', "
"'c']``. Якщо аргумент є списком, він створює копію так само, як ``seq[:]``."

msgid "What's a negative index?"
msgstr "Що таке негативний індекс?"

msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Послідовності Python індексуються позитивними та негативними числами. Для "
"додатних чисел 0 є першим індексом, 1 є другим індексом і так далі. Для "
"негативних індексів -1 є останнім індексом, а -2 є передостаннім "
"(передостаннім) індексом і так далі. Подумайте про ``seq[-n]`` як про те "
"саме, що ``seq[len(seq)-n]``."

msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"Використання від’ємних індексів може бути дуже зручним. Наприклад, "
"``S[:-1]`` — це весь рядок, за винятком останнього символу, який корисний "
"для видалення кінцевого символу нового рядка з рядка."

msgid "How do I iterate over a sequence in reverse order?"
msgstr "Як мені виконати ітерацію по послідовності у зворотному порядку?"

msgid "Use the :func:`reversed` built-in function::"
msgstr "Використовуйте вбудовану функцію :func:`reversed`::"

msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Це не торкнеться вашої оригінальної послідовності, але створить нову копію "
"зі зворотним порядком повторення."

msgid "How do you remove duplicates from a list?"
msgstr "Як видалити дублікати зі списку?"

msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"Перегляньте кулінарну книгу Python для довгого обговорення багатьох способів "
"зробити це:"

msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of "
"the list, deleting duplicates as you go::"
msgstr ""
"Якщо ви не проти змінити порядок списку, відсортуйте його, а потім скануйте "
"з кінця списку, видаляючи дублікати по ходу::"

msgid ""
"If all elements of the list may be used as set keys (i.e. they are all :term:"
"`hashable`) this is often faster ::"
msgstr ""
"Якщо всі елементи списку можна використовувати як набір ключів (тобто всі "
"вони :term:`hashable`), це часто швидше ::"

msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Це перетворює список на набір, таким чином видаляючи дублікати, а потім "
"знову на список."

msgid "How do you remove multiple items from a list"
msgstr "Як видалити кілька елементів зі списку"

msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice "
"replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Як і у випадку з видаленням дублікатів, явне повторення у зворотному порядку "
"з умовою видалення є однією з можливостей. Однак простіше і швидше "
"використовувати заміну фрагмента з неявною або явною прямою ітерацією. Ось "
"три варіації::"

msgid "The list comprehension may be fastest."
msgstr "Розуміння списку може бути найшвидшим."

msgid "How do you make an array in Python?"
msgstr "Як створити масив у Python?"

msgid "Use a list::"
msgstr "Використовуйте список::"

msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"За часовою складністю списки еквівалентні масивам C або Pascal; основна "
"відмінність полягає в тому, що список Python може містити об’єкти багатьох "
"різних типів."

msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that NumPy and other third party packages define array-"
"like structures with various characteristics as well."
msgstr ""
"Модуль ``array`` також надає методи для створення масивів фіксованих типів "
"із компактним представленням, але вони повільніші для індексування, ніж "
"списки. Також зауважте, що NumPy та інші пакунки сторонніх розробників також "
"визначають масивоподібні структури з різними характеристиками."

msgid ""
"To get Lisp-style linked lists, you can emulate cons cells using tuples::"
msgstr ""
"Щоб отримати пов’язані списки у стилі Lisp, ви можете емулювати комірки "
"мінусів за допомогою кортежів::"

msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of lisp car is ``lisp_list[0]`` and the analogue of cdr is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Якщо потрібна змінність, ви можете використовувати списки замість кортежів. "
"Тут аналогом lisp car є ``lisp_list[0]``, а аналогом cdr є ``lisp_list[1]``. "
"Робіть це, лише якщо ви впевнені, що вам це дійсно потрібно, тому що "
"зазвичай це набагато повільніше, ніж використання списків Python."

msgid "How do I create a multidimensional list?"
msgstr "Як створити багатовимірний список?"

msgid "You probably tried to make a multidimensional array like this::"
msgstr ""
"Можливо, ви намагалися створити багатовимірний масив, подібний до цього:"

msgid "This looks correct if you print it:"
msgstr "Це виглядає правильно, якщо ви його надрукуєте:"

msgid "But when you assign a value, it shows up in multiple places:"
msgstr ""
"Але коли ви призначаєте значення, воно відображається в кількох місцях:"

msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"Причина полягає в тому, що реплікація списку з ``*`` не створює копії, а "
"лише створює посилання на існуючі об’єкти. ``*3`` створює список, що містить "
"3 посилання на той самий список довжиною два. Зміни в одному рядку "
"відображатимуться в усіх рядках, що майже напевно не те, що ви хочете."

msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"Пропонований підхід полягає в тому, щоб спочатку створити список потрібної "
"довжини, а потім заповнити кожен елемент новоствореним списком::"

msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Це генерує список, що містить 3 різні списки довжиною два. Ви також можете "
"використовувати розуміння списку:"

msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy <http://"
"www.numpy.org/>`_ is the best known."
msgstr ""
"Або ви можете використовувати розширення, яке надає тип даних матриці; "
"`NumPy <http://www.numpy.org/>`_ є найвідомішим."

msgid "How do I apply a method to a sequence of objects?"
msgstr "Як застосувати метод до послідовності об’єктів?"

msgid "Use a list comprehension::"
msgstr "Використовуйте розуміння списку::"

msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"Чому a_tuple[i] += ['item'] викликає виключення, коли додавання працює?"

msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and "
"immutable objects in Python."
msgstr ""
"Це пояснюється поєднанням того факту, що розширені оператори присвоєння є "
"операторами *присвоєння*, а також різниці між змінними та незмінними "
"об’єктами в Python."

msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Це обговорення загалом стосується випадків, коли розширені оператори "
"присвоєння застосовуються до елементів кортежу, які вказують на змінні "
"об’єкти, але ми будемо використовувати ``list`` і ``+=`` як наш приклад."

msgid "If you wrote::"
msgstr "Якщо ви написали::"

msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"Причина винятку має бути зрозуміла одразу: ``1`` додається до об’єкта "
"``a_tuple[0]``, що вказує на (``1``), створюючи об’єкт результату ``2``, але "
"коли ми намагаємося призначити результат обчислення, ``2``, елементу ``0`` "
"кортежу, ми отримуємо помилку, оскільки ми не можемо змінити те, на що "
"вказує елемент кортежу."

msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"Під обкладинками цей доповнений оператор присвоєння робить приблизно "
"наступне:"

msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Саме частина операції присвоєння створює помилку, оскільки кортеж є "
"незмінним."

msgid "When you write something like::"
msgstr "Коли ви пишете щось на зразок::"

msgid ""
"The exception is a bit more surprising, and even more surprising is the fact "
"that even though there was an error, the append worked::"
msgstr ""
"Виняток є трохи більш дивним, і ще більш дивним є той факт, що, незважаючи "
"на помилку, додаток працював:"

msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an ``__iadd__`` magic method, it gets called when the ``+=`` augmented "
"assignment is executed, and its return value is what gets used in the "
"assignment statement; and (b) for lists, ``__iadd__`` is equivalent to "
"calling ``extend`` on the list and returning the list.  That's why we say "
"that for lists, ``+=`` is a \"shorthand\" for ``list.extend``::"
msgstr ""
"Щоб зрозуміти, чому це відбувається, вам потрібно знати, що (а) якщо об’єкт "
"реалізує чарівний метод ``__iadd__``, він викликається, коли виконується "
"доповнене призначення ``+=``, і його значення, що повертається, є тим, що "
"отримує використовується в заяві про призначення; і (b) для списків "
"``__iadd__`` еквівалентно виклику ``extend`` для списку та поверненню "
"списку. Ось чому ми говоримо, що для списків ``+=`` є \"скороченим\" для "
"``list.extend``::"

msgid "This is equivalent to::"
msgstr "Це еквівалентно::"

msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"Об’єкт, на який вказує a_list, було змінено, і вказівник на змінений об’єкт "
"знову призначено ``a_list``. Кінцевим результатом призначення є no-op, "
"оскільки це вказівник на той самий об’єкт, на який раніше вказував "
"``a_list``, але призначення все одно відбувається."

msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr ""
"Таким чином, у нашому прикладі кортежу те, що відбувається, еквівалентно::"

msgid ""
"The ``__iadd__`` succeeds, and thus the list is extended, but even though "
"``result`` points to the same object that ``a_tuple[0]`` already points to, "
"that final assignment still results in an error, because tuples are "
"immutable."
msgstr ""
"``__iadd__`` виконується успішно, і таким чином список розширюється, але "
"навіть якщо ``result`` вказує на той самий об’єкт, на який уже вказує "
"``a_tuple[0]``, остаточне призначення все одно призводить до помилки, тому "
"що кортежі незмінні."

msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Я хочу зробити складне сортування: чи можете ви виконати перетворення Шварца "
"в Python?"

msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"Техніка, яку приписують Рендалу Шварцу зі спільноти Perl, сортує елементи "
"списку за метрикою, яка відображає кожен елемент на його \"значення "
"сортування\". У Python використовуйте аргумент ``key`` для методу :meth:"
"`list.sort`::"

msgid "How can I sort one list by values from another list?"
msgstr "Як я можу сортувати один список за значеннями з іншого списку?"

msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Об’єднайте їх у ітератор кортежів, відсортуйте отриманий список, а потім "
"виберіть потрібний елемент. ::"

msgid "Objects"
msgstr "Об'єкти"

msgid "What is a class?"
msgstr "Що таке клас?"

msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"Клас — це окремий тип об’єкта, створений шляхом виконання оператора класу. "
"Об’єкти класу використовуються як шаблони для створення об’єктів "
"екземплярів, які втілюють як дані (атрибути), так і код (методи), специфічні "
"для типу даних."

msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"Клас може базуватися на одному або кількох інших класах, які називаються "
"базовими класами. Потім він успадковує атрибути та методи своїх базових "
"класів. Це дозволяє послідовно вдосконалювати об’єктну модель шляхом "
"успадкування. У вас може бути загальний клас ``Поштова скринька``, який "
"надає основні методи доступу до поштової скриньки, і підкласи, такі як "
"``MboxMailbox``, ``MaildirMailbox``, ``OutlookMailbox``, які обробляють "
"різні конкретні формати поштових скриньок."

msgid "What is a method?"
msgstr "Що таке метод?"

msgid ""
"A method is a function on some object ``x`` that you normally call as ``x."
"name(arguments...)``.  Methods are defined as functions inside the class "
"definition::"
msgstr ""
"Метод — це функція для деякого об’єкта ``x``, який зазвичай викликається як "
"``x.name(arguments...)``. Методи визначаються як функції всередині "
"визначення класу::"

msgid "What is self?"
msgstr "Що таке себе?"

msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, "
"c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self — це просто умовна назва для першого аргументу методу. Метод, "
"визначений як ``meth(self, a, b, c)``, слід викликати як ``x.meth(a, b, c)`` "
"для деякого екземпляра ``x`` класу, в якому відбувається визначення; "
"викликаний метод вважатиме, що він викликається як ``meth(x, a, b, c)``."

msgid "See also :ref:`why-self`."
msgstr "Дивіться також :ref:`why-self`."

msgid ""
"How do I check if an object is an instance of a given class or of a subclass "
"of it?"
msgstr ""
"Як перевірити, чи є об’єкт екземпляром заданого класу чи його підкласу?"

msgid ""
"Use the built-in function ``isinstance(obj, cls)``.  You can check if an "
"object is an instance of any of a number of classes by providing a tuple "
"instead of a single class, e.g. ``isinstance(obj, (class1, class2, ...))``, "
"and can also check whether an object is one of Python's built-in types, e.g. "
"``isinstance(obj, str)`` or ``isinstance(obj, (int, float, complex))``."
msgstr ""
"Використовуйте вбудовану функцію ``isinstance(obj, cls)``. Ви можете "
"перевірити, чи є об’єкт екземпляром будь-якого з кількох класів, надавши "
"кортеж замість одного класу, наприклад. ``isinstance(obj, (class1, "
"class2, ...))``, а також може перевірити, чи є об’єкт одним із вбудованих "
"типів Python, напр. ``isinstance(obj, str)`` або ``isinstance(obj, (int, "
"float, complex))``."

msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an :"
"term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Зауважте, що :func:`isinstance` також перевіряє віртуальне успадкування від :"
"term:`abstract base class`. Таким чином, тест поверне ``True`` для "
"зареєстрованого класу, навіть якщо він прямо чи опосередковано не успадкував "
"його. Щоб перевірити \"справжнє успадкування\", проскануйте :term:`MRO` "
"класу:"

msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Зауважте, що більшість програм не дуже часто використовують :func:"
"`isinstance` у визначених користувачем класах. Якщо ви розробляєте класи "
"самостійно, більш правильним об’єктно-орієнтованим стилем є визначення "
"методів у класах, які інкапсулюють конкретну поведінку, замість перевірки "
"класу об’єкта та виконання інших дій на основі того, який це клас. "
"Наприклад, якщо у вас є функція, яка щось робить:"

msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Кращий підхід полягає в тому, щоб визначити метод ``search()`` для всіх "
"класів і просто викликати його::"

msgid "What is delegation?"
msgstr "Що таке делегування?"

msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all "
"other methods to the corresponding method of ``x``."
msgstr ""
"Делегування — це об’єктно-орієнтована техніка (яка також називається "
"шаблоном проектування). Припустімо, у вас є об’єкт ``x`` і ви хочете змінити "
"поведінку лише одного з його методів. Ви можете створити новий клас, який "
"забезпечує нову реалізацію методу, який ви хочете змінити, і делегує всі "
"інші методи відповідному методу ``x``."

msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all "
"written data to uppercase::"
msgstr ""
"Програмісти на Python можуть легко реалізувати делегування. Наприклад, "
"наступний клас реалізує клас, який поводиться як файл, але перетворює всі "
"записані дані у верхній регістр:"

msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying ``self._outfile."
"write()`` method.  All other methods are delegated to the underlying ``self."
"_outfile`` object.  The delegation is accomplished via the ``__getattr__`` "
"method; consult :ref:`the language reference <attribute-access>` for more "
"information about controlling attribute access."
msgstr ""
"Тут клас ``UpperOut`` перевизначає метод ``write()`` для перетворення рядка "
"аргументу у верхній регістр перед викликом основного методу ``self._outfile."
"write()``. Усі інші методи делегуються базовому об’єкту ``self._outfile``. "
"Делегування виконується за допомогою методу ``__getattr__``; зверніться до :"
"ref:`мовної довідки <attribute-access>`, щоб дізнатися більше про керування "
"доступом до атрибутів."

msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a :meth:"
"`__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Зауважте, що для більш загальних випадків делегування може виявитися "
"складнішим. Коли атрибути повинні бути встановлені, а також отримані, клас "
"також повинен визначити метод :meth:`__setattr__`, і він повинен робити це "
"обережно. Базова реалізація :meth:`__setattr__` приблизно еквівалентна "
"наступному:"

msgid ""
"Most :meth:`__setattr__` implementations must modify ``self.__dict__`` to "
"store local state for self without causing an infinite recursion."
msgstr ""
"Більшість реалізацій :meth:`__setattr__` повинні модифікувати ``self."
"__dict__``, щоб зберігати локальний стан для себе, не викликаючи "
"нескінченної рекурсії."

msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"Як викликати метод, визначений у базовому класі, з похідного класу, який "
"його розширює?"

msgid "Use the built-in :func:`super` function::"
msgstr "Використовуйте вбудовану функцію :func:`super`::"

msgid ""
"In the example, :func:`super` will automatically determine the instance from "
"which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"У прикладі :func:`super` автоматично визначатиме екземпляр, з якого його "
"було викликано (значення ``self``), шукатиме :term:`method resolution order` "
"(MRO) за допомогою ``type(self) ).__mro__`` і повертає наступний рядок після "
"``Derived`` у MRO: ``Base``."

msgid "How can I organize my code to make it easier to change the base class?"
msgstr "Як я можу організувати свій код, щоб полегшити зміну базового класу?"

msgid ""
"You could assign the base class to an alias and derive from the alias.  Then "
"all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Ви можете призначити базовий клас псевдоніму та отримати його від "
"псевдоніма. Тоді все, що вам потрібно змінити, це значення, присвоєне "
"псевдоніму. До речі, цей прийом також зручний, якщо ви хочете динамічно "
"(наприклад, залежно від наявності ресурсів) вирішувати, який базовий клас "
"використовувати. Приклад::"

msgid "How do I create static class data and static class methods?"
msgstr "Як створити статичні дані класу та статичні методи класу?"

msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"У Python підтримуються як статичні дані, так і статичні методи (у сенсі C++ "
"або Java)."

msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"Для статичних даних просто визначте атрибут класу. Щоб призначити нове "
"значення атрибуту, ви повинні явно використовувати ім’я класу в призначенні::"

msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` також посилається на ``C.count`` для будь-якого ``c`` такого, що "
"``isinstance(c, C)`` має місце, якщо не перевизначено самим ``c`` або "
"деякими на шляху пошуку базового класу від ``c.__class__`` назад до ``C``."

msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Застереження: у методі C призначення на кшталт ``self.count = 42`` створює "
"новий і непов’язаний екземпляр під назвою \"count\" у власному дикторі "
"``self``. Повторне прив’язування назви статичних даних класу має завжди "
"вказувати клас незалежно від того, чи знаходиться він у методі чи ні:"

msgid "Static methods are possible::"
msgstr "Можливі статичні методи:"

msgid ""
"However, a far more straightforward way to get the effect of a static method "
"is via a simple module-level function::"
msgstr ""
"Однак набагато більш простий спосіб отримати ефект статичного методу — це за "
"допомогою простої функції на рівні модуля::"

msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Якщо ваш код структурований таким чином, щоб визначити один клас (або тісно "
"пов’язану ієрархію класів) на модуль, це забезпечує бажану інкапсуляцію."

msgid "How can I overload constructors (or methods) in Python?"
msgstr "Як я можу перевантажити конструктори (або методи) у Python?"

msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"Ця відповідь фактично стосується всіх методів, але зазвичай це питання "
"виникає першим у контексті конструкторів."

msgid "In C++ you'd write"
msgstr "У C++ ви б написали"

msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"У Python ви повинні написати єдиний конструктор, який ловить усі випадки, "
"використовуючи аргументи за замовчуванням. Наприклад::"

msgid "This is not entirely equivalent, but close enough in practice."
msgstr "Це не зовсім еквівалентно, але досить близько на практиці."

msgid "You could also try a variable-length argument list, e.g. ::"
msgstr ""
"Ви також можете спробувати список аргументів змінної довжини, наприклад. ::"

msgid "The same approach works for all method definitions."
msgstr "Той самий підхід працює для всіх визначень методів."

msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr ""
"Я намагаюся використовувати __спам і отримую помилку про "
"_SomeClassName__спам."

msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Назви змінних із подвійним підкресленням на початку \"спотворені\", щоб "
"забезпечити простий, але ефективний спосіб визначення приватних змінних "
"класу. Будь-який ідентифікатор у формі ``__spam`` (принаймні два символи "
"підкреслення на початку, не більше одного символу підкреслення в кінці) "
"текстово замінюється на ``_classname__spam``, де ``classname`` є поточною "
"назвою класу з будь-якими початковими символами підкреслення."

msgid ""
"This doesn't guarantee privacy: an outside user can still deliberately "
"access the \"_classname__spam\" attribute, and private values are visible in "
"the object's ``__dict__``.  Many Python programmers never bother to use "
"private variable names at all."
msgstr ""
"Це не гарантує конфіденційності: зовнішній користувач усе ще може навмисно "
"отримати доступ до атрибута \"_classname__spam\", а приватні значення "
"відображаються в ``__dict__`` об’єкта. Багато програмістів на Python взагалі "
"ніколи не використовують приватні імена змінних."

msgid "My class defines __del__ but it is not called when I delete the object."
msgstr ""
"Мій клас визначає __del__, але він не викликається, коли я видаляю об’єкт."

msgid "There are several possible reasons for this."
msgstr "Для цього є кілька можливих причин."

msgid ""
"The del statement does not necessarily call :meth:`__del__` -- it simply "
"decrements the object's reference count, and if this reaches zero :meth:"
"`__del__` is called."
msgstr ""
"Інструкція del не обов’язково викликає :meth:`__del__` — вона просто зменшує "
"кількість посилань на об’єкт, і якщо вона досягає нуля, викликається :meth:"
"`__del__`."

msgid ""
"If your data structures contain circular links (e.g. a tree where each child "
"has a parent reference and each parent has a list of children) the reference "
"counts will never go back to zero.  Once in a while Python runs an algorithm "
"to detect such cycles, but the garbage collector might run some time after "
"the last reference to your data structure vanishes, so your :meth:`__del__` "
"method may be called at an inconvenient and random time. This is "
"inconvenient if you're trying to reproduce a problem. Worse, the order in "
"which object's :meth:`__del__` methods are executed is arbitrary.  You can "
"run :func:`gc.collect` to force a collection, but there *are* pathological "
"cases where objects will never be collected."
msgstr ""
"Якщо ваші структури даних містять циклічні зв’язки (наприклад, дерево, де "
"кожен дочірній елемент має батьківське посилання, а кожен батьківський "
"елемент має список дочірніх елементів), підрахунок посилань ніколи не "
"повернеться до нуля. Час від часу Python запускає алгоритм для виявлення "
"таких циклів, але збирач сміття може працювати через деякий час після "
"зникнення останнього посилання на вашу структуру даних, тому ваш метод :meth:"
"`__del__` може бути викликаний у незручний і випадковий час. Це незручно, "
"якщо ви намагаєтеся відтворити проблему. Гірше того, порядок, у якому "
"виконуються методи :meth:`__del__` об’єкта, є довільним. Ви можете "
"запустити :func:`gc.collect`, щоб примусово зібрати, але *бувають* "
"патологічні випадки, коли об’єкти ніколи не збираються."

msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects.  "
"Don't call :meth:`__del__` directly -- :meth:`__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than "
"once for the same object."
msgstr ""
"Незважаючи на збирач циклів, доцільно визначити явний метод ``close()`` для "
"об’єктів, який буде викликатися щоразу, коли ви закінчите з ними. Потім "
"метод close() може видалити атрибути, які посилаються на підоб’єкти. Не "
"викликайте :meth:`__del__` безпосередньо -- :meth:`__del__` має викликати "
"``close()``, а ``close()`` має переконатися, що його можна викликати кілька "
"разів для того самого об'єкт."

msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Іншим способом уникнути циклічних посилань є використання модуля :mod:"
"`weakref`, який дозволяє вам вказувати на об’єкти, не збільшуючи їх "
"кількість посилань. Деревоподібні структури даних, наприклад, повинні "
"використовувати слабкі посилання для своїх батьківських і братських посилань "
"(якщо вони їм потрібні!)."

msgid ""
"Finally, if your :meth:`__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Нарешті, якщо ваш метод :meth:`__del__` викликає виняток, у :data:`sys."
"stderr` друкується попереджувальне повідомлення."

msgid "How do I get a list of all instances of a given class?"
msgstr "Як отримати список усіх екземплярів певного класу?"

msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python не відстежує всі екземпляри класу (або вбудованого типу). Ви можете "
"запрограмувати конструктор класу для відстеження всіх екземплярів, "
"зберігаючи список слабких посилань на кожен екземпляр."

msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "Чому результат ``id()`` здається не унікальним?"

msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in "
"memory.  This is illustrated by this example:"
msgstr ""
"Вбудований :func:`id` повертає ціле число, яке гарантовано буде унікальним "
"протягом усього життя об’єкта. Оскільки в CPython це адреса пам’яті об’єкта, "
"часто трапляється так, що після видалення об’єкта з пам’яті наступний щойно "
"створений об’єкт розміщується в тій же позиції в пам’яті. Це проілюстровано "
"таким прикладом:"

msgid ""
"The two ids belong to different integer objects that are created before, and "
"deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"Два ідентифікатори належать до різних цілочисельних об’єктів, створених "
"раніше та видалених одразу після виконання виклику ``id()``. Щоб "
"переконатися, що об’єкти, чий ідентифікатор ви хочете перевірити, все ще "
"живі, створіть інше посилання на об’єкт:"

msgid "When can I rely on identity tests with the *is* operator?"
msgstr "Коли я можу покладатися на перевірку ідентичності з оператором *is*?"

msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"Оператор ``is`` перевіряє ідентичність об'єкта. Перевірка \"a is b\" "
"еквівалентна \"id(a) == id(b)\"."

msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are "
"usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"Найважливіша властивість перевірки ідентичності полягає в тому, що об’єкт "
"завжди ідентичний самому собі, ``a is a`` завжди повертає ``True``. Тести "
"ідентифікації зазвичай швидші, ніж тести рівності. І на відміну від тестів "
"на рівність, тести ідентичності гарантовано повертають логічне значення "
"``True`` або ``False``."

msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Однак тести на ідентичність можна *тільки* замінити на тести на рівність, "
"якщо ідентичність об’єкта забезпечена. Загалом існує три обставини, за яких "
"ідентичність гарантується:"

msgid ""
"1) Assignments create new names but do not change object identity.  After "
"the assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"1) Присвоєння створює нові імена, але не змінює ідентифікацію об’єкта. Після "
"присвоєння ``нове = старе`` гарантується, що ``нове є старим``."

msgid ""
"2) Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"2) Поміщення об’єкта в контейнер, який зберігає посилання на об’єкти, не "
"змінює ідентифікацію об’єкта. Після присвоєння списку ``s[0] = x`` "
"гарантується, що ``s[0] є x``."

msgid ""
"3) If an object is a singleton, it means that only one instance of that "
"object can exist.  After the assignments ``a = None`` and ``b = None``, it "
"is guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"3) Якщо об’єкт є єдиним, це означає, що може існувати лише один екземпляр "
"цього об’єкта. Після присвоєння ``a = None`` і ``b = None`` гарантується, що "
"``a є b``, оскільки ``None`` є єдиним елементом."

msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"У більшості інших обставин тести на ідентичність є недоцільними, а тести на "
"рівність є кращими. Зокрема, тести ідентичності не слід використовувати для "
"перевірки таких констант, як :class:`int` і :class:`str`, які не гарантовано "
"є одиночними:"

msgid "Likewise, new instances of mutable containers are never identical::"
msgstr ""
"Подібним чином нові екземпляри змінних контейнерів ніколи не бувають "
"ідентичними:"

msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"У коді стандартної бібліотеки ви побачите кілька загальних шаблонів для "
"правильного використання тестів ідентичності:"

msgid ""
"1) As recommended by :pep:`8`, an identity test is the preferred way to "
"check for ``None``.  This reads like plain English in code and avoids "
"confusion with other objects that may have boolean values that evaluate to "
"false."
msgstr ""
"1) Відповідно до рекомендацій :pep:`8`, тест ідентичності є кращим способом "
"перевірки ``None``. Це читається як звичайна англійська мова в коді та "
"дозволяє уникнути плутанини з іншими об’єктами, які можуть мати логічні "
"значення, які оцінюються як false."

msgid ""
"2) Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`::"
msgstr ""

msgid ""
"3) Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"3) Контейнерні реалізації іноді потребують доповнення тестів на рівність "
"тестами ідентичності. Це запобігає заплутанню коду такими об’єктами, як "
"``float('NaN')``, які не дорівнюють собі."

msgid ""
"For example, here is the implementation of :meth:`collections.abc.Sequence."
"__contains__`::"
msgstr ""
"Наприклад, ось реалізація :meth:`collections.abc.Sequence.__contains__`::"

msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"Як підклас може контролювати, які дані зберігаються в незмінному екземплярі?"

msgid ""
"When subclassing an immutable type, override the :meth:`__new__` method "
"instead of the :meth:`__init__` method.  The latter only runs *after* an "
"instance is created, which is too late to alter data in an immutable "
"instance."
msgstr ""
"Під час створення підкласу незмінного типу замініть метод :meth:`__new__` "
"замість методу :meth:`__init__`. Останній запускається лише *після* "
"створення екземпляра, що надто пізно для зміни даних у незмінному екземплярі."

msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr "Усі ці незмінні класи мають інший підпис, ніж їх батьківський клас:"

msgid "The classes can be used like this:"
msgstr "Класи можна використовувати так:"

msgid "How do I cache method calls?"
msgstr "Як кешувати виклики методів?"

msgid ""
"The two principal tools for caching methods are :func:`functools."
"cached_property` and :func:`functools.lru_cache`.  The former stores results "
"at the instance level and the latter at the class level."
msgstr ""
"Двома основними інструментами для методів кешування є :func:`functools."
"cached_property` і :func:`functools.lru_cache`. Перший зберігає результати "
"на рівні екземпляра, а другий — на рівні класу."

msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"Підхід *cached_property* працює лише з методами, які не приймають жодних "
"аргументів. Він не створює посилання на екземпляр. Кешований результат "
"методу зберігатиметься лише доти, доки екземпляр активний."

msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"Перевагою є те, що коли екземпляр більше не використовується, кешований "
"результат методу буде негайно опубліковано. Недоліком є те, що якщо "
"екземпляри накопичуються, накопичений метод теж буде результатом. Вони "
"можуть рости необмежено."

msgid ""
"The *lru_cache* approach works with methods that have hashable arguments.  "
"It creates a reference to the instance unless special efforts are made to "
"pass in weak references."
msgstr ""
"Підхід *lru_cache* працює з методами, які мають хешовані аргументи. Він "
"створює посилання на екземпляр, якщо не докладаються спеціальні зусилля для "
"передачі слабких посилань."

msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"Перевага найменш використовуваного алгоритму полягає в тому, що кеш "
"обмежений указаним *maxsize*. Недоліком є те, що екземпляри залишаються "
"активними, поки вони не вичерпаються з кешу або поки кеш не буде очищено."

msgid "This example shows the various techniques::"
msgstr "Цей приклад демонструє різні техніки:"

msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"Наведений вище приклад передбачає, що *station_id* ніколи не змінюється. "
"Якщо відповідні атрибути екземпляра є змінними, підхід *cached_property* не "
"може працювати, оскільки він не може виявити зміни в атрибутах."

msgid ""
"The *lru_cache* approach can be made to work, but the class needs to define "
"the *__eq__* and *__hash__* methods so the cache can detect relevant "
"attribute updates::"
msgstr ""

msgid "Modules"
msgstr "Модулі"

msgid "How do I create a .pyc file?"
msgstr "Як створити файл .pyc?"

msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for details.)"
msgstr ""
"Коли модуль імпортується вперше (або якщо вихідний файл змінився після "
"створення поточного скомпільованого файлу), файл ``.pyc``, що містить "
"скомпільований код, має бути створений у підкаталозі ``__pycache__`` "
"каталог, що містить файл ``.py``. Файл ``.pyc`` матиме назву файлу, яка "
"починається з тієї самої назви, що й файл ``.py``, і закінчується ``.pyc``, "
"із середнім компонентом, який залежить від конкретного ``python`` двійковий "
"файл, який його створив. (Докладніше див. :pep:`3147`.)"

msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"Однією з причин того, що файл ``.pyc`` може не бути створений, є проблема з "
"дозволами для каталогу, що містить вихідний файл, тобто неможливо створити "
"підкаталог ``__pycache__``. Це може статися, наприклад, якщо ви розробляєте "
"як один користувач, але запускаєте як інший, наприклад, якщо ви тестуєте за "
"допомогою веб-сервера."

msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python "
"has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"Якщо не встановлено змінну середовища :envvar:`PYTHONDONTWRITEBYTECODE`, "
"створення файлу .pyc відбувається автоматично, якщо ви імпортуєте модуль і "
"Python має можливість (дозволи, вільне місце тощо) створити ``__pycache__`` "
"підкаталог і записати скомпільований модуль у цей підкаталог."

msgid ""
"Running Python on a top level script is not considered an import and no ``."
"pyc`` will be created.  For example, if you have a top-level module ``foo."
"py`` that imports another module ``xyz.py``, when you run ``foo`` (by typing "
"``python foo.py`` as a shell command), a ``.pyc`` will be created for "
"``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"Запуск Python на сценарії верхнього рівня не вважається імпортом, і ``.pyc`` "
"не буде створено. Наприклад, якщо у вас є модуль верхнього рівня ``foo.py``, "
"який імпортує інший модуль ``xyz.py``, коли ви запускаєте ``foo`` (ввівши "
"``python foo.py`` як команду оболонки), для ``xyz`` буде створено ``.pyc``, "
"оскільки ``xyz`` імпортовано, але файл ``.pyc`` не буде створено для "
"``foo``, оскільки ``foo.py`` не імпортується."

msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a ``."
"pyc`` file for a module that is not imported -- you can, using the :mod:"
"`py_compile` and :mod:`compileall` modules."
msgstr ""
"Якщо вам потрібно створити файл ``.pyc`` для ``foo``, тобто створити файл ``."
"pyc`` для модуля, який не імпортується, ви можете, використовувати модулі :"
"mod:`py_compile` і :mod:`compileall`."

msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to "
"use the ``compile()`` function in that module interactively::"
msgstr ""
"Модуль :mod:`py_compile` може вручну скомпілювати будь-який модуль. Одним із "
"способів є використання функції ``compile()`` у цьому модулі в "
"інтерактивному режимі:"

msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter "
"``cfile``)."
msgstr ""
"Це запише ``.pyc`` до підкаталогу ``__pycache__`` в тому самому місці, що "
"``foo.py`` (або ви можете змінити це за допомогою додаткового параметра "
"``cfile``)."

msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"Ви також можете автоматично скомпілювати всі файли в каталозі або каталогах "
"за допомогою модуля :mod:`compileall`. Ви можете зробити це з підказки "
"оболонки, запустивши ``compileall.py`` і вказавши шлях до каталогу, що "
"містить файли Python для компіляції::"

msgid "How do I find the current module name?"
msgstr "Як знайти поточну назву модуля?"

msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"Модуль може дізнатися власну назву модуля, дивлячись на попередньо визначену "
"глобальну змінну ``__name__``. Якщо має значення ``'__main__``, програма "
"виконується як сценарій. Багато модулів, які зазвичай використовуються "
"шляхом їх імпорту, також забезпечують інтерфейс командного рядка або "
"самоперевірку та виконують цей код лише після перевірки ``__name__``::"

msgid "How can I have modules that mutually import each other?"
msgstr "Як я можу мати модулі, які взаємно імпортують один одного?"

msgid "Suppose you have the following modules:"
msgstr "Припустимо, у вас є такі модулі:"

msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

msgid "The problem is that the interpreter will perform the following steps:"
msgstr "Проблема полягає в тому, що перекладач виконуватиме наступні кроки:"

msgid "main imports ``foo``"
msgstr "основний імпорт ``foo``"

msgid "Empty globals for ``foo`` are created"
msgstr "Створюються порожні глобальні значення для ``foo``"

msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` компілюється та починає виконуватися"

msgid "``foo`` imports ``bar``"
msgstr "``foo`` імпортує ``bar``"

msgid "Empty globals for ``bar`` are created"
msgstr "Створено порожні глобали для ``bar``"

msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` компілюється та починає виконуватися"

msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` імпортує ``foo`` (що є безопераційним, оскільки вже існує модуль з "
"назвою ``foo``)"

msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"Механізм імпорту намагається прочитати ``foo_var`` з ``foo`` глобальних, щоб "
"встановити ``bar.foo_var = foo.foo_var``"

msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet "
"and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"Останній крок не вдається, оскільки Python ще не завершив інтерпретацію "
"``foo``, а глобальний словник символів для ``foo`` все ще порожній."

msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"Те ж саме відбувається, коли ви використовуєте ``import foo``, а потім "
"намагаєтесь отримати доступ ``foo.foo_var`` у глобальному коді."

msgid "There are (at least) three possible workarounds for this problem."
msgstr "Є (принаймні) три можливі способи вирішення цієї проблеми."

msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import ..."
"``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Гвідо ван Россум рекомендує уникати будь-якого використання ``from <module> "
"import ...`` і розміщувати весь код у функціях. Для ініціалізації глобальних "
"змінних і змінних класу слід використовувати лише константи або вбудовані "
"функції. Це означає, що все з імпортованого модуля посилається як "
"``<module> . <name>``."

msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Джим Роскінд пропонує виконувати кроки в такому порядку в кожному модулі:"

msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"експорт (глобальні елементи, функції та класи, яким не потрібні імпортовані "
"базові класи)"

msgid "``import`` statements"
msgstr "оператори ``імпорту``"

msgid ""
"active code (including globals that are initialized from imported values)."
msgstr ""
"активний код (включаючи глобальні значення, ініціалізовані з імпортованих "
"значень)."

msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"Ван Россуму не дуже подобається такий підхід, оскільки імпорт з’являється в "
"незнайомому місці, але він працює."

msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Матіас Урліхс рекомендує реструктуризувати ваш код, щоб рекурсивний імпорт "
"не був необхідним."

msgid "These solutions are not mutually exclusive."
msgstr "Ці рішення не є взаємовиключними."

msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') повертає <module 'x'> ; як я можу отримати z?"

msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Замість цього можна скористатися зручною функцією :func:`~importlib."
"import_module` з :mod:`importlib`::"

msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"Коли я редагую імпортований модуль і повторно імпортую його, зміни не "
"відображаються. чому це відбувається"

msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force "
"re-reading of a changed module, do this::"
msgstr ""
"З міркувань ефективності та узгодженості Python читає файл модуля лише під "
"час першого імпорту модуля. Якби цього не було, у програмі, що складається з "
"багатьох модулів, кожен з яких імпортує той самий базовий модуль, базовий "
"модуль аналізувався б і повторно аналізувався багато разів. Щоб примусово "
"перечитати змінений модуль, виконайте наступне:"

msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Попередження: ця техніка не є на 100% надійною. Зокрема, модулі, що містять "
"оператори типу ::"

msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"продовжить працювати зі старою версією імпортованих об'єктів. Якщо модуль "
"містить визначення класу, існуючі екземпляри класу *не* будуть оновлені для "
"використання нового визначення класу. Це може призвести до наступної "
"парадоксальної поведінки:"

msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of "
"the class objects::"
msgstr ""
"Природа проблеми стане зрозумілою, якщо ви роздрукуєте \"ідентичність\" "
"об’єктів класу:"
