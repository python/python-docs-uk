# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-05-19 14:13+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../distutils/examples.rst:5
msgid "Distutils Examples"
msgstr "Приклади Distutils"

#: ../../distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html"
" independently covers all of the relevant information currently included "
"here."
msgstr ""
"Цей документ зберігається лише до тих пір, поки документація ``setuptools`` "
"за адресою https://setuptools.readthedocs.io/en/latest/setuptools.html "
"окремо не охопить всю відповідну інформацію, яка зараз включена тут."

#: ../../distutils/examples.rst:9
msgid ""
"This chapter provides a number of basic examples to help get started with "
"distutils.  Additional information about using distutils can be found in the"
" Distutils Cookbook."
msgstr ""
"У цьому розділі наведено низку основних прикладів, які допоможуть розпочати "
"роботу з distutils. Додаткову інформацію про використання distutils можна "
"знайти в кулінарній книзі Distutils."

#: ../../distutils/examples.rst:16
msgid ""
"`Distutils Cookbook <https://wiki.python.org/moin/Distutils/Cookbook>`_"
msgstr ""
"`Кулінарна книга Distutils "
"<https://wiki.python.org/moin/Distutils/Cookbook>`_"

#: ../../distutils/examples.rst:17
msgid ""
"Collection of recipes showing how to achieve more control over distutils."
msgstr ""
"Збірка рецептів, які показують, як досягти більшого контролю над distutils."

#: ../../distutils/examples.rst:23
msgid "Pure Python distribution (by module)"
msgstr "Чистий дистрибутив Python (за модулями)"

#: ../../distutils/examples.rst:25
msgid ""
"If you're just distributing a couple of modules, especially if they don't "
"live in a particular package, you can specify them individually using the "
"``py_modules`` option in the setup script."
msgstr ""
"Якщо ви просто розповсюджуєте кілька модулів, особливо якщо вони не живуть в"
" окремому пакеті, ви можете вказати їх окремо за допомогою параметра "
"``py_modules`` у сценарії встановлення."

#: ../../distutils/examples.rst:29
msgid ""
"In the simplest case, you'll have two files to worry about: a setup script "
"and the single module you're distributing, :file:`foo.py` in this example::"
msgstr ""
"У найпростішому випадку вам доведеться потурбуватися про два файли: сценарій"
" встановлення та єдиний модуль, який ви розповсюджуєте, :file:`foo.py` у "
"цьому прикладі::"

#: ../../distutils/examples.rst:36
msgid ""
"(In all diagrams in this section, *<root>* will refer to the distribution "
"root directory.)  A minimal setup script to describe this situation would "
"be::"
msgstr ""
"(На всіх діаграмах у цьому розділі * <root> * посилатиметься на кореневий "
"каталог розповсюдження.) Мінімальний сценарій налаштування для опису цієї "
"ситуації буде таким:"

#: ../../distutils/examples.rst:45
msgid ""
"Note that the name of the distribution is specified independently with the "
"``name`` option, and there's no rule that says it has to be the same as the "
"name of the sole module in the distribution (although that's probably a good"
" convention to follow).  However, the distribution name is used to generate "
"filenames, so you should stick to letters, digits, underscores, and hyphens."
msgstr ""
"Зауважте, що ім’я дистрибутива вказується окремо за допомогою параметра "
"``name``, і немає правила, яке б стверджувало, що воно має бути таким самим,"
" як ім’я єдиного модуля в дистрибутиві (хоча це, ймовірно, гарна угода, якої"
" слід дотримуватися ). Однак ім’я дистрибутива використовується для "
"генерування імен файлів, тому ви повинні дотримуватися літер, цифр, символів"
" підкреслення та дефісів."

#: ../../distutils/examples.rst:51
msgid ""
"Since ``py_modules`` is a list, you can of course specify multiple modules, "
"eg. if you're distributing modules :mod:`foo` and :mod:`bar`, your setup "
"might look like this::"
msgstr ""
"Оскільки ``py_modules`` є списком, ви, звичайно, можете вказати декілька "
"модулів, наприклад. якщо ви розповсюджуєте модулі :mod:`foo` і :mod:`bar`, "
"ваші налаштування можуть виглядати так:"

#: ../../distutils/examples.rst:60
msgid "and the setup script might be  ::"
msgstr "і сценарій налаштування може бути таким:"

#: ../../distutils/examples.rst:68
msgid ""
"You can put module source files into another directory, but if you have "
"enough modules to do that, it's probably easier to specify modules by "
"package rather than listing them individually."
msgstr ""
"Ви можете помістити вихідні файли модуля в інший каталог, але якщо у вас "
"достатньо модулів для цього, можливо, простіше вказати модулі за пакетом, а "
"не перераховувати їх окремо."

#: ../../distutils/examples.rst:76
msgid "Pure Python distribution (by package)"
msgstr "Чистий дистрибутив Python (за пакетом)"

#: ../../distutils/examples.rst:78
msgid ""
"If you have more than a couple of modules to distribute, especially if they "
"are in multiple packages, it's probably easier to specify whole packages "
"rather than individual modules.  This works even if your modules are not in "
"a package; you can just tell the Distutils to process modules from the root "
"package, and that works the same as any other package (except that you don't"
" have to have an :file:`__init__.py` file)."
msgstr ""
"Якщо у вас є кілька модулів для розповсюдження, особливо якщо вони містяться"
" в кількох пакетах, можливо, простіше вказати цілі пакети, а не окремі "
"модулі. Це працює, навіть якщо ваші модулі не в пакеті; ви можете просто "
"сказати Distutils обробляти модулі з кореневого пакета, і це працює так "
"само, як і будь-який інший пакет (за винятком того, що вам не обов’язково "
"мати файл :file:`__init__.py`)."

#: ../../distutils/examples.rst:85
msgid "The setup script from the last example could also be written as  ::"
msgstr "Сценарій налаштування з останнього прикладу також можна записати як::"

#: ../../distutils/examples.rst:93
msgid "(The empty string stands for the root package.)"
msgstr "(Порожній рядок означає кореневий пакет.)"

#: ../../distutils/examples.rst:95
msgid ""
"If those two files are moved into a subdirectory, but remain in the root "
"package, e.g.::"
msgstr ""
"Якщо ці два файли переміщуються до підкаталогу, але залишаються в кореневому"
" пакеті, наприклад::"

#: ../../distutils/examples.rst:103
msgid ""
"then you would still specify the root package, but you have to tell the "
"Distutils where source files in the root package live::"
msgstr ""
"тоді ви все одно вкажете кореневий пакет, але ви повинні повідомити "
"Distutils, де знаходяться вихідні файли в кореневому пакеті::"

#: ../../distutils/examples.rst:113
msgid ""
"More typically, though, you will want to distribute multiple modules in the "
"same package (or in sub-packages).  For example, if the :mod:`foo`  and "
":mod:`bar` modules belong in package :mod:`foobar`, one way to layout your "
"source tree is ::"
msgstr ""
"Однак зазвичай ви захочете поширювати кілька модулів в одному пакеті (або в "
"підпакетах). Наприклад, якщо модулі :mod:`foo` і :mod:`bar` належать до "
"пакета :mod:`foobar`, одним зі способів компонування дерева вихідних кодів "
"є:"

#: ../../distutils/examples.rst:125
msgid ""
"This is in fact the default layout expected by the Distutils, and the one "
"that requires the least work to describe in your setup script::"
msgstr ""
"Насправді це макет за замовчуванням, очікуваний Distutils, і той, який "
"вимагає найменшої роботи для опису у вашому сценарії налаштування::"

#: ../../distutils/examples.rst:134
msgid ""
"If you want to put modules in directories not named for their package, then "
"you need to use the ``package_dir`` option again.  For example, if the "
":file:`src` directory holds modules in the :mod:`foobar` package::"
msgstr ""
"Якщо ви бажаєте розмістити модулі в каталогах, не названих відповідно до "
"їхнього пакета, вам потрібно знову використати опцію ``package_dir``. "
"Наприклад, якщо каталог :file:`src` містить модулі в пакеті :mod:`foobar`:"

#: ../../distutils/examples.rst:145
msgid "an appropriate setup script would be  ::"
msgstr "відповідним сценарієм налаштування буде:"

#: ../../distutils/examples.rst:154
msgid ""
"Or, you might put modules from your main package right in the distribution "
"root::"
msgstr ""
"Або ви можете розмістити модулі з основного пакета прямо в корені "
"дистрибутива::"

#: ../../distutils/examples.rst:163
msgid "in which case your setup script would be  ::"
msgstr "у цьому випадку ваш сценарій налаштування буде таким:"

#: ../../distutils/examples.rst:172
msgid "(The empty string also stands for the current directory.)"
msgstr "(Порожній рядок також означає поточний каталог.)"

#: ../../distutils/examples.rst:174
msgid ""
"If you have sub-packages, they must be explicitly listed in ``packages``, "
"but any entries in ``package_dir`` automatically extend to sub-packages. (In"
" other words, the Distutils does *not* scan your source tree, trying to "
"figure out which directories correspond to Python packages by looking for "
":file:`__init__.py` files.)  Thus, if the default layout grows a sub-"
"package::"
msgstr ""
"Якщо у вас є підпакунки, їх потрібно явно вказати в ``packages``, але будь-"
"які записи в ``package_dir`` автоматично поширюються на підпакунки. (Іншими "
"словами, Distutils *не* сканує ваше дерево вихідних кодів, намагаючись "
"з’ясувати, які каталоги відповідають пакетам Python, шукаючи файли "
":file:`__init__.py`.) Таким чином, якщо макет за замовчуванням збільшує під-"
" пакет::"

#: ../../distutils/examples.rst:190
msgid "then the corresponding setup script would be  ::"
msgstr "тоді відповідний сценарій налаштування буде таким:"

#: ../../distutils/examples.rst:202
msgid "Single extension module"
msgstr "Один модуль розширення"

#: ../../distutils/examples.rst:204
msgid ""
"Extension modules are specified using the ``ext_modules`` option. "
"``package_dir`` has no effect on where extension source files are found; it "
"only affects the source for pure Python modules.  The simplest  case, a "
"single extension module in a single C source file, is::"
msgstr ""
"Модулі розширення вказуються за допомогою параметра ``ext_modules``. "
"``package_dir`` не впливає на те, де знаходяться вихідні файли розширення; "
"це впливає лише на джерело для чистих модулів Python. Найпростіший випадок, "
"один модуль розширення в одному вихідному файлі C, це:"

#: ../../distutils/examples.rst:213
msgid ""
"If the :mod:`foo` extension belongs in the root package, the setup script "
"for this could be  ::"
msgstr ""
"Якщо розширення :mod:`foo` належить кореневому пакету, сценарій налаштування"
" для цього може бути таким::"

#: ../../distutils/examples.rst:223
msgid ""
"If the extension actually belongs in a package, say :mod:`foopkg`, then"
msgstr "Якщо розширення насправді належить до пакета, скажіть :mod:`foopkg`"

#: ../../distutils/examples.rst:225
msgid ""
"With exactly the same source tree layout, this extension can be put in the "
":mod:`foopkg` package simply by changing the name of the extension::"
msgstr ""
"З таким же макетом вихідного дерева, це розширення можна помістити в пакет "
":mod:`foopkg`, просто змінивши назву розширення::"

#: ../../distutils/examples.rst:236
msgid "Checking a package"
msgstr "Перевірка посилки"

#: ../../distutils/examples.rst:238
msgid ""
"The ``check`` command allows you to verify if your package meta-data meet "
"the minimum requirements to build a distribution."
msgstr ""
"Команда ``check`` дозволяє вам перевірити, чи метадані вашого пакета "
"відповідають мінімальним вимогам для створення дистрибутива."

#: ../../distutils/examples.rst:241
msgid ""
"To run it, just call it using your :file:`setup.py` script. If something is "
"missing, ``check`` will display a warning."
msgstr ""
"Щоб запустити його, просто викличте його за допомогою свого сценарію "
":file:`setup.py`. Якщо чогось не вистачає, ``check`` відобразить "
"попередження."

#: ../../distutils/examples.rst:244
msgid "Let's take an example with a simple script::"
msgstr "Розглянемо приклад із простим скриптом::"

#: ../../distutils/examples.rst:250
msgid "Running the ``check`` command will display some warnings:"
msgstr "Виконання команди ``check`` відобразить деякі попередження:"

#: ../../distutils/examples.rst:261
msgid ""
"If you use the reStructuredText syntax in the ``long_description`` field and"
" `docutils`_  is installed you can check if the syntax is fine with the "
"``check`` command, using the ``restructuredtext`` option."
msgstr ""
"Якщо ви використовуєте синтаксис reStructuredText у полі "
"``long_description`` і `docutils`_ встановлено, ви можете перевірити, чи "
"синтаксис правильний за допомогою команди ``check``, використовуючи параметр"
" ``restructuredtext``."

#: ../../distutils/examples.rst:265
msgid "For example, if the :file:`setup.py` script is changed like this::"
msgstr "Наприклад, якщо сценарій :file:`setup.py` змінено таким чином:"

#: ../../distutils/examples.rst:280
msgid ""
"Where the long description is broken, ``check`` will be able to detect it by"
" using the :mod:`docutils` parser:"
msgstr ""
"Якщо довгий опис пошкоджено, ``check`` зможе виявити це за допомогою "
"аналізатора :mod:`docutils`:"

#: ../../distutils/examples.rst:291
msgid "Reading the metadata"
msgstr "Читання метаданих"

#: ../../distutils/examples.rst:293
msgid ""
"The :func:`distutils.core.setup` function provides a command-line interface "
"that allows you to query the metadata fields of a project through the "
"``setup.py`` script of a given project:"
msgstr ""
"Функція :func:`distutils.core.setup` забезпечує інтерфейс командного рядка, "
"який дозволяє запитувати поля метаданих проекту за допомогою сценарію "
"``setup.py`` даного проекту:"

#: ../../distutils/examples.rst:302
msgid ""
"This call reads the ``name`` metadata by running the "
":func:`distutils.core.setup`  function. Although, when a source or binary "
"distribution is created with Distutils, the metadata fields are written in a"
" static file called :file:`PKG-INFO`. When a Distutils-based project is "
"installed in Python, the :file:`PKG-INFO` file is copied alongside the "
"modules and packages of the distribution under :file:`NAME-VERSION-"
"pyX.X.egg-info`, where ``NAME`` is the name of the project, ``VERSION`` its "
"version as defined in the Metadata, and ``pyX.X`` the major and minor "
"version of Python like ``2.7`` or ``3.2``."
msgstr ""
"Цей виклик читає метадані ``name`` за допомогою функції "
":func:`distutils.core.setup`. Хоча, коли вихідний або бінарний дистрибутив "
"створюється за допомогою Distutils, поля метаданих записуються в статичний "
"файл під назвою :file:`PKG-INFO`. Коли проект на основі Distutils "
"інстальовано в Python, файл :file:`PKG-INFO` копіюється разом із модулями та"
" пакетами дистрибутива в :file:`NAME-VERSION-pyX.X.egg-info`, де ``NAME`` — "
"це назва проекту, ``VERSION`` — його версія, як визначено в метаданих, а "
"``pyX.X`` — основна та допоміжна версії Python, наприклад ``2.7`` або "
"``3.2``."

#: ../../distutils/examples.rst:312
msgid ""
"You can read back this static file, by using the "
":class:`distutils.dist.DistributionMetadata` class and its "
":func:`read_pkg_file` method::"
msgstr ""
"Ви можете прочитати цей статичний файл за допомогою класу "
":class:`distutils.dist.DistributionMetadata` та його методу "
":func:`read_pkg_file`::"

#: ../../distutils/examples.rst:326
msgid ""
"Notice that the class can also be instantiated with a metadata file path to "
"loads its values::"
msgstr ""
"Зауважте, що клас також може бути створений за допомогою шляху до файлу "
"метаданих для завантаження його значень:"
