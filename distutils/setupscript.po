# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Writing the Setup Script"
msgstr "Написання сценарію налаштування"

msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html "
"independently covers all of the relevant information currently included here."
msgstr ""
"Цей документ зберігається лише до тих пір, поки документація ``setuptools`` "
"за адресою https://setuptools.readthedocs.io/en/latest/setuptools.html "
"окремо не охопить всю відповідну інформацію, яка зараз включена тут."

msgid ""
"The setup script is the centre of all activity in building, distributing, "
"and installing modules using the Distutils.  The main purpose of the setup "
"script is to describe your module distribution to the Distutils, so that the "
"various commands that operate on your modules do the right thing.  As we saw "
"in section :ref:`distutils-simple-example` above, the setup script consists "
"mainly of a call to :func:`setup`, and most information supplied to the "
"Distutils by the module developer is supplied as keyword arguments to :func:"
"`setup`."
msgstr ""
"Сценарій встановлення є центром усієї діяльності зі створення, "
"розповсюдження та встановлення модулів за допомогою Distutils. Основна мета "
"сценарію налаштування — описати розповсюдження ваших модулів у Distutils, "
"щоб різні команди, що працюють із вашими модулями, працювали правильно. Як "
"ми бачили в розділі :ref:`distutils-simple-example` вище, сценарій "
"налаштування складається в основному з виклику :func:`setup`, і більшість "
"інформації, яку надає Distutils розробник модуля, надається як аргументи "
"ключового слова до :func:`setup`."

msgid ""
"Here's a slightly more involved example, which we'll follow for the next "
"couple of sections: the Distutils' own setup script.  (Keep in mind that "
"although the Distutils are included with Python 1.6 and later, they also "
"have an independent existence so that Python 1.5.2 users can use them to "
"install other module distributions.  The Distutils' own setup script, shown "
"here, is used to install the package into Python 1.5.2.) ::"
msgstr ""
"Ось трохи складніший приклад, який ми розглянемо в наступних кількох "
"розділах: власний сценарій налаштування Distutils. (Майте на увазі, що "
"незважаючи на те, що Distutils включено до Python 1.6 і пізніших версій, "
"вони також існують незалежно, тому користувачі Python 1.5.2 можуть "
"використовувати їх для встановлення інших дистрибутивів модулів. "
"Використовується власний сценарій налаштування Distutils, показаний тут щоб "
"інсталювати пакет у Python 1.5.2.) ::"

msgid ""
"There are only two differences between this and the trivial one-file "
"distribution presented in section :ref:`distutils-simple-example`: more "
"metadata, and the specification of pure Python modules by package, rather "
"than by module.  This is important since the Distutils consist of a couple "
"of dozen modules split into (so far) two packages; an explicit list of every "
"module would be tedious to generate and difficult to maintain.  For more "
"information on the additional meta-data, see section :ref:`meta-data`."
msgstr ""
"Існує лише дві відмінності між цим і тривіальним однофайловим розподілом, "
"представленим у розділі :ref:`distutils-simple-example`: більше метаданих і "
"специфікація чистих модулів Python за пакетом, а не за модулем. Це важливо, "
"оскільки Distutils складається з кількох десятків модулів, розділених на "
"(поки що) два пакети; явний список кожного модуля було б стомлюючим для "
"створення та важким для підтримки. Для отримання додаткової інформації про "
"додаткові метадані перегляньте розділ :ref:`meta-data`."

msgid ""
"Note that any pathnames (files or directories) supplied in the setup script "
"should be written using the Unix convention, i.e. slash-separated.  The "
"Distutils will take care of converting this platform-neutral representation "
"into whatever is appropriate on your current platform before actually using "
"the pathname.  This makes your setup script portable across operating "
"systems, which of course is one of the major goals of the Distutils.  In "
"this spirit, all pathnames in this document are slash-separated."
msgstr ""
"Зауважте, що будь-які імена шляхів (файлів або каталогів), надані в сценарії "
"встановлення, мають бути записані з використанням конвенції Unix, тобто "
"розділені рискою. Distutils подбає про перетворення цього нейтрального щодо "
"платформи представлення у те, що підходить для вашої поточної платформи, "
"перш ніж фактично використовувати шлях. Це робить ваш сценарій налаштування "
"переносимим між операційними системами, що, звичайно, є однією з головних "
"цілей Distutils. У цьому дусі всі назви шляхів у цьому документі розділені "
"косою рискою."

msgid ""
"This, of course, only applies to pathnames given to Distutils functions.  If "
"you, for example, use standard Python functions such as :func:`glob.glob` "
"or :func:`os.listdir` to specify files, you should be careful to write "
"portable code instead of hardcoding path separators::"
msgstr ""
"Звичайно, це стосується лише імен шляхів, наданих функціям Distutils. Якщо "
"ви, наприклад, використовуєте стандартні функції Python, такі як :func:`glob."
"glob` або :func:`os.listdir` для вказування файлів, вам слід бути "
"обережними, щоб писати портативний код замість жорсткого кодування "
"роздільників шляхів::"

msgid "Listing whole packages"
msgstr "Перелік цілих пакетів"

msgid ""
"The ``packages`` option tells the Distutils to process (build, distribute, "
"install, etc.) all pure Python modules found in each package mentioned in "
"the ``packages`` list.  In order to do this, of course, there has to be a "
"correspondence between package names and directories in the filesystem.  The "
"default correspondence is the most obvious one, i.e. package :mod:"
"`distutils` is found in the directory :file:`distutils` relative to the "
"distribution root. Thus, when you say ``packages = ['foo']`` in your setup "
"script, you are promising that the Distutils will find a file :file:`foo/"
"__init__.py` (which might be spelled differently on your system, but you get "
"the idea) relative to the directory where your setup script lives.  If you "
"break this promise, the Distutils will issue a warning but still process the "
"broken package anyway."
msgstr ""
"Параметр ``packages`` повідомляє Distutils обробляти (збирати, "
"розповсюджувати, інсталювати тощо) усі чисті модулі Python, знайдені в "
"кожному пакеті, згаданому у списку ``packages``. Для цього, звичайно, має "
"бути відповідність між назвами пакетів і каталогами у файловій системі. "
"Типова відповідність є найбільш очевидною, тобто пакунок :mod:`distutils` "
"знаходиться в каталозі :file:`distutils` відносно кореня дистрибутива. Таким "
"чином, коли ви кажете ``packages = ['foo']`` у вашому сценарії встановлення, "
"ви обіцяєте, що Distutils знайде файл :file:`foo/__init__.py` (який може "
"бути написаний інакше у вашій системі , але ви зрозуміли) відносно каталогу, "
"де знаходиться ваш сценарій налаштування. Якщо ви порушите цю обіцянку, "
"Distutils видасть попередження, але все одно обробить зламаний пакет."

msgid ""
"If you use a different convention to lay out your source directory, that's "
"no problem: you just have to supply the ``package_dir`` option to tell the "
"Distutils about your convention.  For example, say you keep all Python "
"source under :file:`lib`, so that modules in the \"root package\" (i.e., not "
"in any package at all) are in :file:`lib`, modules in the :mod:`foo` package "
"are in :file:`lib/foo`, and so forth.  Then you would put ::"
msgstr ""
"Якщо ви використовуєте іншу угоду для компонування вихідного каталогу, це не "
"проблема: вам просто потрібно вказати опцію ``package_dir``, щоб повідомити "
"Distutils про вашу угоду. Наприклад, припустимо, що ви зберігаєте всі "
"джерела Python у :file:`lib`, так що модулі в \"кореневому пакеті\" (тобто "
"не в будь-якому пакеті взагалі) знаходяться в :file:`lib`, а модулі в Пакет :"
"mod:`foo` міститься в :file:`lib/foo` і так далі. Тоді ви б поставили ::"

msgid ""
"in your setup script.  The keys to this dictionary are package names, and an "
"empty package name stands for the root package.  The values are directory "
"names relative to your distribution root.  In this case, when you say "
"``packages = ['foo']``, you are promising that the file :file:`lib/foo/"
"__init__.py` exists."
msgstr ""
"у вашому сценарії налаштування. Ключами до цього словника є імена пакетів, а "
"порожня назва пакета означає кореневий пакет. Значення – це імена каталогів "
"відносно кореня дистрибутива. У цьому випадку, коли ви кажете ``packages = "
"['foo']``, ви обіцяєте, що файл :file:`lib/foo/__init__.py` існує."

msgid ""
"Another possible convention is to put the :mod:`foo` package right in :file:"
"`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would be "
"written in the setup script as ::"
msgstr ""
"Іншою можливою угодою є розміщення пакета :mod:`foo` безпосередньо в :file:"
"`lib`, пакета :mod:`foo.bar` в :file:`lib/bar` тощо. Це буде написано в "
"сценарій налаштування як ::"

msgid ""
"A ``package: dir`` entry in the ``package_dir`` dictionary implicitly "
"applies to all packages below *package*, so the :mod:`foo.bar` case is "
"automatically handled here.  In this example, having ``packages = ['foo', "
"'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and :"
"file:`lib/bar/__init__.py`.  (Keep in mind that although ``package_dir`` "
"applies recursively, you must explicitly list all packages in ``packages``: "
"the Distutils will *not* recursively scan your source tree looking for any "
"directory with an :file:`__init__.py` file.)"
msgstr ""
"Запис ``package: dir`` у словнику ``package_dir`` неявно застосовується до "
"всіх пакунків нижче *package*, тому тут автоматично обробляється випадок :"
"mod:`foo.bar`. У цьому прикладі наявність ``packages = ['foo', 'foo.bar']`` "
"повідомляє Distutils шукати :file:`lib/__init__.py` і :file:`lib/bar/"
"__init__.py`. (Майте на увазі, що хоча ``package_dir`` застосовується "
"рекурсивно, ви повинні явно перерахувати всі пакунки в ``packages``: "
"Distutils *не* рекурсивно скануватиме ваше вихідне дерево в пошуках будь-"
"якого каталогу з :file:`__init__. py` файл.)"

msgid "Listing individual modules"
msgstr "Перелік окремих модулів"

msgid ""
"For a small module distribution, you might prefer to list all modules rather "
"than listing packages---especially the case of a single module that goes in "
"the \"root package\" (i.e., no package at all).  This simplest case was "
"shown in section :ref:`distutils-simple-example`; here is a slightly more "
"involved example::"
msgstr ""
"Для невеликого розповсюдження модулів ви можете віддати перевагу переліку "
"всіх модулів, а не переліку пакунків --- особливо у випадку окремого модуля, "
"який міститься в \"кореневому пакеті\" (тобто без пакета взагалі). Цей "
"найпростіший випадок було показано в розділі :ref:`distutils-simple-"
"example`; ось трохи складніший приклад::"

msgid ""
"This describes two modules, one of them in the \"root\" package, the other "
"in the :mod:`pkg` package.  Again, the default package/directory layout "
"implies that these two modules can be found in :file:`mod1.py` and :file:"
"`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And again, "
"you can override the package/directory correspondence using the "
"``package_dir`` option."
msgstr ""
"Це описує два модулі, один з них у кореневому пакеті, інший у пакеті :mod:"
"`pkg`. Знову ж таки, макет пакета/каталогу за замовчуванням означає, що ці "
"два модулі можна знайти в :file:`mod1.py` і :file:`pkg/mod2.py`, і що :file:"
"`pkg/__init__.py` існує так само. І знову ж таки, ви можете змінити "
"відповідність пакета/каталогу за допомогою параметра ``package_dir``."

msgid "Describing extension modules"
msgstr "Опис модулів розширення"

msgid ""
"Just as writing Python extension modules is a bit more complicated than "
"writing pure Python modules, describing them to the Distutils is a bit more "
"complicated. Unlike pure modules, it's not enough just to list modules or "
"packages and expect the Distutils to go out and find the right files; you "
"have to specify the extension name, source file(s), and any compile/link "
"requirements (include directories, libraries to link with, etc.)."
msgstr ""
"Подібно до того, як написання модулів розширення Python є дещо складнішим, "
"ніж написання чистих модулів Python, описувати їх у Distutils дещо "
"складніше. На відміну від чистих модулів, недостатньо просто перерахувати "
"модулі чи пакети й очікувати, що Distutils вийдуть і знайдуть потрібні "
"файли; ви повинні вказати ім’я розширення, вихідний(і) файл(и) та будь-які "
"вимоги до компіляції/посилання (включно з каталогами, бібліотеками для "
"зв’язування тощо)."

msgid ""
"All of this is done through another keyword argument to :func:`setup`, the "
"``ext_modules`` option.  ``ext_modules`` is just a list of :class:"
"`~distutils.core.Extension` instances, each of which describes a single "
"extension module. Suppose your distribution includes a single extension, "
"called :mod:`foo` and implemented by :file:`foo.c`.  If no additional "
"instructions to the compiler/linker are needed, describing this extension is "
"quite simple::"
msgstr ""
"Все це робиться за допомогою іншого ключового аргументу :func:`setup`, "
"параметра ``ext_modules``. ``ext_modules`` - це лише список екземплярів :"
"class:`~distutils.core.Extension`, кожен з яких описує окремий модуль "
"розширення. Припустімо, що ваш дистрибутив містить одне розширення, яке "
"називається :mod:`foo` і реалізоване :file:`foo.c`. Якщо додаткові "
"інструкції для компілятора/лінкера не потрібні, описати це розширення досить "
"просто:"

msgid ""
"The :class:`Extension` class can be imported from :mod:`distutils.core` "
"along with :func:`setup`.  Thus, the setup script for a module distribution "
"that contains only this one extension and nothing else might be::"
msgstr ""
"Клас :class:`Extension` можна імпортувати з :mod:`distutils.core` разом із :"
"func:`setup`. Таким чином, сценарій налаштування для розповсюдження модуля, "
"який містить лише це одне розширення і нічого іншого, може бути:"

msgid ""
"The :class:`Extension` class (actually, the underlying extension-building "
"machinery implemented by the :command:`build_ext` command) supports a great "
"deal of flexibility in describing Python extensions, which is explained in "
"the following sections."
msgstr ""
"Клас :class:`Extension` (фактично базовий механізм створення розширень, "
"реалізований командою :command:`build_ext`) підтримує велику гнучкість в "
"описі розширень Python, що пояснюється в наступних розділах."

msgid "Extension names and packages"
msgstr "Назви розширень і пакети"

msgid ""
"The first argument to the :class:`~distutils.core.Extension` constructor is "
"always the name of the extension, including any package names.  For "
"example, ::"
msgstr ""
"Першим аргументом конструктора :class:`~distutils.core.Extension` завжди є "
"ім’я розширення, включаючи будь-які імена пакетів. Наприклад, ::"

msgid "describes an extension that lives in the root package, while ::"
msgstr "описує розширення, яке знаходиться в кореневому пакеті, а ::"

msgid ""
"describes the same extension in the :mod:`pkg` package.  The source files "
"and resulting object code are identical in both cases; the only difference "
"is where in the filesystem (and therefore where in Python's namespace "
"hierarchy) the resulting extension lives."
msgstr ""
"описує те саме розширення в пакеті :mod:`pkg`. Вихідні файли та отриманий "
"об’єктний код ідентичні в обох випадках; єдина різниця полягає в тому, де у "
"файловій системі (і, отже, де в ієрархії простору імен Python) живе "
"результуюче розширення."

msgid ""
"If you have a number of extensions all in the same package (or all under the "
"same base package), use the ``ext_package`` keyword argument to :func:"
"`setup`.  For example, ::"
msgstr ""
"Якщо у вас є декілька розширень в одному пакеті (або всі в одному базовому "
"пакеті), використовуйте аргумент ключового слова ``ext_package`` для :func:"
"`setup`. Наприклад, ::"

msgid ""
"will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and :file:`bar."
"c` to :mod:`pkg.subpkg.bar`."
msgstr ""
"скомпілює :file:`foo.c` до розширення :mod:`pkg.foo`, а :file:`bar.c` до :"
"mod:`pkg.subpkg.bar`."

msgid "Extension source files"
msgstr "Вихідні файли розширення"

msgid ""
"The second argument to the :class:`~distutils.core.Extension` constructor is "
"a list of source files.  Since the Distutils currently only support C, C++, "
"and Objective-C extensions, these are normally C/C++/Objective-C source "
"files.  (Be sure to use appropriate extensions to distinguish C++ source "
"files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and "
"Windows compilers.)"
msgstr ""
"Другим аргументом конструктора :class:`~distutils.core.Extension` є список "
"вихідних файлів. Оскільки Distutils наразі підтримують лише розширення C, C+"
"+ і Objective-C, зазвичай це вихідні файли C/C++/Objective-C. (Обов’язково "
"використовуйте відповідні розширення, щоб розрізняти вихідні файли C++: :"
"file:`.cc` і :file:`.cpp`, здається, розпізнаються як компіляторами Unix, "
"так і Windows.)"

msgid ""
"However, you can also include SWIG interface (:file:`.i`) files in the list; "
"the :command:`build_ext` command knows how to deal with SWIG extensions: it "
"will run SWIG on the interface file and compile the resulting C/C++ file "
"into your extension."
msgstr ""
"Однак ви також можете включити файли інтерфейсу SWIG (:file:`.i`) до списку; "
"Команда :command:`build_ext` знає, як працювати з розширеннями SWIG: вона "
"запустить SWIG у файлі інтерфейсу та скомпілює отриманий файл C/C++ у ваше "
"розширення."

msgid ""
"This warning notwithstanding, options to SWIG can be currently passed like "
"this::"
msgstr ""
"Незважаючи на це попередження, наразі параметри для SWIG можна передати так:"

msgid "Or on the commandline like this::"
msgstr "Або в командному рядку так::"

msgid ""
"On some platforms, you can include non-source files that are processed by "
"the compiler and included in your extension.  Currently, this just means "
"Windows message text (:file:`.mc`) files and resource definition (:file:`."
"rc`) files for Visual C++. These will be compiled to binary resource (:file:"
"`.res`) files and linked into the executable."
msgstr ""
"На деяких платформах ви можете включити не вихідні файли, які оброблені "
"компілятором і включені у ваше розширення. Наразі це лише файли текстових "
"повідомлень Windows (:file:`.mc`) і файли визначення ресурсів (:file:`.rc`) "
"для Visual C++. Вони будуть скомпільовані у двійкові файли ресурсів (:file:`."
"res`) і пов’язані у виконуваний файл."

msgid "Preprocessor options"
msgstr "Опції препроцесора"

msgid ""
"Three optional arguments to :class:`~distutils.core.Extension` will help if "
"you need to specify include directories to search or preprocessor macros to "
"define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``."
msgstr ""
"Три необов’язкові аргументи для :class:`~distutils.core.Extension` "
"допоможуть, якщо вам потрібно вказати включати каталоги для пошуку або "
"макроси препроцесора для визначення/невизначення: ``include_dirs``, "
"``define_macros`` і ``undef_macros``."

msgid ""
"For example, if your extension requires header files in the :file:`include` "
"directory under your distribution root, use the ``include_dirs`` option::"
msgstr ""
"Наприклад, якщо ваше розширення потребує файлів заголовків у каталозі :file:"
"`include` у корені дистрибутива, використовуйте опцію ``include_dirs``::"

msgid ""
"You can specify absolute directories there; if you know that your extension "
"will only be built on Unix systems with X11R6 installed to :file:`/usr`, you "
"can get away with ::"
msgstr ""
"Там можна вказати абсолютні каталоги; якщо ви знаєте, що ваше розширення "
"буде побудовано лише на системах Unix із X11R6, встановленим у :file:`/usr`, "
"ви можете обійтися ::"

msgid ""
"You should avoid this sort of non-portable usage if you plan to distribute "
"your code: it's probably better to write C code like  ::"
msgstr ""
"Якщо ви плануєте розповсюджувати свій код, вам слід уникати такого "
"непортативного використання: ймовірно, краще писати код на C так::"

msgid ""
"If you need to include header files from some other Python extension, you "
"can take advantage of the fact that header files are installed in a "
"consistent way by the Distutils :command:`install_headers` command.  For "
"example, the Numerical Python header files are installed (on a standard Unix "
"installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact "
"location will differ according to your platform and Python installation.)  "
"Since the Python include directory---\\ :file:`/usr/local/include/python1.5` "
"in this case---is always included in the search path when building Python "
"extensions, the best approach is to write C code like  ::"
msgstr ""
"Якщо вам потрібно включити файли заголовків з іншого розширення Python, ви "
"можете скористатися тим фактом, що файли заголовків установлюються узгоджено "
"за допомогою команди Distutils :command:`install_headers`. Наприклад, "
"числові файли заголовків Python інсталюються (у стандартній установці Unix) "
"у :file:`/usr/local/include/python1.5/Numerical`. (Точне розташування буде "
"відрізнятися залежно від вашої платформи та інсталяції Python.) Оскільки "
"каталог включення Python---\\ :file:`/usr/local/include/python1.5` у цьому "
"випадку---завжди включається в Шлях пошуку під час створення розширень "
"Python найкращим підходом є написання коду C, наприклад::"

msgid ""
"If you must put the :file:`Numerical` include directory right into your "
"header search path, though, you can find that directory using the Distutils :"
"mod:`distutils.sysconfig` module::"
msgstr ""
"Якщо вам потрібно розмістити каталог :file:`Numerical` включення прямо в "
"шлях пошуку заголовка, ви можете знайти цей каталог за допомогою модуля "
"Distutils :mod:`distutils.sysconfig`::"

msgid ""
"Even though this is quite portable---it will work on any Python "
"installation, regardless of platform---it's probably easier to just write "
"your C code in the sensible way."
msgstr ""
"Незважаючи на те, що це досить портативно --- воно працюватиме на будь-якій "
"інсталяції Python, незалежно від платформи --- мабуть, легше просто написати "
"свій код на C розумним способом."

msgid ""
"You can define and undefine pre-processor macros with the ``define_macros`` "
"and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, "
"value)`` tuples, where ``name`` is the name of the macro to define (a "
"string) and ``value`` is its value: either a string or ``None``.  (Defining "
"a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in "
"your C source: with most compilers, this sets ``FOO`` to the string ``1``.)  "
"``undef_macros`` is just a list of macros to undefine."
msgstr ""
"Ви можете визначити та скасувати визначення макросів попередньої обробки за "
"допомогою параметрів ``define_macros`` і ``undef_macros``. ``define_macros`` "
"бере список кортежів ``(name, value)``, де ``name`` є назвою макросу для "
"визначення (рядок), а ``value`` є його значенням: або рядок або ``None``. "
"(Визначення макросу ``FOO`` як ``None`` є еквівалентом простого ``#define "
"FOO`` у вашому вихідному коді C: у більшості компіляторів це встановлює "
"``FOO`` у рядок ``1``.) ``undef_macros`` — це лише список макросів, які "
"потрібно скасувати."

msgid "For example::"
msgstr "Наприклад::"

msgid "is the equivalent of having this at the top of every C source file::"
msgstr ""
"це еквівалент розміщення цього у верхній частині кожного вихідного файлу C::"

msgid "Library options"
msgstr "Параметри бібліотеки"

msgid ""
"You can also specify the libraries to link against when building your "
"extension, and the directories to search for those libraries.  The "
"``libraries`` option is a list of libraries to link against, "
"``library_dirs`` is a list of directories to search for libraries at  link-"
"time, and ``runtime_library_dirs`` is a list of directories to  search for "
"shared (dynamically loaded) libraries at run-time."
msgstr ""
"Ви також можете вказати бібліотеки для зв’язування під час створення "
"розширення та каталоги для пошуку цих бібліотек. Параметр ``libraries`` — це "
"список бібліотек, з якими потрібно зв’язатися, ``library_dirs`` — це список "
"каталогів для пошуку бібліотек під час підключення, а "
"``runtime_library_dirs`` — це список каталогів для пошуку спільних "
"(динамічно завантажувані) бібліотеки під час виконання."

msgid ""
"For example, if you need to link against libraries known to be in the "
"standard library search path on target systems ::"
msgstr ""
"Наприклад, якщо вам потрібно зв’язатися з бібліотеками, які, як відомо, "
"знаходяться в стандартному шляху пошуку бібліотек у цільових системах ::"

msgid ""
"If you need to link with libraries in a non-standard location, you'll have "
"to include the location in ``library_dirs``::"
msgstr ""
"Якщо вам потрібно зв’язатися з бібліотеками в нестандартному розташуванні, "
"вам доведеться включити це розташування в ``library_dirs``::"

msgid ""
"(Again, this sort of non-portable construct should be avoided if you intend "
"to distribute your code.)"
msgstr ""
"(Знову ж таки, такого роду непереносимих конструкцій слід уникати, якщо ви "
"маєте намір поширювати свій код.)"

msgid "Other options"
msgstr "Інші варіанти"

msgid ""
"There are still some other options which can be used to handle special cases."
msgstr ""
"Є ще деякі інші параметри, які можна використовувати для обробки особливих "
"випадків."

msgid ""
"The ``optional`` option is a boolean; if it is true, a build failure in the "
"extension will not abort the build process, but instead simply not install "
"the failing extension."
msgstr ""
"Параметр ``optional`` є логічним; якщо це правда, помилка збірки в "
"розширенні не призведе до переривання процесу збірки, а натомість просто не "
"встановить помилкове розширення."

msgid ""
"The ``extra_objects`` option is a list of object files to be passed to the "
"linker. These files must not have extensions, as the default extension for "
"the compiler is used."
msgstr ""
"Параметр ``extra_objects`` - це список об'єктних файлів, які будуть передані "
"компонувальнику. Ці файли не повинні мати розширень, оскільки "
"використовується розширення за замовчуванням для компілятора."

msgid ""
"``extra_compile_args`` and ``extra_link_args`` can be used to specify "
"additional command line options for the respective compiler and linker "
"command lines."
msgstr ""
"``extra_compile_args`` і ``extra_link_args`` можна використовувати для "
"визначення додаткових параметрів командного рядка для відповідних командних "
"рядків компілятора та компонувальника."

msgid ""
"``export_symbols`` is only useful on Windows.  It can contain a list of "
"symbols (functions or variables) to be exported. This option is not needed "
"when building compiled extensions: Distutils  will automatically add "
"``initmodule`` to the list of exported symbols."
msgstr ""
"``export_symbols`` корисний лише в Windows. Він може містити список символів "
"(функцій або змінних), які потрібно експортувати. Ця опція не потрібна під "
"час створення скомпільованих розширень: Distutils автоматично додасть "
"``initmodule`` до списку експортованих символів."

msgid ""
"The ``depends`` option is a list of files that the extension depends on (for "
"example header files). The build command will call the compiler on the "
"sources to rebuild extension if any on this files has been modified since "
"the previous build."
msgstr ""
"Параметр ``depends`` — це список файлів, від яких залежить розширення "
"(наприклад, файли заголовків). Команда збірки викличе компілятор вихідних "
"кодів, щоб відновити розширення, якщо якісь у цих файлах було змінено з часу "
"попередньої збірки."

msgid "Relationships between Distributions and Packages"
msgstr "Відносини між дистрибутивами та пакетами"

msgid "A distribution may relate to packages in three specific ways:"
msgstr "Розповсюдження може стосуватися пакетів трьома конкретними способами:"

msgid "It can require packages or modules."
msgstr "Для цього можуть знадобитися пакети або модулі."

msgid "It can provide packages or modules."
msgstr "Він може надавати пакети або модулі."

msgid "It can obsolete packages or modules."
msgstr "Це може застаріти пакети або модулі."

msgid ""
"These relationships can be specified using keyword arguments to the :func:"
"`distutils.core.setup` function."
msgstr ""
"Ці зв’язки можна вказати за допомогою ключових аргументів функції :func:"
"`distutils.core.setup`."

msgid ""
"Dependencies on other Python modules and packages can be specified by "
"supplying the *requires* keyword argument to :func:`setup`. The value must "
"be a list of strings.  Each string specifies a package that is required, and "
"optionally what versions are sufficient."
msgstr ""
"Залежності від інших модулів і пакетів Python можна вказати, надавши "
"аргумент ключового слова *requires* для :func:`setup`. Значення має бути "
"списком рядків. Кожен рядок визначає необхідний пакет і, за бажанням, "
"достатні версії."

msgid ""
"To specify that any version of a module or package is required, the string "
"should consist entirely of the module or package name. Examples include "
"``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr ""
"Щоб вказати, що потрібна будь-яка версія модуля чи пакета, рядок має "
"повністю складатися з назви модуля чи пакета. Приклади включають "
"``'mymodule`` і ``'xml.parsers.expat''``."

msgid ""
"If specific versions are required, a sequence of qualifiers can be supplied "
"in parentheses.  Each qualifier may consist of a comparison operator and a "
"version number.  The accepted comparison operators are::"
msgstr ""
"Якщо потрібні певні версії, у дужках можна вказати послідовність "
"кваліфікаторів. Кожен кваліфікатор може складатися з оператора порівняння та "
"номера версії. Прийнятні оператори порівняння:"

msgid ""
"These can be combined by using multiple qualifiers separated by commas (and "
"optional whitespace).  In this case, all of the qualifiers must be matched; "
"a logical AND is used to combine the evaluations."
msgstr ""
"Їх можна комбінувати за допомогою кількох кваліфікаторів, розділених комами "
"(і необов’язковими пробілами). У цьому випадку всі кваліфікатори повинні "
"збігатися; логічне І використовується для об’єднання оцінок."

msgid "Let's look at a bunch of examples:"
msgstr "Давайте розглянемо кілька прикладів:"

msgid "Requires Expression"
msgstr "Вимагає експресії"

msgid "Explanation"
msgstr "Пояснення"

msgid "``==1.0``"
msgstr "``==1,0``"

msgid "Only version ``1.0`` is compatible"
msgstr "Лише версія ``1.0`` сумісна"

msgid "``>1.0, !=1.5.1, <2.0``"
msgstr "``>1.0, !=1.5.1, <2.0``"

msgid ""
"Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``"
msgstr "Будь-яка версія після ``1.0`` і до ``2.0`` сумісна, крім ``1.5.1``"

msgid ""
"Now that we can specify dependencies, we also need to be able to specify "
"what we provide that other distributions can require.  This is done using "
"the *provides* keyword argument to :func:`setup`. The value for this keyword "
"is a list of strings, each of which names a Python module or package, and "
"optionally identifies the version.  If the version is not specified, it is "
"assumed to match that of the distribution."
msgstr ""
"Тепер, коли ми можемо вказати залежності, нам також потрібно мати можливість "
"вказати, що ми надаємо, що можуть вимагати інші дистрибутиви. Це робиться за "
"допомогою ключового аргументу *provides* для :func:`setup`. Значення цього "
"ключового слова — це список рядків, кожен з яких іменує модуль або пакет "
"Python і, за бажанням, визначає версію. Якщо версія не вказана, вважається, "
"що вона відповідає версії дистрибутива."

msgid "Some examples:"
msgstr "Деякі приклади:"

msgid "Provides Expression"
msgstr "Забезпечує експресію"

msgid "``mypkg``"
msgstr "``mypkg``"

msgid "Provide ``mypkg``, using the distribution version"
msgstr "Надайте ``mypkg``, використовуючи версію розповсюдження"

msgid "``mypkg (1.1)``"
msgstr "``mypkg (1.1)``"

msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr "Надайте ``mypkg`` версії 1.1, незалежно від версії дистрибутива"

msgid ""
"A package can declare that it obsoletes other packages using the *obsoletes* "
"keyword argument.  The value for this is similar to that of the *requires* "
"keyword: a list of strings giving module or package specifiers.  Each "
"specifier consists of a module or package name optionally followed by one or "
"more version qualifiers.  Version qualifiers are given in parentheses after "
"the module or package name."
msgstr ""
"Пакунок може оголосити, що він застарів іншим пакункам за допомогою "
"аргументу ключового слова *obsoletes*. Значення для цього подібне до "
"значення ключового слова *requires*: список рядків, що надають специфікатори "
"модуля або пакета. Кожен специфікатор складається з назви модуля або пакета, "
"за якою необов’язково слідують один або більше кваліфікаторів версії. "
"Специфікатори версії наведені в круглих дужках після назви модуля або пакета."

msgid ""
"The versions identified by the qualifiers are those that are obsoleted by "
"the distribution being described.  If no qualifiers are given, all versions "
"of the named module or package are understood to be obsoleted."
msgstr ""
"Версії, визначені кваліфікаторами, є тими, які застаріли через описуваний "
"розподіл. Якщо кваліфікатори не вказано, усі версії названого модуля або "
"пакета вважаються застарілими."

msgid "Installing Scripts"
msgstr "Встановлення скриптів"

msgid ""
"So far we have been dealing with pure and non-pure Python modules, which are "
"usually not run by themselves but imported by scripts."
msgstr ""
"Поки що ми мали справу з чистими та нечистими модулями Python, які зазвичай "
"не запускаються самостійно, а імпортуються за допомогою сценаріїв."

msgid ""
"Scripts are files containing Python source code, intended to be started from "
"the command line.  Scripts don't require Distutils to do anything very "
"complicated. The only clever feature is that if the first line of the script "
"starts with ``#!`` and contains the word \"python\", the Distutils will "
"adjust the first line to refer to the current interpreter location. By "
"default, it is replaced with the current interpreter location.  The :option:"
"`!--executable` (or :option:`!-e`) option will allow the interpreter path to "
"be explicitly overridden."
msgstr ""
"Сценарії — це файли, що містять вихідний код Python і призначені для запуску "
"з командного рядка. Сценарії не вимагають від Distutils виконання чогось "
"дуже складного. Єдина розумна функція полягає в тому, що якщо перший рядок "
"сценарію починається з ``#!`` і містить слово \"python\", Distutils "
"відкоригує перший рядок відповідно до поточного розташування інтерпретатора. "
"За замовчуванням його замінено на поточне розташування інтерпретатора. "
"Параметр :option:`!--executable` (або :option:`!-e`) дозволить явно "
"перевизначати шлях інтерпретатора."

msgid ""
"The ``scripts`` option simply is a list of files to be handled in this way.  "
"From the PyXML setup script::"
msgstr ""
"Параметр ``scripts`` — це просто список файлів, які потрібно обробляти таким "
"чином. Зі сценарію налаштування PyXML::"

msgid ""
"All the scripts will also be added to the ``MANIFEST`` file if no template "
"is provided.  See :ref:`manifest`."
msgstr ""
"Усі сценарії також буде додано до файлу ``MANIFEST``, якщо шаблон не надано. "
"Див. :ref:`manifest`."

msgid "Installing Package Data"
msgstr "Встановлення пакетних даних"

msgid ""
"Often, additional files need to be installed into a package.  These files "
"are often data that's closely related to the package's implementation, or "
"text files containing documentation that might be of interest to programmers "
"using the package.  These files are called :dfn:`package data`."
msgstr ""
"Часто в пакет потрібно інсталювати додаткові файли. Ці файли часто є даними, "
"тісно пов’язаними з реалізацією пакета, або текстовими файлами, що містять "
"документацію, яка може зацікавити програмістів, які використовують пакет. Ці "
"файли називаються :dfn:`package data`."

msgid ""
"Package data can be added to packages using the ``package_data`` keyword "
"argument to the :func:`setup` function.  The value must be a mapping from "
"package name to a list of relative path names that should be copied into the "
"package.  The paths are interpreted as relative to the directory containing "
"the package (information from the ``package_dir`` mapping is used if "
"appropriate); that is, the files are expected to be part of the package in "
"the source directories. They may contain glob patterns as well."
msgstr ""
"Дані пакетів можна додати до пакетів за допомогою ключового аргументу "
"``package_data`` функції :func:`setup`. Значення має бути зіставленням назви "
"пакета зі списком відносних імен шляхів, які слід скопіювати в пакет. Шляхи "
"інтерпретуються як відносні до каталогу, що містить пакунок (інформація з "
"відображення ``package_dir`` використовується, якщо це доречно); тобто "
"очікується, що файли будуть частиною пакета у вихідних каталогах. Вони також "
"можуть містити глобуси."

msgid ""
"The path names may contain directory portions; any necessary directories "
"will be created in the installation."
msgstr ""
"Назви шляхів можуть містити частини каталогу; усі необхідні каталоги будуть "
"створені під час встановлення."

msgid ""
"For example, if a package should contain a subdirectory with several data "
"files, the files can be arranged like this in the source tree::"
msgstr ""
"Наприклад, якщо пакунок має містити підкаталог із кількома файлами даних, "
"файли можна розташувати таким чином у вихідному дереві:"

msgid "The corresponding call to :func:`setup` might be::"
msgstr "Відповідний виклик :func:`setup` може бути::"

msgid ""
"All the files that match ``package_data`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"Усі файли, які відповідають ``package_data``, будуть додані до ``MANIFEST`` "
"файлу, якщо шаблон не надано. Див. :ref:`manifest`."

msgid "Installing Additional Files"
msgstr "Встановлення додаткових файлів"

msgid ""
"The ``data_files`` option can be used to specify additional files needed by "
"the module distribution: configuration files, message catalogs, data files, "
"anything which doesn't fit in the previous categories."
msgstr ""
"Параметр ``data_files`` можна використовувати для визначення додаткових "
"файлів, необхідних для розповсюдження модуля: конфігураційні файли, каталоги "
"повідомлень, файли даних, будь-що, що не підходить до попередніх категорій."

msgid ""
"``data_files`` specifies a sequence of (*directory*, *files*) pairs in the "
"following way::"
msgstr ""
"``data_files`` визначає послідовність пар (*каталог*, *файли*) таким чином:"

msgid ""
"Each (*directory*, *files*) pair in the sequence specifies the installation "
"directory and the files to install there."
msgstr ""
"Кожна пара (*каталог*, *файли*) у послідовності визначає каталог інсталяції "
"та файли для інсталяції."

msgid ""
"Each file name in *files* is interpreted relative to the :file:`setup.py` "
"script at the top of the package source distribution. Note that you can "
"specify the directory where the data files will be installed, but you cannot "
"rename the data files themselves."
msgstr ""
"Кожне ім’я файлу в *files* інтерпретується відносно сценарію :file:`setup."
"py` у верхній частині вихідного коду пакета. Зверніть увагу, що ви можете "
"вказати каталог, куди будуть встановлені файли даних, але ви не можете "
"перейменувати самі файли даних."

msgid ""
"The *directory* should be a relative path. It is interpreted relative to the "
"installation prefix (Python's ``sys.prefix`` for system installations; "
"``site.USER_BASE`` for user installations). Distutils allows *directory* to "
"be an absolute installation path, but this is discouraged since it is "
"incompatible with the wheel packaging format. No directory information from "
"*files* is used to determine the final location of the installed file; only "
"the name of the file is used."
msgstr ""
"*Каталог* має бути відносним шляхом. Він інтерпретується відносно префікса "
"встановлення (``sys.prefix`` Python для системних установок; ``site."
"USER_BASE`` для установок користувача). Distutils дозволяє *каталог* бути "
"абсолютним шляхом встановлення, але це не рекомендується, оскільки це "
"несумісно з форматом упаковки коліс. Для визначення кінцевого розташування "
"встановленого файлу інформація про каталог із *файлів* не використовується; "
"використовується лише ім'я файлу."

msgid ""
"You can specify the ``data_files`` options as a simple sequence of files "
"without specifying a target directory, but this is not recommended, and the :"
"command:`install` command will print a warning in this case. To install data "
"files directly in the target directory, an empty string should be given as "
"the directory."
msgstr ""
"Ви можете вказати параметри ``data_files`` як просту послідовність файлів "
"без вказівки цільового каталогу, але це не рекомендується, і команда :"
"command:`install` у цьому випадку виведе попередження. Щоб установити файли "
"даних безпосередньо в цільовий каталог, як каталог слід вказати порожній "
"рядок."

msgid ""
"All the files that match ``data_files`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"Усі файли, які відповідають ``data_files``, будуть додані до ``MANIFEST`` "
"файлу, якщо шаблон не надано. Див. :ref:`manifest`."

msgid "Additional meta-data"
msgstr "Додаткові метадані"

msgid ""
"The setup script may include additional meta-data beyond the name and "
"version. This information includes:"
msgstr ""
"Сценарій налаштування може містити додаткові метадані, окрім імені та "
"версії. Ця інформація включає:"

msgid "Meta-Data"
msgstr "Мета-дані"

msgid "Description"
msgstr "опис"

msgid "Value"
msgstr "Значення"

msgid "Notes"
msgstr "Примітки"

msgid "``name``"
msgstr "``ім'я``"

msgid "name of the package"
msgstr "назву пакета"

msgid "short string"
msgstr "короткий рядок"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``version``"
msgstr "``версія``"

msgid "version of this release"
msgstr "версія цього випуску"

msgid "(1)(2)"
msgstr "(1)(2)"

msgid "``author``"
msgstr "``автор``"

msgid "package author's name"
msgstr "ім'я автора пакета"

msgid "\\(3)"
msgstr "\\(3)"

msgid "``author_email``"
msgstr "``author_email``"

msgid "email address of the package author"
msgstr "адреса електронної пошти автора пакета"

msgid "email address"
msgstr "адреса електронної пошти"

msgid "``maintainer``"
msgstr "``підтримувач``"

msgid "package maintainer's name"
msgstr "ім'я супроводжуючого пакета"

msgid "``maintainer_email``"
msgstr "``maintainer_email``"

msgid "email address of the package maintainer"
msgstr "адреса електронної пошти супроводжуючого пакет"

msgid "``url``"
msgstr "``url``"

msgid "home page for the package"
msgstr "домашня сторінка для пакета"

msgid "URL"
msgstr "URL"

msgid "``description``"
msgstr "``опис``"

msgid "short, summary description of the package"
msgstr "короткий короткий опис пакету"

msgid "``long_description``"
msgstr "``довгий_опис``"

msgid "longer description of the package"
msgstr "додатковий опис пакета"

msgid "long string"
msgstr "довгий рядок"

msgid "\\(4)"
msgstr "\\(4)"

msgid "``download_url``"
msgstr "URL-адреса_завантаження"

msgid "location where the package may be downloaded"
msgstr "місце, де можна завантажити пакет"

msgid "``classifiers``"
msgstr "``класифікатори``"

msgid "a list of classifiers"
msgstr "список класифікаторів"

msgid "list of strings"
msgstr "список рядків"

msgid "(6)(7)"
msgstr "(6)(7)"

msgid "``platforms``"
msgstr "``платформи``"

msgid "a list of platforms"
msgstr "список платформ"

msgid "(6)(8)"
msgstr "(6)(8)"

msgid "``keywords``"
msgstr "``ключові слова``"

msgid "a list of keywords"
msgstr "список ключових слів"

msgid "``license``"
msgstr "``ліцензія``"

msgid "license for the package"
msgstr "ліцензія на пакет"

msgid "\\(5)"
msgstr "\\(5)"

msgid "Notes:"
msgstr "Примітки:"

msgid "These fields are required."
msgstr "Ці поля є обов’язковими."

msgid ""
"It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr "Рекомендується, щоб версії мали форму *major.minor[.patch[.sub]]*."

msgid ""
"Either the author or the maintainer must be identified. If maintainer is "
"provided, distutils lists it as the author in :file:`PKG-INFO`."
msgstr ""
"Має бути ідентифікований або автор, або супроводжувач. Якщо вказано "
"супроводжуючого, distutils вказує його як автора в :file:`PKG-INFO`."

msgid ""
"The ``long_description`` field is used by PyPI when you publish a package, "
"to build its project page."
msgstr ""
"Поле ``long_description`` використовується PyPI, коли ви публікуєте пакет, "
"для створення його сторінки проекту."

msgid ""
"The ``license`` field is a text indicating the license covering the package "
"where the license is not a selection from the \"License\" Trove classifiers. "
"See the ``Classifier`` field. Notice that there's a ``licence`` distribution "
"option which is deprecated but still acts as an alias for ``license``."
msgstr ""
"Поле \"ліцензія\" — це текст, що вказує на ліцензію, що охоплює пакет, де "
"ліцензія не є вибором із класифікаторів Trove \"Ліцензії\". Перегляньте поле "
"``Класифікатор``. Зауважте, що існує опція розповсюдження ``ліцензія``, яка "
"є застарілою, але все ще діє як псевдонім для ``ліцензії``."

msgid "This field must be a list."
msgstr "Це поле має бути списком."

msgid ""
"The valid classifiers are listed on `PyPI <https://pypi.org/classifiers>`_."
msgstr ""
"Дійсні класифікатори перераховані на `PyPI <https://pypi.org/classifiers>`_."

msgid ""
"To preserve backward compatibility, this field also accepts a string. If you "
"pass a comma-separated string ``'foo, bar'``, it will be converted to "
"``['foo', 'bar']``, Otherwise, it will be converted to a list of one string."
msgstr ""
"Щоб зберегти зворотну сумісність, це поле також приймає рядок. Якщо ви "
"передасте розділений комами рядок ``'foo, bar''``, він буде перетворений на "
"``['foo', 'bar']``, інакше він буде перетворений на список з одного рядка."

msgid "'short string'"
msgstr "'короткий рядок'"

msgid "A single line of text, not more than 200 characters."
msgstr "Один рядок тексту, не більше 200 символів."

msgid "'long string'"
msgstr "\"довгий рядок\""

msgid ""
"Multiple lines of plain text in reStructuredText format (see http://docutils."
"sourceforge.net/)."
msgstr ""
"Кілька рядків звичайного тексту у форматі reStructuredText (див. http://"
"docutils.sourceforge.net/)."

msgid "'list of strings'"
msgstr "'список рядків'"

msgid "See below."
msgstr "Дивіться нижче."

msgid ""
"Encoding the version information is an art in itself. Python packages "
"generally adhere to the version format *major.minor[.patch][sub]*. The major "
"number is 0 for initial, experimental releases of software. It is "
"incremented for releases that represent major milestones in a package. The "
"minor number is incremented when important new features are added to the "
"package. The patch number increments when bug-fix releases are made. "
"Additional trailing version information is sometimes used to indicate sub-"
"releases.  These are \"a1,a2,...,aN\" (for alpha releases, where "
"functionality and API may change), \"b1,b2,...,bN\" (for beta releases, "
"which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release release "
"testing). Some examples:"
msgstr ""
"Кодування інформації про версію — це саме по собі мистецтво. Пакунки Python "
"зазвичай мають формат версії *major.minor[.patch][sub]*. Основне число — 0 "
"для початкових, експериментальних версій програмного забезпечення. Він "
"збільшується для випусків, які представляють основні віхи в пакеті. Менше "
"число збільшується, коли до пакета додаються важливі нові функції. Номер "
"виправлення збільшується, коли випускаються випуски виправлень помилок. "
"Додаткова кінцева інформація про версію іноді використовується для "
"позначення підрелізів. Це \"a1,a2,...,aN\" (для альфа-версій, де "
"функціональність і API можуть змінюватися), \"b1,b2,...,bN\" (для бета-"
"версій, які лише виправляють помилки) і \"pr1 ,pr2,...,prN\" (для "
"остаточного тестування перед випуском). Деякі приклади:"

msgid "0.1.0"
msgstr "0.1.0"

msgid "the first, experimental release of a package"
msgstr "перший, експериментальний випуск пакету"

msgid "1.0.1a2"
msgstr "1.0.1a2"

msgid "the second alpha release of the first patch version of 1.0"
msgstr "друга альфа-версія першої версії патча 1.0"

msgid "``classifiers`` must be specified in a list::"
msgstr "``класифікатори`` повинні бути вказані в списку::"

msgid ""
":class:`~distutils.core.setup` now warns when ``classifiers``, ``keywords`` "
"or ``platforms`` fields are not specified as a list or a string."
msgstr ""
":class:`~distutils.core.setup` тепер попереджає, коли поля "
"``класифікатори``, ``ключові слова`` або ``платформи`` не вказані як список "
"або рядок."

msgid "Debugging the setup script"
msgstr "Налагодження сценарію налаштування"

msgid ""
"Sometimes things go wrong, and the setup script doesn't do what the "
"developer wants."
msgstr ""
"Іноді щось йде не так, і сценарій налаштування не виконує те, що хоче "
"розробник."

msgid ""
"Distutils catches any exceptions when running the setup script, and print a "
"simple error message before the script is terminated.  The motivation for "
"this behaviour is to not confuse administrators who don't know much about "
"Python and are trying to install a package.  If they get a big long "
"traceback from deep inside the guts of Distutils, they may think the package "
"or the Python installation is broken because they don't read all the way "
"down to the bottom and see that it's a permission problem."
msgstr ""
"Distutils вловлює будь-які винятки під час запуску сценарію налаштування та "
"друкує просте повідомлення про помилку перед завершенням сценарію. Мотивація "
"такої поведінки полягає в тому, щоб не заплутати адміністраторів, які мало "
"знають про Python і намагаються встановити пакет. Якщо вони отримають велике "
"довге відстеження з глибини нутрощів Distutils, вони можуть подумати, що "
"пакет або інсталяція Python зламані, оскільки вони не прочитали весь шлях до "
"кінця й побачать, що це проблема з дозволом."

msgid ""
"On the other hand, this doesn't help the developer to find the cause of the "
"failure. For this purpose, the :envvar:`DISTUTILS_DEBUG` environment "
"variable can be set to anything except an empty string, and distutils will "
"now print detailed information about what it is doing, dump the full "
"traceback when an exception occurs, and print the whole command line when an "
"external program (like a C compiler) fails."
msgstr ""
"З іншого боку, це не допомагає розробнику знайти причину збою. З цією метою "
"для змінної середовища :envvar:`DISTUTILS_DEBUG` можна встановити будь-яке "
"значення, окрім порожнього рядка, і distutils тепер друкуватиме детальну "
"інформацію про те, що він робить, створюватиме повну трасування, коли "
"станеться виняткова ситуація, і друкуватиме всю команду рядок, коли зовнішня "
"програма (наприклад, компілятор C) дає збій."
