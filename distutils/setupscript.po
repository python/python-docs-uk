# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# Transifex Bot <>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-05-19 14:13+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Transifex Bot <>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../distutils/setupscript.rst:5
msgid "Writing the Setup Script"
msgstr "Написання сценарію налаштування"

#: ../../distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html"
" independently covers all of the relevant information currently included "
"here."
msgstr ""
"Цей документ зберігається лише до тих пір, поки документація ``setuptools`` "
"за адресою https://setuptools.readthedocs.io/en/latest/setuptools.html "
"окремо не охопить всю відповідну інформацію, яка зараз включена тут."

#: ../../distutils/setupscript.rst:9
msgid ""
"The setup script is the centre of all activity in building, distributing, "
"and installing modules using the Distutils.  The main purpose of the setup "
"script is to describe your module distribution to the Distutils, so that the"
" various commands that operate on your modules do the right thing.  As we "
"saw in section :ref:`distutils-simple-example` above, the setup script "
"consists mainly of a call to :func:`setup`, and most information supplied to"
" the Distutils by the module developer is supplied as keyword arguments to "
":func:`setup`."
msgstr ""
"Сценарій встановлення є центром усієї діяльності зі створення, "
"розповсюдження та встановлення модулів за допомогою Distutils. Основна мета "
"сценарію налаштування — описати розповсюдження ваших модулів у Distutils, "
"щоб різні команди, що працюють із вашими модулями, працювали правильно. Як "
"ми бачили в розділі :ref:`distutils-simple-example` вище, сценарій "
"налаштування складається в основному з виклику :func:`setup`, і більшість "
"інформації, яку надає Distutils розробник модуля, надається як аргументи "
"ключового слова до :func:`setup`."

#: ../../distutils/setupscript.rst:17
msgid ""
"Here's a slightly more involved example, which we'll follow for the next "
"couple of sections: the Distutils' own setup script.  (Keep in mind that "
"although the Distutils are included with Python 1.6 and later, they also "
"have an independent existence so that Python 1.5.2 users can use them to "
"install other module distributions.  The Distutils' own setup script, shown "
"here, is used to install the package into Python 1.5.2.) ::"
msgstr ""
"Ось трохи складніший приклад, який ми розглянемо в наступних кількох "
"розділах: власний сценарій налаштування Distutils. (Майте на увазі, що "
"незважаючи на те, що Distutils включено до Python 1.6 і пізніших версій, "
"вони також існують незалежно, тому користувачі Python 1.5.2 можуть "
"використовувати їх для встановлення інших дистрибутивів модулів. "
"Використовується власний сценарій налаштування Distutils, показаний тут щоб "
"інсталювати пакет у Python 1.5.2.) ::"

#: ../../distutils/setupscript.rst:37
msgid ""
"There are only two differences between this and the trivial one-file "
"distribution presented in section :ref:`distutils-simple-example`: more "
"metadata, and the specification of pure Python modules by package, rather "
"than by module.  This is important since the Distutils consist of a couple "
"of dozen modules split into (so far) two packages; an explicit list of every"
" module would be tedious to generate and difficult to maintain.  For more "
"information on the additional meta-data, see section :ref:`meta-data`."
msgstr ""
"Існує лише дві відмінності між цим і тривіальним однофайловим розподілом, "
"представленим у розділі :ref:`distutils-simple-example`: більше метаданих і "
"специфікація чистих модулів Python за пакетом, а не за модулем. Це важливо, "
"оскільки Distutils складається з кількох десятків модулів, розділених на "
"(поки що) два пакети; явний список кожного модуля було б стомлюючим для "
"створення та важким для підтримки. Для отримання додаткової інформації про "
"додаткові метадані перегляньте розділ :ref:`meta-data`."

#: ../../distutils/setupscript.rst:45
msgid ""
"Note that any pathnames (files or directories) supplied in the setup script "
"should be written using the Unix convention, i.e. slash-separated.  The "
"Distutils will take care of converting this platform-neutral representation "
"into whatever is appropriate on your current platform before actually using "
"the pathname.  This makes your setup script portable across operating "
"systems, which of course is one of the major goals of the Distutils.  In "
"this spirit, all pathnames in this document are slash-separated."
msgstr ""
"Зауважте, що будь-які імена шляхів (файлів або каталогів), надані в сценарії"
" встановлення, мають бути записані з використанням конвенції Unix, тобто "
"розділені рискою. Distutils подбає про перетворення цього нейтрального щодо "
"платформи представлення у те, що підходить для вашої поточної платформи, "
"перш ніж фактично використовувати шлях. Це робить ваш сценарій налаштування "
"переносимим між операційними системами, що, звичайно, є однією з головних "
"цілей Distutils. У цьому дусі всі назви шляхів у цьому документі розділені "
"косою рискою."

#: ../../distutils/setupscript.rst:53
msgid ""
"This, of course, only applies to pathnames given to Distutils functions.  If"
" you, for example, use standard Python functions such as :func:`glob.glob` "
"or :func:`os.listdir` to specify files, you should be careful to write "
"portable code instead of hardcoding path separators::"
msgstr ""
"Звичайно, це стосується лише імен шляхів, наданих функціям Distutils. Якщо "
"ви, наприклад, використовуєте стандартні функції Python, такі як "
":func:`glob.glob` або :func:`os.listdir` для вказування файлів, вам слід "
"бути обережними, щоб писати портативний код замість жорсткого кодування "
"роздільників шляхів::"

#: ../../distutils/setupscript.rst:65
msgid "Listing whole packages"
msgstr "Перелік цілих пакетів"

#: ../../distutils/setupscript.rst:67
msgid ""
"The ``packages`` option tells the Distutils to process (build, distribute, "
"install, etc.) all pure Python modules found in each package mentioned in "
"the ``packages`` list.  In order to do this, of course, there has to be a "
"correspondence between package names and directories in the filesystem.  The"
" default correspondence is the most obvious one, i.e. package "
":mod:`distutils` is found in the directory :file:`distutils` relative to the"
" distribution root. Thus, when you say ``packages = ['foo']`` in your setup "
"script, you are promising that the Distutils will find a file "
":file:`foo/__init__.py` (which might be spelled differently on your system, "
"but you get the idea) relative to the directory where your setup script "
"lives.  If you break this promise, the Distutils will issue a warning but "
"still process the broken package anyway."
msgstr ""
"Параметр ``packages`` повідомляє Distutils обробляти (збирати, "
"розповсюджувати, інсталювати тощо) усі чисті модулі Python, знайдені в "
"кожному пакеті, згаданому у списку ``packages``. Для цього, звичайно, має "
"бути відповідність між назвами пакетів і каталогами у файловій системі. "
"Типова відповідність є найбільш очевидною, тобто пакунок :mod:`distutils` "
"знаходиться в каталозі :file:`distutils` відносно кореня дистрибутива. Таким"
" чином, коли ви кажете ``packages = ['foo']`` у вашому сценарії "
"встановлення, ви обіцяєте, що Distutils знайде файл :file:`foo/__init__.py` "
"(який може бути написаний інакше у вашій системі , але ви зрозуміли) "
"відносно каталогу, де знаходиться ваш сценарій налаштування. Якщо ви "
"порушите цю обіцянку, Distutils видасть попередження, але все одно обробить "
"зламаний пакет."

#: ../../distutils/setupscript.rst:79
msgid ""
"If you use a different convention to lay out your source directory, that's "
"no problem: you just have to supply the ``package_dir`` option to tell the "
"Distutils about your convention.  For example, say you keep all Python "
"source under :file:`lib`, so that modules in the \"root package\" (i.e., not"
" in any package at all) are in :file:`lib`, modules in the :mod:`foo` "
"package are in :file:`lib/foo`, and so forth.  Then you would put ::"
msgstr ""
"Якщо ви використовуєте іншу угоду для компонування вихідного каталогу, це не"
" проблема: вам просто потрібно вказати опцію ``package_dir``, щоб повідомити"
" Distutils про вашу угоду. Наприклад, припустимо, що ви зберігаєте всі "
"джерела Python у :file:`lib`, так що модулі в \"кореневому пакеті\" (тобто "
"не в будь-якому пакеті взагалі) знаходяться в :file:`lib`, а модулі в Пакет "
":mod:`foo` міститься в :file:`lib/foo` і так далі. Тоді ви б поставили ::"

#: ../../distutils/setupscript.rst:88
msgid ""
"in your setup script.  The keys to this dictionary are package names, and an"
" empty package name stands for the root package.  The values are directory "
"names relative to your distribution root.  In this case, when you say "
"``packages = ['foo']``, you are promising that the file "
":file:`lib/foo/__init__.py` exists."
msgstr ""
"у вашому сценарії налаштування. Ключами до цього словника є імена пакетів, а"
" порожня назва пакета означає кореневий пакет. Значення – це імена каталогів"
" відносно кореня дистрибутива. У цьому випадку, коли ви кажете ``packages = "
"['foo']``, ви обіцяєте, що файл :file:`lib/foo/__init__.py` існує."

#: ../../distutils/setupscript.rst:93
msgid ""
"Another possible convention is to put the :mod:`foo` package right in "
":file:`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would"
" be written in the setup script as ::"
msgstr ""
"Іншою можливою угодою є розміщення пакета :mod:`foo` безпосередньо в "
":file:`lib`, пакета :mod:`foo.bar` в :file:`lib/bar` тощо. Це буде написано "
"в сценарій налаштування як ::"

#: ../../distutils/setupscript.rst:99
msgid ""
"A ``package: dir`` entry in the ``package_dir`` dictionary implicitly "
"applies to all packages below *package*, so the :mod:`foo.bar` case is "
"automatically handled here.  In this example, having ``packages = ['foo', "
"'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and "
":file:`lib/bar/__init__.py`.  (Keep in mind that although ``package_dir`` "
"applies recursively, you must explicitly list all packages in ``packages``: "
"the Distutils will *not* recursively scan your source tree looking for any "
"directory with an :file:`__init__.py` file.)"
msgstr ""
"Запис ``package: dir`` у словнику ``package_dir`` неявно застосовується до "
"всіх пакунків нижче *package*, тому тут автоматично обробляється випадок "
":mod:`foo.bar`. У цьому прикладі наявність ``packages = ['foo', 'foo.bar']``"
" повідомляє Distutils шукати :file:`lib/__init__.py` і "
":file:`lib/bar/__init__.py`. (Майте на увазі, що хоча ``package_dir`` "
"застосовується рекурсивно, ви повинні явно перерахувати всі пакунки в "
"``packages``: Distutils *не* рекурсивно скануватиме ваше вихідне дерево в "
"пошуках будь-якого каталогу з :file:`__init__. py` файл.)"

#: ../../distutils/setupscript.rst:112
msgid "Listing individual modules"
msgstr "Перелік окремих модулів"

#: ../../distutils/setupscript.rst:114
msgid ""
"For a small module distribution, you might prefer to list all modules rather"
" than listing packages---especially the case of a single module that goes in"
" the \"root package\" (i.e., no package at all).  This simplest case was "
"shown in section :ref:`distutils-simple-example`; here is a slightly more "
"involved example::"
msgstr ""
"Для невеликого розповсюдження модулів ви можете віддати перевагу переліку "
"всіх модулів, а не переліку пакунків --- особливо у випадку окремого модуля,"
" який міститься в \"кореневому пакеті\" (тобто без пакета взагалі). Цей "
"найпростіший випадок було показано в розділі :ref:`distutils-simple-"
"example`; ось трохи складніший приклад::"

#: ../../distutils/setupscript.rst:121
msgid ""
"This describes two modules, one of them in the \"root\" package, the other "
"in the :mod:`pkg` package.  Again, the default package/directory layout "
"implies that these two modules can be found in :file:`mod1.py` and "
":file:`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And "
"again, you can override the package/directory correspondence using the "
"``package_dir`` option."
msgstr ""
"Це описує два модулі, один з них у кореневому пакеті, інший у пакеті "
":mod:`pkg`. Знову ж таки, макет пакета/каталогу за замовчуванням означає, що"
" ці два модулі можна знайти в :file:`mod1.py` і :file:`pkg/mod2.py`, і що "
":file:`pkg/__init__.py` існує так само. І знову ж таки, ви можете змінити "
"відповідність пакета/каталогу за допомогою параметра ``package_dir``."

#: ../../distutils/setupscript.rst:131
msgid "Describing extension modules"
msgstr "Опис модулів розширення"

#: ../../distutils/setupscript.rst:133
msgid ""
"Just as writing Python extension modules is a bit more complicated than "
"writing pure Python modules, describing them to the Distutils is a bit more "
"complicated. Unlike pure modules, it's not enough just to list modules or "
"packages and expect the Distutils to go out and find the right files; you "
"have to specify the extension name, source file(s), and any compile/link "
"requirements (include directories, libraries to link with, etc.)."
msgstr ""
"Подібно до того, як написання модулів розширення Python є дещо складнішим, "
"ніж написання чистих модулів Python, описувати їх у Distutils дещо "
"складніше. На відміну від чистих модулів, недостатньо просто перерахувати "
"модулі чи пакети й очікувати, що Distutils вийдуть і знайдуть потрібні "
"файли; ви повинні вказати ім’я розширення, вихідний(і) файл(и) та будь-які "
"вимоги до компіляції/посилання (включно з каталогами, бібліотеками для "
"зв’язування тощо)."

#: ../../distutils/setupscript.rst:142
msgid ""
"All of this is done through another keyword argument to :func:`setup`, the "
"``ext_modules`` option.  ``ext_modules`` is just a list of "
":class:`~distutils.core.Extension` instances, each of which describes a "
"single extension module. Suppose your distribution includes a single "
"extension, called :mod:`foo` and implemented by :file:`foo.c`.  If no "
"additional instructions to the compiler/linker are needed, describing this "
"extension is quite simple::"
msgstr ""
"Все це робиться за допомогою іншого ключового аргументу :func:`setup`, "
"параметра ``ext_modules``. ``ext_modules`` - це лише список екземплярів "
":class:`~distutils.core.Extension`, кожен з яких описує окремий модуль "
"розширення. Припустімо, що ваш дистрибутив містить одне розширення, яке "
"називається :mod:`foo` і реалізоване :file:`foo.c`. Якщо додаткові "
"інструкції для компілятора/лінкера не потрібні, описати це розширення досить"
" просто:"

#: ../../distutils/setupscript.rst:152
msgid ""
"The :class:`Extension` class can be imported from :mod:`distutils.core` "
"along with :func:`setup`.  Thus, the setup script for a module distribution "
"that contains only this one extension and nothing else might be::"
msgstr ""
"Клас :class:`Extension` можна імпортувати з :mod:`distutils.core` разом із "
":func:`setup`. Таким чином, сценарій налаштування для розповсюдження модуля,"
" який містить лише це одне розширення і нічого іншого, може бути:"

#: ../../distutils/setupscript.rst:162
msgid ""
"The :class:`Extension` class (actually, the underlying extension-building "
"machinery implemented by the :command:`build_ext` command) supports a great "
"deal of flexibility in describing Python extensions, which is explained in "
"the following sections."
msgstr ""
"Клас :class:`Extension` (фактично базовий механізм створення розширень, "
"реалізований командою :command:`build_ext`) підтримує велику гнучкість в "
"описі розширень Python, що пояснюється в наступних розділах."

#: ../../distutils/setupscript.rst:169
msgid "Extension names and packages"
msgstr "Назви розширень і пакети"

#: ../../distutils/setupscript.rst:171
msgid ""
"The first argument to the :class:`~distutils.core.Extension` constructor is "
"always the name of the extension, including any package names.  For example,"
" ::"
msgstr ""
"Першим аргументом конструктора :class:`~distutils.core.Extension` завжди є "
"ім’я розширення, включаючи будь-які імена пакетів. Наприклад, ::"

#: ../../distutils/setupscript.rst:176
msgid "describes an extension that lives in the root package, while ::"
msgstr "описує розширення, яке знаходиться в кореневому пакеті, а ::"

#: ../../distutils/setupscript.rst:180
msgid ""
"describes the same extension in the :mod:`pkg` package.  The source files "
"and resulting object code are identical in both cases; the only difference "
"is where in the filesystem (and therefore where in Python's namespace "
"hierarchy) the resulting extension lives."
msgstr ""
"описує те саме розширення в пакеті :mod:`pkg`. Вихідні файли та отриманий "
"об’єктний код ідентичні в обох випадках; єдина різниця полягає в тому, де у "
"файловій системі (і, отже, де в ієрархії простору імен Python) живе "
"результуюче розширення."

#: ../../distutils/setupscript.rst:185
msgid ""
"If you have a number of extensions all in the same package (or all under the"
" same base package), use the ``ext_package`` keyword argument to "
":func:`setup`.  For example, ::"
msgstr ""
"Якщо у вас є декілька розширень в одному пакеті (або всі в одному базовому "
"пакеті), використовуйте аргумент ключового слова ``ext_package`` для "
":func:`setup`. Наприклад, ::"

#: ../../distutils/setupscript.rst:195
msgid ""
"will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and "
":file:`bar.c` to :mod:`pkg.subpkg.bar`."
msgstr ""
"скомпілює :file:`foo.c` до розширення :mod:`pkg.foo`, а :file:`bar.c` до "
":mod:`pkg.subpkg.bar`."

#: ../../distutils/setupscript.rst:200
msgid "Extension source files"
msgstr "Вихідні файли розширення"

#: ../../distutils/setupscript.rst:202
msgid ""
"The second argument to the :class:`~distutils.core.Extension` constructor is"
" a list of source files.  Since the Distutils currently only support C, C++,"
" and Objective-C extensions, these are normally C/C++/Objective-C source "
"files.  (Be sure to use appropriate extensions to distinguish C++ source "
"files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and "
"Windows compilers.)"
msgstr ""
"Другим аргументом конструктора :class:`~distutils.core.Extension` є список "
"вихідних файлів. Оскільки Distutils наразі підтримують лише розширення C, "
"C++ і Objective-C, зазвичай це вихідні файли C/C++/Objective-C. (Обов’язково"
" використовуйте відповідні розширення, щоб розрізняти вихідні файли C++: "
":file:`.cc` і :file:`.cpp`, здається, розпізнаються як компіляторами Unix, "
"так і Windows.)"

#: ../../distutils/setupscript.rst:209
msgid ""
"However, you can also include SWIG interface (:file:`.i`) files in the list;"
" the :command:`build_ext` command knows how to deal with SWIG extensions: it"
" will run SWIG on the interface file and compile the resulting C/C++ file "
"into your extension."
msgstr ""
"Однак ви також можете включити файли інтерфейсу SWIG (:file:`.i`) до списку;"
" Команда :command:`build_ext` знає, як працювати з розширеннями SWIG: вона "
"запустить SWIG у файлі інтерфейсу та скомпілює отриманий файл C/C++ у ваше "
"розширення."

#: ../../distutils/setupscript.rst:216
msgid ""
"This warning notwithstanding, options to SWIG can be currently passed like "
"this::"
msgstr ""
"Незважаючи на це попередження, наразі параметри для SWIG можна передати так:"

#: ../../distutils/setupscript.rst:225
msgid "Or on the commandline like this::"
msgstr "Або в командному рядку так::"

#: ../../distutils/setupscript.rst:229
msgid ""
"On some platforms, you can include non-source files that are processed by "
"the compiler and included in your extension.  Currently, this just means "
"Windows message text (:file:`.mc`) files and resource definition "
"(:file:`.rc`) files for Visual C++. These will be compiled to binary "
"resource (:file:`.res`) files and linked into the executable."
msgstr ""
"На деяких платформах ви можете включити не вихідні файли, які оброблені "
"компілятором і включені у ваше розширення. Наразі це лише файли текстових "
"повідомлень Windows (:file:`.mc`) і файли визначення ресурсів (:file:`.rc`) "
"для Visual C++. Вони будуть скомпільовані у двійкові файли ресурсів "
"(:file:`.res`) і пов’язані у виконуваний файл."

#: ../../distutils/setupscript.rst:237
msgid "Preprocessor options"
msgstr "Опції препроцесора"

#: ../../distutils/setupscript.rst:239
msgid ""
"Three optional arguments to :class:`~distutils.core.Extension` will help if "
"you need to specify include directories to search or preprocessor macros to "
"define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``."
msgstr ""
"Три необов’язкові аргументи для :class:`~distutils.core.Extension` "
"допоможуть, якщо вам потрібно вказати включати каталоги для пошуку або "
"макроси препроцесора для визначення/невизначення: ``include_dirs``, "
"``define_macros`` і ``undef_macros``."

#: ../../distutils/setupscript.rst:243
msgid ""
"For example, if your extension requires header files in the :file:`include` "
"directory under your distribution root, use the ``include_dirs`` option::"
msgstr ""
"Наприклад, якщо ваше розширення потребує файлів заголовків у каталозі "
":file:`include` у корені дистрибутива, використовуйте опцію "
"``include_dirs``::"

#: ../../distutils/setupscript.rst:248
msgid ""
"You can specify absolute directories there; if you know that your extension "
"will only be built on Unix systems with X11R6 installed to :file:`/usr`, you"
" can get away with ::"
msgstr ""
"Там можна вказати абсолютні каталоги; якщо ви знаєте, що ваше розширення "
"буде побудовано лише на системах Unix із X11R6, встановленим у :file:`/usr`,"
" ви можете обійтися ::"

#: ../../distutils/setupscript.rst:254
msgid ""
"You should avoid this sort of non-portable usage if you plan to distribute "
"your code: it's probably better to write C code like  ::"
msgstr ""
"Якщо ви плануєте розповсюджувати свій код, вам слід уникати такого "
"непортативного використання: ймовірно, краще писати код на C так::"

#: ../../distutils/setupscript.rst:259
msgid ""
"If you need to include header files from some other Python extension, you "
"can take advantage of the fact that header files are installed in a "
"consistent way by the Distutils :command:`install_headers` command.  For "
"example, the Numerical Python header files are installed (on a standard Unix"
" installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact"
" location will differ according to your platform and Python installation.)  "
"Since the Python include directory---\\ :file:`/usr/local/include/python1.5`"
" in this case---is always included in the search path when building Python "
"extensions, the best approach is to write C code like  ::"
msgstr ""
"Якщо вам потрібно включити файли заголовків з іншого розширення Python, ви "
"можете скористатися тим фактом, що файли заголовків установлюються узгоджено"
" за допомогою команди Distutils :command:`install_headers`. Наприклад, "
"числові файли заголовків Python інсталюються (у стандартній установці Unix) "
"у :file:`/usr/local/include/python1.5/Numerical`. (Точне розташування буде "
"відрізнятися залежно від вашої платформи та інсталяції Python.) Оскільки "
"каталог включення Python---\\ :file:`/usr/local/include/python1.5` у цьому "
"випадку---завжди включається в Шлях пошуку під час створення розширень "
"Python найкращим підходом є написання коду C, наприклад::"

#: ../../distutils/setupscript.rst:271
msgid ""
"If you must put the :file:`Numerical` include directory right into your "
"header search path, though, you can find that directory using the Distutils "
":mod:`distutils.sysconfig` module::"
msgstr ""
"Якщо вам потрібно розмістити каталог :file:`Numerical` включення прямо в "
"шлях пошуку заголовка, ви можете знайти цей каталог за допомогою модуля "
"Distutils :mod:`distutils.sysconfig`::"

#: ../../distutils/setupscript.rst:281
msgid ""
"Even though this is quite portable---it will work on any Python "
"installation, regardless of platform---it's probably easier to just write "
"your C code in the sensible way."
msgstr ""
"Незважаючи на те, що це досить портативно --- воно працюватиме на будь-якій "
"інсталяції Python, незалежно від платформи --- мабуть, легше просто написати"
" свій код на C розумним способом."

#: ../../distutils/setupscript.rst:285
msgid ""
"You can define and undefine pre-processor macros with the ``define_macros`` "
"and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, "
"value)`` tuples, where ``name`` is the name of the macro to define (a "
"string) and ``value`` is its value: either a string or ``None``.  (Defining "
"a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in "
"your C source: with most compilers, this sets ``FOO`` to the string ``1``.)"
"  ``undef_macros`` is just a list of macros to undefine."
msgstr ""
"Ви можете визначити та скасувати визначення макросів попередньої обробки за "
"допомогою параметрів ``define_macros`` і ``undef_macros``. ``define_macros``"
" бере список кортежів ``(name, value)``, де ``name`` є назвою макросу для "
"визначення (рядок), а ``value`` є його значенням: або рядок або ``None``. "
"(Визначення макросу ``FOO`` як ``None`` є еквівалентом простого ``#define "
"FOO`` у вашому вихідному коді C: у більшості компіляторів це встановлює "
"``FOO`` у рядок ``1``.) ``undef_macros`` — це лише список макросів, які "
"потрібно скасувати."

#: ../../distutils/setupscript.rst:293
msgid "For example::"
msgstr "Наприклад::"

#: ../../distutils/setupscript.rst:300
msgid "is the equivalent of having this at the top of every C source file::"
msgstr ""
"це еквівалент розміщення цього у верхній частині кожного вихідного файлу C::"

#: ../../distutils/setupscript.rst:309
msgid "Library options"
msgstr "Параметри бібліотеки"

#: ../../distutils/setupscript.rst:311
msgid ""
"You can also specify the libraries to link against when building your "
"extension, and the directories to search for those libraries.  The "
"``libraries`` option is a list of libraries to link against, "
"``library_dirs`` is a list of directories to search for libraries at  link-"
"time, and ``runtime_library_dirs`` is a list of directories to  search for "
"shared (dynamically loaded) libraries at run-time."
msgstr ""
"Ви також можете вказати бібліотеки для зв’язування під час створення "
"розширення та каталоги для пошуку цих бібліотек. Параметр ``libraries`` — це"
" список бібліотек, з якими потрібно зв’язатися, ``library_dirs`` — це список"
" каталогів для пошуку бібліотек під час підключення, а "
"``runtime_library_dirs`` — це список каталогів для пошуку спільних "
"(динамічно завантажувані) бібліотеки під час виконання."

#: ../../distutils/setupscript.rst:317
msgid ""
"For example, if you need to link against libraries known to be in the "
"standard library search path on target systems ::"
msgstr ""
"Наприклад, якщо вам потрібно зв’язатися з бібліотеками, які, як відомо, "
"знаходяться в стандартному шляху пошуку бібліотек у цільових системах ::"

#: ../../distutils/setupscript.rst:323
msgid ""
"If you need to link with libraries in a non-standard location, you'll have "
"to include the location in ``library_dirs``::"
msgstr ""
"Якщо вам потрібно зв’язатися з бібліотеками в нестандартному розташуванні, "
"вам доведеться включити це розташування в ``library_dirs``::"

#: ../../distutils/setupscript.rst:330
msgid ""
"(Again, this sort of non-portable construct should be avoided if you intend "
"to distribute your code.)"
msgstr ""
"(Знову ж таки, такого роду непереносимих конструкцій слід уникати, якщо ви "
"маєте намір поширювати свій код.)"

#: ../../distutils/setupscript.rst:337
msgid "Other options"
msgstr "Інші варіанти"

#: ../../distutils/setupscript.rst:339
msgid ""
"There are still some other options which can be used to handle special "
"cases."
msgstr ""
"Є ще деякі інші параметри, які можна використовувати для обробки особливих "
"випадків."

#: ../../distutils/setupscript.rst:341
msgid ""
"The ``optional`` option is a boolean; if it is true, a build failure in the "
"extension will not abort the build process, but instead simply not install "
"the failing extension."
msgstr ""
"Параметр ``optional`` є логічним; якщо це правда, помилка збірки в "
"розширенні не призведе до переривання процесу збірки, а натомість просто не "
"встановить помилкове розширення."

#: ../../distutils/setupscript.rst:345
msgid ""
"The ``extra_objects`` option is a list of object files to be passed to the "
"linker. These files must not have extensions, as the default extension for "
"the compiler is used."
msgstr ""
"Параметр ``extra_objects`` - це список об'єктних файлів, які будуть передані"
" компонувальнику. Ці файли не повинні мати розширень, оскільки "
"використовується розширення за замовчуванням для компілятора."

#: ../../distutils/setupscript.rst:349
msgid ""
"``extra_compile_args`` and ``extra_link_args`` can be used to specify "
"additional command line options for the respective compiler and linker "
"command lines."
msgstr ""
"``extra_compile_args`` і ``extra_link_args`` можна використовувати для "
"визначення додаткових параметрів командного рядка для відповідних командних "
"рядків компілятора та компонувальника."

#: ../../distutils/setupscript.rst:353
msgid ""
"``export_symbols`` is only useful on Windows.  It can contain a list of "
"symbols (functions or variables) to be exported. This option is not needed "
"when building compiled extensions: Distutils  will automatically add "
"``initmodule`` to the list of exported symbols."
msgstr ""
"``export_symbols`` корисний лише в Windows. Він може містити список символів"
" (функцій або змінних), які потрібно експортувати. Ця опція не потрібна під "
"час створення скомпільованих розширень: Distutils автоматично додасть "
"``initmodule`` до списку експортованих символів."

#: ../../distutils/setupscript.rst:358
msgid ""
"The ``depends`` option is a list of files that the extension depends on (for"
" example header files). The build command will call the compiler on the "
"sources to rebuild extension if any on this files has been modified since "
"the previous build."
msgstr ""
"Параметр ``depends`` — це список файлів, від яких залежить розширення "
"(наприклад, файли заголовків). Команда збірки викличе компілятор вихідних "
"кодів, щоб відновити розширення, якщо якісь у цих файлах було змінено з часу"
" попередньої збірки."

#: ../../distutils/setupscript.rst:364
msgid "Relationships between Distributions and Packages"
msgstr "Відносини між дистрибутивами та пакетами"

#: ../../distutils/setupscript.rst:366
msgid "A distribution may relate to packages in three specific ways:"
msgstr "Розповсюдження може стосуватися пакетів трьома конкретними способами:"

#: ../../distutils/setupscript.rst:368
msgid "It can require packages or modules."
msgstr "Для цього можуть знадобитися пакети або модулі."

#: ../../distutils/setupscript.rst:370
msgid "It can provide packages or modules."
msgstr "Він може надавати пакети або модулі."

#: ../../distutils/setupscript.rst:372
msgid "It can obsolete packages or modules."
msgstr "Це може застаріти пакети або модулі."

#: ../../distutils/setupscript.rst:374
msgid ""
"These relationships can be specified using keyword arguments to the "
":func:`distutils.core.setup` function."
msgstr ""
"Ці зв’язки можна вказати за допомогою ключових аргументів функції "
":func:`distutils.core.setup`."

#: ../../distutils/setupscript.rst:377
msgid ""
"Dependencies on other Python modules and packages can be specified by "
"supplying the *requires* keyword argument to :func:`setup`. The value must "
"be a list of strings.  Each string specifies a package that is required, and"
" optionally what versions are sufficient."
msgstr ""
"Залежності від інших модулів і пакетів Python можна вказати, надавши "
"аргумент ключового слова *requires* для :func:`setup`. Значення має бути "
"списком рядків. Кожен рядок визначає необхідний пакет і, за бажанням, "
"достатні версії."

#: ../../distutils/setupscript.rst:382
msgid ""
"To specify that any version of a module or package is required, the string "
"should consist entirely of the module or package name. Examples include "
"``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr ""
"Щоб вказати, що потрібна будь-яка версія модуля чи пакета, рядок має "
"повністю складатися з назви модуля чи пакета. Приклади включають "
"``'mymodule`` і ``'xml.parsers.expat''``."

#: ../../distutils/setupscript.rst:386
msgid ""
"If specific versions are required, a sequence of qualifiers can be supplied "
"in parentheses.  Each qualifier may consist of a comparison operator and a "
"version number.  The accepted comparison operators are::"
msgstr ""
"Якщо потрібні певні версії, у дужках можна вказати послідовність "
"кваліфікаторів. Кожен кваліфікатор може складатися з оператора порівняння та"
" номера версії. Прийнятні оператори порівняння:"

#: ../../distutils/setupscript.rst:393
msgid ""
"These can be combined by using multiple qualifiers separated by commas (and "
"optional whitespace).  In this case, all of the qualifiers must be matched; "
"a logical AND is used to combine the evaluations."
msgstr ""
"Їх можна комбінувати за допомогою кількох кваліфікаторів, розділених комами "
"(і необов’язковими пробілами). У цьому випадку всі кваліфікатори повинні "
"збігатися; логічне І використовується для об’єднання оцінок."

#: ../../distutils/setupscript.rst:397
msgid "Let's look at a bunch of examples:"
msgstr "Давайте розглянемо кілька прикладів:"

#: ../../distutils/setupscript.rst:400
msgid "Requires Expression"
msgstr "Вимагає експресії"

#: ../../distutils/setupscript.rst:400 ../../distutils/setupscript.rst:418
msgid "Explanation"
msgstr "Пояснення"

#: ../../distutils/setupscript.rst:402
msgid "``==1.0``"
msgstr "``==1,0``"

#: ../../distutils/setupscript.rst:402
msgid "Only version ``1.0`` is compatible"
msgstr "Лише версія ``1.0`` сумісна"

#: ../../distutils/setupscript.rst:404
msgid "``>1.0, !=1.5.1, <2.0``"
msgstr "``>1.0, !=1.5.1, <2.0``"

#: ../../distutils/setupscript.rst:404
msgid ""
"Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``"
msgstr "Будь-яка версія після ``1.0`` і до ``2.0`` сумісна, крім ``1.5.1``"

#: ../../distutils/setupscript.rst:408
msgid ""
"Now that we can specify dependencies, we also need to be able to specify "
"what we provide that other distributions can require.  This is done using "
"the *provides* keyword argument to :func:`setup`. The value for this keyword"
" is a list of strings, each of which names a Python module or package, and "
"optionally identifies the version.  If the version is not specified, it is "
"assumed to match that of the distribution."
msgstr ""
"Тепер, коли ми можемо вказати залежності, нам також потрібно мати можливість"
" вказати, що ми надаємо, що можуть вимагати інші дистрибутиви. Це робиться "
"за допомогою ключового аргументу *provides* для :func:`setup`. Значення "
"цього ключового слова — це список рядків, кожен з яких іменує модуль або "
"пакет Python і, за бажанням, визначає версію. Якщо версія не вказана, "
"вважається, що вона відповідає версії дистрибутива."

#: ../../distutils/setupscript.rst:415
msgid "Some examples:"
msgstr "Деякі приклади:"

#: ../../distutils/setupscript.rst:418
msgid "Provides Expression"
msgstr "Забезпечує експресію"

#: ../../distutils/setupscript.rst:420
msgid "``mypkg``"
msgstr "``mypkg``"

#: ../../distutils/setupscript.rst:420
msgid "Provide ``mypkg``, using the distribution version"
msgstr "Надайте ``mypkg``, використовуючи версію розповсюдження"

#: ../../distutils/setupscript.rst:423
msgid "``mypkg (1.1)``"
msgstr "``mypkg (1.1)``"

#: ../../distutils/setupscript.rst:423
msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr "Надайте ``mypkg`` версії 1.1, незалежно від версії дистрибутива"

#: ../../distutils/setupscript.rst:427
msgid ""
"A package can declare that it obsoletes other packages using the *obsoletes*"
" keyword argument.  The value for this is similar to that of the *requires* "
"keyword: a list of strings giving module or package specifiers.  Each "
"specifier consists of a module or package name optionally followed by one or"
" more version qualifiers.  Version qualifiers are given in parentheses after"
" the module or package name."
msgstr ""
"Пакунок може оголосити, що він застарів іншим пакункам за допомогою "
"аргументу ключового слова *obsoletes*. Значення для цього подібне до "
"значення ключового слова *requires*: список рядків, що надають специфікатори"
" модуля або пакета. Кожен специфікатор складається з назви модуля або "
"пакета, за якою необов’язково слідують один або більше кваліфікаторів "
"версії. Специфікатори версії наведені в круглих дужках після назви модуля "
"або пакета."

#: ../../distutils/setupscript.rst:434
msgid ""
"The versions identified by the qualifiers are those that are obsoleted by "
"the distribution being described.  If no qualifiers are given, all versions "
"of the named module or package are understood to be obsoleted."
msgstr ""
"Версії, визначені кваліфікаторами, є тими, які застаріли через описуваний "
"розподіл. Якщо кваліфікатори не вказано, усі версії названого модуля або "
"пакета вважаються застарілими."

#: ../../distutils/setupscript.rst:441
msgid "Installing Scripts"
msgstr "Встановлення скриптів"

#: ../../distutils/setupscript.rst:443
msgid ""
"So far we have been dealing with pure and non-pure Python modules, which are"
" usually not run by themselves but imported by scripts."
msgstr ""
"Поки що ми мали справу з чистими та нечистими модулями Python, які зазвичай "
"не запускаються самостійно, а імпортуються за допомогою сценаріїв."

#: ../../distutils/setupscript.rst:446
msgid ""
"Scripts are files containing Python source code, intended to be started from"
" the command line.  Scripts don't require Distutils to do anything very "
"complicated. The only clever feature is that if the first line of the script"
" starts with ``#!`` and contains the word \"python\", the Distutils will "
"adjust the first line to refer to the current interpreter location. By "
"default, it is replaced with the current interpreter location.  The "
":option:`!--executable` (or :option:`!-e`) option will allow the interpreter"
" path to be explicitly overridden."
msgstr ""
"Сценарії — це файли, що містять вихідний код Python і призначені для запуску"
" з командного рядка. Сценарії не вимагають від Distutils виконання чогось "
"дуже складного. Єдина розумна функція полягає в тому, що якщо перший рядок "
"сценарію починається з ``#!`` і містить слово \"python\", Distutils "
"відкоригує перший рядок відповідно до поточного розташування інтерпретатора."
" За замовчуванням його замінено на поточне розташування інтерпретатора. "
"Параметр :option:`!--executable` (або :option:`!-e`) дозволить явно "
"перевизначати шлях інтерпретатора."

#: ../../distutils/setupscript.rst:454
msgid ""
"The ``scripts`` option simply is a list of files to be handled in this way."
"  From the PyXML setup script::"
msgstr ""
"Параметр ``scripts`` — це просто список файлів, які потрібно обробляти таким"
" чином. Зі сценарію налаштування PyXML::"

#: ../../distutils/setupscript.rst:461
msgid ""
"All the scripts will also be added to the ``MANIFEST`` file if no template "
"is provided.  See :ref:`manifest`."
msgstr ""
"Усі сценарії також буде додано до файлу ``MANIFEST``, якщо шаблон не надано."
" Див. :ref:`manifest`."

#: ../../distutils/setupscript.rst:469
msgid "Installing Package Data"
msgstr "Встановлення пакетних даних"

#: ../../distutils/setupscript.rst:471
msgid ""
"Often, additional files need to be installed into a package.  These files "
"are often data that's closely related to the package's implementation, or "
"text files containing documentation that might be of interest to programmers"
" using the package.  These files are called :dfn:`package data`."
msgstr ""
"Часто в пакет потрібно інсталювати додаткові файли. Ці файли часто є даними,"
" тісно пов’язаними з реалізацією пакета, або текстовими файлами, що містять "
"документацію, яка може зацікавити програмістів, які використовують пакет. Ці"
" файли називаються :dfn:`package data`."

#: ../../distutils/setupscript.rst:476
msgid ""
"Package data can be added to packages using the ``package_data`` keyword "
"argument to the :func:`setup` function.  The value must be a mapping from "
"package name to a list of relative path names that should be copied into the"
" package.  The paths are interpreted as relative to the directory containing"
" the package (information from the ``package_dir`` mapping is used if "
"appropriate); that is, the files are expected to be part of the package in "
"the source directories. They may contain glob patterns as well."
msgstr ""
"Дані пакетів можна додати до пакетів за допомогою ключового аргументу "
"``package_data`` функції :func:`setup`. Значення має бути зіставленням назви"
" пакета зі списком відносних імен шляхів, які слід скопіювати в пакет. Шляхи"
" інтерпретуються як відносні до каталогу, що містить пакунок (інформація з "
"відображення ``package_dir`` використовується, якщо це доречно); тобто "
"очікується, що файли будуть частиною пакета у вихідних каталогах. Вони також"
" можуть містити глобуси."

#: ../../distutils/setupscript.rst:484
msgid ""
"The path names may contain directory portions; any necessary directories "
"will be created in the installation."
msgstr ""
"Назви шляхів можуть містити частини каталогу; усі необхідні каталоги будуть "
"створені під час встановлення."

#: ../../distutils/setupscript.rst:487
msgid ""
"For example, if a package should contain a subdirectory with several data "
"files, the files can be arranged like this in the source tree::"
msgstr ""
"Наприклад, якщо пакунок має містити підкаталог із кількома файлами даних, "
"файли можна розташувати таким чином у вихідному дереві:"

#: ../../distutils/setupscript.rst:500
msgid "The corresponding call to :func:`setup` might be::"
msgstr "Відповідний виклик :func:`setup` може бути::"

#: ../../distutils/setupscript.rst:509
msgid ""
"All the files that match ``package_data`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"Усі файли, які відповідають ``package_data``, будуть додані до ``MANIFEST`` "
"файлу, якщо шаблон не надано. Див. :ref:`manifest`."

#: ../../distutils/setupscript.rst:517
msgid "Installing Additional Files"
msgstr "Встановлення додаткових файлів"

#: ../../distutils/setupscript.rst:519
msgid ""
"The ``data_files`` option can be used to specify additional files needed by "
"the module distribution: configuration files, message catalogs, data files, "
"anything which doesn't fit in the previous categories."
msgstr ""
"Параметр ``data_files`` можна використовувати для визначення додаткових "
"файлів, необхідних для розповсюдження модуля: конфігураційні файли, каталоги"
" повідомлень, файли даних, будь-що, що не підходить до попередніх категорій."

#: ../../distutils/setupscript.rst:523
msgid ""
"``data_files`` specifies a sequence of (*directory*, *files*) pairs in the "
"following way::"
msgstr ""
"``data_files`` визначає послідовність пар (*каталог*, *файли*) таким чином:"

#: ../../distutils/setupscript.rst:531
msgid ""
"Each (*directory*, *files*) pair in the sequence specifies the installation "
"directory and the files to install there."
msgstr ""
"Кожна пара (*каталог*, *файли*) у послідовності визначає каталог інсталяції "
"та файли для інсталяції."

#: ../../distutils/setupscript.rst:534
msgid ""
"Each file name in *files* is interpreted relative to the :file:`setup.py` "
"script at the top of the package source distribution. Note that you can "
"specify the directory where the data files will be installed, but you cannot"
" rename the data files themselves."
msgstr ""
"Кожне ім’я файлу в *files* інтерпретується відносно сценарію "
":file:`setup.py` у верхній частині вихідного коду пакета. Зверніть увагу, що"
" ви можете вказати каталог, куди будуть встановлені файли даних, але ви не "
"можете перейменувати самі файли даних."

#: ../../distutils/setupscript.rst:539
msgid ""
"The *directory* should be a relative path. It is interpreted relative to the"
" installation prefix (Python's ``sys.prefix`` for system installations; "
"``site.USER_BASE`` for user installations). Distutils allows *directory* to "
"be an absolute installation path, but this is discouraged since it is "
"incompatible with the wheel packaging format. No directory information from "
"*files* is used to determine the final location of the installed file; only "
"the name of the file is used."
msgstr ""
"*Каталог* має бути відносним шляхом. Він інтерпретується відносно префікса "
"встановлення (``sys.prefix`` Python для системних установок; "
"``site.USER_BASE`` для установок користувача). Distutils дозволяє *каталог* "
"бути абсолютним шляхом встановлення, але це не рекомендується, оскільки це "
"несумісно з форматом упаковки коліс. Для визначення кінцевого розташування "
"встановленого файлу інформація про каталог із *файлів* не використовується; "
"використовується лише ім'я файлу."

#: ../../distutils/setupscript.rst:547
msgid ""
"You can specify the ``data_files`` options as a simple sequence of files "
"without specifying a target directory, but this is not recommended, and the "
":command:`install` command will print a warning in this case. To install "
"data files directly in the target directory, an empty string should be given"
" as the directory."
msgstr ""
"Ви можете вказати параметри ``data_files`` як просту послідовність файлів "
"без вказівки цільового каталогу, але це не рекомендується, і команда "
":command:`install` у цьому випадку виведе попередження. Щоб установити файли"
" даних безпосередньо в цільовий каталог, як каталог слід вказати порожній "
"рядок."

#: ../../distutils/setupscript.rst:553
msgid ""
"All the files that match ``data_files`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr ""
"Усі файли, які відповідають ``data_files``, будуть додані до ``MANIFEST`` "
"файлу, якщо шаблон не надано. Див. :ref:`manifest`."

#: ../../distutils/setupscript.rst:561
msgid "Additional meta-data"
msgstr "Додаткові метадані"

#: ../../distutils/setupscript.rst:563
msgid ""
"The setup script may include additional meta-data beyond the name and "
"version. This information includes:"
msgstr ""
"Сценарій налаштування може містити додаткові метадані, окрім імені та "
"версії. Ця інформація включає:"

#: ../../distutils/setupscript.rst:567
msgid "Meta-Data"
msgstr "Мета-дані"

#: ../../distutils/setupscript.rst:567
msgid "Description"
msgstr "опис"

#: ../../distutils/setupscript.rst:567
msgid "Value"
msgstr "Значення"

#: ../../distutils/setupscript.rst:567
msgid "Notes"
msgstr "Примітки"

#: ../../distutils/setupscript.rst:569
msgid "``name``"
msgstr "``ім'я``"

#: ../../distutils/setupscript.rst:569
msgid "name of the package"
msgstr "назву пакета"

#: ../../distutils/setupscript.rst:569 ../../distutils/setupscript.rst:571
#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:578
#: ../../distutils/setupscript.rst:585 ../../distutils/setupscript.rst:601
msgid "short string"
msgstr "короткий рядок"

#: ../../distutils/setupscript.rst:569 ../../distutils/setupscript.rst:583
msgid "\\(1)"
msgstr "\\(1)"

#: ../../distutils/setupscript.rst:571
msgid "``version``"
msgstr "``версія``"

#: ../../distutils/setupscript.rst:571
msgid "version of this release"
msgstr "версія цього випуску"

#: ../../distutils/setupscript.rst:571
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../distutils/setupscript.rst:573
msgid "``author``"
msgstr "``автор``"

#: ../../distutils/setupscript.rst:573
msgid "package author's name"
msgstr "ім'я автора пакета"

#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:575
#: ../../distutils/setupscript.rst:578 ../../distutils/setupscript.rst:580
msgid "\\(3)"
msgstr "\\(3)"

#: ../../distutils/setupscript.rst:575
msgid "``author_email``"
msgstr "``author_email``"

#: ../../distutils/setupscript.rst:575
msgid "email address of the package author"
msgstr "адреса електронної пошти автора пакета"

#: ../../distutils/setupscript.rst:575 ../../distutils/setupscript.rst:580
msgid "email address"
msgstr "адреса електронної пошти"

#: ../../distutils/setupscript.rst:578
msgid "``maintainer``"
msgstr "``підтримувач``"

#: ../../distutils/setupscript.rst:578
msgid "package maintainer's name"
msgstr "ім'я супроводжуючого пакета"

#: ../../distutils/setupscript.rst:580
msgid "``maintainer_email``"
msgstr "``maintainer_email``"

#: ../../distutils/setupscript.rst:580
msgid "email address of the package maintainer"
msgstr "адреса електронної пошти супроводжуючого пакет"

#: ../../distutils/setupscript.rst:583
msgid "``url``"
msgstr "``url``"

#: ../../distutils/setupscript.rst:583
msgid "home page for the package"
msgstr "домашня сторінка для пакета"

#: ../../distutils/setupscript.rst:583 ../../distutils/setupscript.rst:592
msgid "URL"
msgstr "URL"

#: ../../distutils/setupscript.rst:585
msgid "``description``"
msgstr "``опис``"

#: ../../distutils/setupscript.rst:585
msgid "short, summary description of the package"
msgstr "короткий короткий опис пакету"

#: ../../distutils/setupscript.rst:589
msgid "``long_description``"
msgstr "``довгий_опис``"

#: ../../distutils/setupscript.rst:589
msgid "longer description of the package"
msgstr "додатковий опис пакета"

#: ../../distutils/setupscript.rst:589
msgid "long string"
msgstr "довгий рядок"

#: ../../distutils/setupscript.rst:589
msgid "\\(4)"
msgstr "\\(4)"

#: ../../distutils/setupscript.rst:592
msgid "``download_url``"
msgstr "URL-адреса_завантаження"

#: ../../distutils/setupscript.rst:592
msgid "location where the package may be downloaded"
msgstr "місце, де можна завантажити пакет"

#: ../../distutils/setupscript.rst:595
msgid "``classifiers``"
msgstr "``класифікатори``"

#: ../../distutils/setupscript.rst:595
msgid "a list of classifiers"
msgstr "список класифікаторів"

#: ../../distutils/setupscript.rst:595 ../../distutils/setupscript.rst:597
#: ../../distutils/setupscript.rst:599
msgid "list of strings"
msgstr "список рядків"

#: ../../distutils/setupscript.rst:595
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../distutils/setupscript.rst:597
msgid "``platforms``"
msgstr "``платформи``"

#: ../../distutils/setupscript.rst:597
msgid "a list of platforms"
msgstr "список платформ"

#: ../../distutils/setupscript.rst:597 ../../distutils/setupscript.rst:599
msgid "(6)(8)"
msgstr "(6)(8)"

#: ../../distutils/setupscript.rst:599
msgid "``keywords``"
msgstr "``ключові слова``"

#: ../../distutils/setupscript.rst:599
msgid "a list of keywords"
msgstr "список ключових слів"

#: ../../distutils/setupscript.rst:601
msgid "``license``"
msgstr "``ліцензія``"

#: ../../distutils/setupscript.rst:601
msgid "license for the package"
msgstr "ліцензія на пакет"

#: ../../distutils/setupscript.rst:601
msgid "\\(5)"
msgstr "\\(5)"

#: ../../distutils/setupscript.rst:604
msgid "Notes:"
msgstr "Примітки:"

#: ../../distutils/setupscript.rst:607
msgid "These fields are required."
msgstr "Ці поля є обов’язковими."

#: ../../distutils/setupscript.rst:610
msgid ""
"It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr "Рекомендується, щоб версії мали форму *major.minor[.patch[.sub]]*."

#: ../../distutils/setupscript.rst:613
msgid ""
"Either the author or the maintainer must be identified. If maintainer is "
"provided, distutils lists it as the author in :file:`PKG-INFO`."
msgstr ""
"Має бути ідентифікований або автор, або супроводжувач. Якщо вказано "
"супроводжуючого, distutils вказує його як автора в :file:`PKG-INFO`."

#: ../../distutils/setupscript.rst:617
msgid ""
"The ``long_description`` field is used by PyPI when you publish a package, "
"to build its project page."
msgstr ""
"Поле ``long_description`` використовується PyPI, коли ви публікуєте пакет, "
"для створення його сторінки проекту."

#: ../../distutils/setupscript.rst:621
msgid ""
"The ``license`` field is a text indicating the license covering the package "
"where the license is not a selection from the \"License\" Trove classifiers."
" See the ``Classifier`` field. Notice that there's a ``licence`` "
"distribution option which is deprecated but still acts as an alias for "
"``license``."
msgstr ""
"Поле \"ліцензія\" — це текст, що вказує на ліцензію, що охоплює пакет, де "
"ліцензія не є вибором із класифікаторів Trove \"Ліцензії\". Перегляньте поле"
" ``Класифікатор``. Зауважте, що існує опція розповсюдження ``ліцензія``, яка"
" є застарілою, але все ще діє як псевдонім для ``ліцензії``."

#: ../../distutils/setupscript.rst:628
msgid "This field must be a list."
msgstr "Це поле має бути списком."

#: ../../distutils/setupscript.rst:631
msgid ""
"The valid classifiers are listed on `PyPI <https://pypi.org/classifiers>`_."
msgstr ""
"Дійсні класифікатори перераховані на `PyPI <https://pypi.org/classifiers>`_."

#: ../../distutils/setupscript.rst:635
msgid ""
"To preserve backward compatibility, this field also accepts a string. If you"
" pass a comma-separated string ``'foo, bar'``, it will be converted to "
"``['foo', 'bar']``, Otherwise, it will be converted to a list of one string."
msgstr ""
"Щоб зберегти зворотну сумісність, це поле також приймає рядок. Якщо ви "
"передасте розділений комами рядок ``'foo, bar''``, він буде перетворений на "
"``['foo', 'bar']``, інакше він буде перетворений на список з одного рядка."

#: ../../distutils/setupscript.rst:641
msgid "'short string'"
msgstr "'короткий рядок'"

#: ../../distutils/setupscript.rst:641
msgid "A single line of text, not more than 200 characters."
msgstr "Один рядок тексту, не більше 200 символів."

#: ../../distutils/setupscript.rst:645
msgid "'long string'"
msgstr "\"довгий рядок\""

#: ../../distutils/setupscript.rst:644
msgid ""
"Multiple lines of plain text in reStructuredText format (see "
"https://docutils.sourceforge.io/)."
msgstr ""

#: ../../distutils/setupscript.rst:648
msgid "'list of strings'"
msgstr "'список рядків'"

#: ../../distutils/setupscript.rst:648
msgid "See below."
msgstr "Дивіться нижче."

#: ../../distutils/setupscript.rst:650
msgid ""
"Encoding the version information is an art in itself. Python packages "
"generally adhere to the version format *major.minor[.patch][sub]*. The major"
" number is 0 for initial, experimental releases of software. It is "
"incremented for releases that represent major milestones in a package. The "
"minor number is incremented when important new features are added to the "
"package. The patch number increments when bug-fix releases are made. "
"Additional trailing version information is sometimes used to indicate sub-"
"releases.  These are \"a1,a2,...,aN\" (for alpha releases, where "
"functionality and API may change), \"b1,b2,...,bN\" (for beta releases, "
"which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release release "
"testing). Some examples:"
msgstr ""
"Кодування інформації про версію — це саме по собі мистецтво. Пакунки Python "
"зазвичай мають формат версії *major.minor[.patch][sub]*. Основне число — 0 "
"для початкових, експериментальних версій програмного забезпечення. Він "
"збільшується для випусків, які представляють основні віхи в пакеті. Менше "
"число збільшується, коли до пакета додаються важливі нові функції. Номер "
"виправлення збільшується, коли випускаються випуски виправлень помилок. "
"Додаткова кінцева інформація про версію іноді використовується для "
"позначення підрелізів. Це \"a1,a2,...,aN\" (для альфа-версій, де "
"функціональність і API можуть змінюватися), \"b1,b2,...,bN\" (для бета-"
"версій, які лише виправляють помилки) і \"pr1 ,pr2,...,prN\" (для "
"остаточного тестування перед випуском). Деякі приклади:"

#: ../../distutils/setupscript.rst:662
msgid "0.1.0"
msgstr "0.1.0"

#: ../../distutils/setupscript.rst:662
msgid "the first, experimental release of a package"
msgstr "перший, експериментальний випуск пакету"

#: ../../distutils/setupscript.rst:665
msgid "1.0.1a2"
msgstr "1.0.1a2"

#: ../../distutils/setupscript.rst:665
msgid "the second alpha release of the first patch version of 1.0"
msgstr "друга альфа-версія першої версії патча 1.0"

#: ../../distutils/setupscript.rst:667
msgid "``classifiers`` must be specified in a list::"
msgstr "``класифікатори`` повинні бути вказані в списку::"

#: ../../distutils/setupscript.rst:688
msgid ""
":class:`~distutils.core.setup` now warns when ``classifiers``, ``keywords`` "
"or ``platforms`` fields are not specified as a list or a string."
msgstr ""
":class:`~distutils.core.setup` тепер попереджає, коли поля "
"``класифікатори``, ``ключові слова`` або ``платформи`` не вказані як список "
"або рядок."

#: ../../distutils/setupscript.rst:695
msgid "Debugging the setup script"
msgstr "Налагодження сценарію налаштування"

#: ../../distutils/setupscript.rst:697
msgid ""
"Sometimes things go wrong, and the setup script doesn't do what the "
"developer wants."
msgstr ""
"Іноді щось йде не так, і сценарій налаштування не виконує те, що хоче "
"розробник."

#: ../../distutils/setupscript.rst:700
msgid ""
"Distutils catches any exceptions when running the setup script, and print a "
"simple error message before the script is terminated.  The motivation for "
"this behaviour is to not confuse administrators who don't know much about "
"Python and are trying to install a package.  If they get a big long "
"traceback from deep inside the guts of Distutils, they may think the package"
" or the Python installation is broken because they don't read all the way "
"down to the bottom and see that it's a permission problem."
msgstr ""
"Distutils вловлює будь-які винятки під час запуску сценарію налаштування та "
"друкує просте повідомлення про помилку перед завершенням сценарію. Мотивація"
" такої поведінки полягає в тому, щоб не заплутати адміністраторів, які мало "
"знають про Python і намагаються встановити пакет. Якщо вони отримають велике"
" довге відстеження з глибини нутрощів Distutils, вони можуть подумати, що "
"пакет або інсталяція Python зламані, оскільки вони не прочитали весь шлях до"
" кінця й побачать, що це проблема з дозволом."

#: ../../distutils/setupscript.rst:708
msgid ""
"On the other hand, this doesn't help the developer to find the cause of the "
"failure. For this purpose, the :envvar:`DISTUTILS_DEBUG` environment "
"variable can be set to anything except an empty string, and distutils will "
"now print detailed information about what it is doing, dump the full "
"traceback when an exception occurs, and print the whole command line when an"
" external program (like a C compiler) fails."
msgstr ""
"З іншого боку, це не допомагає розробнику знайти причину збою. З цією метою "
"для змінної середовища :envvar:`DISTUTILS_DEBUG` можна встановити будь-яке "
"значення, окрім порожнього рядка, і distutils тепер друкуватиме детальну "
"інформацію про те, що він робить, створюватиме повну трасування, коли "
"станеться виняткова ситуація, і друкуватиме всю команду рядок, коли зовнішня"
" програма (наприклад, компілятор C) дає збій."
