# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Integer Objects"
msgstr "Цілі об'єкти"

msgid ""
"All integers are implemented as \"long\" integer objects of arbitrary size."
msgstr ""
"Усі цілі числа реалізуються як \"довгі\" цілі об’єкти довільного розміру."

msgid ""
"On error, most ``PyLong_As*`` APIs return ``(return type)-1`` which cannot "
"be distinguished from a number.  Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"У разі помилки більшість API ``PyLong_As*`` повертають ``(тип "
"повернення)-1``, який неможливо відрізнити від числа. Використовуйте :c:func:"
"`PyErr_Occurred` для усунення неоднозначності."

msgid "This subtype of :c:type:`PyObject` represents a Python integer object."
msgstr "Цей підтип :c:type:`PyObject` представляє цілочисельний об’єкт Python."

msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python integer type. "
"This is the same object as :class:`int` in the Python layer."
msgstr ""
"Цей екземпляр :c:type:`PyTypeObject` представляє цілочисельний тип Python. "
"Це той самий об’єкт, що й :class:`int` на рівні Python."

msgid ""
"Return true if its argument is a :c:type:`PyLongObject` or a subtype of :c:"
"type:`PyLongObject`.  This function always succeeds."
msgstr ""
"Повертає true, якщо його аргумент є :c:type:`PyLongObject` або підтипом :c:"
"type:`PyLongObject`. Ця функція завжди успішна."

msgid ""
"Return true if its argument is a :c:type:`PyLongObject`, but not a subtype "
"of :c:type:`PyLongObject`.  This function always succeeds."
msgstr ""
"Повертає true, якщо його аргумент є :c:type:`PyLongObject`, але не підтипом :"
"c:type:`PyLongObject`. Ця функція завжди успішна."

msgid ""
"Return a new :c:type:`PyLongObject` object from *v*, or ``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` з *v* або ``NULL`` у разі "
"помилки."

msgid ""
"The current implementation keeps an array of integer objects for all "
"integers between ``-5`` and ``256``. When you create an int in that range "
"you actually just get back a reference to the existing object."
msgstr ""
"Поточна реалізація зберігає масив цілих об’єктів для всіх цілих чисел від "
"``-5`` до ``256``. Коли ви створюєте int у цьому діапазоні, ви фактично "
"повертаєте посилання на існуючий об’єкт."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`unsigned long`, "
"or ``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` із C :c:type:`unsigned long` "
"або ``NULL`` у разі помилки."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`Py_ssize_t`, or "
"``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` із C :c:type:`Py_ssize_t` або "
"``NULL`` у разі помилки."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`size_t`, or "
"``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` із C :c:type:`size_t` або "
"``NULL`` у разі помилки."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`long long`, or "
"``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` із C :c:type:`long long` або "
"``NULL`` у разі помилки."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`unsigned long "
"long`, or ``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` із C :c:type:`unsigned long "
"long` або ``NULL`` у разі помилки."

msgid ""
"Return a new :c:type:`PyLongObject` object from the integer part of *v*, or "
"``NULL`` on failure."
msgstr ""
"Повертає новий об’єкт :c:type:`PyLongObject` із цілої частини *v* або "
"``NULL`` у разі помилки."

msgid ""
"Return a new :c:type:`PyLongObject` based on the string value in *str*, "
"which is interpreted according to the radix in *base*.  If *pend* is non-"
"``NULL``, *\\*pend* will point to the first character in *str* which follows "
"the representation of the number.  If *base* is ``0``, *str* is interpreted "
"using the :ref:`integers` definition; in this case, leading zeros in a non-"
"zero decimal number raises a :exc:`ValueError`. If *base* is not ``0``, it "
"must be between ``2`` and ``36``, inclusive.  Leading spaces and single "
"underscores after a base specifier and between digits are ignored.  If there "
"are no digits, :exc:`ValueError` will be raised."
msgstr ""
"Повертає новий :c:type:`PyLongObject` на основі значення рядка в *str*, яке "
"інтерпретується відповідно до основи в *base*. Якщо *pend* не є ``NULL``, "
"*\\*pend* вказуватиме на перший символ у *str*, який слідує за "
"представленням числа. Якщо *base* дорівнює ``0``, *str* інтерпретується за "
"допомогою визначення :ref:`integers`; у цьому випадку нулі на початку "
"ненульового десяткового числа викликають :exc:`ValueError`. Якщо *база* не "
"дорівнює ``0``, вона має бути між ``2`` і ``36`` включно. Початкові пробіли "
"та одинарне підкреслення після базового специфікатора та між цифрами "
"ігноруються. Якщо цифр немає, буде викликано :exc:`ValueError`."

msgid ""
"Convert a sequence of Unicode digits in the string *u* to a Python integer "
"value."
msgstr ""
"Перетворіть послідовність цифр Unicode у рядку *u* на ціле число Python."

msgid ""
"Create a Python integer from the pointer *p*. The pointer value can be "
"retrieved from the resulting value using :c:func:`PyLong_AsVoidPtr`."
msgstr ""
"Створіть ціле число Python із покажчика *p*. Значення вказівника можна "
"отримати з результуючого значення за допомогою :c:func:`PyLong_AsVoidPtr`."

msgid ""
"Return a C :c:type:`long` representation of *obj*.  If *obj* is not an "
"instance of :c:type:`PyLongObject`, first call its :meth:`__index__` method "
"(if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`long` представлення *obj*. Якщо *obj* не є екземпляром :"
"c:type:`PyLongObject`, спочатку викличте його метод :meth:`__index__` (якщо "
"є), щоб перетворити його на :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *obj* is out of range for a :c:"
"type:`long`."
msgstr ""
"Викликати :exc:`OverflowError`, якщо значення *obj* виходить за межі "
"діапазону для :c:type:`long`."

msgid "Returns ``-1`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"Повертає ``-1`` у разі помилки. Використовуйте :c:func:`PyErr_Occurred` для "
"усунення неоднозначності."

msgid "Use :meth:`__index__` if available."
msgstr "Використовуйте :meth:`__index__`, якщо доступний."

msgid "This function will no longer use :meth:`__int__`."
msgstr "Ця функція більше не використовуватиме :meth:`__int__`."

msgid ""
"If the value of *obj* is greater than :const:`LONG_MAX` or less than :const:"
"`LONG_MIN`, set *\\*overflow* to ``1`` or ``-1``, respectively, and return "
"``-1``; otherwise, set *\\*overflow* to ``0``.  If any other exception "
"occurs set *\\*overflow* to ``0`` and return ``-1`` as usual."
msgstr ""
"Якщо значення *obj* більше за :const:`LONG_MAX` або менше за :const:"
"`LONG_MIN`, установіть для *\\*overflow* значення ``1`` або ``-1`` "
"відповідно та поверніть ``-1``; інакше встановіть *\\*overflow* на ``0``. "
"Якщо виникає будь-який інший виняток, встановіть *\\*overflow* на ``0`` і "
"поверніть ``-1``, як зазвичай."

msgid ""
"Return a C :c:type:`long long` representation of *obj*.  If *obj* is not an "
"instance of :c:type:`PyLongObject`, first call its :meth:`__index__` method "
"(if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`long long` представлення *obj*. Якщо *obj* не є "
"екземпляром :c:type:`PyLongObject`, спочатку викличте його метод :meth:"
"`__index__` (якщо є), щоб перетворити його на :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *obj* is out of range for a :c:"
"type:`long long`."
msgstr ""
"Викликати :exc:`OverflowError`, якщо значення *obj* виходить за межі "
"діапазону для :c:type:`long long`."

msgid ""
"If the value of *obj* is greater than :const:`LLONG_MAX` or less than :const:"
"`LLONG_MIN`, set *\\*overflow* to ``1`` or ``-1``, respectively, and return "
"``-1``; otherwise, set *\\*overflow* to ``0``.  If any other exception "
"occurs set *\\*overflow* to ``0`` and return ``-1`` as usual."
msgstr ""
"Якщо значення *obj* більше за :const:`LLONG_MAX` або менше за :const:"
"`LLONG_MIN`, установіть для *\\*overflow* значення ``1`` або ``-1`` "
"відповідно та поверніть ``-1``; інакше встановіть *\\*overflow* на ``0``. "
"Якщо виникає будь-який інший виняток, встановіть *\\*overflow* на ``0`` і "
"поверніть ``-1``, як зазвичай."

msgid ""
"Return a C :c:type:`Py_ssize_t` representation of *pylong*.  *pylong* must "
"be an instance of :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`Py_ssize_t` представлення *pylong*. *pylong* має бути "
"екземпляром :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"type:`Py_ssize_t`."
msgstr ""
"Викликайте :exc:`OverflowError`, якщо значення *pylong* виходить за межі "
"діапазону для :c:type:`Py_ssize_t`."

msgid ""
"Return a C :c:type:`unsigned long` representation of *pylong*.  *pylong* "
"must be an instance of :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`unsigned long` представлення *pylong*. *pylong* має бути "
"екземпляром :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"type:`unsigned long`."
msgstr ""
"Викликати :exc:`OverflowError`, якщо значення *pylong* виходить за межі "
"діапазону для :c:type:`unsigned long`."

msgid ""
"Returns ``(unsigned long)-1`` on error. Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"У разі помилки повертає ``(unsigned long)-1``. Використовуйте :c:func:"
"`PyErr_Occurred` для усунення неоднозначності."

msgid ""
"Return a C :c:type:`size_t` representation of *pylong*.  *pylong* must be an "
"instance of :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`size_t` представлення *pylong*. *pylong* має бути "
"екземпляром :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"type:`size_t`."
msgstr ""
"Викликайте :exc:`OverflowError`, якщо значення *pylong* виходить за межі "
"діапазону для :c:type:`size_t`."

msgid ""
"Returns ``(size_t)-1`` on error. Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"Повертає ``(size_t)-1`` у разі помилки. Використовуйте :c:func:"
"`PyErr_Occurred` для усунення неоднозначності."

msgid ""
"Return a C :c:type:`unsigned long long` representation of *pylong*.  "
"*pylong* must be an instance of :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`unsigned long long` представлення *pylong*. *pylong* має "
"бути екземпляром :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for an :"
"c:type:`unsigned long long`."
msgstr ""
"Викликайте :exc:`OverflowError`, якщо значення *pylong* виходить за межі "
"діапазону для :c:type:`unsigned long long`."

msgid ""
"Returns ``(unsigned long long)-1`` on error. Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"У разі помилки повертає ``(unsigned long long)-1``. Використовуйте :c:func:"
"`PyErr_Occurred` для усунення неоднозначності."

msgid ""
"A negative *pylong* now raises :exc:`OverflowError`, not :exc:`TypeError`."
msgstr ""
"Негативний *pylong* тепер викликає :exc:`OverflowError`, а не :exc:"
"`TypeError`."

msgid ""
"Return a C :c:type:`unsigned long` representation of *obj*.  If *obj* is not "
"an instance of :c:type:`PyLongObject`, first call its :meth:`__index__` "
"method (if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`unsigned long` представлення *obj*. Якщо *obj* не є "
"екземпляром :c:type:`PyLongObject`, спочатку викличте його метод :meth:"
"`__index__` (якщо є), щоб перетворити його на :c:type:`PyLongObject`."

msgid ""
"If the value of *obj* is out of range for an :c:type:`unsigned long`, return "
"the reduction of that value modulo ``ULONG_MAX + 1``."
msgstr ""
"Якщо значення *obj* виходить за межі діапазону для :c:type:`unsigned long`, "
"поверніть зменшення цього значення за модулем ``ULONG_MAX + 1``."

msgid ""
"Returns ``(unsigned long)-1`` on error.  Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"У разі помилки повертає ``(unsigned long)-1``. Використовуйте :c:func:"
"`PyErr_Occurred` для усунення неоднозначності."

msgid ""
"Return a C :c:type:`unsigned long long` representation of *obj*.  If *obj* "
"is not an instance of :c:type:`PyLongObject`, first call its :meth:"
"`__index__` method (if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`unsigned long long` представлення *obj*. Якщо *obj* не є "
"екземпляром :c:type:`PyLongObject`, спочатку викличте його метод :meth:"
"`__index__` (якщо є), щоб перетворити його на :c:type:`PyLongObject`."

msgid ""
"If the value of *obj* is out of range for an :c:type:`unsigned long long`, "
"return the reduction of that value modulo ``ULLONG_MAX + 1``."
msgstr ""
"Якщо значення *obj* виходить за межі діапазону для :c:type:`unsigned long "
"long`, поверніть зменшення цього значення за модулем ``ULLONG_MAX + 1``."

msgid ""
"Returns ``(unsigned long long)-1`` on error.  Use :c:func:`PyErr_Occurred` "
"to disambiguate."
msgstr ""
"У разі помилки повертає ``(unsigned long long)-1``. Використовуйте :c:func:"
"`PyErr_Occurred` для усунення неоднозначності."

msgid ""
"Return a C :c:type:`double` representation of *pylong*.  *pylong* must be an "
"instance of :c:type:`PyLongObject`."
msgstr ""
"Повертає C :c:type:`double` представлення *pylong*. *pylong* має бути "
"екземпляром :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"type:`double`."
msgstr ""
"Викликайте :exc:`OverflowError`, якщо значення *pylong* виходить за межі "
"діапазону для :c:type:`double`."

msgid ""
"Returns ``-1.0`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"Повертає ``-1.0`` у разі помилки. Використовуйте :c:func:`PyErr_Occurred` "
"для усунення неоднозначності."

msgid ""
"Convert a Python integer *pylong* to a C :c:type:`void` pointer. If *pylong* "
"cannot be converted, an :exc:`OverflowError` will be raised.  This is only "
"assured to produce a usable :c:type:`void` pointer for values created with :"
"c:func:`PyLong_FromVoidPtr`."
msgstr ""
"Перетворіть ціле число Python *pylong* на покажчик C :c:type:`void`. Якщо "
"*pylong* не можна перетворити, буде викликано :exc:`OverflowError`. Це "
"гарантовано лише для створення придатного для використання покажчика :c:type:"
"`void` для значень, створених за допомогою :c:func:`PyLong_FromVoidPtr`."

msgid ""
"Returns ``NULL`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"Повертає ``NULL`` у разі помилки. Використовуйте :c:func:`PyErr_Occurred` "
"для усунення неоднозначності."
