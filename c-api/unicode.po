# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-18 14:18+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "Об’єкти та кодеки Unicode"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "Об'єкти Unicode"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"З моменту впровадження :pep:`393` у Python 3.3 об’єкти Unicode внутрішньо "
"використовують різноманітні представлення, щоб дозволити обробку повного "
"діапазону символів Unicode, залишаючись ефективним для пам’яті. Існують "
"особливі випадки для рядків, де всі кодові точки нижчі за 128, 256 або "
"65536; інакше кодові точки повинні бути нижче 1114112 (що є повним "
"діапазоном Unicode)."

#: ../../c-api/unicode.rst:20
msgid ""
"UTF-8 representation is created on demand and cached in the Unicode object."
msgstr ""

#: ../../c-api/unicode.rst:23
msgid ""
"The :c:type:`Py_UNICODE` representation has been removed since Python 3.12 "
"with deprecated APIs. See :pep:`623` for more information."
msgstr ""

#: ../../c-api/unicode.rst:29
msgid "Unicode Type"
msgstr "Тип Unicode"

#: ../../c-api/unicode.rst:31
msgid ""
"These are the basic Unicode object types used for the Unicode implementation"
" in Python:"
msgstr ""
"Ось основні типи об’єктів Unicode, які використовуються для реалізації "
"Unicode в Python:"

#: ../../c-api/unicode.rst:38
msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"Ці типи є визначеннями типів для беззнакових цілих типів, достатньо широких,"
" щоб містити символи 32 біти, 16 бітів і 8 бітів відповідно. При роботі з "
"окремими символами Unicode використовуйте :c:type:`Py_UCS4`."

#: ../../c-api/unicode.rst:47
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform."
msgstr ""
"Це визначення типу :c:type:`wchar_t`, який є 16-бітним або 32-бітним типом "
"залежно від платформи."

#: ../../c-api/unicode.rst:50
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr ""
"У попередніх версіях це був 16-розрядний або 32-розрядний тип залежно від "
"того, чи ви вибрали \"вузьку\" чи \"широку\" версію Unicode Python під час "
"збирання."

#: ../../c-api/unicode.rst:62
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"Ці підтипи :c:type:`PyObject` представляють об’єкт Python Unicode. Майже у "
"всіх випадках їх не слід використовувати напряму, оскільки всі функції API, "
"які працюють з об’єктами Unicode, приймають і повертають покажчики "
":c:type:`PyObject`."

#: ../../c-api/unicode.rst:71
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type."
"  It is exposed to Python code as ``str``."
msgstr ""
"Цей екземпляр :c:type:`PyTypeObject` представляє тип Python Unicode. Він "
"доступний коду Python як ``str``."

#: ../../c-api/unicode.rst:75
msgid ""
"The following APIs are C macros and static inlined functions for fast checks"
" and access to internal read-only data of Unicode objects:"
msgstr ""

#: ../../c-api/unicode.rst:80
msgid ""
"Return true if the object *obj* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr ""

#: ../../c-api/unicode.rst:86
msgid ""
"Return true if the object *obj* is a Unicode object, but not an instance of "
"a subtype.  This function always succeeds."
msgstr ""

#: ../../c-api/unicode.rst:92
msgid "Returns ``0``. This API is kept only for backward compatibility."
msgstr ""

#: ../../c-api/unicode.rst:96
msgid "This API does nothing since Python 3.12."
msgstr ""

#: ../../c-api/unicode.rst:102
msgid ""
"Return the length of the Unicode string, in code points.  *unicode* has to "
"be a Unicode object in the \"canonical\" representation (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:112
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use "
":c:func:`PyUnicode_KIND` to select the right function."
msgstr ""

#: ../../c-api/unicode.rst:124
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "Повертає значення макросу :c:func:`PyUnicode_KIND`."

#: ../../c-api/unicode.rst:128
msgid "``PyUnicode_WCHAR_KIND`` has been removed."
msgstr ""

#: ../../c-api/unicode.rst:134
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  "
"*unicode* has to be a Unicode object in the \"canonical\" representation "
"(not checked)."
msgstr ""

#: ../../c-api/unicode.rst:143
msgid ""
"Return a void pointer to the raw Unicode buffer.  *unicode* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:152
msgid ""
"Write into a canonical representation *data* (as obtained with "
":c:func:`PyUnicode_DATA`).  This function performs no sanity checks, and is "
"intended for usage in loops.  The caller should cache the *kind* value and "
"*data* pointer as obtained from other calls.  *index* is the index in the "
"string (starts at 0) and *value* is the new code point value which should be"
" written to that location."
msgstr ""

#: ../../c-api/unicode.rst:165
msgid ""
"Read a code point from a canonical representation *data* (as obtained with "
":c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr ""
"Прочитайте кодову точку з канонічного представлення *data* (отриманого за "
"допомогою :c:func:`PyUnicode_DATA`). Перевірки чи готові виклики не "
"виконуються."

#: ../../c-api/unicode.rst:173
msgid ""
"Read a character from a Unicode object *unicode*, which must be in the "
"\"canonical\" representation.  This is less efficient than "
":c:func:`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""

#: ../../c-api/unicode.rst:182
msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *unicode*, which must be in the \"canonical\" representation.  This"
" is always an approximation but more efficient than iterating over the "
"string."
msgstr ""

#: ../../c-api/unicode.rst:191
msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr ""
"Повертає ``1``, якщо рядок є дійсним ідентифікатором відповідно до "
"визначення мови, розділ :ref:`identifiers`. Інакше поверніть ``0``."

#: ../../c-api/unicode.rst:194
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr ""
"Функція більше не викликає :c:func:`Py_FatalError`, якщо рядок не готовий."

#: ../../c-api/unicode.rst:200
msgid "Unicode Character Properties"
msgstr "Властивості символів Unicode"

#: ../../c-api/unicode.rst:202
msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr ""
"Unicode надає багато різних властивостей символів. Найпотрібніші з них "
"доступні через ці макроси, які зіставляються з функціями C залежно від "
"конфігурації Python."

#: ../../c-api/unicode.rst:209
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи *ch* є пробілом."

#: ../../c-api/unicode.rst:214
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи *ch* є символом нижнього "
"регістру."

#: ../../c-api/unicode.rst:219
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr ""
"Повертає ``1`` або ``0`` залежно від того, чи *ch* є символом у верхньому "
"регістрі."

#: ../../c-api/unicode.rst:224
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr ""
"Повертає ``1`` або ``0`` залежно від того, чи *ch* є символом заголовка."

#: ../../c-api/unicode.rst:229
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи є *ch* символом розриву рядка."

#: ../../c-api/unicode.rst:234
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи є *ch* десятковим символом."

#: ../../c-api/unicode.rst:239
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи є *ch* символом цифри."

#: ../../c-api/unicode.rst:244
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи є *ch* цифровим символом."

#: ../../c-api/unicode.rst:249
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи *ch* є буквою."

#: ../../c-api/unicode.rst:254
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric "
"character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи є *ch* буквено-цифровим "
"символом."

#: ../../c-api/unicode.rst:259
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character, in"
" the sense of :meth:`str.isprintable`."
msgstr ""

#: ../../c-api/unicode.rst:263
msgid "These APIs can be used for fast direct character conversions:"
msgstr ""
"Ці API можна використовувати для швидкого прямого перетворення символів:"

#: ../../c-api/unicode.rst:268
msgid "Return the character *ch* converted to lower case."
msgstr "Повертає символ *ch*, перетворений на нижній регістр."

#: ../../c-api/unicode.rst:273
msgid "Return the character *ch* converted to upper case."
msgstr "Повертає символ *ch*, перетворений у верхній регістр."

#: ../../c-api/unicode.rst:278
msgid "Return the character *ch* converted to title case."
msgstr "Повертає символ *ch*, перетворений на регістр заголовка."

#: ../../c-api/unicode.rst:283
msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This function does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:289
msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1``"
" if this is not possible.  This function does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:295
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This function does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:299
msgid "These APIs can be used to work with surrogates:"
msgstr "Ці API можна використовувати для роботи із сурогатами:"

#: ../../c-api/unicode.rst:303
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "Перевірте, чи *ch* є сурогатом (``0xD800 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:307
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "Перевірте, чи *ch* є високим сурогатом (``0xD800 <= ch <= 0xDBFF``)."

#: ../../c-api/unicode.rst:311
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "Перевірте, чи *ch* є низьким сурогатом (``0xDC00 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:315
msgid ""
"Join two surrogate code points and return a single :c:type:`Py_UCS4` value. "
"*high* and *low* are respectively the leading and trailing surrogates in a "
"surrogate pair. *high* must be in the range [0xD800; 0xDBFF] and *low* must "
"be in the range [0xDC00; 0xDFFF]."
msgstr ""

#: ../../c-api/unicode.rst:322
msgid "Creating and accessing Unicode strings"
msgstr "Створення та доступ до рядків Unicode"

#: ../../c-api/unicode.rst:324
msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr ""
"Щоб створити об’єкти Unicode та отримати доступ до їхніх основних "
"властивостей послідовності, використовуйте ці API:"

#: ../../c-api/unicode.rst:329
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up"
" to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"Створіть новий об’єкт Unicode. *maxchar* має бути справжньою максимальною "
"кодовою точкою, яка буде розміщена в рядку. Приблизно його можна округлити "
"до найближчого значення в послідовності 127, 255, 65535, 1114111."

#: ../../c-api/unicode.rst:333
msgid ""
"This is the recommended way to allocate a new Unicode object.  Objects "
"created using this function are not resizable."
msgstr ""
"Це рекомендований спосіб виділення нового об’єкта Unicode. Розмір об’єктів, "
"створених за допомогою цієї функції, неможливо змінити."

#: ../../c-api/unicode.rst:336
msgid "On error, set an exception and return ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:344
msgid ""
"Create a new Unicode object with the given *kind* (possible values are "
":c:macro:`PyUnicode_1BYTE_KIND` etc., as returned by "
":c:func:`PyUnicode_KIND`).  The *buffer* must point to an array of *size* "
"units of 1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"Створіть новий об’єкт Unicode із заданим *kind* (можливі значення: "
":c:macro:`PyUnicode_1BYTE_KIND` тощо, як повертає :c:func:`PyUnicode_KIND`)."
" *Буфер* має вказувати на масив одиниць *розміру* по 1, 2 або 4 байти на "
"символ, як задано типом."

#: ../../c-api/unicode.rst:349
msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string "
"(:c:macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in the "
"UCS1 range, it will be transformed into UCS1 "
"(:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""

#: ../../c-api/unicode.rst:360
msgid ""
"Create a Unicode object from the char buffer *str*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. The return value might be a shared object, i.e. modification of the "
"data is not allowed."
msgstr ""

#: ../../c-api/unicode.rst:366
msgid "This function raises :exc:`SystemError` when:"
msgstr ""

#: ../../c-api/unicode.rst:368
msgid "*size* < 0,"
msgstr ""

#: ../../c-api/unicode.rst:369
msgid "*str* is ``NULL`` and *size* > 0"
msgstr ""

#: ../../c-api/unicode.rst:371
msgid "*str* == ``NULL`` with *size* > 0 is not allowed anymore."
msgstr ""

#: ../../c-api/unicode.rst:377
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*str*."
msgstr ""

#: ../../c-api/unicode.rst:383
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string."
msgstr ""

#: ../../c-api/unicode.rst:389
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr ""
"Специфікатор перетворення містить два або більше символів і має наступні "
"компоненти, які мають відображатися в такому порядку:"

#: ../../c-api/unicode.rst:392
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Символ ``'%'``, який позначає початок специфікатора."

#: ../../c-api/unicode.rst:394
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Прапорці перетворення (опціонально), які впливають на результат деяких типів"
" перетворення."

#: ../../c-api/unicode.rst:397
msgid ""
"Minimum field width (optional). If specified as an ``'*'`` (asterisk), the "
"actual width is given in the next argument, which must be of type "
":c:expr:`int`, and the object to convert comes after the minimum field width"
" and optional precision."
msgstr ""

#: ../../c-api/unicode.rst:402
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision. If"
" specified as ``'*'`` (an asterisk), the actual precision is given in the "
"next argument, which must be of type :c:expr:`int`, and the value to convert"
" comes after the precision."
msgstr ""

#: ../../c-api/unicode.rst:407
msgid "Length modifier (optional)."
msgstr "Модифікатор довжини (необов'язково)."

#: ../../c-api/unicode.rst:409
msgid "Conversion type."
msgstr "Тип перетворення."

#: ../../c-api/unicode.rst:411
msgid "The conversion flag characters are:"
msgstr "Символи прапора перетворення:"

#: ../../c-api/unicode.rst:416
msgid "Flag"
msgstr "Прапор"

#: ../../c-api/unicode.rst:416
msgid "Meaning"
msgstr "Значення"

#: ../../c-api/unicode.rst:418
msgid "``0``"
msgstr "``0``"

#: ../../c-api/unicode.rst:418
msgid "The conversion will be zero padded for numeric values."
msgstr "Перетворення буде доповнено нулем для числових значень."

#: ../../c-api/unicode.rst:420
msgid "``-``"
msgstr ""

#: ../../c-api/unicode.rst:420
msgid ""
"The converted value is left adjusted (overrides the ``0`` flag if both are "
"given)."
msgstr ""

#: ../../c-api/unicode.rst:424
msgid ""
"The length modifiers for following integer conversions (``d``, ``i``, ``o``,"
" ``u``, ``x``, or ``X``) specify the type of the argument (:c:expr:`int` by "
"default):"
msgstr ""

#: ../../c-api/unicode.rst:431
msgid "Modifier"
msgstr ""

#: ../../c-api/unicode.rst:431
msgid "Types"
msgstr "Типи"

#: ../../c-api/unicode.rst:433
msgid "``l``"
msgstr "``l``"

#: ../../c-api/unicode.rst:433
msgid ":c:expr:`long` or :c:expr:`unsigned long`"
msgstr ""

#: ../../c-api/unicode.rst:435
msgid "``ll``"
msgstr ""

#: ../../c-api/unicode.rst:435
msgid ":c:expr:`long long` or :c:expr:`unsigned long long`"
msgstr ""

#: ../../c-api/unicode.rst:437
msgid "``j``"
msgstr ""

#: ../../c-api/unicode.rst:437
msgid ":c:type:`intmax_t` or :c:type:`uintmax_t`"
msgstr ""

#: ../../c-api/unicode.rst:439
msgid "``z``"
msgstr ""

#: ../../c-api/unicode.rst:439
msgid ":c:type:`size_t` or :c:type:`ssize_t`"
msgstr ""

#: ../../c-api/unicode.rst:441
msgid "``t``"
msgstr ""

#: ../../c-api/unicode.rst:441
msgid ":c:type:`ptrdiff_t`"
msgstr ""

#: ../../c-api/unicode.rst:444
msgid ""
"The length modifier ``l`` for following conversions ``s`` or ``V`` specify "
"that the type of the argument is :c:expr:`const wchar_t*`."
msgstr ""

#: ../../c-api/unicode.rst:447
msgid "The conversion specifiers are:"
msgstr ""

#: ../../c-api/unicode.rst:453
msgid "Conversion Specifier"
msgstr ""

#: ../../c-api/unicode.rst:454
msgid "Type"
msgstr "Тип"

#: ../../c-api/unicode.rst:455
msgid "Comment"
msgstr "коментар"

#: ../../c-api/unicode.rst:457
msgid "``%``"
msgstr "``%``"

#: ../../c-api/unicode.rst:458
msgid "*n/a*"
msgstr "*немає*"

#: ../../c-api/unicode.rst:459
msgid "The literal ``%`` character."
msgstr ""

#: ../../c-api/unicode.rst:461
msgid "``d``, ``i``"
msgstr ""

#: ../../c-api/unicode.rst:462 ../../c-api/unicode.rst:466
#: ../../c-api/unicode.rst:470 ../../c-api/unicode.rst:474
#: ../../c-api/unicode.rst:478
msgid "Specified by the length modifier"
msgstr ""

#: ../../c-api/unicode.rst:463
msgid "The decimal representation of a signed C integer."
msgstr ""

#: ../../c-api/unicode.rst:465
msgid "``u``"
msgstr ""

#: ../../c-api/unicode.rst:467
msgid "The decimal representation of an unsigned C integer."
msgstr ""

#: ../../c-api/unicode.rst:469
msgid "``o``"
msgstr "``о``"

#: ../../c-api/unicode.rst:471
msgid "The octal representation of an unsigned C integer."
msgstr ""

#: ../../c-api/unicode.rst:473
msgid "``x``"
msgstr "``x``"

#: ../../c-api/unicode.rst:475
msgid "The hexadecimal representation of an unsigned C integer (lowercase)."
msgstr ""

#: ../../c-api/unicode.rst:477
msgid "``X``"
msgstr ""

#: ../../c-api/unicode.rst:479
msgid "The hexadecimal representation of an unsigned C integer (uppercase)."
msgstr ""

#: ../../c-api/unicode.rst:481
msgid "``c``"
msgstr "``c``"

#: ../../c-api/unicode.rst:482
msgid ":c:expr:`int`"
msgstr ""

#: ../../c-api/unicode.rst:483
msgid "A single character."
msgstr ""

#: ../../c-api/unicode.rst:485
msgid "``s``"
msgstr "``s``"

#: ../../c-api/unicode.rst:486
msgid ":c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ""

#: ../../c-api/unicode.rst:487
msgid "A null-terminated C character array."
msgstr "Масив символів C із закінченням нулем."

#: ../../c-api/unicode.rst:489
msgid "``p``"
msgstr "``p``"

#: ../../c-api/unicode.rst:490
msgid ":c:expr:`const void*`"
msgstr ""

#: ../../c-api/unicode.rst:491
msgid ""
"The hex representation of a C  pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""

#: ../../c-api/unicode.rst:496
msgid "``A``"
msgstr ""

#: ../../c-api/unicode.rst:497 ../../c-api/unicode.rst:501
#: ../../c-api/unicode.rst:511 ../../c-api/unicode.rst:515
#: ../../c-api/unicode.rst:519 ../../c-api/unicode.rst:524
msgid ":c:expr:`PyObject*`"
msgstr ""

#: ../../c-api/unicode.rst:498
msgid "The result of calling :func:`ascii`."
msgstr "Результат виклику :func:`ascii`."

#: ../../c-api/unicode.rst:500
msgid "``U``"
msgstr ""

#: ../../c-api/unicode.rst:502
msgid "A Unicode object."
msgstr "Об'єкт Unicode."

#: ../../c-api/unicode.rst:504
msgid "``V``"
msgstr ""

#: ../../c-api/unicode.rst:505
msgid ":c:expr:`PyObject*`, :c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ""

#: ../../c-api/unicode.rst:506
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"Об’єкт Unicode (який може бути ``NULL``) і масив символів C із нульовим "
"закінченням як другий параметр (який використовуватиметься, якщо перший "
"параметр ``NULL``)."

#: ../../c-api/unicode.rst:510
msgid "``S``"
msgstr ""

#: ../../c-api/unicode.rst:512
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "Результат виклику :c:func:`PyObject_Str`."

#: ../../c-api/unicode.rst:514
msgid "``R``"
msgstr ""

#: ../../c-api/unicode.rst:516
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "Результат виклику :c:func:`PyObject_Repr`."

#: ../../c-api/unicode.rst:518
msgid "``T``"
msgstr ""

#: ../../c-api/unicode.rst:520
msgid ""
"Get the fully qualified name of an object type; call "
":c:func:`PyType_GetFullyQualifiedName`."
msgstr ""

#: ../../c-api/unicode.rst:523
msgid "``#T``"
msgstr ""

#: ../../c-api/unicode.rst:525
msgid ""
"Similar to ``T`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr ""

#: ../../c-api/unicode.rst:528
msgid "``N``"
msgstr "``N``"

#: ../../c-api/unicode.rst:529 ../../c-api/unicode.rst:534
msgid ":c:expr:`PyTypeObject*`"
msgstr ""

#: ../../c-api/unicode.rst:530
msgid ""
"Get the fully qualified name of a type; call "
":c:func:`PyType_GetFullyQualifiedName`."
msgstr ""

#: ../../c-api/unicode.rst:533
msgid "``#N``"
msgstr ""

#: ../../c-api/unicode.rst:535
msgid ""
"Similar to ``N`` format, but use a colon (``:``) as separator between the "
"module name and the qualified name."
msgstr ""

#: ../../c-api/unicode.rst:539
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes or :c:type:`wchar_t` items (if "
"the length modifier ``l`` is used) for ``\"%s\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""

#: ../../c-api/unicode.rst:547
msgid ""
"Unlike to C :c:func:`printf` the ``0`` flag has effect even when a precision"
" is given for integer conversions (``d``, ``i``, ``u``, ``o``, ``x``, or "
"``X``)."
msgstr ""

#: ../../c-api/unicode.rst:551
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "Додано підтримку ``\"%lld\"`` і ``\"%llu\"``."

#: ../../c-api/unicode.rst:554
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "Додано підтримку ``\"%li\"``, ``\"%lli\"`` і ``\"%zi\"``."

#: ../../c-api/unicode.rst:557
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr ""
"Підтримка ширини та точного форматування для ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` додано."

#: ../../c-api/unicode.rst:561
msgid ""
"Support for conversion specifiers ``o`` and ``X``. Support for length "
"modifiers ``j`` and ``t``. Length modifiers are now applied to all integer "
"conversions. Length modifier ``l`` is now applied to conversion specifiers "
"``s`` and ``V``. Support for variable width and precision ``*``. Support for"
" flag ``-``."
msgstr ""

#: ../../c-api/unicode.rst:569
msgid ""
"An unrecognized format character now sets a :exc:`SystemError`. In previous "
"versions it caused all the rest of the format string to be copied as-is to "
"the result string, and any extra arguments discarded."
msgstr ""

#: ../../c-api/unicode.rst:573
msgid "Support for ``%T``, ``%#T``, ``%N`` and ``%#N`` formats added."
msgstr ""

#: ../../c-api/unicode.rst:579
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two"
" arguments."
msgstr ""
"Ідентичний :c:func:`PyUnicode_FromFormat` за винятком того, що він приймає "
"рівно два аргументи."

#: ../../c-api/unicode.rst:585
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return"
" a new :term:`strong reference` to the object."
msgstr ""

#: ../../c-api/unicode.rst:589
msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr ""
"Об’єкти, відмінні від Unicode або його підтипів, викличуть :exc:`TypeError`."

#: ../../c-api/unicode.rst:594
msgid "Create a Unicode Object from the given Unicode code point *ordinal*."
msgstr ""

#: ../../c-api/unicode.rst:596
msgid ""
"The ordinal must be in ``range(0x110000)``. A :exc:`ValueError` is raised in"
" the case it is not."
msgstr ""

#: ../../c-api/unicode.rst:603
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "Декодуйте закодований об’єкт *obj* в об’єкт Unicode."

#: ../../c-api/unicode.rst:605
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using"
" the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes`, :class:`bytearray` та інші :term:`bytes-подібні об’єкти "
"<bytes-like object>` декодуються відповідно до заданого *кодування* та з "
"використанням обробки помилок, визначеної *errors*. Обидва можуть бути "
"``NULL``, щоб інтерфейс використовував значення за замовчуванням (дивіться "
":ref:`builtincodecs` для деталей)."

#: ../../c-api/unicode.rst:611
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be"
" set."
msgstr ""
"Усі інші об’єкти, включно з об’єктами Unicode, викликають встановлення "
":exc:`TypeError`."

#: ../../c-api/unicode.rst:614
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr ""
"API повертає ``NULL``, якщо сталася помилка. Виклик відповідає за "
"декодування повернутих об'єктів."

#: ../../c-api/unicode.rst:620
msgid ""
"Return the name of the default string encoding, ``\"utf-8\"``. See "
":func:`sys.getdefaultencoding`."
msgstr ""

#: ../../c-api/unicode.rst:623
msgid ""
"The returned string does not need to be freed, and is valid until "
"interpreter shutdown."
msgstr ""

#: ../../c-api/unicode.rst:629
msgid "Return the length of the Unicode object, in code points."
msgstr "Повертає довжину об’єкта Юнікод у кодових точках."

#: ../../c-api/unicode.rst:631
msgid "On error, set an exception and return ``-1``."
msgstr ""

#: ../../c-api/unicode.rst:642
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to "
":c:func:`!memcpy` if possible.  Returns ``-1`` and sets an exception on "
"error, otherwise returns the number of copied characters."
msgstr ""

#: ../../c-api/unicode.rst:653
msgid ""
"Fill a string with a character: write *fill_char* into "
"``unicode[start:start+length]``."
msgstr ""
"Заповніть рядок символом: напишіть *fill_char* у "
"``unicode[start:start+length]``."

#: ../../c-api/unicode.rst:656
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr ""
"Помилка, якщо *fill_char* перевищує максимальний символ рядка або якщо рядок"
" має більше ніж 1 посилання."

#: ../../c-api/unicode.rst:659
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr ""
"Повертає номер написаного символу або повертає ``-1`` і викликає виняток у "
"разі помилки."

#: ../../c-api/unicode.rst:668
msgid ""
"Write a character to a string.  The string must have been created through "
":c:func:`PyUnicode_New`.  Since Unicode strings are supposed to be "
"immutable, the string must not be shared, or have been hashed yet."
msgstr ""
"Записати символ у рядок. Рядок має бути створено через "
":c:func:`PyUnicode_New`. Оскільки рядки Юнікоду мають бути незмінними, рядок"
" не можна надавати спільно або хешувати."

#: ../../c-api/unicode.rst:672
msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object can be modified safely (i.e. that it "
"its reference count is one)."
msgstr ""
"Ця функція перевіряє, що *unicode* є об’єктом Unicode, що індекс не виходить"
" за межі та чи можна безпечно змінювати об’єкт (тобто чи кількість посилань "
"дорівнює одиниці)."

#: ../../c-api/unicode.rst:676
msgid "Return ``0`` on success, ``-1`` on error with an exception set."
msgstr ""

#: ../../c-api/unicode.rst:683
msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to "
":c:func:`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""

#: ../../c-api/unicode.rst:687
msgid "Return character on success, ``-1`` on error with an exception set."
msgstr ""

#: ../../c-api/unicode.rst:695
msgid ""
"Return a substring of *unicode*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported. On "
"error, set an exception and return ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:705
msgid ""
"Copy the string *unicode* into a UCS4 buffer, including a null character, if"
" *copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*unicode*).  *buffer* is returned on success."
msgstr ""

#: ../../c-api/unicode.rst:715
msgid ""
"Copy the string *unicode* into a new UCS4 buffer that is allocated using "
":c:func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a "
":exc:`MemoryError` set.  The returned buffer always has an extra null code "
"point appended."
msgstr ""

#: ../../c-api/unicode.rst:724
msgid "Locale Encoding"
msgstr "Кодування мови"

#: ../../c-api/unicode.rst:726
msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr ""
"Поточне кодування мови можна використовувати для декодування тексту з "
"операційної системи."

#: ../../c-api/unicode.rst:733
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a"
" null character but cannot contain embedded null characters."
msgstr ""
"Декодуйте рядок з UTF-8 на Android і VxWorks або з поточного кодування мови "
"на інших платформах. Підтримуваними обробниками помилок є ``\"strict\"`` і "
"``\"surrogateescape\"`` (:pep:`383`). Декодер використовує ``\"strict\"`` "
"обробник помилок, якщо *errors* має значення ``NULL``. *str* має "
"закінчуватися нульовим символом, але не може містити вбудовані нульові "
"символи."

#: ../../c-api/unicode.rst:740
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from the "
":term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/unicode.rst:743 ../../c-api/unicode.rst:778
msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "Ця функція ігнорує :ref:`Режим Python UTF-8 <utf8-mode>`."

#: ../../c-api/unicode.rst:747 ../../c-api/unicode.rst:863
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "Функція :c:func:`Py_DecodeLocale`."

#: ../../c-api/unicode.rst:751
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_DecodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"Функція тепер також використовує поточне кодування мови для обробника "
"помилок ``surrogateescape``, за винятком Android. Раніше "
":c:func:`Py_DecodeLocale` використовувався для ``surrogateescape``, а "
"поточне кодування мови використовувалося для ``strict``."

#: ../../c-api/unicode.rst:760
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`!strlen`."
msgstr ""

#: ../../c-api/unicode.rst:768
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a "
":class:`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"Закодуйте об’єкт Unicode до UTF-8 на Android і VxWorks або до поточного "
"кодування мови на інших платформах. Підтримуваними обробниками помилок є "
"``\"strict\"`` і ``\"surrogateescape\"`` (:pep:`383`). Кодер використовує "
"``\"strict\"`` обробник помилок, якщо *errors* має значення ``NULL``. "
"Повертає об’єкт :class:`bytes`. *unicode* не може містити вбудовані нульові "
"символи."

#: ../../c-api/unicode.rst:775
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to the "
":term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/unicode.rst:782 ../../c-api/unicode.rst:894
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr "Функція :c:func:`Py_EncodeLocale`."

#: ../../c-api/unicode.rst:786
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_EncodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"Функція тепер також використовує поточне кодування мови для обробника "
"помилок ``surrogateescape``, за винятком Android. Раніше "
":c:func:`Py_EncodeLocale` використовувався для ``surrogateescape``, а "
"поточне кодування мови використовувалося для ``strict``."

#: ../../c-api/unicode.rst:795
msgid "File System Encoding"
msgstr "Кодування файлової системи"

#: ../../c-api/unicode.rst:797
msgid ""
"Functions encoding to and decoding from the :term:`filesystem encoding and "
"error handler` (:pep:`383` and :pep:`529`)."
msgstr ""

#: ../../c-api/unicode.rst:800
msgid ""
"To encode file names to :class:`bytes` during argument parsing, the "
"``\"O&\"`` converter should be used, passing "
":c:func:`!PyUnicode_FSConverter` as the conversion function:"
msgstr ""

#: ../../c-api/unicode.rst:806
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: encode :class:`str` objects "
"-- obtained directly or through the :class:`os.PathLike` interface -- to "
":class:`bytes` using :c:func:`PyUnicode_EncodeFSDefault`; :class:`bytes` "
"objects are output as-is. *result* must be an address of a C variable of "
"type :c:expr:`PyObject*` (or :c:expr:`PyBytesObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`bytes object "
"<bytesobjects>` which must be released when it is no longer used and return "
"a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null bytes are "
"not allowed in the result. On failure, return ``0`` with an exception set."
msgstr ""

#: ../../c-api/unicode.rst:818
msgid ""
"If *obj* is ``NULL``, the function releases a strong reference stored in the"
" variable referred by *result* and returns ``1``."
msgstr ""

#: ../../c-api/unicode.rst:823 ../../c-api/unicode.rst:850
msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

#: ../../c-api/unicode.rst:826
msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"``"
" converter should be used, passing :c:func:`!PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""

#: ../../c-api/unicode.rst:832
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: decode :class:`bytes` objects"
" -- obtained either directly or indirectly through the :class:`os.PathLike` "
"interface -- to :class:`str` using "
":c:func:`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` objects are output "
"as-is. *result* must be an address of a C variable of type "
":c:expr:`PyObject*` (or :c:expr:`PyUnicodeObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`Unicode object "
"<unicodeobjects>` which must be released when it is no longer used and "
"return a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null "
"characters are not allowed in the result. On failure, return ``0`` with an "
"exception set."
msgstr ""

#: ../../c-api/unicode.rst:845
msgid ""
"If *obj* is ``NULL``, release the strong reference to the object referred to"
" by *result* and return ``1``."
msgstr ""

#: ../../c-api/unicode.rst:856
msgid ""
"Decode a string from the :term:`filesystem encoding and error handler`."
msgstr "Декодуйте рядок із :term:`filesystem encoding and error handler`."

#: ../../c-api/unicode.rst:858
msgid ""
"If you need to decode a string from the current locale encoding, use "
":c:func:`PyUnicode_DecodeLocaleAndSize`."
msgstr ""

#: ../../c-api/unicode.rst:865 ../../c-api/unicode.rst:878
#: ../../c-api/unicode.rst:898
msgid ""
"The :term:`filesystem error handler <filesystem encoding and error handler>`"
" is now used."
msgstr ""

#: ../../c-api/unicode.rst:872
msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr ""
"Декодуйте рядок із нульовим закінченням із :term:`filesystem encoding and "
"error handler`."

#: ../../c-api/unicode.rst:875
msgid ""
"If the string length is known, use "
":c:func:`PyUnicode_DecodeFSDefaultAndSize`."
msgstr ""

#: ../../c-api/unicode.rst:885
msgid ""
"Encode a Unicode object to the :term:`filesystem encoding and error "
"handler`, and return :class:`bytes`. Note that the resulting :class:`bytes` "
"object can contain null bytes."
msgstr ""

#: ../../c-api/unicode.rst:889
msgid ""
"If you need to encode a string to the current locale encoding, use "
":c:func:`PyUnicode_EncodeLocale`."
msgstr ""

#: ../../c-api/unicode.rst:903
msgid "wchar_t Support"
msgstr "Підтримка wchar_t"

#: ../../c-api/unicode.rst:905
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr ":c:type:`wchar_t` підтримка платформ, які її підтримують:"

#: ../../c-api/unicode.rst:909
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *wstr* of the "
"given *size*. Passing ``-1`` as the *size* indicates that the function must "
"itself compute the length, using :c:func:`!wcslen`. Return ``NULL`` on "
"failure."
msgstr ""

#: ../../c-api/unicode.rst:917
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer *wstr*.  "
"At most *size* :c:type:`wchar_t` characters are copied (excluding a possibly"
" trailing null termination character).  Return the number of "
":c:type:`wchar_t` characters copied or ``-1`` in case of an error."
msgstr ""

#: ../../c-api/unicode.rst:922
msgid ""
"When *wstr* is ``NULL``, instead return the *size* that would be required to"
" store all of *unicode* including a terminating null."
msgstr ""

#: ../../c-api/unicode.rst:925
msgid ""
"Note that the resulting :c:expr:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the "
":c:expr:`wchar_t*` string is null-terminated in case this is required by the"
" application. Also, note that the :c:expr:`wchar_t*` string might contain "
"null characters, which would cause the string to be truncated when used with"
" most C functions."
msgstr ""

#: ../../c-api/unicode.rst:935
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the "
":c:expr:`wchar_t*` string contains null characters a :exc:`ValueError` is "
"raised."
msgstr ""

#: ../../c-api/unicode.rst:943
msgid ""
"Returns a buffer allocated by :c:macro:`PyMem_New` (use :c:func:`PyMem_Free`"
" to free it) on success. On error, returns ``NULL`` and *\\*size* is "
"undefined. Raises a :exc:`MemoryError` if memory allocation is failed."
msgstr ""

#: ../../c-api/unicode.rst:950
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:expr:`wchar_t*` "
"string contains null characters."
msgstr ""

#: ../../c-api/unicode.rst:958
msgid "Built-in Codecs"
msgstr "Вбудовані кодеки"

#: ../../c-api/unicode.rst:960
msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr ""
"Python надає набір вбудованих кодеків, написаних на C для швидкості. Усі ці "
"кодеки можна безпосередньо використовувати за допомогою наведених нижче "
"функцій."

#: ../../c-api/unicode.rst:963
msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"Багато з наведених нижче API приймають кодування двох аргументів і помилки, "
"і вони мають таку саму семантику, як і вбудовані конструктори рядкових "
"об’єктів :func:`str`."

#: ../../c-api/unicode.rst:967
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is"
" UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` "
"for encoding file names. This uses the :term:`filesystem encoding and error "
"handler` internally."
msgstr ""

#: ../../c-api/unicode.rst:972
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to"
" use the default handling defined for the codec.  Default error handling for"
" all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"Обробка помилок встановлюється помилками, які також можуть мати значення "
"``NULL``, що означає використання обробки за замовчуванням, визначеної для "
"кодека. Обробка помилок за замовчуванням для всіх вбудованих кодеків є "
"\"суворою\" (:exc:`ValueError` викликається)."

#: ../../c-api/unicode.rst:976
msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr ""
"Усі кодеки використовують подібний інтерфейс. Для простоти документуються "
"лише відхилення від наступних загальних."

#: ../../c-api/unicode.rst:981
msgid "Generic Codecs"
msgstr "Загальні кодеки"

#: ../../c-api/unicode.rst:983
msgid "These are the generic codec APIs:"
msgstr "Це загальні кодеки API:"

#: ../../c-api/unicode.rst:989
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str*. *encoding* and *errors* have the same meaning as the parameters of "
"the same name in the :func:`str` built-in function.  The codec to be used is"
" looked up using the Python codec registry.  Return ``NULL`` if an exception"
" was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:999
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode та поверніть результат як об’єкт Python bytes. "
"*encoding* і *errors* мають те саме значення, що й однойменні параметри в "
"методі Unicode :meth:`~str.encode`. Кодек, який буде використовуватися, "
"шукається за допомогою реєстру кодеків Python. Повертає ``NULL``, якщо кодек"
" викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1007
msgid "UTF-8 Codecs"
msgstr "Кодеки UTF-8"

#: ../../c-api/unicode.rst:1009
msgid "These are the UTF-8 codec APIs:"
msgstr "Це API кодека UTF-8:"

#: ../../c-api/unicode.rst:1014
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string"
" *str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1021
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як "
":c:func:`PyUnicode_DecodeUTF8`. Якщо *consumed* не має значення ``NULL``, "
"кінцеві неповні послідовності байтів UTF-8 не розглядатимуться як помилка. "
"Ці байти не будуть декодовані, а кількість декодованих байтів "
"зберігатиметься в *спожитих*."

#: ../../c-api/unicode.rst:1029
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою UTF-8 і поверніть результат як об’єкт "
"Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1033 ../../c-api/unicode.rst:1048
msgid ""
"The function fails if the string contains surrogate code points (``U+D800`` "
"- ``U+DFFF``)."
msgstr ""

#: ../../c-api/unicode.rst:1039
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned"
" buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"Поверніть вказівник на кодування UTF-8 об’єкта Unicode та збережіть розмір "
"закодованого представлення (у байтах) у *size*. Аргумент *size* може бути "
"``NULL``; у цьому випадку розмір не буде збережено. До поверненого буфера "
"завжди додається додатковий нульовий байт (не включений у *size*), незалежно"
" від того, чи є інші нульові кодові точки."

#: ../../c-api/unicode.rst:1045
msgid ""
"On error, set an exception, set *size* to ``-1`` (if it's not NULL) and "
"return ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:1051
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"Це кешує представлення UTF-8 рядка в об’єкті Unicode, а наступні виклики "
"повертатимуть вказівник на той самий буфер. Абонент не несе відповідальності"
" за звільнення буфера. Буфер звільняється, і покажчики на нього стають "
"недійсними, коли об’єкт Unicode збирається як сміття."

#: ../../c-api/unicode.rst:1058 ../../c-api/unicode.rst:1080
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "Тип повернення тепер ``const char *``, а не ``char *``."

#: ../../c-api/unicode.rst:1061
msgid "This function is a part of the :ref:`limited API <limited-c-api>`."
msgstr ""

#: ../../c-api/unicode.rst:1067
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "Як :c:func:`PyUnicode_AsUTF8AndSize`, але не зберігає розмір."

#: ../../c-api/unicode.rst:1071
msgid ""
"This function does not have any special behavior for `null characters "
"<https://en.wikipedia.org/wiki/Null_character>`_ embedded within *unicode*. "
"As a result, strings containing null characters will remain in the returned "
"string, which some C functions might interpret as the end of the string, "
"leading to truncation. If truncation is an issue, it is recommended to use "
":c:func:`PyUnicode_AsUTF8AndSize` instead."
msgstr ""

#: ../../c-api/unicode.rst:1085
msgid "UTF-32 Codecs"
msgstr "Кодеки UTF-32"

#: ../../c-api/unicode.rst:1087
msgid "These are the UTF-32 codec APIs:"
msgstr "Це API кодеків UTF-32:"

#: ../../c-api/unicode.rst:1093
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Декодуйте байти *size* із рядка буфера, закодованого в UTF-32, і повертайте "
"відповідний об’єкт Unicode. *errors* (якщо не ``NULL``) визначає обробку "
"помилок. За замовчуванням встановлено \"суворий\"."

#: ../../c-api/unicode.rst:1097 ../../c-api/unicode.rst:1147
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr ""
"Якщо *byteorder* не ``NULL``, декодер починає декодування, використовуючи "
"вказаний порядок байтів::"

#: ../../c-api/unicode.rst:1100 ../../c-api/unicode.rst:1150
msgid ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"
msgstr ""

#: ../../c-api/unicode.rst:1104
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"Якщо ``*byteorder`` дорівнює нулю, а перші чотири байти вхідних даних є "
"міткою порядку байтів (BOM), декодер перемикається на цей порядок байтів і "
"BOM не копіюється в результуючий рядок Unicode. Якщо ``*byteorder`` дорівнює"
" ``-1`` або ``1``, будь-яка позначка порядку байтів копіюється до виводу."

#: ../../c-api/unicode.rst:1109
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end"
" of input data."
msgstr ""
"Після завершення *\\*byteorder* встановлюється на поточний порядок байтів у "
"кінці вхідних даних."

#: ../../c-api/unicode.rst:1112 ../../c-api/unicode.rst:1163
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr ""
"Якщо *byteorder* дорівнює ``NULL``, кодек запускається в режимі власного "
"порядку."

#: ../../c-api/unicode.rst:1114 ../../c-api/unicode.rst:1165
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1120
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not"
" treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як "
":c:func:`PyUnicode_DecodeUTF32`. Якщо *consumed* не дорівнює ``NULL``, "
":c:func:`PyUnicode_DecodeUTF32Stateful` не розглядатиме кінцеві неповні "
"послідовності байтів UTF-32 (наприклад, кількість байтів, що не ділиться на "
"чотири) як помилку. Ці байти не будуть декодовані, а кількість декодованих "
"байтів зберігатиметься в *спожитих*."

#: ../../c-api/unicode.rst:1129
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Повертає байтовий рядок Python, використовуючи кодування UTF-32 у рідному "
"порядку байтів. Рядок завжди починається з позначки BOM. Обробка помилок "
"\"строга\". Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1135
msgid "UTF-16 Codecs"
msgstr "Кодеки UTF-16"

#: ../../c-api/unicode.rst:1137
msgid "These are the UTF-16 codec APIs:"
msgstr "Це API кодека UTF-16:"

#: ../../c-api/unicode.rst:1143
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Декодуйте байти *size* із рядка буфера, закодованого в UTF-16, і повертайте "
"відповідний об’єкт Unicode. *errors* (якщо не ``NULL``) визначає обробку "
"помилок. За замовчуванням встановлено \"суворий\"."

#: ../../c-api/unicode.rst:1154
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"Якщо ``*byteorder`` дорівнює нулю, а перші два байти вхідних даних є міткою "
"порядку байтів (BOM), декодер перемикається на цей порядок байтів і BOM не "
"копіюється в результуючий рядок Unicode. Якщо ``*byteorder`` дорівнює ``-1``"
" або ``1``, будь-яка позначка порядку байтів копіюється до виводу (де це "
"призведе до ``\\ufeff`` або ``\\ufffe`` символ)."

#: ../../c-api/unicode.rst:1160
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end"
" of input data."
msgstr ""
"Після завершення ``*byteorder`` встановлюється на поточний порядок байтів у "
"кінці вхідних даних."

#: ../../c-api/unicode.rst:1171
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not"
" treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як "
":c:func:`PyUnicode_DecodeUTF16`. Якщо *consumed* не дорівнює ``NULL``, "
":c:func:`PyUnicode_DecodeUTF16Stateful` не розглядатиме кінцеві неповні "
"послідовності байтів UTF-16 (наприклад, непарну кількість байтів або "
"розділену сурогатну пару) як помилку. Ці байти не будуть декодовані, а "
"кількість декодованих байтів зберігатиметься в *спожитих*."

#: ../../c-api/unicode.rst:1180
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Повертає байтовий рядок Python, використовуючи кодування UTF-16 у рідному "
"порядку байтів. Рядок завжди починається з позначки BOM. Обробка помилок "
"\"строга\". Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1186
msgid "UTF-7 Codecs"
msgstr "Кодеки UTF-7"

#: ../../c-api/unicode.rst:1188
msgid "These are the UTF-7 codec APIs:"
msgstr "Це API кодека UTF-7:"

#: ../../c-api/unicode.rst:1193
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string"
" *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1200
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як "
":c:func:`PyUnicode_DecodeUTF7`. Якщо *consumed* не дорівнює ``NULL``, "
"кінцеві неповні розділи UTF-7 base-64 не розглядатимуться як помилка. Ці "
"байти не будуть декодовані, а кількість декодованих байтів зберігатиметься в"
" *спожитих*."

#: ../../c-api/unicode.rst:1207
msgid "Unicode-Escape Codecs"
msgstr "Кодеки Unicode-Escape"

#: ../../c-api/unicode.rst:1209
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "Це API кодека \"Unicode Escape\":"

#: ../../c-api/unicode.rst:1215
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""

#: ../../c-api/unicode.rst:1221
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою Unicode-Escape та поверніть результат "
"як об’єкт bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1227
msgid "Raw-Unicode-Escape Codecs"
msgstr "Кодеки Raw-Unicode-Escape"

#: ../../c-api/unicode.rst:1229
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "Це API кодека \"Raw Unicode Escape\":"

#: ../../c-api/unicode.rst:1235
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""

#: ../../c-api/unicode.rst:1241
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою Raw-Unicode-Escape та поверніть "
"результат як об’єкт bytes. Обробка помилок \"строга\". Повертає ``NULL``, "
"якщо кодек викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1247
msgid "Latin-1 Codecs"
msgstr "Кодеки Latin-1"

#: ../../c-api/unicode.rst:1249
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr ""
"Це API кодека Latin-1: Latin-1 відповідає першим 256 порядковим номерам "
"Unicode, і лише вони приймаються кодеками під час кодування."

#: ../../c-api/unicode.rst:1255
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1261
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою Latin-1 і поверніть результат як "
"об’єкт Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо "
"кодек викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1267
msgid "ASCII Codecs"
msgstr "Кодеки ASCII"

#: ../../c-api/unicode.rst:1269
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr ""
"Це API кодеків ASCII. Приймаються лише 7-бітні дані ASCII. Усі інші коди "
"генерують помилки."

#: ../../c-api/unicode.rst:1275
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string"
" *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1281
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою ASCII і поверніть результат як об’єкт "
"Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1287
msgid "Character Map Codecs"
msgstr "Кодеки карти символів"

#: ../../c-api/unicode.rst:1289
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`!encodings` package). The codec uses mappings "
"to encode and decode characters.  The mapping objects provided must support "
"the :meth:`~object.__getitem__` mapping interface; dictionaries and "
"sequences work well."
msgstr ""

#: ../../c-api/unicode.rst:1295
msgid "These are the mapping codec APIs:"
msgstr "Це API кодека відображення:"

#: ../../c-api/unicode.rst:1300
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *str*"
" using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1304
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"Якщо *mapping* має значення ``NULL``, буде застосовано декодування Latin-1. "
"Інакше *відображення* має зіставляти порядкові номери байтів (цілі числа в "
"діапазоні від 0 до 255) на рядки Unicode, цілі числа (які потім "
"інтерпретуються як порядкові номери Unicode) або ``None``. Невідображені "
"байти даних – ті, які викликають :exc:`LookupError`, а також ті, які "
"відображаються на ``None``, ``0xFFFE`` або ``'\\ufffe``, розглядаються як "
"невизначені відображення і викликати помилку."

#: ../../c-api/unicode.rst:1315
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if"
" an exception was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою даного об’єкта *mapping* і поверніть "
"результат як об’єкт bytes. Обробка помилок \"строга\". Повертає ``NULL``, "
"якщо кодек викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1319
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"Об’єкт *mapping* має зіставляти порядкові цілі числа Unicode з об’єктами "
"bytes, цілі числа в діапазоні від 0 до 255 або ``None``. Невідображені "
"порядкові символи (які спричиняють :exc:`LookupError`), а також відображені "
"на ``None`` розглядаються як \"невизначене відображення\" та викликають "
"помилку."

#: ../../c-api/unicode.rst:1325
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr ""
"Наступний кодек API є особливим у тому, що відображає Unicode на Unicode."

#: ../../c-api/unicode.rst:1329
msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr ""
"Перекладіть рядок, застосувавши до нього таблицю зіставлення символів і "
"поверніть отриманий об’єкт Unicode. Повертає ``NULL``, якщо кодек викликав "
"виняткову ситуацію."

#: ../../c-api/unicode.rst:1333
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr ""
"Таблиця відображення має зіставляти порядкові цілі числа Unicode з "
"порядковими цілими числами Unicode або \"Немає\" (спричиняючи видалення "
"символу)."

#: ../../c-api/unicode.rst:1336
msgid ""
"Mapping tables need only provide the :meth:`~object.__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""

#: ../../c-api/unicode.rst:1340
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr ""
"*помилки* має звичайне значення для кодеків. Це може бути ``NULL``, що "
"вказує на використання стандартної обробки помилок."

#: ../../c-api/unicode.rst:1345
msgid "MBCS codecs for Windows"
msgstr "Кодеки MBCS для Windows"

#: ../../c-api/unicode.rst:1347
msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"Це API кодека MBCS. Наразі вони доступні лише у Windows і використовують "
"конвертери Win32 MBCS для реалізації перетворень. Зауважте, що MBCS (або "
"DBCS) — це клас кодувань, а не одне. Цільове кодування визначається "
"налаштуваннями користувача на машині, на якій працює кодек."

#: ../../c-api/unicode.rst:1354
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""

#: ../../c-api/unicode.rst:1361
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як "
":c:func:`PyUnicode_DecodeMBCS`. Якщо *consumed* не дорівнює ``NULL``, "
":c:func:`PyUnicode_DecodeMBCSStateful` не декодуватиме кінцевий провідний "
"байт, а кількість декодованих байтів зберігатиметься в *consumed*."

#: ../../c-api/unicode.rst:1370
msgid ""
"Similar to :c:func:`PyUnicode_DecodeMBCSStateful`, except uses the code page"
" specified by *code_page*."
msgstr ""

#: ../../c-api/unicode.rst:1376
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою MBCS і поверніть результат як об’єкт "
"Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

#: ../../c-api/unicode.rst:1383
msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use "
":c:macro:`!CP_ACP` code page to get the MBCS encoder."
msgstr ""

#: ../../c-api/unicode.rst:1391
msgid "Methods & Slots"
msgstr "Методи та слоти"

#: ../../c-api/unicode.rst:1397
msgid "Methods and Slot Functions"
msgstr "Методи та функції слота"

#: ../../c-api/unicode.rst:1399
msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr ""
"Наступні API здатні обробляти об’єкти Unicode та рядки на вхідних даних (ми "
"називаємо їх рядками в описах) і повертати об’єкти Unicode або цілі числа "
"відповідно."

#: ../../c-api/unicode.rst:1403
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr ""
"Усі вони повертають ``NULL`` або ``-1``, якщо виникає виняткова ситуація."

#: ../../c-api/unicode.rst:1408
msgid "Concat two strings giving a new Unicode string."
msgstr "Concat два рядки дають новий рядок Unicode."

#: ../../c-api/unicode.rst:1413
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"Розділити рядок, що дасть список рядків Unicode. Якщо *sep* дорівнює "
"``NULL``, розділення буде виконано на всіх пробільних підрядках. В іншому "
"випадку на даному сепараторі відбуваються розбивання. Буде виконано не "
"більше ніж *maxsplit*. Якщо значення від’ємне, обмеження не встановлено. "
"Розділювачі не включені в отриманий список."

#: ../../c-api/unicode.rst:1418 ../../c-api/unicode.rst:1428
#: ../../c-api/unicode.rst:1449 ../../c-api/unicode.rst:1462
msgid "On error, return ``NULL`` with an exception set."
msgstr ""

#: ../../c-api/unicode.rst:1420
msgid "Equivalent to :py:meth:`str.split`."
msgstr ""

#: ../../c-api/unicode.rst:1425
msgid ""
"Similar to :c:func:`PyUnicode_Split`, but splitting will be done beginning "
"at the end of the string."
msgstr ""

#: ../../c-api/unicode.rst:1430
msgid "Equivalent to :py:meth:`str.rsplit`."
msgstr ""

#: ../../c-api/unicode.rst:1435
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepends* is ``0``, the Line "
"break characters are not included in the resulting strings."
msgstr ""

#: ../../c-api/unicode.rst:1442
msgid ""
"Split a Unicode string at the first occurrence of *sep*, and return a "
"3-tuple containing the part before the separator, the separator itself, and "
"the part after the separator. If the separator is not found, return a "
"3-tuple containing the string itself, followed by two empty strings."
msgstr ""

#: ../../c-api/unicode.rst:1447 ../../c-api/unicode.rst:1460
msgid "*sep* must not be empty."
msgstr ""

#: ../../c-api/unicode.rst:1451
msgid "Equivalent to :py:meth:`str.partition`."
msgstr ""

#: ../../c-api/unicode.rst:1456
msgid ""
"Similar to :c:func:`PyUnicode_Partition`, but split a Unicode string at the "
"last occurrence of *sep*. If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""

#: ../../c-api/unicode.rst:1464
msgid "Equivalent to :py:meth:`str.rpartition`."
msgstr ""

#: ../../c-api/unicode.rst:1469
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr ""
"З’єднайте послідовність рядків за допомогою заданого *роздільника* та "
"поверніть отриманий рядок Unicode."

#: ../../c-api/unicode.rst:1476
msgid ""
"Return ``1`` if *substr* matches ``unicode[start:end]`` at the given tail "
"end (*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` "
"a suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""

#: ../../c-api/unicode.rst:1484
msgid ""
"Return the first position of *substr* in ``unicode[start:end]`` using the "
"given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""

#: ../../c-api/unicode.rst:1494
msgid ""
"Return the first position of the character *ch* in ``unicode[start:end]`` "
"using the given *direction* (*direction* == ``1`` means to do a forward "
"search, *direction* == ``-1`` a backward search).  The return value is the "
"index of the first match; a value of ``-1`` indicates that no match was "
"found, and ``-2`` indicates that an error occurred and an exception has been"
" set."
msgstr ""

#: ../../c-api/unicode.rst:1502
msgid ""
"*start* and *end* are now adjusted to behave like ``unicode[start:end]``."
msgstr ""

#: ../../c-api/unicode.rst:1509
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``unicode[start:end]``.  Return ``-1`` if an error occurred."
msgstr ""

#: ../../c-api/unicode.rst:1516
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *unicode* with "
"*replstr* and return the resulting Unicode object. *maxcount* == ``-1`` "
"means replace all occurrences."
msgstr ""

#: ../../c-api/unicode.rst:1523
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr ""
"Порівняйте два рядки та поверніть ``-1``, ``0``, ``1`` для меншого, рівного "
"та більшого відповідно."

#: ../../c-api/unicode.rst:1526
msgid ""
"This function returns ``-1`` upon failure, so one should call "
":c:func:`PyErr_Occurred` to check for errors."
msgstr ""
"Ця функція повертає ``-1`` у разі помилки, тому слід викликати "
":c:func:`PyErr_Occurred`, щоб перевірити наявність помилок."

#: ../../c-api/unicode.rst:1532
msgid ""
"Compare a Unicode object with a char buffer which is interpreted as being "
"UTF-8 or ASCII encoded and return true (``1``) if they are equal, or false "
"(``0``) otherwise. If the Unicode object contains surrogate code points "
"(``U+D800`` - ``U+DFFF``) or the C string is not valid UTF-8, false (``0``) "
"is returned."
msgstr ""

#: ../../c-api/unicode.rst:1539 ../../c-api/unicode.rst:1560
msgid "This function does not raise exceptions."
msgstr "Ця функція не викликає винятків."

#: ../../c-api/unicode.rst:1546
msgid ""
"Similar to :c:func:`PyUnicode_EqualToUTF8AndSize`, but compute *string* "
"length using :c:func:`!strlen`. If the Unicode object contains null "
"characters, false (``0``) is returned."
msgstr ""

#: ../../c-api/unicode.rst:1555
msgid ""
"Compare a Unicode object, *unicode*, with *string* and return ``-1``, ``0``,"
" ``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""

#: ../../c-api/unicode.rst:1565
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr "Rich порівнює два рядки Unicode та повертає одне з наступного:"

#: ../../c-api/unicode.rst:1567
msgid "``NULL`` in case an exception was raised"
msgstr "``NULL`` у разі виникнення винятку"

#: ../../c-api/unicode.rst:1568
msgid ":c:data:`Py_True` or :c:data:`Py_False` for successful comparisons"
msgstr ""

#: ../../c-api/unicode.rst:1569
msgid ":c:data:`Py_NotImplemented` in case the type combination is unknown"
msgstr ""

#: ../../c-api/unicode.rst:1571
msgid ""
"Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, "
":c:macro:`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT`, and :c:macro:`Py_LE`."
msgstr ""

#: ../../c-api/unicode.rst:1577
msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr ""
"Повертає новий рядковий об’єкт із *format* і *args*; це аналогічно ``format "
"% args``."

#: ../../c-api/unicode.rst:1583
msgid ""
"Check whether *substr* is contained in *unicode* and return true or false "
"accordingly."
msgstr ""

#: ../../c-api/unicode.rst:1586
msgid ""
"*substr* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr ""

#: ../../c-api/unicode.rst:1592
msgid ""
"Intern the argument :c:expr:`*p_unicode` in place.  The argument must be the"
" address of a pointer variable pointing to a Python Unicode string object.  "
"If there is an existing interned string that is the same as "
":c:expr:`*p_unicode`, it sets :c:expr:`*p_unicode` to it (releasing the "
"reference to the old string object and creating a new :term:`strong "
"reference` to the interned string object), otherwise it leaves "
":c:expr:`*p_unicode` alone and interns it."
msgstr ""

#: ../../c-api/unicode.rst:1599
msgid ""
"(Clarification: even though there is a lot of talk about references, think "
"of this function as reference-neutral. You must own the object you pass in; "
"after the call you no longer own the passed-in reference, but you newly own "
"the result.)"
msgstr ""

#: ../../c-api/unicode.rst:1604
msgid ""
"This function never raises an exception. On error, it leaves its argument "
"unchanged without interning it."
msgstr ""

#: ../../c-api/unicode.rst:1607
msgid ""
"Instances of subclasses of :py:class:`str` may not be interned, that is, "
":c:expr:`PyUnicode_CheckExact(*p_unicode)` must be true. If it is not, then "
"-- as with any other error -- the argument is left unchanged."
msgstr ""

#: ../../c-api/unicode.rst:1611
msgid ""
"Note that interned strings are not “immortal”. You must keep a reference to "
"the result to benefit from interning."
msgstr ""

#: ../../c-api/unicode.rst:1617
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace`, meant for statically allocated strings."
msgstr ""

#: ../../c-api/unicode.rst:1620
msgid ""
"Return a new (\"owned\") reference to either a new Unicode string object "
"that has been interned, or an earlier interned string object with the same "
"value."
msgstr ""

#: ../../c-api/unicode.rst:1624
msgid ""
"Python may keep a reference to the result, or make it :term:`immortal`, "
"preventing it from being garbage-collected promptly. For interning an "
"unbounded number of different strings, such as ones coming from user input, "
"prefer calling :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace` directly."
msgstr ""

#: ../../c-api/unicode.rst:1632
msgid "Strings interned this way are made :term:`immortal`."
msgstr ""
