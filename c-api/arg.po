# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:47+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Parsing arguments and building values"
msgstr "Розбір аргументів і створення значень"

msgid ""
"These functions are useful when creating your own extensions functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""
"Ці функції корисні під час створення власних функцій і методів розширень. "
"Додаткова інформація та приклади доступні в :ref:`extending-index`."

msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, :c:"
"func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"Перші три з цих описаних функцій, :c:func:`PyArg_ParseTuple`, :c:func:"
"`PyArg_ParseTupleAndKeywords` і :c:func:`PyArg_Parse`, усі використовують "
"*форматні рядки*, які використовуються, щоб повідомити функції про очікувані "
"аргументи. Рядки формату використовують однаковий синтаксис для кожної з цих "
"функцій."

msgid "Parsing arguments"
msgstr "Розбір аргументів"

msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"Рядок формату складається з нуля або більше \"одиниць формату\". Одиниця "
"формату описує один об’єкт Python; зазвичай це один символ або послідовність "
"одиниць формату в дужках. За кількома винятками, одиниця формату, яка не є "
"послідовністю в дужках, зазвичай відповідає одному аргументу адреси для цих "
"функцій. У наступному описі форма в лапках є одиницею формату; запис у "
"(круглих) дужках — це тип об’єкта Python, який відповідає одиниці формату; а "
"запис у [квадратних] дужках — це тип змінної (змінних) C, адреса якої має "
"бути передана."

msgid "Strings and buffers"
msgstr "Рядки та буфери"

msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You "
"don't have to provide raw storage for the returned unicode or bytes area."
msgstr ""
"Ці формати дозволяють отримати доступ до об’єкта як до безперервної частини "
"пам’яті. Вам не потрібно надавати необроблене сховище для поверненої області "
"Юнікоду або байтів."

msgid ""
"In general, when a format sets a pointer to a buffer, the buffer is managed "
"by the corresponding Python object, and the buffer shares the lifetime of "
"this object.  You won't have to release any memory yourself. The only "
"exceptions are ``es``, ``es#``, ``et`` and ``et#``."
msgstr ""
"Загалом, коли формат встановлює вказівник на буфер, буфером керує "
"відповідний об’єкт Python, і буфер розділяє час життя цього об’єкта. Вам не "
"доведеться самостійно звільняти пам’ять. Єдиним винятком є ``es``, ``es#``, "
"``et`` і ``et#``."

msgid ""
"However, when a :c:type:`Py_buffer` structure gets filled, the underlying "
"buffer is locked so that the caller can subsequently use the buffer even "
"inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable "
"data being resized or destroyed.  As a result, **you have to call** :c:func:"
"`PyBuffer_Release` after you have finished processing the data (or in any "
"early abort case)."
msgstr ""
"Однак, коли структура :c:type:`Py_buffer` заповнюється, базовий буфер "
"блокується, щоб абонент згодом міг використовувати буфер навіть усередині "
"блоку :c:type:`Py_BEGIN_ALLOW_THREADS` без ризику зміни розміру змінних "
"даних або знищено. У результаті **ви повинні викликати** :c:func:"
"`PyBuffer_Release` після завершення обробки даних (або в будь-якому випадку "
"раннього переривання)."

msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "Якщо не зазначено інше, буфери не завершуються NUL."

msgid ""
"Some formats require a read-only :term:`bytes-like object`, and set a "
"pointer instead of a buffer structure.  They work by checking that the "
"object's :c:member:`PyBufferProcs.bf_releasebuffer` field is ``NULL``, which "
"disallows mutable objects such as :class:`bytearray`."
msgstr ""
"Деякі формати вимагають лише для читання :term:`bytes-like object` і "
"встановлюють вказівник замість буферної структури. Вони працюють, "
"перевіряючи, що поле :c:member:`PyBufferProcs.bf_releasebuffer` об’єкта має "
"значення ``NULL``, що забороняє змінні об’єкти, такі як :class:`bytearray`."

msgid ""
"For all ``#`` variants of formats (``s#``, ``y#``, etc.), the macro :c:macro:"
"`PY_SSIZE_T_CLEAN` must be defined before including :file:`Python.h`. On "
"Python 3.9 and older, the type of the length argument is :c:type:"
"`Py_ssize_t` if the :c:macro:`PY_SSIZE_T_CLEAN` macro is defined, or int "
"otherwise."
msgstr ""
"Для всіх варіантів форматів ``#`` (``s#``, ``y#`` тощо) макрос :c:macro:"
"`PY_SSIZE_T_CLEAN` має бути визначений перед включенням :file:`Python. h`. У "
"Python 3.9 і старіших версіях тип аргументу length є :c:type:`Py_ssize_t`, "
"якщо визначено макрос :c:macro:`PY_SSIZE_T_CLEAN`, або int в іншому випадку."

msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address "
"you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception "
"is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"Перетворення об’єкта Unicode на покажчик C на рядок символів. Покажчик на "
"існуючий рядок зберігається в змінній покажчика символів, адресу якої ви "
"передаєте. Рядок C закінчується NUL. Рядок Python не повинен містити "
"вбудованих нульових кодових точок; якщо це так, виникає виняток :exc:"
"`ValueError`. Об’єкти Unicode перетворюються на рядки C за допомогою "
"кодування ``'utf-8``. Якщо це перетворення не вдається, виникає помилка :exc:"
"`UnicodeError`."

msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`.  "
"If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with :c:func:"
"`PyUnicode_FSConverter` as *converter*."
msgstr ""
"Цей формат не приймає :term:`байтоподібні об’єкти <bytes-like object>`. Якщо "
"ви хочете прийняти шляхи до файлової системи та перетворити їх на рядки "
"символів C, бажано використовувати формат ``O&`` з :c:func:"
"`PyUnicode_FSConverter` як *перетворювач*."

msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr ""
"Раніше помилка :exc:`TypeError` виникала, коли в рядку Python зустрічалися "
"вбудовані нульові кодові точки."

msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` або :term:`bytes-like object`) [Py_buffer]"

msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Цей формат приймає як об’єкти Unicode, так і байтоподібні об’єкти. Він "
"заповнює структуру :c:type:`Py_buffer`, надану абонентом. У цьому випадку "
"результуючий рядок C може містити вбудовані байти NUL. Об’єкти Unicode "
"перетворюються на рядки C за допомогою кодування ``'utf-8``."

msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, :"
"c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, лише для читання :term:`bytes-like object`) [const "
"char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Like ``s*``, except that it doesn't accept mutable objects. The result is "
"stored into two C variables, the first one a pointer to a C string, the "
"second one its length. The string may contain embedded null bytes. Unicode "
"objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Як ``s*``, за винятком того, що він не приймає змінні об’єкти. Результат "
"зберігається у двох змінних C, перша з яких є покажчиком на рядок C, а друга "
"— її довжиною. Рядок може містити вбудовані нульові байти. Об’єкти Unicode "
"перетворюються на рядки C за допомогою кодування ``'utf-8``."

msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` або ``None``) [const char \\*]"

msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Подібно до ``s``, але об’єкт Python також може мати значення ``None``, у "
"цьому випадку вказівник C встановлено на ``NULL``."

msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytes-like object` або ``None``) [Py_buffer]"

msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to ``NULL``."
msgstr ""
"Подібно до ``s*``, але об’єкт Python також може бути ``None``, у цьому "
"випадку ``buf`` член структури :c:type:`Py_buffer` має значення ``NULL`` ."

msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str`, лише для читання :term:`bytes-like object` або "
"``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Подібно до ``s#``, але об’єкт Python також може мати значення ``None``, у "
"цьому випадку вказівник на C встановлюється як ``NULL``."

msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr "``y`` (тільки для читання :term:`bytes-like object`) [const char \\*]"

msgid ""
"This format converts a bytes-like object to a C pointer to a character "
"string; it does not accept Unicode objects.  The bytes buffer must not "
"contain embedded null bytes; if it does, a :exc:`ValueError` exception is "
"raised."
msgstr ""
"Цей формат перетворює байтоподібний об’єкт на вказівник C на рядок символів; "
"він не приймає об'єкти Unicode. Буфер байтів не повинен містити вбудованих "
"нульових байтів; якщо це так, виникає виняток :exc:`ValueError`."

msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr ""
"Раніше помилка :exc:`TypeError` виникала, коли в буфері байтів зустрічалися "
"вбудовані нульові байти."

msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytes-like object`) [Py_buffer]"

msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr ""
"Цей варіант ``s*`` не приймає об’єкти Unicode, лише байтоподібні об’єкти. "
"**Це рекомендований спосіб приймати двійкові дані.**"

msgid ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, :c:type:"
"`Py_ssize_t`]"
msgstr ""
"``y#`` (тільки для читання :term:`bytes-like object`) [const char \\*, :c:"
"type:`Py_ssize_t`]"

msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr ""
"Цей варіант ``s#`` не приймає об’єкти Unicode, лише байтоподібні об’єкти."

msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:type:`PyObject*`."
msgstr ""
"Вимагає, щоб об’єкт Python був об’єктом :class:`bytes` без будь-яких спроб "
"перетворення. Викликає :exc:`TypeError`, якщо об’єкт не є об’єктом bytes. "
"Змінна C також може бути оголошена як :c:type:`PyObject*`."

msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a :"
"class:`bytearray` object. The C variable may also be declared as :c:type:"
"`PyObject*`."
msgstr ""
"Вимагає, щоб об’єкт Python був об’єктом :class:`bytearray` без жодних спроб "
"перетворення. Викликає :exc:`TypeError`, якщо об’єкт не є об’єктом :class:"
"`bytearray`. Змінна C також може бути оголошена як :c:type:`PyObject*`."

msgid "``u`` (:class:`str`) [const Py_UNICODE \\*]"
msgstr "``u`` (:class:`str`) [const Py_UNICODE \\*]"

msgid ""
"Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of "
"Unicode characters.  You must pass the address of a :c:type:`Py_UNICODE` "
"pointer variable, which will be filled with the pointer to an existing "
"Unicode buffer.  Please note that the width of a :c:type:`Py_UNICODE` "
"character depends on compilation options (it is either 16 or 32 bits). The "
"Python string must not contain embedded null code points; if it does, a :exc:"
"`ValueError` exception is raised."
msgstr ""
"Перетворіть об’єкт Python Unicode на вказівник C на буфер із символами "
"Unicode, що закінчується NUL. Ви повинні передати адресу змінної вказівника :"
"c:type:`Py_UNICODE`, яка буде заповнена вказівником на існуючий буфер "
"Unicode. Зауважте, що ширина символу :c:type:`Py_UNICODE` залежить від "
"параметрів компіляції (це 16 або 32 біти). Рядок Python не повинен містити "
"вбудованих нульових кодових точок; якщо це так, виникає виняток :exc:"
"`ValueError`."

msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using :c:"
"func:`PyUnicode_AsWideCharString`."
msgstr ""
"Частина API старого стилю :c:type:`Py_UNICODE`; будь ласка, перейдіть на "
"використання :c:func:`PyUnicode_AsWideCharString`."

msgid "``u#`` (:class:`str`) [const Py_UNICODE \\*, :c:type:`Py_ssize_t`]"
msgstr "``u#`` (:class:`str`) [const Py_UNICODE \\*, :c:type:`Py_ssize_t`]"

msgid ""
"This variant on ``u`` stores into two C variables, the first one a pointer "
"to a Unicode data buffer, the second one its length.  This variant allows "
"null code points."
msgstr ""
"Цей варіант ``u`` зберігає дві змінні C, перша з яких є вказівником на буфер "
"даних Unicode, а друга – його довжину. Цей варіант допускає нульові кодові "
"точки."

msgid "``Z`` (:class:`str` or ``None``) [const Py_UNICODE \\*]"
msgstr "``Z`` (:class:`str` або ``None``) [const Py_UNICODE \\*]"

msgid ""
"Like ``u``, but the Python object may also be ``None``, in which case the :c:"
"type:`Py_UNICODE` pointer is set to ``NULL``."
msgstr ""
"Подібно до ``u``, але об’єкт Python також може мати значення ``None``, у "
"цьому випадку вказівник :c:type:`Py_UNICODE` має значення ``NULL``."

msgid ""
"``Z#`` (:class:`str` or ``None``) [const Py_UNICODE \\*, :c:type:"
"`Py_ssize_t`]"
msgstr ""
"``Z#`` (:class:`str` або ``None``) [const Py_UNICODE \\*, :c:type:"
"`Py_ssize_t`]"

msgid ""
"Like ``u#``, but the Python object may also be ``None``, in which case the :"
"c:type:`Py_UNICODE` pointer is set to ``NULL``."
msgstr ""
"Подібно до ``u#``, але об’єкт Python також може мати значення ``None``, у "
"цьому випадку вказівник :c:type:`Py_UNICODE` має значення ``NULL``."

msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  "
"The C variable may also be declared as :c:type:`PyObject*`."
msgstr ""
"Вимагає, щоб об’єкт Python був об’єктом Unicode, без будь-яких спроб "
"перетворення. Викликає :exc:`TypeError`, якщо об’єкт не є об’єктом Unicode. "
"Змінна C також може бути оголошена як :c:type:`PyObject*`."

msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (читання-запис :term:`bytes-like object`) [Py_buffer]"

msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call :c:func:"
"`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"Цей формат приймає будь-який об’єкт, який реалізує інтерфейс буфера читання-"
"запису. Він заповнює структуру :c:type:`Py_buffer`, надану абонентом. Буфер "
"може містити вбудовані нульові байти. Виклик має викликати :c:func:"
"`PyBuffer_Release`, коли це буде зроблено з буфером."

msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*кодування, char \\*\\*buffer]"

msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""
"Цей варіант на ``s`` використовується для кодування Юнікоду в символьний "
"буфер. Він працює лише для закодованих даних без вбудованих байтів NUL."

msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:type:`const char*` which points to the name of an encoding as a "
"NUL-terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:type:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument."
msgstr ""
"Цей формат вимагає двох аргументів. Перший використовується лише як вхід і "
"має бути :c:type:`const char*`, який вказує на ім’я кодування як рядок із "
"закінченням NUL, або ``NULL``, у цьому випадку ``' використовується "
"кодування utf-8''``. Виняток виникає, якщо назване кодування невідоме "
"Python. Другим аргументом має бути :c:type:`char**`; значення покажчика, на "
"який він посилається, буде встановлено на буфер із вмістом тексту аргументу. "
"Текст буде закодовано в кодуванні, визначеному першим аргументом."

msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :c:func:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` виділить буфер необхідного розміру, скопіює "
"закодовані дані в цей буфер і налаштує *\\*buffer* для посилання на щойно "
"виділене сховище. Виклик відповідає за виклик :c:func:`PyMem_Free`, щоб "
"звільнити виділений буфер після використання."

msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` або :class:`bytearray`) [const char "
"\\*кодування, char \\*\\*buffer]"

msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"Те саме, що ``es``, за винятком того, що об’єкти рядків байтів передаються "
"без їх перекодування. Натомість реалізація припускає, що об’єкт рядка байтів "
"використовує кодування, передане як параметр."

msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*кодування, char \\*\\*буфер, :c:type:"
"`Py_ssize_t` \\*buffer_length]"

msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer. "
"Unlike the ``es`` format, this variant allows input data which contains NUL "
"characters."
msgstr ""
"Цей варіант ``s#`` використовується для кодування Юнікоду в символьний "
"буфер. На відміну від формату ``es``, цей варіант дозволяє вводити дані, які "
"містять символи NUL."

msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :c:type:`const char*` which points to the name of an encoding as a NUL-"
"terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is used. "
"An exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:type:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"Для цього потрібні три аргументи. Перший використовується лише як вхід і має "
"бути :c:type:`const char*`, який вказує на ім’я кодування як рядок із "
"закінченням NUL, або ``NULL``, у цьому випадку ``' використовується "
"кодування utf-8''``. Виняток виникає, якщо назване кодування невідоме "
"Python. Другим аргументом має бути :c:type:`char**`; значення покажчика, на "
"який він посилається, буде встановлено на буфер із вмістом тексту аргументу. "
"Текст буде закодовано в кодуванні, визначеному першим аргументом. Третій "
"аргумент повинен бути вказівником на ціле число; ціле число, на яке "
"посилається, буде встановлено на кількість байтів у вихідному буфері."

msgid "There are two modes of operation:"
msgstr "Є два режими роботи:"

msgid ""
"If *\\*buffer* points a ``NULL`` pointer, the function will allocate a "
"buffer of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"Якщо *\\*buffer* вказує на вказівник ``NULL``, функція виділить буфер "
"необхідного розміру, скопіює закодовані дані в цей буфер і встановить "
"*\\*buffer* для посилання на щойно виділене сховище. Виклик відповідає за "
"виклик :c:func:`PyMem_Free`, щоб звільнити виділений буфер після "
"використання."

msgid ""
"If *\\*buffer* points to a non-``NULL`` pointer (an already allocated "
"buffer), :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"Якщо *\\*buffer* вказує на вказівник, відмінний від ``NULL`` (уже виділений "
"буфер), :c:func:`PyArg_ParseTuple` використовуватиме це розташування як "
"буфер та інтерпретуватиме початкове значення *\\*buffer_length* як розмір "
"буфера. Потім він скопіює закодовані дані в буфер і завершить його NUL. Якщо "
"буфер недостатньо великий, буде встановлено :exc:`ValueError`."

msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""
"В обох випадках *\\*buffer_length* встановлюється на довжину закодованих "
"даних без кінцевого байта NUL."

msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` або :class:`bytearray`) [const char "
"\\*кодування, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"

msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"Те саме, що ``es#``, за винятком того, що байтові рядкові об’єкти "
"передаються без їх перекодування. Натомість реалізація припускає, що об’єкт "
"рядка байтів використовує кодування, передане як параметр."

msgid "Numbers"
msgstr "Числа"

msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [беззнаковий символ]"

msgid ""
"Convert a nonnegative Python integer to an unsigned tiny int, stored in a C :"
"c:type:`unsigned char`."
msgstr ""
"Перетворіть невід’ємне ціле число Python на беззнакове крихітне int, що "
"зберігається в C :c:type:`unsigned char`."

msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [беззнаковий символ]"

msgid ""
"Convert a Python integer to a tiny int without overflow checking, stored in "
"a C :c:type:`unsigned char`."
msgstr ""
"Перетворюйте ціле число Python на крихітне int без перевірки переповнення, "
"що зберігається в C :c:type:`unsigned char`."

msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [короткий int]"

msgid "Convert a Python integer to a C :c:type:`short int`."
msgstr "Перетворіть ціле число Python на C :c:type:`short int`."

msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

msgid ""
"Convert a Python integer to a C :c:type:`unsigned short int`, without "
"overflow checking."
msgstr ""
"Перетворіть ціле число Python на C :c:type:`unsigned short int` без "
"перевірки переповнення."

msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

msgid "Convert a Python integer to a plain C :c:type:`int`."
msgstr "Перетворіть ціле число Python на звичайне C :c:type:`int`."

msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

msgid ""
"Convert a Python integer to a C :c:type:`unsigned int`, without overflow "
"checking."
msgstr ""
"Перетворіть ціле число Python на C :c:type:`unsigned int` без перевірки "
"переповнення."

msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [довге ціле]"

msgid "Convert a Python integer to a C :c:type:`long int`."
msgstr "Перетворіть ціле число Python на C :c:type:`long int`."

msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [беззнаковий довгий]"

msgid ""
"Convert a Python integer to a C :c:type:`unsigned long` without overflow "
"checking."
msgstr ""
"Перетворіть ціле число Python на C :c:type:`unsigned long` без перевірки "
"переповнення."

msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [довгий довгий]"

msgid "Convert a Python integer to a C :c:type:`long long`."
msgstr "Перетворіть ціле число Python на C :c:type:`long long`."

msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [беззнаковий довгий довгий]"

msgid ""
"Convert a Python integer to a C :c:type:`unsigned long long` without "
"overflow checking."
msgstr ""
"Перетворіть ціле число Python на C :c:type:`unsigned long long` без "
"перевірки переповнення."

msgid "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"
msgstr "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"

msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "Перетворіть ціле число Python на C :c:type:`Py_ssize_t`."

msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` або :class:`bytearray` довжиною 1) [char]"

msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray` "
"object of length 1, to a C :c:type:`char`."
msgstr ""
"Перетворіть байт Python, представлений як об’єкт :class:`bytes` або :class:"
"`bytearray` довжини 1, на C :c:type:`char`."

msgid "Allow :class:`bytearray` objects."
msgstr "Дозволити об’єкти :class:`bytearray`."

msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` довжини 1) [int]"

msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:type:`int`."
msgstr ""
"Перетворіть символ Python, представлений як об’єкт :class:`str` довжини 1, "
"на C :c:type:`int`."

msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [float]"

msgid "Convert a Python floating point number to a C :c:type:`float`."
msgstr "Перетворіть число з плаваючою комою Python на C :c:type:`float`."

msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [double]"

msgid "Convert a Python floating point number to a C :c:type:`double`."
msgstr "Перетворіть число з плаваючою комою Python на C :c:type:`double`."

msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr ""
"Перетворіть комплексне число Python на структуру C :c:type:`Py_complex`."

msgid "Other objects"
msgstr "Інші об'єкти"

msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (об'єкт) [PyObject \\*]"

msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  The object's "
"reference count is not increased.  The pointer stored is not ``NULL``."
msgstr ""
"Зберігайте об’єкт Python (без будь-якого перетворення) у покажчику на об’єкт "
"C. Таким чином, програма C отримує фактичний об’єкт, який було передано. "
"Кількість посилань на об'єкт не збільшується. Збережений покажчик не є "
"``NULL``."

msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (об'єкт) [*typeobject*, PyObject \\*]"

msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :c:type:`PyObject*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""
"Зберігайте об’єкт Python у покажчику на об’єкт C. Це схоже на ``O``, але "
"приймає два аргументи C: перший — це адреса об’єкта типу Python, другий — "
"адреса змінної C (типу :c:type:`PyObject*`) у в якому зберігається покажчик "
"на об’єкт. Якщо об’єкт Python не має потрібного типу, виникає :exc:"
"`TypeError`."

msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (об'єкт) [*конвертер*, *що завгодно*]"

msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :c:type:`void *`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"Перетворіть об’єкт Python на змінну C за допомогою функції *конвертера*. Для "
"цього потрібні два аргументи: перший — функція, другий — адреса змінної C "
"(довільного типу), перетворена на :c:type:`void *`. Функція *converter* у "
"свою чергу викликається наступним чином:"

msgid ""
"where *object* is the Python object to be converted and *address* is the :c:"
"type:`void*` argument that was passed to the :c:func:`PyArg_Parse\\*` "
"function. The returned *status* should be ``1`` for a successful conversion "
"and ``0`` if the conversion has failed.  When the conversion fails, the "
"*converter* function should raise an exception and leave the content of "
"*address* unmodified."
msgstr ""
"де *object* — це об’єкт Python, який потрібно перетворити, а *address* — це "
"аргумент :c:type:`void*`, який було передано до функції :c:func:"
"`PyArg_Parse\\*`. Повернений *статус* має бути ``1`` для успішного "
"перетворення та ``0``, якщо перетворення не вдалося. Якщо перетворення "
"завершується невдачею, функція *конвертер* має викликати виняток і залишати "
"вміст *адреси* без змін."

msgid ""
"If the *converter* returns ``Py_CLEANUP_SUPPORTED``, it may get called a "
"second time if the argument parsing eventually fails, giving the converter a "
"chance to release any memory that it had already allocated. In this second "
"call, the *object* parameter will be ``NULL``; *address* will have the same "
"value as in the original call."
msgstr ""
"Якщо *конвертер* повертає ``Py_CLEANUP_SUPPORTED``, він може бути викликаний "
"вдруге, якщо синтаксичний аналіз аргументу врешті-решт не вдається, даючи "
"конвертеру можливість звільнити будь-яку пам’ять, яку він уже виділив. У "
"цьому другому виклику параметр *object* буде ``NULL``; *адреса* матиме те "
"саме значення, що й у вихідному виклику."

msgid "``Py_CLEANUP_SUPPORTED`` was added."
msgstr "Додано ``Py_CLEANUP_SUPPORTED``."

msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about "
"how Python tests values for truth."
msgstr ""
"Перевіряє передане значення на істинність (логічне значення **p**\\ повторне "
"визначення) і перетворює результат на еквівалентне ціле значення C true/"
"false. Встановлює int на ``1``, якщо вираз був істинним, і ``0``, якщо він "
"був false. Це приймає будь-яке дійсне значення Python. Перегляньте :ref:"
"`truth` для отримання додаткової інформації про те, як Python перевіряє "
"значення на істинність."

msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""
"Об’єкт має бути послідовністю Python, довжина якої дорівнює кількості "
"одиниць формату в *елементах*. Аргументи C мають відповідати окремим "
"одиницям формату в *items*. Одиниці формату для послідовностей можуть бути "
"вкладеними."

msgid ""
"It is possible to pass \"long\" integers (integers whose value exceeds the "
"platform's :const:`LONG_MAX`) however no proper range checking is done --- "
"the most significant bits are silently truncated when the receiving field is "
"too small to receive the value (actually, the semantics are inherited from "
"downcasts in C --- your mileage may vary)."
msgstr ""
"Можна передати \"довгі\" цілі числа (цілі числа, значення яких перевищує "
"значення платформи :const:`LONG_MAX`), однак належна перевірка діапазону не "
"виконується --- старші біти мовчки скорочуються, коли поле прийому замале "
"для отримання значення (насправді, семантика успадкована від downcasts у C "
"--- ваш пробіг може відрізнятися)."

msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""
"Кілька інших символів мають значення в рядку формату. Вони можуть не "
"знаходитися всередині вкладених дужок. Вони є:"

msgid "``|``"
msgstr "``|``"

msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"Вказує, що решта аргументів у списку аргументів Python необов’язкові. Змінні "
"C, які відповідають необов’язковим аргументам, мають бути ініціалізовані "
"значенням за замовчуванням --- коли необов’язковий аргумент не вказано, :c:"
"func:`PyArg_ParseTuple` не торкається вмісту відповідних змінних C."

msgid "``$``"
msgstr "``$``"

msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always "
"be specified before ``$`` in the format string."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` only: вказує, що решта аргументів у "
"списку аргументів Python є лише ключовими словами. Наразі всі аргументи лише "
"для ключових слів також мають бути необов’язковими, тому ``|`` завжди "
"потрібно вказувати перед ``$`` у рядку формату."

msgid "``:``"
msgstr "``:``"

msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"Тут список одиниць формату закінчується; рядок після двокрапки "
"використовується як ім’я функції в повідомленнях про помилки (\"пов’язане "
"значення\" винятку, яке викликає :c:func:`PyArg_ParseTuple`)."

msgid "``;``"
msgstr "``;``"

msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""
"Тут список одиниць формату закінчується; рядок після крапки з комою "
"використовується як повідомлення про помилку *замість* повідомлення про "
"помилку за замовчуванням. ``:`` і ``;`` взаємно виключають один одного."

msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"Зауважте, що будь-які посилання на об’єкти Python, які надаються абоненту, є "
"*позиченими* посиланнями; не зменшуйте кількість посилань!"

msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"Додатковими аргументами, що передаються цим функціям, повинні бути адреси "
"змінних, тип яких визначається рядком формату; вони використовуються для "
"зберігання значень із вхідного кортежу. Є кілька випадків, як описано у "
"списку одиниць формату вище, де ці параметри використовуються як вхідні "
"значення; вони повинні відповідати тому, що вказано для відповідної одиниці "
"формату в цьому випадку."

msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the :c:func:`PyArg_Parse\\*` "
"functions return true, otherwise they return false and raise an appropriate "
"exception. When the :c:func:`PyArg_Parse\\*` functions fail due to "
"conversion failure in one of the format units, the variables at the "
"addresses corresponding to that and the following format units are left "
"untouched."
msgstr ""
"Щоб перетворення відбулося успішно, об’єкт *arg* має відповідати формату, а "
"формат має бути вичерпаним. У разі успіху функції :c:func:`PyArg_Parse\\*` "
"повертають true, інакше вони повертають false і викликають відповідний "
"виняток. Коли функції :c:func:`PyArg_Parse\\*` виходять з ладу через помилку "
"перетворення в одному з блоків формату, змінні за адресами, що відповідають "
"цьому та наступним блокам формату, залишаються недоторканими."

msgid "API Functions"
msgstr "Функції API"

msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false "
"and raises the appropriate exception."
msgstr ""
"Проаналізуйте параметри функції, яка приймає лише позиційні параметри в "
"локальні змінні. Повертає true в разі успіху; у разі невдачі повертає false "
"і викликає відповідний виняток."

msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Ідентичний :c:func:`PyArg_ParseTuple`, за винятком того, що він приймає "
"va_list, а не змінну кількість аргументів."

msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables.  The *keywords* argument is a ``NULL``-"
"terminated array of keyword parameter names.  Empty names denote :ref:"
"`positional-only parameters <positional-only_parameter>`. Returns true on "
"success; on failure, it returns false and raises the appropriate exception."
msgstr ""
"Проаналізуйте параметри функції, яка приймає як позиційні, так і ключові "
"параметри в локальні змінні. Аргумент *keywords* — це масив імен параметрів "
"ключових слів із закінченням ``NULL``. Порожні імена позначають :ref:"
"`позиційні параметри <positional-only_parameter>`. Повертає true в разі "
"успіху; у разі невдачі повертає false і викликає відповідний виняток."

msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""
"Додано підтримку :ref:`позиційних параметрів <positional-only_parameter>`."

msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a "
"va_list rather than a variable number of arguments."
msgstr ""
"Ідентичний :c:func:`PyArg_ParseTupleAndKeywords`, за винятком того, що він "
"приймає va_list, а не змінну кількість аргументів."

msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"Переконайтеся, що ключі в словнику аргументів ключових слів є рядками. Це "
"потрібно, лише якщо :c:func:`PyArg_ParseTupleAndKeywords` не "
"використовується, оскільки останній вже виконує цю перевірку."

msgid ""
"Function used to deconstruct the argument lists of \"old-style\" functions "
"--- these are functions which use the :const:`METH_OLDARGS` parameter "
"parsing method, which has been removed in Python 3.  This is not recommended "
"for use in parameter parsing in new code, and most code in the standard "
"interpreter has been modified to no longer use this for that purpose.  It "
"does remain a convenient way to decompose other tuples, however, and may "
"continue to be used for that purpose."
msgstr ""
"Функція, яка використовується для деконструювання списків аргументів функцій "
"\"старого стилю\" --- це функції, які використовують метод аналізу "
"параметрів :const:`METH_OLDARGS`, який було видалено в Python 3. Це не "
"рекомендовано використовувати для аналізу параметрів у новому коді, і "
"більшість коду в стандартному інтерпретаторі було змінено, щоб більше не "
"використовувати це для цієї мети. Однак він залишається зручним способом "
"розкладання інших кортежів і може продовжувати використовуватися для цієї "
"мети."

msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :const:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:type:`PyObject*` variable; these will be filled "
"in with the values from *args*; they will contain :term:`borrowed references "
"<borrowed reference>`. The variables which correspond to optional parameters "
"not given by *args* will not be filled in; these should be initialized by "
"the caller. This function returns true on success and false if *args* is not "
"a tuple or contains the wrong number of elements; an exception will be set "
"if there was a failure."
msgstr ""
"Простіша форма отримання параметрів, яка не використовує рядок формату для "
"визначення типів аргументів. Функції, які використовують цей метод для "
"отримання своїх параметрів, мають бути оголошені як :const:`METH_VARARGS` у "
"таблицях функцій або методів. Кортеж, що містить фактичні параметри, слід "
"передати як *args*; насправді це має бути кортеж. Довжина кортежу має бути "
"не менше *min* і не більше *max*; *min* і *max* можуть бути рівними. У "
"функцію повинні бути передані додаткові аргументи, кожен з яких має бути "
"вказівником на змінну :c:type:`PyObject*`; вони будуть заповнені значеннями "
"з *args*; вони міститимуть :term:`позичені посилання <borrowed reference>`. "
"Змінні, які відповідають необов’язковим параметрам, не заданим *args*, не "
"будуть заповнені; вони повинні бути ініціалізовані абонентом. Ця функція "
"повертає true у разі успіху та false, якщо *args* не є кортежем або містить "
"неправильну кількість елементів; якщо сталася помилка, буде встановлено "
"виняток."

msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`_weakref` helper module for weak references::"
msgstr ""
"Це приклад використання цієї функції, взятий із джерел допоміжного модуля :"
"mod:`_weakref` для слабких посилань:"

msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"Виклик :c:func:`PyArg_UnpackTuple` у цьому прикладі повністю еквівалентний "
"виклику :c:func:`PyArg_ParseTuple`::"

msgid "Building values"
msgstr "Формування цінностей"

msgid ""
"Create a new value based on a format string similar to those accepted by "
"the :c:func:`PyArg_Parse\\*` family of functions and a sequence of values.  "
"Returns the value or ``NULL`` in the case of an error; an exception will be "
"raised if ``NULL`` is returned."
msgstr ""
"Створіть нове значення на основі рядка формату, подібного до тих, що "
"приймаються сімейством функцій :c:func:`PyArg_Parse\\*` і послідовністю "
"значень. Повертає значення або ``NULL`` у разі помилки; виняток буде "
"викликано, якщо буде повернуто ``NULL``."

msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force "
"it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` не завжди створює кортеж. Він створює кортеж, лише "
"якщо його рядок формату містить дві або більше одиниць формату. Якщо рядок "
"формату порожній, повертається ``None``; якщо він містить рівно одну одиницю "
"формату, він повертає будь-який об’єкт, описаний цією одиницею формату. Щоб "
"змусити його повертати кортеж розміром 0 або одиницю, візьміть рядок формату "
"в дужки."

msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes :c:func:"
"`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`, your "
"code is responsible for calling :c:func:`free` for that memory once :c:func:"
"`Py_BuildValue` returns."
msgstr ""
"Коли буфери пам’яті передаються як параметри для надання даних для створення "
"об’єктів, як і для форматів ``s`` і ``s#``, необхідні дані копіюються. "
"Об’єкти, створені :c:func:`Py_BuildValue`, ніколи не посилаються на буфери, "
"надані абонентом. Іншими словами, якщо ваш код викликає :c:func:`malloc` і "
"передає виділену пам’ять :c:func:`Py_BuildValue`, ваш код відповідальний за "
"виклик :c:func:`free` для цієї пам’яті один раз :c:func:`Py_BuildValue` "
"повертає."

msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"У наступному описі форма в лапках є одиницею формату; запис у (круглих) "
"дужках — це тип об’єкта Python, який поверне блок формату; і запис у "
"[квадратних] дужках є типом значень C, які потрібно передати."

msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long "
"format strings a tad more readable."
msgstr ""
"Символи пробілу, табуляції, двокрапки та коми ігноруються в рядках "
"форматування (але не в одиницях форматування, таких як ``s#``). Це можна "
"використати, щоб зробити рядки довгого формату трохи більш читабельними."

msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``s`` (:class:`str` або ``None``) [const char \\*]"

msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, ``None`` is used."
msgstr ""
"Перетворіть рядок C із нульовим закінченням на об’єкт Python :class:`str` за "
"допомогою кодування ``'utf-8'``. Якщо вказівник на рядок C має значення "
"``NULL``, використовується ``None``."

msgid ""
"``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str` або ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Перетворіть рядок C та його довжину на об’єкт Python :class:`str` за "
"допомогою кодування ``'utf-8'``. Якщо покажчик рядка C має значення "
"``NULL``, довжина ігнорується і повертається ``None``."

msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [const char \\*]"

msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string "
"pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Це перетворює рядок C на об’єкт Python :class:`bytes`. Якщо вказівник на "
"рядок C має значення ``NULL``, повертається ``None``."

msgid "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Це перетворює рядок C та його довжину на об’єкт Python. Якщо вказівник на "
"рядок C має значення ``NULL``, повертається ``None``."

msgid "Same as ``s``."
msgstr "Те саме, що ``s``."

msgid ""
"``z#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str` або ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid "Same as ``s#``."
msgstr "Те саме, що ``s#``."

msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr "``u`` (:class:`str`) [const wchar_t \\*]"

msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"``NULL``, ``None`` is returned."
msgstr ""
"Перетворіть буфер даних Unicode (UTF-16 або UCS-4) :c:type:`wchar_t` із "
"закінченням нульовим символом на об’єкт Python Unicode. Якщо покажчик буфера "
"Unicode має значення ``NULL``, повертається ``None``."

msgid "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"
msgstr "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Перетворіть буфер даних Unicode (UTF-16 або UCS-4) і його довжину на об’єкт "
"Python Unicode. Якщо покажчик буфера Unicode має значення ``NULL``, довжина "
"ігнорується і повертається ``None``."

msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``U`` (:class:`str` або ``None``) [const char \\*]"

msgid ""
"``U#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``U#`` (:class:`str` або ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid "Convert a plain C :c:type:`int` to a Python integer object."
msgstr "Перетворіть простий C :c:type:`int` на цілочисельний об’єкт Python."

msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [символ]"

msgid "Convert a plain C :c:type:`char` to a Python integer object."
msgstr "Перетворіть звичайний C :c:type:`char` на цілочисельний об’єкт Python."

msgid "Convert a plain C :c:type:`short int` to a Python integer object."
msgstr ""
"Перетворіть простий C :c:type:`short int` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`long int` to a Python integer object."
msgstr "Перетворіть C :c:type:`long int` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`unsigned char` to a Python integer object."
msgstr "Перетворіть C :c:type:`unsigned char` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`unsigned short int` to a Python integer object."
msgstr ""
"Перетворіть C :c:type:`unsigned short int` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`unsigned int` to a Python integer object."
msgstr "Перетворіть C :c:type:`unsigned int` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`unsigned long` to a Python integer object."
msgstr "Перетворіть C :c:type:`unsigned long` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`long long` to a Python integer object."
msgstr "Перетворіть C :c:type:`long long` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`unsigned long long` to a Python integer object."
msgstr ""
"Перетворіть C :c:type:`unsigned long long` на цілочисельний об’єкт Python."

msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "Перетворіть C :c:type:`Py_ssize_t` на ціле число Python."

msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` довжиною 1) [символ]"

msgid ""
"Convert a C :c:type:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr ""
"Перетворіть C :c:type:`int`, що представляє байт, на об’єкт Python :class:"
"`bytes` довжини 1."

msgid ""
"Convert a C :c:type:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr ""
"Перетворіть C :c:type:`int`, що представляє символ, на Python :class:`str` "
"об’єкт довжини 1."

msgid "Convert a C :c:type:`double` to a Python floating point number."
msgstr "Перетворіть C :c:type:`double` на число з плаваючою комою Python."

msgid "Convert a C :c:type:`float` to a Python floating point number."
msgstr "Перетворіть C :c:type:`float` на число з плаваючою комою Python."

msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [Py_complex \\*]"

msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr ""
"Перетворіть структуру C :c:type:`Py_complex` на комплексне число Python."

msgid ""
"Pass a Python object untouched (except for its reference count, which is "
"incremented by one).  If the object passed in is a ``NULL`` pointer, it is "
"assumed that this was caused because the call producing the argument found "
"an error and set an exception. Therefore, :c:func:`Py_BuildValue` will "
"return ``NULL`` but won't raise an exception.  If no exception has been "
"raised yet, :exc:`SystemError` is set."
msgstr ""
"Передайте об’єкт Python без змін (крім його кількості посилань, яка "
"збільшується на одиницю). Якщо переданий об’єкт є вказівником ``NULL``, "
"припускається, що це сталося через те, що виклик, що створює аргумент, "
"знайшов помилку та встановив виняток. Тому :c:func:`Py_BuildValue` поверне "
"``NULL``, але не викличе виняткову ситуацію. Якщо жодного винятку ще не було "
"викликано, встановлено :exc:`SystemError`."

msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (об'єкт) [PyObject \\*]"

msgid "Same as ``O``."
msgstr "Те саме, що \"О\"."

msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (об'єкт) [PyObject \\*]"

msgid ""
"Same as ``O``, except it doesn't increment the reference count on the "
"object. Useful when the object is created by a call to an object constructor "
"in the argument list."
msgstr ""
"Те саме, що ``O``, за винятком того, що він не збільшує кількість посилань "
"на об’єкт. Корисно, коли об’єкт створюється за допомогою виклику "
"конструктора об’єкта в списку аргументів."

msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with :c:type:"
"`void*`) as its argument and should return a \"new\" Python object, or "
"``NULL`` if an error occurred."
msgstr ""
"Перетворюйте *що завгодно* в об’єкт Python за допомогою функції "
"*конвертера*. Функція викликається з *будь-яким* (що має бути сумісним з :c:"
"type:`void*`) як аргументом і має повертати \"новий\" об’єкт Python або "
"``NULL``, якщо сталася помилка."

msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr ""
"Перетворіть послідовність значень C на кортеж Python із такою ж кількістю "
"елементів."

msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*matching-items*]"

msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr ""
"Перетворіть послідовність значень C на список Python з такою ж кількістю "
"елементів."

msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*відповідні-елементи*]"

msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr ""
"Перетворіть послідовність значень C у словник Python. Кожна пара послідовних "
"значень C додає один елемент до словника, який виконує функції ключа та "
"значення відповідно."

msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and ``NULL`` returned."
msgstr ""
"Якщо в рядку формату є помилка, встановлюється виняток :exc:`SystemError` і "
"повертається ``NULL``."

msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Ідентичний :c:func:`Py_BuildValue`, за винятком того, що він приймає "
"va_list, а не змінну кількість аргументів."
