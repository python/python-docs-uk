# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-22 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr "Ініціалізація, фіналізація та потоки"

#: ../../c-api/init.rst:10
msgid ""
"See :ref:`Python Initialization Configuration <init-config>` for details on "
"how to configure the interpreter prior to initialization."
msgstr ""

#: ../../c-api/init.rst:16
msgid "Before Python Initialization"
msgstr "Перед ініціалізацією Python"

#: ../../c-api/init.rst:18
msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function "
"must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables "
"<global-conf-vars>`."
msgstr ""
"У програмі, яка вбудовує Python, функція :c:func:`Py_Initialize` має бути "
"викликана перед використанням будь-яких інших функцій API Python/C; за "
"винятком кількох функцій і :ref:`глобальних змінних конфігурації <global-"
"conf-vars>`."

#: ../../c-api/init.rst:23
msgid ""
"The following functions can be safely called before Python is initialized:"
msgstr "Наступні функції можна безпечно викликати до ініціалізації Python:"

#: ../../c-api/init.rst:25
msgid "Functions that initialize the interpreter:"
msgstr ""

#: ../../c-api/init.rst:27
msgid ":c:func:`Py_Initialize`"
msgstr ""

#: ../../c-api/init.rst:28
msgid ":c:func:`Py_InitializeEx`"
msgstr ""

#: ../../c-api/init.rst:29
msgid ":c:func:`Py_InitializeFromConfig`"
msgstr ":c:func:`Py_InitializeFromConfig`"

#: ../../c-api/init.rst:30
msgid ":c:func:`Py_BytesMain`"
msgstr ":c:func:`Py_BytesMain`"

#: ../../c-api/init.rst:31
msgid ":c:func:`Py_Main`"
msgstr ""

#: ../../c-api/init.rst:32
msgid "the runtime pre-initialization functions covered in :ref:`init-config`"
msgstr ""

#: ../../c-api/init.rst:34
msgid "Configuration functions:"
msgstr "Функції конфігурації:"

#: ../../c-api/init.rst:36
msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

#: ../../c-api/init.rst:37
msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

#: ../../c-api/init.rst:38
msgid ":c:func:`!PyInitFrozenExtensions`"
msgstr ""

#: ../../c-api/init.rst:39
msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

#: ../../c-api/init.rst:40
msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

#: ../../c-api/init.rst:41
msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

#: ../../c-api/init.rst:42
msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

#: ../../c-api/init.rst:43
msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

#: ../../c-api/init.rst:44
msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

#: ../../c-api/init.rst:45
msgid "the configuration functions covered in :ref:`init-config`"
msgstr ""

#: ../../c-api/init.rst:47
msgid "Informative functions:"
msgstr "Інформативні функції:"

#: ../../c-api/init.rst:49 ../../c-api/init.rst:57
msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:50
msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

#: ../../c-api/init.rst:51
msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

#: ../../c-api/init.rst:52
msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

#: ../../c-api/init.rst:53
msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

#: ../../c-api/init.rst:54
msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

#: ../../c-api/init.rst:55
msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

#: ../../c-api/init.rst:56
msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:59
msgid "Utilities:"
msgstr "Утиліти:"

#: ../../c-api/init.rst:61
msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

#: ../../c-api/init.rst:62
msgid ""
"the status reporting and utility functions covered in :ref:`init-config`"
msgstr ""

#: ../../c-api/init.rst:64
msgid "Memory allocators:"
msgstr "Розподільники пам'яті:"

#: ../../c-api/init.rst:66
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:67
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/init.rst:68
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/init.rst:69
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/init.rst:71
msgid "Synchronization:"
msgstr ""

#: ../../c-api/init.rst:73
msgid ":c:func:`PyMutex_Lock`"
msgstr ""

#: ../../c-api/init.rst:74
msgid ":c:func:`PyMutex_Unlock`"
msgstr ""

#: ../../c-api/init.rst:78
msgid ""
"Despite their apparent similarity to some of the functions listed above, the"
" following functions **should not be called** before the interpreter has "
"been initialized: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, "
":c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, "
":c:func:`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, "
":c:func:`Py_GetProgramName`, :c:func:`PyEval_InitThreads`, and "
":c:func:`Py_RunMain`."
msgstr ""

#: ../../c-api/init.rst:90
msgid "Global configuration variables"
msgstr "Глобальні змінні конфігурації"

#: ../../c-api/init.rst:92
msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled by "
":ref:`command line options <using-on-interface-options>`."
msgstr ""
"Python має змінні для глобальної конфігурації для керування різними "
"функціями та параметрами. За замовчуванням ці позначки контролюються "
":ref:`параметрами командного рядка <using-on-interface-options>`."

#: ../../c-api/init.rst:96
msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` sets "
":c:data:`Py_BytesWarningFlag` to 1 and ``-bb`` sets "
":c:data:`Py_BytesWarningFlag` to 2."
msgstr ""
"Коли параметр встановлює прапор, значення прапора дорівнює кількості разів, "
"коли цей параметр було встановлено. Наприклад, ``-b`` встановлює "
":c:data:`Py_BytesWarningFlag` на 1, а ``-bb`` встановлює "
":c:data:`Py_BytesWarningFlag` на 2."

#: ../../c-api/init.rst:102
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.bytes_warning` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:106
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with "
":class:`str` or :class:`bytes` with :class:`int`.  Issue an error if greater"
" or equal to ``2``."
msgstr ""
"Видає попередження, коли порівнює :class:`bytes` або :class:`bytearray` з "
":class:`str` або :class:`bytes` з :class:`int`. Видає помилку, якщо більше "
"або дорівнює ``2``."

#: ../../c-api/init.rst:110
msgid "Set by the :option:`-b` option."
msgstr "Встановлюється параметром :option:`-b`."

#: ../../c-api/init.rst:116
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.parser_debug` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:120
msgid ""
"Turn on parser debugging output (for expert only, depending on compilation "
"options)."
msgstr ""
"Увімкніть вихід налагодження аналізатора (лише для експерта, залежно від "
"параметрів компіляції)."

#: ../../c-api/init.rst:123
msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-d` і змінною середовища "
":envvar:`PYTHONDEBUG`."

#: ../../c-api/init.rst:130
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.write_bytecode` should be used instead, see :ref:`Python"
" Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:134
msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the import "
"of source modules."
msgstr ""
"Якщо встановлено ненульове значення, Python не намагатиметься записати файли"
" ``.pyc`` під час імпорту вихідних модулів."

#: ../../c-api/init.rst:137
msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ""
"Встановлюється параметром :option:`-B` і змінною середовища "
":envvar:`PYTHONDONTWRITEBYTECODE`."

#: ../../c-api/init.rst:144
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.pathconfig_warnings` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:148
msgid ""
"Suppress error messages when calculating the module search path in "
":c:func:`Py_GetPath`."
msgstr ""
"Придушити повідомлення про помилки під час обчислення шляху пошуку модуля в "
":c:func:`Py_GetPath`."

#: ../../c-api/init.rst:151
msgid "Private flag used by ``_freeze_module`` and ``frozenmain`` programs."
msgstr ""

#: ../../c-api/init.rst:157
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.hash_seed` and :c:member:`PyConfig.use_hash_seed` should"
" be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""

#: ../../c-api/init.rst:162
msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set to "
"a non-empty string."
msgstr ""
"Установіть значення ``1``, якщо змінна середовища :envvar:`PYTHONHASHSEED` "
"має значення непорожнього рядка."

#: ../../c-api/init.rst:165
msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr ""
"Якщо прапорець відмінний від нуля, прочитайте змінну середовища "
":envvar:`PYTHONHASHSEED`, щоб ініціалізувати секретне початкове значення "
"хешу."

#: ../../c-api/init.rst:172
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.use_environment` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:176
msgid ""
"Ignore all :envvar:`!PYTHON*` environment variables, e.g. "
":envvar:`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""

#: ../../c-api/init.rst:179
msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr "Встановлюється параметрами :option:`-E` і :option:`-I`."

#: ../../c-api/init.rst:185
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.inspect` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:189
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, even"
" when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"Якщо сценарій передається як перший аргумент або використовується параметр "
":option:`-c`, увійдіть в інтерактивний режим після виконання сценарію або "
"команди, навіть якщо :data:`sys.stdin` не виглядає як термінал."

#: ../../c-api/init.rst:193
msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-i` і змінною середовища "
":envvar:`PYTHONINSPECT`."

#: ../../c-api/init.rst:200
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.interactive` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:204
msgid "Set by the :option:`-i` option."
msgstr "Встановлюється параметром :option:`-i`."

#: ../../c-api/init.rst:210
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.isolated` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:214
msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"Запустіть Python в ізольованому режимі. В ізольованому режимі "
":data:`sys.path` не містить ані каталогу сценарію, ані каталогу сайту-"
"пакетів користувача."

#: ../../c-api/init.rst:217
msgid "Set by the :option:`-I` option."
msgstr "Встановлюється параметром :option:`-I`."

#: ../../c-api/init.rst:225
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyPreConfig.legacy_windows_fs_encoding` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:229
msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error "
"handler, instead of the UTF-8 encoding with ``surrogatepass`` error handler,"
" for the :term:`filesystem encoding and error handler`."
msgstr ""
"Якщо прапорець відмінний від нуля, використовуйте кодування ``mbcs`` із "
"обробником помилок ``replace``, замість кодування UTF-8 із ``surrogatepass``"
" обробником помилок, для :term:`filesystem encoding and error handler`."

#: ../../c-api/init.rst:233
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
"Установіть значення ``1``, якщо змінна середовища "
":envvar:`PYTHONLEGACYWINDOWSFSENCODING` має значення непорожнього рядка."

#: ../../c-api/init.rst:236
msgid "See :pep:`529` for more details."
msgstr "Дивіться :pep:`529` для більш детальної інформації."

#: ../../c-api/init.rst:238 ../../c-api/init.rst:256
msgid "Availability"
msgstr ""

#: ../../c-api/init.rst:244
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.legacy_windows_stdio` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:248
msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of "
":class:`!io._WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""

#: ../../c-api/init.rst:251
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment variable "
"is set to a non-empty string."
msgstr ""
"Установіть значення ``1``, якщо змінна середовища "
":envvar:`PYTHONLEGACYWINDOWSSTDIO` має значення непорожнього рядка."

#: ../../c-api/init.rst:254
msgid "See :pep:`528` for more details."
msgstr "Дивіться :pep:`528` для більш детальної інформації."

#: ../../c-api/init.rst:262
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.site_import` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:266
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call "
":func:`site.main` if you want them to be triggered)."
msgstr ""
"Вимкніть імпорт модуля :mod:`site` і залежні від сайту маніпуляції "
":data:`sys.path`, які він передбачає. Також вимкніть ці маніпуляції, якщо "
":mod:`site` буде явно імпортовано пізніше (викличте :func:`site.main`, якщо "
"ви хочете, щоб вони були активовані)."

#: ../../c-api/init.rst:271
msgid "Set by the :option:`-S` option."
msgstr "Встановлюється параметром :option:`-S`."

#: ../../c-api/init.rst:277
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.user_site_directory` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:281
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to "
":data:`sys.path`."
msgstr ""
"Не додавайте каталог :data:`user site-packages <site.USER_SITE>` до "
":data:`sys.path`."

#: ../../c-api/init.rst:284
msgid ""
"Set by the :option:`-s` and :option:`-I` options, and the "
":envvar:`PYTHONNOUSERSITE` environment variable."
msgstr ""
"Встановлюється параметрами :option:`-s` і :option:`-I`, а також змінною "
"середовища :envvar:`PYTHONNOUSERSITE`."

#: ../../c-api/init.rst:291
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.optimization_level` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:295
msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-O` і змінною середовища "
":envvar:`PYTHONOPTIMIZE`."

#: ../../c-api/init.rst:302
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.quiet` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:306
msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr ""
"Не відображайте повідомлення про авторські права та версію навіть в "
"інтерактивному режимі."

#: ../../c-api/init.rst:308
msgid "Set by the :option:`-q` option."
msgstr "Встановлюється параметром :option:`-q`."

#: ../../c-api/init.rst:316
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.buffered_stdio` should be used instead, see :ref:`Python"
" Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:320
msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "Примусово розбуферизувати потоки stdout і stderr."

#: ../../c-api/init.rst:322
msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ""
"Встановлюється параметром :option:`-u` і змінною середовища "
":envvar:`PYTHONUNBUFFERED`."

#: ../../c-api/init.rst:329
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.verbose` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:333
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or equal "
"to ``2``, print a message for each file that is checked for when searching "
"for a module. Also provides information on module cleanup at exit."
msgstr ""
"Друкувати повідомлення кожного разу, коли модуль ініціалізовано, із "
"зазначенням місця (ім’я файлу чи вбудованого модуля), з якого він "
"завантажується. Якщо більше або дорівнює ``2``, друкувати повідомлення для "
"кожного файлу, який перевіряється під час пошуку модуля. Також надає "
"інформацію про очищення модуля при виході."

#: ../../c-api/init.rst:338
msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-v` і змінною середовища "
":envvar:`PYTHONVERBOSE`."

#: ../../c-api/init.rst:345
msgid "Initializing and finalizing the interpreter"
msgstr "Ініціалізація та завершення інтерпретатора"

#: ../../c-api/init.rst:360
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; see "
":ref:`Before Python Initialization <pre-init-safe>` for the few exceptions."
msgstr ""
"Ініціалізація інтерпретатора Python. У програмі, що вбудовує Python, це слід"
" викликати перед використанням будь-яких інших функцій API Python/C; див. "
":ref:`Перед ініціалізацією Python <pre-init-safe>` для кількох винятків."

#: ../../c-api/init.rst:364
msgid ""
"This initializes the table of loaded modules (``sys.modules``), and creates "
"the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`. It "
"also initializes the module search path (``sys.path``). It does not set "
"``sys.argv``; use the :ref:`Python Initialization Configuration <init-"
"config>` API for that. This is a no-op when called for a second time "
"(without calling :c:func:`Py_FinalizeEx` first).  There is no return value; "
"it is a fatal error if the initialization fails."
msgstr ""

#: ../../c-api/init.rst:372 ../../c-api/init.rst:386
msgid ""
"Use :c:func:`Py_InitializeFromConfig` to customize the :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:376
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"У Windows змінює режим консолі з ``O_TEXT`` на ``O_BINARY``, що також вплине"
" на використання консолі не на Python за допомогою C Runtime."

#: ../../c-api/init.rst:382
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which may be useful when CPython is embedded as part of a larger "
"application."
msgstr ""

#: ../../c-api/init.rst:392
msgid ""
"Initialize Python from *config* configuration, as described in :ref:`init-"
"from-config`."
msgstr ""

#: ../../c-api/init.rst:395
msgid ""
"See the :ref:`init-config` section for details on pre-initializing the "
"interpreter, populating the runtime configuration structure, and querying "
"the returned status structure."
msgstr ""

#: ../../c-api/init.rst:402
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Повертає істину (не нуль), якщо інтерпретатор Python ініціалізовано, і false"
" (нуль), якщо ні. Після виклику :c:func:`Py_FinalizeEx` повертається false, "
"доки :c:func:`Py_Initialize` не буде викликано знову."

#: ../../c-api/init.rst:409
msgid ""
"Return true (non-zero) if the main Python interpreter is :term:`shutting "
"down <interpreter shutdown>`. Return false (zero) otherwise."
msgstr ""

#: ../../c-api/init.rst:417
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters (see "
":c:func:`Py_NewInterpreter` below) that were created and not yet destroyed "
"since the last call to :c:func:`Py_Initialize`.  Ideally, this frees all "
"memory allocated by the Python interpreter.  This is a no-op when called for"
" a second time (without calling :c:func:`Py_Initialize` again first)."
msgstr ""

#: ../../c-api/init.rst:424
msgid ""
"Since this is the reverse of :c:func:`Py_Initialize`, it should be called in"
" the same thread with the same interpreter active.  That means the main "
"thread and the main interpreter. This should never be called while "
":c:func:`Py_RunMain` is running."
msgstr ""

#: ../../c-api/init.rst:429
msgid ""
"Normally the return value is ``0``. If there were errors during finalization"
" (flushing buffered data), ``-1`` is returned."
msgstr ""

#: ../../c-api/init.rst:433
msgid ""
"This function is provided for a number of reasons.  An embedding application"
" might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks"
" in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"Ця функція передбачена з кількох причин. Програма для вбудовування може "
"захотіти перезапустити Python без необхідності перезапускати саму програму. "
"Програма, яка завантажила інтерпретатор Python із динамічно завантажуваної "
"бібліотеки (або DLL), може захотіти звільнити всю пам’ять, виділену Python, "
"перед вивантаженням DLL. Під час пошуку витоків пам’яті в програмі розробник"
" може захотіти звільнити всю пам’ять, виділену Python, перш ніж вийти з "
"програми."

#: ../../c-api/init.rst:441
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`~object.__del__` "
"methods) to fail when they depend on other objects (even functions) or "
"modules.  Dynamically loaded extension modules loaded by Python are not "
"unloaded.  Small amounts of memory allocated by the Python interpreter may "
"not be freed (if you find a leak, please report it).  Memory tied up in "
"circular references between objects is not freed.  Some memory allocated by "
"extension modules may not be freed.  Some extensions may not work properly "
"if their initialization routine is called more than once; this can happen if"
" an application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` "
"more than once."
msgstr ""

#: ../../c-api/init.rst:452
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython._PySys_ClearAuditHooks`` with no arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``cpython._PySys_ClearAuditHooks`` "
"без аргументів."

#: ../../c-api/init.rst:459
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr ""
"Це зворотно сумісна версія :c:func:`Py_FinalizeEx`, яка не враховує "
"значення, що повертається."

#: ../../c-api/init.rst:465
msgid ""
"Similar to :c:func:`Py_Main` but *argv* is an array of bytes strings, "
"allowing the calling application to delegate the text decoding step to the "
"CPython runtime."
msgstr ""

#: ../../c-api/init.rst:474
msgid ""
"The main program for the standard interpreter, encapsulating a full "
"initialization/finalization cycle, as well as additional behaviour to "
"implement reading configurations settings from the environment and command "
"line, and then executing ``__main__`` in accordance with :ref:`using-on-"
"cmdline`."
msgstr ""

#: ../../c-api/init.rst:480
msgid ""
"This is made available for programs which wish to support the full CPython "
"command line interface, rather than just embedding a Python runtime in a "
"larger application."
msgstr ""

#: ../../c-api/init.rst:484
msgid ""
"The *argc* and *argv* parameters are similar to those which are passed to a "
"C program's :c:func:`main` function, except that the *argv* entries are "
"first converted to ``wchar_t`` using :c:func:`Py_DecodeLocale`. It is also "
"important to note that the argument list entries may be modified to point to"
" strings other than those passed in (however, the contents of the strings "
"pointed to by the argument list are not modified)."
msgstr ""

#: ../../c-api/init.rst:491
msgid ""
"The return value will be ``0`` if the interpreter exits normally (i.e., "
"without an exception), ``1`` if the interpreter exits due to an exception, "
"or ``2`` if the argument list does not represent a valid Python command "
"line."
msgstr ""

#: ../../c-api/init.rst:496
msgid ""
"Note that if an otherwise unhandled :exc:`SystemExit` is raised, this "
"function will not return ``1``, but exit the process, as long as "
"``Py_InspectFlag`` is not set. If ``Py_InspectFlag`` is set, execution will "
"drop into the interactive Python prompt, at which point a second otherwise "
"unhandled :exc:`SystemExit` will still exit the process, while any other "
"means of exiting will set the return value as described above."
msgstr ""

#: ../../c-api/init.rst:503
msgid ""
"In terms of the CPython runtime configuration APIs documented in the "
":ref:`runtime configuration <init-config>` section (and without accounting "
"for error handling), ``Py_Main`` is approximately equivalent to::"
msgstr ""

#: ../../c-api/init.rst:507
msgid ""
"PyConfig config;\n"
"PyConfig_InitPythonConfig(&config);\n"
"PyConfig_SetArgv(&config, argc, argv);\n"
"Py_InitializeFromConfig(&config);\n"
"PyConfig_Clear(&config);\n"
"\n"
"Py_RunMain();"
msgstr ""

#: ../../c-api/init.rst:515
msgid ""
"In normal usage, an embedding application will call this function *instead* "
"of calling :c:func:`Py_Initialize`, :c:func:`Py_InitializeEx` or "
":c:func:`Py_InitializeFromConfig` directly, and all settings will be applied"
" as described elsewhere in this documentation. If this function is instead "
"called *after* a preceding runtime initialization API call, then exactly "
"which environmental and command line configuration settings will be updated "
"is version dependent (as it depends on which settings correctly support "
"being modified after they have already been set once when the runtime was "
"first initialized)."
msgstr ""

#: ../../c-api/init.rst:528
msgid "Executes the main module in a fully configured CPython runtime."
msgstr ""

#: ../../c-api/init.rst:530
msgid ""
"Executes the command (:c:member:`PyConfig.run_command`), the script "
"(:c:member:`PyConfig.run_filename`) or the module "
"(:c:member:`PyConfig.run_module`) specified on the command line or in the "
"configuration. If none of these values are set, runs the interactive Python "
"prompt (REPL) using the ``__main__`` module's global namespace."
msgstr ""

#: ../../c-api/init.rst:536
msgid ""
"If :c:member:`PyConfig.inspect` is not set (the default), the return value "
"will be ``0`` if the interpreter exits normally (that is, without raising an"
" exception), or ``1`` if the interpreter exits due to an exception. If an "
"otherwise unhandled :exc:`SystemExit` is raised, the function will "
"immediately exit the process instead of returning ``1``."
msgstr ""

#: ../../c-api/init.rst:542
msgid ""
"If :c:member:`PyConfig.inspect` is set (such as when the :option:`-i` option"
" is used), rather than returning when the interpreter exits, execution will "
"instead resume in an interactive Python prompt (REPL) using the ``__main__``"
" module's global namespace. If the interpreter exited with an exception, it "
"is immediately raised in the REPL session. The function return value is then"
" determined by the way the *REPL session* terminates: returning ``0`` if the"
" session terminates without raising an unhandled exception, exiting "
"immediately for an unhandled :exc:`SystemExit`, and returning ``1`` for any "
"other unhandled exception."
msgstr ""

#: ../../c-api/init.rst:552
msgid ""
"This function always finalizes the Python interpreter regardless of whether "
"it returns a value or immediately exits the process due to an unhandled "
":exc:`SystemExit` exception."
msgstr ""

#: ../../c-api/init.rst:556
msgid ""
"See :ref:`Python Configuration <init-python-config>` for an example of a "
"customized Python that always runs in isolated mode using "
":c:func:`Py_RunMain`."
msgstr ""

#: ../../c-api/init.rst:562
msgid "Process-wide parameters"
msgstr "Параметри для всього процесу"

#: ../../c-api/init.rst:572
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.program_name` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:576
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to"
" the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Цю функцію слід викликати перед першим викликом :c:func:`Py_Initialize`, "
"якщо вона взагалі викликається. Він повідомляє інтерпретатору значення "
"аргументу ``argv[0]`` для функції :c:func:`main` програми (перетворене на "
"широкі символи). Це використовується :c:func:`Py_GetPath` та деякими іншими "
"функціями нижче для пошуку бібліотек часу виконання Python відносно "
"виконуваного файлу інтерпретатора. Значення за замовчуванням - ``'python'``."
" Аргумент має вказувати на широкий символьний рядок із нульовим закінченням "
"у статичній пам’яті, вміст якої не змінюватиметься протягом виконання "
"програми. Жоден код інтерпретатора Python не змінить вміст цього сховища."

#: ../../c-api/init.rst:587 ../../c-api/init.rst:829 ../../c-api/init.rst:865
#: ../../c-api/init.rst:891
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a "
":c:expr:`wchar_*` string."
msgstr ""

#: ../../c-api/init.rst:595
msgid ""
"Return the program name set with :c:member:`PyConfig.program_name`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""

#: ../../c-api/init.rst:599 ../../c-api/init.rst:621 ../../c-api/init.rst:667
#: ../../c-api/init.rst:689 ../../c-api/init.rst:715 ../../c-api/init.rst:903
msgid ""
"This function should not be called before :c:func:`Py_Initialize`, otherwise"
" it returns ``NULL``."
msgstr ""
"Цю функцію не слід викликати перед :c:func:`Py_Initialize`, інакше вона "
"повертає ``NULL``."

#: ../../c-api/init.rst:602 ../../c-api/init.rst:624 ../../c-api/init.rst:670
#: ../../c-api/init.rst:692 ../../c-api/init.rst:720 ../../c-api/init.rst:906
msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr ""
"Тепер він повертає ``NULL``, якщо викликаний перед :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:605 ../../c-api/init.rst:695
msgid "Get :data:`sys.executable` instead."
msgstr ""

#: ../../c-api/init.rst:611
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set with"
" :c:member:`PyConfig.program_name` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller"
" should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the :option:`--prefix` "
"argument to the :program:`configure` script at build time.  The value is "
"available to Python code as ``sys.base_prefix``. It is only useful on Unix."
"  See also the next function."
msgstr ""

#: ../../c-api/init.rst:627
msgid ""
"Get :data:`sys.base_prefix` instead, or :data:`sys.prefix` if :ref:`virtual "
"environments <venv-def>` need to be handled."
msgstr ""

#: ../../c-api/init.rst:634
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set with"
" :c:member:`PyConfig.program_name` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix"
" is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to the "
":makevar:`exec_prefix` variable in the top-level :file:`Makefile` and the "
"``--exec-prefix`` argument to the :program:`configure` script at build  "
"time.  The value is available to Python code as ``sys.base_exec_prefix``.  "
"It is only useful on Unix."
msgstr ""

#: ../../c-api/init.rst:645
msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform"
" independent may be installed in :file:`/usr/local`."
msgstr ""
"Довідкова інформація: префікс exec відрізняється від префікса, коли залежні "
"від платформи файли (такі як виконувані файли та спільні бібліотеки) "
"інстальовано в іншому дереві каталогів. У типовій інсталяції залежні від "
"платформи файли можна інсталювати у піддереві :file:`/usr/local/plat`, а "
"незалежні від платформи — у :file:`/usr/local`."

#: ../../c-api/init.rst:651
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another platform."
"  Different major revisions of the same operating system generally also form"
" different platforms.  Non-Unix operating systems are a different story; the"
" installation strategies on those systems are so different that the prefix "
"and exec-prefix are meaningless, and set to the empty string. Note that "
"compiled Python bytecode files are platform independent (but not independent"
" from the Python version by which they were compiled!)."
msgstr ""
"Загалом, платформа – це комбінація сімейства апаратного та програмного "
"забезпечення, напр. Машини Sparc під керуванням операційної системи Solaris "
"2.x вважаються тією самою платформою, але машини Intel під керуванням "
"Solaris 2.x є іншою платформою, а машини Intel під керуванням Linux є ще "
"іншою платформою. Різні основні версії однієї операційної системи, як "
"правило, створюють різні платформи. Інша історія — операційні системи, "
"відмінні від Unix; стратегії встановлення в цих системах настільки різні, що"
" префікс і префікс exec не мають сенсу та встановлюються як порожній рядок. "
"Зауважте, що скомпільовані файли байт-коду Python не залежать від платформи "
"(але не залежать від версії Python, за допомогою якої вони були "
"скомпільовані!)."

#: ../../c-api/init.rst:662
msgid ""
"System administrators will know how to configure the :program:`mount` or "
":program:`automount` programs to share :file:`/usr/local` between platforms "
"while having :file:`/usr/local/plat` be a different filesystem for each "
"platform."
msgstr ""
"Системні адміністратори знатимуть, як налаштувати програми :program:`mount` "
"або :program:`automount` для спільного використання :file:`/usr/local` між "
"платформами, використовуючи :file:`/usr/local/plat` різні файлові системи "
"для кожної платформи."

#: ../../c-api/init.rst:673
msgid ""
"Get :data:`sys.base_exec_prefix` instead, or :data:`sys.exec_prefix` if "
":ref:`virtual environments <venv-def>` need to be handled."
msgstr ""

#: ../../c-api/init.rst:683
msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:member:`PyConfig.program_name`). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""

#: ../../c-api/init.rst:705
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:member:`PyConfig.program_name`) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path"
" for loading modules."
msgstr ""

#: ../../c-api/init.rst:723
msgid "Get :data:`sys.path` instead."
msgstr ""

#: ../../c-api/init.rst:729
msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr ""
"Повернути версію цього інтерпретатора Python. Це рядок, який виглядає "
"приблизно так::"

#: ../../c-api/init.rst:732
msgid "\"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\""
msgstr ""

#: ../../c-api/init.rst:736
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated by a"
" period.  The returned string points into static storage; the caller should "
"not modify its value.  The value is available to Python code as "
":data:`sys.version`."
msgstr ""
"Перше слово (до першого символу пробілу) є поточною версією Python; перші "
"символи — це головна та другорядна версії, розділені крапкою. Повернений "
"рядок вказує на статичне сховище; абонент не повинен змінювати його "
"значення. Значення доступне для коду Python як :data:`sys.version`."

#: ../../c-api/init.rst:741
msgid "See also the :c:var:`Py_Version` constant."
msgstr ""

#: ../../c-api/init.rst:748
msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On macOS, it "
"is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.platform``."
msgstr ""
"Повертає ідентифікатор платформи для поточної платформи. В Unix це "
"формується з \"офіційної\" назви операційної системи, перетвореної на нижній"
" регістр, за якою йде основний номер версії; наприклад, для Solaris 2.x, яка"
" також відома як SunOS 5.x, значенням є ``'sunos5``. У macOS це "
"``'darwin'``. У Windows це ``'win'``. Повернений рядок вказує на статичне "
"сховище; абонент не повинен змінювати його значення. Значення доступне для "
"коду Python як ``sys.platform``."

#: ../../c-api/init.rst:759
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr ""
"Поверніть, наприклад, офіційний рядок авторських прав для поточної версії "
"Python"

#: ../../c-api/init.rst:761
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr ""
"``'Авторське право 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:765
msgid ""
"The returned string points into static storage; the caller should not modify"
" its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"Повернений рядок вказує на статичне сховище; абонент не повинен змінювати "
"його значення. Значення доступне для коду Python як ``sys.copyright``."

#: ../../c-api/init.rst:771
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr ""
"Повертає вказівку компілятора, використаного для створення поточної версії "
"Python, у квадратних дужках, наприклад::"

#: ../../c-api/init.rst:774
msgid "\"[GCC 2.7.2.2]\""
msgstr ""

#: ../../c-api/init.rst:778 ../../c-api/init.rst:792
msgid ""
"The returned string points into static storage; the caller should not modify"
" its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"Повернений рядок вказує на статичне сховище; абонент не повинен змінювати "
"його значення. Значення доступне для коду Python як частина змінної "
"``sys.version``."

#: ../../c-api/init.rst:785
msgid ""
"Return information about the sequence number and build date and time  of the"
" current Python interpreter instance, for example ::"
msgstr ""
"Повертає інформацію про порядковий номер, дату й час збирання поточного "
"екземпляра інтерпретатора Python, наприклад::"

#: ../../c-api/init.rst:788
msgid "\"#67, Aug  1 1997, 22:34:28\""
msgstr ""

#: ../../c-api/init.rst:804
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.argv`, :c:member:`PyConfig.parse_argv` and "
":c:member:`PyConfig.safe_path` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:809
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"Встановити :data:`sys.argv` на основі *argc* і *argv*. Ці параметри подібні "
"до тих, що передаються до функції програми :c:func:`main` з тією різницею, "
"що перший запис має посилатися на файл сценарію, який буде виконано, а не на"
" виконуваний файл, у якому розміщено інтерпретатор Python. Якщо сценарію, "
"який буде запущено, немає, перший запис у *argv* може бути порожнім рядком. "
"Якщо цій функції не вдається ініціалізувати :data:`sys.argv`, за допомогою "
":c:func:`Py_FatalError` повідомляється про фатальну умову."

#: ../../c-api/init.rst:817
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"Якщо *updatepath* дорівнює нулю, це все, що функція робить. Якщо "
"*updatepath* відмінний від нуля, функція також змінює :data:`sys.path` "
"відповідно до наступного алгоритму:"

#: ../../c-api/init.rst:821
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to "
":data:`sys.path`."
msgstr ""
"Якщо ім’я існуючого сценарію передається в ``argv[0]``, абсолютний шлях до "
"каталогу, де розташований сценарій, додається до :data:`sys.path`."

#: ../../c-api/init.rst:824
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which"
" is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"В іншому випадку (тобто, якщо *argc* дорівнює ``0`` або ``argv[0]`` не "
"вказує на існуюче ім’я файлу), до :data:`sys.path` додається порожній рядок,"
" що те саме, що додавати поточний робочий каталог (``\".\"``)."

#: ../../c-api/init.rst:832 ../../c-api/init.rst:868
msgid ""
"See also :c:member:`PyConfig.orig_argv` and :c:member:`PyConfig.argv` "
"members of the :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:836
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See :cve:`2008-5983`."
msgstr ""

#: ../../c-api/init.rst:841
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called "
":c:func:`PySys_SetArgv`, for example using::"
msgstr ""
"У версіях до 3.1.3 ви можете досягти того самого ефекту, вручну витягнувши "
"перший елемент :data:`sys.path` після виклику :c:func:`PySys_SetArgv`, "
"наприклад, використовуючи::"

#: ../../c-api/init.rst:845
msgid "PyRun_SimpleString(\"import sys; sys.path.pop(0)\\n\");"
msgstr ""

#: ../../c-api/init.rst:857
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.argv` and :c:member:`PyConfig.parse_argv` should be used"
" instead, see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:861
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with the "
":option:`-I`."
msgstr ""
"Ця функція працює як :c:func:`PySys_SetArgvEx` з *updatepath*, встановленим "
"на ``1``, якщо інтерпретатор :program:`python` не було запущено з "
":option:`-I`."

#: ../../c-api/init.rst:871
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "Значення *updatepath* залежить від :option:`-I`."

#: ../../c-api/init.rst:878
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.home` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:882
msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"Встановіть типовий \"домашній\" каталог, тобто розташування стандартних "
"бібліотек Python. Дивіться :envvar:`PYTHONHOME` для визначення значення "
"рядка аргументу."

#: ../../c-api/init.rst:886
msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Аргумент має вказувати на символьний рядок із нульовим закінченням у "
"статичному сховищі, вміст якого не змінюватиметься протягом виконання "
"програми. Жоден код інтерпретатора Python не змінить вміст цього сховища."

#: ../../c-api/init.rst:899
msgid ""
"Return the default \"home\", that is, the value set by "
":c:member:`PyConfig.home`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""

#: ../../c-api/init.rst:909
msgid ""
"Get :c:member:`PyConfig.home` or :envvar:`PYTHONHOME` environment variable "
"instead."
msgstr ""

#: ../../c-api/init.rst:917
msgid "Thread State and the Global Interpreter Lock"
msgstr "Стан потоку та глобальне блокування інтерпретатора"

#: ../../c-api/init.rst:924
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Інтерпретатор Python не є повністю потокобезпечним. Щоб підтримувати "
"багатопотокові програми Python, існує глобальне блокування, яке називається "
":term:`global interpreter lock` або :term:`GIL`, яке має утримуватися "
"поточним потоком, перш ніж він зможе безпечно отримати доступ до об’єктів "
"Python. Без блокування навіть найпростіші операції можуть спричинити "
"проблеми в багатопотоковій програмі: наприклад, коли два потоки одночасно "
"збільшують кількість посилань на один і той же об’єкт, кількість посилань "
"може збільшитися лише один раз, а не двічі."

#: ../../c-api/init.rst:934
msgid ""
"Therefore, the rule exists that only the thread that has acquired the "
":term:`GIL` may operate on Python objects or call Python/C API functions. In"
" order to emulate concurrency of execution, the interpreter regularly tries "
"to switch threads (see :func:`sys.setswitchinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""
"Тому існує правило, згідно з яким лише потік, який отримав :term:`GIL`, може"
" працювати з об’єктами Python або викликати функції API Python/C. Щоб "
"імітувати паралельне виконання, інтерпретатор регулярно намагається "
"перемикати потоки (див. :func:`sys.setswitchinterval`). Блокування також "
"знімається навколо можливого блокування операцій введення-виведення, таких "
"як читання або запис файлу, щоб тим часом могли працювати інші потоки "
"Python."

#: ../../c-api/init.rst:944
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`.  There's also one "
"global variable pointing to the current :c:type:`PyThreadState`: it can be "
"retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"Інтерпретатор Python зберігає певну облікову інформацію про потоки в "
"структурі даних під назвою :c:type:`PyThreadState`. Існує також одна "
"глобальна змінна, яка вказує на поточний :c:type:`PyThreadState`: її можна "
"отримати за допомогою :c:func:`PyThreadState_Get`."

#: ../../c-api/init.rst:950
msgid "Releasing the GIL from extension code"
msgstr "Реліз GIL від коду розширення"

#: ../../c-api/init.rst:952
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr ""
"Більшість кодів розширення, які маніпулюють :term:`GIL`, мають таку просту "
"структуру:"

#: ../../c-api/init.rst:955
msgid ""
"Save the thread state in a local variable.\n"
"Release the global interpreter lock.\n"
"... Do some blocking I/O operation ...\n"
"Reacquire the global interpreter lock.\n"
"Restore the thread state from the local variable."
msgstr ""

#: ../../c-api/init.rst:961
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"Це настільки поширене явище, що для його спрощення існує пара макросів:"

#: ../../c-api/init.rst:963
msgid ""
"Py_BEGIN_ALLOW_THREADS\n"
"... Do some blocking I/O operation ...\n"
"Py_END_ALLOW_THREADS"
msgstr ""

#: ../../c-api/init.rst:971
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a"
" hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the"
" block."
msgstr ""
"Макрос :c:macro:`Py_BEGIN_ALLOW_THREADS` відкриває новий блок і оголошує "
"приховану локальну змінну; макрос :c:macro:`Py_END_ALLOW_THREADS` закриває "
"блок."

#: ../../c-api/init.rst:975
msgid "The block above expands to the following code::"
msgstr "Блок вище розширюється до наступного коду::"

#: ../../c-api/init.rst:977
msgid ""
"PyThreadState *_save;\n"
"\n"
"_save = PyEval_SaveThread();\n"
"... Do some blocking I/O operation ...\n"
"PyEval_RestoreThread(_save);"
msgstr ""

#: ../../c-api/init.rst:987
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"Ось як ці функції працюють: глобальне блокування інтерпретатора "
"використовується для захисту вказівника на поточний стан потоку. При знятті "
"блокування та збереженні стану потоку вказівник поточного стану потоку "
"повинен бути отриманий до зняття блокування (оскільки інший потік може "
"негайно отримати блокування та зберегти свій власний стан потоку в "
"глобальній змінній). І навпаки, під час отримання блокування та відновлення "
"стану потоку, блокування має бути отримано перед збереженням покажчика стану"
" потоку."

#: ../../c-api/init.rst:996
msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""
"Виклик системних функцій вводу-виводу є найпоширенішим варіантом "
"використання для випуску GIL, але він також може бути корисним перед "
"викликом тривалих обчислень, яким не потрібен доступ до об’єктів Python, "
"таких як стиснення або криптографічні функції, що працюють над буферами "
"пам’яті. Наприклад, стандартні модулі :mod:`zlib` і :mod:`hashlib` "
"звільняють GIL під час стиснення або хешування даних."

#: ../../c-api/init.rst:1007
msgid "Non-Python created threads"
msgstr "Потоки, створені не на Python"

#: ../../c-api/init.rst:1009
msgid ""
"When threads are created using the dedicated Python APIs (such as the "
":mod:`threading` module), a thread state is automatically associated to them"
" and the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""
"Коли потоки створюються за допомогою спеціальних API Python (таких як модуль"
" :mod:`threading`), стан потоку автоматично пов’язується з ними, і код, "
"показаний вище, є правильним. Однак, коли потоки створюються з C (наприклад,"
" сторонньою бібліотекою з власним керуванням потоками), вони не містять GIL,"
" а також для них не існує структури стану потоку."

#: ../../c-api/init.rst:1016
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you"
" are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""
"Якщо вам потрібно викликати код Python із цих потоків (часто це буде "
"частиною API зворотного виклику, наданого вищезгаданою сторонньою "
"бібліотекою), ви повинні спочатку зареєструвати ці потоки в інтерпретаторі, "
"створивши структуру даних стану потоку, а потім отримати GIL і, нарешті, "
"збереження покажчика стану потоку, перш ніж ви зможете почати "
"використовувати API Python/C. Коли ви закінчите, ви повинні скинути "
"вказівник стану потоку, звільнити GIL і, нарешті, звільнити структуру даних "
"стану потоку."

#: ../../c-api/init.rst:1024
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
"Функції :c:func:`PyGILState_Ensure` і :c:func:`PyGILState_Release` виконують"
" усе вищезазначене автоматично. Типова ідіома виклику Python із потоку C:"

#: ../../c-api/init.rst:1028
msgid ""
"PyGILState_STATE gstate;\n"
"gstate = PyGILState_Ensure();\n"
"\n"
"/* Perform Python actions here. */\n"
"result = CallSomeFunction();\n"
"/* evaluate result or handle exception */\n"
"\n"
"/* Release the thread. No Python API allowed beyond this point. */\n"
"PyGILState_Release(gstate);"
msgstr ""

#: ../../c-api/init.rst:1038
msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters (using "
":c:func:`Py_NewInterpreter`), but mixing multiple interpreters and the "
"``PyGILState_*`` API is unsupported."
msgstr ""

#: ../../c-api/init.rst:1048
msgid "Cautions about fork()"
msgstr "Застереження щодо fork()"

#: ../../c-api/init.rst:1050
msgid ""
"Another important thing to note about threads is their behaviour in the face"
" of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist.  This has a "
"concrete impact both on how locks must be handled and on all stored state in"
" CPython's runtime."
msgstr ""
"Ще одна важлива річ, на яку слід звернути увагу щодо потоків, це їхня "
"поведінка перед викликом C :c:func:`fork`. У більшості систем із "
":c:func:`fork` після розгалуження процесу існуватиме лише потік, який видав "
"розгалуження. Це має конкретний вплив як на те, як потрібно обробляти "
"блокування, так і на весь збережений стан у середовищі виконання CPython."

#: ../../c-api/init.rst:1056
msgid ""
"The fact that only the \"current\" thread remains means any locks held by "
"other threads will never be released. Python solves this for :func:`os.fork`"
" by acquiring the locks it uses internally before the fork, and releasing "
"them afterwards. In addition, it resets any :ref:`lock-objects` in the "
"child. When extending or embedding Python, there is no way to inform Python "
"of additional (non-Python) locks that need to be acquired before or reset "
"after a fork. OS facilities such as :c:func:`!pthread_atfork` would need to "
"be used to accomplish the same thing. Additionally, when extending or "
"embedding Python, calling :c:func:`fork` directly rather than through "
":func:`os.fork` (and returning to or calling into Python) may result in a "
"deadlock by one of Python's internal locks being held by a thread that is "
"defunct after the fork. :c:func:`PyOS_AfterFork_Child` tries to reset the "
"necessary locks, but is not always able to."
msgstr ""

#: ../../c-api/init.rst:1071
msgid ""
"The fact that all other threads go away also means that CPython's runtime "
"state there must be cleaned up properly, which :func:`os.fork` does.  This "
"means finalizing all other :c:type:`PyThreadState` objects belonging to the "
"current interpreter and all other :c:type:`PyInterpreterState` objects.  Due"
" to this and the special nature of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`, :c:func:`fork` should only be called in that "
"interpreter's \"main\" thread, where the CPython global runtime was "
"originally initialized. The only exception is if :c:func:`exec` will be "
"called immediately after."
msgstr ""
"Той факт, що всі інші потоки зникають, також означає, що стан виконання "
"CPython там має бути належним чином очищено, що й робить :func:`os.fork`. Це"
" означає завершення всіх інших об’єктів :c:type:`PyThreadState`, що належать"
" поточному інтерпретатору, і всіх інших об’єктів "
":c:type:`PyInterpreterState`. Через це та особливу природу :ref:`\"main\" "
"інтерпретатора <sub-interpreter-support>`, :c:func:`fork` слід викликати "
"лише в тому \"main\" потоці цього інтерпретатора, де початково "
"ініціалізовано глобальне середовище виконання CPython. Єдиним винятком є те,"
" що :c:func:`exec` буде викликано одразу після."

#: ../../c-api/init.rst:1084
msgid "High-level API"
msgstr "API високого рівня"

#: ../../c-api/init.rst:1086
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""
"Це типи та функції, які найчастіше використовуються під час написання коду "
"розширення C або під час вбудовування інтерпретатора Python:"

#: ../../c-api/init.rst:1091
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"Ця структура даних представляє стан, спільний для кількох взаємодіючих "
"потоків. Потоки, що належать одному інтерпретатору, спільно використовують "
"адміністрування модуля та кілька інших внутрішніх елементів. У цій структурі"
" немає громадських учасників."

#: ../../c-api/init.rst:1096
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"Потоки, що належать різним інтерпретаторам, спочатку нічого спільного не "
"мають, окрім стану процесу, наприклад доступної пам’яті, відкритих файлових "
"дескрипторів тощо. Глобальне блокування інтерпретатора також "
"використовується для всіх потоків, незалежно від того, до якого "
"інтерпретатора вони належать."

#: ../../c-api/init.rst:1104
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is:"
msgstr ""

#: ../../c-api/init.rst:1109
msgid "This thread's interpreter state."
msgstr ""

#: ../../c-api/init.rst:1120
msgid "Deprecated function which does nothing."
msgstr "Застаріла функція, яка нічого не робить."

#: ../../c-api/init.rst:1122
msgid ""
"In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr ""
"У Python 3.6 і старіших версіях ця функція створювала GIL, якщо його не "
"існувало."

#: ../../c-api/init.rst:1124
msgid "The function now does nothing."
msgstr "Тепер функція нічого не робить."

#: ../../c-api/init.rst:1127
msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't have "
"to call it yourself anymore."
msgstr ""
"Ця функція тепер викликається :c:func:`Py_Initialize()`, тому вам більше не "
"потрібно викликати її самостійно."

#: ../../c-api/init.rst:1131
msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr "Цю функцію більше не можна викликати до :c:func:`Py_Initialize()`."

#: ../../c-api/init.rst:1141
msgid ""
"Release the global interpreter lock (if it has been created) and reset the "
"thread state to ``NULL``, returning the previous thread state (which is not "
"``NULL``).  If the lock has been created, the current thread must have "
"acquired it."
msgstr ""
"Звільніть глобальне блокування інтерпретатора (якщо його було створено) і "
"скиньте стан потоку до ``NULL``, повертаючи попередній стан потоку (який не "
"є ``NULL``). Якщо блокування було створено, поточний потік повинен отримати "
"його."

#: ../../c-api/init.rst:1149
msgid ""
"Acquire the global interpreter lock (if it has been created) and set the "
"thread state to *tstate*, which must not be ``NULL``.  If the lock has been "
"created, the current thread must not have acquired it, otherwise deadlock "
"ensues."
msgstr ""
"Отримайте глобальне блокування інтерпретатора (якщо його було створено) і "
"встановіть стан потоку на *tstate*, який не має бути ``NULL``. Якщо "
"блокування було створено, поточний потік не повинен отримати його, інакше "
"виникає взаємоблокування."

#: ../../c-api/init.rst:1155 ../../c-api/init.rst:1214
#: ../../c-api/init.rst:1499
msgid ""
"Calling this function from a thread when the runtime is finalizing will "
"terminate the thread, even if the thread was not created by Python. You can "
"use :c:func:`Py_IsFinalizing` or :func:`sys.is_finalizing` to check if the "
"interpreter is in process of being finalized before calling this function to"
" avoid unwanted termination."
msgstr ""

#: ../../c-api/init.rst:1163
msgid ""
"Return the current thread state.  The global interpreter lock must be held. "
"When the current thread state is ``NULL``, this issues a fatal error (so "
"that the caller needn't check for ``NULL``)."
msgstr ""
"Повертає поточний стан потоку. Необхідно утримувати глобальне блокування "
"інтерпретатора. Коли поточний стан потоку ``NULL``, це викликає фатальну "
"помилку (тому абоненту не потрібно перевіряти ``NULL``)."

#: ../../c-api/init.rst:1167
msgid "See also :c:func:`PyThreadState_GetUnchecked`."
msgstr ""

#: ../../c-api/init.rst:1172
msgid ""
"Similar to :c:func:`PyThreadState_Get`, but don't kill the process with a "
"fatal error if it is NULL. The caller is responsible to check if the result "
"is NULL."
msgstr ""

#: ../../c-api/init.rst:1176
msgid ""
"In Python 3.5 to 3.12, the function was private and known as "
"``_PyThreadState_UncheckedGet()``."
msgstr ""

#: ../../c-api/init.rst:1183
msgid ""
"Swap the current thread state with the thread state given by the argument "
"*tstate*, which may be ``NULL``.  The global interpreter lock must be held "
"and is not released."
msgstr ""
"Замінити поточний стан потоку на стан потоку, заданий аргументом *tstate*, "
"який може бути ``NULL``. Глобальне блокування інтерпретатора має бути "
"утримано та не звільнене."

#: ../../c-api/init.rst:1188
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""
"Наступні функції використовують локальне сховище потоків і несумісні з "
"підінтерпретаторами:"

#: ../../c-api/init.rst:1193
msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the global interpreter lock. This may "
"be called as many times as desired by a thread as long as each call is "
"matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` and "
":c:func:`PyGILState_Release` calls as long as the thread state is restored "
"to its previous state before the Release().  For example, normal usage of "
"the :c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` "
"macros is acceptable."
msgstr ""
"Переконайтеся, що поточний потік готовий викликати API Python C незалежно "
"від поточного стану Python або глобального блокування інтерпретатора. Це "
"може бути викликано скільки завгодно разів потоком, якщо кожен виклик "
"відповідає виклику :c:func:`PyGILState_Release`. Загалом, між викликами "
":c:func:`PyGILState_Ensure` і :c:func:`PyGILState_Release` можна "
"використовувати інші пов’язані з потоками API, якщо стан потоку відновлено "
"до попереднього стану до Release(). Наприклад, нормальне використання "
"макросів :c:macro:`Py_BEGIN_ALLOW_THREADS` і :c:macro:`Py_END_ALLOW_THREADS`"
" є прийнятним."

#: ../../c-api/init.rst:1203
msgid ""
"The return value is an opaque \"handle\" to the thread state when "
":c:func:`PyGILState_Ensure` was called, and must be passed to "
":c:func:`PyGILState_Release` to ensure Python is left in the same state. "
"Even though recursive calls are allowed, these handles *cannot* be shared - "
"each unique call to :c:func:`PyGILState_Ensure` must save the handle for its"
" call to :c:func:`PyGILState_Release`."
msgstr ""
"Значення, що повертається, є непрозорим \"дескриптором\" стану потоку під "
"час виклику :c:func:`PyGILState_Ensure`, і його потрібно передати в "
":c:func:`PyGILState_Release`, щоб Python залишався в тому самому стані. "
"Незважаючи на те, що рекурсивні виклики дозволені, ці дескриптори *не можна*"
" спільно використовувати — кожен унікальний виклик "
":c:func:`PyGILState_Ensure` повинен зберігати дескриптор для свого виклику "
":c:func:`PyGILState_Release`."

#: ../../c-api/init.rst:1210
msgid ""
"When the function returns, the current thread will hold the GIL and be able "
"to call arbitrary Python code.  Failure is a fatal error."
msgstr ""
"Коли функція повертається, поточний потік зберігатиме GIL і зможе викликати "
"довільний код Python. Невдача є фатальною помилкою."

#: ../../c-api/init.rst:1222
msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the corresponding "
":c:func:`PyGILState_Ensure` call (but generally this state will be unknown "
"to the caller, hence the use of the GILState API)."
msgstr ""
"Вивільніть будь-які раніше отримані ресурси. Після цього виклику стан Python"
" буде таким же, як і до відповідного виклику :c:func:`PyGILState_Ensure` "
"(але зазвичай цей стан буде невідомий абоненту, тому використовується "
"GILState API)."

#: ../../c-api/init.rst:1227
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to "
":c:func:`PyGILState_Release` on the same thread."
msgstr ""
"Кожен виклик :c:func:`PyGILState_Ensure` має відповідати виклику "
":c:func:`PyGILState_Release` у тому самому потоці."

#: ../../c-api/init.rst:1233
msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main thread"
" always has such a thread-state, even if no auto-thread-state call has been "
"made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""
"Отримати поточний стан потоку для цього потоку. Може повертати ``NULL``, "
"якщо API GILState не використовувався в поточному потоці. Зверніть увагу, що"
" основний потік завжди має такий стан потоку, навіть якщо в основному потоці"
" не було зроблено виклик автоматичного стану потоку. Це в основному "
"допоміжна/діагностична функція."

#: ../../c-api/init.rst:1241
msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` otherwise. "
"This function can be called from any thread at any time. Only if it has had "
"its Python thread state initialized and currently is holding the GIL will it"
" return ``1``. This is mainly a helper/diagnostic function.  It can be "
"useful for example in callback contexts or memory allocation functions when "
"knowing that the GIL is locked can allow the caller to perform sensitive "
"actions or otherwise behave differently."
msgstr ""
"Повертає ``1``, якщо поточний потік містить GIL, і ``0`` інакше. Цю функцію "
"можна викликати з будь-якого потоку в будь-який час. Лише якщо він "
"ініціалізував стан потоку Python і зараз утримує GIL, він поверне ``1``. Це "
"в основному допоміжна/діагностична функція. Це може бути корисно, наприклад,"
" у контекстах зворотного виклику або функціях виділення пам’яті, коли знання"
" про те, що GIL заблоковано, може дозволити абоненту виконувати "
"конфіденційні дії або іншим чином поводитися по-іншому."

#: ../../c-api/init.rst:1253
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"Наступні макроси зазвичай використовуються без крапки з комою в кінці; "
"подивіться, наприклад, використання в вихідному дистрибутиві Python."

#: ../../c-api/init.rst:1259
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Note that it contains an opening brace; it must be "
"matched with a following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above "
"for further discussion of this macro."
msgstr ""
"Цей макрос розширюється до ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Зауважте, що він містить відкриваючу дужку; він "
"повинен відповідати наступному макросу :c:macro:`Py_END_ALLOW_THREADS`. "
"Дивіться вище для подальшого обговорення цього макросу."

#: ../../c-api/init.rst:1267
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier "
":c:macro:`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion "
"of this macro."
msgstr ""
"Цей макрос розширюється до ``PyEval_RestoreThread(_save); }``. Зверніть "
"увагу, що він містить закриваючу дужку; він повинен відповідати попередньому"
" макросу :c:macro:`Py_BEGIN_ALLOW_THREADS`. Дивіться вище для подальшого "
"обговорення цього макросу."

#: ../../c-api/init.rst:1275
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to "
":c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"Цей макрос розширюється до ``PyEval_RestoreThread(_save);``: він "
"еквівалентний :c:macro:`Py_END_ALLOW_THREADS` без закриваючої дужки."

#: ../../c-api/init.rst:1281
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to "
":c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration."
msgstr ""
"Цей макрос розширюється до ``_save = PyEval_SaveThread();``: він "
"еквівалентний :c:macro:`Py_BEGIN_ALLOW_THREADS` без відкриваючої дужки та "
"оголошення змінної."

#: ../../c-api/init.rst:1287
msgid "Low-level API"
msgstr "API низького рівня"

#: ../../c-api/init.rst:1289
msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr ""
"Усі наведені нижче функції мають викликатися після :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:1291
msgid ":c:func:`Py_Initialize()` now initializes the :term:`GIL`."
msgstr ":c:func:`Py_Initialize()` тепер ініціалізує :term:`GIL`."

#: ../../c-api/init.rst:1297
msgid ""
"Create a new interpreter state object.  The global interpreter lock need not"
" be held, but may be held if it is necessary to serialize calls to this "
"function."
msgstr ""
"Створіть новий об’єкт стану інтерпретатора. Глобальне блокування "
"інтерпретатора не потрібно утримувати, але можна утримувати, якщо необхідно "
"серіалізувати виклики цієї функції."

#: ../../c-api/init.rst:1301
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.PyInterpreterState_New`` with no arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``cpython.PyInterpreterState_New`` "
"без аргументів."

#: ../../c-api/init.rst:1306
msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr ""
"Скинути всю інформацію в об’єкті стану інтерпретатора. Необхідно утримувати "
"глобальне блокування інтерпретатора."

#: ../../c-api/init.rst:1309
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.PyInterpreterState_Clear`` with no arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``cpython.PyInterpreterState_Clear``"
" без аргументів."

#: ../../c-api/init.rst:1314
msgid ""
"Destroy an interpreter state object.  The global interpreter lock need not "
"be held.  The interpreter state must have been reset with a previous call to"
" :c:func:`PyInterpreterState_Clear`."
msgstr ""
"Знищити об’єкт стану інтерпретатора. Глобальне блокування інтерпретатора не "
"потрібно утримувати. Стан інтерпретатора має бути скинуто за допомогою "
"попереднього виклику :c:func:`PyInterpreterState_Clear`."

#: ../../c-api/init.rst:1321
msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"The global interpreter lock need not be held, but may be held if it is "
"necessary to serialize calls to this function."
msgstr ""
"Створіть новий об’єкт стану потоку, що належить даному об’єкту "
"інтерпретатора. Глобальне блокування інтерпретатора не потрібно утримувати, "
"але можна утримувати, якщо необхідно серіалізувати виклики цієї функції."

#: ../../c-api/init.rst:1328
msgid ""
"Reset all information in a thread state object.  The global interpreter lock"
" must be held."
msgstr ""
"Скинути всю інформацію в об’єкті стану потоку. Необхідно утримувати "
"глобальне блокування інтерпретатора."

#: ../../c-api/init.rst:1331
msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback. "
"Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""
"Ця функція тепер викликає зворотний виклик "
":c:member:`PyThreadState.on_delete`. Раніше це траплялося в "
":c:func:`PyThreadState_Delete`."

#: ../../c-api/init.rst:1335
msgid "The :c:member:`PyThreadState.on_delete` callback was removed."
msgstr ""

#: ../../c-api/init.rst:1341
msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to "
":c:func:`PyThreadState_Clear`."
msgstr ""
"Знищити об’єкт стану потоку. Глобальне блокування інтерпретатора не потрібно"
" утримувати. Стан потоку має бути скинуто попереднім викликом "
":c:func:`PyThreadState_Clear`."

#: ../../c-api/init.rst:1348
msgid ""
"Destroy the current thread state and release the global interpreter lock. "
"Like :c:func:`PyThreadState_Delete`, the global interpreter lock must be "
"held. The thread state must have been reset with a previous call to "
":c:func:`PyThreadState_Clear`."
msgstr ""

#: ../../c-api/init.rst:1356
msgid "Get the current frame of the Python thread state *tstate*."
msgstr "Отримати поточний кадр стану потоку Python *tstate*."

#: ../../c-api/init.rst:1358
msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is currently "
"executing."
msgstr ""
"Повертає :term:`strong reference`. Повертає ``NULL``, якщо наразі не "
"виконується жоден кадр."

#: ../../c-api/init.rst:1361
msgid "See also :c:func:`PyEval_GetFrame`."
msgstr "Дивіться також :c:func:`PyEval_GetFrame`."

#: ../../c-api/init.rst:1363 ../../c-api/init.rst:1372
#: ../../c-api/init.rst:1381
msgid "*tstate* must not be ``NULL``."
msgstr "*tstate* не має бути ``NULL``."

#: ../../c-api/init.rst:1370
msgid ""
"Get the unique thread state identifier of the Python thread state *tstate*."
msgstr "Отримайте унікальний ідентифікатор стану потоку Python *tstate*."

#: ../../c-api/init.rst:1379
msgid "Get the interpreter of the Python thread state *tstate*."
msgstr "Отримайте інтерпретатор стану потоку Python *tstate*."

#: ../../c-api/init.rst:1388
msgid "Suspend tracing and profiling in the Python thread state *tstate*."
msgstr ""

#: ../../c-api/init.rst:1390
msgid "Resume them using the :c:func:`PyThreadState_LeaveTracing` function."
msgstr ""

#: ../../c-api/init.rst:1397
msgid ""
"Resume tracing and profiling in the Python thread state *tstate* suspended "
"by the :c:func:`PyThreadState_EnterTracing` function."
msgstr ""

#: ../../c-api/init.rst:1400
msgid ""
"See also :c:func:`PyEval_SetTrace` and :c:func:`PyEval_SetProfile` "
"functions."
msgstr ""

#: ../../c-api/init.rst:1408
msgid "Get the current interpreter."
msgstr "Отримати поточний перекладач."

#: ../../c-api/init.rst:1410
msgid ""
"Issue a fatal error if there no current Python thread state or no current "
"interpreter. It cannot return NULL."
msgstr ""
"Видає фатальну помилку, якщо немає поточного стану потоку Python або "
"поточного інтерпретатора. Він не може повертати NULL."

#: ../../c-api/init.rst:1413 ../../c-api/init.rst:1423
msgid "The caller must hold the GIL."
msgstr "Абонент повинен тримати GIL."

#: ../../c-api/init.rst:1420
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then"
" ``-1`` is returned and an error is set."
msgstr ""
"Повернути унікальний ідентифікатор перекладача. Якщо під час цього сталася "
"якась помилка, повертається ``-1`` і встановлюється помилка."

#: ../../c-api/init.rst:1430
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"Повертає словник, у якому можуть зберігатися дані інтерпретатора. Якщо ця "
"функція повертає ``NULL``, це означає, що жодного винятку не було викликано,"
" і абонент повинен припустити, що недоступний dict інтерпретатора."

#: ../../c-api/init.rst:1434
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"Це не заміна :c:func:`PyModule_GetState()`, який розширення мають "
"використовувати для зберігання інформації про стан інтерпретатора."

#: ../../c-api/init.rst:1441
msgid "Type of a frame evaluation function."
msgstr "Тип функції оцінки фрейму."

#: ../../c-api/init.rst:1443
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""
"Параметр *throwflag* використовується методом ``throw()`` генераторів: якщо "
"він відмінний від нуля, обробити поточний виняток."

#: ../../c-api/init.rst:1446
msgid "The function now takes a *tstate* parameter."
msgstr "Тепер функція приймає параметр *tstate*."

#: ../../c-api/init.rst:1449
msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr ""

#: ../../c-api/init.rst:1454
msgid "Get the frame evaluation function."
msgstr "Отримати функцію оцінки фрейму."

#: ../../c-api/init.rst:1456 ../../c-api/init.rst:1464
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr "Перегляньте :pep:`523` \"Додавання API оцінки фрейму до CPython\"."

#: ../../c-api/init.rst:1462
msgid "Set the frame evaluation function."
msgstr "Встановіть функцію оцінки кадру."

#: ../../c-api/init.rst:1471
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no current thread "
"state is available. If this function returns ``NULL``, no exception has been"
" raised and the caller should assume no current thread state is available."
msgstr ""
"Повертає словник, у якому розширення можуть зберігати інформацію про стан "
"потоку. Кожне розширення має використовувати унікальний ключ для збереження "
"стану в словнику. Цю функцію можна викликати, якщо поточний стан потоку "
"недоступний. Якщо ця функція повертає ``NULL``, це означає, що жодного "
"винятку не було викликано, і абонент повинен вважати, що поточний стан "
"потоку недоступний."

#: ../../c-api/init.rst:1480
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with the GIL held. Returns the number of thread states modified; this is "
"normally one, but will be zero if the thread id isn't found.  If *exc* is "
"``NULL``, the pending exception (if any) for the thread is cleared. This "
"raises no exceptions."
msgstr ""

#: ../../c-api/init.rst:1488
msgid ""
"The type of the *id* parameter changed from :c:expr:`long` to "
":c:expr:`unsigned long`."
msgstr ""

#: ../../c-api/init.rst:1494
msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which must not be ``NULL``.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"Отримайте глобальне блокування інтерпретатора та встановіть поточний стан "
"потоку на *tstate*, який не має бути ``NULL``. Замок повинен бути створений "
"раніше. Якщо цей потік уже має блокування, виникає взаємоблокування."

#: ../../c-api/init.rst:1505
msgid ""
"Updated to be consistent with :c:func:`PyEval_RestoreThread`, "
":c:func:`Py_END_ALLOW_THREADS`, and :c:func:`PyGILState_Ensure`, and "
"terminate the current thread if called while the interpreter is finalizing."
msgstr ""
"Оновлено для узгодження з :c:func:`PyEval_RestoreThread`, "
":c:func:`Py_END_ALLOW_THREADS` і :c:func:`PyGILState_Ensure`, а також "
"завершує поточний потік, якщо він викликається, поки інтерпретатор завершує "
"роботу."

#: ../../c-api/init.rst:1510
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` — це функція вищого рівня, яка завжди "
"доступна (навіть якщо потоки не ініціалізовано)."

#: ../../c-api/init.rst:1516
msgid ""
"Reset the current thread state to ``NULL`` and release the global "
"interpreter lock.  The lock must have been created earlier and must be held "
"by the current thread.  The *tstate* argument, which must not be ``NULL``, "
"is only used to check that it represents the current thread state --- if it "
"isn't, a fatal error is reported."
msgstr ""
"Скиньте поточний стан потоку на ``NULL`` і звільніть глобальне блокування "
"інтерпретатора. Блокування має бути створено раніше та утримуватися поточним"
" потоком. Аргумент *tstate*, який не має бути ``NULL``, використовується "
"лише для перевірки того, що він представляє поточний стан потоку --- якщо це"
" не так, повідомляється про фатальну помилку."

#: ../../c-api/init.rst:1522
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` — це функція вищого рівня, яка завжди доступна "
"(навіть якщо потоки не ініціалізовано)."

#: ../../c-api/init.rst:1529
msgid "Sub-interpreter support"
msgstr "Підтримка субінтерпретатора"

#: ../../c-api/init.rst:1531
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you"
" to do that."
msgstr ""
"Хоча в більшості випадків ви вбудовуєте лише один інтерпретатор Python, є "
"випадки, коли вам потрібно створити кілька незалежних інтерпретаторів в "
"одному процесі і, можливо, навіть в одному потоці. Суб-інтерпретатори "
"дозволяють це зробити."

#: ../../c-api/init.rst:1536
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike"
" sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution"
" during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""
"\"Головний\" інтерпретатор є першим, який створюється під час ініціалізації "
"середовища виконання. Зазвичай це єдиний інтерпретатор Python у процесі. На "
"відміну від субінтерпретаторів, головний інтерпретатор має унікальні "
"глобальні обов’язки процесу, такі як обробка сигналів. Він також відповідає "
"за виконання під час ініціалізації середовища виконання та зазвичай є "
"активним інтерпретатором під час завершення виконання. Функція "
":c:func:`PyInterpreterState_Main` повертає вказівник на його стан."

#: ../../c-api/init.rst:1543
msgid ""
"You can switch between sub-interpreters using the "
":c:func:`PyThreadState_Swap` function. You can create and destroy them using"
" the following functions:"
msgstr ""
"Ви можете перемикатися між підінтерпретаторами за допомогою функції "
":c:func:`PyThreadState_Swap`. Ви можете створювати та знищувати їх за "
"допомогою таких функцій:"

#: ../../c-api/init.rst:1549
msgid ""
"Structure containing most parameters to configure a sub-interpreter. Its "
"values are used only in :c:func:`Py_NewInterpreterFromConfig` and never "
"modified by the runtime."
msgstr ""

#: ../../c-api/init.rst:1555
msgid "Structure fields:"
msgstr "Поля структури:"

#: ../../c-api/init.rst:1559
msgid ""
"If this is ``0`` then the sub-interpreter will use its own \"object\" "
"allocator state. Otherwise it will use (share) the main interpreter's."
msgstr ""

#: ../../c-api/init.rst:1563
msgid ""
"If this is ``0`` then "
":c:member:`~PyInterpreterConfig.check_multi_interp_extensions` must be ``1``"
" (non-zero). If this is ``1`` then :c:member:`~PyInterpreterConfig.gil` must"
" not be :c:macro:`PyInterpreterConfig_OWN_GIL`."
msgstr ""

#: ../../c-api/init.rst:1571
msgid ""
"If this is ``0`` then the runtime will not support forking the process in "
"any thread where the sub-interpreter is currently active. Otherwise fork is "
"unrestricted."
msgstr ""

#: ../../c-api/init.rst:1575
msgid ""
"Note that the :mod:`subprocess` module still works when fork is disallowed."
msgstr ""

#: ../../c-api/init.rst:1580
msgid ""
"If this is ``0`` then the runtime will not support replacing the current "
"process via exec (e.g. :func:`os.execv`) in any thread where the sub-"
"interpreter is currently active. Otherwise exec is unrestricted."
msgstr ""

#: ../../c-api/init.rst:1585
msgid ""
"Note that the :mod:`subprocess` module still works when exec is disallowed."
msgstr ""

#: ../../c-api/init.rst:1590
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create threads. Otherwise threads are allowed."
msgstr ""

#: ../../c-api/init.rst:1596
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create daemon threads. Otherwise daemon threads are allowed (as long as "
":c:member:`~PyInterpreterConfig.allow_threads` is non-zero)."
msgstr ""

#: ../../c-api/init.rst:1603
msgid ""
"If this is ``0`` then all extension modules may be imported, including "
"legacy (single-phase init) modules, in any thread where the sub-interpreter "
"is currently active. Otherwise only multi-phase init extension modules (see "
":pep:`489`) may be imported. (Also see "
":c:macro:`Py_mod_multiple_interpreters`.)"
msgstr ""

#: ../../c-api/init.rst:1610
msgid ""
"This must be ``1`` (non-zero) if "
":c:member:`~PyInterpreterConfig.use_main_obmalloc` is ``0``."
msgstr ""

#: ../../c-api/init.rst:1615
msgid ""
"This determines the operation of the GIL for the sub-interpreter. It may be "
"one of the following:"
msgstr ""

#: ../../c-api/init.rst:1622
msgid "Use the default selection (:c:macro:`PyInterpreterConfig_SHARED_GIL`)."
msgstr ""

#: ../../c-api/init.rst:1626
msgid "Use (share) the main interpreter's GIL."
msgstr ""

#: ../../c-api/init.rst:1630
msgid "Use the sub-interpreter's own GIL."
msgstr ""

#: ../../c-api/init.rst:1632
msgid ""
"If this is :c:macro:`PyInterpreterConfig_OWN_GIL` then "
":c:member:`PyInterpreterConfig.use_main_obmalloc` must be ``0``."
msgstr ""

#: ../../c-api/init.rst:1646
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and "
":mod:`sys`.  The table of loaded modules (``sys.modules``) and the module "
"search path (``sys.path``) are also separate.  The new environment has no "
"``sys.argv`` variable.  It has new standard I/O stream file objects "
"``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` (however these refer to the"
" same underlying file descriptors)."
msgstr ""
"Створіть новий підінтерпретатор. Це (майже) повністю окреме середовище для "
"виконання коду Python. Зокрема, новий інтерпретатор має окремі незалежні "
"версії всіх імпортованих модулів, включаючи фундаментальні модулі "
":mod:`builtins`, :mod:`__main__` і :mod:`sys`. Таблиця завантажених модулів "
"(``sys.modules``) і шлях пошуку модуля (``sys.path``) також окремі. Нове "
"середовище не має змінної ``sys.argv``. Він має нові стандартні файлові "
"об’єкти потоку вводу/виводу ``sys.stdin``, ``sys.stdout`` і ``sys.stderr`` "
"(однак вони посилаються на ті самі основні дескриптори файлів)."

#: ../../c-api/init.rst:1656
msgid ""
"The given *config* controls the options with which the interpreter is "
"initialized."
msgstr ""

#: ../../c-api/init.rst:1659
msgid ""
"Upon success, *tstate_p* will be set to the first thread state created in "
"the new sub-interpreter.  This thread state is made in the current thread "
"state. Note that no actual thread is created; see the discussion of thread "
"states below.  If creation of the new interpreter is unsuccessful, "
"*tstate_p* is set to ``NULL``; no exception is set since the exception state"
" is stored in the current thread state and there may not be a current thread"
" state."
msgstr ""

#: ../../c-api/init.rst:1668
msgid ""
"Like all other Python/C API functions, the global interpreter lock must be "
"held before calling this function and is still held when it returns.  "
"Likewise a current thread state must be set on entry.  On success, the "
"returned thread state will be set as current.  If the sub-interpreter is "
"created with its own GIL then the GIL of the calling interpreter will be "
"released.  When the function returns, the new interpreter's GIL will be held"
" by the current thread and the previously interpreter's GIL will remain "
"released here."
msgstr ""

#: ../../c-api/init.rst:1679
msgid ""
"Sub-interpreters are most effective when isolated from each other, with "
"certain functionality restricted::"
msgstr ""

#: ../../c-api/init.rst:1682
msgid ""
"PyInterpreterConfig config = {\n"
"    .use_main_obmalloc = 0,\n"
"    .allow_fork = 0,\n"
"    .allow_exec = 0,\n"
"    .allow_threads = 1,\n"
"    .allow_daemon_threads = 0,\n"
"    .check_multi_interp_extensions = 1,\n"
"    .gil = PyInterpreterConfig_OWN_GIL,\n"
"};\n"
"PyThreadState *tstate = Py_NewInterpreterFromConfig(&config);"
msgstr ""

#: ../../c-api/init.rst:1693
msgid ""
"Note that the config is used only briefly and does not get modified. During "
"initialization the config's values are converted into various "
":c:type:`PyInterpreterState` values.  A read-only copy of the config may be "
"stored internally on the :c:type:`PyInterpreterState`."
msgstr ""

#: ../../c-api/init.rst:1702
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr ""
"Модулі розширення розподіляються між (під)інтерпретаторами наступним чином:"

#: ../../c-api/init.rst:1704
msgid ""
"For modules using multi-phase initialization, e.g. "
":c:func:`PyModule_FromDefAndSpec`, a separate module object is created and "
"initialized for each interpreter. Only C-level static and global variables "
"are shared between these module objects."
msgstr ""
"Для модулів, які використовують багатофазову ініціалізацію, напр. "
":c:func:`PyModule_FromDefAndSpec`, окремий об’єкт модуля створюється та "
"ініціалізується для кожного інтерпретатора. Лише статичні та глобальні "
"змінні рівня C використовуються між цими об’єктами модуля."

#: ../../c-api/init.rst:1710
msgid ""
"For modules using single-phase initialization, e.g. "
":c:func:`PyModule_Create`, the first time a particular extension is "
"imported, it is initialized normally, and a (shallow) copy of its module's "
"dictionary is squirreled away. When the same extension is imported by "
"another (sub-)interpreter, a new module is initialized and filled with the "
"contents of this copy; the extension's ``init`` function is not called. "
"Objects in the module's dictionary thus end up shared across "
"(sub-)interpreters, which might cause unwanted behavior (see `Bugs and "
"caveats`_ below)."
msgstr ""
"Для модулів, які використовують однофазну ініціалізацію, напр. "
":c:func:`PyModule_Create`, коли конкретне розширення імпортується вперше, "
"воно ініціалізується звичайним чином, а (неглибока) копія словника його "
"модуля видаляється. Коли те саме розширення імпортується іншим "
"(під)інтерпретатором, новий модуль ініціалізується та заповнюється вмістом "
"цієї копії; функція ``init`` розширення не викликається. Таким чином, "
"об’єкти в словнику модуля розподіляються між (суб-)інтерпретаторами, що може"
" спричинити небажану поведінку (див. `Bugs and caveats`_  нижче)."

#: ../../c-api/init.rst:1721
msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by calling "
":c:func:`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, the "
"extension's ``initmodule`` function *is* called again. As with multi-phase "
"initialization, this means that only C-level static and global variables are"
" shared between these modules."
msgstr ""
"Зауважте, що це відрізняється від того, що відбувається, коли розширення "
"імпортується після повної повторної ініціалізації інтерпретатора викликом "
":c:func:`Py_FinalizeEx` і :c:func:`Py_Initialize`; у цьому випадку функція "
"``initmodule`` розширення *викликається* знову. Як і у випадку з "
"багатофазною ініціалізацією, це означає, що ці модулі спільно використовують"
" лише статичні та глобальні змінні рівня C."

#: ../../c-api/init.rst:1741
msgid ""
"Create a new sub-interpreter.  This is essentially just a wrapper around "
":c:func:`Py_NewInterpreterFromConfig` with a config that preserves the "
"existing behavior.  The result is an unisolated sub-interpreter that shares "
"the main interpreter's GIL, allows fork/exec, allows daemon threads, and "
"allows single-phase init modules."
msgstr ""

#: ../../c-api/init.rst:1753
msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion of "
"thread states below.  When the call returns, the current thread state is "
"``NULL``.  All thread states associated with this interpreter are destroyed."
"  The global interpreter lock used by the target interpreter must be held "
"before calling this function.  No GIL is held when it returns."
msgstr ""

#: ../../c-api/init.rst:1761
msgid ""
":c:func:`Py_FinalizeEx` will destroy all sub-interpreters that haven't been "
"explicitly destroyed at that point."
msgstr ""

#: ../../c-api/init.rst:1766
msgid "A Per-Interpreter GIL"
msgstr ""

#: ../../c-api/init.rst:1768
msgid ""
"Using :c:func:`Py_NewInterpreterFromConfig` you can create a sub-interpreter"
" that is completely isolated from other interpreters, including having its "
"own GIL.  The most important benefit of this isolation is that such an "
"interpreter can execute Python code without being blocked by other "
"interpreters or blocking any others.  Thus a single Python process can truly"
" take advantage of multiple CPU cores when running Python code.  The "
"isolation also encourages a different approach to concurrency than that of "
"just using threads. (See :pep:`554`.)"
msgstr ""

#: ../../c-api/init.rst:1778
msgid ""
"Using an isolated interpreter requires vigilance in preserving that "
"isolation.  That especially means not sharing any objects or mutable state "
"without guarantees about thread-safety.  Even objects that are otherwise "
"immutable (e.g. ``None``, ``(1, 5)``) can't normally be shared because of "
"the refcount.  One simple but less-efficient approach around this is to use "
"a global lock around all use of some state (or object). Alternately, "
"effectively immutable objects (like integers or strings) can be made safe in"
" spite of their refcounts by making them :term:`immortal`. In fact, this has"
" been done for the builtin singletons, small integers, and a number of other"
" builtin objects."
msgstr ""

#: ../../c-api/init.rst:1789
msgid ""
"If you preserve isolation then you will have access to proper multi-core "
"computing without the complications that come with free-threading. Failure "
"to preserve isolation will expose you to the full consequences of free-"
"threading, including races and hard-to-debug crashes."
msgstr ""

#: ../../c-api/init.rst:1794
msgid ""
"Aside from that, one of the main challenges of using multiple isolated "
"interpreters is how to communicate between them safely (not break isolation)"
" and efficiently.  The runtime and stdlib do not provide any standard "
"approach to this yet.  A future stdlib module would help mitigate the effort"
" of preserving isolation and expose effective tools for communicating (and "
"sharing) data between interpreters."
msgstr ""

#: ../../c-api/init.rst:1805
msgid "Bugs and caveats"
msgstr "Помилки та застереження"

#: ../../c-api/init.rst:1807
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""
"Оскільки субінтерпретатори (і головний інтерпретатор) є частиною одного "
"процесу, ізоляція між ними не є ідеальною --- наприклад, використовуючи "
"низькорівневі файлові операції, такі як :func:`os.close`, вони можуть "
"(випадково або зловмисно) впливають на відкриті файли один одного. Через те,"
" як розширення розподіляються між (під)інтерпретаторами, деякі розширення "
"можуть не працювати належним чином; це особливо ймовірно при використанні "
"однофазної ініціалізації або (статичних) глобальних змінних. Можна вставляти"
" об’єкти, створені в одному суб-інтерпретаторі, у простір імен іншого "
"(суб-)інтерпретатора; цього слід уникати, якщо це можливо."

#: ../../c-api/init.rst:1817
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's"
" dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""
"Слід приділяти особливу увагу уникненню спільного використання визначених "
"користувачем функцій, методів, екземплярів або класів між "
"підінтерпретаторами, оскільки операції імпорту, які виконуються такими "
"об’єктами, можуть вплинути на неправильний (під)інтерпретатор словник "
"завантажених модулів. Не менш важливо уникати спільного використання "
"об’єктів, з яких доступні вищевказані."

#: ../../c-api/init.rst:1823
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states"
" and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and "
":c:func:`PyGILState_Release` calls. Furthermore, extensions (such as "
":mod:`ctypes`) using these APIs to allow calling of Python code from non-"
"Python created threads will probably be broken when using sub-interpreters."
msgstr ""

#: ../../c-api/init.rst:1834
msgid "Asynchronous Notifications"
msgstr "Асинхронні сповіщення"

#: ../../c-api/init.rst:1836
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer"
" and a void pointer argument."
msgstr ""
"Надається механізм для створення асинхронних сповіщень головному потоку "
"інтерпретатора. Ці сповіщення приймають форму вказівника функції та "
"аргументу вказівника void."

#: ../../c-api/init.rst:1843
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main"
" thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"Заплануйте виклик функції з основного потоку інтерпретатора. У разі успіху "
"повертається ``0`` і *func* ставиться в чергу для виклику в основному "
"потоці. У разі помилки повертається ``-1`` без встановлення винятків."

#: ../../c-api/init.rst:1847
msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"Після успішного розміщення в черзі *func* буде *зрештою* викликано з "
"основного потоку інтерпретатора з аргументом *arg*. Його буде викликано "
"асинхронно щодо нормально запущеного коду Python, але з дотриманням обох цих"
" умов:"

#: ../../c-api/init.rst:1852
msgid "on a :term:`bytecode` boundary;"
msgstr "на межі :term:`bytecode`;"

#: ../../c-api/init.rst:1853
msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* can"
" therefore use the full C API)."
msgstr ""
"з головним потоком, який утримує :term:`global interpreter lock` (*func* "
"може використовувати повний C API)."

#: ../../c-api/init.rst:1856
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the global interpreter lock is released."
msgstr ""
"*func* має повернути ``0`` у разі успіху або ``-1`` у разі помилки з набором"
" винятків. *func* не буде перервано для рекурсивного виконання іншого "
"асинхронного сповіщення, але його все одно можна перервати для перемикання "
"потоків, якщо глобальне блокування інтерпретатора звільнено."

#: ../../c-api/init.rst:1861
msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr ""
"Цій функції не потрібен поточний стан потоку для запуску, і їй не потрібне "
"блокування глобального інтерпретатора."

#: ../../c-api/init.rst:1864
msgid ""
"To call this function in a subinterpreter, the caller must hold the GIL. "
"Otherwise, the function *func* can be scheduled to be called from the wrong "
"interpreter."
msgstr ""
"Щоб викликати цю функцію в підінтерпретаторі, абонент, що викликає, повинен "
"мати GIL. В іншому випадку функція *func* може бути запланована для виклику "
"з неправильного інтерпретатора."

#: ../../c-api/init.rst:1869
msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use the "
":ref:`PyGILState API<gilstate>`."
msgstr ""
"Це функція низького рівня, корисна лише в дуже особливих випадках. Немає "
"гарантії, що *func* буде викликано якомога швидше. Якщо основний потік "
"зайнятий виконанням системного виклику, *func* не буде викликано до "
"повернення системного виклику. Ця функція зазвичай **не** підходить для "
"виклику коду Python із довільних потоків C. Замість цього використовуйте "
":ref:`PyGILState API <gilstate>`."

#: ../../c-api/init.rst:1878
msgid ""
"If this function is called in a subinterpreter, the function *func* is now "
"scheduled to be called from the subinterpreter, rather than being called "
"from the main interpreter. Each subinterpreter now has its own list of "
"scheduled calls."
msgstr ""
"Якщо ця функція викликається у підінтерпретаторі, функція *func* тепер "
"запланована для виклику з підінтерпретатора, а не з основного "
"інтерпретатора. Кожен субінтерпретатор тепер має власний список запланованих"
" викликів."

#: ../../c-api/init.rst:1887
msgid "Profiling and Tracing"
msgstr "Профілювання та трасування"

#: ../../c-api/init.rst:1892
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Інтерпретатор Python надає деяку низькорівневу підтримку для підключення "
"засобів профілювання та трасування виконання. Вони використовуються для "
"інструментів профілювання, налагодження та аналізу покриття."

#: ../../c-api/init.rst:1896
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function"
" call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"Цей інтерфейс C дозволяє коду профілювання або трасування уникнути накладних"
" витрат на виклик через викликані об’єкти на рівні Python, замість цього "
"здійснюючи прямий виклик функції C. Основні атрибути закладу не змінилися; "
"інтерфейс дозволяє встановлювати функції трасування для кожного потоку, а "
"основні події, які повідомляються у функцію трасування, є такими самими, як "
"повідомлялося функціям трасування на рівні Python у попередніх версіях."

#: ../../c-api/init.rst:1906
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the"
" event pertains, *what* is one of the constants :c:data:`PyTrace_CALL`, "
":c:data:`PyTrace_EXCEPTION`, :c:data:`PyTrace_LINE`, "
":c:data:`PyTrace_RETURN`, :c:data:`PyTrace_C_CALL`, "
":c:data:`PyTrace_C_EXCEPTION`, :c:data:`PyTrace_C_RETURN`, or "
":c:data:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:"
msgstr ""

#: ../../c-api/init.rst:1915
msgid "Value of *what*"
msgstr "Значення *чого*"

#: ../../c-api/init.rst:1915
msgid "Meaning of *arg*"
msgstr "Значення *arg*"

#: ../../c-api/init.rst:1917
msgid ":c:data:`PyTrace_CALL`"
msgstr ""

#: ../../c-api/init.rst:1917 ../../c-api/init.rst:1922
#: ../../c-api/init.rst:1933
msgid "Always :c:data:`Py_None`."
msgstr "Завжди :c:data:`Py_None`."

#: ../../c-api/init.rst:1919
msgid ":c:data:`PyTrace_EXCEPTION`"
msgstr ""

#: ../../c-api/init.rst:1919
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr "Інформація про винятки, яку повертає :func:`sys.exc_info`."

#: ../../c-api/init.rst:1922
msgid ":c:data:`PyTrace_LINE`"
msgstr ""

#: ../../c-api/init.rst:1924
msgid ":c:data:`PyTrace_RETURN`"
msgstr ""

#: ../../c-api/init.rst:1924
msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr ""
"Значення, що повертається абоненту, або ``NULL``, якщо викликано винятком."

#: ../../c-api/init.rst:1927
msgid ":c:data:`PyTrace_C_CALL`"
msgstr ""

#: ../../c-api/init.rst:1927 ../../c-api/init.rst:1929
#: ../../c-api/init.rst:1931
msgid "Function object being called."
msgstr "Об’єкт функції, що викликається."

#: ../../c-api/init.rst:1929
msgid ":c:data:`PyTrace_C_EXCEPTION`"
msgstr ""

#: ../../c-api/init.rst:1931
msgid ":c:data:`PyTrace_C_RETURN`"
msgstr ""

#: ../../c-api/init.rst:1933
msgid ":c:data:`PyTrace_OPCODE`"
msgstr ""

#: ../../c-api/init.rst:1938
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"Значення параметра *what* для функції :c:type:`Py_tracefunc`, коли "
"повідомляється про новий виклик функції чи методу або новий запис у "
"генераторі. Зауважте, що створення ітератора для функції генератора не "
"повідомляється, оскільки немає передачі керування до байт-коду Python у "
"відповідному кадрі."

#: ../../c-api/init.rst:1947
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"Значення параметра *what* для функції :c:type:`Py_tracefunc`, коли виникає "
"виняткова ситуація. Функція зворотного виклику викликається з цим значенням "
"для *what*, коли після обробки будь-якого байт-коду, після чого виняток стає"
" встановленим у кадрі, що виконується. Наслідком цього є те, що коли "
"розповсюдження винятку спричиняє розгортання стека Python, зворотний виклик "
"викликається після повернення до кожного кадру під час поширення винятку. "
"Лише функції трасування отримують ці події; вони не потрібні профайлеру."

#: ../../c-api/init.rst:1958
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by setting "
":attr:`~frame.f_trace_lines` to *0* on that frame."
msgstr ""

#: ../../c-api/init.rst:1966
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""
"Значення для параметра *what* для :c:type:`Py_tracefunc` функціонує, коли "
"виклик збирається повернутися."

#: ../../c-api/init.rst:1972
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""
"Значення параметра *what* для функцій :c:type:`Py_tracefunc`, коли має бути "
"викликана функція C."

#: ../../c-api/init.rst:1978
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""
"Значення для параметра *what* для функцій :c:type:`Py_tracefunc`, коли "
"функція C викликала виняткову ситуацію."

#: ../../c-api/init.rst:1984
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""
"Значення для параметра *what* для функцій :c:type:`Py_tracefunc`, коли "
"функція C повертає."

#: ../../c-api/init.rst:1990
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by setting "
":attr:`~frame.f_trace_opcodes` to *1* on the frame."
msgstr ""

#: ../../c-api/init.rst:1998
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``."
"  If the profile function needs to maintain state, using a different value "
"for *obj* for each thread provides a convenient and thread-safe place to "
"store it.  The profile function is called for all monitored events except "
":c:data:`PyTrace_LINE` :c:data:`PyTrace_OPCODE` and "
":c:data:`PyTrace_EXCEPTION`."
msgstr ""

#: ../../c-api/init.rst:2005
msgid "See also the :func:`sys.setprofile` function."
msgstr ""

#: ../../c-api/init.rst:2007 ../../c-api/init.rst:2014
#: ../../c-api/init.rst:2033 ../../c-api/init.rst:2040
msgid "The caller must hold the :term:`GIL`."
msgstr "Абонент повинен утримувати :term:`GIL`."

#: ../../c-api/init.rst:2011
msgid ""
"Like :c:func:`PyEval_SetProfile` but sets the profile function in all "
"running threads belonging to the current interpreter instead of the setting "
"it only on the current thread."
msgstr ""

#: ../../c-api/init.rst:2016
msgid ""
"As :c:func:`PyEval_SetProfile`, this function ignores any exceptions raised "
"while setting the profile functions in all threads."
msgstr ""

#: ../../c-api/init.rst:2024
msgid ""
"Set the tracing function to *func*.  This is similar to "
":c:func:`PyEval_SetProfile`, except the tracing function does receive line-"
"number events and per-opcode events, but does not receive any event related "
"to C function objects being called.  Any trace function registered using "
":c:func:`PyEval_SetTrace` will not receive :c:data:`PyTrace_C_CALL`, "
":c:data:`PyTrace_C_EXCEPTION` or :c:data:`PyTrace_C_RETURN` as a value for "
"the *what* parameter."
msgstr ""

#: ../../c-api/init.rst:2031
msgid "See also the :func:`sys.settrace` function."
msgstr ""

#: ../../c-api/init.rst:2037
msgid ""
"Like :c:func:`PyEval_SetTrace` but sets the tracing function in all running "
"threads belonging to the current interpreter instead of the setting it only "
"on the current thread."
msgstr ""

#: ../../c-api/init.rst:2042
msgid ""
"As :c:func:`PyEval_SetTrace`, this function ignores any exceptions raised "
"while setting the trace functions in all threads."
msgstr ""

#: ../../c-api/init.rst:2048
msgid "Reference tracing"
msgstr ""

#: ../../c-api/init.rst:2054
msgid ""
"The type of the trace function registered using "
":c:func:`PyRefTracer_SetTracer`. The first parameter is a Python object that"
" has been just created (when **event** is set to "
":c:data:`PyRefTracer_CREATE`) or about to be destroyed (when **event** is "
"set to :c:data:`PyRefTracer_DESTROY`). The **data** argument is the opaque "
"pointer that was provided when :c:func:`PyRefTracer_SetTracer` was called."
msgstr ""

#: ../../c-api/init.rst:2064
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been created."
msgstr ""

#: ../../c-api/init.rst:2069
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been destroyed."
msgstr ""

#: ../../c-api/init.rst:2074
msgid ""
"Register a reference tracer function. The function will be called when a new"
" Python has been created or when an object is going to be destroyed. If "
"**data** is provided it must be an opaque pointer that will be provided when"
" the tracer function is called. Return ``0`` on success. Set an exception "
"and return ``-1`` on error."
msgstr ""

#: ../../c-api/init.rst:2080
msgid ""
"Not that tracer functions **must not** create Python objects inside or "
"otherwise the call will be re-entrant. The tracer also **must not** clear "
"any existing exception or set an exception.  The GIL will be held every time"
" the tracer function is called."
msgstr ""

#: ../../c-api/init.rst:2085 ../../c-api/init.rst:2096
msgid "The GIL must be held when calling this function."
msgstr ""

#: ../../c-api/init.rst:2091
msgid ""
"Get the registered reference tracer function and the value of the opaque "
"data pointer that was registered when :c:func:`PyRefTracer_SetTracer` was "
"called. If no tracer was registered this function will return NULL and will "
"set the **data** pointer to NULL."
msgstr ""

#: ../../c-api/init.rst:2103
msgid "Advanced Debugger Support"
msgstr "Розширена підтримка налагоджувача"

#: ../../c-api/init.rst:2108
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr ""
"Ці функції призначені лише для використання розширеними інструментами "
"налагодження."

#: ../../c-api/init.rst:2113
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""
"Повертає об’єкт стану інтерпретатора на початку списку всіх таких об’єктів."

#: ../../c-api/init.rst:2118
msgid "Return the main interpreter state object."
msgstr "Повертає основний об'єкт стану інтерпретатора."

#: ../../c-api/init.rst:2123
msgid ""
"Return the next interpreter state object after *interp* from the list of all"
" such objects."
msgstr ""
"Повертає наступний об’єкт стану інтерпретатора після *interp* зі списку всіх"
" таких об’єктів."

#: ../../c-api/init.rst:2129
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"Поверніть вказівник на перший об’єкт :c:type:`PyThreadState` у списку "
"потоків, пов’язаних з інтерпретатором *interp*."

#: ../../c-api/init.rst:2135
msgid ""
"Return the next thread state object after *tstate* from the list of all such"
" objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"Повертає наступний об’єкт стану потоку після *tstate* зі списку всіх таких "
"об’єктів, що належать до того самого об’єкта :c:type:`PyInterpreterState`."

#: ../../c-api/init.rst:2142
msgid "Thread Local Storage Support"
msgstr "Підтримка потокового локального сховища"

#: ../../c-api/init.rst:2146
msgid ""
"The Python interpreter provides low-level support for thread-local storage "
"(TLS) which wraps the underlying native TLS implementation to support the "
"Python-level thread local storage API (:class:`threading.local`).  The "
"CPython C level APIs are similar to those offered by pthreads and Windows: "
"use a thread key and functions to associate a :c:expr:`void*` value per "
"thread."
msgstr ""

#: ../../c-api/init.rst:2153
msgid ""
"The GIL does *not* need to be held when calling these functions; they supply"
" their own locking."
msgstr ""
"GIL *не* потрібно утримувати під час виклику цих функцій; вони забезпечують "
"власний замок."

#: ../../c-api/init.rst:2156
msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS APIs,"
" you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
"Зауважте, що :file:`Python.h` не містить оголошення TLS API, вам потрібно "
"включити :file:`pythread.h`, щоб використовувати локальне сховище потоків."

#: ../../c-api/init.rst:2160
msgid ""
"None of these API functions handle memory management on behalf of the "
":c:expr:`void*` values.  You need to allocate and deallocate them yourself. "
"If the :c:expr:`void*` values happen to be :c:expr:`PyObject*`, these "
"functions don't do refcount operations on them either."
msgstr ""

#: ../../c-api/init.rst:2168
msgid "Thread Specific Storage (TSS) API"
msgstr "API для спеціального зберігання потоків (TSS)."

#: ../../c-api/init.rst:2170
msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within "
"the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""

#: ../../c-api/init.rst:2176
msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr "\"Новий C-API для локального зберігання потоків у CPython\" (:pep:`539`)"

#: ../../c-api/init.rst:2181
msgid ""
"This data structure represents the state of a thread key, the definition of "
"which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no "
"public members in this structure."
msgstr ""
"Ця структура даних представляє стан ключа потоку, визначення якого може "
"залежати від базової реалізації TLS, і вона має внутрішнє поле, що "
"представляє стан ініціалізації ключа. У цій структурі немає громадських "
"учасників."

#: ../../c-api/init.rst:2186
msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
"Якщо :ref:`Py_LIMITED_API <stable>` не визначено, статичний розподіл цього "
"типу за допомогою :c:macro:`Py_tss_NEEDS_INIT` дозволений."

#: ../../c-api/init.rst:2192
msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. Note"
" that this macro won't be defined with :ref:`Py_LIMITED_API <stable>`."
msgstr ""
"Цей макрос розширюється до ініціалізатора для змінних :c:type:`Py_tss_t`. "
"Зауважте, що цей макрос не буде визначено за допомогою :ref:`Py_LIMITED_API "
"<stable>`."

#: ../../c-api/init.rst:2197
msgid "Dynamic Allocation"
msgstr "Динамічний розподіл"

#: ../../c-api/init.rst:2199
msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension modules "
"built with :ref:`Py_LIMITED_API <stable>`, where static allocation of this "
"type is not possible due to its implementation being opaque at build time."
msgstr ""
"Динамічне розміщення :c:type:`Py_tss_t`, необхідне в модулях розширення, "
"створених за допомогою :ref:`Py_LIMITED_API <stable>`, де статичне "
"розміщення цього типу неможливе через те, що його реалізація непрозора під "
"час створення."

#: ../../c-api/init.rst:2206
msgid ""
"Return a value which is the same state as a value initialized with "
":c:macro:`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic allocation "
"failure."
msgstr ""
"Повертає значення, яке є таким самим станом, як і значення, ініціалізоване "
"за допомогою :c:macro:`Py_tss_NEEDS_INIT` або ``NULL`` у разі помилки "
"динамічного розподілу."

#: ../../c-api/init.rst:2213
msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after first "
"calling :c:func:`PyThread_tss_delete` to ensure any associated thread locals"
" have been unassigned. This is a no-op if the *key* argument is ``NULL``."
msgstr ""

#: ../../c-api/init.rst:2219
msgid ""
"A freed key becomes a dangling pointer. You should reset the key to "
"``NULL``."
msgstr ""

#: ../../c-api/init.rst:2224
msgid "Methods"
msgstr "методи"

#: ../../c-api/init.rst:2226
msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, the "
"behaviors of :c:func:`PyThread_tss_set` and :c:func:`PyThread_tss_get` are "
"undefined if the given :c:type:`Py_tss_t` has not been initialized by "
":c:func:`PyThread_tss_create`."
msgstr ""
"Параметр *key* цих функцій не має бути ``NULL``. Крім того, поведінка "
":c:func:`PyThread_tss_set` і :c:func:`PyThread_tss_get` є невизначеною, якщо"
" даний :c:type:`Py_tss_t` не був ініціалізований "
":c:func:`PyThread_tss_create`."

#: ../../c-api/init.rst:2234
msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been initialized"
" by :c:func:`PyThread_tss_create`."
msgstr ""
"Повертає ненульове значення, якщо заданий :c:type:`Py_tss_t` ініціалізовано "
":c:func:`PyThread_tss_create`."

#: ../../c-api/init.rst:2240
msgid ""
"Return a zero value on successful initialization of a TSS key.  The behavior"
" is undefined if the value pointed to by the *key* argument is not "
"initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be called "
"repeatedly on the same key -- calling it on an already initialized key is a "
"no-op and immediately returns success."
msgstr ""
"Повертає нульове значення в разі успішної ініціалізації ключа TSS. Поведінка"
" не визначена, якщо значення, на яке вказує аргумент *key*, не "
"ініціалізовано :c:macro:`Py_tss_NEEDS_INIT`. Цю функцію можна викликати "
"неодноразово для одного і того ж ключа — виклик її для вже ініціалізованого "
"ключа є безопераційним і негайно повертає успіх."

#: ../../c-api/init.rst:2249
msgid ""
"Destroy a TSS key to forget the values associated with the key across all "
"threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again by "
":c:func:`PyThread_tss_create`. This function can be called repeatedly on the"
" same key -- calling it on an already destroyed key is a no-op."
msgstr ""
"Знищіть ключ TSS, щоб забути значення, пов’язані з ключем у всіх потоках, і "
"змініть стан ініціалізації ключа на неініціалізований. Знищений ключ можна "
"знову ініціалізувати за допомогою :c:func:`PyThread_tss_create`. Цю функцію "
"можна багаторазово викликати для одного і того ж ключа – виклик її для вже "
"знищеного ключа є безопераційним."

#: ../../c-api/init.rst:2258
msgid ""
"Return a zero value to indicate successfully associating a :c:expr:`void*` "
"value with a TSS key in the current thread.  Each thread has a distinct "
"mapping of the key to a :c:expr:`void*` value."
msgstr ""

#: ../../c-api/init.rst:2265
msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current "
"thread.  This returns ``NULL`` if no value is associated with the key in the"
" current thread."
msgstr ""

#: ../../c-api/init.rst:2273
msgid "Thread Local Storage (TLS) API"
msgstr "API локального зберігання потоків (TLS)."

#: ../../c-api/init.rst:2275
msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API <thread-"
"specific-storage-api>`."
msgstr ""
"Цей API замінено :ref:`API спеціального зберігання потоків (TSS) <thread-"
"specific-storage-api>`."

#: ../../c-api/init.rst:2280
msgid ""
"This version of the API does not support platforms where the native TLS key "
"is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""
"Ця версія API не підтримує платформи, де власний ключ TLS визначено таким "
"чином, що його неможливо безпечно перевести в ``int``. На таких платформах "
":c:func:`PyThread_create_key` негайно повернеться зі статусом помилки, а всі"
" інші функції TLS будуть безопераційними на таких платформах."

#: ../../c-api/init.rst:2285
msgid ""
"Due to the compatibility problem noted above, this version of the API should"
" not be used in new code."
msgstr ""
"Через проблему сумісності, зазначену вище, цю версію API не слід "
"використовувати в новому коді."

#: ../../c-api/init.rst:2296
msgid "Synchronization Primitives"
msgstr "Примітиви синхронізації"

#: ../../c-api/init.rst:2298
msgid "The C-API provides a basic mutual exclusion lock."
msgstr ""

#: ../../c-api/init.rst:2302
msgid ""
"A mutual exclusion lock.  The :c:type:`!PyMutex` should be initialized to "
"zero to represent the unlocked state.  For example::"
msgstr ""

#: ../../c-api/init.rst:2305
msgid "PyMutex mutex = {0};"
msgstr ""

#: ../../c-api/init.rst:2307
msgid ""
"Instances of :c:type:`!PyMutex` should not be copied or moved.  Both the "
"contents and address of a :c:type:`!PyMutex` are meaningful, and it must "
"remain at a fixed, writable location in memory."
msgstr ""

#: ../../c-api/init.rst:2313
msgid ""
"A :c:type:`!PyMutex` currently occupies one byte, but the size should be "
"considered unstable.  The size may change in future Python releases without "
"a deprecation period."
msgstr ""

#: ../../c-api/init.rst:2321
msgid ""
"Lock mutex *m*.  If another thread has already locked it, the calling thread"
" will block until the mutex is unlocked.  While blocked, the thread will "
"temporarily release the :term:`GIL` if it is held."
msgstr ""

#: ../../c-api/init.rst:2329
msgid ""
"Unlock mutex *m*. The mutex must be locked --- otherwise, the function will "
"issue a fatal error."
msgstr ""

#: ../../c-api/init.rst:2337
msgid "Python Critical Section API"
msgstr ""

#: ../../c-api/init.rst:2339
msgid ""
"The critical section API provides a deadlock avoidance layer on top of per-"
"object locks for :term:`free-threaded <free threading>` CPython.  They are "
"intended to replace reliance on the :term:`global interpreter lock`, and are"
" no-ops in versions of Python with the global interpreter lock."
msgstr ""

#: ../../c-api/init.rst:2344
msgid ""
"Critical sections avoid deadlocks by implicitly suspending active critical "
"sections and releasing the locks during calls to "
":c:func:`PyEval_SaveThread`. When :c:func:`PyEval_RestoreThread` is called, "
"the most recent critical section is resumed, and its locks reacquired.  This"
" means the critical section API provides weaker guarantees than traditional "
"locks -- they are useful because their behavior is similar to the "
":term:`GIL`."
msgstr ""

#: ../../c-api/init.rst:2351
msgid ""
"The functions and structs used by the macros are exposed for cases where C "
"macros are not available. They should only be used as in the given macro "
"expansions. Note that the sizes and contents of the structures may change in"
" future Python versions."
msgstr ""

#: ../../c-api/init.rst:2358
msgid ""
"Operations that need to lock two objects at once must use "
":c:macro:`Py_BEGIN_CRITICAL_SECTION2`.  You *cannot* use nested critical "
"sections to lock more than one object at once, because the inner critical "
"section may suspend the outer critical sections.  This API does not provide "
"a way to lock more than two objects at once."
msgstr ""

#: ../../c-api/init.rst:2364
msgid "Example usage::"
msgstr "Приклад використання::"

#: ../../c-api/init.rst:2366
msgid ""
"static PyObject *\n"
"set_field(MyObject *self, PyObject *value)\n"
"{\n"
"   Py_BEGIN_CRITICAL_SECTION(self);\n"
"   Py_SETREF(self->field, Py_XNewRef(value));\n"
"   Py_END_CRITICAL_SECTION();\n"
"   Py_RETURN_NONE;\n"
"}"
msgstr ""

#: ../../c-api/init.rst:2375
msgid ""
"In the above example, :c:macro:`Py_SETREF` calls :c:macro:`Py_DECREF`, which"
" can call arbitrary code through an object's deallocation function.  The "
"critical section API avoids potential deadlocks due to reentrancy and lock "
"ordering by allowing the runtime to temporarily suspend the critical section"
" if the code triggered by the finalizer blocks and calls "
":c:func:`PyEval_SaveThread`."
msgstr ""

#: ../../c-api/init.rst:2383
msgid ""
"Acquires the per-object lock for the object *op* and begins a critical "
"section."
msgstr ""

#: ../../c-api/init.rst:2386 ../../c-api/init.rst:2400
#: ../../c-api/init.rst:2415 ../../c-api/init.rst:2429
msgid "In the free-threaded build, this macro expands to::"
msgstr ""

#: ../../c-api/init.rst:2388
msgid ""
"{\n"
"    PyCriticalSection _py_cs;\n"
"    PyCriticalSection_Begin(&_py_cs, (PyObject*)(op))"
msgstr ""

#: ../../c-api/init.rst:2392 ../../c-api/init.rst:2421
msgid "In the default build, this macro expands to ``{``."
msgstr ""

#: ../../c-api/init.rst:2398
msgid "Ends the critical section and releases the per-object lock."
msgstr ""

#: ../../c-api/init.rst:2402
msgid ""
"    PyCriticalSection_End(&_py_cs);\n"
"}"
msgstr ""

#: ../../c-api/init.rst:2405 ../../c-api/init.rst:2434
msgid "In the default build, this macro expands to ``}``."
msgstr ""

#: ../../c-api/init.rst:2411
msgid ""
"Acquires the per-objects locks for the objects *a* and *b* and begins a "
"critical section.  The locks are acquired in a consistent order (lowest "
"address first) to avoid lock ordering deadlocks."
msgstr ""

#: ../../c-api/init.rst:2417
msgid ""
"{\n"
"    PyCriticalSection2 _py_cs2;\n"
"    PyCriticalSection_Begin2(&_py_cs2, (PyObject*)(a), (PyObject*)(b))"
msgstr ""

#: ../../c-api/init.rst:2427
msgid "Ends the critical section and releases the per-object locks."
msgstr ""

#: ../../c-api/init.rst:2431
msgid ""
"    PyCriticalSection_End2(&_py_cs2);\n"
"}"
msgstr ""

#: ../../c-api/init.rst:350
msgid "PyEval_InitThreads()"
msgstr ""

#: ../../c-api/init.rst:350
msgid "modules (in module sys)"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:701
msgid "path (in module sys)"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:701 ../../c-api/init.rst:1136
#: ../../c-api/init.rst:1638 ../../c-api/init.rst:1733
msgid "module"
msgstr "модуль"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1638
#: ../../c-api/init.rst:1733
msgid "builtins"
msgstr "вбудовані елементи"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1638
#: ../../c-api/init.rst:1733
msgid "__main__"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1638
#: ../../c-api/init.rst:1733
msgid "sys"
msgstr "система"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:701
msgid "search"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:701
msgid "path"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1698
#: ../../c-api/init.rst:1751
msgid "Py_FinalizeEx (C function)"
msgstr ""

#: ../../c-api/init.rst:567
msgid "Py_Initialize()"
msgstr ""

#: ../../c-api/init.rst:567 ../../c-api/init.rst:799
msgid "main()"
msgstr ""

#: ../../c-api/init.rst:567
msgid "Py_GetPath()"
msgstr ""

#: ../../c-api/init.rst:680
msgid "executable (in module sys)"
msgstr ""

#: ../../c-api/init.rst:734 ../../c-api/init.rst:776 ../../c-api/init.rst:790
msgid "version (in module sys)"
msgstr ""

#: ../../c-api/init.rst:746
msgid "platform (in module sys)"
msgstr ""

#: ../../c-api/init.rst:763
msgid "copyright (in module sys)"
msgstr ""

#: ../../c-api/init.rst:799
msgid "Py_FatalError()"
msgstr ""

#: ../../c-api/init.rst:799
msgid "argv (in module sys)"
msgstr ""

#: ../../c-api/init.rst:919
msgid "global interpreter lock"
msgstr "глобальне блокування інтерпретатора"

#: ../../c-api/init.rst:919
msgid "interpreter lock"
msgstr ""

#: ../../c-api/init.rst:919
msgid "lock, interpreter"
msgstr ""

#: ../../c-api/init.rst:932
msgid "setswitchinterval (in module sys)"
msgstr ""

#: ../../c-api/init.rst:941
msgid "PyThreadState (C type)"
msgstr ""

#: ../../c-api/init.rst:967
msgid "Py_BEGIN_ALLOW_THREADS (C macro)"
msgstr ""

#: ../../c-api/init.rst:967
msgid "Py_END_ALLOW_THREADS (C macro)"
msgstr ""

#: ../../c-api/init.rst:983
msgid "PyEval_RestoreThread (C function)"
msgstr ""

#: ../../c-api/init.rst:983
msgid "PyEval_SaveThread (C function)"
msgstr ""

#: ../../c-api/init.rst:1114
msgid "PyEval_AcquireThread()"
msgstr ""

#: ../../c-api/init.rst:1114
msgid "PyEval_ReleaseThread()"
msgstr ""

#: ../../c-api/init.rst:1114
msgid "PyEval_SaveThread()"
msgstr ""

#: ../../c-api/init.rst:1114
msgid "PyEval_RestoreThread()"
msgstr ""

#: ../../c-api/init.rst:1136
msgid "_thread"
msgstr "_thread"

#: ../../c-api/init.rst:1638 ../../c-api/init.rst:1733
msgid "stdout (in module sys)"
msgstr ""

#: ../../c-api/init.rst:1638 ../../c-api/init.rst:1733
msgid "stderr (in module sys)"
msgstr ""

#: ../../c-api/init.rst:1638 ../../c-api/init.rst:1733
msgid "stdin (in module sys)"
msgstr ""

#: ../../c-api/init.rst:1698
msgid "Py_Initialize (C function)"
msgstr ""

#: ../../c-api/init.rst:1728
msgid "close (in module os)"
msgstr ""
