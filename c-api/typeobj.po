# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Type Objects"
msgstr "Об'єкти типу"

msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the :c:func:"
"`PyObject_\\*` or :c:func:`PyType_\\*` functions, but do not offer much "
"that's interesting to most Python applications. These objects are "
"fundamental to how objects behave, so they are very important to the "
"interpreter itself and to any extension module that implements new types."
msgstr ""
"Можливо, одна з найважливіших структур об’єктної системи Python – це "
"структура, яка визначає новий тип: структура :c:type:`PyTypeObject`. Об’єкти "
"типу можна обробляти за допомогою будь-якої функції :c:func:`PyObject_\\*` "
"або :c:func:`PyType_\\*`, але вони не пропонують багато цікавого для "
"більшості програм Python. Ці об’єкти є фундаментальними для того, як об’єкти "
"поводяться, тому вони дуже важливі для самого інтерпретатора та будь-якого "
"модуля розширення, який реалізує нові типи."

msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Об’єкти типу досить великі порівняно з більшістю стандартних типів. Причина "
"такого розміру полягає в тому, що кожен об’єкт типу зберігає велику "
"кількість значень, переважно покажчиків на функції C, кожен з яких реалізує "
"невелику частину функціональності типу. У цьому розділі детально "
"розглядаються поля об’єкта типу. Поля будуть описані в тому порядку, в якому "
"вони розташовані в структурі."

msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"На додаток до наведеної нижче короткої довідки, розділ :ref:`typedef-"
"examples` надає швидке розуміння значення та використання :c:type:"
"`PyTypeObject`."

msgid "Quick Reference"
msgstr "Короткий довідник"

msgid "\"tp slots\""
msgstr "\"tp слоти\""

msgid "PyTypeObject Slot [#slots]_"
msgstr "Слот PyTypeObject [#slots]_"

msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Введіть <slot-typedefs-table>`"

msgid "special methods/attrs"
msgstr "спеціальні методи/атр"

msgid "Info [#cols]_"
msgstr "Інформація [#cols]_"

msgid "O"
msgstr "О"

msgid "T"
msgstr "T"

msgid "D"
msgstr "D"

msgid "I"
msgstr "I"

msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr " <R> :c:member:`~PyTypeObject.tp_name`"

msgid "const char *"
msgstr "const char *"

msgid "__name__"
msgstr "__name__"

msgid "X"
msgstr "X"

msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

msgid "G"
msgstr "Г"

msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

msgid "%"
msgstr "%"

msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

msgid "__repr__"
msgstr "__repr__"

msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

msgid "__hash__"
msgstr "__hash__"

msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

msgid "__call__"
msgstr "__call__"

msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

msgid "__str__"
msgstr "__str__"

msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

msgid "unsigned long"
msgstr "беззнаковий long"

msgid "?"
msgstr "?"

msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

msgid "__doc__"
msgstr "__doc__"

msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

msgid "__iter__"
msgstr "__iter__"

msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

msgid "__next__"
msgstr "__next__"

msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

msgid "__base__"
msgstr "__base__"

msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

msgid "__dict__"
msgstr "__dict__"

msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

msgid "__get__"
msgstr "__get__"

msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

msgid "__set__, __delete__"
msgstr "__set__, __delete__"

msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

msgid "__init__"
msgstr "__init__"

msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

msgid "__new__"
msgstr "__new__"

msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr " <:c:member:`~PyTypeObject.tp_bases`>"

msgid "__bases__"
msgstr "__bases__"

msgid "~"
msgstr "~"

msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr " <:c:member:`~PyTypeObject.tp_mro`>"

msgid "__mro__"
msgstr "__mro__"

msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

msgid "__subclasses__"
msgstr "__subclasses__"

msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

msgid "unsigned int"
msgstr "беззнаковий int"

msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

msgid "__del__"
msgstr "__del__"

msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

msgid ""
"A slot name in parentheses indicates it is (effectively) deprecated. Names "
"in angle brackets should be treated as read-only. Names in square brackets "
"are for internal use only. \"<R>\" (as a prefix) means the field is required "
"(must be non-``NULL``)."
msgstr ""
"Назва слота в дужках вказує на те, що він (фактично) застарілий. Імена в "
"кутових дужках мають розглядатися як доступні лише для читання. Імена в "
"квадратних дужках призначені лише для внутрішнього використання. \" <R> "
"\" (як префікс) означає, що поле є обов’язковим (має бути відмінним від "
"``NULL``)."

msgid "Columns:"
msgstr "Стовпці:"

msgid "**\"O\"**:  set on :c:type:`PyBaseObject_Type`"
msgstr "**\"O\"**: встановлено на :c:type:`PyBaseObject_Type`"

msgid "**\"T\"**:  set on :c:type:`PyType_Type`"
msgstr "**\"T\"**: встановлено на :c:type:`PyType_Type`"

msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr ""
"**\"D\"**: за умовчанням (якщо для слота встановлено значення ``NULL``)"

msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: наслідування"

msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Зверніть увагу, що деякі слоти фактично успадковуються через звичайний "
"ланцюжок пошуку атрибутів."

msgid "sub-slots"
msgstr "підслоти"

msgid "Slot"
msgstr "Слот"

msgid "special methods"
msgstr "спеціальні методи"

msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

msgid "__await__"
msgstr "__await__"

msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

msgid "__aiter__"
msgstr "__aiter__"

msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

msgid "__anext__"
msgstr "__anext__"

msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

msgid "__add__ __radd__"
msgstr "__add__ __radd__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

msgid "__iadd__"
msgstr "__iadd__"

msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

msgid "__isub__"
msgstr "__isub__"

msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

msgid "__imul__"
msgstr "__imul__"

msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

msgid "__imod__"
msgstr "__imod__"

msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

msgid "__ipow__"
msgstr "__ipow__"

msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

msgid "__neg__"
msgstr "__neg__"

msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

msgid "__pos__"
msgstr "__pos__"

msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

msgid "__abs__"
msgstr "__abs__"

msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

msgid "__bool__"
msgstr "__bool__"

msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

msgid "__invert__"
msgstr "__invert__"

msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

msgid "__ilshift__"
msgstr "__ilshift__"

msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

msgid "__irshift__"
msgstr "__irshift__"

msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

msgid "__and__ __rand__"
msgstr "__and__ __rand__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

msgid "__iand__"
msgstr "__iand__"

msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

msgid "__ixor__"
msgstr "__ixor__"

msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

msgid "__or__ __ror__"
msgstr "__or__ __ror__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

msgid "__ior__"
msgstr "__ior__"

msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

msgid "__int__"
msgstr "__int__"

msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

msgid "void *"
msgstr "порожній *"

msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

msgid "__float__"
msgstr "__float__"

msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

msgid "__floordiv__"
msgstr "__floordiv__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

msgid "__ifloordiv__"
msgstr "__ifloordiv__"

msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

msgid "__truediv__"
msgstr "__truediv__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

msgid "__itruediv__"
msgstr "__itruediv__"

msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

msgid "__index__"
msgstr "__index__"

msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

msgid "__imatmul__"
msgstr "__imatmul__"

msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

msgid "__len__"
msgstr "__len__"

msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

msgid "__getitem__"
msgstr "__getitem__"

msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

msgid "__add__"
msgstr "__add__"

msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

msgid "__mul__"
msgstr "__mul__"

msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

msgid "__contains__"
msgstr "__contains__"

msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

msgid "slot typedefs"
msgstr "типи слотів"

msgid "typedef"
msgstr "typedef"

msgid "Parameter Types"
msgstr "Типи параметрів"

msgid "Return Type"
msgstr "Тип повернення"

msgid "void"
msgstr "пустий"

msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

msgid "int"
msgstr "int"

msgid "Py_hash_t"
msgstr "Py_hash_t"

msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Дивіться :ref:`slot-typedefs` нижче, щоб дізнатися більше."

msgid "PyTypeObject Definition"
msgstr "Визначення PyTypeObject"

msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"Визначення структури для :c:type:`PyTypeObject` можна знайти в :file:"
"`Include/object.h`. Для зручності посилання повторює наведене там визначення:"

msgid "PyObject Slots"
msgstr "Слоти PyObject"

msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by :func:`type_new`, "
"usually called from a class statement). Note that :c:data:`PyType_Type` (the "
"metatype) initializes :c:member:`~PyTypeObject.tp_itemsize`, which means "
"that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""
"Структура об’єкта типу розширює структуру :c:type:`PyVarObject`. Поле :attr:"
"`ob_size` використовується для динамічних типів (створених :func:`type_new`, "
"які зазвичай викликаються з оператора класу). Зауважте, що :c:data:"
"`PyType_Type` (метатип) ініціалізує :c:member:`~PyTypeObject.tp_itemsize`, "
"що означає, що його екземпляри (тобто об’єкти типу) *мають* мати поле :attr:"
"`ob_size`."

msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :attr:`ob_type` "
"points back to the type) do *not* count as references.  But for :ref:"
"`dynamically allocated type objects <heap-types>`, the instances *do* count "
"as references."
msgstr ""
"Це кількість посилань об’єкта типу, ініціалізована макросом "
"``PyObject_HEAD_INIT`` значенням ``1``. Зауважте, що для :ref:`статично "
"виділених об’єктів типу <static-types>` екземпляри типу (об’єкти, чий :attr:"
"`ob_type` вказує на тип) *не* вважаються посиланнями. Але для :ref:"
"`динамічно виділених об’єктів типу <heap-types>` екземпляри *враховуються* "
"як посилання."

msgid "**Inheritance:**"
msgstr "**Наслідування:**"

msgid "This field is not inherited by subtypes."
msgstr "Це поле не успадковується підтипами."

msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Це тип типу, іншими словами його метатип. Він ініціалізується аргументом "
"макросу ``PyObject_HEAD_INIT``, і його значення зазвичай має бути "
"``&PyType_Type``. Однак для динамічно завантажуваних модулів розширення, які "
"повинні використовуватися в Windows (принаймні), компілятор скаржиться, що "
"це недійсний ініціалізатор. Таким чином, прийнято передавати ``NULL`` в "
"макрос ``PyObject_HEAD_INIT`` і ініціалізувати це поле явно на початку "
"функції ініціалізації модуля, перш ніж робити будь-що інше. Зазвичай це "
"робиться так:"

msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is ``NULL``, and if so, initializes "
"it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` "
"will not change this field if it is non-zero."
msgstr ""
"Це слід зробити до того, як будуть створені будь-які екземпляри типу. :c:"
"func:`PyType_Ready` перевіряє, чи :attr:`ob_type` має значення ``NULL``, і "
"якщо так, ініціалізує його полем :attr:`ob_type` базового класу. :c:func:"
"`PyType_Ready` не змінить це поле, якщо воно відмінне від нуля."

msgid "This field is inherited by subtypes."
msgstr "Це поле успадковується підтипами."

msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined "
"(see the :option:`configure --with-trace-refs option <--with-trace-refs>`)."
msgstr ""
"Ці поля присутні лише тоді, коли визначено макрос ``Py_TRACE_REFS`` (див. "
"параметр :option:`configure --with-trace-refs <--with-trace-refs>`)."

msgid ""
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For :ref:`statically allocated objects "
"<static-types>`, these fields always remain ``NULL``.  For :ref:`dynamically "
"allocated objects <heap-types>`, these two fields are used to link the "
"object into a doubly-linked list of *all* live objects on the heap."
msgstr ""
"Їх ініціалізація до ``NULL`` забезпечується макросом ``PyObject_HEAD_INIT``. "
"Для :ref:`статично виділених об’єктів <static-types>` ці поля завжди "
"залишаються ``NULL``. Для :ref:`динамічно виділених об’єктів <heap-types>` "
"ці два поля використовуються для зв’язування об’єкта в подвійний список "
"*усіх* живих об’єктів у купі."

msgid ""
"This could be used for various debugging purposes; currently the only uses "
"are the :func:`sys.getobjects` function and to print the objects that are "
"still alive at the end of a run when the environment variable :envvar:"
"`PYTHONDUMPREFS` is set."
msgstr ""
"Це можна використовувати для різних цілей налагодження; наразі єдиним "
"використанням є функція :func:`sys.getobjects` і друк об’єктів, які "
"залишаються живими наприкінці виконання, коли встановлено змінну середовища :"
"envvar:`PYTHONDUMPREFS`."

msgid "These fields are not inherited by subtypes."
msgstr "Ці поля не успадковуються підтипами."

msgid "PyVarObject Slots"
msgstr "Слоти PyVarObject"

msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"Для :ref:`статично виділених об’єктів типу <static-types>`, це має бути "
"ініціалізовано нулем. Для :ref:`динамічно виділених об’єктів типу <heap-"
"types>` це поле має особливе внутрішнє значення."

msgid "PyTypeObject Slots"
msgstr "Слоти PyTypeObject"

msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:type:"
"`PyBaseObject_Type` and :c:type:`PyType_Type` effectively act as defaults.)"
msgstr ""
"Кожен слот має розділ, що описує успадкування. Якщо :c:func:`PyType_Ready` "
"може встановити значення, коли для поля встановлено значення ``NULL``, тоді "
"також буде розділ \"За замовчуванням\". (Зверніть увагу, що багато полів, "
"установлених у :c:type:`PyBaseObject_Type` і :c:type:`PyType_Type`, фактично "
"діють як значення за замовчуванням.)"

msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Покажчик на рядок із закінченням NUL, що містить назву типу. Для типів, які "
"доступні як глобальні модулі, рядок має бути повним ім’ям модуля, за яким "
"слідує крапка та ім’я типу; для вбудованих типів це має бути лише назва "
"типу. Якщо модуль є підмодулем пакета, повна назва пакета є частиною повної "
"назви модуля. Наприклад, тип із назвою :class:`T`, визначений у модулі :mod:"
"`M` у вкладеному пакеті :mod:`Q` у пакеті :mod:`P`, повинен мати :c:member:"
"`~PyTypeObject.tp_name` ініціалізатор ``\"P.Q.M.T\"``."

msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"Для :ref:`динамічно виділених об’єктів типу <heap-types>`, це має бути лише "
"ім’я типу, а ім’я модуля явно зберігається в dict типу як значення для ключа "
"``'__module__'``."

msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`__module__` attribute, and everything after the "
"last dot is made accessible as the :attr:`~definition.__name__` attribute."
msgstr ""
"Для :ref:`статично виділених об’єктів типу <static-types>` поле *tp_name* "
"має містити крапку. Усе перед останньою крапкою стає доступним як атрибут :"
"attr:`__module__`, а все після останньої крапки стає доступним як атрибут :"
"attr:`~definition.__name__`."

msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Якщо крапка відсутня, усе поле :c:member:`~PyTypeObject.tp_name` стає "
"доступним як атрибут :attr:`~definition.__name__`, а атрибут :attr:"
"`__module__` не визначено (якщо це не зазначено явно). набір у словнику, як "
"пояснено вище). Це означає, що ваш тип буде неможливо замаринувати. Крім "
"того, він не буде вказаний у документації модуля, створеній за допомогою "
"pydoc."

msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Це поле не має бути ``NULL``. Це єдине обов’язкове поле в :c:func:"
"`PyTypeObject` (окрім потенційно :c:member:`~PyTypeObject.tp_itemsize`)."

msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr "Ці поля дозволяють обчислити розмір екземплярів типу в байтах."

msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Існує два види типів: типи з екземплярами фіксованої довжини мають нульове "
"поле :c:member:`~PyTypeObject.tp_itemsize`, типи з екземплярами змінної "
"довжини мають ненульове поле :c:member:`~PyTypeObject.tp_itemsize` поле. Для "
"типу з екземплярами фіксованої довжини всі екземпляри мають однаковий "
"розмір, указаний у :c:member:`~PyTypeObject.tp_basicsize`."

msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :c:member:`~PyTypeObject."
"tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is "
"the \"length\" of the object.  The value of N is typically stored in the "
"instance's :attr:`ob_size` field.  There are exceptions:  for example, ints "
"use a negative :attr:`ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in "
"the instance layout doesn't mean that the instance structure is variable-"
"length (for example, the structure for the list type has fixed-length "
"instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""
"Для типу з примірниками змінної довжини примірники повинні мати поле :attr:"
"`ob_size`, а розмір примірника становить :c:member:`~PyTypeObject."
"tp_basicsize` плюс N разів :c:member:`~PyTypeObject. tp_itemsize`, де N — "
"\"довжина\" об’єкта. Значення N зазвичай зберігається в полі екземпляра :"
"attr:`ob_size`. Бувають винятки: наприклад, int використовує від'ємний :attr:"
"`ob_size` для позначення від’ємного числа, а N є ``abs(ob_size)``. Крім "
"того, наявність поля :attr:`ob_size` у макеті екземпляра не означає, що "
"структура екземпляра має змінну довжину (наприклад, структура для типу "
"списку має екземпляри фіксованої довжини, але ці екземпляри мають значуще "
"поле :attr:`ob_size`)."

msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :c:member:`~PyTypeObject."
"tp_basicsize` is to use the ``sizeof`` operator on the struct used to "
"declare the instance layout. The basic size does not include the GC header "
"size."
msgstr ""
"Базовий розмір включає поля в екземплярі, оголошеному макросом :c:macro:"
"`PyObject_HEAD` або :c:macro:`PyObject_VAR_HEAD` (залежно від того, який "
"використовується для оголошення структури екземпляра), а це, у свою чергу, "
"включає :attr:`Поля _ob_prev` і :attr:`_ob_next`, якщо вони присутні. Це "
"означає, що єдиний правильний спосіб отримати ініціалізатор для :c:member:"
"`~PyTypeObject.tp_basicsize` — це використання оператора ``sizeof`` у "
"структурі, яка використовується для оголошення макета екземпляра. Базовий "
"розмір не включає розмір заголовка GC."

msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"Примітка щодо вирівнювання: якщо елементи змінної потребують особливого "
"вирівнювання, про це слід подбати за допомогою значення :c:member:"
"`~PyTypeObject.tp_basicsize`. Приклад: припустимо, що тип реалізує масив "
"``double``. :c:member:`~PyTypeObject.tp_itemsize` — це ``sizeof(double)``. "
"Програміст відповідає за те, щоб :c:member:`~PyTypeObject.tp_basicsize` був "
"кратним ``sizeof(double)`` (припускаючи, що це вимога вирівнювання для "
"``double``)."

msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr ""
"Для будь-якого типу з екземплярами змінної довжини це поле не має бути "
"``NULL``."

msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"Ці поля успадковуються окремо за підтипами. Якщо базовий тип має ненульовий :"
"c:member:`~PyTypeObject.tp_itemsize`, зазвичай небезпечно встановлювати :c:"
"member:`~PyTypeObject.tp_itemsize` інше ненульове значення в підтипі ( хоча "
"це залежить від реалізації базового типу)."

msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"Покажчик на функцію деструктора екземпляра. Ця функція має бути визначена, "
"якщо тип не гарантує, що її екземпляри ніколи не будуть звільнені (як у "
"випадку сінгтонів ``None`` і ``Ellipsis``). Сигнатура функції:"

msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), "
"it is permissible to call the object deallocator directly instead of via :c:"
"member:`~PyTypeObject.tp_free`.  The object deallocator should be the one "
"used to allocate the instance; this is normally :c:func:`PyObject_Del` if "
"the instance was allocated using :c:func:`PyObject_New` or :c:func:"
"`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""
"Функція деструктора викликається макросами :c:func:`Py_DECREF` і :c:func:"
"`Py_XDECREF`, коли кількість нових посилань дорівнює нулю. На даний момент "
"екземпляр все ще існує, але на нього немає посилань. Функція деструктора "
"повинна звільнити всі посилання, якими володіє екземпляр, звільнити всі "
"буфери пам’яті, якими володіє екземпляр (за допомогою функції звільнення, що "
"відповідає функції розподілу, що використовується для виділення буфера), і "
"викликати тип :c:member:`~PyTypeObject.tp_free`. Якщо тип не можна "
"підтипувати (не має встановленого біта прапора :const:"
"`Py_TPFLAGS_BASETYPE`), дозволено викликати засіб усунення об’єктів "
"безпосередньо, а не через :c:member:`~PyTypeObject.tp_free`. Розділювач "
"об’єктів має бути тим, який використовується для виділення примірника; "
"зазвичай це :c:func:`PyObject_Del`, якщо екземпляр було виділено за "
"допомогою :c:func:`PyObject_New` або :c:func:`PyObject_VarNew`, або :c:func:"
"`PyObject_GC_Del`, якщо екземпляр було виділено за допомогою :c:func:"
"`PyObject_GC_New` або :c:func:`PyObject_GC_NewVar`."

msgid ""
"If the type supports garbage collection (has the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"Якщо тип підтримує збирання сміття (має встановлений біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`), деструктор повинен викликати :c:func:"
"`PyObject_GC_UnTrack` перед очищенням будь-яких полів-членів."

msgid ""
"Finally, if the type is heap allocated (:const:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should decrement the reference count for its type object after "
"calling the type deallocator. In order to avoid dangling pointers, the "
"recommended way to achieve this is:"
msgstr ""
"Нарешті, якщо тип виділено купу (:const:`Py_TPFLAGS_HEAPTYPE`), засіб "
"розповсюдження має зменшити кількість посилань для свого об’єкта типу після "
"виклику засобу розповсюдження типу. Щоб уникнути звисаючих покажчиків, "
"рекомендований спосіб досягти цього:"

msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Необов’язкове зміщення функції для кожного екземпляра, яка реалізує виклик "
"об’єкта за допомогою :ref:`vectorcall протоколу <vectorcall>`, більш "
"ефективної альтернативи простішого :c:member:`~PyTypeObject.tp_call`."

msgid ""
"This field is only used if the flag :const:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Це поле використовується, лише якщо встановлено прапорець :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL`. Якщо так, це має бути додатне ціле число, що "
"містить зміщення в екземплярі покажчика :c:type:`vectorcallfunc`."

msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :const:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Покажчик *vectorcallfunc* може бути ``NULL``, у цьому випадку примірник "
"поводиться так, ніби :const:`Py_TPFLAGS_HAVE_VECTORCALL` не було "
"встановлено: виклик примірника повертається до :c:member:`~PyTypeObject."
"tp_call`."

msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Будь-який клас, який встановлює ``Py_TPFLAGS_HAVE_VECTORCALL``, також "
"повинен встановити :c:member:`~PyTypeObject.tp_call` і переконатися, що його "
"поведінка узгоджується з функцією *vectorcallfunc*. Це можна зробити, "
"встановивши *tp_call* на :c:func:`PyVectorcall_Call`."

msgid ""
"It is not recommended for :ref:`heap types <heap-types>` to implement the "
"vectorcall protocol. When a user sets :attr:`__call__` in Python code, only "
"*tp_call* is updated, likely making it inconsistent with the vectorcall "
"function."
msgstr ""

msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"До версії 3.8 цей слот мав назву ``tp_print``. У Python 2.x він "
"використовувався для друку у файл. У Python від 3.0 до 3.7 він не "
"використовувався."

msgid ""
"This field is always inherited. However, the :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not, then "
"the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:func:"
"`PyVectorcall_Call` is explicitly called. This is in particular the case "
"for :ref:`heap types <heap-types>` (including subclasses defined in Python)."
msgstr ""

msgid "An optional pointer to the get-attribute-string function."
msgstr "Додатковий покажчик на функцію get-attribute-string."

msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Це поле застаріло. Коли його визначено, він має вказувати на функцію, яка "
"діє так само, як функція :c:member:`~PyTypeObject.tp_getattro`, але "
"використовує рядок C замість рядкового об’єкта Python, щоб надати назву "
"атрибуту."

msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
msgstr "Група: :attr:`tp_getattr`, :attr:`tp_getattro`"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_getattro`: підтип успадковує і :c:member:`~PyTypeObject.tp_getattr`, і :c:"
"member:`~PyTypeObject.tp_getattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_getattr` і :c:member:`~PyTypeObject.tp_getattro` "
"мають значення ``NULL``."

msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr ""
"Додатковий вказівник на функцію для налаштування та видалення атрибутів."

msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Це поле застаріло. Коли його визначено, він має вказувати на функцію, яка "
"діє так само, як функція :c:member:`~PyTypeObject.tp_setattro`, але "
"використовує рядок C замість рядкового об’єкта Python, щоб надати назву "
"атрибуту."

msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
msgstr "Група: :attr:`tp_setattr`, :attr:`tp_setattro`"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_setattro`: підтип успадковує і :c:member:`~PyTypeObject.tp_setattr`, і :c:"
"member:`~PyTypeObject.tp_setattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_setattr` і :c:member:`~PyTypeObject.tp_setattro` "
"мають значення ``NULL``."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протоколи :term:`awaitable` і :term:`asynchronous "
"iterator` на рівні C. Дивіться :ref:`async-structs` для деталей."

msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Раніше відомий як ``tp_compare`` і ``tp_reserved``."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_async` не успадковується, але поля, що "
"містяться, успадковуються окремо."

msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"Додатковий покажчик на функцію, яка реалізує вбудовану функцію :func:`repr`."

msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_Repr`::"

msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"Функція має повертати рядок або об’єкт Unicode. В ідеалі ця функція має "
"повертати рядок, який, переданий до :func:`eval`, за відповідного середовища "
"повертає об’єкт із тим самим значенням. Якщо це неможливо, він повинен "
"повертати рядок, що починається з ``'<'`` та закінчується на ``'>'``, з "
"якого можна вивести як тип, так і значення об’єкта."

msgid "**Default:**"
msgstr "**За замовчуванням:**"

msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Якщо це поле не встановлено, повертається рядок у формі ``<%s object at "
"%p>``, де ``%s`` замінюється назвою типу, а ``%p`` адресою пам'яті об'єкта."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протокол номерів. Ці поля задокументовані в :ref:"
"`number-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_number` не успадковується, але поля, що "
"містяться, успадковуються окремо."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протокол послідовності. Ці поля задокументовані в :"
"ref:`sequence-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_sequence` не успадковується, але поля, "
"що містяться, успадковуються окремо."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протокол відображення. Ці поля задокументовані в :"
"ref:`mapping-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_mapping` не успадковується, але поля, що "
"містяться, успадковуються окремо."

msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"Додатковий покажчик на функцію, яка реалізує вбудовану функцію :func:`hash`."

msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_Hash`::"

msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"Значення ``-1`` не повинно повертатися як звичайне значення, що "
"повертається; якщо під час обчислення хеш-значення виникає помилка, функція "
"повинна встановити виняток і повернути ``-1``."

msgid ""
"When this field is not set (*and* :attr:`tp_richcompare` is not set), an "
"attempt to take the hash of the object raises :exc:`TypeError`. This is the "
"same as setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"Якщо це поле не встановлено (*і* :attr:`tp_richcompare` не встановлено), "
"спроба отримати хеш об’єкта викликає :exc:`TypeError`. Це те саме, що "
"встановити значення :c:func:`PyObject_HashNotImplemented`."

msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"У цьому полі можна явно встановити значення :c:func:"
"`PyObject_HashNotImplemented`, щоб заблокувати успадкування геш-методу від "
"батьківського типу. Це інтерпретується як еквівалент ``__hash__ = None`` на "
"рівні Python, змушуючи ``isinstance(o, collections.Hashable)`` правильно "
"повертати ``False``. Зауважте, що зворотне також вірно – встановлення "
"``__hash__ = None`` для класу на рівні Python призведе до того, що слот "
"``tp_hash`` буде встановлено на :c:func:`PyObject_HashNotImplemented`."

msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
msgstr "Група: :attr:`tp_hash`, :attr:`tp_richcompare`"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_richcompare`: підтип успадковує як :c:member:`~PyTypeObject."
"tp_richcompare`, так і :c:member:`~PyTypeObject.tp_hash`, коли підтипи :c:"
"member:`~PyTypeObject.tp_richcompare` і :c:member:`~PyTypeObject.tp_hash` "
"мають значення ``NULL``."

msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Додатковий покажчик на функцію, яка реалізує виклик об’єкта. Це має бути "
"``NULL``, якщо об’єкт не можна викликати. Підпис такий самий, як і для :c:"
"func:`PyObject_Call`::"

msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"Додатковий покажчик на функцію, яка реалізує вбудовану операцію :func:`str`. "
"(Зауважте, що :class:`str` тепер є типом, а :func:`str` викликає конструктор "
"для цього типу. Цей конструктор викликає :c:func:`PyObject_Str` для "
"виконання фактичної роботи, а :c:func:`PyObject_Str` викличе цей обробник.)"

msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_Str`::"

msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"Функція має повертати рядок або об’єкт Unicode. Це має бути \"дружнє\" "
"рядкове представлення об’єкта, оскільки це представлення буде "
"використовуватися, серед іншого, функцією :func:`print`."

msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Якщо це поле не встановлено, :c:func:`PyObject_Repr` викликається для "
"повернення рядкового представлення."

msgid "An optional pointer to the get-attribute function."
msgstr "Додатковий покажчик на функцію get-attribute."

msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_GetAttr`::"

msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Зазвичай зручно встановити для цього поля значення :c:func:"
"`PyObject_GenericGetAttr`, що реалізує звичайний спосіб пошуку атрибутів "
"об’єкта."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_getattr`: підтип успадковує і :c:member:`~PyTypeObject.tp_getattr`, і :c:"
"member:`~PyTypeObject.tp_getattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_getattr` і :c:member:`~PyTypeObject.tp_getattro` "
"мають значення ``NULL``."

msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""
":c:type:`PyBaseObject_Type` використовує :c:func:`PyObject_GenericGetAttr`."

msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_SetAttr`::"

msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Крім того, для видалення атрибута має підтримуватися встановлення *значення* "
"на ``NULL``. Зазвичай зручно встановити для цього поля значення :c:func:"
"`PyObject_GenericSetAttr`, що реалізує звичайний спосіб встановлення "
"атрибутів об’єкта."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_setattr`: підтип успадковує і :c:member:`~PyTypeObject.tp_setattr`, і :c:"
"member:`~PyTypeObject.tp_setattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_setattr` і :c:member:`~PyTypeObject.tp_setattro` "
"мають значення ``NULL``."

msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""
":c:type:`PyBaseObject_Type` використовує :c:func:`PyObject_GenericSetAttr`."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують інтерфейс буфера. Ці поля задокументовані в :ref:"
"`buffer-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_buffer` не успадковується, але поля, що "
"містяться, успадковуються окремо."

msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Це поле є бітовою маскою різних прапорів. Деякі прапорці вказують на "
"варіантну семантику для певних ситуацій; інші використовуються для вказівки, "
"що певні поля в об’єкті типу (або в структурах розширення, на які "
"посилаються через :c:member:`~PyTypeObject.tp_as_number`, :c:member:"
"`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping` і :c:"
"member:`~PyTypeObject.tp_as_buffer`), які історично не завжди були присутні, "
"є дійсними; якщо такий біт прапора очищений, до полів типу, які він "
"охороняє, не можна звертатися, і вони повинні вважатися такими, що мають "
"нульове або ``NULL`` значення."

msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"Успадкування цього поля складне. Більшість бітів прапора успадковуються "
"індивідуально, тобто якщо базовий тип має встановлений біт прапора, підтип "
"успадковує цей біт прапора. Біти прапорів, які відносяться до структур "
"розширення, суворо успадковуються, якщо успадковується структура розширення, "
"тобто значення біта прапора базового типу копіюється в підтип разом із "
"покажчиком на структуру розширення. Біт прапора :const:`Py_TPFLAGS_HAVE_GC` "
"успадковується разом із полями :c:member:`~PyTypeObject.tp_traverse` і :c:"
"member:`~PyTypeObject.tp_clear`, тобто якщо біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC` є чистим у підтипі, а поля :c:member:`~PyTypeObject."
"tp_traverse` і :c:member:`~PyTypeObject.tp_clear` у підтипі існують і мають "
"значення ``NULL``."

msgid ""
":c:type:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:type:`PyBaseObject_Type` використовує ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

msgid "**Bit Masks:**"
msgstr "**Бітові маски:**"

msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"Наразі визначено такі бітові маски; їх можна об’єднати АБО за допомогою "
"оператора ``|``, щоб сформувати значення поля :c:member:`~PyTypeObject."
"tp_flags`. Макрос :c:func:`PyType_HasFeature` приймає тип і значення "
"прапорців, *tp* і *f*, і перевіряє, чи ``tp->tp_flags & f`` є відмінним від "
"нуля."

msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :attr:`ob_type` field of its instances is considered a reference "
"to the type, and the type object is INCREF'ed when a new instance is "
"created, and DECREF'ed when an instance is destroyed (this does not apply to "
"instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""
"Цей біт встановлюється, коли сам об’єкт типу розміщується в купі, наприклад, "
"типи, створені динамічно за допомогою :c:func:`PyType_FromSpec`. У цьому "
"випадку поле :attr:`ob_type` його екземплярів вважається посиланням на тип, "
"а для об’єкта типу INCREF під час створення нового екземпляра та DECREF під "
"час знищення екземпляра (це робить не застосовуються до екземплярів "
"підтипів; лише тип, на який посилається ob_type екземпляра, отримує INCREF "
"або DECREF)."

msgid "???"
msgstr "???"

msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Цей біт встановлюється, коли тип можна використовувати як базовий тип іншого "
"типу. Якщо цей біт ясний, тип не може бути підтиповим (подібно до "
"\"фінального\" класу в Java)."

msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Цей біт встановлюється, коли об’єкт типу повністю ініціалізовано :c:func:"
"`PyType_Ready`."

msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Цей біт встановлюється, коли :c:func:`PyType_Ready` знаходиться в процесі "
"ініціалізації об’єкта типу."

msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""
"Цей біт встановлюється, якщо об’єкт підтримує збирання сміття. Якщо цей біт "
"установлено, екземпляри мають бути створені за допомогою :c:func:"
"`PyObject_GC_New` і знищені за допомогою :c:func:`PyObject_GC_Del`. Більше "
"інформації в розділі :ref:`supporting-cycle-detection`. Цей біт також "
"означає, що пов’язані з GC поля :c:member:`~PyTypeObject.tp_traverse` і :c:"
"member:`~PyTypeObject.tp_clear` присутні в об’єкті типу."

msgid ""
"Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"
msgstr ""
"Група: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"

msgid ""
"The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :"
"attr:`tp_traverse` and :attr:`tp_clear` fields, i.e.  if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :attr:"
"`tp_traverse` and :attr:`tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
"Біт прапора :const:`Py_TPFLAGS_HAVE_GC` успадковується разом із полями :attr:"
"`tp_traverse` і :attr:`tp_clear`, тобто якщо біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC` очищений у підтипі, а Поля :attr:`tp_traverse` і :attr:"
"`tp_clear` у підтипі існують і мають значення ``NULL``."

msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Це бітова маска всіх бітів, які стосуються існування певних полів в об’єкті "
"типу та його структурах розширення. Наразі він містить такі біти: :const:"
"`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

msgid "This bit indicates that objects behave like unbound methods."
msgstr "Цей біт вказує, що об’єкти поводяться як незв’язані методи."

msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Якщо цей прапор встановлено для ``type(meth)``, тоді:"

msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (з ``obj`` не None) має бути "
"еквівалентним ``meth(obj, *args, **kwds)``."

msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` має бути еквівалентним "
"``meth(*args, **kwds)``."

msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Цей прапорець дає змогу оптимізувати типові виклики методів, як-от ``obj."
"meth()``: він уникає створення тимчасового об’єкта \"зв’язаного методу\" для "
"``obj.meth``."

msgid ""
"This flag is never inherited by :ref:`heap types <heap-types>`. For "
"extension types, it is inherited whenever :c:member:`~PyTypeObject."
"tp_descr_get` is inherited."
msgstr ""

msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Ці позначки використовуються такими функціями, як :c:func:`PyLong_Check`, "
"щоб швидко визначити, чи є тип підкласом вбудованого типу; такі спеціальні "
"перевірки є швидшими, ніж загальні перевірки, наприклад :c:func:"
"`PyObject_IsInstance`. Користувальницькі типи, які успадковуються від "
"вбудованих, повинні мати належним чином встановлені :c:member:`~PyTypeObject."
"tp_flags`, інакше код, який взаємодіє з такими типами, поводитиметься по-"
"різному залежно від типу перевірки, що використовується."

msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Цей біт встановлюється, коли слот :c:member:`~PyTypeObject.tp_finalize` "
"присутній у структурі типу."

msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Цей прапорець більше не потрібен, оскільки інтерпретатор припускає, що слот :"
"c:member:`~PyTypeObject.tp_finalize` завжди присутній у структурі типу."

msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Цей біт встановлюється, коли клас реалізує :ref:`vectorcall протокол "
"<vectorcall>`. Перегляньте :c:member:`~PyTypeObject.tp_vectorcall_offset` "
"для деталей."

msgid ""
"This bit is inherited for :ref:`static subtypes <static-types>` if :c:member:"
"`~PyTypeObject.tp_call` is also inherited. :ref:`Heap types <heap-types>` do "
"not inherit ``Py_TPFLAGS_HAVE_VECTORCALL``."
msgstr ""

msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Цей біт встановлено для об’єктів типу, які є незмінними: атрибути типу не "
"можна ні встановити, ні видалити."

msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` автоматично застосовує цей прапорець до :ref:"
"`статичних типів <static-types>`."

msgid "This flag is not inherited."
msgstr "Цей прапорець не успадковується."

msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"Заборонити створення екземплярів типу: установіть для :c:member:"
"`~PyTypeObject.tp_new` значення NULL і не створюйте ключ ``__new__`` у "
"словнику типу."

msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"Прапор має бути встановлений до створення типу, а не після. Наприклад, його "
"потрібно встановити перед викликом :c:func:`PyType_Ready` для типу."

msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"Прапорець автоматично встановлюється для :ref:`статичних типів <static-"
"types>`, якщо :c:member:`~PyTypeObject.tp_base` має значення NULL або "
"``&PyBaseObject_Type`` і :c:member:`~PyTypeObject.tp_new` має значення NULL."

msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Цей біт вказує на те, що екземпляри класу можуть відповідати шаблонам "
"відображення, якщо використовуються як суб’єкт блоку :keyword:`match`. Він "
"автоматично встановлюється під час реєстрації або підкласу :class:"
"`collections.abc.Mapping` і скасовується під час реєстрації :class:"
"`collections.abc.Sequence`."

msgid ""
":const:`Py_TPFLAGS_MAPPING` and :const:`Py_TPFLAGS_SEQUENCE` are mutually "
"exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":const:`Py_TPFLAGS_MAPPING` і :const:`Py_TPFLAGS_SEQUENCE` є "
"взаємовиключними; одночасне ввімкнення обох прапорів є помилкою."

msgid ""
"This flag is inherited by types that do not already set :const:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Цей прапорець успадковується типами, які ще не встановили :const:"
"`Py_TPFLAGS_SEQUENCE`."

msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Структурне зіставлення шаблонів: Специфікація"

msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Цей біт вказує на те, що екземпляри класу можуть відповідати шаблонам "
"послідовності, коли використовуються як суб’єкт блоку :keyword:`match`. Він "
"автоматично встановлюється під час реєстрації або підкласу :class:"
"`collections.abc.Sequence` і скасовується під час реєстрації :class:"
"`collections.abc.Mapping`."

msgid ""
"This flag is inherited by types that do not already set :const:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Цей прапорець успадковується типами, які ще не встановили :const:"
"`Py_TPFLAGS_MAPPING`."

msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""
"Додатковий вказівник на рядок C із закінченням NUL, що дає рядок "
"документації для об’єкта цього типу. Це відображається як атрибут :attr:"
"`__doc__` для типу та екземплярів типу."

msgid "This field is *not* inherited by subtypes."
msgstr "Це поле *не* успадковується підтипами."

msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Додатковий покажчик на функцію обходу для збирача сміття. Це "
"використовується, лише якщо встановлено біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`. Підпис::"

msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Більше інформації про схему збирання сміття Python можна знайти в розділі :"
"ref:`supporting-cycle-detection`."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`local_traverse` from the :mod:"
"`_thread` extension module::"
msgstr ""
"Покажчик :c:member:`~PyTypeObject.tp_traverse` використовується збирачем "
"сміття для виявлення опорних циклів. Типова реалізація функції :c:member:"
"`~PyTypeObject.tp_traverse` просто викликає :c:func:`Py_VISIT` для кожного з "
"членів примірника, які є об’єктами Python, якими володіє примірник. "
"Наприклад, це функція :c:func:`local_traverse` з модуля розширення :mod:"
"`_thread`::"

msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Зауважте, що :c:func:`Py_VISIT` викликається лише для тих членів, які можуть "
"брати участь у еталонних циклах. Хоча також є член ``self->key``, він може "
"бути лише ``NULL`` або рядком Python і тому не може бути частиною еталонного "
"циклу."

msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"З іншого боку, навіть якщо ви знаєте, що член ніколи не може бути частиною "
"циклу, як допомога в налагодженні, ви можете все одно відвідати його, щоб "
"скористатися функцією :func:`~gc.get_referents` модуля :mod:`gc` буде "
"включати його."

msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Під час реалізації :c:member:`~PyTypeObject.tp_traverse` необхідно відвідати "
"лише члени, якими *володіє* примірник (через наявність :term:`сильних "
"посилань <strong reference>` на них). Наприклад, якщо об’єкт підтримує "
"слабкі посилання через слот :c:member:`~PyTypeObject.tp_weaklist`, "
"вказівник, що підтримує зв’язаний список (на що вказує *tp_weaklist*), "
"**не** має відвідуватися, як це робить екземпляр не володіє безпосередньо "
"слабкими посиланнями на себе (список слабких посилань існує для підтримки "
"механізму слабких посилань, але екземпляр не має сильного посилання на "
"елементи всередині нього, оскільки їх можна видалити, навіть якщо екземпляр "
"все ще живий)."

msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Зауважте, що :c:func:`Py_VISIT` вимагає параметрів *visit* і *arg*, щоб :c:"
"func:`local_traverse` мав ці конкретні імена; не називай їх як завгодно."

msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Екземпляри :ref:`виділених у купі типів <heap-types>` містять посилання на "
"свій тип. Таким чином, їх функція обходу повинна або відвідати :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, або делегувати цю відповідальність, викликавши "
"``tp_traverse`` іншого типу, виділеного купою (наприклад, суперкласу, "
"виділеного купою). Якщо вони цього не роблять, об’єкт типу може не збиратися "
"сміттям."

msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Очікується, що типи, виділені в купі, відвідуватимуть ``Py_TYPE(self)`` у "
"``tp_traverse``. У попередніх версіях Python, через `помилку 40217 <https://"
"bugs.python.org/issue40217>`_, це може призвести до збоїв у підкласах."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject.tp_clear` "
"і бітом прапора :const:`Py_TPFLAGS_HAVE_GC`: біт прапора, :c:member:"
"`~PyTypeObject.tp_traverse` і :c:member:`~PyTypeObject.tp_clear` "
"успадковуються від базового типу, якщо всі вони дорівнюють нулю в підтипі."

msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature "
"is::"
msgstr ""
"Додатковий покажчик на зрозумілу функцію для збирача сміття. Це "
"використовується, лише якщо встановлено біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`. Підпис::"

msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Функція-член :c:member:`~PyTypeObject.tp_clear` використовується для розриву "
"еталонних циклів у циклічному смітті, виявленому збирачем сміття. Взяті "
"разом, усі функції :c:member:`~PyTypeObject.tp_clear` у системі мають "
"поєднуватися, щоб розірвати всі цикли посилань. Це непомітно, і якщо є "
"сумніви, додайте функцію :c:member:`~PyTypeObject.tp_clear`. Наприклад, тип "
"кортежу не реалізує функцію :c:member:`~PyTypeObject.tp_clear`, тому що "
"можна довести, що жоден еталонний цикл не може повністю складатися з "
"кортежів. Тому функції :c:member:`~PyTypeObject.tp_clear` інших типів мають "
"бути достатніми, щоб розірвати будь-який цикл, що містить кортеж. Це не "
"відразу очевидно, і рідко є вагомі причини уникати реалізації :c:member:"
"`~PyTypeObject.tp_clear`."

msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Реалізації :c:member:`~PyTypeObject.tp_clear` мають видаляти посилання "
"екземпляра на ті з його членів, які можуть бути об’єктами Python, і "
"встановлювати його покажчики на ці члени на ``NULL``, як у наступному "
"прикладі::"

msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to ``NULL``.  This is "
"because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be ``NULL`` at that time, so that *self* knows the contained object "
"can no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations "
"in a safe order."
msgstr ""
"Слід використовувати макрос :c:func:`Py_CLEAR`, оскільки очищення посилань є "
"делікатним: посилання на об’єкт, що міститься, не має бути зменшено, доки "
"покажчик на об’єкт, що міститься, не буде встановлено на ``NULL``. Це "
"пов’язано з тим, що зменшення підрахунку посилань може призвести до того, що "
"об’єкт, що міститься, стане сміттям, запускаючи ланцюг дій із відновлення, "
"який може включати виклик довільного коду Python (через фіналізатори або "
"зворотні виклики weakref, пов’язані з об’єктом, що міститься). Якщо для "
"такого коду можливо знову посилатися на *self*, важливо, щоб вказівник на "
"об’єкт, що міститься, у цей час був ``NULL``, щоб *self* знав, що об’єкт, що "
"міститься, більше не можна використовувати. Макрос :c:func:`Py_CLEAR` "
"виконує операції в безпечному порядку."

msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"Зауважте, що :c:member:`~PyTypeObject.tp_clear` не *завжди* викликається до "
"того, як екземпляр буде звільнено. Наприклад, коли підрахунку посилань "
"достатньо, щоб визначити, що об’єкт більше не використовується, циклічний "
"збирач сміття не залучається, і безпосередньо викликається :c:member:"
"`~PyTypeObject.tp_dealloc`."

msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Оскільки мета функцій :c:member:`~PyTypeObject.tp_clear` — розірвати цикли "
"посилань, немає необхідності очищати об’єкти, що містяться, як-от рядки "
"Python або цілі числа Python, які не можуть брати участь у циклах посилань. "
"З іншого боку, може бути зручно очистити всі об’єкти Python і написати "
"функцію типу :c:member:`~PyTypeObject.tp_dealloc` для виклику :c:member:"
"`~PyTypeObject.tp_clear`."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_traverse` і :const:`Py_TPFLAGS_HAVE_GC` біт прапора: біт прапора, :c:"
"member:`~PyTypeObject.tp_traverse` і :c:member:`~PyTypeObject.tp_clear` "
"успадковуються від базового типу, якщо всі вони дорівнюють нулю в підтипі."

msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Додатковий вказівник на функцію розширеного порівняння, сигнатура якої::"

msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Перший параметр гарантовано є екземпляром типу, визначеного :c:type:"
"`PyTypeObject`."

msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"Функція має повертати результат порівняння (зазвичай ``Py_True`` або "
"``Py_False``). Якщо порівняння не визначено, воно має повернути "
"``Py_NotImplemented``, якщо сталася інша помилка, воно має повернути "
"``NULL`` і встановити умову винятку."

msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Наступні константи визначено для використання як третій аргумент для :c:"
"member:`~PyTypeObject.tp_richcompare` і для :c:func:`PyObject_RichCompare`:"

msgid "Constant"
msgstr "Постійний"

msgid "Comparison"
msgstr "Порівняння"

msgid ":const:`Py_LT`"
msgstr ":const:`Py_LT`"

msgid "``<``"
msgstr "``<``"

msgid ":const:`Py_LE`"
msgstr ":const:`Py_LE`"

msgid "``<=``"
msgstr "``<=``"

msgid ":const:`Py_EQ`"
msgstr ":const:`Py_EQ`"

msgid "``==``"
msgstr "``==``"

msgid ":const:`Py_NE`"
msgstr ":const:`Py_NE`"

msgid "``!=``"
msgstr "``!=``"

msgid ":const:`Py_GT`"
msgstr ":const:`Py_GT`"

msgid "``>``"
msgstr "``>``"

msgid ":const:`Py_GE`"
msgstr ":const:`Py_GE`"

msgid "``>=``"
msgstr "``>=``"

msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"Наступний макрос визначено для полегшення написання розширених функцій "
"порівняння:"

msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Повертає з функції ``Py_True`` або ``Py_False``, залежно від результату "
"порівняння. VAL_A і VAL_B повинні бути впорядковані операторами порівняння C "
"(наприклад, вони можуть бути C int або float). Третій аргумент визначає "
"необхідну операцію, як для :c:func:`PyObject_RichCompare`."

msgid "The return value's reference count is properly incremented."
msgstr ""
"Лічильник посилань на значення, що повертається, правильно збільшується."

msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "У разі помилки встановлює виняток і повертає ``NULL`` із функції."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject.tp_hash`: "
"підтип успадковує :c:member:`~PyTypeObject.tp_richcompare` і :c:member:"
"`~PyTypeObject.tp_hash`, коли підтип :c:member:`~PyTypeObject."
"tp_richcompare` і :c:member:`~PyTypeObject.tp_hash` мають значення ``NULL``."

msgid ""
":c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare` "
"implementation, which may be inherited.  However, if only :attr:`tp_hash` is "
"defined, not even the inherited function is used and instances of the type "
"will not be able to participate in any comparisons."
msgstr ""
":c:type:`PyBaseObject_Type` забезпечує реалізацію :attr:`tp_richcompare`, "
"яка може бути успадкована. Однак, якщо визначено лише :attr:`tp_hash`, "
"навіть успадкована функція не використовується, і екземпляри типу не зможуть "
"брати участь у жодних порівняннях."

msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the :c:func:`PyWeakref_\\*` "
"functions.  The instance structure needs to include a field of type :c:type:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Якщо на екземпляри цього типу є слабкі посилання, це поле більше за нуль і "
"містить зсув у структурі екземпляра заголовка списку слабких посилань "
"(ігноруючи заголовок GC, якщо він присутній); це зміщення використовується "
"функціями :c:func:`PyObject_ClearWeakRefs` і функціями :c:func:"
"`PyWeakref_\\*`. Структура екземпляра має включати поле типу :c:type:"
"`PyObject*`, яке ініціалізується значенням ``NULL``."

msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"Не плутайте це поле з :c:member:`~PyTypeObject.tp_weaklist`; це заголовок "
"списку для слабких посилань на сам об’єкт типу."

msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Це поле успадковується підтипами, але перегляньте наведені нижче правила. "
"Підтип може замінити це зміщення; це означає, що підтип використовує інший "
"слабкий заголовок списку посилань, ніж базовий тип. Оскільки заголовок "
"списку завжди можна знайти через :c:member:`~PyTypeObject."
"tp_weaklistoffset`, це не повинно бути проблемою."

msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""
"Якщо тип, визначений оператором класу, не має оголошення :attr:`~object."
"__slots__`, і жоден із його базових типів не має слабких посилань, тип стає "
"слабко посилальним шляхом додавання слота заголовка списку слабких посилань "
"до макета екземпляра та встановлення :c:member:`~PyTypeObject."
"tp_weaklistoffset` зміщення цього слота."

msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Коли оголошення типу :attr:`__slots__` містить слот під назвою :attr:"
"`__weakref__`, цей слот стає заголовком списку слабких посилань для "
"екземплярів типу, а зсув слота зберігається в :c:member:`~PyTypeObject."
"tp_weaklistoffset` типу."

msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""
"Якщо оголошення типу :attr:`__slots__` не містить слота з назвою :attr:"
"`__weakref__`, тип успадковує свій :c:member:`~PyTypeObject."
"tp_weaklistoffset` від свого базового типу."

msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"Додатковий покажчик на функцію, яка повертає :term:`iterator` для об’єкта. "
"Його наявність зазвичай сигналізує про те, що екземпляри цього типу :term:"
"`iterable` (хоча послідовності можуть бути ітерованими без цієї функції)."

msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Ця функція має той самий підпис, що й :c:func:`PyObject_GetIter`::"

msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"Додатковий покажчик на функцію, яка повертає наступний елемент у :term:"
"`iterator`. Підпис::"

msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"Коли ітератор вичерпано, він повинен повернути ``NULL``; Виняток :exc:"
"`StopIteration` може бути встановлений або не встановлений. Коли виникає "
"інша помилка, вона також має повернути ``NULL``. Його наявність сигналізує "
"про те, що екземпляри цього типу є ітераторами."

msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Типи ітераторів також повинні визначати функцію :c:member:`~PyTypeObject."
"tp_iter`, і ця функція має повертати сам екземпляр ітератора (а не новий "
"екземпляр ітератора)."

msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Ця функція має той самий підпис, що й :c:func:`PyIter_Next`."

msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Необов’язковий вказівник на статичний масив структур :c:type:`PyMethodDef` "
"із закінченням ``NULL``, що оголошує регулярні методи цього типу."

msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Для кожного запису в масиві до словника типу (див. :c:member:`~PyTypeObject."
"tp_dict` нижче) додається запис, що містить дескриптор методу."

msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (методи успадковуються через інший "
"механізм)."

msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"Необов’язковий вказівник на статичний масив структур :c:type:`PyMemberDef` "
"із закінченням ``NULL``, що оголошує регулярні члени даних (поля або слоти) "
"екземплярів цього типу."

msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Для кожного запису в масиві до словника типу (див. :c:member:`~PyTypeObject."
"tp_dict` нижче) додається запис, що містить дескриптор члена."

msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (члени успадковуються через інший "
"механізм)."

msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"Додатковий вказівник на статичний масив структур :c:type:`PyGetSetDef` із "
"закінченням ``NULL``, що оголошує обчислені атрибути екземплярів цього типу."

msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Для кожного запису в масиві до словника типу (див. :c:member:`~PyTypeObject."
"tp_dict` нижче) додається запис, що містить дескриптор getset."

msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (обчислені атрибути успадковуються за "
"допомогою іншого механізму)."

msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Додатковий покажчик на базовий тип, властивості якого успадковуються. На "
"цьому рівні підтримується лише одиночне успадкування; множинне успадкування "
"вимагає динамічного створення об’єкта типу шляхом виклику метатипу."

msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"Ініціалізація слота підпорядковується правилам ініціалізації глобалів. C99 "
"вимагає, щоб ініціалізатори були \"константами адреси\". Позначення функцій, "
"такі як :c:func:`PyType_GenericNew`, з неявним перетворенням на вказівник, є "
"дійсними константами адрес C99."

msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"func:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Однак унарний оператор \"&\", застосований до нестатичної змінної, "
"наприклад :c:func:`PyBaseObject_Type`, не потрібен для створення константи "
"адреси. Компілятори можуть це підтримувати (gcc підтримує), а MSVC — ні. "
"Обидва компілятори суворо відповідають стандартам у цій конкретній поведінці."

msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"Отже, :c:member:`~PyTypeObject.tp_base` має бути встановлено у функції "
"ініціалізації модуля розширення."

msgid "This field is not inherited by subtypes (obviously)."
msgstr "Це поле не успадковується підтипами (очевидно)."

msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"У цьому полі за замовчуванням встановлено ``&PyBaseObject_Type`` (що "
"програмістам на Python відоме як тип :class:`object`)."

msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "Словник типу зберігається тут у :c:func:`PyType_Ready`."

msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""
"Перед викликом PyType_Ready це поле має бути ініціалізовано як ``NULL``; він "
"також може бути ініціалізований словником, що містить початкові атрибути для "
"типу. Після того, як :c:func:`PyType_Ready` ініціалізує тип, додаткові "
"атрибути для типу можуть бути додані до цього словника, лише якщо вони не "
"відповідають перевантаженим операціям (наприклад, :meth:`__add__`)."

msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (хоча атрибути, визначені тут, "
"успадковуються за допомогою іншого механізму)."

msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Якщо це поле має значення ``NULL``, :c:func:`PyType_Ready` призначить йому "
"новий словник."

msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"Небезпечно використовувати :c:func:`PyDict_SetItem` або іншим чином "
"змінювати :c:member:`~PyTypeObject.tp_dict` за допомогою словника C-API."

msgid "An optional pointer to a \"descriptor get\" function."
msgstr "Додатковий вказівник на функцію \"отримання дескриптора\"."

msgid "The function signature is::"
msgstr "Сигнатура функції:"

msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Додатковий покажчик на функцію для встановлення та видалення значення "
"дескриптора."

msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "Аргумент *value* має значення ``NULL``, щоб видалити значення."

msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Якщо екземпляри цього типу мають словник, що містить змінні екземпляра, це "
"поле ненульове та містить зміщення в екземплярах типу словника змінних "
"екземплярів; це зміщення використовується :c:func:`PyObject_GenericGetAttr`."

msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"Не плутайте це поле з :c:member:`~PyTypeObject.tp_dict`; це словник для "
"атрибутів самого об’єкта типу."

msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""
"Якщо значення цього поля більше нуля, воно визначає зміщення від початку "
"структури екземпляра. Якщо значення менше нуля, воно визначає зміщення від "
"*кінця* структури екземпляра. Від’ємне зміщення є дорожчим у використанні, і "
"його слід використовувати лише тоді, коли структура екземпляра містить "
"частину змінної довжини. Це використовується, наприклад, для додавання "
"словника змінних примірників до підтипів :class:`str` або :class:`tuple`. "
"Зауважте, що в цьому випадку поле :c:member:`~PyTypeObject.tp_basicsize` має "
"враховувати словник, доданий у кінець, навіть якщо словник не включено до "
"основного макета об’єкта. У системі з розміром покажчика 4 байти :c:member:"
"`~PyTypeObject.tp_dictoffset` має бути встановлено на ``-4``, щоб вказати, "
"що словник знаходиться в самому кінці структури."

msgid ""
"The real dictionary offset in an instance can be computed from a negative :c:"
"member:`~PyTypeObject.tp_dictoffset` as follows::"
msgstr ""
"Справжнє зміщення словника в екземплярі можна обчислити з негативного :c:"
"member:`~PyTypeObject.tp_dictoffset` наступним чином::"

msgid ""
"where :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` and :c:member:`~PyTypeObject.tp_dictoffset` are taken from the "
"type object, and :attr:`ob_size` is taken from the instance.  The absolute "
"value is taken because ints use the sign of :attr:`ob_size` to store the "
"sign of the number.  (There's never a need to do this calculation yourself; "
"it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""
"де :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` і :c:member:`~PyTypeObject.tp_dictoffset` беруться з об’єкта "
"типу, а :attr:`ob_size` береться з примірника. Береться абсолютне значення, "
"тому що int використовує знак :attr:`ob_size` для зберігання знака числа. "
"(Ніколи не потрібно робити це обчислення самостійно; це робить за вас :c:"
"func:`_PyObject_GetDictPtr`.)"

msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""
"Це поле успадковується підтипами, але перегляньте наведені нижче правила. "
"Підтип може замінити це зміщення; це означає, що екземпляри підтипу "
"зберігають словник зі зміщенням різниці, ніж базовий тип. Оскільки словник "
"завжди можна знайти через :c:member:`~PyTypeObject.tp_dictoffset`, це не "
"повинно бути проблемою."

msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""
"Якщо тип, визначений оператором класу, не має оголошення :attr:`~object."
"__slots__`, і жоден із його базових типів не має словника змінної "
"екземпляра, слот словника додається до макета екземпляра та :c:member:"
"`~PyTypeObject.tp_dictoffset` встановлено на зміщення цього слота."

msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""
"Коли тип, визначений оператором класу, має оголошення :attr:`__slots__`, тип "
"успадковує свій :c:member:`~PyTypeObject.tp_dictoffset` від свого базового "
"типу."

msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""
"(Додавання слота з іменем :attr:`~object.__dict__` до оголошення :attr:"
"`__slots__` не має очікуваного ефекту, це лише викликає плутанину. Можливо, "
"це слід додати як функцію, як :attr:`__weakref__` хоча.)"

msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`__dict__` gets created for instances."
msgstr ""
"Цей слот не має умовчання. Для :ref:`статичних типів <static-types>`, якщо "
"поле має значення ``NULL``, тоді :attr:`__dict__` не створюється для "
"екземплярів."

msgid "An optional pointer to an instance initialization function."
msgstr "Додатковий покажчик на функцію ініціалізації екземпляра."

msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""
"Ця функція відповідає методу класів :meth:`__init__`. Подібно до :meth:"
"`__init__`, екземпляр можна створити без виклику :meth:`__init__`, а "
"екземпляр можна повторно ініціалізувати, викликавши його метод :meth:"
"`__init__` знову."

msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""
"Аргумент self - це екземпляр, який потрібно ініціалізувати; аргументи *args* "
"і *kwds* представляють позиційні та ключові аргументи виклику :meth:"
"`__init__`."

msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"Функція :c:member:`~PyTypeObject.tp_init`, якщо вона не ``NULL``, "
"викликається, коли екземпляр створюється звичайним викликом його типу, після "
"функції :c:member:`~PyTypeObject.tp_new` типу. повернув екземпляр типу. Якщо "
"функція :c:member:`~PyTypeObject.tp_new` повертає екземпляр якогось іншого "
"типу, який не є підтипом вихідного типу, функція :c:member:`~PyTypeObject."
"tp_init` не викликається; якщо :c:member:`~PyTypeObject.tp_new` повертає "
"екземпляр підтипу вихідного типу, викликається :c:member:`~PyTypeObject."
"tp_init` підтипу."

msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"У разі успіху повертає ``0``, ``-1`` і встановлює виняток у випадку помилки."

msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr ""
"Для :ref:`статичних типів <static-types>` це поле не має значення за "
"замовчуванням."

msgid "An optional pointer to an instance allocation function."
msgstr "Додатковий покажчик на функцію виділення екземпляра."

msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""
"Це поле успадковується статичними підтипами, але не динамічними підтипами "
"(підтипами, створеними оператором класу)."

msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""
"Для динамічних підтипів це поле завжди має значення :c:func:"
"`PyType_GenericAlloc`, щоб примусово використовувати стандартну стратегію "
"розподілу купи."

msgid ""
"For static subtypes, :c:type:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""
"Для статичних підтипів :c:type:`PyBaseObject_Type` використовує :c:func:"
"`PyType_GenericAlloc`. Це рекомендоване значення для всіх статично "
"визначених типів."

msgid "An optional pointer to an instance creation function."
msgstr "Додатковий покажчик на функцію створення екземпляра."

msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"Аргумент *subtype* — це тип об’єкта, що створюється; аргументи *args* і "
"*kwds* представляють позиційні та ключові аргументи виклику типу. Зауважте, "
"що *subtype* не обов’язково дорівнює типу, чия функція :c:member:"
"`~PyTypeObject.tp_new` викликається; це може бути підтип цього типу (але не "
"непов’язаний тип)."

msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"Функція :c:member:`~PyTypeObject.tp_new` має викликати ``subtype-"
">tp_alloc(subtype, nitems)``, щоб виділити простір для об’єкта, а потім "
"виконувати подальшу ініціалізацію лише стільки, скільки це абсолютно "
"необхідно. Ініціалізацію, яку можна безпечно проігнорувати або повторити, "
"слід розмістити в обробнику :c:member:`~PyTypeObject.tp_init`. Хорошим "
"емпіричним правилом є те, що для незмінних типів уся ініціалізація має "
"відбуватися в :c:member:`~PyTypeObject.tp_new`, тоді як для змінних типів "
"більшість ініціалізацій має бути відкладено до :c:member:`~PyTypeObject."
"tp_init`."

msgid ""
"Set the :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow creating "
"instances of the type in Python."
msgstr ""
"Установіть прапорець :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION`, щоб "
"заборонити створення екземплярів типу в Python."

msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Це поле успадковується підтипами, за винятком :ref:`статичних типів <static-"
"types>`, у яких :c:member:`~PyTypeObject.tp_base` має значення ``NULL`` або "
"``&PyBaseObject_Type``."

msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"Для :ref:`статичних типів <static-types>` це поле не має типового значення. "
"Це означає, що якщо слот визначено як ``NULL``, тип не можна викликати для "
"створення нових екземплярів; мабуть, існує якийсь інший спосіб створення "
"екземплярів, як-от фабрична функція."

msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr "Додатковий покажчик на функцію звільнення екземпляра. Його підпис::"

msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr "Ініціалізатор, сумісний із цим підписом, це :c:func:`PyObject_Free`."

msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""
"Це поле успадковується статичними підтипами, але не динамічними підтипами "
"(підтипами, створеними оператором класу)"

msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit."
msgstr ""
"У динамічних підтипах це поле встановлюється на засіб розблокування, який "
"відповідає :c:func:`PyType_GenericAlloc` і значенню біта прапора :const:"
"`Py_TPFLAGS_HAVE_GC`."

msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del."
msgstr ""
"Для статичних підтипів :c:type:`PyBaseObject_Type` використовує PyObject_Del."

msgid "An optional pointer to a function called by the garbage collector."
msgstr "Додатковий покажчик на функцію, яка викликається збирачем сміття."

msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"Збирач сміття повинен знати, чи є певний об'єкт предметом колекціонування чи "
"ні. Зазвичай достатньо подивитися на поле типу об’єкта :c:member:"
"`~PyTypeObject.tp_flags` і перевірити біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`. Але деякі типи мають поєднання статично та динамічно "
"виділених екземплярів, і статично виділені екземпляри неможливо зібрати. "
"Такі типи повинні визначати цю функцію; він має повертати ``1`` для "
"екземпляра, який можна колекціонувати, і ``0`` для екземпляра, який не "
"підлягає колекціонуванню. Підпис::"

msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(Єдиним прикладом цього є самі типи. Метатип :c:data:`PyType_Type` визначає "
"цю функцію, щоб розрізняти статично та :ref:`динамічно виділені типи <heap-"
"types>`.)"

msgid ""
"This slot has no default.  If this field is ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Цей слот не має умовчання. Якщо це поле має значення ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` використовується як функціональний еквівалент."

msgid "Tuple of base types."
msgstr "Кортеж базових типів."

msgid ""
"This is set for types created by a class statement.  It should be ``NULL`` "
"for statically defined types."
msgstr ""
"Це встановлено для типів, створених оператором класу. Він має бути ``NULL`` "
"для статично визначених типів."

msgid "This field is not inherited."
msgstr "Це поле не успадковується."

msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Кортеж, що містить розширений набір базових типів, починаючи з самого типу "
"та закінчуючи :class:`object`, у порядку вирішення методів."

msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"Це поле не успадковується; він обчислюється за допомогою :c:func:"
"`PyType_Ready`."

msgid "Unused.  Internal use only."
msgstr "Невикористаний. Тільки для внутрішнього використання."

msgid "List of weak references to subclasses.  Internal use only."
msgstr ""
"Список слабких посилань на підкласи. Тільки для внутрішнього використання."

msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Голова списку слабких посилань для слабких посилань на об’єкт цього типу. Не "
"передається у спадок. Тільки для внутрішнього використання."

msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Це поле застаріло. Натомість використовуйте :c:member:`~PyTypeObject."
"tp_finalize`."

msgid "Used to index into the method cache.  Internal use only."
msgstr ""
"Використовується для індексування в кеш методів. Тільки для внутрішнього "
"використання."

msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr "Додатковий покажчик на функцію завершення екземпляра. Його підпис::"

msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"Якщо встановлено :c:member:`~PyTypeObject.tp_finalize`, інтерпретатор "
"викликає його один раз під час завершення екземпляра. Він викликається або "
"зі збирача сміття (якщо екземпляр є частиною ізольованого еталонного циклу), "
"або безпосередньо перед звільненням об’єкта. У будь-якому випадку, він "
"гарантовано буде викликаний перед спробою розірвати еталонні цикли, "
"гарантуючи, що він знайде об’єкт у нормальному стані."

msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` не повинен змінювати поточний статус "
"винятку; отже, рекомендований спосіб написання нетривіального фіналізатора:"

msgid ""
"For this field to be taken into account (even through inheritance), you must "
"also set the :const:`Py_TPFLAGS_HAVE_FINALIZE` flags bit."
msgstr ""
"Щоб це поле було враховано (навіть через успадкування), ви також повинні "
"встановити біт прапорців :const:`Py_TPFLAGS_HAVE_FINALIZE`."

msgid ""
"Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject."
"tp_dealloc` may be called from any Python thread, not just the thread which "
"created the object (if the object becomes part of a refcount cycle, that "
"cycle might be collected by a garbage collection on any thread).  This is "
"not a problem for Python API calls, since the thread on which tp_dealloc is "
"called will own the Global Interpreter Lock (GIL). However, if the object "
"being destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the thread "
"which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"Також зауважте, що в Python зі збиранням сміття :c:member:`~PyTypeObject."
"tp_dealloc` можна викликати з будь-якого потоку Python, а не лише з потоку, "
"який створив об’єкт (якщо об’єкт стає частиною циклу підрахунку посилань, це "
"цикл може бути зібраний за допомогою збирання сміття в будь-якому потоці). "
"Це не проблема для викликів Python API, оскільки потік, у якому викликається "
"tp_dealloc, буде володіти глобальним блокуванням інтерпретатора (GIL). "
"Проте, якщо об’єкт, який знищується, у свою чергу знищує об’єкти з якоїсь "
"іншої бібліотеки C або C++, слід подбати про те, щоб знищення цих об’єктів у "
"потоці, яка викликала tp_dealloc, не порушувало жодних припущень бібліотеки."

msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"Безпечна фіналізація об'єкта\" (:pep:`442`)"

msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"attr:`__new__` and :attr:`__init__` is used."
msgstr ""
"Функція Vectorcall для викликів об’єкта цього типу. Іншими словами, він "
"використовується для реалізації :ref:`vectorcall <vectorcall>` для ``type."
"__call__``. Якщо ``tp_vectorcall`` має значення ``NULL``, використовується "
"реалізація виклику за замовчуванням за допомогою :attr:`__new__` і :attr:"
"`__init__`."

msgid "This field is never inherited."
msgstr "Це поле ніколи не успадковується."

msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(поле існує з 3.8, але використовується лише з 3.9)"

msgid "Static Types"
msgstr "Статичні типи"

msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Традиційно типи, визначені в коді C, є *статичними*, тобто статична "
"структура :c:type:`PyTypeObject` визначається безпосередньо в коді та "
"ініціалізується за допомогою :c:func:`PyType_Ready`."

msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Це призводить до типів, які обмежені відносно типів, визначених у Python:"

msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Статичні типи обмежені однією базою, тобто вони не можуть використовувати "
"множинне успадкування."

msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Об’єкти статичного типу (але не обов’язково їх екземпляри) незмінні. "
"Неможливо додати або змінити атрибути об’єкта типу з Python."

msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Об’єкти статичного типу є спільними для :ref:`суб-інтерпретаторів <sub-"
"interpreter-support>`, тому вони не повинні включати будь-який стан, "
"специфічний для субінтерпретатора."

msgid ""
"Also, since :c:type:`PyTypeObject` is not part of the :ref:`stable ABI "
"<stable>`, any extension modules using static types must be compiled for a "
"specific Python minor version."
msgstr ""
"Крім того, оскільки :c:type:`PyTypeObject` не є частиною :ref:`stable ABI "
"<stable>`, будь-які модулі розширення, що використовують статичні типи, "
"повинні бути скомпільовані для конкретної проміжної версії Python."

msgid "Heap Types"
msgstr "Типи купи"

msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :const:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Альтернативою :ref:`статичним типам <static-types>` є *розподілені типи*, "
"або скорочено *типи купи*, які тісно відповідають класам, створеним "
"оператором ``class`` Python. Для типів купи встановлено прапорець :const:"
"`Py_TPFLAGS_HEAPTYPE`."

msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, or :c:func:"
"`PyType_FromModuleAndSpec`."
msgstr ""
"Це робиться шляхом заповнення структури :c:type:`PyType_Spec` і виклику :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases` або :c:func:"
"`PyType_FromModuleAndSpec`."

msgid "Number Object Structures"
msgstr "Числові об’єктні структури"

msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Ця структура містить покажчики на функції, які об’єкт використовує для "
"реалізації протоколу чисел. Кожна функція використовується функцією з "
"подібною назвою, задокументованою в розділі :ref:`number`."

msgid "Here is the structure definition::"
msgstr "Ось визначення структури::"

msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Двійкові та потрійні функції повинні перевіряти тип усіх своїх операндів і "
"здійснювати необхідні перетворення (принаймні один із операндів є "
"екземпляром визначеного типу). Якщо операція не визначена для заданих "
"операндів, двійкові та тернарні функції повинні повернути "
"``Py_NotImplemented``, якщо сталася інша помилка, вони повинні повернути "
"``NULL`` і встановити виняток."

msgid ""
"The :c:data:`nb_reserved` field should always be ``NULL``.  It was "
"previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""
"Поле :c:data:`nb_reserved` має завжди мати значення ``NULL``. Раніше він "
"називався :c:data:`nb_long` і був перейменований у Python 3.0.1."

msgid "Mapping Object Structures"
msgstr "Відображення структур об’єктів"

msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Ця структура містить покажчики на функції, які об’єкт використовує для "
"реалізації протоколу відображення. Він складається з трьох членів:"

msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Ця функція використовується :c:func:`PyMapping_Size` і :c:func:"
"`PyObject_Size` і має однакову сигнатуру. Цей слот може бути встановлений на "
"``NULL``, якщо об’єкт не має визначеної довжини."

msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Ця функція використовується :c:func:`PyObject_GetItem` і :c:func:"
"`PySequence_GetSlice`, і має такий же підпис, як :c:func:`!"
"PyObject_GetItem`. Цей слот має бути заповнений, щоб функція :c:func:"
"`PyMapping_Check` повернула ``1``, інакше вона може бути ``NULL``."

msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and :c:func:"
"`PyObject_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Цю функцію використовують :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` і :c:func:"
"`PyObject_DelSlice`. Він має той самий підпис, що й :c:func:`!"
"PyObject_SetItem`, але *v* також можна встановити на ``NULL``, щоб видалити "
"елемент. Якщо цей слот має значення ``NULL``, об’єкт не підтримує "
"призначення та видалення елементів."

msgid "Sequence Object Structures"
msgstr "Структури об’єктів послідовності"

msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Ця структура містить покажчики на функції, які об’єкт використовує для "
"реалізації протоколу послідовності."

msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Ця функція використовується :c:func:`PySequence_Size` і :c:func:"
"`PyObject_Size` і має однакову сигнатуру. Він також використовується для "
"обробки негативних індексів через слоти :c:member:`~PySequenceMethods."
"sq_item` і :c:member:`~PySequenceMethods.sq_ass_item`."

msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_Concat` і має такий самий "
"підпис. Він також використовується оператором ``+`` після спроби додавання "
"чисел через слот :c:member:`~PyNumberMethods.nb_add`."

msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_Repeat` і має такий самий "
"підпис. Він також використовується оператором ``*`` після спроби числового "
"множення через слот :c:member:`~PyNumberMethods.nb_multiply`."

msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Ця функція використовується :c:func:`PySequence_GetItem` і має такий самий "
"підпис. Він також використовується :c:func:`PyObject_GetItem` після спроби "
"підписки через слот :c:member:`~PyMappingMethods.mp_subscript`. Цей слот має "
"бути заповнений, щоб функція :c:func:`PySequence_Check` повертала ``1``, "
"інакше вона може бути ``NULL``."

msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is ``NULL``, "
"the index is passed as is to the function."
msgstr ""
"Негативні індекси обробляються таким чином: якщо слот :attr:`sq_length` "
"заповнений, він викликається, і довжина послідовності використовується для "
"обчислення позитивного індексу, який передається в :attr:`sq_item`. Якщо :"
"attr:`sq_length` дорівнює ``NULL``, індекс передається до функції як є."

msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Ця функція використовується :c:func:`PySequence_SetItem` і має такий самий "
"підпис. Він також використовується :c:func:`PyObject_SetItem` і :c:func:"
"`PyObject_DelItem` після спроби призначення та видалення елемента через "
"слот :c:member:`~PyMappingMethods.mp_ass_subscript`. Цей слот можна залишити "
"``NULL``, якщо об’єкт не підтримує призначення та видалення елементів."

msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Ця функція може використовуватися :c:func:`PySequence_Contains` і має такий "
"самий підпис. Цей слот можна залишити ``NULL``, у цьому випадку :c:func:`!"
"PySequence_Contains` просто обходить послідовність, поки не знайде збіг."

msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_InPlaceConcat` і має такий "
"самий підпис. Він повинен змінити свій перший операнд і повернути його. Цей "
"слот можна залишити ``NULL``, у цьому випадку :c:func:`!"
"PySequence_InPlaceConcat` повернеться до :c:func:`PySequence_Concat`. Він "
"також використовується розширеним призначенням ``+=`` після спроби додавання "
"чисел на місці через слот :c:member:`~PyNumberMethods.nb_inplace_add`."

msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_InPlaceRepeat` і має такий "
"самий підпис. Він повинен змінити свій перший операнд і повернути його. Цей "
"слот можна залишити ``NULL``, у цьому випадку :c:func:`!"
"PySequence_InPlaceRepeat` повернеться до :c:func:`PySequence_Repeat`. Він "
"також використовується розширеним призначенням ``*=`` після спроби числового "
"множення на місці через слот :c:member:`~PyNumberMethods."
"nb_inplace_multiply`."

msgid "Buffer Object Structures"
msgstr "Буферні об'єктні структури"

msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Ця структура містить покажчики на функції, необхідні для :ref:`протоколу "
"буфера <bufferobjects>`. Протокол визначає, як об’єкт-експортер може "
"надавати свої внутрішні дані об’єктам-споживачам."

msgid "The signature of this function is::"
msgstr "Сигнатура цієї функції:"

msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Обробляти запит до *exporter* для заповнення *view*, як зазначено *flags*. "
"За винятком пункту (3), реалізація цієї функції ПОВИННА виконувати такі дії:"

msgid ""
"Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, "
"set :c:data:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Перевірте, чи можна задовольнити запит. Якщо ні, підніміть :c:data:"
"`PyExc_BufferError`, встановіть :c:data:`view->obj` на ``NULL`` і поверніть "
"``-1``."

msgid "Fill in the requested fields."
msgstr "Заповніть необхідні поля."

msgid "Increment an internal counter for the number of exports."
msgstr "Збільшити внутрішній лічильник для кількості експортів."

msgid ""
"Set :c:data:`view->obj` to *exporter* and increment :c:data:`view->obj`."
msgstr ""
"Установіть для :c:data:`view->obj` значення *exporter* і збільште :c:data:"
"`view->obj`."

msgid "Return ``0``."
msgstr "Повернути ``0``."

msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Якщо *експортер* є частиною ланцюжка або дерева постачальників буферів, "
"можна використовувати дві основні схеми:"

msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"data:`view->obj` to a new reference to itself."
msgstr ""
"Повторний експорт: кожен член дерева діє як об’єкт експорту та встановлює :c:"
"data:`view->obj` нове посилання на себе."

msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:data:`view->obj` will be a new reference to the root object."
msgstr ""
"Перенаправлення: запит буфера перенаправляється до кореневого об’єкта "
"дерева. Тут :c:data:`view->obj` буде новим посиланням на кореневий об’єкт."

msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Окремі поля *view* описані в розділі :ref:`Структура буфера <buffer-"
"structure>`, правила, як експортер повинен реагувати на конкретні запити, "
"знаходяться в розділі :ref:`Типи запитів буфера <buffer-request-types>`."

msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Уся пам’ять, на яку вказує структура :c:type:`Py_buffer`, належить "
"експортеру та має залишатися чинною, доки не залишиться споживачів. :c:"
"member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` та :c:member:"
"`~Py_buffer.internal` доступні лише для читання для споживача."

msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` забезпечує простий спосіб відкрити простий буфер "
"байтів, правильно обробляючи всі типи запитів."

msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` — це інтерфейс для споживача, який обертає цю "
"функцію."

msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Обробляти запит на звільнення ресурсів буфера. Якщо не потрібно звільняти "
"ресурси, :c:member:`PyBufferProcs.bf_releasebuffer` може мати значення "
"``NULL``. В іншому випадку стандартна реалізація цієї функції виконає "
"наступні додаткові дії:"

msgid "Decrement an internal counter for the number of exports."
msgstr "Зменшити внутрішній лічильник для кількості експортів."

msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Якщо лічильник ``0``, звільнити всю пам'ять, пов'язану з *view*."

msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"Експортер ПОВИНЕН використовувати поле :c:member:`~Py_buffer.internal`, щоб "
"відстежувати ресурси, пов’язані з буфером. Це поле гарантовано залишається "
"постійним, тоді як споживач МОЖЕ передати копію вихідного буфера як аргумент "
"*view*."

msgid ""
"This function MUST NOT decrement :c:data:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Ця функція НЕ ПОВИННА зменшувати :c:data:`view->obj`, оскільки це робиться "
"автоматично в :c:func:`PyBuffer_Release` (ця схема корисна для розриву "
"еталонних циклів)."

msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` — це інтерфейс для споживача, який обертає цю "
"функцію."

msgid "Async Object Structures"
msgstr "Асинхронні об'єктні структури"

msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Ця структура містить покажчики на функції, необхідні для реалізації "
"об’єктів :term:`awaitable` і :term:`asynchronous iterator`."

msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"Повернений об’єкт має бути :term:`iterator`, тобто :c:func:`PyIter_Check` "
"має повернути для нього ``1``."

msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Цей слот може мати значення ``NULL``, якщо об’єкт не є :term:`awaitable`."

msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`__anext__` "
"for details."
msgstr ""
"Має повертати об’єкт :term:`asynchronous iterator`. Докладніше див. :meth:"
"`__anext__`."

msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Цей слот може мати значення ``NULL``, якщо об’єкт не реалізує протокол "
"асинхронної ітерації."

msgid ""
"Must return an :term:`awaitable` object.  See :meth:`__anext__` for details. "
"This slot may be set to ``NULL``."
msgstr ""
"Має повертати об’єкт :term:`awaitable`. Докладніше див. :meth:`__anext__`. "
"Цей слот може мати значення ``NULL``."

msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Дивіться :c:func:`PyIter_Send` для деталей. Цей слот може мати значення "
"``NULL``."

msgid "Slot Type typedefs"
msgstr "Типи слотів"

msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, "
"the object's :attr:`ob_size` field should be initialized to *nitems* and the "
"length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be :c:"
"member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Метою цієї функції є відокремлення виділення пам’яті від ініціалізації "
"пам’яті. Він має повертати вказівник на блок пам’яті адекватної довжини для "
"екземпляра, відповідним чином вирівняний та ініціалізований нулями, але з :"
"attr:`ob_refcnt`, встановленим на ``1``, і :attr:`ob_type`, встановленим на "
"аргумент типу. Якщо тип :c:member:`~PyTypeObject.tp_itemsize` відмінний від "
"нуля, поле :attr:`ob_size` об’єкта має бути ініціалізовано *nitems*, а "
"довжина виділеного блоку пам’яті має бути ``tp_basicsize + nitems "
"*tp_itemsize``, округлений до кратного ``sizeof(void*)``; інакше *nitems* не "
"використовується, а довжина блоку має бути :c:member:`~PyTypeObject."
"tp_basicsize`."

msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Ця функція не повинна виконувати будь-яку іншу ініціалізацію екземпляра, "
"навіть не для виділення додаткової пам’яті; це має зробити :c:member:"
"`~PyTypeObject.tp_new`."

msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_free`."

msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_new`."

msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_init`."

msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_repr`."

msgid "Return the value of the named attribute for the object."
msgstr "Повертає значення названого атрибута для об’єкта."

msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Установіть для об’єкта значення іменованого атрибута. Аргумент значення має "
"значення ``NULL``, щоб видалити атрибут."

msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_getattro`."

msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_setattro`."

msgid "See :c:member:`~PyTypeObject.tp_descrget`."
msgstr ""

msgid "See :c:member:`~PyTypeObject.tp_descrset`."
msgstr ""

msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_hash`."

msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_richcompare`."

msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_iter`."

msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Перегляньте :c:member:`~PyTypeObject.tp_iternext`."

msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Перегляньте :c:member:`~PyAsyncMethods.am_send`."

msgid "Examples"
msgstr "Приклади"

msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Нижче наведено прості приклади визначень типів Python. Вони включають "
"загальне використання, з яким ви можете зіткнутися. Деякі демонструють хитрі "
"кутові випадки. Більше прикладів, практичної інформації та підручника див. :"
"ref:`defining-new-types` і :ref:`new-types-topics`."

msgid "A basic :ref:`static type <static-types>`::"
msgstr "Базовий :ref:`статичний тип <static-types>`::"

msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"Ви також можете знайти старіший код (особливо в кодовій базі CPython) із "
"більш детальним ініціалізатором:"

msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "Тип, який підтримує слабкі посилання, екземпляри dicts і хешування::"

msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:data:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"Підклас str, який не може бути підкласом і не може бути викликаний для "
"створення екземплярів (наприклад, використовує окрему заводську функцію), "
"використовуючи прапор :c:data:`Py_TPFLAGS_DISALLOW_INSTANTIATION`::"

msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"Найпростіший :ref:`статичний тип <static-types>` з екземплярами фіксованої "
"довжини::"

msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"Найпростіший :ref:`статичний тип <static-types>` з екземплярами змінної "
"довжини::"
