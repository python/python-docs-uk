# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Taras Kuzyo <kuzyo.taras@gmail.com>, 2023
# Dmytro Kazanzhy, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../c-api/intro.rst:8
msgid "Introduction"
msgstr "Вступ"

#: ../../c-api/intro.rst:10
msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers"
" access to the Python interpreter at a variety of levels.  The API is "
"equally usable from C++, but for brevity it is generally referred to as the "
"Python/C API.  There are two fundamentally different reasons for using the "
"Python/C API. The first reason is to write *extension modules* for specific "
"purposes; these are C modules that extend the Python interpreter.  This is "
"probably the most common use.  The second reason is to use Python as a "
"component in a larger application; this technique is generally referred to "
"as :dfn:`embedding` Python in an application."
msgstr ""
"Інтерфейс прикладного програміста для Python надає програмістам C і C++ "
"доступ до інтерпретатора Python на різних рівнях. API так само можна "
"використовувати з C++, але для стислості його зазвичай називають Python/C "
"API. Є дві принципово різні причини використання Python/C API. Перша причина"
" полягає в написанні *модулів розширення* для певних цілей; це модулі C, які"
" розширюють інтерпретатор Python. Мабуть, це найпоширеніше використання. "
"Друга причина полягає в тому, щоб використовувати Python як компонент у "
"більшій програмі; цей прийом зазвичай називають :dfn:`embedding` Python у "
"програму."

#: ../../c-api/intro.rst:20
msgid ""
"Writing an extension module is a relatively well-understood process, where a"
" \"cookbook\" approach works well.  There are several tools that automate "
"the process to some extent.  While people have embedded Python in other "
"applications since its early existence, the process of embedding Python is "
"less straightforward than writing an extension."
msgstr ""
"Написання модуля розширення є відносно добре зрозумілим процесом, де добре "
"працює підхід \"кулінарної книги\". Є кілька інструментів, які певною мірою "
"автоматизують процес. Хоча люди вбудовували Python в інші програми з самого "
"початку його існування, процес вбудовування Python менш простий, ніж "
"написання розширення."

#: ../../c-api/intro.rst:26
msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python"
" in a real application."
msgstr ""
"Багато функцій API корисні незалежно від того, чи ви вбудовуєте чи "
"розширюєте Python; крім того, більшість програм, які вбудовують Python, "
"потребуватимуть також надати спеціальне розширення, тому, мабуть, доцільно "
"ознайомитися з написанням розширення перед тим, як намагатися вставити "
"Python у реальну програму."

#: ../../c-api/intro.rst:34
msgid "Coding standards"
msgstr "Стандарти кодування"

#: ../../c-api/intro.rst:36
msgid ""
"If you're writing C code for inclusion in CPython, you **must** follow the "
"guidelines and standards defined in :PEP:`7`.  These guidelines apply "
"regardless of the version of Python you are contributing to.  Following "
"these conventions is not necessary for your own third party extension "
"modules, unless you eventually expect to contribute them to Python."
msgstr ""
"Якщо ви пишете код C для включення в CPython, ви **повинні** дотримуватися "
"вказівок і стандартів, визначених у :PEP:`7`. Ці вказівки застосовуються "
"незалежно від версії Python, до якої ви робите внесок. Дотримання цих умов "
"не є обов’язковим для ваших власних модулів розширення сторонніх "
"розробників, якщо тільки ви не плануєте додати їх до Python."

#: ../../c-api/intro.rst:46
msgid "Include Files"
msgstr "Включати файли"

#: ../../c-api/intro.rst:48
msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr ""
"Усі визначення функцій, типів і макросів, необхідні для використання API "
"Python/C, включено у ваш код у такий рядок::"

#: ../../c-api/intro.rst:51
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""

#: ../../c-api/intro.rst:54
msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and "
"``<stdlib.h>`` (if available)."
msgstr ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and "
"``<stdlib.h>`` (if available)."

#: ../../c-api/intro.rst:60
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before"
" any standard headers are included."
msgstr ""
"Оскільки Python може визначати деякі визначення попереднього процесора, які "
"впливають на стандартні заголовки в деяких системах, ви *мусите* включити "
":file:`Python.h` перед тим, як включити будь-які стандартні заголовки."

#: ../../c-api/intro.rst:64
msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`arg-parsing` for a description of this macro."
msgstr ""
"Рекомендується завжди визначати ``PY_SSIZE_T_CLEAN`` перед включенням "
"``Python.h``. Перегляньте :ref:`arg-parsing` для опису цього макросу."

#: ../../c-api/intro.rst:67
msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member"
" names do not have a reserved prefix."
msgstr ""
"Усі видимі для користувача імена, визначені Python.h (крім тих, що визначені"
" включеними стандартними заголовками), мають один із префіксів ``Py`` або "
"``_Py``. Імена, що починаються з ``_Py`` призначені для внутрішнього "
"використання реалізацією Python і не повинні використовуватися розробниками "
"розширень. Імена членів структури не мають зарезервованого префікса."

#: ../../c-api/intro.rst:74
msgid ""
"User code should never define names that begin with ``Py`` or ``_Py``. This "
"confuses the reader, and jeopardizes the portability of the user code to "
"future Python versions, which may define additional names beginning with one"
" of these prefixes."
msgstr ""
"Код користувача ніколи не повинен визначати імена, які починаються з ``Py`` "
"або ``_Py``. Це заплутує читача та ставить під загрозу перенесення коду "
"користувача на майбутні версії Python, які можуть визначати додаткові імена,"
" що починаються з одного з цих префіксів."

#: ../../c-api/intro.rst:79
msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and "
":file:`{exec_prefix}/include/pythonversion/`, where :option:`prefix "
"<--prefix>` and :option:`exec_prefix <--exec-prefix>` are defined by the "
"corresponding parameters to Python's :program:`configure` script and "
"*version* is ``'%d.%d' % sys.version_info[:2]``.  On Windows, the headers "
"are installed in :file:`{prefix}/include`, where ``prefix`` is the "
"installation directory specified to the installer."
msgstr ""

#: ../../c-api/intro.rst:88
msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will"
" break on multi-platform builds since the platform independent headers under"
" :option:`prefix <--prefix>` include the platform specific headers from "
":option:`exec_prefix <--exec-prefix>`."
msgstr ""

#: ../../c-api/intro.rst:95
msgid ""
"C++ users should note that although the API is defined entirely using C, the"
" header files properly declare the entry points to be ``extern \"C\"``. As a"
" result, there is no need to do anything special to use the API from C++."
msgstr ""
"Користувачі C++ повинні мати на увазі, що хоча API повністю визначено за "
"допомогою C, файли заголовків належним чином оголошують точки входу як "
"``extern \"C\"``. Як наслідок, немає потреби робити щось особливе для "
"використання API із C++."

#: ../../c-api/intro.rst:101
msgid "Useful macros"
msgstr "Корисні макроси"

#: ../../c-api/intro.rst:103
msgid ""
"Several useful macros are defined in the Python header files.  Many are "
"defined closer to where they are useful (e.g. :c:macro:`Py_RETURN_NONE`). "
"Others of a more general utility are defined here.  This is not necessarily "
"a complete listing."
msgstr ""
"У файлах заголовків Python визначено кілька корисних макросів. Багато "
"визначено ближче до того, де вони корисні (наприклад, "
":c:macro:`Py_RETURN_NONE`). Тут визначено інші більш загальні корисності. Це"
" не обов’язково повний список."

#: ../../c-api/intro.rst:110
msgid ""
"Declare an extension module ``PyInit`` initialization function. The function"
" return type is :c:expr:`PyObject*`. The macro declares any special linkage "
"declarations required by the platform, and for C++ declares the function as "
"``extern \"C\"``."
msgstr ""

#: ../../c-api/intro.rst:115
msgid ""
"The initialization function must be named :samp:`PyInit_{name}`, where "
"*name* is the name of the module, and should be the only non-\\ ``static`` "
"item defined in the module file. Example::"
msgstr ""

#: ../../c-api/intro.rst:119
msgid ""
"static struct PyModuleDef spam_module = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModule_Create(&spam_module);\n"
"}"
msgstr ""

#: ../../c-api/intro.rst:134
msgid "Return the absolute value of ``x``."
msgstr "Повертає абсолютне значення ``x``."

#: ../../c-api/intro.rst:140
msgid ""
"Ask the compiler to always inline a static inline function. The compiler can"
" ignore it and decides to not inline the function."
msgstr ""

#: ../../c-api/intro.rst:143
msgid ""
"It can be used to inline performance critical static inline functions when "
"building Python in debug mode with function inlining disabled. For example, "
"MSC disables function inlining when building in debug mode."
msgstr ""

#: ../../c-api/intro.rst:147
msgid ""
"Marking blindly a static inline function with Py_ALWAYS_INLINE can result in"
" worse performances (due to increased code size for example). The compiler "
"is usually smarter than the developer for the cost/benefit analysis."
msgstr ""

#: ../../c-api/intro.rst:151
msgid ""
"If Python is :ref:`built in debug mode <debug-build>` (if the "
":c:macro:`Py_DEBUG` macro is defined), the :c:macro:`Py_ALWAYS_INLINE` macro"
" does nothing."
msgstr ""

#: ../../c-api/intro.rst:154
msgid "It must be specified before the function return type. Usage::"
msgstr ""

#: ../../c-api/intro.rst:156
msgid "static inline Py_ALWAYS_INLINE int random(void) { return 4; }"
msgstr ""

#: ../../c-api/intro.rst:162
msgid ""
"Argument must be a character or an integer in the range [-128, 127] or [0, "
"255].  This macro returns ``c`` cast to an ``unsigned char``."
msgstr ""
"Аргумент має бути символом або цілим числом у діапазоні [-128, 127] або [0, "
"255]. Цей макрос повертає ``c``, приведений до ``unsigned char``."

#: ../../c-api/intro.rst:167
msgid ""
"Use this for deprecated declarations.  The macro must be placed before the "
"symbol name."
msgstr ""
"Використовуйте це для застарілих декларацій. Макрос необхідно розмістити "
"перед назвою символу."

#: ../../c-api/intro.rst:170 ../../c-api/intro.rst:256
#: ../../c-api/intro.rst:274
msgid "Example::"
msgstr "Приклад::"

#: ../../c-api/intro.rst:172
msgid "Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);"
msgstr ""

#: ../../c-api/intro.rst:174
msgid "MSVC support was added."
msgstr "Додано підтримку MSVC."

#: ../../c-api/intro.rst:179
msgid ""
"Like ``getenv(s)``, but returns ``NULL`` if :option:`-E` was passed on the "
"command line (see :c:member:`PyConfig.use_environment`)."
msgstr ""

#: ../../c-api/intro.rst:184
msgid "Return the maximum value between ``x`` and ``y``."
msgstr "Повертає максимальне значення між ``x`` і ``y``."

#: ../../c-api/intro.rst:190
msgid "Return the size of a structure (``type``) ``member`` in bytes."
msgstr "Повертає розмір члена структури (``type``) у байтах."

#: ../../c-api/intro.rst:196
msgid "Return the minimum value between ``x`` and ``y``."
msgstr "Повертає мінімальне значення між ``x`` і ``y``."

#: ../../c-api/intro.rst:202
msgid ""
"Disable inlining on a function. For example, it reduces the C stack "
"consumption: useful on LTO+PGO builds which heavily inline code (see "
":issue:`33720`)."
msgstr ""

#: ../../c-api/intro.rst:206
msgid "Usage::"
msgstr "Використання::"

#: ../../c-api/intro.rst:208
msgid "Py_NO_INLINE static int random(void) { return 4; }"
msgstr ""

#: ../../c-api/intro.rst:214
msgid ""
"Convert ``x`` to a C string.  E.g. ``Py_STRINGIFY(123)`` returns "
"``\"123\"``."
msgstr ""
"Перетворіть ``x`` на рядок C. наприклад ``Py_STRINGIFY(123)`` повертає "
"``\"123\"``."

#: ../../c-api/intro.rst:221
msgid ""
"Use this when you have a code path that cannot be reached by design. For "
"example, in the ``default:`` clause in a ``switch`` statement for which all "
"possible values are covered in ``case`` statements.  Use this in places "
"where you might be tempted to put an ``assert(0)`` or ``abort()`` call."
msgstr ""
"Використовуйте це, якщо у вас є шлях коду, який неможливий за проектом. "
"Наприклад, у реченні ``default:`` в операторі ``switch``, для якого всі "
"можливі значення охоплюються в операторах ``case``. Використовуйте це в "
"місцях, де у вас може виникнути спокуса викликати ``assert(0)`` або "
"``abort()``."

#: ../../c-api/intro.rst:226
msgid ""
"In release mode, the macro helps the compiler to optimize the code, and "
"avoids a warning about unreachable code.  For example, the macro is "
"implemented with ``__builtin_unreachable()`` on GCC in release mode."
msgstr ""
"У режимі випуску макрос допомагає компілятору оптимізувати код і уникає "
"попередження про недоступність коду. Наприклад, макрос реалізовано за "
"допомогою ``__builtin_unreachable()`` на GCC у режимі випуску."

#: ../../c-api/intro.rst:230
msgid ""
"A use for ``Py_UNREACHABLE()`` is following a call a function that never "
"returns but that is not declared :c:macro:`_Py_NO_RETURN`."
msgstr ""
"Використання ``Py_UNREACHABLE()`` — це виклик функції, яка ніколи не "
"повертається, але не оголошена :c:macro:`_Py_NO_RETURN`."

#: ../../c-api/intro.rst:233
msgid ""
"If a code path is very unlikely code but can be reached under exceptional "
"case, this macro must not be used.  For example, under low memory condition "
"or if a system call returns a value out of the expected range.  In this "
"case, it's better to report the error to the caller.  If the error cannot be"
" reported to caller, :c:func:`Py_FatalError` can be used."
msgstr ""
"Якщо кодовий шлях є дуже малоймовірним кодом, але його можна досягти у "
"виняткових випадках, цей макрос не можна використовувати. Наприклад, у разі "
"недостатнього обсягу пам’яті або якщо системний виклик повертає значення за "
"межами очікуваного діапазону. У цьому випадку краще повідомити про помилку "
"абонента. Якщо про помилку неможливо повідомити абоненту, можна використати "
":c:func:`Py_FatalError`."

#: ../../c-api/intro.rst:243
msgid ""
"Use this for unused arguments in a function definition to silence compiler "
"warnings. Example: ``int func(int a, int Py_UNUSED(b)) { return a; }``."
msgstr ""
"Використовуйте це для невикористаних аргументів у визначенні функції, щоб "
"заглушити попередження компілятора. Приклад: ``int func(int a, int "
"Py_UNUSED(b)) { return a; }``."

#: ../../c-api/intro.rst:250
msgid ""
"Creates a variable with name ``name`` that can be used in docstrings. If "
"Python is built without docstrings, the value will be empty."
msgstr ""
"Створює змінну з назвою ``name``, яку можна використовувати в рядках "
"документів. Якщо Python створено без рядків документації, значення буде "
"порожнім."

#: ../../c-api/intro.rst:253
msgid ""
"Use :c:macro:`PyDoc_STRVAR` for docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Використовуйте :c:macro:`PyDoc_STRVAR` для рядків документів, щоб "
"підтримувати створення Python без рядків документів, як зазначено в "
":pep:`7`."

#: ../../c-api/intro.rst:258
msgid ""
"PyDoc_STRVAR(pop_doc, \"Remove and return the rightmost element.\");\n"
"\n"
"static PyMethodDef deque_methods[] = {\n"
"    // ...\n"
"    {\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n"
"    // ...\n"
"}"
msgstr ""

#: ../../c-api/intro.rst:268
msgid ""
"Creates a docstring for the given input string or an empty string if "
"docstrings are disabled."
msgstr ""
"Створює рядок документації для заданого рядка введення або порожній рядок, "
"якщо рядки документації вимкнено."

#: ../../c-api/intro.rst:271
msgid ""
"Use :c:macro:`PyDoc_STR` in specifying docstrings to support building Python"
" without docstrings, as specified in :pep:`7`."
msgstr ""
"Використовуйте :c:macro:`PyDoc_STR` у визначенні рядків документів, щоб "
"підтримувати створення Python без рядків документів, як зазначено в "
":pep:`7`."

#: ../../c-api/intro.rst:276
msgid ""
"static PyMethodDef pysqlite_row_methods[] = {\n"
"    {\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS,\n"
"        PyDoc_STR(\"Returns the keys of the row.\")},\n"
"    {NULL, NULL}\n"
"};"
msgstr ""

#: ../../c-api/intro.rst:286
msgid "Objects, Types and Reference Counts"
msgstr "Об’єкти, типи та кількість посилань"

#: ../../c-api/intro.rst:290
msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:expr:`PyObject*`.  This type is a pointer to an opaque data"
" type representing an arbitrary Python object.  Since all Python object "
"types are treated the same way by the Python language in most situations "
"(e.g., assignments, scope rules, and argument passing), it is only fitting "
"that they should be represented by a single C type.  Almost all Python "
"objects live on the heap: you never declare an automatic or static variable "
"of type :c:type:`PyObject`, only pointer variables of type "
":c:expr:`PyObject*` can  be declared.  The sole exception are the type "
"objects; since these must never be deallocated, they are typically static "
":c:type:`PyTypeObject` objects."
msgstr ""

#: ../../c-api/intro.rst:301
msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a "
":dfn:`reference count`.  An object's type determines what kind of object it "
"is (e.g., an integer, a list, or a user-defined function; there are many "
"more as explained in :ref:`types`).  For each of the well-known types there "
"is a macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is"
" a Python list."
msgstr ""
"Усі об’єкти Python (навіть цілі числа Python) мають :dfn:`type` і "
":dfn:`reference counting`. Тип об’єкта визначає тип об’єкта (наприклад, ціле"
" число, список або визначена користувачем функція; їх багато інших, як "
"пояснюється в :ref:`types`). Для кожного з добре відомих типів існує макрос,"
" щоб перевірити, чи належить об’єкт до цього типу; наприклад, "
"``PyList_Check(a)`` є істинним, якщо (і тільки якщо) об’єкт, на який вказує "
"*a*, є списком Python."

#: ../../c-api/intro.rst:312
msgid "Reference Counts"
msgstr "Довідкова кількість"

#: ../../c-api/intro.rst:314
msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many different "
"places there are that have a :term:`strong reference` to an object. Such a "
"place could be another object, or a global (or static) C variable, or a "
"local variable in some C function. When the last :term:`strong reference` to"
" an object is released (i.e. its reference count becomes zero), the object "
"is deallocated. If it contains references to other objects, those references"
" are released. Those other objects may be deallocated in turn, if there are "
"no more references to them, and so on.  (There's an obvious problem  with "
"objects that reference each other here; for now, the solution is \"don't do "
"that.\")"
msgstr ""

#: ../../c-api/intro.rst:331
msgid ""
"Reference counts are always manipulated explicitly.  The normal way is to "
"use the macro :c:func:`Py_INCREF` to take a new reference to an object (i.e."
" increment its reference count by one), and :c:func:`Py_DECREF` to release "
"that reference (i.e. decrement the reference count by one).  The "
":c:func:`Py_DECREF` macro is considerably more complex than the incref one, "
"since it must check whether the reference count becomes zero and then cause "
"the object's deallocator to be called.  The deallocator is a function "
"pointer contained in the object's type structure.  The type-specific "
"deallocator takes care of releasing references for other objects contained "
"in the object if this is a compound object type, such as a list, as well as "
"performing any additional finalization that's needed.  There's no chance "
"that the reference count can overflow; at least as many bits are used to "
"hold the reference count as there are distinct memory locations in virtual "
"memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the "
"reference count increment is a simple operation."
msgstr ""

#: ../../c-api/intro.rst:347
msgid ""
"It is not necessary to hold a :term:`strong reference` (i.e. increment the "
"reference count) for every local variable that contains a pointer to an "
"object.  In theory, the  object's reference count goes up by one when the "
"variable is made to  point to it and it goes down by one when the variable "
"goes out of  scope.  However, these two cancel each other out, so at the end"
" the  reference count hasn't changed.  The only real reason to use the  "
"reference count is to prevent the object from being deallocated as  long as "
"our variable is pointing to it.  If we know that there is at  least one "
"other reference to the object that lives at least as long as our variable, "
"there is no need to take a new :term:`strong reference` (i.e. increment the "
"reference count) temporarily. An important situation where this arises is in"
" objects  that are passed as arguments to C functions in an extension module"
"  that are called from Python; the call mechanism guarantees to hold a  "
"reference to every argument for the duration of the call."
msgstr ""

#: ../../c-api/intro.rst:363
msgid ""
"However, a common pitfall is to extract an object from a list and hold on to"
" it for a while without taking a new reference.  Some other operation might "
"conceivably remove the object from the list, releasing that reference, and "
"possibly deallocating it. The real danger is that innocent-looking "
"operations may invoke arbitrary Python code which could do this; there is a "
"code path which allows control to flow back to the user from a "
":c:func:`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""

#: ../../c-api/intro.rst:371
msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always create a new :term:`strong "
"reference` (i.e. increment the reference count) of the object they return. "
"This leaves the caller with the responsibility to call :c:func:`Py_DECREF` "
"when they are done with the result; this soon becomes second nature."
msgstr ""

#: ../../c-api/intro.rst:382
msgid "Reference Count Details"
msgstr "Деталі кількості посилань"

#: ../../c-api/intro.rst:384
msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually releasing it by calling "
":c:func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a "
":term:`borrowed reference`."
msgstr ""

#: ../../c-api/intro.rst:397
msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr ""
"І навпаки, коли функція, що викликає, передає посилання на об’єкт, є дві "
"можливості: функція *вкрадає* посилання на об’єкт або ні. *Крадіжка "
"посилання* означає, що коли ви передаєте посилання на функцію, ця функція "
"припускає, що вона тепер володіє цим посиланням, і ви більше не несете за це"
" відповідальності."

#: ../../c-api/intro.rst:407
msgid ""
"Few functions steal references; the two notable exceptions are "
":c:func:`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a "
"reference to the item (but not to the tuple or list into which the item is "
"put!).  These functions were designed to steal a reference because of a "
"common idiom for populating a tuple or list with newly created objects; for "
"example, the code to create the tuple ``(1, 2, \"three\")`` could look like "
"this (forgetting about error handling for the moment; a better way to code "
"this is shown below)::"
msgstr ""
"Кілька функцій викрадають посилання; двома помітними винятками є "
":c:func:`PyList_SetItem` і :c:func:`PyTuple_SetItem`, які викрадають "
"посилання на елемент (але не на кортеж або список, до якого поміщено "
"елемент!). Ці функції були розроблені для викрадення посилання через "
"загальну ідіому для заповнення кортежу або списку новоствореними об’єктами; "
"наприклад, код для створення кортежу ``(1, 2, \"three\")`` може виглядати "
"так (наразі забувши про обробку помилок; кращий спосіб кодування цього "
"показано нижче):"

#: ../../c-api/intro.rst:415
msgid ""
"PyObject *t;\n"
"\n"
"t = PyTuple_New(3);\n"
"PyTuple_SetItem(t, 0, PyLong_FromLong(1L));\n"
"PyTuple_SetItem(t, 1, PyLong_FromLong(2L));\n"
"PyTuple_SetItem(t, 2, PyUnicode_FromString(\"three\"));"
msgstr ""

#: ../../c-api/intro.rst:422
msgid ""
"Here, :c:func:`PyLong_FromLong` returns a new reference which is immediately"
" stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object"
" although the reference to it will be stolen, use :c:func:`Py_INCREF` to "
"grab another reference before calling the reference-stealing function."
msgstr ""
"Тут :c:func:`PyLong_FromLong` повертає нове посилання, яке негайно викрадає "
":c:func:`PyTuple_SetItem`. Якщо ви хочете продовжувати використовувати "
"об’єкт, хоча посилання на нього буде вкрадено, використовуйте "
":c:func:`Py_INCREF`, щоб захопити інше посилання перед викликом функції "
"викрадання посилань."

#: ../../c-api/intro.rst:427
msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to"
" do this since tuples are an immutable data type.  You should only use "
":c:func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"До речі, :c:func:`PyTuple_SetItem` є *єдиним* способом встановлення "
"елементів кортежу; :c:func:`PySequence_SetItem` і :c:func:`PyObject_SetItem`"
" відмовляються робити це, оскільки кортежі є незмінним типом даних. Ви "
"повинні використовувати лише :c:func:`PyTuple_SetItem` для кортежів, які ви "
"створюєте самостійно."

#: ../../c-api/intro.rst:432
msgid ""
"Equivalent code for populating a list can be written using "
":c:func:`PyList_New` and :c:func:`PyList_SetItem`."
msgstr ""
"Еквівалентний код для заповнення списку можна написати за допомогою "
":c:func:`PyList_New` і :c:func:`PyList_SetItem`."

#: ../../c-api/intro.rst:435
msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, "
":c:func:`Py_BuildValue`, that can create most common objects from C values, "
"directed by a :dfn:`format string`. For example, the above two blocks of "
"code could be replaced by the following (which also takes care of the error "
"checking)::"
msgstr ""
"Однак на практиці ви рідко будете використовувати ці способи створення та "
"заповнення кортежу чи списку. Існує загальна функція, "
":c:func:`Py_BuildValue`, яка може створювати найбільш поширені об’єкти зі "
"значень C, керованих :dfn:`format string`. Наприклад, наведені вище два "
"блоки коду можна замінити наступним (який також піклується про перевірку "
"помилок):"

#: ../../c-api/intro.rst:441
msgid ""
"PyObject *tuple, *list;\n"
"\n"
"tuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\");\n"
"list = Py_BuildValue(\"[iis]\", 1, 2, \"three\");"
msgstr ""

#: ../../c-api/intro.rst:446
msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding references is much saner, since you don't have to take a new "
"reference just so you can give that reference away (\"have it be stolen\")."
"  For example, this function sets all items of a list (actually, any mutable"
" sequence) to a given item::"
msgstr ""

#: ../../c-api/intro.rst:453
msgid ""
"int\n"
"set_all(PyObject *target, PyObject *item)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"\n"
"    n = PyObject_Length(target);\n"
"    if (n < 0)\n"
"        return -1;\n"
"    for (i = 0; i < n; i++) {\n"
"        PyObject *index = PyLong_FromSsize_t(i);\n"
"        if (!index)\n"
"            return -1;\n"
"        if (PyObject_SetItem(target, index, item) < 0) {\n"
"            Py_DECREF(index);\n"
"            return -1;\n"
"        }\n"
"        Py_DECREF(index);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/intro.rst:476
msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference"
" to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` and"
"  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr ""
"Ситуація дещо інша для значень, що повертаються функцією. Хоча передача "
"посилання на більшість функцій не змінює вашу відповідальність за це "
"посилання, багато функцій, які повертають посилання на об’єкт, передають вам"
" право власності на посилання. Причина проста: у багатьох випадках "
"повернутий об’єкт створюється на льоту, і отримане вами посилання є єдиним "
"посиланням на об’єкт. Тому загальні функції, які повертають посилання на "
"об’єкти, як-от :c:func:`PyObject_GetItem` і :c:func:`PySequence_GetItem`, "
"завжди повертають нове посилання (викликач стає власником посилання)."

#: ../../c-api/intro.rst:485
msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type"
" of the object passed as an argument to the function) *doesn't enter into "
"it!* Thus, if you  extract an item from a list using "
":c:func:`PyList_GetItem`, you don't own the reference --- but if you obtain "
"the same item from the same list using :c:func:`PySequence_GetItem` (which "
"happens to take exactly the same arguments), you do own a reference to the "
"returned object."
msgstr ""
"Важливо розуміти, що чи володієте ви посиланням, яке повертає функція, "
"залежить лише від того, яку функцію ви викликаєте --- *оперення* (тип "
"об’єкта, переданого як аргумент функції) *не входить до нього !* Таким "
"чином, якщо ви витягуєте елемент зі списку за допомогою "
":c:func:`PyList_GetItem`, ви не володієте посиланням --- але якщо ви "
"отримуєте той самий елемент із того самого списку за допомогою "
":c:func:`PySequence_GetItem` (який приймає точно ті самі аргументи), у вас є"
" посилання на повернутий об’єкт."

#: ../../c-api/intro.rst:497
msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr ""
"Ось приклад того, як можна написати функцію, яка обчислює суму елементів у "
"списку цілих чисел; один раз за допомогою :c:func:`PyList_GetItem` і один "
"раз за допомогою :c:func:`PySequence_GetItem`. ::"

#: ../../c-api/intro.rst:501
msgid ""
"long\n"
"sum_list(PyObject *list)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"\n"
"    n = PyList_Size(list);\n"
"    if (n < 0)\n"
"        return -1; /* Not a list */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PyList_GetItem(list, i); /* Can't fail */\n"
"        if (!PyLong_Check(item)) continue; /* Skip non-integers */\n"
"        value = PyLong_AsLong(item);\n"
"        if (value == -1 && PyErr_Occurred())\n"
"            /* Integer too big to fit in a C long, bail out */\n"
"            return -1;\n"
"        total += value;\n"
"    }\n"
"    return total;\n"
"}"
msgstr ""

#: ../../c-api/intro.rst:527
msgid ""
"long\n"
"sum_sequence(PyObject *sequence)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"    n = PySequence_Length(sequence);\n"
"    if (n < 0)\n"
"        return -1; /* Has no length */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PySequence_GetItem(sequence, i);\n"
"        if (item == NULL)\n"
"            return -1; /* Not a sequence, or other failure */\n"
"        if (PyLong_Check(item)) {\n"
"            value = PyLong_AsLong(item);\n"
"            Py_DECREF(item);\n"
"            if (value == -1 && PyErr_Occurred())\n"
"                /* Integer too big to fit in a C long, bail out */\n"
"                return -1;\n"
"            total += value;\n"
"        }\n"
"        else {\n"
"            Py_DECREF(item); /* Discard reference ownership */\n"
"        }\n"
"    }\n"
"    return total;\n"
"}"
msgstr ""

#: ../../c-api/intro.rst:561
msgid "Types"
msgstr "Типи"

#: ../../c-api/intro.rst:563
msgid ""
"There are few other data types that play a significant role in  the Python/C"
" API; most are simple C types such as :c:expr:`int`,  :c:expr:`long`, "
":c:expr:`double` and :c:expr:`char*`.  A few structure types  are used to "
"describe static tables used to list the functions exported  by a module or "
"the data attributes of a new object type, and another is used to describe "
"the value of a complex number.  These will  be discussed together with the "
"functions that use them."
msgstr ""

#: ../../c-api/intro.rst:573
msgid ""
"A signed integral type such that ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 doesn't define such a thing directly (size_t is an unsigned integral "
"type). See :pep:`353` for details. ``PY_SSIZE_T_MAX`` is the largest "
"positive value of type :c:type:`Py_ssize_t`."
msgstr ""
"Інтегральний тип зі знаком, такий що ``sizeof(Py_ssize_t) == "
"sizeof(size_t)``. C99 не визначає таку річ безпосередньо (size_t є "
"беззнаковим інтегральним типом). Подробиці див. :pep:`353`. "
"``PY_SSIZE_T_MAX`` є найбільшим додатним значенням типу "
":c:type:`Py_ssize_t`."

#: ../../c-api/intro.rst:582
msgid "Exceptions"
msgstr "Винятки"

#: ../../c-api/intro.rst:584
msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the "
"top-level interpreter, where they are reported to the  user accompanied by a"
" stack traceback."
msgstr ""
"Програміст на Python має мати справу лише з винятками, якщо потрібна "
"спеціальна обробка помилок; необроблені винятки автоматично поширюються до "
"абонента, потім до абонента, що викликає, і так далі, доки вони не досягнуть"
" інтерпретатора верхнього рівня, де про них повідомляється користувачеві в "
"супроводі стека."

#: ../../c-api/intro.rst:592
msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim"
" is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either ``NULL`` or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error"
" indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr ""
"Однак для програмістів на C перевірка помилок завжди має бути явною. Усі "
"функції в Python/C API можуть викликати винятки, якщо в документації до "
"функції не вказано інше. Загалом, коли функція стикається з помилкою, вона "
"встановлює виняток, відкидає будь-які посилання на об’єкти, якими вона "
"володіє, і повертає індикатор помилки. Якщо не задокументовано інше, цей "
"індикатор має значення ``NULL`` або ``-1``, залежно від типу повернення "
"функції. Кілька функцій повертають логічний результат true/false, де false "
"вказує на помилку. Дуже небагато функцій не повертають явного індикатора "
"помилки або мають неоднозначне значення, що повертається, і вимагають явного"
" тестування помилок за допомогою :c:func:`PyErr_Occurred`. Ці винятки завжди"
" чітко задокументовані."

#: ../../c-api/intro.rst:607
msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one"
" of two states: an exception has occurred, or not. The function "
":c:func:`PyErr_Occurred` can be used to check for this: it returns a "
"borrowed reference to the exception type object when an exception has "
"occurred, and ``NULL`` otherwise.  There are a number of functions to set "
"the exception state: :c:func:`PyErr_SetString` is the most common (though "
"not the most general) function to set the exception state, and "
":c:func:`PyErr_Clear` clears the exception state."
msgstr ""
"Винятковий стан підтримується в потоковому сховищі (це еквівалентно "
"використанню глобального сховища в непотоковій програмі). Потік може "
"перебувати в одному з двох станів: сталася виняток чи ні. Для перевірки "
"цього можна використати функцію :c:func:`PyErr_Occurred`: вона повертає "
"запозичене посилання на об’єкт типу винятку, коли виняток стався, і ``NULL``"
" в іншому випадку. Існує кілька функцій для встановлення виняткового стану: "
":c:func:`PyErr_SetString` є найпоширенішою (хоча і не найзагальнішою) "
"функцією для встановлення виняткового стану, а :c:func:`PyErr_Clear` очищає "
"виняток стан."

#: ../../c-api/intro.rst:617
msgid ""
"The full exception state consists of three objects (all of which can  be "
"``NULL``): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python result of "
"``sys.exc_info()``; however, they are not the same: the Python objects "
"represent the last exception being handled by a Python  :keyword:`try` ... "
":keyword:`except` statement, while the C level exception state only exists "
"while an exception is being passed on between C functions until it reaches "
"the Python bytecode interpreter's  main loop, which takes care of "
"transferring it to ``sys.exc_info()`` and friends."
msgstr ""
"Повний винятковий стан складається з трьох об’єктів (усі з яких можуть бути "
"``NULL``): типу винятку, відповідного значення винятку та зворотного "
"відстеження. Вони мають ті самі значення, що й результат Python для "
"``sys.exc_info()``; однак вони не однакові: об’єкти Python представляють "
"останній виняток, який обробляється оператором Python :keyword:`try` ... "
":keyword:`except`, тоді як винятковий стан рівня C існує лише під час "
"виключення передається між функціями C, доки він не досягне головного циклу "
"інтерпретатора байт-коду Python, який піклується про його передачу до "
"``sys.exc_info()`` та друзів."

#: ../../c-api/intro.rst:629
msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access"
" the exception state from Python code is to call the function "
":func:`sys.exc_info`, which returns the per-thread exception state for "
"Python code.  Also, the semantics of both ways to access the exception state"
" have changed so that a function which catches an exception will save and "
"restore its thread's exception state so as to preserve the exception state "
"of its caller.  This prevents common bugs in exception handling code caused "
"by an innocent-looking function overwriting the exception being handled; it "
"also reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr ""
"Зауважте, що, починаючи з Python 1.5, бажаним, потоково-безпечним способом "
"доступу до виняткового стану з коду Python є виклик функції "
":func:`sys.exc_info`, яка повертає винятковий стан для кожного потоку для "
"коду Python. Крім того, семантика обох способів доступу до виняткового стану"
" була змінена таким чином, що функція, яка перехоплює виняток, збереже та "
"відновить винятковий стан свого потоку, щоб зберегти винятковий стан свого "
"викликаючого. Це запобігає поширеним помилкам у коді обробки виключень, "
"спричинених невинною функцією, яка перезаписує виняток, що обробляється; це "
"також зменшує часто небажане подовження тривалості життя для об’єктів, на "
"які посилаються фрейми стека в трасуванні."

#: ../../c-api/intro.rst:640
msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and"
" if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr ""
"Як загальний принцип, функція, яка викликає іншу функцію для виконання "
"певного завдання, повинна перевіряти, чи викликана функція викликала "
"виняток, і якщо так, передати стан винятку її викликаючому. Він має "
"відкидати будь-які посилання на об’єкти, якими він володіє, і повертати "
"індикатор помилки, але *не* встановлювати інший виняток --- який би "
"перезаписував щойно викликаний виняток і втрачав важливу інформацію про "
"точну причину помилки."

#: ../../c-api/intro.rst:649
msgid ""
"A simple example of detecting exceptions and passing them on is shown in the"
" :c:func:`!sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The"
" following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr ""

#: ../../c-api/intro.rst:655
msgid ""
"def incr_item(dict, key):\n"
"    try:\n"
"        item = dict[key]\n"
"    except KeyError:\n"
"        item = 0\n"
"    dict[key] = item + 1"
msgstr ""

#: ../../c-api/intro.rst:664
msgid "Here is the corresponding C code, in all its glory::"
msgstr "Ось відповідний код C у всій його красі:"

#: ../../c-api/intro.rst:666
msgid ""
"int\n"
"incr_item(PyObject *dict, PyObject *key)\n"
"{\n"
"    /* Objects all initialized to NULL for Py_XDECREF */\n"
"    PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\n"
"    int rv = -1; /* Return value initialized to -1 (failure) */\n"
"\n"
"    item = PyObject_GetItem(dict, key);\n"
"    if (item == NULL) {\n"
"        /* Handle KeyError only: */\n"
"        if (!PyErr_ExceptionMatches(PyExc_KeyError))\n"
"            goto error;\n"
"\n"
"        /* Clear the error and use zero: */\n"
"        PyErr_Clear();\n"
"        item = PyLong_FromLong(0L);\n"
"        if (item == NULL)\n"
"            goto error;\n"
"    }\n"
"    const_one = PyLong_FromLong(1L);\n"
"    if (const_one == NULL)\n"
"        goto error;\n"
"\n"
"    incremented_item = PyNumber_Add(item, const_one);\n"
"    if (incremented_item == NULL)\n"
"        goto error;\n"
"\n"
"    if (PyObject_SetItem(dict, key, incremented_item) < 0)\n"
"        goto error;\n"
"    rv = 0; /* Success */\n"
"    /* Continue with cleanup code */\n"
"\n"
" error:\n"
"    /* Cleanup code, shared by success and failure path */\n"
"\n"
"    /* Use Py_XDECREF() to ignore NULL references */\n"
"    Py_XDECREF(item);\n"
"    Py_XDECREF(const_one);\n"
"    Py_XDECREF(incremented_item);\n"
"\n"
"    return rv; /* -1 for error, 0 for success */\n"
"}"
msgstr ""

#: ../../c-api/intro.rst:716
msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and "
":c:func:`PyErr_Clear` to handle specific exceptions, and the use of "
":c:func:`Py_XDECREF` to dispose of owned references that may be ``NULL`` "
"(note the ``'X'`` in the name; :c:func:`Py_DECREF` would crash when "
"confronted with a ``NULL`` reference).  It is important that the variables "
"used to hold owned references are initialized to ``NULL`` for this to work; "
"likewise, the proposed return value is initialized to ``-1`` (failure) and "
"only set to success after the final call made is successful."
msgstr ""
"Цей приклад представляє схвалене використання оператора ``goto`` у C! Він "
"ілюструє використання :c:func:`PyErr_ExceptionMatches` і "
":c:func:`PyErr_Clear` для обробки конкретних винятків, а також використання "
":c:func:`Py_XDECREF` для утилізації власних посилань, які можуть бути "
"``NULL`` (зверніть увагу на ``'X'`` в назві; :c:func:`Py_DECREF` аварійно "
"завершував би роботу, якщо зіткнутися з посиланням ``NULL``). Щоб це "
"працювало, важливо, щоб змінні, які використовуються для зберігання належних"
" посилань, були ініціалізовані як ``NULL``; аналогічно запропоноване "
"значення, що повертається, ініціалізується як ``-1`` (помилка) і "
"встановлюється як успішне лише після успішного останнього виклику."

#: ../../c-api/intro.rst:730
msgid "Embedding Python"
msgstr "Вбудовування Python"

#: ../../c-api/intro.rst:732
msgid ""
"The one important task that only embedders (as opposed to extension writers)"
" of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of"
" the interpreter can only be used after the interpreter has been "
"initialized."
msgstr ""
"Єдине важливе завдання, про яке мають турбуватися лише вбудовувачі (на "
"відміну від авторів розширень) інтерпретатора Python, це ініціалізація та, "
"можливо, фіналізація інтерпретатора Python. Більшість функцій інтерпретатора"
" можна використовувати лише після ініціалізації інтерпретатора."

#: ../../c-api/intro.rst:745
msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental modules"
" :mod:`builtins`, :mod:`__main__`, and :mod:`sys`.  It also initializes the "
"module search path (``sys.path``)."
msgstr ""
"Основною функцією ініціалізації є :c:func:`Py_Initialize`. Це ініціалізує "
"таблицю завантажених модулів і створює фундаментальні модулі "
":mod:`builtins`, :mod:`__main__` і :mod:`sys`. Він також ініціалізує шлях "
"пошуку модуля (``sys.path``)."

#: ../../c-api/intro.rst:750
msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  "
"(``sys.argv``). If this variable is needed by Python code that will be "
"executed later, setting :c:member:`PyConfig.argv` and "
":c:member:`PyConfig.parse_argv` must be set: see :ref:`Python Initialization"
" Configuration <init-config>`."
msgstr ""

#: ../../c-api/intro.rst:755
msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"У більшості систем (зокрема, в Unix і Windows, хоча деталі дещо "
"відрізняються), :c:func:`Py_Initialize` обчислює шлях пошуку модуля на "
"основі свого найкращого припущення щодо розташування стандартного "
"виконуваного файлу інтерпретатора Python, припускаючи, що бібліотека Python "
"знаходиться у фіксованому місці відносно виконуваного файлу інтерпретатора "
"Python. Зокрема, він шукає каталог під назвою :file:`lib/python{X.Y}` "
"відносно батьківського каталогу, де виконуваний файл під назвою "
":file:`python` знайдено на шляху пошуку команд оболонки (змінна середовища "
":envvar:`PATH`)."

#: ../../c-api/intro.rst:764
msgid ""
"For instance, if the Python executable is found in "
":file:`/usr/local/bin/python`, it will assume that the libraries are in "
":file:`/usr/local/lib/python{X.Y}`.  (In fact, this particular path is also "
"the \"fallback\" location, used when no executable file named :file:`python`"
" is found along :envvar:`PATH`.)  The user can override this behavior by "
"setting the environment variable :envvar:`PYTHONHOME`, or insert additional "
"directories in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"Наприклад, якщо виконуваний файл Python знайдено в "
":file:`/usr/local/bin/python`, буде вважатися, що бібліотеки знаходяться в "
":file:`/usr/local/lib/python{X.Y}`. (Насправді цей конкретний шлях також є "
"\"резервним\" розташуванням, яке використовується, коли вздовж "
":envvar:`PATH` не знайдено виконуваного файлу з назвою :file:`python`.) "
"Користувач може змінити цю поведінку, встановивши змінну середовища "
":envvar:`PYTHONHOME`, або вставте додаткові каталоги перед стандартним "
"шляхом, встановивши :envvar:`PYTHONPATH`."

#: ../../c-api/intro.rst:778
msgid ""
"The embedding application can steer the search by setting "
":c:member:`PyConfig.program_name` *before* calling "
":c:func:`Py_InitializeFromConfig`. Note that :envvar:`PYTHONHOME` still "
"overrides this and :envvar:`PYTHONPATH` is still inserted in front of the "
"standard path.  An application that requires total control has to provide "
"its own implementation of :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, "
":c:func:`Py_GetExecPrefix`, and :c:func:`Py_GetProgramFullPath` (all defined"
" in :file:`Modules/getpath.c`)."
msgstr ""

#: ../../c-api/intro.rst:789
msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to "
":c:func:`Py_Initialize`) or the application is simply done with its  use of "
"Python and wants to free memory allocated by Python.  This can be "
"accomplished by calling :c:func:`Py_FinalizeEx`.  The function "
":c:func:`Py_IsInitialized` returns true if Python is currently in the "
"initialized state.  More information about these functions is given in a "
"later chapter. Notice that :c:func:`Py_FinalizeEx` does *not* free all "
"memory allocated by the Python interpreter, e.g. memory allocated by "
"extension modules currently cannot be released."
msgstr ""
"Іноді бажано \"деініціалізувати\" Python. Наприклад, програма може захотіти "
"почати спочатку (здійснити ще один виклик :c:func:`Py_Initialize`) або "
"програма просто завершила роботу з Python і хоче звільнити пам’ять, виділену"
" Python. Це можна зробити, викликавши :c:func:`Py_FinalizeEx`. Функція "
":c:func:`Py_IsInitialized` повертає істину, якщо Python зараз перебуває в "
"ініціалізованому стані. Більше інформації про ці функції наведено в "
"наступному розділі. Зауважте, що :c:func:`Py_FinalizeEx` *не* звільняє всю "
"пам’ять, виділену інтерпретатором Python, напр. Пам'ять, виділена модулями "
"розширення, наразі не може бути звільнена."

#: ../../c-api/intro.rst:803
msgid "Debugging Builds"
msgstr "Налагодження збірок"

#: ../../c-api/intro.rst:805
msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr ""
"Python можна створити з кількома макросами, щоб увімкнути додаткові "
"перевірки інтерпретатора та модулів розширення. Ці перевірки, як правило, "
"додають велику кількість накладних витрат до середовища виконання, тому їх "
"не ввімкнено за замовчуванням."

#: ../../c-api/intro.rst:809
msgid ""
"A full list of the various types of debugging builds is in the file "
":file:`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are"
" available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently used builds will be described in the remainder of this "
"section."
msgstr ""

#: ../../c-api/intro.rst:817
msgid ""
"Compiling the interpreter with the :c:macro:`!Py_DEBUG` macro defined "
"produces what is generally meant by :ref:`a debug build of Python <debug-"
"build>`. :c:macro:`!Py_DEBUG` is enabled in the Unix build by adding "
":option:`--with-pydebug` to the :file:`./configure` command. It is also "
"implied by the presence of the not-Python-specific :c:macro:`!_DEBUG` macro."
"  When :c:macro:`!Py_DEBUG` is enabled in the Unix build, compiler "
"optimization is disabled."
msgstr ""

#: ../../c-api/intro.rst:825
msgid ""
"In addition to the reference count debugging described below, extra checks "
"are performed, see :ref:`Python Debug Build <debug-build>`."
msgstr ""
"На додаток до налагодження кількості посилань, описаного нижче, виконуються "
"додаткові перевірки, див. :ref:`Python Debug Build <debug-build>`."

#: ../../c-api/intro.rst:828
msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing (see the "
":option:`configure --with-trace-refs option <--with-trace-refs>`). When "
"defined, a circular doubly linked list of active objects is maintained by "
"adding two extra fields to every :c:type:`PyObject`.  Total allocations are "
"tracked as well.  Upon exit, all existing references are printed.  (In "
"interactive mode this happens after every statement run by the interpreter.)"
msgstr ""
"Визначення :c:macro:`Py_TRACE_REFS` увімкне трасування посилань (див. опцію "
":option:`configure --with-trace-refs <--with-trace-refs>`). Коли визначено, "
"круговий подвійний зв’язаний список активних об’єктів підтримується шляхом "
"додавання двох додаткових полів до кожного :c:type:`PyObject`. Також "
"відстежуються загальні асигнування. Після виходу друкуються всі наявні "
"посилання. (В інтерактивному режимі це відбувається після кожного оператора,"
" виконаного інтерпретатором.)"

#: ../../c-api/intro.rst:835
msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr ""
"Будь ласка, зверніться до :file:`Misc/SpecialBuilds.txt` у дистрибутиві "
"вихідних кодів Python для отримання більш детальної інформації."

#: ../../c-api/intro.rst:288
msgid "object"
msgstr "об'єкт"

#: ../../c-api/intro.rst:288
msgid "type"
msgstr "тип"

#: ../../c-api/intro.rst:327
msgid "Py_INCREF (C function)"
msgstr ""

#: ../../c-api/intro.rst:327
msgid "Py_DECREF (C function)"
msgstr ""

#: ../../c-api/intro.rst:403
msgid "PyList_SetItem (C function)"
msgstr ""

#: ../../c-api/intro.rst:403
msgid "PyTuple_SetItem (C function)"
msgstr ""

#: ../../c-api/intro.rst:474
msgid "set_all()"
msgstr ""

#: ../../c-api/intro.rst:493
msgid "PyList_GetItem (C function)"
msgstr ""

#: ../../c-api/intro.rst:493
msgid "PySequence_GetItem (C function)"
msgstr ""

#: ../../c-api/intro.rst:523
msgid "sum_list()"
msgstr ""

#: ../../c-api/intro.rst:555 ../../c-api/intro.rst:647
msgid "sum_sequence()"
msgstr ""

#: ../../c-api/intro.rst:590
msgid "PyErr_Occurred (C function)"
msgstr ""

#: ../../c-api/intro.rst:603
msgid "PyErr_SetString (C function)"
msgstr ""

#: ../../c-api/intro.rst:603 ../../c-api/intro.rst:711
msgid "PyErr_Clear (C function)"
msgstr ""

#: ../../c-api/intro.rst:627
msgid "exc_info (in module sys)"
msgstr ""

#: ../../c-api/intro.rst:662 ../../c-api/intro.rst:709
msgid "incr_item()"
msgstr ""

#: ../../c-api/intro.rst:711
msgid "PyErr_ExceptionMatches (C function)"
msgstr ""

#: ../../c-api/intro.rst:711
msgid "Py_XDECREF (C function)"
msgstr ""

#: ../../c-api/intro.rst:737
msgid "Py_Initialize (C function)"
msgstr ""

#: ../../c-api/intro.rst:737
msgid "module"
msgstr "модуль"

#: ../../c-api/intro.rst:737
msgid "builtins"
msgstr "вбудовані елементи"

#: ../../c-api/intro.rst:737
msgid "__main__"
msgstr ""

#: ../../c-api/intro.rst:737
msgid "sys"
msgstr "система"

#: ../../c-api/intro.rst:737
msgid "search"
msgstr ""

#: ../../c-api/intro.rst:737
msgid "path"
msgstr ""

#: ../../c-api/intro.rst:737
msgid "path (in module sys)"
msgstr ""

#: ../../c-api/intro.rst:772
msgid "Py_GetPath (C function)"
msgstr ""

#: ../../c-api/intro.rst:772
msgid "Py_GetPrefix (C function)"
msgstr ""

#: ../../c-api/intro.rst:772
msgid "Py_GetExecPrefix (C function)"
msgstr ""

#: ../../c-api/intro.rst:772
msgid "Py_GetProgramFullPath (C function)"
msgstr ""

#: ../../c-api/intro.rst:787
msgid "Py_IsInitialized (C function)"
msgstr ""
