# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers "
"access to the Python interpreter at a variety of levels.  The API is equally "
"usable from C++, but for brevity it is generally referred to as the Python/C "
"API.  There are two fundamentally different reasons for using the Python/C "
"API. The first reason is to write *extension modules* for specific purposes; "
"these are C modules that extend the Python interpreter.  This is probably "
"the most common use.  The second reason is to use Python as a component in a "
"larger application; this technique is generally referred to as :dfn:"
"`embedding` Python in an application."
msgstr ""
"Інтерфейс прикладного програміста для Python надає програмістам C і C++ "
"доступ до інтерпретатора Python на різних рівнях. API так само можна "
"використовувати з C++, але для стислості його зазвичай називають Python/C "
"API. Є дві принципово різні причини використання Python/C API. Перша причина "
"полягає в написанні *модулів розширення* для певних цілей; це модулі C, які "
"розширюють інтерпретатор Python. Мабуть, це найпоширеніше використання. "
"Друга причина полягає в тому, щоб використовувати Python як компонент у "
"більшій програмі; цей прийом зазвичай називають :dfn:`embedding` Python у "
"програму."

msgid ""
"Writing an extension module is a relatively well-understood process, where a "
"\"cookbook\" approach works well.  There are several tools that automate the "
"process to some extent.  While people have embedded Python in other "
"applications since its early existence, the process of embedding Python is "
"less straightforward than writing an extension."
msgstr ""
"Написання модуля розширення є відносно добре зрозумілим процесом, де добре "
"працює підхід \"кулінарної книги\". Є кілька інструментів, які певною мірою "
"автоматизують процес. Хоча люди вбудовували Python в інші програми з самого "
"початку його існування, процес вбудовування Python менш простий, ніж "
"написання розширення."

msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python "
"in a real application."
msgstr ""
"Багато функцій API корисні незалежно від того, чи ви вбудовуєте чи "
"розширюєте Python; крім того, більшість програм, які вбудовують Python, "
"потребуватимуть також надати спеціальне розширення, тому, мабуть, доцільно "
"ознайомитися з написанням розширення перед тим, як намагатися вставити "
"Python у реальну програму."

msgid "Coding standards"
msgstr "Стандарти кодування"

msgid ""
"If you're writing C code for inclusion in CPython, you **must** follow the "
"guidelines and standards defined in :PEP:`7`.  These guidelines apply "
"regardless of the version of Python you are contributing to.  Following "
"these conventions is not necessary for your own third party extension "
"modules, unless you eventually expect to contribute them to Python."
msgstr ""
"Якщо ви пишете код C для включення в CPython, ви **повинні** дотримуватися "
"вказівок і стандартів, визначених у :PEP:`7`. Ці вказівки застосовуються "
"незалежно від версії Python, до якої ви робите внесок. Дотримання цих умов "
"не є обов’язковим для ваших власних модулів розширення сторонніх "
"розробників, якщо тільки ви не плануєте додати їх до Python."

msgid "Include Files"
msgstr "Включати файли"

msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr ""
"Усі визначення функцій, типів і макросів, необхідні для використання API "
"Python/C, включено у ваш код у такий рядок::"

msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and ``<stdlib."
"h>`` (if available)."
msgstr ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and ``<stdlib."
"h>`` (if available)."

msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"Оскільки Python може визначати деякі визначення попереднього процесора, які "
"впливають на стандартні заголовки в деяких системах, ви *мусите* включити :"
"file:`Python.h` перед тим, як включити будь-які стандартні заголовки."

msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`arg-parsing` for a description of this macro."
msgstr ""
"Рекомендується завжди визначати ``PY_SSIZE_T_CLEAN`` перед включенням "
"``Python.h``. Перегляньте :ref:`arg-parsing` для опису цього макросу."

msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member "
"names do not have a reserved prefix."
msgstr ""
"Усі видимі для користувача імена, визначені Python.h (крім тих, що визначені "
"включеними стандартними заголовками), мають один із префіксів ``Py`` або "
"``_Py``. Імена, що починаються з ``_Py`` призначені для внутрішнього "
"використання реалізацією Python і не повинні використовуватися розробниками "
"розширень. Імена членів структури не мають зарезервованого префікса."

msgid ""
"User code should never define names that begin with ``Py`` or ``_Py``. This "
"confuses the reader, and jeopardizes the portability of the user code to "
"future Python versions, which may define additional names beginning with one "
"of these prefixes."
msgstr ""
"Код користувача ніколи не повинен визначати імена, які починаються з ``Py`` "
"або ``_Py``. Це заплутує читача та ставить під загрозу перенесення коду "
"користувача на майбутні версії Python, які можуть визначати додаткові імена, "
"що починаються з одного з цих префіксів."

msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and :file:"
"`{exec_prefix}/include/pythonversion/`, where :envvar:`prefix` and :envvar:"
"`exec_prefix` are defined by the corresponding parameters to Python's :"
"program:`configure` script and *version* is ``'%d.%d' % sys."
"version_info[:2]``.  On Windows, the headers are installed in :file:"
"`{prefix}/include`, where :envvar:`prefix` is the installation directory "
"specified to the installer."
msgstr ""
"Файли заголовків зазвичай встановлюються за допомогою Python. В Unix вони "
"розташовані в каталогах :file:`{prefix}/include/pythonversion/` і :file:"
"`{exec_prefix}/include/pythonversion/`, де :envvar:`prefix` і :envvar:"
"`exec_prefix` визначаються відповідними параметрами сценарію :program:"
"`configure` Python, а *версією* є ``'%d.%d' % sys.version_info[:2]``. У "
"Windows заголовки встановлюються в :file:`{prefix}/include`, де :envvar:"
"`prefix` — це каталог встановлення, указаний інсталятором."

msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will "
"break on multi-platform builds since the platform independent headers under :"
"envvar:`prefix` include the platform specific headers from :envvar:"
"`exec_prefix`."
msgstr ""
"Щоб включити заголовки, розмістіть обидва каталоги (якщо різні) на шляху "
"пошуку вашого компілятора для включення. *Не* розміщуйте батьківські "
"каталоги на шляху пошуку, а потім використовуйте ``#include <pythonX.Y/"
"Python.h>``; це порушиться на мультиплатформенних збірках, оскільки "
"незалежні від платформи заголовки в :envvar:`prefix` включають специфічні "
"заголовки платформи з :envvar:`exec_prefix`."

msgid ""
"C++ users should note that although the API is defined entirely using C, the "
"header files properly declare the entry points to be ``extern \"C\"``. As a "
"result, there is no need to do anything special to use the API from C++."
msgstr ""
"Користувачі C++ повинні мати на увазі, що хоча API повністю визначено за "
"допомогою C, файли заголовків належним чином оголошують точки входу як "
"``extern \"C\"``. Як наслідок, немає потреби робити щось особливе для "
"використання API із C++."

msgid "Useful macros"
msgstr "Корисні макроси"

msgid ""
"Several useful macros are defined in the Python header files.  Many are "
"defined closer to where they are useful (e.g. :c:macro:`Py_RETURN_NONE`). "
"Others of a more general utility are defined here.  This is not necessarily "
"a complete listing."
msgstr ""
"У файлах заголовків Python визначено кілька корисних макросів. Багато "
"визначено ближче до того, де вони корисні (наприклад, :c:macro:"
"`Py_RETURN_NONE`). Тут визначено інші більш загальні корисності. Це не "
"обов’язково повний список."

msgid ""
"Use this when you have a code path that cannot be reached by design. For "
"example, in the ``default:`` clause in a ``switch`` statement for which all "
"possible values are covered in ``case`` statements.  Use this in places "
"where you might be tempted to put an ``assert(0)`` or ``abort()`` call."
msgstr ""
"Використовуйте це, якщо у вас є шлях коду, який неможливий за проектом. "
"Наприклад, у реченні ``default:`` в операторі ``switch``, для якого всі "
"можливі значення охоплюються в операторах ``case``. Використовуйте це в "
"місцях, де у вас може виникнути спокуса викликати ``assert(0)`` або "
"``abort()``."

msgid ""
"In release mode, the macro helps the compiler to optimize the code, and "
"avoids a warning about unreachable code.  For example, the macro is "
"implemented with ``__builtin_unreachable()`` on GCC in release mode."
msgstr ""
"У режимі випуску макрос допомагає компілятору оптимізувати код і уникає "
"попередження про недоступність коду. Наприклад, макрос реалізовано за "
"допомогою ``__builtin_unreachable()`` на GCC у режимі випуску."

msgid ""
"A use for ``Py_UNREACHABLE()`` is following a call a function that never "
"returns but that is not declared :c:macro:`_Py_NO_RETURN`."
msgstr ""
"Використання ``Py_UNREACHABLE()`` — це виклик функції, яка ніколи не "
"повертається, але не оголошена :c:macro:`_Py_NO_RETURN`."

msgid ""
"If a code path is very unlikely code but can be reached under exceptional "
"case, this macro must not be used.  For example, under low memory condition "
"or if a system call returns a value out of the expected range.  In this "
"case, it's better to report the error to the caller.  If the error cannot be "
"reported to caller, :c:func:`Py_FatalError` can be used."
msgstr ""
"Якщо кодовий шлях є дуже малоймовірним кодом, але його можна досягти у "
"виняткових випадках, цей макрос не можна використовувати. Наприклад, у разі "
"недостатнього обсягу пам’яті або якщо системний виклик повертає значення за "
"межами очікуваного діапазону. У цьому випадку краще повідомити про помилку "
"абонента. Якщо про помилку неможливо повідомити абоненту, можна використати :"
"c:func:`Py_FatalError`."

msgid "Return the absolute value of ``x``."
msgstr "Повертає абсолютне значення ``x``."

msgid "Return the minimum value between ``x`` and ``y``."
msgstr "Повертає мінімальне значення між ``x`` і ``y``."

msgid "Return the maximum value between ``x`` and ``y``."
msgstr "Повертає максимальне значення між ``x`` і ``y``."

msgid ""
"Convert ``x`` to a C string.  E.g. ``Py_STRINGIFY(123)`` returns ``\"123\"``."
msgstr ""
"Перетворіть ``x`` на рядок C. наприклад ``Py_STRINGIFY(123)`` повертає "
"``\"123\"``."

msgid "Return the size of a structure (``type``) ``member`` in bytes."
msgstr "Повертає розмір члена структури (``type``) у байтах."

msgid ""
"Argument must be a character or an integer in the range [-128, 127] or [0, "
"255].  This macro returns ``c`` cast to an ``unsigned char``."
msgstr ""
"Аргумент має бути символом або цілим числом у діапазоні [-128, 127] або [0, "
"255]. Цей макрос повертає ``c``, приведений до ``unsigned char``."

msgid ""
"Like ``getenv(s)``, but returns ``NULL`` if :option:`-E` was passed on the "
"command line (i.e. if ``Py_IgnoreEnvironmentFlag`` is set)."
msgstr ""
"Подібно до ``getenv(s)``, але повертає ``NULL``, якщо :option:`-E` було "
"передано в командному рядку (тобто якщо ``Py_IgnoreEnvironmentFlag`` "
"встановлено)."

msgid ""
"Use this for unused arguments in a function definition to silence compiler "
"warnings. Example: ``int func(int a, int Py_UNUSED(b)) { return a; }``."
msgstr ""
"Використовуйте це для невикористаних аргументів у визначенні функції, щоб "
"заглушити попередження компілятора. Приклад: ``int func(int a, int "
"Py_UNUSED(b)) { return a; }``."

msgid ""
"Use this for deprecated declarations.  The macro must be placed before the "
"symbol name."
msgstr ""
"Використовуйте це для застарілих декларацій. Макрос необхідно розмістити "
"перед назвою символу."

msgid "Example::"
msgstr "Приклад::"

msgid "MSVC support was added."
msgstr "Додано підтримку MSVC."

msgid ""
"Creates a variable with name ``name`` that can be used in docstrings. If "
"Python is built without docstrings, the value will be empty."
msgstr ""
"Створює змінну з назвою ``name``, яку можна використовувати в рядках "
"документів. Якщо Python створено без рядків документації, значення буде "
"порожнім."

msgid ""
"Use :c:macro:`PyDoc_STRVAR` for docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Використовуйте :c:macro:`PyDoc_STRVAR` для рядків документів, щоб "
"підтримувати створення Python без рядків документів, як зазначено в :pep:`7`."

msgid ""
"Creates a docstring for the given input string or an empty string if "
"docstrings are disabled."
msgstr ""
"Створює рядок документації для заданого рядка введення або порожній рядок, "
"якщо рядки документації вимкнено."

msgid ""
"Use :c:macro:`PyDoc_STR` in specifying docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Використовуйте :c:macro:`PyDoc_STR` у визначенні рядків документів, щоб "
"підтримувати створення Python без рядків документів, як зазначено в :pep:`7`."

msgid "Objects, Types and Reference Counts"
msgstr "Об’єкти, типи та кількість посилань"

msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:type:`PyObject*`.  This type is a pointer to an opaque data "
"type representing an arbitrary Python object.  Since all Python object types "
"are treated the same way by the Python language in most situations (e.g., "
"assignments, scope rules, and argument passing), it is only fitting that "
"they should be represented by a single C type.  Almost all Python objects "
"live on the heap: you never declare an automatic or static variable of type :"
"c:type:`PyObject`, only pointer variables of type :c:type:`PyObject*` can  "
"be declared.  The sole exception are the type objects; since these must "
"never be deallocated, they are typically static :c:type:`PyTypeObject` "
"objects."
msgstr ""
"Більшість функцій API Python/C мають один або кілька аргументів, а також "
"повертається значення типу :c:type:`PyObject*`. Цей тип є вказівником на "
"непрозорий тип даних, що представляє довільний об’єкт Python. Оскільки всі "
"типи об’єктів Python обробляються мовою Python однаково в більшості ситуацій "
"(наприклад, призначення, правила області та передача аргументів), цілком "
"доречно, щоб вони були представлені одним типом C. Майже всі об’єкти Python "
"живуть у купі: ви ніколи не оголошуєте автоматичну чи статичну змінну типу :"
"c:type:`PyObject`, можна оголошувати лише змінні-вказівники типу :c:type:"
"`PyObject*`. Єдиним винятком є об'єкти типу; оскільки їх ніколи не можна "
"звільняти, зазвичай це статичні об’єкти :c:type:`PyTypeObject`."

msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a :dfn:"
"`reference count`.  An object's type determines what kind of object it is (e."
"g., an integer, a list, or a user-defined function; there are many more as "
"explained in :ref:`types`).  For each of the well-known types there is a "
"macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is "
"a Python list."
msgstr ""
"Усі об’єкти Python (навіть цілі числа Python) мають :dfn:`type` і :dfn:"
"`reference counting`. Тип об’єкта визначає тип об’єкта (наприклад, ціле "
"число, список або визначена користувачем функція; їх багато інших, як "
"пояснюється в :ref:`types`). Для кожного з добре відомих типів існує макрос, "
"щоб перевірити, чи належить об’єкт до цього типу; наприклад, "
"``PyList_Check(a)`` є істинним, якщо (і тільки якщо) об’єкт, на який вказує "
"*a*, є списком Python."

msgid "Reference Counts"
msgstr "Довідкова кількість"

msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many  different "
"places there are that have a reference to an object.  Such a  place could be "
"another object, or a global (or static) C variable, or  a local variable in "
"some C function. When an object's reference count  becomes zero, the object "
"is deallocated.  If it contains references to  other objects, their "
"reference count is decremented. Those other  objects may be deallocated in "
"turn, if this decrement makes their reference count become zero, and so on.  "
"(There's an obvious problem  with objects that reference each other here; "
"for now, the solution is  \"don't do that.\")"
msgstr ""
"Кількість посилань є важливою, оскільки сучасні комп’ютери мають кінцевий (і "
"часто дуже обмежений) розмір пам’яті; він підраховує, скільки існує різних "
"місць, які мають посилання на об’єкт. Таким місцем може бути інший об’єкт, "
"або глобальна (або статична) змінна C, або локальна змінна в деякій функції "
"C. Коли кількість посилань об’єкта стає нульовою, об’єкт звільняється. Якщо "
"він містить посилання на інші об’єкти, їх кількість посилань зменшується. Ці "
"інші об’єкти можуть бути звільнені по черзі, якщо це зменшення призведе до "
"того, що їх число посилань стане нульовим і так далі. (Тут є очевидна "
"проблема з об’єктами, які посилаються один на одного; поки що рішенням є "
"\"не робіть цього\".)"

msgid ""
"Reference counts are always manipulated explicitly.  The normal way is  to "
"use the macro :c:func:`Py_INCREF` to increment an object's reference count "
"by one, and :c:func:`Py_DECREF` to decrement it by   one.  The :c:func:"
"`Py_DECREF` macro is considerably more complex than the incref one, since it "
"must check whether the reference count becomes zero and then cause the "
"object's deallocator to be called. The deallocator is a function pointer "
"contained in the object's type structure.  The type-specific deallocator "
"takes care of decrementing the reference counts for other objects contained "
"in the object if this is a compound object type, such as a list, as well as "
"performing any additional finalization that's needed.  There's no chance "
"that the reference count can overflow; at least as many bits are used to "
"hold the reference count as there are distinct memory locations in virtual "
"memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the "
"reference count increment is a simple operation."
msgstr ""
"Кількість посилань завжди маніпулюється явно. Звичайним способом є "
"використання макросу :c:func:`Py_INCREF`, щоб збільшити кількість посилань "
"на об’єкт на одиницю, і :c:func:`Py_DECREF`, щоб зменшити його на одиницю. "
"Макрос :c:func:`Py_DECREF` є значно складнішим, ніж макрос incref, оскільки "
"він має перевіряти, чи кількість посилань стає нульовою, а потім викликає "
"виклик засобу звільнення об’єкта. Deallocator — це покажчик на функцію, що "
"міститься в структурі типу об’єкта. Спеціальний для типу делокатор "
"піклується про зменшення лічильників посилань для інших об’єктів, що "
"містяться в об’єкті, якщо це складений тип об’єкта, наприклад список, а "
"також виконує будь-яку додаткову фіналізацію, яка потрібна. Немає шансів, що "
"кількість посилань може переповнитися; для підрахунку посилань "
"використовується принаймні стільки бітів, скільки є окремих ділянок пам’яті "
"у віртуальній пам’яті (за умови, що ``sizeof(Py_ssize_t) >= "
"sizeof(void*)``). Таким чином, збільшення кількості посилань є простою "
"операцією."

msgid ""
"It is not necessary to increment an object's reference count for every  "
"local variable that contains a pointer to an object.  In theory, the  "
"object's reference count goes up by one when the variable is made to  point "
"to it and it goes down by one when the variable goes out of  scope.  "
"However, these two cancel each other out, so at the end the  reference count "
"hasn't changed.  The only real reason to use the  reference count is to "
"prevent the object from being deallocated as  long as our variable is "
"pointing to it.  If we know that there is at  least one other reference to "
"the object that lives at least as long as our variable, there is no need to "
"increment the reference count  temporarily. An important situation where "
"this arises is in objects  that are passed as arguments to C functions in an "
"extension module  that are called from Python; the call mechanism guarantees "
"to hold a  reference to every argument for the duration of the call."
msgstr ""
"Немає необхідності збільшувати кількість посилань на об’єкт для кожної "
"локальної змінної, яка містить покажчик на об’єкт. Теоретично кількість "
"посилань на об’єкт збільшується на одиницю, коли змінна вказує на нього, і "
"зменшується на одиницю, коли змінна виходить за межі видимості. Однак ці два "
"скасовують один одного, тому в кінці кількість посилань не змінилася. Єдина "
"реальна причина використовувати підрахунок посилань — це запобігти "
"звільненню об’єкта, доки наша змінна вказує на нього. Якщо ми знаємо, що "
"існує принаймні ще одне посилання на об’єкт, яке живе принаймні стільки ж, "
"скільки наша змінна, немає потреби тимчасово збільшувати кількість посилань. "
"Важливою ситуацією, в якій це виникає, є об’єкти, які передаються як "
"аргументи функціям C у модулі розширення, які викликаються з Python; "
"механізм виклику гарантує збереження посилання на кожен аргумент протягом "
"тривалості виклику."

msgid ""
"However, a common pitfall is to extract an object from a list and hold on to "
"it for a while without incrementing its reference count. Some other "
"operation might conceivably remove the object from the list, decrementing "
"its reference count and possibly deallocating it. The real danger is that "
"innocent-looking operations may invoke arbitrary Python code which could do "
"this; there is a code path which allows control to flow back to the user "
"from a :c:func:`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""
"Однак поширеною підводним каменем є вилучення об’єкта зі списку та утримання "
"його деякий час, не збільшуючи його кількість посилань. Якась інша операція "
"може ймовірно видалити об’єкт зі списку, зменшивши кількість його посилань "
"і, можливо, звільнивши його розміщення. Реальна небезпека полягає в тому, що "
"невинні на вигляд операції можуть викликати довільний код Python, який міг "
"би це зробити; існує шлях до коду, який дозволяє повертати користувачеві "
"керування з :c:func:`Py_DECREF`, тому майже будь-яка операція є потенційно "
"небезпечною."

msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always increment the reference count of "
"the object they return. This leaves the caller with the responsibility to "
"call :c:func:`Py_DECREF` when they are done with the result; this soon "
"becomes second nature."
msgstr ""
"Безпечним підходом є завжди використовувати загальні операції (функції, "
"назва яких починається з ``PyObject_``, ``PyNumber_``, ``PySequence_`` або "
"``PyMapping_``). Ці операції завжди збільшують кількість посилань на об’єкт, "
"який вони повертають. Це залишає абонента відповідальним за виклик :c:func:"
"`Py_DECREF`, коли вони закінчили з результатом; незабаром це стає другою "
"натурою."

msgid "Reference Count Details"
msgstr "Деталі кількості посилань"

msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually decref'ing it by calling :"
"c:func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a :term:"
"`borrowed reference`."
msgstr ""
"Поведінку підрахунку посилань функцій у Python/C API найкраще пояснити з "
"точки зору *володіння посиланнями*. Право власності стосується посилань, а "
"не об’єктів (об’єкти не належать: вони завжди є спільними). \"Володіння "
"посиланням\" означає відповідальність за виклик Py_DECREF на ньому, коли "
"посилання більше не потрібне. Право власності також може бути передане, "
"тобто код, який отримує право власності на посилання, стає відповідальним за "
"остаточне його дешифрування шляхом виклику :c:func:`Py_DECREF` або :c:func:"
"`Py_XDECREF`, коли він більше не потрібен - --або передача цієї "
"відповідальності (зазвичай абоненту). Коли функція передає право власності "
"на посилання її викликаючому, той, хто викликає, отримує *нове* посилання. "
"Якщо право власності не передається, кажуть, що абонент *позичив* посилання. "
"Нічого не потрібно робити для :term:`borrowed reference`."

msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr ""
"І навпаки, коли функція, що викликає, передає посилання на об’єкт, є дві "
"можливості: функція *вкрадає* посилання на об’єкт або ні. *Крадіжка "
"посилання* означає, що коли ви передаєте посилання на функцію, ця функція "
"припускає, що вона тепер володіє цим посиланням, і ви більше не несете за це "
"відповідальності."

msgid ""
"Few functions steal references; the two notable exceptions are :c:func:"
"`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a reference to "
"the item (but not to the tuple or list into which the item is put!).  These "
"functions were designed to steal a reference because of a common idiom for "
"populating a tuple or list with newly created objects; for example, the code "
"to create the tuple ``(1, 2, \"three\")`` could look like this (forgetting "
"about error handling for the moment; a better way to code this is shown "
"below)::"
msgstr ""
"Кілька функцій викрадають посилання; двома помітними винятками є :c:func:"
"`PyList_SetItem` і :c:func:`PyTuple_SetItem`, які викрадають посилання на "
"елемент (але не на кортеж або список, до якого поміщено елемент!). Ці "
"функції були розроблені для викрадення посилання через загальну ідіому для "
"заповнення кортежу або списку новоствореними об’єктами; наприклад, код для "
"створення кортежу ``(1, 2, \"three\")`` може виглядати так (наразі забувши "
"про обробку помилок; кращий спосіб кодування цього показано нижче):"

msgid ""
"Here, :c:func:`PyLong_FromLong` returns a new reference which is immediately "
"stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object "
"although the reference to it will be stolen, use :c:func:`Py_INCREF` to grab "
"another reference before calling the reference-stealing function."
msgstr ""
"Тут :c:func:`PyLong_FromLong` повертає нове посилання, яке негайно викрадає :"
"c:func:`PyTuple_SetItem`. Якщо ви хочете продовжувати використовувати "
"об’єкт, хоча посилання на нього буде вкрадено, використовуйте :c:func:"
"`Py_INCREF`, щоб захопити інше посилання перед викликом функції викрадання "
"посилань."

msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to "
"do this since tuples are an immutable data type.  You should only use :c:"
"func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"До речі, :c:func:`PyTuple_SetItem` є *єдиним* способом встановлення "
"елементів кортежу; :c:func:`PySequence_SetItem` і :c:func:`PyObject_SetItem` "
"відмовляються робити це, оскільки кортежі є незмінним типом даних. Ви "
"повинні використовувати лише :c:func:`PyTuple_SetItem` для кортежів, які ви "
"створюєте самостійно."

msgid ""
"Equivalent code for populating a list can be written using :c:func:"
"`PyList_New` and :c:func:`PyList_SetItem`."
msgstr ""
"Еквівалентний код для заповнення списку можна написати за допомогою :c:func:"
"`PyList_New` і :c:func:`PyList_SetItem`."

msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, :c:func:"
"`Py_BuildValue`, that can create most common objects from C values, directed "
"by a :dfn:`format string`. For example, the above two blocks of code could "
"be replaced by the following (which also takes care of the error checking)::"
msgstr ""
"Однак на практиці ви рідко будете використовувати ці способи створення та "
"заповнення кортежу чи списку. Існує загальна функція, :c:func:"
"`Py_BuildValue`, яка може створювати найбільш поширені об’єкти зі значень C, "
"керованих :dfn:`format string`. Наприклад, наведені вище два блоки коду "
"можна замінити наступним (який також піклується про перевірку помилок):"

msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding reference counts is much saner, since you don't have to increment "
"a reference count so you can give a reference away (\"have it be stolen\").  "
"For example, this function sets all items of a list (actually, any mutable "
"sequence) to a given item::"
msgstr ""
"Набагато поширеніше використовувати :c:func:`PyObject_SetItem` і друзів з "
"елементами, посилання на які ви лише запозичуєте, наприклад аргументи, які "
"були передані функції, яку ви пишете. У такому випадку їхня поведінка щодо "
"кількості посилань є набагато розумнішою, оскільки вам не потрібно "
"збільшувати кількість посилань, щоб ви могли віддати посилання (\"нехай його "
"вкрадуть\"). Наприклад, ця функція встановлює всі елементи списку (фактично, "
"будь-яку змінну послідовність) у заданий елемент::"

msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference "
"to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` "
"and  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr ""
"Ситуація дещо інша для значень, що повертаються функцією. Хоча передача "
"посилання на більшість функцій не змінює вашу відповідальність за це "
"посилання, багато функцій, які повертають посилання на об’єкт, передають вам "
"право власності на посилання. Причина проста: у багатьох випадках повернутий "
"об’єкт створюється на льоту, і отримане вами посилання є єдиним посиланням "
"на об’єкт. Тому загальні функції, які повертають посилання на об’єкти, як-"
"от :c:func:`PyObject_GetItem` і :c:func:`PySequence_GetItem`, завжди "
"повертають нове посилання (викликач стає власником посилання)."

msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type "
"of the object passed as an argument to the function) *doesn't enter into it!"
"* Thus, if you  extract an item from a list using :c:func:`PyList_GetItem`, "
"you don't own the reference --- but if you obtain the same item from the "
"same list using :c:func:`PySequence_GetItem` (which happens to take exactly "
"the same arguments), you do own a reference to the returned object."
msgstr ""
"Важливо розуміти, що чи володієте ви посиланням, яке повертає функція, "
"залежить лише від того, яку функцію ви викликаєте --- *оперення* (тип "
"об’єкта, переданого як аргумент функції) *не входить до нього !* Таким "
"чином, якщо ви витягуєте елемент зі списку за допомогою :c:func:"
"`PyList_GetItem`, ви не володієте посиланням --- але якщо ви отримуєте той "
"самий елемент із того самого списку за допомогою :c:func:"
"`PySequence_GetItem` (який приймає точно ті самі аргументи), у вас є "
"посилання на повернутий об’єкт."

msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr ""
"Ось приклад того, як можна написати функцію, яка обчислює суму елементів у "
"списку цілих чисел; один раз за допомогою :c:func:`PyList_GetItem` і один "
"раз за допомогою :c:func:`PySequence_GetItem`. ::"

msgid "Types"
msgstr "Типи"

msgid ""
"There are few other data types that play a significant role in  the Python/C "
"API; most are simple C types such as :c:type:`int`,  :c:type:`long`, :c:type:"
"`double` and :c:type:`char*`.  A few structure types  are used to describe "
"static tables used to list the functions exported  by a module or the data "
"attributes of a new object type, and another is used to describe the value "
"of a complex number.  These will  be discussed together with the functions "
"that use them."
msgstr ""
"Є кілька інших типів даних, які відіграють значну роль в API Python/C; "
"більшість є простими типами C, такими як :c:type:`int`, :c:type:`long`, :c:"
"type:`double` і :c:type:`char*`. Кілька типів структури використовуються для "
"опису статичних таблиць, які використовуються для переліку функцій, "
"експортованих модулем, або атрибутів даних нового типу об’єкта, а інший "
"використовується для опису значення комплексного числа. Вони будуть "
"обговорюватися разом із функціями, які їх використовують."

msgid ""
"A signed integral type such that ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 doesn't define such a thing directly (size_t is an unsigned integral "
"type). See :pep:`353` for details. ``PY_SSIZE_T_MAX`` is the largest "
"positive value of type :c:type:`Py_ssize_t`."
msgstr ""
"Інтегральний тип зі знаком, такий що ``sizeof(Py_ssize_t) == "
"sizeof(size_t)``. C99 не визначає таку річ безпосередньо (size_t є "
"беззнаковим інтегральним типом). Подробиці див. :pep:`353`. "
"``PY_SSIZE_T_MAX`` є найбільшим додатним значенням типу :c:type:`Py_ssize_t`."

msgid "Exceptions"
msgstr "Винятки"

msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the top-"
"level interpreter, where they are reported to the  user accompanied by a "
"stack traceback."
msgstr ""
"Програміст на Python має мати справу лише з винятками, якщо потрібна "
"спеціальна обробка помилок; необроблені винятки автоматично поширюються до "
"абонента, потім до абонента, що викликає, і так далі, доки вони не досягнуть "
"інтерпретатора верхнього рівня, де про них повідомляється користувачеві в "
"супроводі стека."

msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim "
"is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either ``NULL`` or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error "
"indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr ""
"Однак для програмістів на C перевірка помилок завжди має бути явною. Усі "
"функції в Python/C API можуть викликати винятки, якщо в документації до "
"функції не вказано інше. Загалом, коли функція стикається з помилкою, вона "
"встановлює виняток, відкидає будь-які посилання на об’єкти, якими вона "
"володіє, і повертає індикатор помилки. Якщо не задокументовано інше, цей "
"індикатор має значення ``NULL`` або ``-1``, залежно від типу повернення "
"функції. Кілька функцій повертають логічний результат true/false, де false "
"вказує на помилку. Дуже небагато функцій не повертають явного індикатора "
"помилки або мають неоднозначне значення, що повертається, і вимагають явного "
"тестування помилок за допомогою :c:func:`PyErr_Occurred`. Ці винятки завжди "
"чітко задокументовані."

msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one "
"of two states: an exception has occurred, or not. The function :c:func:"
"`PyErr_Occurred` can be used to check for this: it returns a borrowed "
"reference to the exception type object when an exception has occurred, and "
"``NULL`` otherwise.  There are a number of functions to set the exception "
"state: :c:func:`PyErr_SetString` is the most common (though not the most "
"general) function to set the exception state, and :c:func:`PyErr_Clear` "
"clears the exception state."
msgstr ""
"Винятковий стан підтримується в потоковому сховищі (це еквівалентно "
"використанню глобального сховища в непотоковій програмі). Потік може "
"перебувати в одному з двох станів: сталася виняток чи ні. Для перевірки "
"цього можна використати функцію :c:func:`PyErr_Occurred`: вона повертає "
"запозичене посилання на об’єкт типу винятку, коли виняток стався, і ``NULL`` "
"в іншому випадку. Існує кілька функцій для встановлення виняткового стану: :"
"c:func:`PyErr_SetString` є найпоширенішою (хоча і не найзагальнішою) "
"функцією для встановлення виняткового стану, а :c:func:`PyErr_Clear` очищає "
"виняток стан."

msgid ""
"The full exception state consists of three objects (all of which can  be "
"``NULL``): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python result of ``sys."
"exc_info()``; however, they are not the same: the Python objects represent "
"the last exception being handled by a Python  :keyword:`try` ... :keyword:"
"`except` statement, while the C level exception state only exists while an "
"exception is being passed on between C functions until it reaches the Python "
"bytecode interpreter's  main loop, which takes care of transferring it to "
"``sys.exc_info()`` and friends."
msgstr ""
"Повний винятковий стан складається з трьох об’єктів (усі з яких можуть бути "
"``NULL``): типу винятку, відповідного значення винятку та зворотного "
"відстеження. Вони мають ті самі значення, що й результат Python для ``sys."
"exc_info()``; однак вони не однакові: об’єкти Python представляють останній "
"виняток, який обробляється оператором Python :keyword:`try` ... :keyword:"
"`except`, тоді як винятковий стан рівня C існує лише під час виключення "
"передається між функціями C, доки він не досягне головного циклу "
"інтерпретатора байт-коду Python, який піклується про його передачу до ``sys."
"exc_info()`` та друзів."

msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access "
"the exception state from Python code is to call the function :func:`sys."
"exc_info`, which returns the per-thread exception state for Python code.  "
"Also, the semantics of both ways to access the exception state have changed "
"so that a function which catches an exception will save and restore its "
"thread's exception state so as to preserve the exception state of its "
"caller.  This prevents common bugs in exception handling code caused by an "
"innocent-looking function overwriting the exception being handled; it also "
"reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr ""
"Зауважте, що, починаючи з Python 1.5, бажаним, потоково-безпечним способом "
"доступу до виняткового стану з коду Python є виклик функції :func:`sys."
"exc_info`, яка повертає винятковий стан для кожного потоку для коду Python. "
"Крім того, семантика обох способів доступу до виняткового стану була змінена "
"таким чином, що функція, яка перехоплює виняток, збереже та відновить "
"винятковий стан свого потоку, щоб зберегти винятковий стан свого "
"викликаючого. Це запобігає поширеним помилкам у коді обробки виключень, "
"спричинених невинною функцією, яка перезаписує виняток, що обробляється; це "
"також зменшує часто небажане подовження тривалості життя для об’єктів, на "
"які посилаються фрейми стека в трасуванні."

msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and "
"if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr ""
"Як загальний принцип, функція, яка викликає іншу функцію для виконання "
"певного завдання, повинна перевіряти, чи викликана функція викликала "
"виняток, і якщо так, передати стан винятку її викликаючому. Він має "
"відкидати будь-які посилання на об’єкти, якими він володіє, і повертати "
"індикатор помилки, але *не* встановлювати інший виняток --- який би "
"перезаписував щойно викликаний виняток і втрачав важливу інформацію про "
"точну причину помилки."

msgid ""
"A simple example of detecting exceptions and passing them on is shown in "
"the :c:func:`sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The "
"following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr ""
"Простий приклад виявлення винятків і їх передачі показано у прикладі :c:func:"
"`sum_sequence` вище. Так сталося, що цьому прикладу не потрібно очищати будь-"
"які належні посилання, коли він виявляє помилку. Наступний приклад функції "
"показує деяке очищення помилок. По-перше, щоб нагадати вам, чому вам "
"подобається Python, ми показуємо еквівалентний код Python:"

msgid "Here is the corresponding C code, in all its glory::"
msgstr "Ось відповідний код C у всій його красі:"

msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and :c:func:"
"`PyErr_Clear` to handle specific exceptions, and the use of :c:func:"
"`Py_XDECREF` to dispose of owned references that may be ``NULL`` (note the "
"``'X'`` in the name; :c:func:`Py_DECREF` would crash when confronted with a "
"``NULL`` reference).  It is important that the variables used to hold owned "
"references are initialized to ``NULL`` for this to work; likewise, the "
"proposed return value is initialized to ``-1`` (failure) and only set to "
"success after the final call made is successful."
msgstr ""
"Цей приклад представляє схвалене використання оператора ``goto`` у C! Він "
"ілюструє використання :c:func:`PyErr_ExceptionMatches` і :c:func:"
"`PyErr_Clear` для обробки конкретних винятків, а також використання :c:func:"
"`Py_XDECREF` для утилізації власних посилань, які можуть бути ``NULL`` "
"(зверніть увагу на ``'X'`` в назві; :c:func:`Py_DECREF` аварійно завершував "
"би роботу, якщо зіткнутися з посиланням ``NULL``). Щоб це працювало, "
"важливо, щоб змінні, які використовуються для зберігання належних посилань, "
"були ініціалізовані як ``NULL``; аналогічно запропоноване значення, що "
"повертається, ініціалізується як ``-1`` (помилка) і встановлюється як "
"успішне лише після успішного останнього виклику."

msgid "Embedding Python"
msgstr "Вбудовування Python"

msgid ""
"The one important task that only embedders (as opposed to extension writers) "
"of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of "
"the interpreter can only be used after the interpreter has been initialized."
msgstr ""
"Єдине важливе завдання, про яке мають турбуватися лише вбудовувачі (на "
"відміну від авторів розширень) інтерпретатора Python, це ініціалізація та, "
"можливо, фіналізація інтерпретатора Python. Більшість функцій інтерпретатора "
"можна використовувати лише після ініціалізації інтерпретатора."

msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental "
"modules :mod:`builtins`, :mod:`__main__`, and :mod:`sys`.  It also "
"initializes the module search path (``sys.path``)."
msgstr ""
"Основною функцією ініціалізації є :c:func:`Py_Initialize`. Це ініціалізує "
"таблицю завантажених модулів і створює фундаментальні модулі :mod:"
"`builtins`, :mod:`__main__` і :mod:`sys`. Він також ініціалізує шлях пошуку "
"модуля (``sys.path``)."

msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  (``sys."
"argv``). If this variable is needed by Python code that will be executed "
"later, it must be set explicitly with a call to  ``PySys_SetArgvEx(argc, "
"argv, updatepath)`` after the call to :c:func:`Py_Initialize`."
msgstr ""

msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"У більшості систем (зокрема, в Unix і Windows, хоча деталі дещо "
"відрізняються), :c:func:`Py_Initialize` обчислює шлях пошуку модуля на "
"основі свого найкращого припущення щодо розташування стандартного "
"виконуваного файлу інтерпретатора Python, припускаючи, що бібліотека Python "
"знаходиться у фіксованому місці відносно виконуваного файлу інтерпретатора "
"Python. Зокрема, він шукає каталог під назвою :file:`lib/python{X.Y}` "
"відносно батьківського каталогу, де виконуваний файл під назвою :file:"
"`python` знайдено на шляху пошуку команд оболонки (змінна середовища :envvar:"
"`PATH`)."

msgid ""
"For instance, if the Python executable is found in :file:`/usr/local/bin/"
"python`, it will assume that the libraries are in :file:`/usr/local/lib/"
"python{X.Y}`.  (In fact, this particular path is also the \"fallback\" "
"location, used when no executable file named :file:`python` is found along :"
"envvar:`PATH`.)  The user can override this behavior by setting the "
"environment variable :envvar:`PYTHONHOME`, or insert additional directories "
"in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"Наприклад, якщо виконуваний файл Python знайдено в :file:`/usr/local/bin/"
"python`, буде вважатися, що бібліотеки знаходяться в :file:`/usr/local/lib/"
"python{X.Y}`. (Насправді цей конкретний шлях також є \"резервним\" "
"розташуванням, яке використовується, коли вздовж :envvar:`PATH` не знайдено "
"виконуваного файлу з назвою :file:`python`.) Користувач може змінити цю "
"поведінку, встановивши змінну середовища :envvar:`PYTHONHOME`, або вставте "
"додаткові каталоги перед стандартним шляхом, встановивши :envvar:"
"`PYTHONPATH`."

msgid ""
"The embedding application can steer the search by calling "
"``Py_SetProgramName(file)`` *before* calling  :c:func:`Py_Initialize`.  Note "
"that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` is "
"still inserted in front of the standard path.  An application that requires "
"total control has to provide its own implementation of :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, and :c:"
"func:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr ""
"Програма для вбудовування може керувати пошуком, викликаючи "
"``Py_SetProgramName(file)`` *перед* викликом :c:func:`Py_Initialize`. "
"Зауважте, що :envvar:`PYTHONHOME` все ще перевизначає це, а :envvar:"
"`PYTHONPATH` все ще вставляється перед стандартним шляхом. Програма, яка "
"потребує повного контролю, має забезпечити власну реалізацію :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix` і :c:func:"
"`Py_GetProgramFullPath` ( все визначено в :file:`Modules/getpath.c`)."

msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to :c:func:"
"`Py_Initialize`) or the application is simply done with its  use of Python "
"and wants to free memory allocated by Python.  This can be accomplished by "
"calling :c:func:`Py_FinalizeEx`.  The function :c:func:`Py_IsInitialized` "
"returns true if Python is currently in the initialized state.  More "
"information about these functions is given in a later chapter. Notice that :"
"c:func:`Py_FinalizeEx` does *not* free all memory allocated by the Python "
"interpreter, e.g. memory allocated by extension modules currently cannot be "
"released."
msgstr ""
"Іноді бажано \"деініціалізувати\" Python. Наприклад, програма може захотіти "
"почати спочатку (здійснити ще один виклик :c:func:`Py_Initialize`) або "
"програма просто завершила роботу з Python і хоче звільнити пам’ять, виділену "
"Python. Це можна зробити, викликавши :c:func:`Py_FinalizeEx`. Функція :c:"
"func:`Py_IsInitialized` повертає істину, якщо Python зараз перебуває в "
"ініціалізованому стані. Більше інформації про ці функції наведено в "
"наступному розділі. Зауважте, що :c:func:`Py_FinalizeEx` *не* звільняє всю "
"пам’ять, виділену інтерпретатором Python, напр. Пам'ять, виділена модулями "
"розширення, наразі не може бути звільнена."

msgid "Debugging Builds"
msgstr "Налагодження збірок"

msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr ""
"Python можна створити з кількома макросами, щоб увімкнути додаткові "
"перевірки інтерпретатора та модулів розширення. Ці перевірки, як правило, "
"додають велику кількість накладних витрат до середовища виконання, тому їх "
"не ввімкнено за замовчуванням."

msgid ""
"A full list of the various types of debugging builds is in the file :file:"
"`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are "
"available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently-used builds will be described in the remainder of this "
"section."
msgstr ""
"Повний список різних типів збірок для налагодження міститься у файлі :file:"
"`Misc/SpecialBuilds.txt` у вихідному дистрибутиві Python. Доступні збірки, "
"які підтримують відстеження лічильників посилань, налагодження розподільника "
"пам’яті або низькорівневе профілювання основного циклу інтерпретатора. У "
"решті цього розділу буде описано лише найбільш часто використовувані збірки."

msgid ""
"Compiling the interpreter with the :c:macro:`Py_DEBUG` macro defined "
"produces what is generally meant by :ref:`a debug build of Python <debug-"
"build>`. :c:macro:`Py_DEBUG` is enabled in the Unix build by adding :option:"
"`--with-pydebug` to the :file:`./configure` command. It is also implied by "
"the presence of the not-Python-specific :c:macro:`_DEBUG` macro.  When :c:"
"macro:`Py_DEBUG` is enabled in the Unix build, compiler optimization is "
"disabled."
msgstr ""
"Компіляція інтерпретатора з визначеним макросом :c:macro:`Py_DEBUG` створює "
"те, що зазвичай мається на увазі під :ref:`збіркою налагодження Python "
"<debug-build>`. :c:macro:`Py_DEBUG` увімкнено в збірці Unix шляхом "
"додавання :option:`--with-pydebug` до команди :file:`./configure`. Це також "
"передбачається наявністю неспецифічного для Python макросу :c:macro:"
"`_DEBUG`. Коли :c:macro:`Py_DEBUG` увімкнено в збірці Unix, оптимізація "
"компілятора вимкнена."

msgid ""
"In addition to the reference count debugging described below, extra checks "
"are performed, see :ref:`Python Debug Build <debug-build>`."
msgstr ""
"На додаток до налагодження кількості посилань, описаного нижче, виконуються "
"додаткові перевірки, див. :ref:`Python Debug Build <debug-build>`."

msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing (see the :option:"
"`configure --with-trace-refs option <--with-trace-refs>`). When defined, a "
"circular doubly linked list of active objects is maintained by adding two "
"extra fields to every :c:type:`PyObject`.  Total allocations are tracked as "
"well.  Upon exit, all existing references are printed.  (In interactive mode "
"this happens after every statement run by the interpreter.)"
msgstr ""
"Визначення :c:macro:`Py_TRACE_REFS` увімкне трасування посилань (див. опцію :"
"option:`configure --with-trace-refs <--with-trace-refs>`). Коли визначено, "
"круговий подвійний зв’язаний список активних об’єктів підтримується шляхом "
"додавання двох додаткових полів до кожного :c:type:`PyObject`. Також "
"відстежуються загальні асигнування. Після виходу друкуються всі наявні "
"посилання. (В інтерактивному режимі це відбувається після кожного оператора, "
"виконаного інтерпретатором.)"

msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr ""
"Будь ласка, зверніться до :file:`Misc/SpecialBuilds.txt` у дистрибутиві "
"вихідних кодів Python для отримання більш детальної інформації."
