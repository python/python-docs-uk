# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Exception Handling"
msgstr "Обробка винятків"

msgid ""
"The functions described in this chapter will let you handle and raise Python "
"exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it "
"to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a "
"pointer, or ``-1`` if they return an integer (exception: the :c:func:"
"`PyArg_\\*` functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"Функції, описані в цьому розділі, дозволять вам обробляти та викликати "
"виняткові ситуації Python. Важливо розуміти деякі основи обробки винятків "
"Python. Це працює приблизно так, як змінна POSIX :c:data:`errno`: існує "
"глобальний індикатор (для кожного потоку) останньої помилки, яка сталася. "
"Більшість функцій C API не очищають це в разі успіху, але встановлюють його, "
"щоб вказати причину помилки в разі невдачі. Більшість функцій C API також "
"повертають індикатор помилки, зазвичай ``NULL``, якщо вони мають повертати "
"покажчик, або ``-1``, якщо вони повертають ціле число (виняток: :c:func:"
"`PyArg_\\*` функції повертають ``1`` для успіху та ``0`` для невдачі)."

msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"Зокрема, індикатор помилки складається з трьох покажчиків на об’єкти: тип "
"винятку, значення винятку та об’єкт трасування. Будь-який із цих покажчиків "
"може бути ``NULL``, якщо не встановлено (хоча деякі комбінації заборонені, "
"наприклад, ви не можете мати не ``NULL`` трасування, якщо тип винятку "
"``NULL``)."

msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it "
"is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"Коли функція повинна вийти з ладу через те, що якась викликана нею функція "
"вийшла з ладу, вона зазвичай не встановлює індикатор помилки; викликана ним "
"функція вже встановила його. Він відповідає або за обробку помилки та "
"очищення виняткової ситуації, або за повернення після очищення будь-яких "
"ресурсів, які він утримує (наприклад, посилання на об’єкти чи розподіл "
"пам’яті); він *не* повинен продовжуватися нормально, якщо він не готовий "
"обробити помилку. Якщо ви повертаєтеся через помилку, важливо вказати "
"абоненту, що була встановлена помилка. Якщо помилку не обробляти або "
"ретельно розповсюджувати, додаткові виклики API Python/C можуть не працювати "
"належним чином і можуть виникати загадкові збої."

msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info()`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught "
"(and has therefore stopped propagating)."
msgstr ""
"Індикатор помилки **не** є результатом :func:`sys.exc_info()`. Перший "
"відповідає винятку, який ще не перехоплено (і, отже, все ще поширюється), а "
"другий повертає виняток після того, як він перехоплений (і, отже, припинив "
"поширення)."

msgid "Printing and clearing"
msgstr "Друк та розчистка"

msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr ""
"Очистіть індикатор помилки. Якщо індикатор помилки не встановлено, ефекту "
"немає."

msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"Надрукуйте стандартне відстеження до ``sys.stderr`` і очистіть індикатор "
"помилки. **Якщо** помилка не є ``SystemExit``, у такому випадку трасування "
"не друкується, і процес Python завершить роботу з кодом помилки, указаним "
"екземпляром ``SystemExit``."

msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr ""
"Викликайте цю функцію **лише**, коли встановлено індикатор помилки. Інакше "
"це призведе до фатальної помилки!"

msgid ""
"If *set_sys_last_vars* is nonzero, the variables :data:`sys.last_type`, :"
"data:`sys.last_value` and :data:`sys.last_traceback` will be set to the "
"type, value and traceback of the printed exception, respectively."
msgstr ""
"Якщо *set_sys_last_vars* не дорівнює нулю, змінним :data:`sys.last_type`, :"
"data:`sys.last_value` і :data:`sys.last_traceback` буде встановлено тип, "
"значення та відстеження надрукованого винятку, відповідно."

msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "Псевдонім для ``PyErr_PrintEx(1)``."

msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr ""
"Викликайте :func:`sys.unraisablehook`, використовуючи поточний виняток і "
"аргумент *obj*."

msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`__del__` method."
msgstr ""
"Ця допоміжна функція друкує попереджувальне повідомлення в ``sys.stderr``, "
"коли встановлено виняток, але інтерпретатор не може фактично викликати "
"виняток. Він використовується, наприклад, коли виникає виняток у методі :"
"meth:`__del__`."

msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of "
"*obj* will be printed in the warning message."
msgstr ""
"Функція викликається з одним аргументом *obj*, який визначає контекст, у "
"якому сталася неможлива виключення. Якщо можливо, відображення *obj* буде "
"надруковано в попередженні."

msgid "An exception must be set when calling this function."
msgstr "При виклику цієї функції необхідно встановити виняток."

msgid "Raising exceptions"
msgstr "Створення винятків"

msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr ""
"Ці функції допомагають встановити індикатор помилки поточного потоку. Для "
"зручності деякі з цих функцій завжди повертатимуть покажчик ``NULL`` для "
"використання в операторі ``return``."

msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions, "
"e.g. :c:data:`PyExc_RuntimeError`.  You need not increment its reference "
"count. The second argument is an error message; it is decoded from "
"``'utf-8'``."
msgstr ""
"Це найпоширеніший спосіб встановлення індикатора помилки. Перший аргумент "
"визначає тип винятку; зазвичай це один із стандартних винятків, напр. :c:"
"data:`PyExc_RuntimeError`. Вам не потрібно збільшувати його кількість "
"посилань. Другим аргументом є повідомлення про помилку; він декодується з "
"``'utf-8'``."

msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr ""
"Ця функція схожа на :c:func:`PyErr_SetString`, але дозволяє вказати "
"довільний об’єкт Python для \"значення\" винятку."

msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in :"
"c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"Ця функція встановлює індикатор помилки та повертає ``NULL``. *exception* "
"має бути класом винятків Python. *format* і наступні параметри допомагають "
"відформатувати повідомлення про помилку; вони мають те саме значення та "
"значення, що й у :c:func:`PyUnicode_FromFormat`. *format* — це рядок у "
"кодуванні ASCII."

msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"Те саме, що :c:func:`PyErr_Format`, але приймає аргумент :c:type:`va_list`, "
"а не змінну кількість аргументів."

msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "Це скорочення для ``PyErr_SetObject(type, Py_None)``."

msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where "
"*message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"Це скорочення для ``PyErr_SetString(PyExc_TypeError, повідомлення)``, де "
"*повідомлення* вказує на те, що вбудовану операцію було викликано з "
"недопустимим аргументом. В основному він призначений для внутрішнього "
"використання."

msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"Це скорочення для ``PyErr_SetNone(PyExc_MemoryError)``; він повертає "
"``NULL``, тому функція розподілу об’єктів може написати ``return "
"PyErr_NoMemory();``, коли їй вичерпується пам’ять."

msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from :"
"c:func:`strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :const:`EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"Це зручна функція для створення винятку, коли функція бібліотеки C повертає "
"помилку та встановлює змінну C :c:data:`errno`. Він створює об’єкт кортежу, "
"першим елементом якого є ціле значення :c:data:`errno`, а другим елементом — "
"відповідне повідомлення про помилку (отримане з :c:func:`strerror`), а потім "
"викликає ``PyErr_SetObject(type , об'єкт)``. В Unix, коли значення :c:data:"
"`errno` дорівнює :const:`EINTR`, що вказує на перерваний системний виклик, "
"це викликає :c:func:`PyErr_CheckSignals`, і якщо це встановлює індикатор "
"помилки, залишає його встановленим до того. Функція завжди повертає "
"``NULL``, тому функція-огортка навколо системного виклику може писати "
"``return PyErr_SetFromErrno(type);``, коли системний виклик повертає помилку."

msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`filename` attribute of the exception instance."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromErrno`, з додатковою поведінкою: якщо "
"*filenameObject* не є ``NULL``, воно передається конструктору *type* як "
"третій параметр. У випадку винятку :exc:`OSError` це використовується для "
"визначення атрибута :attr:`filename` екземпляра винятку."

msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromErrnoWithFilenameObject`, але приймає "
"другий об’єкт імені файлу, щоб викликати помилки, коли функція, яка приймає "
"два імені файлу, виходить з ладу."

msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the :term:`filesystem "
"encoding and error handler`."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromErrnoWithFilenameObject`, але ім’я файлу "
"подається як рядок C. *ім’я файлу* розшифровується з :term:`filesystem "
"encoding and error handler`."

msgid ""
"This is a convenience function to raise :exc:`WindowsError`. If called with "
"*ierr* of :c:data:`0`, the error code returned by a call to :c:func:"
"`GetLastError` is used instead.  It calls the Win32 function :c:func:"
"`FormatMessage` to retrieve the Windows description of error code given by "
"*ierr* or :c:func:`GetLastError`, then it constructs a tuple object whose "
"first item is the *ierr* value and whose second item is the corresponding "
"error message (gotten from :c:func:`FormatMessage`), and then calls "
"``PyErr_SetObject(PyExc_WindowsError, object)``. This function always "
"returns ``NULL``."
msgstr ""
"Це зручна функція для виклику :exc:`WindowsError`. Якщо викликати *ierr* із :"
"c:data:`0`, замість цього використовується код помилки, який повертає "
"виклик :c:func:`GetLastError`. Він викликає функцію Win32 :c:func:"
"`FormatMessage`, щоб отримати опис Windows коду помилки, наданого *ierr* "
"або :c:func:`GetLastError`, а потім створює об’єкт кортежу, першим елементом "
"якого є *ierr* і другий елемент якого є відповідним повідомленням про "
"помилку (отриманим із :c:func:`FormatMessage`), а потім викликає "
"``PyErr_SetObject(PyExc_WindowsError, object)``. Ця функція завжди повертає "
"``NULL``."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromWindowsErr`, з додатковим параметром, що "
"визначає тип винятку, який буде створено."

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, but the "
"filename is given as a C string.  *filename* is decoded from the filesystem "
"encoding (:func:`os.fsdecode`)."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, але ім’я "
"файлу подається як рядок C. *ім’я файлу* декодується з кодування файлової "
"системи (:func:`os.fsdecode`)."

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, with an "
"additional parameter specifying the exception type to be raised."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, з додатковим "
"параметром, що визначає тип винятку, який буде створено."

msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"Подібно до :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, але "
"приймає другий об’єкт імені файлу."

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional "
"parameter specifying the exception type to be raised."
msgstr ""
"Подібно до :c:func:`PyErr_SetFromWindowsErrWithFilename`, з додатковим "
"параметром, що визначає тип винятку, який буде створено."

msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and "
"``path`` attributes."
msgstr ""
"Це зручна функція для виклику :exc:`ImportError`. *msg* буде встановлено як "
"рядок повідомлення винятку. *name* і *path*, обидва з яких можуть мати "
"значення ``NULL``, буде встановлено як відповідні атрибути ``name`` і "
"``path`` :exc:`ImportError`."

msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"Дуже схоже на :c:func:`PyErr_SetImportError`, але ця функція дозволяє "
"вказати підклас :exc:`ImportError` для підвищення."

msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"Установіть інформацію про файл, рядок і зсув для поточного винятку. Якщо "
"поточний виняток не є :exc:`SyntaxError`, тоді він встановлює додаткові "
"атрибути, які змушують підсистему друку виключення вважати, що виняток є :"
"exc:`SyntaxError`."

msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the :term:`filesystem encoding and error handler`."
msgstr ""
"Подібно до :c:func:`PyErr_SyntaxLocationObject`, але *filename* — це рядок "
"байтів, декодований з :term:`filesystem encoding and error handler`."

msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr ""
"Як :c:func:`PyErr_SyntaxLocationEx`, але параметр *col_offset* опущено."

msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"Це скорочення для ``PyErr_SetString(PyExc_SystemError, повідомлення)``, де "
"*повідомлення* вказує на те, що внутрішня операція (наприклад, функція "
"Python/C API) була викликана з недопустимим аргументом. В основному він "
"призначений для внутрішнього використання."

msgid "Issuing warnings"
msgstr "Винесення попереджень"

msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if "
"an exception is raised.  (It is not possible to determine whether a warning "
"message is actually printed, nor what the reason is for the exception; this "
"is intentional.)  If an exception is raised, the caller should do its normal "
"exception handling (for example, :c:func:`Py_DECREF` owned references and "
"return an error value)."
msgstr ""
"Використовуйте ці функції, щоб видавати попередження з коду C. Вони "
"відображають аналогічні функції, експортовані модулем Python :mod:"
"`warnings`. Зазвичай вони друкують попередження на *sys.stderr*; однак також "
"можливо, що користувач вказав, що попередження потрібно перетворити на "
"помилки, і в такому випадку вони викличуть виняток. Також можливо, що "
"функції викликають виняток через проблему з механізмом попередження. "
"Повертається значення ``0``, якщо не викликається виняткова ситуація, або "
"``-1``, якщо виникає виняток. (Неможливо визначити, чи справді друкується "
"попереджувальне повідомлення, а також причину винятку; це навмисно.) Якщо "
"виникає виняток, абонент, що викликає, має виконати звичайну обробку "
"винятків (наприклад, :c:func:`Py_DECREF` належать посилання та повертають "
"значення помилки)."

msgid ""
"Issue a warning message.  The *category* argument is a warning category (see "
"below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling :c:func:"
"`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"Видавати попереджувальне повідомлення. Аргумент *category* є категорією "
"попередження (див. нижче) або ``NULL``; аргумент *message* — це рядок у "
"кодуванні UTF-8. *stack_level* — додатне число, яке дає кількість кадрів "
"стека; попередження буде видано з поточного рядка коду в цьому фреймі стека. "
"*Stack_level* 1 — це функція, яка викликає :c:func:`PyErr_WarnEx`, 2 — це "
"функція, яка стоїть вище, і так далі."

msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the default "
"warning category is :c:data:`PyExc_RuntimeWarning`. The standard Python "
"warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"Категорії попереджень мають бути підкласами :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` є підкласом :c:data:`PyExc_Exception`; стандартна категорія "
"попередження: :c:data:`PyExc_RuntimeWarning`. Стандартні категорії "
"попереджень Python доступні як глобальні змінні, імена яких пронумеровані в :"
"ref:`standardwarningcategories`."

msgid ""
"For information about warning control, see the documentation for the :mod:"
"`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"Щоб отримати інформацію про керування попередженнями, перегляньте "
"документацію до модуля :mod:`warnings` і опції :option:`-W` у документації "
"командного рядка. Немає C API для керування попередженнями."

msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function :func:`warnings."
"warn_explicit`; see there for more information.  The *module* and *registry* "
"arguments may be set to ``NULL`` to get the default effect described there."
msgstr ""
"Видавати попереджувальне повідомлення з явним керуванням усіма атрибутами "
"попередження. Це проста обгортка функції Python :func:`warnings."
"warn_explicit`; дивіться там для отримання додаткової інформації. Для "
"аргументів *module* і *registry* можна встановити значення ``NULL``, щоб "
"отримати описаний там ефект за замовчуванням."

msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Подібно до :c:func:`PyErr_WarnExplicitObject`, за винятком того, що "
"*message* і *module* є рядками в кодуванні UTF-8, а *filename* декодується "
"з :term:`filesystem encoding and error handler`."

msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use :c:func:"
"`PyUnicode_FromFormat` to format the warning message.  *format* is an ASCII-"
"encoded string."
msgstr ""
"Функція схожа на :c:func:`PyErr_WarnEx`, але використовуйте :c:func:"
"`PyUnicode_FromFormat` для форматування повідомлення попередження. *format* "
"— це рядок у кодуванні ASCII."

msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is :exc:"
"`ResourceWarning` and it passes *source* to :func:`warnings.WarningMessage`."
msgstr ""
"Функція схожа на :c:func:`PyErr_WarnFormat`, але *category* має значення :"
"exc:`ResourceWarning` і вона передає *source* до :func:`warnings."
"WarningMessage`."

msgid "Querying the error indicator"
msgstr "Запит індикатора помилки"

msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the :c:func:"
"`PyErr_Set\\*` functions or to :c:func:`PyErr_Restore`).  If not set, return "
"``NULL``.  You do not own a reference to the return value, so you do not "
"need to :c:func:`Py_DECREF` it."
msgstr ""
"Перевірте, чи встановлено індикатор помилки. Якщо встановлено, повертає "
"виняток *type* (перший аргумент останнього виклику однієї з функцій :c:func:"
"`PyErr_Set\\*` або :c:func:`PyErr_Restore`). Якщо не встановлено, повертає "
"``NULL``. Ви не володієте посиланням на значення, що повертається, тому вам "
"не потрібно його :c:func:`Py_DECREF`."

msgid "The caller must hold the GIL."
msgstr "Абонент повинен тримати GIL."

msgid ""
"Do not compare the return value to a specific exception; use :c:func:"
"`PyErr_ExceptionMatches` instead, shown below.  (The comparison could easily "
"fail since the exception may be an instance instead of a class, in the case "
"of a class exception, or it may be a subclass of the expected exception.)"
msgstr ""
"Не порівнюйте повернуте значення з певним винятком; замість цього "
"використовуйте :c:func:`PyErr_ExceptionMatches`, як показано нижче. "
"(Порівняння може бути легко невдалим, оскільки виняток може бути екземпляром "
"замість класу, у випадку винятку класу, або він може бути підкласом "
"очікуваного винятку.)"

msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"Еквівалент ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``. Це слід "
"викликати лише тоді, коли фактично встановлено виняток; порушення доступу до "
"пам'яті відбудеться, якщо не було викликано жодного винятку."

msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"Повертає true, якщо *given* виняток відповідає типу винятку в *exc*. Якщо "
"*exc* є об’єктом класу, це також повертає true, коли *given* є екземпляром "
"підкласу. Якщо *exc* є кортежем, усі типи винятків у кортежі (і рекурсивно в "
"підкортежах) шукаються на відповідність."

msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"Отримати індикатор помилки в трьох змінних, адреси яких передано. Якщо "
"індикатор помилки не встановлено, установіть для всіх трьох змінних значення "
"``NULL``. Якщо його встановлено, його буде очищено, і ви матимете посилання "
"на кожен отриманий об’єкт. Значення та об’єкт трасування можуть бути "
"``NULL``, навіть якщо об’єкт типу не є таким."

msgid ""
"This function is normally only used by code that needs to catch exceptions "
"or by code that needs to save and restore the error indicator temporarily, e."
"g.::"
msgstr ""
"Зазвичай ця функція використовується лише кодом, який має перехоплювати "
"винятки, або кодом, якому потрібно тимчасово зберегти та відновити індикатор "
"помилки, наприклад::"

msgid ""
"Set  the error indicator from the three objects.  If the error indicator is "
"already set, it is cleared first.  If the objects are ``NULL``, the error "
"indicator is cleared.  Do not pass a ``NULL`` type and non-``NULL`` value or "
"traceback.  The exception type should be a class.  Do not pass an invalid "
"exception type or value. (Violating these rules will cause subtle problems "
"later.)  This call takes away a reference to each object: you must own a "
"reference to each object before the call and after the call you no longer "
"own these references.  (If you don't understand this, don't use this "
"function.  I warned you.)"
msgstr ""
"Встановіть індикатор помилки з трьох об’єктів. Якщо індикатор помилки вже "
"встановлено, він спочатку очищається. Якщо об’єкти мають значення ``NULL``, "
"індикатор помилки зникає. Не передавайте тип ``NULL`` і не-``NULL`` значення "
"або трасування. Тип винятку має бути класом. Не передавайте недійсний тип "
"або значення винятку. (Порушення цих правил пізніше спричинить незначні "
"проблеми.) Цей виклик забирає посилання на кожен об’єкт: ви повинні мати "
"посилання на кожен об’єкт до виклику, а після виклику ви більше не володієте "
"цими посиланнями. (Якщо ви цього не розумієте, не використовуйте цю функцію. "
"Я вас попереджав.)"

msgid ""
"This function is normally only used by code that needs to save and restore "
"the error indicator temporarily.  Use :c:func:`PyErr_Fetch` to save the "
"current error indicator."
msgstr ""
"Ця функція зазвичай використовується лише кодом, якому потрібно тимчасово "
"зберегти та відновити індикатор помилки. Використовуйте :c:func:"
"`PyErr_Fetch`, щоб зберегти поточний індикатор помилки."

msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"За певних обставин значення, які повертає :c:func:`PyErr_Fetch` нижче, "
"можуть бути \"ненормалізованими\", тобто ``*exc`` є об’єктом класу, але "
"``*val`` не є екземпляром того самого класу . У цьому випадку цю функцію "
"можна використовувати для створення екземпляра класу. Якщо значення вже "
"нормалізовані, нічого не відбувається. Відкладену нормалізацію реалізовано "
"для покращення продуктивності."

msgid ""
"This function *does not* implicitly set the ``__traceback__`` attribute on "
"the exception value. If setting the traceback appropriately is desired, the "
"following additional snippet is needed::"
msgstr ""
"Ця функція *не* неявно встановлює атрибут ``__traceback__`` для значення "
"винятку. Якщо потрібно правильно налаштувати відстеження, потрібен наступний "
"додатковий фрагмент:"

msgid ""
"Retrieve the exception info, as known from ``sys.exc_info()``.  This refers "
"to an exception that was *already caught*, not to an exception that was "
"freshly raised.  Returns new references for the three objects, any of which "
"may be ``NULL``.  Does not modify the exception info state."
msgstr ""

msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"Ця функція зазвичай не використовується кодом, який хоче обробляти винятки. "
"Натомість його можна використовувати, коли коду потрібно тимчасово зберегти "
"та відновити винятковий стан. Використовуйте :c:func:`PyErr_SetExcInfo`, щоб "
"відновити або видалити винятковий стан."

msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an "
"exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. For general rules "
"about the three arguments, see :c:func:`PyErr_Restore`."
msgstr ""

msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"Ця функція зазвичай не використовується кодом, який хоче обробляти винятки. "
"Натомість його можна використовувати, коли коду потрібно тимчасово зберегти "
"та відновити винятковий стан. Використовуйте :c:func:`PyErr_GetExcInfo`, щоб "
"прочитати винятковий стан."

msgid "Signal Handling"
msgstr "Обробка сигналів"

msgid "This function interacts with Python's signal handling."
msgstr "Ця функція взаємодіє з обробкою сигналів Python."

msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes and "
"if so, invokes the corresponding signal handler.  If the :mod:`signal` "
"module is supported, this can invoke a signal handler written in Python."
msgstr ""
"Якщо функція викликається з головного потоку та під основним інтерпретатором "
"Python, вона перевіряє, чи було надіслано сигнал до процесів, і якщо так, "
"викликає відповідний обробник сигналу. Якщо модуль :mod:`signal` "
"підтримується, це може викликати обробник сигналів, написаний на Python."

msgid ""
"The function attempts to handle all pending signals, and then returns ``0``. "
"However, if a Python signal handler raises an exception, the error indicator "
"is set and the function returns ``-1`` immediately (such that other pending "
"signals may not have been handled yet: they will be on the next :c:func:"
"`PyErr_CheckSignals()` invocation)."
msgstr ""
"Функція намагається обробити всі незавершені сигнали, а потім повертає "
"``0``. Однак, якщо обробник сигналів Python викликає виняток, індикатор "
"помилки встановлюється, і функція негайно повертає ``-1`` (наприклад, інші "
"сигнали, що очікують на розгляд, ще не були оброблені: вони будуть на "
"наступному :c:func:`PyErr_CheckSignals()` виклик)."

msgid ""
"If the function is called from a non-main thread, or under a non-main Python "
"interpreter, it does nothing and returns ``0``."
msgstr ""
"Якщо функція викликається з неосновного потоку або під неосновним "
"інтерпретатором Python, вона нічого не робить і повертає ``0``."

msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr ""
"Ця функція може бути викликана довгостроковим кодом C, який хоче бути "
"перерваним запитами користувача (наприклад, натисканням Ctrl-C)."

msgid ""
"The default Python signal handler for :const:`SIGINT` raises the :exc:"
"`KeyboardInterrupt` exception."
msgstr ""
"Стандартний обробник сигналу Python для :const:`SIGINT` викликає виняток :"
"exc:`KeyboardInterrupt`."

msgid ""
"Simulate the effect of a :const:`SIGINT` signal arriving. This is equivalent "
"to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""
"Імітація ефекту надходження сигналу :const:`SIGINT`. Це еквівалентно "
"``PyErr_SetInterruptEx(SIGINT)``."

msgid ""
"This function is async-signal-safe.  It can be called without the :term:"
"`GIL` and from a C signal handler."
msgstr ""
"Ця функція безпечна для асинхронного сигналу. Його можна викликати без :term:"
"`GIL` і з обробника сигналів C."

msgid ""
"Simulate the effect of a signal arriving. The next time :c:func:"
"`PyErr_CheckSignals` is called,  the Python signal handler for the given "
"signal number will be called."
msgstr ""
"Імітація ефекту надходження сигналу. Під час наступного виклику :c:func:"
"`PyErr_CheckSignals` буде викликано обробник сигналу Python для заданого "
"номера сигналу."

msgid ""
"This function can be called by C code that sets up its own signal handling "
"and wants Python signal handlers to be invoked as expected when an "
"interruption is requested (for example when the user presses Ctrl-C to "
"interrupt an operation)."
msgstr ""
"Цю функцію можна викликати за допомогою коду C, який налаштовує власну "
"обробку сигналів і хоче, щоб обробники сигналів Python викликалися належним "
"чином, коли надходить запит на переривання (наприклад, коли користувач "
"натискає Ctrl-C, щоб перервати операцію)."

msgid ""
"If the given signal isn't handled by Python (it was set to :data:`signal."
"SIG_DFL` or :data:`signal.SIG_IGN`), it will be ignored."
msgstr ""
"Якщо вказаний сигнал не обробляється Python (для нього встановлено значення :"
"data:`signal.SIG_DFL` або :data:`signal.SIG_IGN`), він буде проігнорований."

msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""
"Якщо *signum* знаходиться за межами дозволеного діапазону чисел сигналу, "
"повертається ``-1``. В іншому випадку повертається ``0``. Ця функція ніколи "
"не змінює індикатор помилки."

msgid ""
"This utility function specifies a file descriptor to which the signal number "
"is written as a single byte whenever a signal is received. *fd* must be non-"
"blocking. It returns the previous such file descriptor."
msgstr ""
"Ця допоміжна функція вказує дескриптор файлу, до якого номер сигналу "
"записується як один байт кожного разу, коли надходить сигнал. *fd* має бути "
"неблокуючим. Він повертає попередній такий файловий дескриптор."

msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only "
"be called from the main thread."
msgstr ""
"Значення ``-1`` вимикає функцію; це початковий стан. Це еквівалентно :func:"
"`signal.set_wakeup_fd` у Python, але без перевірки помилок. *fd* має бути "
"дійсним дескриптором файлу. Функцію слід викликати лише з основного потоку."

msgid "On Windows, the function now also supports socket handles."
msgstr "У Windows функція тепер також підтримує ручки сокетів."

msgid "Exception Classes"
msgstr "Виняткові класи"

msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"Ця службова функція створює та повертає новий клас винятків. Аргумент *name* "
"має бути назвою нового винятку, рядком C у формі ``module.classname``. "
"Аргументи *base* і *dict* зазвичай мають значення ``NULL``. Це створює "
"об’єкт класу, похідний від :exc:`Exception` (доступний у C як :c:data:"
"`PyExc_Exception`)."

msgid ""
"The :attr:`__module__` attribute of the new class is set to the first part "
"(up to the last dot) of the *name* argument, and the class name is set to "
"the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class "
"variables and methods."
msgstr ""
"Атрибут :attr:`__module__` нового класу встановлюється на першу частину (до "
"останньої крапки) аргументу *name*, а ім’я класу встановлюється на останню "
"частину (після останньої крапки). Аргумент *base* можна використовувати для "
"визначення альтернативних базових класів; це може бути лише один клас або "
"кортеж класів. Аргумент *dict* можна використовувати для визначення словника "
"змінних класу та методів."

msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"Те саме, що :c:func:`PyErr_NewException`, за винятком того, що новому класу "
"винятків можна легко надати рядок документації: якщо *doc* не є ``NULL``, "
"він використовуватиметься як рядок документації для класу винятків."

msgid "Exception Objects"
msgstr "Об’єкти винятків"

msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through :attr:`__traceback__`.  If there is no "
"traceback associated, this returns ``NULL``."
msgstr ""
"Повернути зворотне трасування, пов’язане з винятком, як нове посилання, "
"доступне з Python через :attr:`__traceback__`. Якщо зворотне відстеження не "
"пов’язане, повертається ``NULL``."

msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to "
"clear it."
msgstr ""
"Установіть для трасування, пов’язаного з винятком, значення *tb*. "
"Використовуйте ``Py_None``, щоб очистити його."

msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through :attr:`__context__`.  If there is no context associated, "
"this returns ``NULL``."
msgstr ""
"Повертає контекст (інший екземпляр винятку, під час обробки якого було "
"викликано *ex*), пов’язаний із винятком як нове посилання, доступне з Python "
"через :attr:`__context__`. Якщо пов’язаного контексту немає, повертається "
"``NULL``."

msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"Установіть для контексту, пов’язаного з винятком, значення *ctx*. Щоб "
"очистити його, використовуйте ``NULL``. Немає перевірки типу, щоб "
"переконатися, що *ctx* є винятком. Це краде посилання на *ctx*."

msgid ""
"Return the cause (either an exception instance, or :const:`None`, set by "
"``raise ... from ...``) associated with the exception as a new reference, as "
"accessible from Python through :attr:`__cause__`."
msgstr ""
"Повертає причину (або екземпляр винятку, або :const:`None`, встановлений "
"``raise ... from ...``), пов’язану з винятком як нове посилання, доступне з "
"Python через :attr:`__cause__`."

msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or :const:`None`.  This steals a reference to *cause*."
msgstr ""
"Встановіть причину, пов’язану з винятком, на *cause*. Щоб очистити його, "
"використовуйте ``NULL``. Немає перевірки типу, щоб переконатися, що *cause* "
"є винятком або :const:`None`. Це краде посилання на *причину*."

msgid ""
":attr:`__suppress_context__` is implicitly set to ``True`` by this function."
msgstr ""
":attr:`__suppress_context__` цією функцією неявно встановлено значення "
"``True``."

msgid "Unicode Exception Objects"
msgstr "Виняткові об’єкти Unicode"

msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr ""
"Наступні функції використовуються для створення та зміни винятків Unicode з "
"C."

msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""
"Створіть об’єкт :class:`UnicodeDecodeError` з атрибутами *encoding*, "
"*object*, *length*, *start*, *end* і *reason*. *encoding* і *reason* є "
"рядками в кодуванні UTF-8."

msgid ""
"Create a :class:`UnicodeEncodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""

msgid "3.11"
msgstr ""

msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeEncodeError, \"sOnns\", ...)``."
msgstr ""

msgid ""
"Create a :class:`UnicodeTranslateError` object with the attributes *object*, "
"*length*, *start*, *end* and *reason*. *reason* is a UTF-8 encoded string."
msgstr ""

msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeTranslateError, \"Onns\", ...)``."
msgstr ""

msgid "Return the *encoding* attribute of the given exception object."
msgstr "Повертає атрибут *encoding* даного об’єкта винятку."

msgid "Return the *object* attribute of the given exception object."
msgstr "Повертає атрибут *object* даного об’єкта винятку."

msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"Отримайте атрибут *start* даного об’єкта винятку та помістіть його в "
"*\\*start*. *початок* не має бути ``NULL``. Повертає ``0`` в разі успіху, "
"``-1`` у випадку невдачі."

msgid ""
"Set the *start* attribute of the given exception object to *start*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Установіть для атрибута *start* даного об’єкта винятку значення *start*. "
"Повертає ``0`` в разі успіху, ``-1`` у випадку невдачі."

msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"Отримайте атрибут *end* даного об’єкта винятку та помістіть його в *\\*end*. "
"*end* не має бути ``NULL``. Повертає ``0`` в разі успіху, ``-1`` у випадку "
"невдачі."

msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Установіть для атрибута *end* даного об’єкта винятку значення *end*. "
"Повертає ``0`` в разі успіху, ``-1`` у випадку невдачі."

msgid "Return the *reason* attribute of the given exception object."
msgstr "Повертає атрибут *reason* даного об’єкта винятку."

msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""
"Установіть для атрибута *reason* даного об’єкта винятку значення *reason*. "
"Повертає ``0`` в разі успіху, ``-1`` у випадку невдачі."

msgid "Recursion Control"
msgstr "Контроль рекурсії"

msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"Ці дві функції забезпечують спосіб виконання безпечних рекурсивних викликів "
"на рівні C, як в ядрі, так і в модулях розширення. Вони потрібні, якщо "
"рекурсивний код не обов’язково викликає код Python (який автоматично "
"відстежує глибину рекурсії). Вони також не потрібні для реалізації "
"*tp_call*, оскільки :ref:`протокол виклику <call>` піклується про обробку "
"рекурсії."

msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr "Позначає точку, де має бути виконано рекурсивний виклик C-рівня."

msgid ""
"If :const:`USE_STACKCHECK` is defined, this function checks if the OS stack "
"overflowed using :c:func:`PyOS_CheckStack`.  In this is the case, it sets a :"
"exc:`MemoryError` and returns a nonzero value."
msgstr ""
"Якщо визначено :const:`USE_STACKCHECK`, ця функція перевіряє, чи не було "
"переповнено стек ОС за допомогою :c:func:`PyOS_CheckStack`. У цьому випадку "
"він встановлює :exc:`MemoryError` і повертає ненульове значення."

msgid ""
"The function then checks if the recursion limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""
"Потім функція перевіряє, чи досягнуто обмеження рекурсії. Якщо це так, "
"встановлюється :exc:`RecursionError` і повертається ненульове значення. В "
"іншому випадку повертається нуль."

msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*де* має бути рядок у кодуванні UTF-8, такий як ``\" у перевірці "
"екземпляра\"``, який об’єднується з повідомленням :exc:`RecursionError`, "
"спричиненим обмеженням глибини рекурсії."

msgid "This function is now also available in the limited API."
msgstr "Ця функція тепер також доступна в обмеженому API."

msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"Завершує :c:func:`Py_EnterRecursiveCall`. Потрібно викликати один раз для "
"кожного *успішного* виклику :c:func:`Py_EnterRecursiveCall`."

msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, :"
"c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"Правильна реалізація :c:member:`~PyTypeObject.tp_repr` для типів контейнерів "
"вимагає спеціальної обробки рекурсії. Окрім захисту стека, :c:member:"
"`~PyTypeObject.tp_repr` також має відстежувати об’єкти, щоб запобігти "
"циклам. Наступні дві функції полегшують цю функцію. По суті, це C "
"еквівалент :func:`reprlib.recursive_repr`."

msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr ""
"Викликається на початку реалізації :c:member:`~PyTypeObject.tp_repr` для "
"виявлення циклів."

msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, :class:"
"`dict` objects return ``{...}`` and :class:`list` objects return ``[...]``."
msgstr ""
"Якщо об’єкт уже оброблено, функція повертає додатне ціле число. У цьому "
"випадку реалізація :c:member:`~PyTypeObject.tp_repr` має повертати рядковий "
"об’єкт, що вказує на цикл. Як приклад, об’єкти :class:`dict` повертають "
"``{...}``, а об’єкти :class:`list` повертають ``[...]``."

msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"Функція поверне від’ємне ціле число, якщо досягнуто обмеження рекурсії. У "
"цьому випадку реалізація :c:member:`~PyTypeObject.tp_repr` зазвичай повинна "
"повертати ``NULL``."

msgid ""
"Otherwise, the function returns zero and the :c:member:`~PyTypeObject."
"tp_repr` implementation can continue normally."
msgstr ""
"В іншому випадку функція повертає нуль, і реалізація :c:member:"
"`~PyTypeObject.tp_repr` може продовжуватися нормально."

msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of :"
"c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"Завершує :c:func:`Py_ReprEnter`. Потрібно викликати один раз для кожного "
"виклику :c:func:`Py_ReprEnter`, який повертає нуль."

msgid "Standard Exceptions"
msgstr "Стандартні винятки"

msgid ""
"All standard Python exceptions are available as global variables whose names "
"are ``PyExc_`` followed by the Python exception name.  These have the type :"
"c:type:`PyObject*`; they are all class objects.  For completeness, here are "
"all the variables:"
msgstr ""
"Усі стандартні винятки Python доступні як глобальні змінні, імена яких "
"``PyExc_``, за якими йде назва винятку Python. Вони мають тип :c:type:"
"`PyObject*`; всі вони є об'єктами класу. Для повноти ось усі змінні:"

msgid "C Name"
msgstr "C Назва"

msgid "Python Name"
msgstr "Назва Python"

msgid "Notes"
msgstr "Примітки"

msgid ":c:data:`PyExc_BaseException`"
msgstr ":c:data:`PyExc_BaseException`"

msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

msgid "[1]_"
msgstr "[1]_"

msgid ":c:data:`PyExc_Exception`"
msgstr ":c:data:`PyExc_Exception`"

msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

msgid ":c:data:`PyExc_ArithmeticError`"
msgstr ":c:data:`PyExc_ArithmeticError`"

msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

msgid ":c:data:`PyExc_AssertionError`"
msgstr ":c:data:`PyExc_AssertionError`"

msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

msgid ":c:data:`PyExc_AttributeError`"
msgstr ":c:data:`PyExc_AttributeError`"

msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

msgid ":c:data:`PyExc_BlockingIOError`"
msgstr ":c:data:`PyExc_BlockingIOError`"

msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

msgid ":c:data:`PyExc_BrokenPipeError`"
msgstr ":c:data:`PyExc_BrokenPipeError`"

msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`Помилка BrokenPipeError`"

msgid ":c:data:`PyExc_BufferError`"
msgstr ":c:data:`PyExc_BufferError`"

msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

msgid ":c:data:`PyExc_ChildProcessError`"
msgstr ":c:data:`PyExc_ChildProcessError`"

msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

msgid ":c:data:`PyExc_ConnectionAbortedError`"
msgstr ":c:data:`PyExc_ConnectionAbortedError`"

msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`ConnectionAbortedError`"

msgid ":c:data:`PyExc_ConnectionError`"
msgstr ":c:data:`PyExc_ConnectionError`"

msgid ":exc:`ConnectionError`"
msgstr ":exc:`ConnectionError`"

msgid ":c:data:`PyExc_ConnectionRefusedError`"
msgstr ":c:data:`PyExc_ConnectionRefusedError`"

msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`ConnectionRefusedError`"

msgid ":c:data:`PyExc_ConnectionResetError`"
msgstr ":c:data:`PyExc_ConnectionResetError`"

msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`ConnectionResetError`"

msgid ":c:data:`PyExc_EOFError`"
msgstr ":c:data:`PyExc_EOFError`"

msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

msgid ":c:data:`PyExc_FileExistsError`"
msgstr ":c:data:`PyExc_FileExistsError`"

msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

msgid ":c:data:`PyExc_FileNotFoundError`"
msgstr ":c:data:`PyExc_FileNotFoundError`"

msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

msgid ":c:data:`PyExc_FloatingPointError`"
msgstr ":c:data:`PyExc_FloatingPointError`"

msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

msgid ":c:data:`PyExc_GeneratorExit`"
msgstr ":c:data:`PyExc_GeneratorExit`"

msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

msgid ":c:data:`PyExc_ImportError`"
msgstr ":c:data:`PyExc_ImportError`"

msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

msgid ":c:data:`PyExc_IndentationError`"
msgstr ":c:data:`PyExc_IndentationError`"

msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

msgid ":c:data:`PyExc_IndexError`"
msgstr ":c:data:`PyExc_IndexError`"

msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

msgid ":c:data:`PyExc_InterruptedError`"
msgstr ":c:data:`PyExc_InterruptedError`"

msgid ":exc:`InterruptedError`"
msgstr ":exc:`InterruptedError`"

msgid ":c:data:`PyExc_IsADirectoryError`"
msgstr ":c:data:`PyExc_IsADirectoryError`"

msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

msgid ":c:data:`PyExc_KeyError`"
msgstr ":c:data:`PyExc_KeyError`"

msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

msgid ":c:data:`PyExc_KeyboardInterrupt`"
msgstr ":c:data:`PyExc_KeyboardInterrupt`"

msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

msgid ":c:data:`PyExc_LookupError`"
msgstr ":c:data:`PyExc_LookupError`"

msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

msgid ":c:data:`PyExc_MemoryError`"
msgstr ":c:data:`PyExc_MemoryError`"

msgid ":exc:`MemoryError`"
msgstr ":exc:`помилка пам'яті`"

msgid ":c:data:`PyExc_ModuleNotFoundError`"
msgstr ":c:data:`PyExc_ModuleNotFoundError`"

msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

msgid ":c:data:`PyExc_NameError`"
msgstr ":c:data:`PyExc_NameError`"

msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

msgid ":c:data:`PyExc_NotADirectoryError`"
msgstr ":c:data:`PyExc_NotADirectoryError`"

msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

msgid ":c:data:`PyExc_NotImplementedError`"
msgstr ":c:data:`PyExc_NotImplementedError`"

msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

msgid ":c:data:`PyExc_OSError`"
msgstr ":c:data:`PyExc_OSError`"

msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

msgid ":c:data:`PyExc_OverflowError`"
msgstr ":c:data:`PyExc_OverflowError`"

msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

msgid ":c:data:`PyExc_PermissionError`"
msgstr ":c:data:`PyExc_PermissionError`"

msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

msgid ":c:data:`PyExc_ProcessLookupError`"
msgstr ":c:data:`PyExc_ProcessLookupError`"

msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

msgid ":c:data:`PyExc_RecursionError`"
msgstr ":c:data:`PyExc_RecursionError`"

msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

msgid ":c:data:`PyExc_ReferenceError`"
msgstr ":c:data:`PyExc_ReferenceError`"

msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

msgid ":c:data:`PyExc_RuntimeError`"
msgstr ":c:data:`PyExc_RuntimeError`"

msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

msgid ":c:data:`PyExc_StopAsyncIteration`"
msgstr ":c:data:`PyExc_StopAsyncIteration`"

msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

msgid ":c:data:`PyExc_StopIteration`"
msgstr ":c:data:`PyExc_StopIteration`"

msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

msgid ":c:data:`PyExc_SyntaxError`"
msgstr ":c:data:`PyExc_SyntaxError`"

msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

msgid ":c:data:`PyExc_SystemError`"
msgstr ":c:data:`PyExc_SystemError`"

msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

msgid ":c:data:`PyExc_SystemExit`"
msgstr ":c:data:`PyExc_SystemExit`"

msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemError`"

msgid ":c:data:`PyExc_TabError`"
msgstr ":c:data:`PyExc_TabError`"

msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

msgid ":c:data:`PyExc_TimeoutError`"
msgstr ":c:data:`PyExc_TimeoutError`"

msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

msgid ":c:data:`PyExc_TypeError`"
msgstr ":c:data:`PyExc_TypeError`"

msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

msgid ":c:data:`PyExc_UnboundLocalError`"
msgstr ":c:data:`PyExc_UnboundLocalError`"

msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

msgid ":c:data:`PyExc_UnicodeDecodeError`"
msgstr ":c:data:`PyExc_UnicodeDecodeError`"

msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`Помилка UnicodeDecodeError`"

msgid ":c:data:`PyExc_UnicodeEncodeError`"
msgstr ":c:data:`PyExc_UnicodeEncodeError`"

msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

msgid ":c:data:`PyExc_UnicodeError`"
msgstr ":c:data:`PyExc_UnicodeError`"

msgid ":exc:`UnicodeError`"
msgstr ":exc:`Помилка Unicode`"

msgid ":c:data:`PyExc_UnicodeTranslateError`"
msgstr ":c:data:`PyExc_UnicodeTranslateError`"

msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`Помилка UnicodeTranslateError`"

msgid ":c:data:`PyExc_ValueError`"
msgstr ":c:data:`PyExc_ValueError`"

msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

msgid ":c:data:`PyExc_ZeroDivisionError`"
msgstr ":c:data:`PyExc_ZeroDivisionError`"

msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`Помилка ZeroDivisionError`"

msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and :c:data:"
"`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` і :c:data:"
"`PyExc_TimeoutError` були представлені після :pep:`3151`."

msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ":c:data:`PyExc_StopAsyncIteration` і :c:data:`PyExc_RecursionError`."

msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

msgid "These are compatibility aliases to :c:data:`PyExc_OSError`:"
msgstr "Це псевдоніми сумісності з :c:data:`PyExc_OSError`:"

msgid ":c:data:`PyExc_EnvironmentError`"
msgstr ":c:data:`PyExc_EnvironmentError`"

msgid ":c:data:`PyExc_IOError`"
msgstr ":c:data:`PyExc_IOError`"

msgid ":c:data:`PyExc_WindowsError`"
msgstr ":c:data:`PyExc_WindowsError`"

msgid "[2]_"
msgstr "[2]_"

msgid "These aliases used to be separate exception types."
msgstr "Раніше ці псевдоніми були окремими типами винятків."

msgid "Notes:"
msgstr "Примітки:"

msgid "This is a base class for other standard exceptions."
msgstr "Це базовий клас для інших стандартних винятків."

msgid ""
"Only defined on Windows; protect code that uses this by testing that the "
"preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""
"Визначається лише в Windows; захистити код, який використовує це, "
"перевіривши, чи визначено макрос препроцесора ``MS_WINDOWS``."

msgid "Standard Warning Categories"
msgstr "Стандартні категорії попереджень"

msgid ""
"All standard Python warning categories are available as global variables "
"whose names are ``PyExc_`` followed by the Python exception name. These have "
"the type :c:type:`PyObject*`; they are all class objects. For completeness, "
"here are all the variables:"
msgstr ""
"Усі стандартні категорії попереджень Python доступні як глобальні змінні з "
"іменами ``PyExc_``, за якими йде назва винятку Python. Вони мають тип :c:"
"type:`PyObject*`; всі вони є об'єктами класу. Для повноти ось усі змінні:"

msgid ":c:data:`PyExc_Warning`"
msgstr ":c:data:`PyExc_Warning`"

msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

msgid "[3]_"
msgstr "[3]_"

msgid ":c:data:`PyExc_BytesWarning`"
msgstr ":c:data:`PyExc_BytesWarning`"

msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

msgid ":c:data:`PyExc_DeprecationWarning`"
msgstr ":c:data:`PyExc_DeprecationWarning`"

msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

msgid ":c:data:`PyExc_FutureWarning`"
msgstr ":c:data:`PyExc_FutureWarning`"

msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

msgid ":c:data:`PyExc_ImportWarning`"
msgstr ":c:data:`PyExc_ImportWarning`"

msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

msgid ":c:data:`PyExc_PendingDeprecationWarning`"
msgstr ":c:data:`PyExc_PendingDeprecationWarning`"

msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

msgid ":c:data:`PyExc_ResourceWarning`"
msgstr ":c:data:`PyExc_ResourceWarning`"

msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

msgid ":c:data:`PyExc_RuntimeWarning`"
msgstr ":c:data:`PyExc_RuntimeWarning`"

msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

msgid ":c:data:`PyExc_SyntaxWarning`"
msgstr ":c:data:`PyExc_SyntaxWarning`"

msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

msgid ":c:data:`PyExc_UnicodeWarning`"
msgstr ":c:data:`PyExc_UnicodeWarning`"

msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`Попередження Unicode`"

msgid ":c:data:`PyExc_UserWarning`"
msgstr ":c:data:`PyExc_UserWarning`"

msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

msgid "This is a base class for other standard warning categories."
msgstr "Це базовий клас для інших стандартних категорій попереджень."
