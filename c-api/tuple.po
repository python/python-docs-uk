# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../c-api/tuple.rst:6
msgid "Tuple Objects"
msgstr "Кортежні об'єкти"

#: ../../c-api/tuple.rst:13
msgid "This subtype of :c:type:`PyObject` represents a Python tuple object."
msgstr "Цей підтип :c:type:`PyObject` представляє об’єкт кортежу Python."

#: ../../c-api/tuple.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python tuple type; it"
" is the same object as :class:`tuple` in the Python layer."
msgstr ""
"Цей екземпляр :c:type:`PyTypeObject` представляє тип кортежу Python; це той "
"самий об’єкт, що й :class:`tuple` на рівні Python."

#: ../../c-api/tuple.rst:24
msgid ""
"Return true if *p* is a tuple object or an instance of a subtype of the "
"tuple type.  This function always succeeds."
msgstr ""
"Повертає true, якщо *p* є об’єктом кортежу або екземпляром підтипу типу "
"кортежу. Ця функція завжди успішна."

#: ../../c-api/tuple.rst:30
msgid ""
"Return true if *p* is a tuple object, but not an instance of a subtype of "
"the tuple type.  This function always succeeds."
msgstr ""
"Повертає true, якщо *p* є об’єктом кортежу, але не екземпляром підтипу типу "
"кортежу. Ця функція завжди успішна."

#: ../../c-api/tuple.rst:36
msgid ""
"Return a new tuple object of size *len*, or ``NULL`` with an exception set "
"on failure."
msgstr ""

#: ../../c-api/tuple.rst:42
msgid ""
"Return a new tuple object of size *n*, or ``NULL`` with an exception set on "
"failure. The tuple values are initialized to the subsequent *n* C arguments "
"pointing to Python objects. ``PyTuple_Pack(2, a, b)`` is equivalent to "
"``Py_BuildValue(\"(OO)\", a, b)``."
msgstr ""

#: ../../c-api/tuple.rst:50
msgid ""
"Take a pointer to a tuple object, and return the size of that tuple. On "
"error, return ``-1`` and with an exception set."
msgstr ""

#: ../../c-api/tuple.rst:56
msgid "Like :c:func:`PyTuple_Size`, but without error checking."
msgstr ""

#: ../../c-api/tuple.rst:61
msgid ""
"Return the object at position *pos* in the tuple pointed to by *p*.  If "
"*pos* is negative or out of bounds, return ``NULL`` and set an "
":exc:`IndexError` exception."
msgstr ""
"Повертає об’єкт у позицію *pos* у кортежі, на який вказує *p*. Якщо *pos* є "
"негативним або виходить за межі, поверніть ``NULL`` і встановіть виняток "
":exc:`IndexError`."

#: ../../c-api/tuple.rst:64
msgid ""
"The returned reference is borrowed from the tuple *p* (that is: it is only "
"valid as long as you hold a reference to *p*). To get a :term:`strong "
"reference`, use :c:func:`Py_NewRef(PyTuple_GetItem(...)) <Py_NewRef>` or "
":c:func:`PySequence_GetItem`."
msgstr ""

#: ../../c-api/tuple.rst:73
msgid "Like :c:func:`PyTuple_GetItem`, but does no checking of its arguments."
msgstr "Як :c:func:`PyTuple_GetItem`, але не перевіряє його аргументи."

#: ../../c-api/tuple.rst:78
msgid ""
"Return the slice of the tuple pointed to by *p* between *low* and *high*, or"
" ``NULL`` with an exception set on failure."
msgstr ""

#: ../../c-api/tuple.rst:81
msgid ""
"This is the equivalent of the Python expression ``p[low:high]``. Indexing "
"from the end of the tuple is not supported."
msgstr ""

#: ../../c-api/tuple.rst:87
msgid ""
"Insert a reference to object *o* at position *pos* of the tuple pointed to "
"by *p*.  Return ``0`` on success.  If *pos* is out of bounds, return ``-1`` "
"and set an :exc:`IndexError` exception."
msgstr ""
"Вставте посилання на об’єкт *o* у позиції *pos* кортежу, на який вказує *p*."
" У разі успіху повертає ``0``. Якщо *pos* виходить за межі, поверніть ``-1``"
" і встановіть виняток :exc:`IndexError`."

#: ../../c-api/tuple.rst:93
msgid ""
"This function \"steals\" a reference to *o* and discards a reference to an "
"item already in the tuple at the affected position."
msgstr ""
"Ця функція \"викрадає\" посилання на *o* та відкидає посилання на елемент, "
"який уже міститься в кортежі в ураженій позиції."

#: ../../c-api/tuple.rst:99
msgid ""
"Like :c:func:`PyTuple_SetItem`, but does no error checking, and should "
"*only* be used to fill in brand new tuples."
msgstr ""
"Подібно до :c:func:`PyTuple_SetItem`, але не перевіряє помилки, і його слід "
"використовувати *лише* для заповнення абсолютно нових кортежів."

#: ../../c-api/tuple.rst:102 ../../c-api/tuple.rst:218
#: ../../c-api/tuple.rst:236
msgid ""
"Bounds checking is performed as an assertion if Python is built in "
":ref:`debug mode <debug-build>` or :option:`with assertions <--with-"
"assertions>`."
msgstr ""

#: ../../c-api/tuple.rst:107
msgid ""
"This function \"steals\" a reference to *o*, and, unlike "
":c:func:`PyTuple_SetItem`, does *not* discard a reference to any item that "
"is being replaced; any reference in the tuple at position *pos* will be "
"leaked."
msgstr ""

#: ../../c-api/tuple.rst:115
msgid ""
"Can be used to resize a tuple.  *newsize* will be the new length of the "
"tuple. Because tuples are *supposed* to be immutable, this should only be "
"used if there is only one reference to the object.  Do *not* use this if the"
" tuple may already be known to some other part of the code.  The tuple will "
"always grow or shrink at the end.  Think of this as destroying the old tuple"
" and creating a new one, only more efficiently.  Returns ``0`` on success. "
"Client code should never assume that the resulting value of ``*p`` will be "
"the same as before calling this function. If the object referenced by ``*p``"
" is replaced, the original ``*p`` is destroyed.  On failure, returns ``-1`` "
"and sets ``*p`` to ``NULL``, and raises :exc:`MemoryError` or "
":exc:`SystemError`."
msgstr ""
"Можна використовувати для зміни розміру кортежу. *newsize* буде новою "
"довжиною кортежу. Оскільки кортежі *вважаються* незмінними, це слід "
"використовувати, лише якщо є лише одне посилання на об’єкт. *Не* "
"використовуйте це, якщо кортеж може бути вже відомий іншій частині коду. "
"Кортеж завжди зростатиме або зменшуватиметься в кінці. Думайте про це як про"
" знищення старого кортежу та створення нового, але більш ефективного. У разі"
" успіху повертає ``0``. Клієнтський код ніколи не повинен вважати, що "
"результуюче значення ``*p`` буде таким самим, як і до виклику цієї функції. "
"Якщо об’єкт, на який посилається ``*p``, замінюється, оригінальний ``*p`` "
"знищується. У разі помилки повертає ``-1`` і встановлює ``*p`` значення "
"``NULL`` і викликає :exc:`MemoryError` або :exc:`SystemError`."

#: ../../c-api/tuple.rst:130
msgid "Struct Sequence Objects"
msgstr "Структуруйте об’єкти послідовності"

#: ../../c-api/tuple.rst:132
msgid ""
"Struct sequence objects are the C equivalent of "
":func:`~collections.namedtuple` objects, i.e. a sequence whose items can "
"also be accessed through attributes. To create a struct sequence, you first "
"have to create a specific struct sequence type."
msgstr ""
"Об’єкти послідовності структур є еквівалентом C об’єктів "
":func:`~collections.namedtuple`, тобто послідовності, до елементів якої "
"також можна отримати доступ через атрибути. Щоб створити послідовність "
"структур, спочатку потрібно створити певний тип послідовності структур."

#: ../../c-api/tuple.rst:139
msgid ""
"Create a new struct sequence type from the data in *desc*, described below. "
"Instances of the resulting type can be created with "
":c:func:`PyStructSequence_New`."
msgstr ""
"Створіть новий тип послідовності структур із даних у *desc*, як описано "
"нижче. Екземпляри отриманого типу можна створити за допомогою "
":c:func:`PyStructSequence_New`."

#: ../../c-api/tuple.rst:142 ../../c-api/tuple.rst:211
msgid "Return ``NULL`` with an exception set on failure."
msgstr ""

#: ../../c-api/tuple.rst:147
msgid "Initializes a struct sequence type *type* from *desc* in place."
msgstr "Ініціалізує структурну послідовність типу *type* з *desc* на місці."

#: ../../c-api/tuple.rst:152
msgid ""
"Like :c:func:`PyStructSequence_InitType`, but returns ``0`` on success and "
"``-1`` with an exception set on failure."
msgstr ""

#: ../../c-api/tuple.rst:160
msgid "Contains the meta information of a struct sequence type to create."
msgstr ""
"Містить метаінформацію типу послідовності структур, яку потрібно створити."

#: ../../c-api/tuple.rst:164
msgid ""
"Fully qualified name of the type; null-terminated UTF-8 encoded. The name "
"must contain the module name."
msgstr ""

#: ../../c-api/tuple.rst:169
msgid "Pointer to docstring for the type or ``NULL`` to omit."
msgstr ""

#: ../../c-api/tuple.rst:173
msgid "Pointer to ``NULL``-terminated array with field names of the new type."
msgstr ""

#: ../../c-api/tuple.rst:177
msgid "Number of fields visible to the Python side (if used as tuple)."
msgstr ""

#: ../../c-api/tuple.rst:182
msgid ""
"Describes a field of a struct sequence. As a struct sequence is modeled as a"
" tuple, all fields are typed as :c:expr:`PyObject*`.  The index in the "
":c:member:`~PyStructSequence_Desc.fields` array of the "
":c:type:`PyStructSequence_Desc` determines which field of the struct "
"sequence is described."
msgstr ""

#: ../../c-api/tuple.rst:190
msgid ""
"Name for the field or ``NULL`` to end the list of named fields, set to "
":c:data:`PyStructSequence_UnnamedField` to leave unnamed."
msgstr ""

#: ../../c-api/tuple.rst:195
msgid "Field docstring or ``NULL`` to omit."
msgstr ""

#: ../../c-api/tuple.rst:200
msgid "Special value for a field name to leave it unnamed."
msgstr "Спеціальне значення для імені поля, щоб залишити його без імені."

#: ../../c-api/tuple.rst:202
msgid "The type was changed from ``char *``."
msgstr "Тип змінено з ``char *``."

#: ../../c-api/tuple.rst:208
msgid ""
"Creates an instance of *type*, which must have been created with "
":c:func:`PyStructSequence_NewType`."
msgstr ""
"Створює екземпляр *type*, який має бути створено за допомогою "
":c:func:`PyStructSequence_NewType`."

#: ../../c-api/tuple.rst:216
msgid ""
"Return the object at position *pos* in the struct sequence pointed to by "
"*p*."
msgstr ""

#: ../../c-api/tuple.rst:224
msgid "Alias to :c:func:`PyStructSequence_GetItem`."
msgstr ""

#: ../../c-api/tuple.rst:226
msgid "Now implemented as an alias to :c:func:`PyStructSequence_GetItem`."
msgstr ""

#: ../../c-api/tuple.rst:232
msgid ""
"Sets the field at index *pos* of the struct sequence *p* to value *o*.  Like"
" :c:func:`PyTuple_SET_ITEM`, this should only be used to fill in brand new "
"instances."
msgstr ""
"Встановлює поле за індексом *pos* послідовності структур *p* на значення "
"*o*. Як і :c:func:`PyTuple_SET_ITEM`, це слід використовувати лише для "
"заповнення абсолютно нових екземплярів."

#: ../../c-api/tuple.rst:241
msgid "This function \"steals\" a reference to *o*."
msgstr "Ця функція \"краде\" посилання на *o*."

#: ../../c-api/tuple.rst:246
msgid "Alias to :c:func:`PyStructSequence_SetItem`."
msgstr ""

#: ../../c-api/tuple.rst:248
msgid "Now implemented as an alias to :c:func:`PyStructSequence_SetItem`."
msgstr ""

#: ../../c-api/tuple.rst:8
msgid "object"
msgstr "об'єкт"

#: ../../c-api/tuple.rst:8
msgid "tuple"
msgstr "кортеж"
