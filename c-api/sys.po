# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Operating System Utilities"
msgstr "Утиліти операційної системи"

msgid ""
"Return the file system representation for *path*. If the object is a :class:"
"`str` or :class:`bytes` object, then its reference count is incremented. If "
"the object implements the :class:`os.PathLike` interface, then :meth:`~os."
"PathLike.__fspath__` is returned as long as it is a :class:`str` or :class:"
"`bytes` object. Otherwise :exc:`TypeError` is raised and ``NULL`` is "
"returned."
msgstr ""
"Повертає представлення файлової системи для *шляху*. Якщо об’єкт є об’єктом :"
"class:`str` або :class:`bytes`, то його кількість посилань збільшується. "
"Якщо об’єкт реалізує інтерфейс :class:`os.PathLike`, тоді :meth:`~os."
"PathLike.__fspath__` повертається, якщо це об’єкт :class:`str` або :class:"
"`bytes`. В іншому випадку виникає :exc:`TypeError` і повертається ``NULL``."

msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* is "
"deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the global flag :c:data:"
"`Py_InteractiveFlag` is true, this function also returns true if the "
"*filename* pointer is ``NULL`` or if the name is equal to one of the strings "
"``'<stdin>'`` or ``'???'``."
msgstr ""
"Повертає істину (не нуль), якщо стандартний файл вводу-виводу *fp* з іменем "
"*filename* вважається інтерактивним. Це стосується файлів, для яких "
"isatty(fileno(fp)) має значення true. Якщо глобальний прапор :c:data:"
"`Py_InteractiveFlag` має значення true, ця функція також повертає значення "
"true, якщо покажчик *filename* має значення ``NULL`` або якщо ім’я дорівнює "
"одному з рядків ``' <stdin> ''`` або ``'???''``."

msgid ""
"Function to prepare some internal state before a process fork.  This should "
"be called before calling :c:func:`fork` or any similar function that clones "
"the current process. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Функція для підготовки деякого внутрішнього стану перед розгалуженням "
"процесу. Це слід викликати перед викликом :c:func:`fork` або будь-якої "
"подібної функції, яка клонує поточний процес. Доступно лише в системах, де "
"визначено :c:func:`fork`."

msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"Виклик C :c:func:`fork` має здійснюватися лише з :ref:`\"main\" потоку <fork-"
"and-threads>` (з :ref:`\"main\" інтерпретатора <sub-interpreter-support>`). "
"Те саме стосується ``PyOS_BeforeFork()``."

msgid ""
"Function to update some internal state after a process fork.  This should be "
"called from the parent process after calling :c:func:`fork` or any similar "
"function that clones the current process, regardless of whether process "
"cloning was successful. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Функція для оновлення деякого внутрішнього стану після розгалуження процесу. "
"Це слід викликати з батьківського процесу після виклику :c:func:`fork` або "
"будь-якої подібної функції, яка клонує поточний процес, незалежно від того, "
"чи клонування процесу було успішним. Доступно лише в системах, де визначено :"
"c:func:`fork`."

msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Parent()``."
msgstr ""
"Виклик C :c:func:`fork` має здійснюватися лише з :ref:`\"main\" потоку <fork-"
"and-threads>` (з :ref:`\"main\" інтерпретатора <sub-interpreter-support>`). "
"Те саме стосується ``PyOS_AfterFork_Parent()``."

msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or any "
"similar function that clones the current process, if there is any chance the "
"process will call back into the Python interpreter. Only available on "
"systems where :c:func:`fork` is defined."
msgstr ""
"Функція для оновлення стану внутрішнього інтерпретатора після розгалуження "
"процесу. Це має бути викликано з дочірнього процесу після виклику :c:func:"
"`fork` або будь-якої подібної функції, яка клонує поточний процес, якщо є "
"шанс, що процес знову викличе інтерпретатор Python. Доступно лише в "
"системах, де визначено :c:func:`fork`."

msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"Виклик C :c:func:`fork` має здійснюватися лише з :ref:`\"main\" потоку <fork-"
"and-threads>` (з :ref:`\"main\" інтерпретатора <sub-interpreter-support>`). "
"Те саме стосується ``PyOS_AfterFork_Child()``."

msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to be "
"called by :c:func:`PyOS_BeforeFork()`, :c:func:`PyOS_AfterFork_Parent` and  :"
"c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork` дозволяє реєструвати користувацькі функції "
"Python для виклику :c:func:`PyOS_BeforeFork()`, :c:func:"
"`PyOS_AfterFork_Parent` і :c:func:`PyOS_AfterFork_Child`."

msgid ""
"Function to update some internal state after a process fork; this should be "
"called in the new process if the Python interpreter will continue to be "
"used. If a new executable is loaded into the new process, this function does "
"not need to be called."
msgstr ""
"Функція для оновлення деякого внутрішнього стану після розгалуження процесу; "
"це слід викликати в новому процесі, якщо інтерпретатор Python продовжуватиме "
"використовуватися. Якщо новий виконуваний файл завантажується в новий "
"процес, цю функцію не потрібно викликати."

msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "Цю функцію замінює :c:func:`PyOS_AfterFork_Child()`."

msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :const:`USE_STACKCHECK` is "
"defined (currently on Windows using the Microsoft Visual C++ compiler).  :"
"const:`USE_STACKCHECK` will be defined automatically; you should never "
"change the definition in your own code."
msgstr ""

msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper "
"around either :c:func:`sigaction` or :c:func:`signal`.  Do not call those "
"functions directly! :c:type:`PyOS_sighandler_t` is a typedef alias for :c:"
"type:`void (\\*)(int)`."
msgstr ""
"Повертає поточний обробник сигналу для сигналу *i*. Це тонка обгортка "
"навколо :c:func:`sigaction` або :c:func:`signal`. Не викликайте ці функції "
"безпосередньо! :c:type:`PyOS_sighandler_t` є псевдонімом typedef для :c:type:"
"`void (\\*)(int)`."

msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`sigaction` or :c:func:"
"`signal`.  Do not call those functions directly!  :c:type:"
"`PyOS_sighandler_t` is a typedef alias for :c:type:`void (\\*)(int)`."
msgstr ""
"Встановіть обробник сигналу *i* на *h*; повернути старий обробник сигналів. "
"Це тонка обгортка навколо :c:func:`sigaction` або :c:func:`signal`. Не "
"викликайте ці функції безпосередньо! :c:type:`PyOS_sighandler_t` є "
"псевдонімом typedef для :c:type:`void (\\*)(int)`."

msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` API "
"with the :c:func:`PyConfig_SetBytesString` function which ensures that :ref:"
"`Python is preinitialized <c-preinit>`."
msgstr ""
"Цю функцію не слід викликати безпосередньо: використовуйте :c:type:"
"`PyConfig` API з функцією :c:func:`PyConfig_SetBytesString`, яка гарантує, "
"що :ref:`Python попередньо ініціалізовано <c-preinit>`."

msgid ""
"This function must not be called before :ref:`Python is preinitialized <c-"
"preinit>` and so that the LC_CTYPE locale is properly configured: see the :c:"
"func:`Py_PreInitialize` function."
msgstr ""
"Цю функцію не можна викликати до :ref:`Python попередньо ініціалізовано <c-"
"preinit>` і щоб локаль LC_CTYPE була правильно налаштована: див. функцію :c:"
"func:`Py_PreInitialize`."

msgid ""
"Decode a byte string from the :term:`filesystem encoding and error handler`. "
"If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
"Декодуйте рядок байтів із :term:`filesystem encoding and error handler`. "
"Якщо обробником помилок є :ref:`surrogateescape error handler "
"<surrogateescape>`, недекодовані байти декодуються як символи в діапазоні "
"U+DC80..U+DCFF; і якщо послідовність байтів може бути декодована як "
"сурогатний символ, байти екрануються за допомогою обробника помилок "
"surrogateescape замість їх декодування."

msgid ""
"Return a pointer to a newly allocated wide character string, use :c:func:"
"`PyMem_RawFree` to free the memory. If size is not ``NULL``, write the "
"number of wide characters excluding the null character into ``*size``"
msgstr ""
"Поверніть вказівник на щойно виділений широкий рядок символів, "
"використовуйте :c:func:`PyMem_RawFree`, щоб звільнити пам’ять. Якщо розмір "
"не дорівнює ``NULL``, запишіть кількість широких символів, за винятком "
"нульового символу, у ``*size``"

msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* is "
"not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to "
"``(size_t)-2`` on decoding error."
msgstr ""
"Повертає ``NULL`` у разі помилки декодування або помилки виділення пам'яті. "
"Якщо *size* не дорівнює ``NULL``, ``*size`` встановлюється на ``(size_t)-1`` "
"у разі помилки пам’яті або встановлюється на ``(size_t)-2`` у разі помилки "
"декодування."

msgid ""
"The :term:`filesystem encoding and error handler` are selected by :c:func:"
"`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and :c:member:"
"`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` вибираються :c:func:"
"`PyConfig_Read`: див. члени :c:member:`~PyConfig.filesystem_encoding` і :c:"
"member:`~PyConfig.filesystem_errors` :c:type:`PyConfig`."

msgid ""
"Decoding errors should never happen, unless there is a bug in the C library."
msgstr ""
"Помилки декодування ніколи не повинні траплятися, якщо немає помилки в "
"бібліотеці C."

msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string "
"back to a byte string."
msgstr ""
"Використовуйте функцію :c:func:`Py_EncodeLocale`, щоб закодувати рядок "
"символів назад у рядок байтів."

msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and :c:func:"
"`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
"Функції :c:func:`PyUnicode_DecodeFSDefaultAndSize` і :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."

msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr ""
"Тепер функція використовує кодування UTF-8 у режимі :ref:`Python UTF-8 Mode "
"<utf8-mode>`."

msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` is zero;"
msgstr ""
"Функція тепер використовує кодування UTF-8 у Windows, якщо :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` дорівнює нулю;"

msgid ""
"Encode a wide character string to the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are "
"converted to bytes 0x80..0xFF."
msgstr ""
"Закодуйте широкий рядок символів у :term:`filesystem encoding and error "
"handler`. Якщо обробником помилок є :ref:`surrogateescape error handler "
"<surrogateescape>`, сурогатні символи в діапазоні U+DC80..U+DCFF "
"перетворюються на байти 0x80..0xFF."

msgid ""
"Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free` "
"to free the memory. Return ``NULL`` on encoding error or memory allocation "
"error."
msgstr ""
"Поверніть вказівник на щойно виділений рядок байтів, використовуйте :c:func:"
"`PyMem_Free`, щоб звільнити пам’ять. Повертає ``NULL`` у разі помилки "
"кодування або помилки виділення пам'яті."

msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"Якщо error_pos не дорівнює ``NULL``, ``*error_pos`` встановлюється на "
"``(size_t)-1`` у разі успіху або встановлюється на індекс недійсного символу "
"в разі помилки кодування."

msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back "
"to a wide character string."
msgstr ""
"Використовуйте функцію :c:func:`Py_DecodeLocale`, щоб декодувати рядок "
"байтів назад до широкого рядка символів."

msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and :c:func:`PyUnicode_EncodeLocale` "
"functions."
msgstr ""
"Функції :c:func:`PyUnicode_EncodeFSDefault` і :c:func:"
"`PyUnicode_EncodeLocale`."

msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` is zero."
msgstr ""
"Функція тепер використовує кодування UTF-8 у Windows, якщо :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` дорівнює нулю."

msgid "System Functions"
msgstr "Системні функції"

msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal thread "
"state structure."
msgstr ""
"Це службові функції, які роблять функціональні можливості модуля :mod:`sys` "
"доступними для коду C. Усі вони працюють із dict модуля :mod:`sys` поточного "
"потоку інтерпретатора, який міститься у внутрішній структурі стану потоку."

msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it does "
"not exist, without setting an exception."
msgstr ""
"Повертає *ім’я* об’єкта з модуля :mod:`sys` або ``NULL``, якщо він не існує, "
"без встановлення винятку."

msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which "
"case *name* is deleted from the sys module. Returns ``0`` on success, ``-1`` "
"on error."
msgstr ""
"Встановіть *name* у модулі :mod:`sys` на *v*, якщо *v* не має значення "
"``NULL``, у цьому випадку *name* буде видалено з модуля sys. Повертає ``0`` "
"у разі успіху, ``-1`` у разі помилки."

msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be called "
"prior to :c:func:`Py_Initialize`."
msgstr ""
"Скинути :data:`sys.warnoptions` до порожнього списку. Цю функцію можна "
"викликати перед :c:func:`Py_Initialize`."

msgid ""
"Append *s* to :data:`sys.warnoptions`. This function must be called prior "
"to :c:func:`Py_Initialize` in order to affect the warnings filter list."
msgstr ""
"Додайте *s* до :data:`sys.warnoptions`. Цю функцію потрібно викликати перед :"
"c:func:`Py_Initialize`, щоб вплинути на список фільтрів попереджень."

msgid "Append *unicode* to :data:`sys.warnoptions`."
msgstr "Додайте *unicode* до :data:`sys.warnoptions`."

msgid ""
"Note: this function is not currently usable from outside the CPython "
"implementation, as it must be called prior to the implicit import of :mod:"
"`warnings` in :c:func:`Py_Initialize` to be effective, but can't be called "
"until enough of the runtime has been initialized to permit the creation of "
"Unicode objects."
msgstr ""
"Примітка: цю функцію наразі не можна використовувати поза межами реалізації "
"CPython, оскільки її потрібно викликати перед неявним імпортом :mod:"
"`warnings` у :c:func:`Py_Initialize`, щоб вона була ефективною, але її не "
"можна викликати поки не буде ініціалізовано достатньо часу виконання, щоб "
"дозволити створення об’єктів Unicode."

msgid ""
"Set :data:`sys.path` to a list object of paths found in *path* which should "
"be a list of paths separated with the platform's search path delimiter (``:"
"`` on Unix, ``;`` on Windows)."
msgstr ""
"Встановіть :data:`sys.path` на об’єкт списку шляхів, знайдених у *path*, "
"який має бути списком шляхів, розділених роздільником шляху пошуку платформи "
"(``:`` в Unix, ``;`` у Windows )."

msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr ""
"Запишіть вихідний рядок, описаний *format*, у :data:`sys.stdout`. Ніяких "
"винятків не викликається, навіть якщо відбувається скорочення (див. нижче)."

msgid ""
"*format* should limit the total size of the formatted output string to 1000 "
"bytes or less -- after 1000 bytes, the output string is truncated. In "
"particular, this means that no unrestricted \"%s\" formats should occur; "
"these should be limited using \"%.<N>s\" where <N> is a decimal number "
"calculated so that <N> plus the maximum size of other formatted text does "
"not exceed 1000 bytes.  Also watch out for \"%f\", which can print hundreds "
"of digits for very large numbers."
msgstr ""
"*format* має обмежувати загальний розмір відформатованого вихідного рядка до "
"1000 байтів або менше -- після 1000 байтів вихідний рядок скорочується. "
"Зокрема, це означає, що необмежені формати \"%s\" не повинні відбуватися; їх "
"слід обмежити за допомогою \"%. <N> s\", де <N> — це десяткове число, "
"обчислене таким чином, що <N> плюс максимальний розмір іншого "
"відформатованого тексту не перевищує 1000 байт. Також слідкуйте за \"%f\", "
"який може друкувати сотні цифр для дуже великих чисел."

msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted message "
"is written to the real (C level) *stdout*."
msgstr ""
"Якщо виникає проблема або :data:`sys.stdout` не налаштовано, форматоване "
"повідомлення записується в реальний (рівень C) *stdout*."

msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Як :c:func:`PySys_WriteStdout`, але натомість записуйте в :data:`sys.stderr` "
"або *stderr*."

msgid ""
"Function similar to PySys_WriteStdout() but format the message using :c:func:"
"`PyUnicode_FromFormatV` and don't truncate the message to an arbitrary "
"length."
msgstr ""
"Функція схожа на PySys_WriteStdout(), але форматує повідомлення за "
"допомогою :c:func:`PyUnicode_FromFormatV` і не скорочує повідомлення до "
"довільної довжини."

msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Як :c:func:`PySys_FormatStdout`, але замість цього записуйте в :data:`sys."
"stderr` або *stderr*."

msgid ""
"Parse *s* as a set of :option:`-X` options and add them to the current "
"options mapping as returned by :c:func:`PySys_GetXOptions`. This function "
"may be called prior to :c:func:`Py_Initialize`."
msgstr ""
"Проаналізуйте *s* як набір параметрів :option:`-X` і додайте їх до поточного "
"відображення параметрів, як повертає :c:func:`PySys_GetXOptions`. Цю функцію "
"можна викликати перед :c:func:`Py_Initialize`."

msgid ""
"Return the current dictionary of :option:`-X` options, similarly to :data:"
"`sys._xoptions`.  On error, ``NULL`` is returned and an exception is set."
msgstr ""
"Повертає поточний словник параметрів :option:`-X`, подібно до :data:`sys."
"_xoptions`. У разі помилки повертається ``NULL`` і встановлюється виняток."

msgid ""
"Raise an auditing event with any active hooks. Return zero for success and "
"non-zero with an exception set on failure."
msgstr ""
"Викликати подію аудиту з будь-якими активними хуками. Повертає нуль у разі "
"успіху та відмінний від нуля з винятком, встановленим у випадку невдачі."

msgid ""
"If any hooks have been added, *format* and other arguments will be used to "
"construct a tuple to pass. Apart from ``N``, the same format characters as "
"used in :c:func:`Py_BuildValue` are available. If the built value is not a "
"tuple, it will be added into a single-element tuple. (The ``N`` format "
"option consumes a reference, but since there is no way to know whether "
"arguments to this function will be consumed, using it may cause reference "
"leaks.)"
msgstr ""
"Якщо додано будь-які хуки, *format* та інші аргументи будуть використані для "
"створення кортежу для передачі. Крім ``N``, доступні символи того самого "
"формату, що використовуються в :c:func:`Py_BuildValue`. Якщо побудоване "
"значення не є кортежем, його буде додано до одноелементного кортежу. "
"(Параметр формату ``N`` використовує посилання, але оскільки немає способу "
"дізнатися, чи будуть використані аргументи цієї функції, його використання "
"може спричинити витік посилань.)"

msgid ""
"Note that ``#`` format characters should always be treated as :c:type:"
"`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was defined."
msgstr ""
"Зауважте, що символи формату ``#`` завжди слід розглядати як :c:type:"
"`Py_ssize_t`, незалежно від того, чи було визначено ``PY_SSIZE_T_CLEAN``."

msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit` виконує ту саму функцію з коду Python."

msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr ""
"Вимагати :c:type:`Py_ssize_t` для символів формату ``#``. Раніше виникало "
"неминуче попередження про застарілу версію."

msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return zero "
"on success and non-zero on failure. If the runtime has been initialized, "
"also set an error on failure. Hooks added through this API are called for "
"all interpreters created by the runtime."
msgstr ""
"Додайте *хук*, який можна викликати, до списку активних хуків аудиту. "
"Повертає нуль у разі успіху та ненуль у разі невдачі. Якщо середовище "
"виконання було ініціалізовано, також установіть помилку в разі помилки. "
"Хуки, додані через цей API, викликаються для всіх інтерпретаторів, створених "
"середовищем виконання."

msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr ""
"Покажчик *userData* передається в функцію-перехоплювач. Оскільки функції "
"підключення можуть викликатися з різних середовищ виконання, цей вказівник "
"не повинен посилатися безпосередньо на стан Python."

msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called "
"after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from :class:"
"`Exception` (other errors will not be silenced)."
msgstr ""
"Цю функцію безпечно викликати перед :c:func:`Py_Initialize`. Під час виклику "
"після ініціалізації середовища виконання наявні перехоплювачі аудиту "
"отримують сповіщення та можуть мовчки перервати операцію, викликавши помилку "
"підкласу з :class:`Exception` (інші помилки не будуть заглушені)."

msgid ""
"The hook function is of type :c:type:`int (*)(const char *event, PyObject "
"*args, void *userData)`, where *args* is guaranteed to be a :c:type:"
"`PyTupleObject`. The hook function is always called with the GIL held by the "
"Python interpreter that raised the event."
msgstr ""
"Функція підключення має тип :c:type:`int (*)(const char *event, PyObject "
"*args, void *userData)`, де *args* гарантовано буде :c:type:`PyTupleObject`. "
"Функція підключення завжди викликається з GIL, що зберігається "
"інтерпретатором Python, який викликав подію."

msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the :ref:`audit "
"events table <audit-events>`. Details are in each function's documentation."
msgstr ""
"Дивіться :pep:`578` для детального опису аудиту. Функції середовища "
"виконання та стандартної бібліотеки, які викликають події, перераховані в :"
"ref:`таблиці подій аудиту <audit-events>`. Подробиці наведено в документації "
"кожної функції."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.addaudithook`` with no "
"arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``sys.addaudithook`` без аргументів."

msgid ""
"If the interpreter is initialized, this function raises a auditing event "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added "
"and the exception is cleared. As a result, callers cannot assume that their "
"hook has been added unless they control all existing hooks."
msgstr ""
"Якщо інтерпретатор ініціалізовано, ця функція викликає подію аудиту ``sys."
"addaudithook`` без аргументів. Якщо будь-які існуючі хуки викликають "
"виняток, отриманий від :class:`Exception`, новий хук не буде додано, а "
"виняток буде очищено. Як наслідок, абоненти не можуть вважати, що їхній "
"підхоплювач додано, якщо вони не контролюють усі існуючі підхоплення."

msgid "Process Control"
msgstr "Контроль процесів"

msgid ""
"Print a fatal error message and kill the process.  No cleanup is performed. "
"This function should only be invoked when a condition is detected that would "
"make it dangerous to continue using the Python interpreter; e.g., when the "
"object administration appears to be corrupted.  On Unix, the standard C "
"library function :c:func:`abort` is called which will attempt to produce a :"
"file:`core` file."
msgstr ""
"Надрукуйте повідомлення про фатальну помилку та завершіть процес. Очищення "
"не виконується. Цю функцію слід викликати лише тоді, коли виявлено стан, "
"який може зробити небезпечним продовження використання інтерпретатора "
"Python; наприклад, коли адміністрування об’єкта виглядає пошкодженим. В Unix "
"викликається стандартна функція бібліотеки C :c:func:`abort`, яка "
"намагатиметься створити файл :file:`core`."

msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
"Функцію ``Py_FatalError()`` замінено макросом, який автоматично реєструє "
"назву поточної функції, якщо не визначено макрос ``Py_LIMITED_API``."

msgid "Log the function name automatically."
msgstr "Автоматично реєструйте назву функції."

msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls "
"the standard C library function ``exit(status)``.  If :c:func:"
"`Py_FinalizeEx` indicates an error, the exit status is set to 120."
msgstr ""
"Вийти з поточного процесу. Це викликає :c:func:`Py_FinalizeEx`, а потім "
"викликає стандартну функцію бібліотеки C ``exit(status)``. Якщо :c:func:"
"`Py_FinalizeEx` вказує на помилку, статус виходу встановлюється на 120."

msgid "Errors from finalization no longer ignored."
msgstr "Помилки під час фіналізації більше не ігноруються."

msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The "
"cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on failure, "
"it returns ``-1``.  The cleanup function registered last is called first. "
"Each cleanup function will be called at most once.  Since Python's internal "
"finalization will have completed before the cleanup function, no Python APIs "
"should be called by *func*."
msgstr ""
"Зареєструйте функцію очищення, яку буде викликати :c:func:`Py_FinalizeEx`. "
"Функція очищення буде викликана без аргументів і не повинна повертати "
"значення. Можна зареєструвати щонайбільше 32 функції очищення. Після "
"успішної реєстрації :c:func:`Py_AtExit` повертає ``0``; у разі помилки "
"повертає ``-1``. Першою викликається функція очищення, зареєстрована "
"останньою. Кожна функція очищення буде викликана щонайбільше один раз. "
"Оскільки внутрішня фіналізація Python буде завершена до виконання функції "
"очищення, жодні API Python не повинні викликатися за допомогою *func*."
