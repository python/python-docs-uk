# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Compound statements"
msgstr "Складені висловлювання"

msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Складені висловлювання містять (групи) інші висловлювання; вони певним чином "
"впливають або контролюють виконання цих інших операторів. Загалом складені "
"висловлювання охоплюють кілька рядків, хоча в простих варіантах ціле "
"складене висловлювання може міститися в одному рядку."

msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Оператори :keyword:`if`, :keyword:`while` і :keyword:`for` реалізують "
"традиційні конструкції потоку керування. :keyword:`try` визначає обробники "
"винятків та/або код очищення для групи операторів, тоді як оператор :keyword:"
"`with` дозволяє виконувати код ініціалізації та фіналізації навколо блоку "
"коду. Визначення функцій і класів також є синтаксично складеними "
"висловлюваннями."

msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Складений оператор складається з одного або кількох \"речень\". Речення "
"складається із заголовка та \"набору\". Усі заголовки речень певного "
"складеного оператора мають однаковий рівень відступу. Кожен заголовок "
"пропозиції починається з унікального ключового слова та закінчується "
"двокрапкою. Набір — це група висловлювань, керованих реченням. Набір може "
"складатися з одного або кількох простих операторів, розділених крапкою з "
"комою, у тому самому рядку, що й заголовок, після двокрапки заголовка, або "
"це може бути один чи більше операторів із відступом у наступних рядках. Лише "
"остання форма набору може містити вкладені складені оператори; наступне є "
"незаконним, здебільшого тому, що було б незрозуміло, до якого пункту :"
"keyword:`if` належало б таке положення :keyword:`else`::"

msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Також зауважте, що в цьому контексті крапка з комою зв’язується сильніше, "
"ніж двокрапка, тому в наступному прикладі виконуються або всі, або жоден із "
"викликів :func:`print`::"

msgid "Summarizing:"
msgstr "Підведення підсумків:"

msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Зауважте, що оператори завжди закінчуються на ``NEWLINE``, після якого, "
"можливо, йде ``DEDENT``. Також зауважте, що необов’язкові речення "
"продовження завжди починаються з ключового слова, яке не може розпочинати "
"оператор, тому немає ніяких двозначностей (проблему \"висячих :keyword:"
"`else`\" вирішено в Python, вимагаючи вкладених операторів :keyword:`if` з "
"відступом)."

msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"Форматування правил граматики в наступних розділах розміщує кожне речення в "
"окремому рядку для ясності."

msgid "The :keyword:`!if` statement"
msgstr "Оператор :keyword:`!if`"

msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "Оператор :keyword:`if` використовується для умовного виконання:"

msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Він вибирає точно один із наборів, обчислюючи вирази один за іншим, доки "
"один не буде визнаний істинним (див. розділ :ref:`booleans` для визначення "
"істинного та хибного); тоді цей набір виконується (і жодна інша частина "
"оператора :keyword:`if` не виконується і не оцінюється). Якщо всі вирази "
"хибні, виконується набір пропозиції :keyword:`else`, якщо вона є."

msgid "The :keyword:`!while` statement"
msgstr "Оператор :keyword:`!while`"

msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"Інструкція :keyword:`while` використовується для повторного виконання, доки "
"вираз є істинним:"

msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Це багаторазово перевіряє вираз і, якщо воно вірне, виконує перший набір; "
"якщо вираз є хибним (що може бути першим, коли його перевіряють), набір "
"пропозиції :keyword:`!else` виконується, і цикл припиняється."

msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"Інструкція :keyword:`break`, виконана в першому наборі, завершує цикл без "
"виконання набору речень :keyword:`!else`. Інструкція :keyword:`continue`, "
"виконана в першому наборі, пропускає решту пакета і повертається до "
"перевірки виразу."

msgid "The :keyword:`!for` statement"
msgstr "Оператор :keyword:`!for`"

msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"Оператор :keyword:`for` використовується для повторення елементів "
"послідовності (таких як рядок, кортеж або список) або іншого ітерованого "
"об’єкта:"

msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`!else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"Список виразів обчислюється один раз; він повинен давати ітерований об’єкт. "
"Для результату ``expression_list`` створюється ітератор. Потім набір "
"виконується один раз для кожного елемента, наданого ітератором, у порядку, "
"який повертає ітератор. Кожен елемент по черзі призначається цільовому "
"списку за допомогою стандартних правил призначення (див. :ref:`assignment`), "
"а потім набір виконується. Коли елементи вичерпуються (тобто відразу, коли "
"послідовність стає порожньою або ітератор викликає виняткову ситуацію :exc:"
"`StopIteration`), виконується набір у реченні :keyword:`!else`, якщо він "
"присутній, і цикл припиняється."

msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"Інструкція :keyword:`break`, виконана в першому наборі, завершує цикл без "
"виконання набору речень :keyword:`!else`. Інструкція :keyword:`continue`, "
"виконана в першому наборі, пропускає решту набору і продовжує з наступним "
"елементом або з пропозицією :keyword:`!else`, якщо наступного елемента немає."

msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"Цикл for виконує призначення змінним у цільовому списку. Це перезаписує всі "
"попередні призначення цим змінним, включаючи ті, що зроблені в наборі циклу "
"for::"

msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"Імена в цільовому списку не видаляються після завершення циклу, але якщо "
"послідовність порожня, вони взагалі не будуть призначені циклом. Підказка: "
"вбудована функція :func:`range` повертає ітератор цілих чисел, придатний для "
"імітації ефекту Pascal ``for i := a to b do``; наприклад, ``list(range(3))`` "
"повертає список ``[0, 1, 2]``."

msgid "The :keyword:`!try` statement"
msgstr "Оператор :keyword:`!try`"

msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"Оператор :keyword:`try` визначає обробники винятків та/або код очищення для "
"групи операторів:"

msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started.  This search inspects the except "
"clauses in turn until one is found that matches the exception.  An "
"expression-less except clause, if present, must be last; it matches any "
"exception.  For an except clause with an expression, that expression is "
"evaluated, and the clause matches the exception if the resulting object is "
"\"compatible\" with the exception.  An object is compatible with an "
"exception if the object is the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or a tuple containing an "
"item that is the class or a non-virtual base class of the exception object."
msgstr ""
"Умова(и) :keyword:`except` визначає один або більше обробників винятків. "
"Якщо в реченні :keyword:`try` не виникає жодного винятку, обробник винятків "
"не виконується. Коли в наборі :keyword:`!try` виникає виняткова ситуація, "
"починається пошук обробника виняткової ситуації. Цей пошук перевіряє "
"пропозиції винятків по черзі, поки не буде знайдено те, що відповідає "
"винятку. Речення без виразу, крім, якщо воно присутнє, має бути останнім; "
"він відповідає будь-якому винятку. Для речення винятку з виразом цей вираз "
"оцінюється, і речення відповідає винятку, якщо отриманий об’єкт \"сумісний\" "
"з винятком. Об’єкт сумісний із винятком, якщо він є класом або :term:"
"`невіртуальним базовим класом <abstract base class>` об’єкта винятку, або "
"кортежем, що містить елемент, який є класом або невіртуальним базовим класом "
"об'єкт винятку."

msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"Якщо жоден пункт винятку не відповідає винятку, пошук обробника винятку "
"продовжується в навколишньому коді та в стеку викликів. [#]_"

msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
"Якщо обчислення виразу в заголовку пропозиції винятку викликає виняток, "
"початковий пошук обробника скасовується та починається пошук нового винятку "
"в навколишньому коді та в стеку викликів (це розглядається так, ніби весь "
"оператор :keyword:`try` викликав виняток)."

msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"Якщо знайдено відповідне речення, виняток призначається цільовому об’єкту, "
"указаному після ключового слова :keyword:`!as` у цьому речення, якщо воно є, "
"і виконується набір речень. Усі речення, крім, повинні мати виконуваний "
"блок. Коли досягнуто кінця цього блоку, виконання продовжується в звичайному "
"режимі після всього оператора try. (Це означає, що якщо існують два вкладені "
"обробники для одного винятку, і виняток виникає в пропозиції try "
"внутрішнього обробника, зовнішній обробник не оброблятиме виняток.)"

msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"Якщо виняток було призначено за допомогою ``as target``, воно очищається в "
"кінці пропозиції винятку. Це ніби ::"

msgid "was translated to ::"
msgstr "було перекладено на::"

msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"Це означає, що винятку потрібно призначити інше ім’я, щоб можна було "
"посилатися на нього після пропозиції винятку. Винятки очищаються, оскільки з "
"підключеною до них трасуванням вони утворюють еталонний цикл із фреймом "
"стека, зберігаючи всіх локальних у цьому фреймі живими до наступного "
"збирання сміття."

msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be accessed via :func:`sys."
"exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  The details about the exception accessed via :func:`sys.exc_info` "
"are restored to their previous values when leaving an exception handler::"
msgstr ""
"Перед тим, як буде виконано набір речень винятків, деталі про виняток "
"зберігаються в модулі :mod:`sys` і доступ до них можна отримати через :func:"
"`sys.exc_info`. :func:`sys.exc_info` повертає 3-кортеж, що складається з "
"класу виключення, екземпляру виключення та об’єкта трасування (див. розділ :"
"ref:`types`), що визначає точку в програмі, де сталася виняток. Деталі про "
"виняток, доступ до якого здійснюється через :func:`sys.exc_info`, "
"відновлюються до своїх попередніх значень, коли залишають обробник винятків::"

msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"Необов’язкова пропозиція :keyword:`!else` виконується, якщо потік керування "
"виходить із набору :keyword:`try`, не було викликано винятків і немає :"
"keyword:`return`, :keyword:`continue` або Інструкція :keyword:`break` була "
"виконана. Винятки в пункті :keyword:`!else` не обробляються попередніми "
"пунктами :keyword:`except`."

msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`!else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Якщо :keyword:`finally` присутній, він визначає обробник 'очищення'. "
"Речення :keyword:`try` виконується, включаючи будь-які пропозиції :keyword:"
"`except` і :keyword:`!else`. Якщо виняток виникає в будь-якому з пунктів і "
"не обробляється, виняток тимчасово зберігається. Речення :keyword:`!finally` "
"виконується. Якщо є збережений виняток, він повторно викликається в кінці "
"пропозиції :keyword:`!finally`. Якщо речення :keyword:`!finally` викликає "
"інший виняток, збережений виняток встановлюється як контекст нового "
"виключення. Якщо пропозиція :keyword:`!finally` виконує оператор :keyword:"
"`return`, :keyword:`break` або :keyword:`continue`, збережений виняток "
"скидається:"

msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""
"Інформація про винятки недоступна для програми під час виконання пропозиції :"
"keyword:`finally`."

msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Коли оператор :keyword:`return`, :keyword:`break` або :keyword:`continue` "
"виконується в наборі :keyword:`try` :keyword:`!try`...\\ оператор :keyword:`!"
"finally`, пункт :keyword:`finally` також виконується \"на виході\"."

msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`!return` statement executed in the :keyword:`!finally` clause will "
"always be the last one executed::"
msgstr ""
"Повернене значення функції визначається останнім виконаним оператором :"
"keyword:`return`. Оскільки пропозиція :keyword:`finally` завжди виконується, "
"оператор :keyword:`!return`, що виконується в пропозиції :keyword:`!"
"finally`, завжди буде виконуватися останнім::"

msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Додаткову інформацію про винятки можна знайти в розділі :ref:`exceptions`, а "
"інформацію про використання оператора :keyword:`raise` для створення "
"винятків можна знайти в розділі :ref:`raise`."

msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`finally` clause due to a problem with the implementation."
msgstr ""
"До Python 3.8 оператор :keyword:`continue` був незаконним у пункті :keyword:"
"`finally` через проблему з реалізацією."

msgid "The :keyword:`!with` statement"
msgstr "Оператор :keyword:`!with`"

msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"Оператор :keyword:`with` використовується для обгортання виконання блоку "
"методами, визначеними контекстним менеджером (див. розділ :ref:`context-"
"managers`). Це дозволяє інкапсулювати загальні :keyword:`try`...\\ :keyword:"
"`except`...\\ :keyword:`finally` моделі використання для зручного повторного "
"використання."

msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"Виконання оператора :keyword:`with` з одним \"елементом\" відбувається "
"наступним чином:"

msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"Контекстний вираз (вираз, поданий у :token:`~python-grammar:with_item`) "
"обчислюється для отримання контекстного менеджера."

msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""
"Менеджер контексту :meth:`__enter__` завантажується для подальшого "
"використання."

msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"Менеджер контексту :meth:`__exit__` завантажується для подальшого "
"використання."

msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "Викликається метод :meth:`__enter__` контекстного менеджера."

msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"Якщо мета була включена в оператор :keyword:`with`, їй призначається "
"значення, що повертається з :meth:`__enter__`."

msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
"Оператор :keyword:`with` гарантує, що якщо метод :meth:`__enter__` повертає "
"без помилки, то :meth:`__exit__` завжди буде викликатися. Таким чином, якщо "
"під час призначення цільового списку виникає помилка, вона розглядатиметься "
"так само, як і помилка, яка сталася в наборі. Дивіться крок 6 нижче."

msgid "The suite is executed."
msgstr "Сюїта виконана."

msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"Викликається метод :meth:`__exit__` контекстного менеджера. Якщо виняткова "
"ситуація призвела до виходу з набору, його тип, значення та відстеження "
"передаються як аргументи :meth:`__exit__`. В іншому випадку надається три "
"аргументи :const:`None`."

msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"Якщо набір було закрито через виняток, а значення, яке повертає метод :meth:"
"`__exit__`, було false, виняток створюється повторно. Якщо повернене "
"значення було істинним, виняток пригнічується, і виконання продовжується з "
"оператором, наступним за оператором :keyword:`with`."

msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"Якщо вихід із набору було завершено з будь-якої причини, крім винятку, "
"значення, що повертається з :meth:`__exit__`, ігнорується, і виконання "
"продовжується у звичайному місці для того виду виходу, який було зроблено."

msgid "The following code::"
msgstr "Наступний код::"

msgid "is semantically equivalent to::"
msgstr "семантично еквівалентний::"

msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"З більш ніж одним елементом менеджери контексту обробляються так, ніби "
"кілька операторів :keyword:`with` були вкладеними::"

msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"Ви також можете писати багатоелементні контекстні менеджери в кілька рядків, "
"якщо елементи оточені дужками. Наприклад::"

msgid "Support for multiple context expressions."
msgstr "Підтримка кількох контекстних виразів."

msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"Підтримка використання групування дужок для розбиття оператора на кілька "
"рядків."

msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - оператор \"з\"."

msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Специфікація, передумови та приклади оператора Python :keyword:`with`."

msgid "The :keyword:`!match` statement"
msgstr "Оператор :keyword:`!match`"

msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "Оператор match використовується для зіставлення шаблону. Синтаксис:"

msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"У цьому розділі використовуються одинарні лапки для позначення :ref:`м’яких "
"ключових слів <soft-keywords>`."

msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"Зіставлення шаблону приймає шаблон як вхідні дані (після ``case``) і "
"значення теми (після ``match``). Шаблон (який може містити підшаблони) "
"зіставляється зі значенням теми. Результати:"

msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"Успіх або невдача збігу (також називається успішним або невдалим шаблоном)."

msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"Можливе прив’язування відповідних значень до імені. Передумови для цього "
"обговорюються нижче."

msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"Ключові слова ``match`` і ``case`` є :ref:`м'якими ключовими словами <soft-"
"keywords>`."

msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Зіставлення структурних шаблонів: Специфікація"

msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- Зіставлення структурних шаблонів: підручник"

msgid "Overview"
msgstr "Огляд"

msgid "Here's an overview of the logical flow of a match statement:"
msgstr "Ось огляд логічної послідовності оператора збігу:"

msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"Вираз суб’єкта ``subject_expr`` обчислюється та отримується результуюче "
"значення предмета. Якщо вираз теми містить кому, кортеж створюється за "
"допомогою :ref:`стандартних правил <typesseq-tuple>`."

msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Кожен шаблон у ``case_block`` намагається зіставити зі значенням теми. "
"Конкретні правила успіху чи невдачі описані нижче. Спроба збігу також може "
"пов’язати деякі або всі окремі імена в шаблоні. Точні правила зв’язування "
"шаблону залежать від типу шаблону та вказані нижче. **Прив’язки імен, "
"зроблені під час успішного збігу шаблону, переживають виконаний блок і "
"можуть використовуватися після оператора збігу**."

msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"Під час невдалих збігів шаблонів деякі підшаблони можуть бути успішними. Не "
"покладайтеся на прив’язки, зроблені для невдалого матчу. І навпаки, не "
"покладайтеся на те, що змінні залишаться незмінними після невдалого збігу. "
"Точна поведінка залежить від реалізації та може відрізнятися. Це навмисне "
"рішення, яке дозволяє оптимізувати різні реалізації."

msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Якщо шаблон успішний, відповідний охоронець (якщо присутній) оцінюється. У "
"цьому випадку всі прив’язки імен гарантовано відбулися."

msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Якщо guard оцінює як true або відсутній, виконується ``block`` всередині "
"``case_block``."

msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr "Інакше виконується спроба наступного ``case_block``, як описано вище."

msgid "If there are no further case blocks, the match statement is completed."
msgstr "Якщо немає інших блоків регістру, оператор збігу завершується."

msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"Зазвичай користувачі ніколи не повинні покладатися на шаблон, що оцінюється. "
"Залежно від реалізації, інтерпретатор може кешувати значення або "
"використовувати інші оптимізації, які пропускають повторні оцінки."

msgid "A sample match statement::"
msgstr "Зразок заяви про відповідність::"

msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"У цьому випадку ``if flag`` є охороною. Докладніше про це читайте в "
"наступному розділі."

msgid "Guards"
msgstr "Охоронці"

msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"``guard`` (який є частиною ``case``) має бути успішним для виконання коду "
"всередині блоку ``case``. Він приймає форму: :keyword:`if`, після якого йде "
"вираз."

msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr "Логічний послідовність блоку ``case`` з ``guard`` наступна:"

msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Переконайтеся, що шаблон у блоці ``case`` виконано успішно. Якщо шаблон не "
"вдається, ``guard`` не оцінюється, і перевіряється наступний ``case`` блок."

msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Якщо шаблон вдався, оцініть ``guard``."

msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "Якщо умова ``guard`` оцінюється як істинна, вибирається блок регістру."

msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr "Якщо умова ``guard`` оцінюється як false, блок регістру не вибрано."

msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Якщо ``охоронець`` викликає виняток під час оцінки, виняток з'являється."

msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Охоронцям дозволено мати побічні ефекти, оскільки вони є виразами. Оцінка "
"Guard повинна проходити від першого до останнього блоку регістрів, по "
"одному, пропускаючи блоки регістрів, шаблон(и) яких не всі є успішними. "
"(Тобто оцінка охорони має відбуватися в порядку.) Оцінка охорони має "
"припинитися, коли вибрано блок справи."

msgid "Irrefutable Case Blocks"
msgstr "Незаперечні блоки випадків"

msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Незаперечний блок регістрів — це блок регістрів, що відповідає всім "
"регістрам. Інструкція збігу може мати щонайбільше один неспростовний блок "
"регістру, і він має бути останнім."

msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Блок футляра вважається незаперечним, якщо він не має захисного елемента і "
"його візерунок є неспростовним. Патерн вважається неспростовним, якщо ми "
"можемо довести лише з його синтаксису, що він завжди матиме успіх. "
"Незаперечними є лише такі закономірності:"

msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-patterns`, ліва сторона якого неспростовна"

msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns`, що містить принаймні один неспростовний шаблон"

msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

msgid "parenthesized irrefutable patterns"
msgstr "в дужках неспростовні закономірності"

msgid "Patterns"
msgstr "Візерунки"

msgid "This section uses grammar notations beyond standard EBNF:"
msgstr ""
"У цьому розділі використовуються граматичні нотації поза стандартними EBNF:"

msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "позначення ``SEP.RULE+`` є скороченням для ``RULE (SEP RULE)*``"

msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"нотація ``!RULE`` є скороченням для негативного твердження попереднього "
"перегляду"

msgid "The top-level syntax for ``patterns`` is:"
msgstr "Синтаксис верхнього рівня для ``патернів`` такий:"

msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"Наведені нижче описи включатимуть опис \"у простих термінах\" того, що "
"робить шаблон для цілей ілюстрації (заслуга Реймонда Геттінгера за документ, "
"який надихнув більшість описів). Зауважте, що ці описи наведено лише для "
"ілюстрації та **можуть** не відображати базову реалізацію. Крім того, вони "
"не охоплюють усіх дійсних форм."

msgid "OR Patterns"
msgstr "АБО Шаблони"

msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Шаблон АБО — це два або більше шаблонів, розділених вертикальними рисками ``|"
"``. Синтаксис:"

msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Лише остаточний підшаблон може бути :ref:`irrefutable <irrefutable_case>`, і "
"кожен підшаблон повинен пов’язувати однаковий набір імен, щоб уникнути "
"двозначності."

msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Шаблон АБО зіставляє кожен зі своїх підшаблонів по черзі зі значенням "
"суб’єкта, поки один не досягне успіху. Потім шаблон АБО вважається успішним. "
"В іншому випадку, якщо жоден із підшаблонів не вдасться, шаблон АБО буде "
"невдалим."

msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"Простіше кажучи, ``P1 | P2 | ...`` намагатиметься знайти відповідність "
"``P1``, якщо це не вдасться, вона спробує знайти ``P2``, успішно негайно, "
"якщо будь-який з них вдасться, інакше не вдасться."

msgid "AS Patterns"
msgstr "AS Patterns"

msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Шаблон AS відповідає шаблону АБО ліворуч від ключового слова :keyword:`as` "
"щодо теми. Синтаксис:"

msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a a ``_``."
msgstr ""
"Якщо шаблон АБО не працює, шаблон AS не працює. В іншому випадку шаблон AS "
"прив’язує тему до імені праворуч від ключового слова as і виконується "
"успішно. ``capture_pattern`` не може бути ``_``."

msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"Простіше кажучи, ``P as NAME`` співпадатиме з ``P``, і в разі успіху буде "
"встановлено ``NAME = <subject>``."

msgid "Literal Patterns"
msgstr "Літеральні візерунки"

msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Шаблон літералів відповідає більшості :ref:`літералів <literals>` у Python. "
"Синтаксис:"

msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""
"Правило ``рядки`` і токен ``ЧИСЛО`` визначено в :doc:`стандартній граматиці "
"Python <./grammar>`. Підтримуються рядки в потрійних лапках. Підтримуються "
"необроблені рядки та рядки байтів. :ref:`f-strings` не підтримуються."

msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"Форми ``число_знак '+' ЧИСЛО`` і ``число_знак '-' ЧИСЛО`` призначені для "
"вираження :ref:`комплексних чисел <imaginary>`; вони вимагають дійсного "
"числа зліва та уявного числа справа. наприклад ``3 + 4j``."

msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"Простіше кажучи, ``LITERAL`` буде успішним, лише якщо ``<subject> == "
"LITERAL``. Для синглтонів ``None``, ``True`` і ``False`` використовується "
"оператор :keyword:`is`."

msgid "Capture Patterns"
msgstr "Захоплення шаблонів"

msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "Шаблон захоплення прив’язує значення теми до імені. Синтаксис:"

msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"Одне підкреслення ``_`` не є шаблоном захоплення (це те, що ``!'_''`` "
"виражає). Натомість він розглядається як :token:`~python-grammar:"
"wildcard_pattern`."

msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"У заданому шаблоні дане ім’я може бути пов’язане лише один раз. наприклад "
"``case x, x: ...`` недійсний, тоді як ``case [x] | x: ...`` дозволено."

msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Захоплення шаблонів завжди вдається. Зв’язування відповідає правилам області "
"видимості, встановленим оператором виразу присвоєння в :pep:`572`; ім'я стає "
"локальною змінною в найближчій області видимості функції, якщо немає "
"відповідного оператора :keyword:`global` або :keyword:`nonlocal`."

msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"Простіше кажучи, ``NAME`` завжди матиме успіх і встановлюватиме ``NAME = "
"<subject>``."

msgid "Wildcard Patterns"
msgstr "Шаблони підстановок"

msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Шаблон підстановки завжди успішний (відповідає будь-чому) і не прив’язує "
"жодного імені. Синтаксис:"

msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` є :ref:`м'яким ключовим словом <soft-keywords>` у будь-якому шаблоні, "
"але лише всередині шаблонів. Це ідентифікатор, як зазвичай, навіть у виразах "
"теми ``match``, ``guard``\\ s і ``case`` блоків."

msgid "In simple terms, ``_`` will always succeed."
msgstr "Простіше кажучи, ``_`` завжди матиме успіх."

msgid "Value Patterns"
msgstr "Шаблони цінностей"

msgid "A value pattern represents a named value in Python. Syntax:"
msgstr "Шаблон значення представляє іменоване значення в Python. Синтаксис:"

msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"Пунктирна назва в шаблоні шукається за допомогою стандартних Python :ref:"
"`правил розпізнавання імен <resolve_names>`. Шаблон виконується успішно, "
"якщо знайдене значення порівнюється зі значенням предмета (з використанням "
"оператора рівності ``==``)."

msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""
"Простіше кажучи, ``NAME1.NAME2`` буде успішним, лише якщо ``<subject> == "
"NAME1.NAME2``"

msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"Якщо те саме значення зустрічається кілька разів у тому самому операторі "
"збігу, інтерпретатор може кешувати перше знайдене значення та "
"використовувати його повторно, а не повторювати той самий пошук. Цей кеш "
"суворо прив’язаний до заданого виконання даного оператора відповідності."

msgid "Group Patterns"
msgstr "Шаблони груп"

msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Груповий шаблон дозволяє користувачам додавати дужки навколо шаблонів, щоб "
"підкреслити передбачуване групування. В іншому випадку він не має "
"додаткового синтаксису. Синтаксис:"

msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "Простіше кажучи, ``(P)`` має той самий ефект, що ``P``."

msgid "Sequence Patterns"
msgstr "Шаблони послідовності"

msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Шаблон послідовності містить кілька підшаблонів, які потрібно зіставити з "
"елементами послідовності. Синтаксис подібний до розпакування списку або "
"кортежу."

msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"Немає різниці, якщо дужки або квадратні дужки використовуються для шаблонів "
"послідовності (тобто ``(...)`` проти ``[...]`` )."

msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"Один шаблон, укладений у дужки без кінцевої коми (наприклад, ``(3 | 4)``), "
"є :ref:`груповим шаблоном <group-patterns>`. У той час як один шаблон, "
"укладений у квадратні дужки (наприклад, ``[3 | 4]``), все ще є шаблоном "
"послідовності."

msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"Щонайбільше один зірковий підшаблон може бути в шаблоні послідовності. "
"Підшаблон зірки може з’являтися в будь-якій позиції. Якщо підшаблон зірки "
"відсутній, шаблон послідовності є шаблоном послідовності фіксованої довжини; "
"інакше це шаблон послідовності змінної довжини."

msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"Нижче наведено логічний потік для зіставлення шаблону послідовності зі "
"значенням предмета:"

msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""
"Якщо значення теми не є послідовністю [#]_, шаблон послідовності не "
"виконується."

msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Якщо значення теми є екземпляром ``str``, ``bytes`` або ``bytearray``, "
"шаблон послідовності не виконується."

msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"Подальші кроки залежать від того, чи є шаблон послідовності фіксованою чи "
"змінною довжиною."

msgid "If the sequence pattern is fixed-length:"
msgstr "Якщо шаблон послідовності має фіксовану довжину:"

msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Якщо довжина предметної послідовності не дорівнює кількості підшаблонів, "
"шаблон послідовності не вдається"

msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Підшаблони в шаблоні послідовності зіставляються з відповідними елементами в "
"послідовності предметів зліва направо. Зіставлення припиняється, як тільки "
"підшаблон не вдається. Якщо всі підшаблони успішно відповідають їхньому "
"відповідному елементу, шаблон послідовності вдається."

msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "В іншому випадку, якщо шаблон послідовності має змінну довжину:"

msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Якщо довжина предметної послідовності менша за кількість незіркових "
"підшаблонів, шаблон послідовності не вдається."

msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"Провідні незіркові підшаблони зіставляються з відповідними елементами, як "
"для послідовностей фіксованої довжини."

msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Якщо попередній крок виконано успішно, підшаблон зірочки збігається зі "
"списком, сформованим із решти предметних елементів, за винятком решти "
"елементів, що відповідають підшаблонам без зірочки, які слідують за "
"підшаблоном зірочки."

msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Решта підшаблонів без зірок зіставляються з відповідними предметними "
"елементами, як для послідовності фіксованої довжини."

msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"Довжина предметної послідовності визначається через :func:`len` (тобто "
"через :meth:`__len__` протокол). Ця довжина може бути кешована "
"інтерпретатором подібним чином, як :ref:`шаблони значень <value-patterns>`."

msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"Простіше кажучи, ``[P1, P2, P3,`` ... ``, P <N> ]`` збігається, лише якщо "
"відбувається все наступне:"

msgid "check ``<subject>`` is a sequence"
msgstr "перевірка ``<subject>`` є послідовністю"

msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``P1`` відповідає ``<subject> [0]`` (зауважте, що цей збіг також може "
"пов’язувати імена)"

msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``P2`` відповідає ``<subject> [1]`` (зауважте, що цей збіг також може "
"пов’язувати імена)"

msgid "... and so on for the corresponding pattern/element."
msgstr "... і так далі для відповідного шаблону/елемента."

msgid "Mapping Patterns"
msgstr "Шаблони відображення"

msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Шаблон зіставлення містить один або кілька шаблонів ключ-значення. Синтаксис "
"подібний до побудови словника. Синтаксис:"

msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"Щонайбільше один шаблон подвійної зірки може бути в шаблоні відображення. "
"Шаблон подвійної зірки має бути останнім підшаблоном у шаблоні відображення."

msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"Дублікати ключів у шаблонах зіставлення заборонені. Повторювані ключі "
"літералів викличуть :exc:`SyntaxError`. Два ключі, які інакше мають однакові "
"значення, викликають :exc:`ValueError` під час виконання."

msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"Нижче наведено логічний потік для зіставлення шаблону зіставлення зі "
"значенням предмета:"

msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""
"Якщо значення предмета не є відображенням [#]_, шаблон відображення не "
"виконується."

msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Якщо кожен ключ, поданий у шаблоні відображення, присутній у відображенні "
"предмета, і шаблон для кожного ключа збігається з відповідним елементом "
"відображення предмета, шаблон відображення є успішним."

msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Якщо в шаблоні відображення виявлено повторювані ключі, шаблон вважається "
"недійсним. :exc:`SyntaxError` виникає для повторюваних літеральних значень; "
"або :exc:`ValueError` для іменованих ключів з тим самим значенням."

msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`__getitem__`."
msgstr ""
"Пари ключ-значення зіставляються за допомогою форми з двома аргументами "
"методу get() суб’єкта зіставлення. Зібрані пари ключ-значення мають уже бути "
"присутніми у відображенні, а не створюватися на льоту за допомогою :meth:"
"`__missing__` або :meth:`__getitem__`."

msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"Простіше кажучи, ``{KEY1: P1, KEY2: P2, ... }`` відповідає, лише якщо "
"відбувається все наступне:"

msgid "check ``<subject>`` is a mapping"
msgstr "перевірка ``<subject>`` є відображенням"

msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <subject>``"

msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` відповідає ``<subject>[KEY1]``"

msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "... і так далі для відповідної пари КЛЮЧ/шаблон."

msgid "Class Patterns"
msgstr "Шаблони класів"

msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Шаблон класу представляє клас і його позиційні та ключові аргументи (якщо "
"такі є). Синтаксис:"

msgid "The same keyword should not be repeated in class patterns."
msgstr "Те саме ключове слово не повинно повторюватися в шаблонах класів."

msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"Нижче наведено логічний потік для зіставлення шаблону класу зі значенням "
"предмета:"

msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""
"Якщо ``name_or_attr`` не є екземпляром вбудованого :class:`type` , "
"викликати :exc:`TypeError`."

msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""
"Якщо значення теми не є екземпляром ``name_or_attr`` (перевірено через :func:"
"`isinstance`), шаблон класу не вдається."

msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"Якщо аргументи шаблону відсутні, шаблон виконується успішно. В іншому "
"випадку наступні кроки залежать від того, чи присутні шаблони ключових слів "
"або позиційних аргументів."

msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"Для ряду вбудованих типів (зазначених нижче) приймається один позиційний "
"підшаблон, який відповідатиме всьому об’єкту; для цих типів шаблони ключових "
"слів також працюють, як і для інших типів."

msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"Якщо присутні лише шаблони ключових слів, вони обробляються таким чином, "
"один за іншим:"

msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. Ключове слово шукається як атрибут теми."

msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Якщо це викликає виняток, відмінний від :exc:`AttributeError`, виняток "
"з’являється."

msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr ""
"Якщо це викликає помилку :exc:`AttributeError`, шаблон класу стався невдало."

msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"В іншому випадку підшаблон, пов’язаний із шаблоном ключового слова, "
"зіставляється зі значенням атрибута суб’єкта. Якщо це не вдається, шаблон "
"класу не працює; якщо це вдається, відповідність переходить до наступного "
"ключового слова."

msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr "II. Якщо всі шаблони ключових слів успішні, шаблон класу успішний."

msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Якщо присутні будь-які позиційні шаблони, вони перетворюються на шаблони "
"ключових слів за допомогою атрибута :data:`~object.__match_args__` класу "
"``name_or_attr`` перед відповідністю:"

msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr "I. Викликається еквівалент ``getattr(cls, \"__match_args__\", ())``."

msgid "If this raises an exception, the exception bubbles up."
msgstr "Якщо це викликає виняток, виняток з’являється."

msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""
"Якщо повернуте значення не є кортежем, перетворення не вдається, і виникає :"
"exc:`TypeError`."

msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""
"Якщо є більше позиційних шаблонів, ніж ``len(cls.__match_args__)``, виникає :"
"exc:`TypeError`."

msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"В іншому випадку позиційний шаблон ``i`` перетворюється на шаблон ключового "
"слова з використанням ``__match_args__[i]`` як ключове слово. "
"``__match_args__[i]`` має бути рядком; якщо ні, виникає :exc:`TypeError`."

msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "Якщо є повторювані ключові слова, виникає :exc:`TypeError`."

msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr "II. Коли всі позиційні моделі буде перетворено на ключові слова,"

msgid "the match proceeds as if there were only keyword patterns."
msgstr "відповідність відбувається так, якби були лише шаблони ключових слів."

msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"Для наступних вбудованих типів обробка позиційних підшаблонів відрізняється:"

msgid ":class:`bool`"
msgstr ":class:`bool`"

msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

msgid ":class:`bytes`"
msgstr ":class:`bytes`"

msgid ":class:`dict`"
msgstr ":class:`dict`"

msgid ":class:`float`"
msgstr ":class:`float`"

msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

msgid ":class:`int`"
msgstr ":class:`int`"

msgid ":class:`list`"
msgstr ":class:`list`"

msgid ":class:`set`"
msgstr ":class:`set`"

msgid ":class:`str`"
msgstr ":class:`str`"

msgid ":class:`tuple`"
msgstr ":class:`tuple`"

msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the values ``0.0`` or "
"``False``."
msgstr ""
"Ці класи приймають єдиний позиційний аргумент, і шаблон там порівнюється з "
"цілим об’єктом, а не з атрибутом. Наприклад, ``int(0|1)`` відповідає "
"значенню ``0``, але не значенням ``0.0`` або ``False``."

msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"Простіше кажучи, ``CLS(P1, attr=P2)`` збігається, лише якщо відбувається "
"таке:"

msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance( <subject> , CLS)``"

msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"перетворити ``P1`` на шаблон ключового слова за допомогою ``CLS."
"__match_args__``"

msgid "For each keyword argument ``attr=P2``:"
msgstr "Для кожного аргументу ключового слова ``attr=P2``:"

msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr( <subject> , \"attr\")``"

msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` відповідає ``<subject> .attr``"

msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr "... і так далі для відповідної пари ключового слова аргумент/шаблон."

msgid "Function definitions"
msgstr "Визначення функцій"

msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Визначення функції визначає об’єкт функції, визначений користувачем (див. "
"розділ :ref:`types`):"

msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Визначення функції - це виконуваний оператор. Його виконання прив’язує назву "
"функції в поточному локальному просторі імен до об’єкта функції (обгортка "
"навколо виконуваного коду для функції). Цей об’єкт функції містить посилання "
"на поточний глобальний простір імен як глобальний простір імен, який буде "
"використано під час виклику функції."

msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"Визначення функції не виконує тіло функції; це виконується лише під час "
"виклику функції. [#]_"

msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Визначення функції може бути обгорнуте одним або кількома виразами :term:"
"`decorator`. Вирази декоратора обчислюються, коли функція визначена в "
"області видимості, яка містить визначення функції. Результат має бути "
"викликаним, який викликається з об’єктом функції як єдиним аргументом. "
"Повернене значення прив’язується до імені функції замість об’єкта функції. "
"Кілька декораторів застосовуються вкладеним способом. Наприклад, такий код::"

msgid "is roughly equivalent to ::"
msgstr "приблизно еквівалентно ::"

msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"за винятком того, що вихідна функція тимчасово не прив’язана до імені "
"``func``."

msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Функції можуть бути прикрашені будь-яким дійсним :token:`~python-grammar:"
"assignment_expression`. Раніше граматика була набагато більш обмежувальною; "
"подробиці див. :pep:`614`."

msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Коли один або більше :term:`параметрів <parameter>` мають форму *параметр* "
"``=`` *вираз*, кажуть, що функція має \"значення параметрів за "
"замовчуванням\". Для параметра зі значенням за замовчуванням відповідний :"
"term:`argument` може бути пропущений у виклику, у цьому випадку значення "
"параметра за замовчуванням замінюється. Якщо параметр має значення за "
"замовчуванням, усі наступні параметри до \"``*``\" також повинні мати "
"значення за замовчуванням --- це синтаксичне обмеження, яке не виражається "
"граматикою."

msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Значення параметрів за замовчуванням обчислюються зліва направо, коли "
"виконується визначення функції.** Це означає, що вираз обчислюється один "
"раз, коли визначається функція, і що те саме \"попередньо обчислене\" "
"значення використовується для кожного виклику . Це особливо важливо "
"розуміти, коли значення параметра за замовчуванням є змінним об’єктом, таким "
"як список або словник: якщо функція змінює об’єкт (наприклад, шляхом "
"додавання елемента до списку), значення параметра за замовчуванням фактично "
"змінюється. Загалом це не те, що передбачалося. Щоб обійти це, використайте "
"``None`` за умовчанням і явним чином перевірте його в тілі функції, "
"наприклад::"

msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"Більш детально семантика виклику функції описана в розділі :ref:`calls`. "
"Виклик функції завжди призначає значення всім параметрам, згаданим у списку "
"параметрів, або з позиційних аргументів, з ключових аргументів, або зі "
"значень за замовчуванням. Якщо присутня форма \"``*identifier``\", вона "
"ініціалізується кортежем, що отримує будь-які надлишкові позиційні "
"параметри, за умовчанням порожній кортеж. Якщо присутня форма "
"\"``*identifier``\", вона ініціалізується новим упорядкованим відображенням, "
"отримуючи будь-які надлишкові аргументи ключового слова, за умовчанням до "
"нового порожнього відображення того самого типу. Параметри після \"``*``\" "
"або \"``*identifier``\" є параметрами лише для ключових слів і можуть "
"передаватися лише аргументами ключових слів. Параметри перед \"``/``\" є "
"лише позиційними параметрами і можуть передаватися лише позиційними "
"аргументами."

msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"Синтаксис параметра функції ``/`` може використовуватися для позначення лише "
"позиційних параметрів. Подробиці див. :pep:`570`."

msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"Параметри можуть мати :term:`анотацію <function annotation>` у формі \"``:"
"вираз``\" після імені параметра. Будь-який параметр може мати анотацію, "
"навіть у формі ``*ідентифікатор`` або ``**ідентифікатор``. Функції можуть "
"мати анотацію \"повернення\" у формі \"``-> вираз``\" після списку "
"параметрів. Ці анотації можуть бути будь-яким дійсним виразом Python. "
"Наявність анотацій не змінює семантику функції. Значення анотацій доступні "
"як значення словника, ключ якого містить імена параметрів в атрибуті :attr:"
"`__annotations__` об’єкта функції. Якщо використовується імпорт ``анотацій`` "
"із :mod:`__future__`, анотації зберігаються як рядки під час виконання, що "
"дає змогу відкласти оцінку. В іншому випадку вони оцінюються під час "
"виконання визначення функції. У цьому випадку анотації можуть оцінюватися в "
"іншому порядку, ніж у вихідному коді."

msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Також можна створювати анонімні функції (функції, не прив’язані до імені) "
"для негайного використання у виразах. Тут використовуються лямбда-вирази, "
"описані в розділі :ref:`lambda`. Зауважте, що лямбда-вираз — це лише "
"скорочення спрощеного визначення функції; функція, визначена в операторі \":"
"keyword:`def`\", може бути передана або присвоєна іншому імені так само, як "
"функція, визначена лямбда-виразом. Форма \":keyword:`!def`\" насправді є "
"потужнішою, оскільки вона дозволяє виконувати кілька операторів і анотацій."

msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Примітка програміста:** Функції є об’єктами першого класу. Оператор "
"\"``def``\", який виконується всередині визначення функції, визначає "
"локальну функцію, яку можна повертати або передавати. Вільні змінні, які "
"використовуються у вкладеній функції, можуть отримати доступ до локальних "
"змінних функції, що містить def. Перегляньте розділ :ref:`naming` для "
"деталей."

msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Анотації функцій"

msgid "The original specification for function annotations."
msgstr "Оригінальна специфікація для анотацій функцій."

msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - підказки типу"

msgid "Definition of a standard meaning for annotations: type hints."
msgstr "Визначення стандартного значення для анотацій: тип підказок."

msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Синтаксис для анотацій змінних"

msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr ""
"Можливість вводити оголошення змінних підказок, включаючи змінні класу та "
"змінні екземпляра"

msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Відкладена оцінка анотацій"

msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Підтримка прямих посилань в анотаціях завдяки збереженню анотацій у формі "
"рядка під час виконання замість нетерплячої оцінки."

msgid "Class definitions"
msgstr "Визначення класів"

msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "Визначення класу визначає об’єкт класу (див. розділ :ref:`types`):"

msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Визначення класу є виконуваним оператором. Список успадкування зазвичай "
"надає список базових класів (див. :ref:`metaclasses` для більш просунутого "
"використання), тому кожен елемент у списку повинен оцінюватися як об’єкт "
"класу, який дозволяє створювати підкласи. Класи без списку успадкування "
"успадковують, за замовчуванням, від базового класу :class:`object`; отже, ::"

msgid "is equivalent to ::"
msgstr "еквівалентно ::"

msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"Потім набір класів виконується в новому фреймі виконання (див. :ref:"
"`naming`), використовуючи щойно створений локальний простір імен і "
"оригінальний глобальний простір імен. (Зазвичай набір містить в основному "
"визначення функцій.) Коли набір класу завершує виконання, його кадр "
"виконання відкидається, але його локальний простір імен зберігається. [#]_ "
"Потім створюється об’єкт класу з використанням списку успадкування для "
"базових класів і збереженого локального простору імен для словника "
"атрибутів. Ім'я класу прив'язане до цього об'єкта класу в оригінальному "
"локальному просторі імен."

msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"Порядок, у якому атрибути визначені в тілі класу, зберігається в "
"``__dict__`` нового класу. Зауважте, що це надійно лише відразу після "
"створення класу та лише для класів, які були визначені за допомогою "
"синтаксису визначення."

msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"Створення класів можна значно налаштувати за допомогою :ref:`metaclasses "
"<metaclasses>`."

msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "Класи також можна декорувати: як і при декоруванні функцій, ::"

msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Правила оцінки для виразів декоратора такі ж, як і для декораторів функцій. "
"Потім результат прив’язується до імені класу."

msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Класи можуть бути прикрашені будь-яким дійсним :token:`~python-grammar:"
"assignment_expression`. Раніше граматика була набагато більш обмежувальною; "
"подробиці див. :pep:`614`."

msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Примітка програміста:** Змінні, визначені у визначенні класу, є атрибутами "
"класу; їх ділять інстанції. Атрибути екземпляра можна встановити в методі за "
"допомогою ``self.name = value``. Як атрибути класу, так і атрибути "
"екземпляра доступні через нотацію \"``self.name``\", а атрибут екземпляра "
"приховує атрибут класу з таким самим іменем, коли до нього звертаються таким "
"чином. Атрибути класу можна використовувати як значення за замовчуванням для "
"атрибутів екземплярів, але використання там змінних значень може призвести "
"до неочікуваних результатів. :ref:`Дескриптори <descriptors>` можна "
"використовувати для створення змінних екземпляра з різними деталями "
"реалізації."

msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метакласи в Python 3000"

msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"Пропозиція, яка змінила оголошення метакласів на поточний синтаксис і "
"семантику того, як будуються класи з метакласами."

msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Декоратори класу"

msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"Пропозиція, яка додала декоратори класу. Декоратори функцій і методів були "
"представлені в :pep:`318`."

msgid "Coroutines"
msgstr "Співпрограми"

msgid "Coroutine function definition"
msgstr "Визначення функції співпрограми"

msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Виконання співпрограм Python можна призупинити та відновити в багатьох "
"точках (див. :term:`coroutine`). Вирази :keyword:`await`, :keyword:`async "
"for` і :keyword:`async with` можна використовувати лише в тілі функції "
"співпрограми."

msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Функції, визначені за допомогою синтаксису ``async def``, завжди є функціями "
"співпрограми, навіть якщо вони не містять ключових слів ``await`` або "
"``async``."

msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Використання виразу ``yield from`` всередині тіла функції співпрограми є :"
"exc:`SyntaxError`."

msgid "An example of a coroutine function::"
msgstr "Приклад функції співпрограми::"

msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` і ``async`` тепер є ключовими словами; раніше вони розглядалися як "
"такі лише всередині тіла співпрограми."

msgid "The :keyword:`!async for` statement"
msgstr "Оператор :keyword:`!async for`"

msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`asynchronous iterable` надає метод ``__aiter__``, який безпосередньо "
"повертає :term:`asynchronous iterator`, який може викликати асинхронний код "
"у своєму методі ``__anext__``."

msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"Оператор ``async for`` дозволяє зручно виконувати ітерації над асинхронними "
"ітераціями."

msgid "Is semantically equivalent to::"
msgstr "Семантично еквівалентний::"

msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "Дивіться також :meth:`__aiter__` і :meth:`__anext__` для деталей."

msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Це :exc:`SyntaxError`, якщо використовувати оператор ``async for`` поза "
"тілом функції співпрограми."

msgid "The :keyword:`!async with` statement"
msgstr "Оператор :keyword:`!async with`"

msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Асинхронний менеджер контексту (:term:`asynchronous context manager`) — це "
"менеджер контексту (:term:`context manager`),який може призупинити виконання "
"своїх методів *enter* і *exit*."

msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "Дивіться також :meth:`__aenter__` і :meth:`__aexit__` для деталей."

msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Це :exc:`SyntaxError`, якщо використовувати оператор ``async with`` поза "
"тілом функції співпрограми."

msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Співпрограми з синтаксисом async і await"

msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"Пропозиція, яка зробила співпрограми справжньою автономною концепцією в "
"Python і додала допоміжний синтаксис."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"Виняток поширюється на стек викликів, якщо немає пункту :keyword:`finally`, "
"який викликає інший виняток. Цей новий виняток призводить до втрати старого."

msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr ""
"У відповідності за зразком послідовність визначається як одне з наступного:"

msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "клас, який успадковує :class:`collections.abc.Sequence`"

msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr "клас Python, зареєстрований як :class:`collections.abc.Sequence`"

msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"вбудований клас, який має встановлений біт (CPython) :data:"
"`Py_TPFLAGS_SEQUENCE`"

msgid "a class that inherits from any of the above"
msgstr "клас, який успадковує будь-який з перерахованих вище"

msgid "The following standard library classes are sequences:"
msgstr "Наступні стандартні бібліотечні класи є послідовностями:"

msgid ":class:`array.array`"
msgstr ":class:`array.array`"

msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

msgid ":class:`range`"
msgstr ":class:`range`"

msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Значення суб’єктів типу ``str``, ``bytes`` і ``bytearray`` не відповідають "
"шаблонам послідовності."

msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""
"У відповідності за шаблоном відображення визначається як одне з наступного:"

msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "клас, який успадковує :class:`collections.abc.Mapping`"

msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr "клас Python, зареєстрований як :class:`collections.abc.Mapping`"

msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"вбудований клас, який має встановлений біт (CPython) :data:"
"`Py_TPFLAGS_MAPPING`"

msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""
"Класи стандартної бібліотеки :class:`dict` і :class:`types.MappingProxyType` "
"є відображеннями."

msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"Рядковий літерал, який з’являється як перший оператор у тілі функції, "
"перетворюється на атрибут функції ``__doc__`` і, отже, функцію :term:"
"`docstring`."

msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"Рядковий літерал, що з’являється як перший оператор у тілі класу, "
"перетворюється на елемент простору імен ``__doc__`` і, отже, на :term:"
"`docstring` класу."
