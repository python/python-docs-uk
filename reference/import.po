# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "The import system"
msgstr "Система імпорту"

msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"Код Python в одному :term:`module` отримує доступ до коду в іншому модулі "
"шляхом процесу :term:`importing` його. Інструкція :keyword:`import` є "
"найпоширенішим способом виклику механізму імпорту, але це не єдиний спосіб. "
"Такі функції, як :func:`importlib.import_module` і вбудований :func:"
"`__import__` також можна використовувати для виклику механізму імпорту."

msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
"Оператор :keyword:`import` поєднує дві операції; він шукає названий модуль, "
"а потім прив’язує результати цього пошуку до імені в локальній області. "
"Операція пошуку оператора :keyword:`!import` визначається як виклик функції :"
"func:`__import__` з відповідними аргументами. Значення, що повертається :"
"func:`__import__`, використовується для виконання операції зв’язування імені "
"оператора :keyword:`!import`. Перегляньте оператор :keyword:`!import` для "
"отримання точних деталей цієї операції зв’язування імені."

msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"Прямий виклик :func:`__import__` виконує лише пошук модуля та, якщо "
"знайдено, операцію створення модуля. Хоча можуть виникнути певні побічні "
"ефекти, такі як імпортування батьківських пакетів і оновлення різних кешів "
"(включаючи :data:`sys.modules`), тільки оператор :keyword:`import` виконує "
"операцію зв’язування імені."

msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"Коли виконується оператор :keyword:`import`, викликається стандартна "
"вбудована функція :func:`__import__`. Інші механізми для виклику системи "
"імпорту (такі як :func:`importlib.import_module`) можуть вибрати обхід :func:"
"`__import__` і використовувати власні рішення для реалізації семантики "
"імпорту."

msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"Коли модуль імпортовано вперше, Python шукає модуль і, якщо знайдено, "
"створює об’єкт модуля [#fnmo]_, ініціалізуючи його. Якщо вказаний модуль не "
"знайдено, виникає помилка :exc:`ModuleNotFoundError`. Python реалізує різні "
"стратегії для пошуку названого модуля під час виклику механізму імпорту. Ці "
"стратегії можна модифікувати та розширювати за допомогою різноманітних "
"хуків, описаних у розділах нижче."

msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"Систему імпорту оновлено для повної реалізації другої фази :pep:`302`. "
"Більше немає механізму неявного імпорту – повна система імпорту доступна "
"через :data:`sys.meta_path`. Крім того, була реалізована підтримка рідного "
"пакету простору імен (див. :pep:`420`)."

msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
"Модуль :mod:`importlib` надає багатий API для взаємодії із системою імпорту. "
"Наприклад, :func:`importlib.import_module` надає рекомендований простіший "
"API, ніж вбудований :func:`__import__` для виклику механізму імпорту. "
"Зверніться до документації бібліотеки :mod:`importlib` для отримання "
"додаткової інформації."

msgid "Packages"
msgstr "пакети"

msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"Python має лише один тип об’єкта модуля, і всі модулі належать до цього "
"типу, незалежно від того, чи реалізовано модуль на Python, C чи в чомусь "
"іншому. Щоб допомогти організувати модулі та забезпечити ієрархію імен, "
"Python має концепцію :term:`packages <package>`."

msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"Ви можете розглядати пакети як каталоги у файловій системі, а модулі як "
"файли в каталогах, але не сприймайте цю аналогію надто буквально, оскільки "
"пакети та модулі не обов’язково походять із файлової системи. Для цілей цієї "
"документації ми будемо використовувати цю зручну аналогію каталогів і "
"файлів. Як і каталоги файлової системи, пакунки організовані ієрархічно, і "
"самі пакунки можуть містити підпакети, а також звичайні модулі."

msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"Важливо мати на увазі, що всі пакети є модулями, але не всі модулі є "
"пакетами. Або інакше кажучи, пакунки - це просто особливий вид модулів. "
"Зокрема, будь-який модуль, який містить атрибут ``__path__``, вважається "
"пакетом."

msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by a dot, akin to Python's standard attribute access syntax.  "
"Thus you might have a package called :mod:`email`, which in turn has a "
"subpackage called :mod:`email.mime` and a module within that subpackage "
"called :mod:`email.mime.text`."
msgstr ""
"Усі модулі мають назву. Назви підпакетів відокремлюються від назви "
"батьківського пакета крапкою, подібно до стандартного синтаксису доступу до "
"атрибутів Python. Таким чином, у вас може бути пакет під назвою :mod:"
"`email`, який, у свою чергу, має підпакет під назвою :mod:`email.mime` і "
"модуль у цьому підпакеті під назвою :mod:`email.mime.text`."

msgid "Regular packages"
msgstr "Звичайні пакети"

msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python визначає два типи пакетів: :term:`звичайні пакунки <regular package>` "
"і :term:`пакети простору імен <namespace package>`. Звичайні пакунки — це "
"традиційні пакунки, які існували в Python 3.2 і раніше. Звичайний пакет "
"зазвичай реалізується як каталог, що містить файл ``__init__.py``. Коли "
"імпортується звичайний пакет, цей файл ``__init__.py`` виконується неявно, а "
"об’єкти, які він визначає, прив’язуються до імен у просторі імен пакета. "
"Файл ``__init__.py`` може містити той самий код Python, який може містити "
"будь-який інший модуль, і Python додасть деякі додаткові атрибути до модуля "
"під час його імпорту."

msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"Наприклад, наведений нижче макет файлової системи визначає \"батьківський\" "
"пакет верхнього рівня з трьома підпакетами:"

msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"Імпорт ``parent.one`` неявно виконає ``parent/__init__.py`` і ``parent/one/"
"__init__.py``. Наступні імпорти ``parent.two`` або ``parent.three`` "
"виконають ``parent/two/__init__.py`` та ``parent/three/__init__.py`` "
"відповідно."

msgid "Namespace packages"
msgstr "Пакети простору імен"

msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"Пакет простору імен — це сукупність різноманітних :term:`частин <portion>`, "
"де кожна частина додає підпакет до батьківського пакета. Частини можуть "
"знаходитися в різних місцях файлової системи. Частини також можна знайти в "
"zip-файлах, у мережі чи будь-де ще, де Python шукає під час імпорту. Пакети "
"простору імен можуть або не можуть відповідати безпосередньо об'єктам у "
"файловій системі; вони можуть бути віртуальними модулями, які не мають "
"конкретного представлення."

msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"Пакунки простору імен не використовують звичайний список для свого атрибута "
"``__path__``. Натомість вони використовують настроюваний ітерований тип, "
"який автоматично виконає новий пошук частин пакета під час наступної спроби "
"імпорту в цьому пакеті, якщо шлях до їх батьківського пакета (або :data:`sys."
"path` для пакета верхнього рівня) зміниться."

msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"У пакетах простору імен немає файлу ``parent/__init__.py``. Насправді під "
"час пошуку імпорту може бути знайдено кілька ``батьківських`` каталогів, де "
"кожен надається окремою частиною. Таким чином, ``батьківський/один`` може "
"фізично не знаходитися поруч із ``батьківським/два``. У цьому випадку Python "
"створюватиме пакет простору імен для ``батьківського`` пакета верхнього "
"рівня кожного разу, коли він або один із його підпакетів імпортується."

msgid "See also :pep:`420` for the namespace package specification."
msgstr "Дивіться також :pep:`420` для специфікації пакета простору імен."

msgid "Searching"
msgstr "Пошук"

msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"Щоб розпочати пошук, Python потребує :term:`повної <qualified name>` назви "
"модуля (або пакета, але для цілей цього обговорення різниця несуттєва), який "
"імпортується. Це ім’я може походити з різних аргументів оператора :keyword:"
"`import` або з параметрів функцій :func:`importlib.import_module` або :func:"
"`__import__`."

msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"Ця назва використовуватиметься на різних етапах пошуку імпорту, і це може "
"бути пунктирний шлях до підмодуля, напр. ``foo.bar.baz``. У цьому випадку "
"Python спочатку намагається імпортувати ``foo``, потім ``foo.bar`` і, "
"нарешті, ``foo.bar.baz``. Якщо будь-який із проміжних імпортів не вдається, "
"виникає помилка :exc:`ModuleNotFoundError`."

msgid "The module cache"
msgstr "Кеш модуля"

msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"Перше місце, яке перевіряється під час пошуку імпорту, це :data:`sys."
"modules`. Це відображення служить кеш-пам’яттю всіх модулів, які були раніше "
"імпортовані, включаючи проміжні шляхи. Отже, якщо ``foo.bar.baz`` був раніше "
"імпортований, :data:`sys.modules` міститиме записи для ``foo``, ``foo.bar`` "
"і ``foo.bar.baz``. Кожен ключ матиме значення відповідного об’єкта модуля."

msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"Під час імпорту ім’я модуля шукається в :data:`sys.modules` і, якщо воно "
"присутнє, пов’язане значення означає модуль, який задовольняє імпорт, і "
"процес завершується. Однак, якщо значенням є ``None``, тоді виникає :exc:"
"`ModuleNotFoundError`. Якщо ім’я модуля відсутнє, Python продовжить пошук "
"модуля."

msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` доступний для запису. Видалення ключа може не знищити "
"пов’язаний модуль (оскільки інші модулі можуть містити посилання на нього), "
"але це зробить недійсним запис кешу для названого модуля, змусивши Python "
"знову шукати названий модуль під час наступного імпорту. Ключ також може "
"бути призначений як ``None``, змушуючи наступний імпорт модуля призводити "
"до :exc:`ModuleNotFoundError`."

msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"Але будьте обережні: якби ви зберегли посилання на об’єкт модуля, зробили "
"недійсним запис кешу в :data:`sys.modules`, а потім повторно імпортували "
"названий модуль, два об’єкти модуля *не* будуть однаковими. Навпаки, :func:"
"`importlib.reload` повторно використовуватиме *той самий* об’єкт модуля та "
"просто повторно ініціалізує вміст модуля, повторно запускаючи код модуля."

msgid "Finders and loaders"
msgstr "Шукачі та вантажники"

msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"Якщо названий модуль не знайдено в :data:`sys.modules`, тоді для пошуку та "
"завантаження модуля викликається протокол імпорту Python. Цей протокол "
"складається з двох концептуальних об’єктів, :term:`finders <finder>` і :term:"
"`loaders <loader>`. Робота шукача полягає в тому, щоб визначити, чи зможе "
"він знайти названий модуль, використовуючи ту стратегію, про яку він знає. "
"Об’єкти, які реалізують обидва ці інтерфейси, називаються :term:`імпортерами "
"<importer>` — вони повертаються самі, коли виявляють, що можуть завантажити "
"запитаний модуль."

msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python містить ряд засобів пошуку та імпорту за замовчуванням. Перший знає, "
"як знайти вбудовані модулі, а другий знає, як знайти заморожені модулі. "
"Третій засіб пошуку за умовчанням шукає модулі в :term:`шляху імпорту "
"<import path>`. :term:`шлях імпорту <import path>` — це список розташувань, "
"які можуть іменувати шляхи файлової системи або файли zip. Його також можна "
"розширити для пошуку будь-якого ресурсу, який можна знайти, наприклад, "
"ідентифікованого за URL-адресами."

msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"Механізм імпорту можна розширювати, тому можна додавати нові шукачі, щоб "
"розширити діапазон і обсяг пошуку модулів."

msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"Шукачі фактично не завантажують модулі. Якщо їм вдається знайти названий "
"модуль, вони повертають :dfn:`module spec`, інкапсуляцію інформації, "
"пов’язаної з імпортом модуля, яку потім використовує механізм імпорту під "
"час завантаження модуля."

msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"У наступних розділах більш детально описано протоколи для шукачів і "
"завантажувачів, зокрема те, як ви можете створити та зареєструвати нові "
"протоколи для розширення механізму імпорту."

msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"У попередніх версіях Python шукачі повертали :term:`loaders <loader>` "
"безпосередньо, тоді як тепер вони повертають специфікації модулів, які "
"*містять* завантажувачі. Завантажувачі все ще використовуються під час "
"імпорту, але мають менше обов’язків."

msgid "Import hooks"
msgstr "Імпортні гачки"

msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"Імпортна техніка розрахована на розширення; основним механізмом для цього є "
"*перехоплення імпорту*. Існує два типи хуків імпорту: *мета-хуки* та *хуки "
"шляху імпорту*."

msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"Мета-хуки викликаються на початку обробки імпорту, до того, як відбулася "
"будь-яка інша обробка імпорту, окрім пошуку кешу :data:`sys.modules`. Це "
"дозволяє мета-хукам перевизначати :data:`sys.path` обробку, заморожені "
"модулі або навіть вбудовані модулі. Мета-хуки реєструються шляхом додавання "
"нових об’єктів пошуку до :data:`sys.meta_path`, як описано нижче."

msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"Перехоплювачі шляхів імпорту викликаються як частина обробки :data:`sys."
"path` (або ``package.__path__``) у точці, де зустрічається пов’язаний з ними "
"елемент шляху. Хуки шляхів імпорту реєструються шляхом додавання нових "
"викликів до :data:`sys.path_hooks`, як описано нижче."

msgid "The meta path"
msgstr "Меташлях"

msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"Якщо вказаний модуль не знайдено в :data:`sys.modules`, Python далі шукає :"
"data:`sys.meta_path`, який містить список об’єктів пошуку мета-шляху. Ці "
"шукачі запитуються, щоб побачити, чи знають вони, як працювати з названим "
"модулем. Шукачі меташляхів повинні реалізувати метод під назвою :meth:"
"`~importlib.abc.MetaPathFinder.find_spec()`, який приймає три аргументи: "
"ім’я, шлях імпорту та (необов’язково) цільовий модуль. Шукач меташляху може "
"використовувати будь-яку стратегію, щоб визначити, чи може він обробляти "
"названий модуль чи ні."

msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"Якщо засіб пошуку меташляху знає, як обробляти названий модуль, він повертає "
"специфікаційний об’єкт. Якщо він не може обробити названий модуль, він "
"повертає ``None``. Якщо обробка :data:`sys.meta_path` досягає кінця свого "
"списку без повернення специфікації, тоді виникає :exc:`ModuleNotFoundError`. "
"Будь-які інші викликані винятки просто поширюються, перериваючи процес "
"імпорту."

msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"Метод :meth:`~importlib.abc.MetaPathFinder.find_spec()` засобів пошуку "
"меташляху викликається з двома або трьома аргументами. Перше — це повна "
"назва модуля, який імпортується, наприклад ``foo.bar.baz``. Другим "
"аргументом є записи шляху, які слід використовувати для пошуку модулів. Для "
"модулів верхнього рівня другим аргументом є ``None``, але для підмодулів або "
"підпакетів другим аргументом є значення атрибута ``__path__`` батьківського "
"пакета. Якщо неможливо отримати доступ до відповідного атрибута "
"``__path__``, виникає :exc:`ModuleNotFoundError`. Третій аргумент — це "
"існуючий об’єкт модуля, який буде метою завантаження пізніше. Система "
"імпорту передає цільовий модуль лише під час перезавантаження."

msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"Мета-шлях може проходити кілька разів для одного запиту на імпорт. "
"Наприклад, якщо припустити, що жоден із задіяних модулів уже не кешовано, "
"імпорт ``foo.bar.baz`` спочатку виконає імпорт верхнього рівня, викликаючи "
"``mpf.find_spec(\"foo\", None, None)`` на шукач кожного меташляху (``mpf``). "
"Після того, як ``foo`` було імпортовано, ``foo.bar`` буде імпортовано шляхом "
"проходження меташляху вдруге, викликавши ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)`` . Після того, як ``foo.bar`` буде імпортовано, остаточний "
"обхід викличе ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."

msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"Деякі засоби пошуку меташляхів підтримують лише імпорт верхнього рівня. Ці "
"імпортери завжди повертатимуть ``None``, якщо будь-що інше, ніж ``None``, "
"передається як другий аргумент."

msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"За замовчуванням :data:`sys.meta_path` Python має три засоби пошуку "
"меташляху: один, який знає, як імпортувати вбудовані модулі, інший, який "
"знає, як імпортувати заморожені модулі, і інший, який знає, як імпортувати "
"модулі зі шляху імпорту (:term:`import path`, тобто :term:`path based "
"finder`)."

msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"Метод :meth:`~importlib.abc.MetaPathFinder.find_spec` для пошуку меташляхів "
"замінив :meth:`~importlib.abc.MetaPathFinder.find_module`, який зараз не "
"підтримується. Хоча він продовжуватиме працювати без змін, механізм імпорту "
"спробує його, лише якщо шукач не реалізує ``find_spec()``."

msgid ""
"Use of :meth:`~importlib.abc.MetaPathFinder.find_module` by the import "
"system now raises :exc:`ImportWarning`."
msgstr ""
"Використання :meth:`~importlib.abc.MetaPathFinder.find_module` системою "
"імпорту тепер викликає :exc:`ImportWarning`."

msgid "Loading"
msgstr "Завантаження"

msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"Якщо специфікація модуля буде знайдена, механізм імпорту використовуватиме "
"її (і завантажувач, який вона містить) під час завантаження модуля. Ось "
"приблизно те, що відбувається під час завантаження частини імпорту:"

msgid "Note the following details:"
msgstr "Зверніть увагу на такі деталі:"

msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
"Якщо в :data:`sys.modules` є існуючий об’єкт модуля з вказаною назвою, "
"імпортування його вже повернуло."

msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"Модуль існуватиме в :data:`sys.modules` до того, як завантажувач виконає код "
"модуля. Це важливо, оскільки код модуля може (прямо чи опосередковано) "
"імпортувати сам себе; додавання його до :data:`sys.modules` заздалегідь "
"запобігає необмеженій рекурсії в гіршому випадку та багаторазовому "
"завантаженню в найкращому."

msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"Якщо завантаження не вдасться, модуль із помилкою -- і тільки модуль із "
"помилкою -- видаляється з :data:`sys.modules`. Будь-який модуль, який уже "
"знаходиться в кеші :data:`sys.modules`, і будь-який модуль, який було "
"успішно завантажено як побічний ефект, повинні залишатися в кеші. Це "
"контрастує з перезавантаженням, коли навіть несправний модуль залишається в :"
"data:`sys.modules`."

msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"Після створення модуля, але перед його виконанням, механізм імпорту "
"встановлює пов’язані з імпортом атрибути модуля (\"_init_module_attrs\" у "
"наведеному вище прикладі псевдокоду), як підсумовано в :ref:`пізнішому "
"розділі <import-mod-attrs>`."

msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"Виконання модуля є ключовим моментом завантаження, під час якого простір "
"імен модуля заповнюється. Виконання повністю делеговано завантажувачу, який "
"вирішує, що заповнювати і як."

msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"Модуль, створений під час завантаження та переданий у exec_module(), може не "
"бути тим, що повертається в кінці імпорту [#fnlo]_."

msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"Система імпорту взяла на себе шаблонні обов’язки вантажників. Раніше вони "
"виконувалися методом :meth:`importlib.abc.Loader.load_module`."

msgid "Loaders"
msgstr "Вантажники"

msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"Завантажувачі модулів забезпечують критичну функцію завантаження: виконання "
"модуля. Механізм імпорту викликає метод :meth:`importlib.abc.Loader."
"exec_module` з одним аргументом, об’єктом модуля, який потрібно виконати. "
"Будь-яке значення, повернуте з :meth:`~importlib.abc.Loader.exec_module` "
"ігнорується."

msgid "Loaders must satisfy the following requirements:"
msgstr "Вантажники повинні відповідати таким вимогам:"

msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"Якщо модуль є модулем Python (на відміну від вбудованого модуля або "
"динамічно завантажуваного розширення), завантажувач повинен виконати код "
"модуля в глобальному просторі імен модуля (``module.__dict__``)."

msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"Якщо завантажувач не може виконати модуль, він має викликати :exc:"
"`ImportError`, хоча будь-які інші винятки, викликані під час :meth:"
"`~importlib.abc.Loader.exec_module`, будуть поширені."

msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"У багатьох випадках шукач і завантажувач можуть бути одним і тим же "
"об'єктом; у таких випадках метод :meth:`~importlib.abc.MetaPathFinder."
"find_spec` просто повертатиме специфікацію із завантажувачем, встановленим "
"на ``self``."

msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"Завантажувачі модулів можуть вибрати створення об’єкта модуля під час "
"завантаження, реалізувавши метод :meth:`~importlib.abc.Loader."
"create_module`. Він приймає один аргумент, специфікацію модуля, і повертає "
"новий об’єкт модуля для використання під час завантаження. "
"``create_module()`` не потребує встановлення жодних атрибутів для об’єкта "
"модуля. Якщо метод повертає ``None``, механізм імпорту створить новий модуль "
"сам."

msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "Метод завантажувачів :meth:`~importlib.abc.Loader.create_module`."

msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
"Метод :meth:`~importlib.abc.Loader.load_module` було замінено на :meth:"
"`~importlib.abc.Loader.exec_module`, а механізм імпорту взяв на себе всі "
"шаблонні обов’язки щодо завантаження."

msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"Для сумісності з існуючими завантажувачами механізм імпорту "
"використовуватиме метод завантажувачів ``load_module()``, якщо він існує, а "
"завантажувач також не реалізує ``exec_module()``. Однак ``load_module()`` "
"застаріло, і завантажувачі повинні використовувати ``exec_module()`` замість "
"нього."

msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"Метод ``load_module()`` має реалізовувати всі стандартні функції "
"завантаження, описані вище, на додаток до виконання модуля. Застосовуються "
"ті самі обмеження з деякими додатковими уточненнями:"

msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"Якщо в :data:`sys.modules` є існуючий об’єкт модуля з вказаною назвою, "
"завантажувач повинен використати цей існуючий модуль. (Інакше :func:"
"`importlib.reload` не працюватиме належним чином.) Якщо названий модуль не "
"існує в :data:`sys.modules`, завантажувач має створити новий об’єкт модуля "
"та додати його до :data:`sys.modules`."

msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"Модуль *має* існувати в :data:`sys.modules` до того, як завантажувач виконає "
"код модуля, щоб запобігти необмеженій рекурсії або багаторазовому "
"завантаженню."

msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"Якщо завантаження не вдається, завантажувач повинен видалити будь-які "
"модулі, які він вставив у :data:`sys.modules`, але він повинен видалити "
"**лише** модуль(и) з помилкою, і лише якщо завантажувач сам завантажив "
"модуль( s) явно."

msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
":exc:`DeprecationWarning` виникає, коли ``exec_module()`` визначено, а "
"``create_module()`` ні."

msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Помилка :exc:`ImportError` виникає, коли ``exec_module()`` визначено, а "
"``create_module()`` ні."

msgid "Use of ``load_module()`` will raise :exc:`ImportWarning`."
msgstr "Використання ``load_module()`` призведе до :exc:`ImportWarning`."

msgid "Submodules"
msgstr "Підмодулі"

msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"Коли підмодуль завантажується за допомогою будь-якого механізму (наприклад, "
"``importlib`` API, ``import`` або ``import-from`` оператори, або вбудований "
"``__import__()``), прив’язка розміщується в простір імен батьківського "
"модуля до об’єкта підмодуля. Наприклад, якщо пакет ``spam`` має підмодуль "
"``foo``, після імпорту ``spam.foo``, ``spam`` матиме атрибут ``foo``, який "
"прив’язаний до підмодуля. Скажімо, у вас є така структура каталогів:"

msgid "and ``spam/__init__.py`` has the following line in it::"
msgstr "а ``spam/__init__.py`` містить такий рядок::"

msgid ""
"then executing the following puts name bindings for ``foo`` and ``Foo`` in "
"the ``spam`` module::"
msgstr ""
"потім виконання наступного ставить прив’язки імен для ``foo`` і ``Foo`` в "
"``spam`` модуль::"

msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Враховуючи знайомі правила прив’язки імен Python, це може здатися дивним, "
"але насправді це фундаментальна функція системи імпорту. Незмінним є те, що "
"якщо у вас є ``sys.modules['spam']`` і ``sys.modules['spam.foo']`` (як після "
"імпорту вище), останній повинен відображатися як атрибут ``foo`` першого."

msgid "Module spec"
msgstr "Специфікація модуля"

msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"Механізм імпорту використовує різноманітну інформацію про кожен модуль під "
"час імпорту, особливо перед завантаженням. Більшість інформації є спільною "
"для всіх модулів. Метою специфікації модуля є інкапсуляція цієї інформації, "
"пов’язаної з імпортом, на основі кожного модуля."

msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"Використання специфікації під час імпорту дозволяє передавати стан між "
"компонентами системи імпорту, наприклад. між шукачем, який створює "
"специфікацію модуля, і завантажувачем, який його виконує. Найважливіше те, "
"що це дозволяє імпортним механізмам виконувати стандартні операції "
"завантаження, тоді як без специфікації модуля цю відповідальність несе "
"завантажувач."

msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"Специфікація модуля представлена як атрибут ``__spec__`` в об’єкті модуля. "
"Дивіться :class:`~importlib.machinery.ModuleSpec`, щоб дізнатися більше про "
"вміст специфікації модуля."

msgid "Import-related module attributes"
msgstr "Атрибути модуля, пов’язані з імпортом"

msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr ""
"Механізм імпорту заповнює ці атрибути кожного об’єкта модуля під час "
"завантаження на основі специфікації модуля, перш ніж завантажувач виконає "
"модуль."

msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""
"Атрибут ``__name__`` має бути встановлений на повну назву модуля. Це ім’я "
"використовується для унікальної ідентифікації модуля в системі імпорту."

msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""
"Атрибут ``__loader__`` повинен бути встановлений на об’єкт завантажувача, "
"який імпорт використовував під час завантаження модуля. Це здебільшого для "
"самоаналізу, але може використовуватися для додаткових функцій "
"завантажувача, наприклад для отримання даних, пов’язаних із завантажувачем."

msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"Необхідно встановити атрибут ``__package__`` модуля. Його значення має бути "
"рядком, але воно може збігатися з його ``__name__``. Якщо модуль є пакетом, "
"його значення ``__package__`` має бути встановлено на його ``__name__``. "
"Якщо модуль не є пакетом, для ``__package__`` має бути встановлено порожній "
"рядок для модулів верхнього рівня або для підмодулів — ім’я батьківського "
"пакета. Додаткові відомості див. :pep:`366`."

msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"Цей атрибут використовується замість ``__name__`` для обчислення явного "
"відносного імпорту для основних модулів, як визначено в :pep:`366`. "
"Очікується, що він матиме те саме значення, що й ``__spec__.parent``."

msgid ""
"The value of ``__package__`` is expected to be the same as ``__spec__."
"parent``."
msgstr ""
"Очікується, що значення ``__package__`` буде таким самим, як ``__spec__."
"parent``."

msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module. Setting ``__spec__`` appropriately applies equally to :"
"ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"Атрибут ``__spec__`` має бути встановлений на специфікацію модуля, яка "
"використовувалася під час імпорту модуля. Налаштування ``__spec__`` належним "
"чином застосовується до :ref:`модулів, ініціалізованих під час запуску "
"інтерпретатора <programs>`. Єдиним винятком є ``__main__``, де ``__spec__`` :"
"ref:`встановлено на None у деяких випадках <main_spec>`."

msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr ""
"Якщо ``__package__`` не визначено, ``__spec__.parent`` використовується як "
"запасний варіант."

msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__spec__.parent`` використовується як запасний варіант, коли "
"``__package__`` не визначено."

msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""
"Якщо модуль є пакетом (звичайним або простором імен), необхідно встановити "
"атрибут ``__path__`` об’єкта модуля. Значення має бути повторюваним, але "
"може бути порожнім, якщо ``__path__`` не має подальшого значення. Якщо "
"``__path__`` не порожній, він повинен створювати рядки під час повторення. "
"Детальніше про семантику ``__path__`` наведено :ref:`нижче <package-path-"
"rules>`."

msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr "Непакетні модулі не повинні мати атрибут ``__path__``."

msgid ""
"``__file__`` is optional. If set, this attribute's value must be a string.  "
"The import system may opt to leave ``__file__`` unset if it has no semantic "
"meaning (e.g. a module loaded from a database)."
msgstr ""

msgid ""
"If ``__file__`` is set, it may also be appropriate to set the ``__cached__`` "
"attribute which is the path to any compiled version of the code (e.g. byte-"
"compiled file). The file does not need to exist to set this attribute; the "
"path can simply point to where the compiled file would exist (see :pep:"
"`3147`)."
msgstr ""

msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of ``__file__`` and/or ``__cached__``.  So if a loader can load "
"from a cached module but otherwise does not load from a file, that atypical "
"scenario may be appropriate."
msgstr ""

msgid "module.__path__"
msgstr "module.__path__"

msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr "За визначенням, якщо модуль має атрибут ``__path__``, це пакет."

msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""
"Атрибут ``__path__`` пакета використовується під час імпорту його "
"підпакетів. У механізмі імпорту він функціонує майже так само, як :data:`sys."
"path`, тобто надає список місць для пошуку модулів під час імпорту. Однак "
"``__path__`` зазвичай набагато більш обмежений, ніж :data:`sys.path`."

msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` має бути повторюваним рядком, але він може бути порожнім. Ті "
"самі правила, що використовуються для :data:`sys.path`, також застосовуються "
"до ``__path__`` пакета, а :data:`sys.path_hooks` (описані нижче) звертаються "
"під час проходження ``__path__`` пакета."

msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"Файл ``__init__.py`` пакета може встановлювати або змінювати атрибут "
"``__path__`` пакета, і це був типовий спосіб реалізації пакетів простору "
"імен до :pep:`420`. Із застосуванням :pep:`420` пакетам простору імен більше "
"не потрібно надавати файли ``__init__.py``, що містять лише ``__path__`` код "
"маніпуляції; механізм імпорту автоматично встановлює ``__path__`` правильно "
"для пакета простору імен."

msgid "Module reprs"
msgstr "Репрезентація модуля"

msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"За замовчуванням усі модулі мають придатне для використання відображення, "
"однак, залежно від атрибутів, налаштованих вище, і в специфікації модуля ви "
"можете чіткіше керувати відтворенням об’єктів модуля."

msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"Якщо модуль має специфікацію (``__spec__``), механізм імпорту спробує "
"згенерувати з неї repr. Якщо це не вдається або немає специфікації, система "
"імпорту створить відображення за замовчуванням, використовуючи будь-яку "
"інформацію, доступну в модулі. Він намагатиметься використати ``module."
"__name__``, ``module.__file__`` і ``module.__loader__`` як вхідні дані в "
"repr, із значеннями за замовчуванням для будь-якої інформації, якої немає."

msgid "Here are the exact rules used:"
msgstr "Ось точні правила, які використовуються:"

msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"Якщо модуль має атрибут ``__spec__``, інформація в специфікації "
"використовується для створення repr. Переглядаються атрибути \"name\", "
"\"loader\", \"origin\" і \"has_location\"."

msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"Якщо модуль має атрибут ``__file__``, він використовується як частина repr "
"модуля."

msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"Якщо модуль не має ``__file__``, але має ``__loader__``, який не є ``None``, "
"тоді repr завантажувача використовується як частина repr модуля."

msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "В іншому випадку просто використовуйте ``__name__`` модуля в repr."

msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
"Використання :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` "
"застаріло, і тепер специфікація модуля використовується механізмом імпорту "
"для створення модуля repr."

msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""
"Для зворотної сумісності з Python 3.3 модуль repr буде згенеровано шляхом "
"виклику методу :meth:`~importlib.abc.Loader.module_repr` завантажувача, якщо "
"він визначений, перед спробою будь-якого з описаних вище підходів. Однак "
"метод застарів."

msgid ""
"Calling :meth:`~importlib.abc.Loader.module_repr` now occurs after trying to "
"use a module's ``__spec__`` attribute but before falling back on "
"``__file__``. Use of :meth:`~importlib.abc.Loader.module_repr` is slated to "
"stop in Python 3.12."
msgstr ""
"Виклик :meth:`~importlib.abc.Loader.module_repr` тепер відбувається після "
"спроби використати атрибут ``__spec__`` модуля, але перед поверненням до "
"``__file__``. Використання :meth:`~importlib.abc.Loader.module_repr` "
"планується припинити в Python 3.12."

msgid "Cached bytecode invalidation"
msgstr "Анулювання кешованого байт-коду"

msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"Перед тим, як Python завантажить кешований байт-код із файлу ``.pyc``, він "
"перевіряє, чи оновлений кеш із вихідним файлом ``.py``. За замовчуванням "
"Python робить це, зберігаючи мітку часу останньої зміни джерела та розмір у "
"файлі кешу під час його запису. Під час виконання система імпорту потім "
"перевіряє кеш-файл, перевіряючи збережені в кеш-файлі метадані з метаданими "
"джерела."

msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python також підтримує кеш-файли на основі хешів, які зберігають хеш вмісту "
"вихідного файлу, а не його метаданих. Існує два варіанти хеш-файлів ``."
"pyc``: позначений і не позначений. Для перевірених хеш-файлів ``.pyc`` "
"Python перевіряє файл кешу, хешуючи вихідний файл і порівнюючи отриманий хеш "
"із хешем у файлі кешу. Якщо перевірений файл кешу на основі хешу виявляється "
"недійсним, Python повторно генерує його та записує новий перевірений файл "
"кешу на основі хешу. Для неперевірених файлів ``.pyc`` на основі хешу Python "
"просто припускає, що файл кешу дійсний, якщо він існує. Поведінка перевірки "
"файлів ``.pyc`` на основі хешу може бути замінена прапором :option:`--check-"
"hash-based-pycs`."

msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""
"Додано файли ``.pyc`` на основі хешу. Раніше Python підтримував лише "
"недійсність кешів байт-кодів на основі часових позначок."

msgid "The Path Based Finder"
msgstr "Пошук на основі шляху"

msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"Як згадувалося раніше, Python поставляється з декількома типовими засобами "
"пошуку меташляхів. Один із них, який називається :term:`пошук на основі "
"шляху` (:class:`~importlib.machinery.PathFinder`), шукає :term:`шлях "
"імпорту`, який містить список :term:`записів шляху <path entry>`. Кожен "
"запис шляху називає розташування для пошуку модулів."

msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"Сам шукач на основі шляху не знає, як нічого імпортувати. Замість цього він "
"проходить окремі записи шляху, пов’язуючи кожен із них із інструментом "
"пошуку записів шляху, який знає, як обробляти цей конкретний шлях."

msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"Стандартний набір засобів пошуку шляхів реалізує всю семантику для пошуку "
"модулів у файловій системі, обробки спеціальних типів файлів, таких як "
"вихідний код Python (файли ``.py``), байт-код Python (файли ``.pyc``) і "
"спільні бібліотеки (наприклад, файли ``.so``). Якщо підтримується модулем :"
"mod:`zipimport` у стандартній бібліотеці, засоби пошуку шляхів за "
"замовчуванням також обробляють завантаження всіх цих типів файлів (окрім "
"спільних бібліотек) із файлів zip."

msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"Записи шляху не повинні обмежуватися розташуванням файлової системи. Вони "
"можуть посилатися на URL-адреси, запити до бази даних або будь-яке інше "
"розташування, яке можна вказати як рядок."

msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"Шукач на основі шляху надає додаткові перехоплювачі та протоколи, щоб ви "
"могли розширювати та налаштовувати типи записів шляху для пошуку. Наприклад, "
"якщо ви хочете підтримувати записи шляху як мережеві URL-адреси, ви можете "
"написати хук, який реалізує семантику HTTP для пошуку модулів в Інтернеті. "
"Цей хук (об’єкт виклику) повертав би :term:`path entry finder`, що підтримує "
"описаний нижче протокол, який потім використовувався для отримання "
"завантажувача для модуля з Інтернету."

msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"Попередження: у цьому та попередньому розділах використовується термін "
"*finder*, розрізняючи їх за допомогою термінів :term:`meta path finder` і :"
"term:`path entry finder`. Ці два типи шукачів дуже схожі, підтримують схожі "
"протоколи та функціонують однаково під час процесу імпорту, але важливо мати "
"на увазі, що вони дещо відрізняються. Зокрема, шукачі меташляху працюють на "
"початку процесу імпорту, як ключ від обходу :data:`sys.meta_path`."

msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"Навпаки, засоби пошуку запису шляху є в певному сенсі деталлю реалізації "
"засобу пошуку шляху, і фактично, якби засіб пошуку шляху було вилучено з :"
"data:`sys.meta_path`, жодна семантика засобу пошуку шляху не буде "
"викликатися."

msgid "Path entry finders"
msgstr "Шукачі входу в шлях"

msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
":term:`path based finder` відповідає за пошук і завантаження модулів і "
"пакетів Python, розташування яких вказано за допомогою рядка :term:`path "
"entry`. Більшість записів шляхів іменують розташування у файловій системі, "
"але вони не повинні обмежуватися цим."

msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"Як мета-пошук шляху, :term:`пошук на основі шляху <path based finder>` "
"реалізує :meth:`~importlib.abc.MetaPathFinder.find_spec` протокол, описаний "
"раніше, однак він надає додаткові перехоплювачі, які можна використовувати "
"для налаштування способу пошуку модулів і завантажується з :term:`шляху "
"імпорту <import path>`."

msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
"Три змінні використовуються :term:`path based finder`, :data:`sys.path`, :"
"data:`sys.path_hooks` і :data:`sys.path_importer_cache`. Також "
"використовуються атрибути ``__path__`` об’єктів пакета. Це надає додаткові "
"способи налаштування імпортного обладнання."

msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings and bytes should be present on :data:`sys."
"path`; all other data types are ignored.  The encoding of bytes entries is "
"determined by the individual :term:`path entry finders <path entry finder>`."
msgstr ""
":data:`sys.path` містить список рядків, що містять місця пошуку для модулів "
"і пакетів. Він ініціалізується зі змінної оточення :data:`PYTHONPATH` та "
"інших інших значень за замовчуванням, які залежать від інсталяції та "
"реалізації. Записи в :data:`sys.path` можуть іменувати каталоги у файловій "
"системі, zip-файли та потенційно інші \"розташування\" (див. модуль :mod:"
"`site`), у яких слід шукати модулі, наприклад URL-адреси або запити до бази "
"даних. У :data:`sys.path` мають бути лише рядки та байти; всі інші типи "
"даних ігноруються. Кодування записів байтів визначається окремими :term:"
"`засобами пошуку записів шляху <path entry finder>`."

msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
":term:`пошук на основі шляху <meta path finder>` є :term:`метапошуком шляху "
"<meta path finder>`, тому механізм імпорту починає пошук :term:`шляху "
"імпорту <import path>`, викликаючи :meth:`~importlib.machinery.PathFinder "
"засобу пошуку на основі шляху метод .find_spec, як описано раніше. Коли "
"вказано аргумент ``path`` для :meth:`~importlib.machinery.PathFinder."
"find_spec`, це буде список шляхів до рядків, які потрібно пройти - зазвичай "
"атрибут ``__path__`` пакета для імпорту в цьому пакет. Якщо аргумент "
"``path`` має значення ``None``, це вказує на імпорт верхнього рівня та :data:"
"`sys.path` використовується."

msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be `stat()` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""
"Шукач на основі шляху повторює кожен запис у шляху пошуку та для кожного з "
"них шукає відповідний :term:`path entry finder` (:class:`~importlib.abc."
"PathEntryFinder`) для запису шляху. Оскільки це може бути дорогою операцією "
"(наприклад, для цього пошуку можуть виникати додаткові витрати на виклик "
"`stat()`), засіб пошуку на основі шляху підтримує кеш-пам’ять записів шляхів "
"у засоби пошуку записів шляху. Цей кеш зберігається в :data:`sys."
"path_importer_cache` (незважаючи на назву, цей кеш насправді зберігає "
"об’єкти пошуку, а не обмежується об’єктами :term:`importer`). Таким чином, "
"дорогий пошук конкретного :term:`path entry` розташування :term:`path entry "
"finder` потрібно виконати лише один раз. Код користувача може вільно "
"видаляти записи кешу з :data:`sys.path_importer_cache`, змушуючи шукач на "
"основі шляху знову виконати пошук запису шляху [#fnpic]_."

msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"Якщо запису шляху немає в кеші, пошук на основі шляху повторює кожен виклик "
"у :data:`sys.path_hooks`. Кожен із :term:`перехоплювачів запису шляху <path "
"entry hook>` у цьому списку викликається з одним аргументом, записом шляху, "
"який потрібно шукати. Цей виклик може повертати :term:`пошук запису шляху "
"<path entry finder>`, який може обробити запис шляху, або може викликати :"
"exc:`ImportError`. Помилка :exc:`ImportError` використовується шукачем на "
"основі шляху, щоб сигналізувати про те, що хук не може знайти :term:`пошук "
"запису шляху <path entry finder>` для цього :term:`запису шляху <path "
"entry>`. Виняток ігнорується, і повторення :term:`шляху імпорту <import "
"path>` продовжується. Хук повинен очікувати об'єкт string або bytes; "
"кодування об’єктів bytes залежить від хука (наприклад, це може бути "
"кодування файлової системи, UTF-8 або щось інше), і якщо хук не може "
"декодувати аргумент, він має викликати :exc:`ImportError`."

msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"Якщо :data:`sys.path_hooks` ітерація закінчується без повернення :term:`path "
"entry finder`, тоді метод пошуку на основі шляху :meth:`~importlib.machinery."
"PathFinder.find_spec` зберігатиме ``None`` у :data:`sys.path_importer_cache` "
"(щоб вказати, що немає засобу пошуку для цього запису шляху) і повернути "
"``None``, вказуючи, що цей :term:`meta path finder` не зміг знайти модуль."

msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"Якщо :term:`path entry finder` *повертається* одним із викликів :term:`path "
"entry hook` на :data:`sys.path_hooks`, тоді використовується наступний "
"протокол, щоб запитати модуль на пошуковик spec, який потім використовується "
"під час завантаження модуля."

msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"Поточний робочий каталог, позначений порожнім рядком, обробляється дещо "
"інакше, ніж інші записи в :data:`sys.path`. По-перше, якщо поточний робочий "
"каталог не існує, жодне значення не зберігається в :data:`sys."
"path_importer_cache`. По-друге, значення для поточного робочого каталогу "
"оновлюється для кожного пошуку модуля. По-третє, шлях, який використовується "
"для :data:`sys.path_importer_cache` і повертається :meth:`importlib."
"machinery.PathFinder.find_spec`, буде фактичним поточним робочим каталогом, "
"а не порожнім рядком."

msgid "Path entry finder protocol"
msgstr "Протокол пошуку входу шляху"

msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"Для того, щоб підтримувати імпорт модулів та ініціалізованих пакетів, а "
"також вносити частини до пакетів простору імен, засоби пошуку запису шляху "
"повинні реалізувати метод :meth:`~importlib.abc.PathEntryFinder.find_spec`."

msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` приймає два аргументи: "
"повне ім’я модуля, який імпортується, і (необов’язковий) цільовий модуль. "
"``find_spec()`` повертає повністю заповнену специфікацію для модуля. Ця "
"специфікація завжди матиме встановлений \"завантажувач\" (за одним винятком)."

msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets \"submodule_search_locations\" to "
"a list containing the portion."
msgstr ""
"Щоб вказати механізму імпорту, що специфікація представляє простір імен :"
"term:`portion`, засіб пошуку записів шляху встановлює "
"\"submodule_search_locations\" у список, що містить цю частину."

msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` замінив :meth:`~importlib."
"abc.PathEntryFinder.find_loader` і :meth:`~importlib.abc.PathEntryFinder."
"find_module`, обидва з яких тепер застаріли, але використовуватиметься, якщо "
"``find_spec()`` не визначено."

msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"Старіші засоби пошуку запису шляху можуть використовувати один із цих двох "
"застарілих методів замість ``find_spec()``. Методи досі поважаються заради "
"зворотної сумісності. Однак, якщо ``find_spec()`` реалізовано в пошуку "
"запису шляху, застарілі методи ігноруються."

msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` приймає один аргумент, "
"повну назву модуля, який імпортується. ``find_loader()`` повертає 2-кортеж, "
"де перший елемент є завантажувачем, а другий — простором імен :term:"
"`portion`."

msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"Для зворотної сумісності з іншими реалізаціями протоколу імпорту багато "
"засобів пошуку шляхів також підтримують той самий традиційний метод "
"``find_module()``, який підтримують засоби пошуку меташляхів. Однак методи "
"Find_module() засобу пошуку записів шляху ніколи не викликаються з "
"аргументом ``path`` (вони мають записати відповідну інформацію про шлях від "
"початкового виклику до перехоплення шляху)."

msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"Метод ``find_module()`` для засобів пошуку записів шляху застарів, оскільки "
"він не дозволяє засобу пошуку записів шляху вносити частини до пакетів "
"простору імен. Якщо і \"find_loader()\", і \"find_module()\" існують у "
"пошуку запису шляху, система імпорту завжди викличе \"find_loader()\", а не "
"\"find_module()\"."

msgid ""
"Calls to :meth:`~importlib.abc.PathEntryFinder.find_module` and :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` by the import system will "
"raise :exc:`ImportWarning`."
msgstr ""
"Виклики :meth:`~importlib.abc.PathEntryFinder.find_module` і :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` системою імпорту викликають :"
"exc:`ImportWarning`."

msgid "Replacing the standard import system"
msgstr "Заміна стандартної системи імпорту"

msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"Найнадійнішим механізмом заміни всієї системи імпорту є видалення вмісту за "
"замовчуванням :data:`sys.meta_path`, повністю замінивши його спеціальним "
"хуком мета-шляху."

msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"Якщо прийнятно лише змінювати поведінку операторів імпорту, не впливаючи на "
"інші API, які отримують доступ до системи імпорту, тоді заміни вбудованої "
"функції :func:`__import__` може бути достатньо. Цю техніку також можна "
"використовувати на рівні модуля лише для зміни поведінки операторів імпорту "
"в цьому модулі."

msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"Щоб вибірково запобігти імпорту деяких модулів із хука на ранній стадії "
"меташляху (замість повного відключення стандартної системи імпорту), "
"достатньо викликати :exc:`ModuleNotFoundError` безпосередньо з :meth:"
"`~importlib.abc.MetaPathFinder .find_spec` замість повернення ``None``. "
"Останнє вказує на те, що пошук меташляху має продовжуватися, тоді як виклик "
"винятку негайно припиняє його."

msgid "Package Relative Imports"
msgstr "Відносний імпорт пакетів"

msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"Для відносного імпорту використовуються крапки на початку. Одна крапка на "
"початку вказує на відносний імпорт, починаючи з поточного пакета. Дві або "
"більше крапок на початку вказують на відносний імпорт до батьківського(их) "
"пакета(ів) поточного пакета, один рівень на кожну крапку після першого. "
"Наприклад, враховуючи такий макет пакета:"

msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"У ``subpackage1/moduleX.py`` або ``subpackage1/__init__.py`` наступні дійсні "
"відносні імпорти:"

msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""
"Абсолютний імпорт може використовувати або синтаксис ``import <>`` або "
"``from <> import <>``, але відносний імпорт може використовувати лише другу "
"форму; причина цього в тому, що::"

msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""
"має показувати ``XXX.YYY.ZZZ`` як придатний вираз, але .moduleY не є дійсним "
"виразом."

msgid "Special considerations for __main__"
msgstr "Особливі міркування для __main__"

msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
"Модуль :mod:`__main__` є окремим випадком щодо системи імпорту Python. Як "
"зазначено :ref:`в іншому місці <programs>`, модуль ``__main__`` "
"безпосередньо ініціалізується під час запуску інтерпретатора, подібно до :"
"mod:`sys` і :mod:`builtins`. Однак, на відміну від цих двох, він не "
"кваліфікується як вбудований модуль. Це пояснюється тим, що спосіб "
"ініціалізації ``__main__`` залежить від прапорів та інших параметрів, з "
"якими викликається інтерпретатор."

msgid "__main__.__spec__"
msgstr "__main__.__spec__"

msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
"Залежно від того, як :mod:`__main__` ініціалізовано, ``__main__.__spec__`` "
"встановлюється відповідним чином або має значення ``None``."

msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Коли Python запускається з параметром :option:`-m`, ``__spec__`` "
"встановлюється на специфікацію модуля відповідного модуля або пакета. "
"``__spec__`` також заповнюється, коли модуль ``__main__`` завантажується як "
"частина виконання каталогу, zip-файлу або іншого запису :data:`sys.path`."

msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
"У :ref:`решті випадків <using-on-interface-options>` ``__main__.__spec__`` "
"встановлено на ``None``, оскільки код, який використовується для заповнення :"
"mod:`__main__`, не відповідає безпосередньо імпортованому модулю:"

msgid "interactive prompt"
msgstr "інтерактивна підказка"

msgid ":option:`-c` option"
msgstr "Параметр :option:`-c`"

msgid "running from stdin"
msgstr "працює з stdin"

msgid "running directly from a source or bytecode file"
msgstr "працює безпосередньо з джерела або файлу байт-коду"

msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"Зауважте, що ``__main__.__spec__`` завжди має значення ``None`` в останньому "
"випадку, *навіть якщо* технічно файл можна імпортувати безпосередньо як "
"модуль. Використовуйте перемикач :option:`-m`, якщо потрібні дійсні метадані "
"модуля в :mod:`__main__`."

msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"Зауважте також, що навіть якщо ``__main__`` відповідає імпортованому модулю, "
"а ``__main__.__spec__`` встановлено відповідно, вони все одно вважаються "
"*окремими* модулями. Це пов’язано з тим, що блоки, які захищаються "
"перевірками ``if __name__ == \"__main__\":``, виконуються лише тоді, коли "
"модуль використовується для заповнення простору імен ``__main__``, а не під "
"час звичайного імпорту."

msgid "Open issues"
msgstr "Відкриті питання"

msgid "XXX It would be really nice to have a diagram."
msgstr "XXX Було б дуже добре мати діаграму."

msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting "
"the related entries in the data model reference page?"
msgstr ""
"XXX * (import_machinery.rst) як щодо розділу, присвяченого лише атрибутам "
"модулів і пакетів, можливо, розширюючи або замінюючи відповідні записи на "
"довідковій сторінці моделі даних?"

msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See Also\" "
"links at the top pointing to the new import system section."
msgstr ""
"Усі XXX runpy, pkgutil та інші в посібнику з бібліотеки мають отримати "
"посилання \"Див. також\" угорі, які вказують на новий розділ системи імпорту."

msgid ""
"XXX Add more explanation regarding the different ways in which ``__main__`` "
"is initialized?"
msgstr ""
"XXX Додати додаткові пояснення щодо різних способів ініціалізації "
"``__main__``?"

msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from :pep:"
"`395`)."
msgstr ""
"XXX Додайте більше інформації про особливості/підводні камені ``__main__`` "
"(наприклад, копія з :pep:`395`)."

msgid "References"
msgstr "Список літератури"

msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"Механізм імпорту значно розвинувся з перших днів Python. Оригінальна "
"`специфікація пакетів <https://www.python.org/doc/essays/packages/>`_ все ще "
"доступна для читання, хоча деякі деталі змінилися з моменту написання цього "
"документа."

msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"Початкова специфікація для :data:`sys.meta_path` була :pep:`302` з подальшим "
"розширенням у :pep:`420`."

msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
":pep:`420` представлено :term:`пакети простору імен <namespace package>` для "
"Python 3.3. :pep:`420` також представив протокол :meth:`find_loader` як "
"альтернативу :meth:`find_module`."

msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` описує додавання атрибута ``__package__`` для явного відносного "
"імпорту в основні модулі."

msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` ввів абсолютний і явний відносний імпорт і спочатку запропонував "
"``__name__`` для семантики :pep:`366` згодом вказав би для ``__package__``."

msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` визначає модулі виконання як скрипти."

msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` додає інкапсуляцію стану імпорту кожного модуля в специфікаційні "
"об’єкти. Це також перекладає більшість шаблонних обов’язків вантажників "
"назад на імпортну техніку. Ці зміни дозволяють припинити підтримку кількох "
"API у системі імпорту, а також додати нові методи до засобів пошуку та "
"завантаження."

msgid "Footnotes"
msgstr "Виноски"

msgid "See :class:`types.ModuleType`."
msgstr "Див. :class:`types.ModuleType`."

msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"Реалізація importlib уникає безпосереднього використання значення, що "
"повертається. Натомість він отримує об’єкт module, шукаючи ім’я модуля в :"
"data:`sys.modules`. Непрямим наслідком цього є те, що імпортований модуль "
"може замінити себе в :data:`sys.modules`. Це специфічна поведінка "
"реалізації, яка не гарантовано працюватиме в інших реалізаціях Python."

msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""
"У застарілому коді можна знайти екземпляри :class:`imp.NullImporter` в :data:"
"`sys.path_importer_cache`. Рекомендується змінити код, щоб замість нього "
"використовувати ``None``. Додаткову інформацію див. у :ref:"
"`portingpythoncode`."
