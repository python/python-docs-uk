# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Simple statements"
msgstr "Прості твердження"

msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Просте твердження міститься в одному логічному рядку. В одному рядку, "
"розділених крапкою з комою, може бути кілька простих операторів. Синтаксис "
"простих операторів такий:"

msgid "Expression statements"
msgstr "Вирази"

msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"Інструкції-вирази використовуються (здебільшого в інтерактивному режимі) для "
"обчислення та запису значення або (зазвичай) для виклику процедури (функції, "
"яка не повертає значущого результату; у Python процедури повертають значення "
"``None``). Інші способи використання операторів-виразів дозволені та інколи "
"корисні. Синтаксис оператора виразу:"

msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""
"Оператор виразу обчислює список виразів (який може бути одним виразом)."

msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"В інтерактивному режимі, якщо значення не є ``None``, воно перетворюється на "
"рядок за допомогою вбудованої функції :func:`repr`, а отриманий рядок "
"записується до стандартного виводу в окремому рядку (крім випадків, коли "
"результатом є ``None``, так що виклики процедур не викликають жодних "
"виводів.)"

msgid "Assignment statements"
msgstr "Заяви про призначення"

msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"Оператори присвоєння використовуються для (повторного) прив’язування імен до "
"значень і для зміни атрибутів або елементів змінних об’єктів:"

msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"(Див. розділ :ref:`primaries` для визначення синтаксису для *attributeref*, "
"*subscription* і *slicing*.)"

msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"Інструкція присвоєння оцінює список виразів (пам’ятайте, що це може бути "
"один вираз або список, розділений комами, останній дає кортеж) і призначає "
"єдиний результуючий об’єкт кожному з цільових списків зліва направо."

msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"Присвоєння визначається рекурсивно залежно від форми цілі (списку). Коли "
"ціль є частиною змінного об’єкта (посилання на атрибут, підписка або зріз), "
"змінний об’єкт повинен остаточно виконати призначення та прийняти рішення "
"про його достовірність і може викликати виняток, якщо призначення є "
"неприйнятним. Правила, яких дотримуються різні типи, і винятки, які "
"виникають, наведені разом із визначенням типів об’єктів (див. розділ :ref:"
"`types`)."

msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"Призначення об’єкта цільовому списку, необов’язково укладеному в круглі або "
"квадратні дужки, рекурсивно визначається наступним чином."

msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Якщо цільовий список є одним цільовим об’єктом без кінцевої коми, "
"необов’язково в дужках, об’єкт призначається цій цільовій цілі."

msgid "Else:"
msgstr "ще:"

msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"Якщо цільовий список містить одну ціль із префіксом зірочки, це називається "
"ціль із зірочкою: об’єкт має бути ітерованим із принаймні такою кількістю "
"елементів, скільки цілей у списку цілей, мінус один. Перші елементи iterable "
"призначаються, зліва направо, цілям перед ціллю, позначеною зірочкою. "
"Останні елементи iterable призначаються цілям після цілі, позначеної "
"зірочкою. Список елементів, що залишилися в iterable, потім призначається "
"позначеній цілі (список може бути порожнім)."

msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Інакше: об’єкт має бути ітерованим із такою ж кількістю елементів, як цілей "
"у списку цілей, а елементи призначаються зліва направо відповідним цілям."

msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"Призначення об'єкта одній меті рекурсивно визначається наступним чином."

msgid "If the target is an identifier (name):"
msgstr "Якщо метою є ідентифікатор (ім’я):"

msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"Якщо ім’я не зустрічається в операторі :keyword:`global` або :keyword:"
"`nonlocal` у поточному блоці коду: ім’я прив’язується до об’єкта в поточному "
"локальному просторі імен."

msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Інакше: ім’я прив’язується до об’єкта в глобальному просторі імен або "
"зовнішньому просторі імен, визначеному :keyword:`nonlocal` відповідно."

msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"Ім'я повертається, якщо воно вже було зв'язане. Це може призвести до того, "
"що кількість посилань для об’єкта, раніше прив’язаного до імені, досягне "
"нуля, що призведе до звільнення об’єкта та виклику його деструктора (якщо "
"він є)."

msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"Якщо метою є посилання на атрибут: обчислюється основний вираз у посиланні. "
"Він повинен давати об’єкт із присвоюваними атрибутами; якщо це не так, "
"виникає :exc:`TypeError`. Тоді цей об’єкт запитується призначити призначений "
"об’єкт даному атрибуту; якщо він не може виконати призначення, він викликає "
"виняток (зазвичай, але не обов’язково :exc:`AttributeError`)."

msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"Примітка. Якщо об’єкт є екземпляром класу, а посилання на атрибут міститься "
"з обох сторін оператора присвоєння, вираз у правому боці ``a.x`` може "
"отримати доступ або до атрибута екземпляра, або (якщо атрибут екземпляра не "
"існує) до класу атрибут. Ліва ціль ``a.x`` завжди встановлюється як атрибут "
"екземпляра, створюючи його за необхідності. Таким чином, два входження ``a."
"x`` не обов’язково посилаються на той самий атрибут: якщо правий вираз "
"посилається на атрибут класу, ліва частина створює новий атрибут екземпляра "
"як ціль призначення: :"

msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Цей опис не обов’язково стосується атрибутів дескрипторів, таких як "
"властивості, створені за допомогою :func:`property`."

msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"Якщо метою є підписка: обчислюється основний вираз у посиланні. Він повинен "
"давати або об’єкт змінної послідовності (наприклад, список), або об’єкт "
"відображення (наприклад, словник). Далі обчислюється нижній індекс."

msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"Якщо основний об’єкт є змінним об’єктом послідовності (наприклад, список), "
"нижній індекс повинен давати ціле число. Якщо він від’ємний, до нього "
"додається довжина послідовності. Отримане значення має бути невід’ємним "
"цілим числом, меншим за довжину послідовності, і послідовності пропонується "
"призначити призначений об’єкт своєму елементу з цим індексом. Якщо індекс "
"виходить за межі діапазону, виникає :exc:`IndexError` (присвоєння "
"послідовності з індексом не може додавати нові елементи до списку)."

msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"Якщо основним є об’єкт відображення (наприклад, словник), нижній індекс "
"повинен мати тип, сумісний із типом ключа відображення, а потім відображення "
"запитується створити пару ключ/дані, яка відображає підіндекс у призначений "
"об’єкт. Це може або замінити наявну пару ключ/значення тим самим значенням "
"ключа, або вставити нову пару ключ/значення (якщо ключа з таким самим "
"значенням не існує)."

msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""
"Для об’єктів, визначених користувачем, метод :meth:`__setitem__` "
"викликається з відповідними аргументами."

msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"Якщо метою є нарізка: обчислюється основний вираз у посиланні. Він повинен "
"давати змінний об’єкт послідовності (наприклад, список). Призначений об’єкт "
"має бути об’єктом послідовності того самого типу. Далі обчислюються вирази "
"нижньої та верхньої межі, якщо вони присутні; за замовчуванням нуль і "
"довжина послідовності. Межі повинні обчислюватися як цілі числа. Якщо будь-"
"яка межа негативна, до неї додається довжина послідовності. Отримані межі "
"обрізаються між нулем і довжиною послідовності включно. Нарешті, об’єкту "
"послідовності пропонується замінити зріз елементами призначеної "
"послідовності. Довжина зрізу може відрізнятися від довжини призначеної "
"послідовності, таким чином змінюючи довжину цільової послідовності, якщо це "
"дозволяє цільова послідовність."

msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"У поточній реалізації синтаксис для цілей вважається таким самим, як і для "
"виразів, а недійсний синтаксис відхиляється під час фази генерації коду, "
"викликаючи менш докладні повідомлення про помилки."

msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"Хоча визначення присвоєння передбачає, що збіги між лівою та правою "
"сторонами є \"одночасними\" (наприклад, ``a, b = b, a`` міняє місцями дві "
"змінні), збіги *в* колекції присвоєні змінним відбуваються зліва направо, що "
"іноді призводить до плутанини. Наприклад, наступна програма друкує ``[0, "
"2]``::"

msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Розширене ітераційне розпакування"

msgid "The specification for the ``*target`` feature."
msgstr "Специфікація функції ``*target``."

msgid "Augmented assignment statements"
msgstr "Доповнені заяви про призначення"

msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"Розширене присвоєння — це комбінація в одному операторі двійкової операції "
"та оператора присвоєння:"

msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"(Див. розділ :ref:`primaries` для визначення синтаксису останніх трьох "
"символів.)"

msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"Розширене призначення оцінює ціль (яка, на відміну від звичайних операторів "
"призначення, не може бути розпаковуванням) і список виразів, виконує "
"двійкову операцію, специфічну для типу призначення над двома операндами, і "
"призначає результат вихідній цільовій цілі. Ціль оцінюється лише один раз."

msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"Вираз розширеного присвоєння, як-от ``x += 1``, можна переписати як ``x = x "
"+ 1``, щоб досягти подібного, але не зовсім рівного ефекту. У доповненій "
"версії ``x`` обчислюється лише один раз. Крім того, якщо можливо, фактична "
"операція виконується *на місці*, тобто замість створення нового об’єкта та "
"призначення його цільовому об’єкту змінюється старий об’єкт."

msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"На відміну від звичайних завдань, розширені завдання оцінюють ліву сторону "
"*перед* оцінкою правої сторони. Наприклад, ``a[i] += f(x)`` спочатку шукає "
"``a[i]``, потім обчислює ``f(x)`` і виконує додавання, і, нарешті, він "
"записує результат назад до ``a[i]``."

msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"За винятком призначення кортежам і декільком цілям в одному операторі, "
"призначення, виконане доповненими операторами призначення, обробляється так "
"само, як і звичайні призначення. Подібним чином, за винятком можливої "
"поведінки *на місці*, двійкова операція, що виконується розширеним "
"призначенням, є такою самою, як і звичайні двійкові операції."

msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"Для цілей, які є посиланнями на атрибути, застосовується те саме :ref:"
"`застереження щодо атрибутів класу та екземпляра <attr-target-note>`, що й "
"для звичайних призначень."

msgid "Annotated assignment statements"
msgstr "Анотовані заяви про призначення"

msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
":term:`Анотація <variable annotation>` присвоєння — це комбінація в одному "
"операторі анотації змінної або атрибута та необов’язкового оператора "
"призначення:"

msgid ""
"The difference from normal :ref:`assignment` is that only single target is "
"allowed."
msgstr ""
"Відмінність від звичайного :ref:`assignment` полягає в тому, що дозволена "
"лише одна мета."

msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute :"
"attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution, "
"if annotations are found statically."
msgstr ""
"Для простих імен як цілей призначення, якщо вони знаходяться в області класу "
"або модуля, анотації оцінюються та зберігаються в спеціальному атрибуті "
"класу або модуля :attr:`__annotations__`, який є словниковим відображенням "
"імен змінних (спотворених, якщо приватні) до оцінюваних анотацій. Цей "
"атрибут доступний для запису та автоматично створюється на початку виконання "
"класу або тіла модуля, якщо анотації знайдено статично."

msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr ""
"Для виразів як цілей призначення анотації оцінюються, якщо вони знаходяться "
"в області класу або модуля, але не зберігаються."

msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Якщо ім’я анотовано в області видимості функції, то це ім’я є локальним для "
"цієї області. Анотації ніколи не оцінюються та зберігаються в областях "
"функцій."

msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or :"
"meth:`__setattr__` call."
msgstr ""
"Якщо присутня права сторона, анотоване призначення виконує фактичне "
"призначення перед оцінкою анотацій (де це можливо). Якщо права сторона "
"відсутня для цільового виразу, то інтерпретатор оцінює ціль, за винятком "
"останнього виклику :meth:`__setitem__` або :meth:`__setattr__`."

msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Синтаксис для анотацій змінних"

msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"Пропозиція, яка додала синтаксис для анотування типів змінних (включаючи "
"змінні класу та змінні екземпляра), замість вираження їх через коментарі."

msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Тип підказок"

msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"Пропозиція, яка додала модуль :mod:`typing`, щоб забезпечити стандартний "
"синтаксис для анотацій типів, які можна використовувати в інструментах "
"статичного аналізу та IDE."

msgid ""
"Now annotated assignments allow same expressions in the right hand side as "
"the regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""
"Тепер анотовані призначення допускають ті самі вирази в правій частині, що й "
"звичайні призначення. Раніше деякі вирази (наприклад, вирази кортежу без "
"дужок) викликали синтаксичну помилку."

msgid "The :keyword:`!assert` statement"
msgstr "Оператор :keyword:`!assert`"

msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"Оператори Assert — це зручний спосіб вставити в програму твердження "
"налагодження:"

msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "Проста форма, ``assert expression``, еквівалентна ::"

msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr "Розширена форма, ``assert expression1, expression2``, еквівалентна ::"

msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an "
"assert statement when optimization is requested at compile time.  Note that "
"it is unnecessary to include the source code for the expression that failed "
"in the error message; it will be displayed as part of the stack trace."
msgstr ""
"Ці еквівалентності припускають, що :const:`__debug__` і :exc:"
"`AssertionError` посилаються на вбудовані змінні з цими іменами. У поточній "
"реалізації вбудована змінна :const:`__debug__` має значення ``True`` за "
"звичайних обставин, ``False``, коли запитується оптимізація (параметр "
"командного рядка :option:`-O`). Поточний генератор коду не видає код для "
"оператора assert, коли під час компіляції запитується оптимізація. Зауважте, "
"що немає потреби включати вихідний код для виразу, що не вдалося виконати, у "
"повідомленні про помилку; він буде відображатися як частина трасування стека."

msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Присвоєння :const:`__debug__` є незаконним. Значення для вбудованої змінної "
"визначається під час запуску інтерпретатора."

msgid "The :keyword:`!pass` statement"
msgstr "Оператор :keyword:`!pass`"

msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` є нульовою операцією --- коли вона виконується, нічого не "
"відбувається. Це корисно як заповнювач, коли оператор потрібний синтаксично, "
"але не потрібно виконувати код, наприклад::"

msgid "The :keyword:`!del` statement"
msgstr "Оператор :keyword:`!del`"

msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"Видалення рекурсивно визначається дуже подібно до того, як визначається "
"призначення. Замість того, щоб викладати все детально, ось кілька підказок."

msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "Видалення списку цілей рекурсивно видаляє кожну ціль зліва направо."

msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"Видалення імені видаляє прив’язку цього імені до локального чи глобального "
"простору імен, залежно від того, чи зустрічається ім’я в операторі :keyword:"
"`global` у тому самому блоці коду. Якщо ім’я не зв’язане, буде викликано "
"виняток :exc:`NameError`."

msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"Видалення посилань на атрибути, підписок і фрагментів передається до "
"основного задіяного об’єкта; Видалення фрагмента загалом еквівалентно "
"присвоєнню порожньому фрагменту потрібного типу (але навіть це визначається "
"об’єктом фрагмента)."

msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Раніше було заборонено видаляти ім’я з локального простору імен, якщо воно "
"зустрічається як вільна змінна у вкладеному блоці."

msgid "The :keyword:`!return` statement"
msgstr "Оператор :keyword:`!return`"

msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` може бути лише синтаксично вкладеним у визначення функції, "
"а не у визначенні вкладеного класу."

msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Якщо присутній список виразів, він обчислюється, інакше замінюється ``None``."

msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` залишає поточний виклик функції зі списком виразів (або "
"``None``) як значення повернення."

msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"Коли :keyword:`return` передає керування оператору :keyword:`try` з "
"пропозицією :keyword:`finally`, ця пропозиція :keyword:`!finally` "
"виконується перед фактичним виходом із функції."

msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"У функції генератора оператор :keyword:`return` вказує на те, що генератор "
"завершено та спричинить виклик :exc:`StopIteration`. Повернене значення (за "
"наявності) використовується як аргумент для створення :exc:`StopIteration` і "
"стає атрибутом :attr:`StopIteration.value`."

msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"У функції асинхронного генератора порожній оператор :keyword:`return` вказує "
"на те, що асинхронний генератор завершено та призведе до виклику :exc:"
"`StopAsyncIteration`. Непорожній оператор :keyword:`!return` є синтаксичною "
"помилкою у функції асинхронного генератора."

msgid "The :keyword:`!yield` statement"
msgstr "Оператор :keyword:`!yield`"

msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
"Оператор :keyword:`yield` семантично еквівалентний виразу :ref:`yield "
"<yieldexpr>`. Оператор yield можна використовувати, щоб опустити дужки, які "
"в іншому випадку були б потрібні в еквівалентному операторі виразу yield. "
"Наприклад, оператори yield::"

msgid "are equivalent to the yield expression statements ::"
msgstr "еквівалентні операторам виразу yield ::"

msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""
"Вирази й оператори yield використовуються лише під час визначення функції :"
"term:`generator` і лише в тілі функції-генератора. Використання yield у "
"визначенні функції достатньо, щоб це визначення створювало функцію-генератор "
"замість звичайної функції."

msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
"Щоб отримати повну інформацію про семантику :keyword:`yield`, зверніться до "
"розділу :ref:`yieldexpr`."

msgid "The :keyword:`!raise` statement"
msgstr "Оператор :keyword:`!raise`"

msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"Якщо виразів немає, :keyword:`raise` повторно викликає виняток, який зараз "
"обробляється, який також відомий як *активний виняток*. Якщо наразі немає "
"активного винятку, виникає виняток :exc:`RuntimeError`, який вказує на те, "
"що це помилка."

msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"В іншому випадку :keyword:`raise` обчислює перший вираз як об’єкт винятку. "
"Це має бути або підклас, або екземпляр :class:`BaseException`. Якщо це клас, "
"екземпляр винятку буде отримано за потреби шляхом створення екземпляра класу "
"без аргументів."

msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
":dfn:`type` винятку — це клас екземпляра винятку, :dfn:`value` — це сам "
"екземпляр."

msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""
"Об’єкт трасування зазвичай створюється автоматично, коли виникає виняток і "
"додається до нього як атрибут :attr:`__traceback__`, який доступний для "
"запису. Ви можете створити виняток і встановити власну трасування одним "
"кроком за допомогою методу винятку :meth:`~BaseException.with_traceback` "
"(який повертає той самий екземпляр винятку, з його трасуванням, встановленим "
"для його аргументу), наприклад:"

msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`__cause__` attribute (which is writable). If the "
"expression is an exception class, the class will be instantiated and the "
"resulting exception instance will be attached to the raised exception as "
"the :attr:`__cause__` attribute. If the raised exception is not handled, "
"both exceptions will be printed::"
msgstr ""
"Речення ``from`` використовується для ланцюжка винятків: якщо задано, другий "
"*вираз* має бути іншим класом винятків або екземпляром. Якщо другий вираз є "
"екземпляром винятку, його буде приєднано до викликаного винятку як атрибут :"
"attr:`__cause__` (який доступний для запису). Якщо вираз є класом винятку, "
"екземпляр класу буде створено, а отриманий екземпляр винятку буде додано до "
"викликаного винятку як атрибут :attr:`__cause__`. Якщо викликаний виняток не "
"оброблено, обидва виключення будуть надруковані::"

msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`__context__` attribute::"
msgstr ""
"Подібний механізм працює неявно, якщо виникає новий виняток, коли виняток "
"уже обробляється. Виняток може бути оброблено, коли використовується "
"речення :keyword:`except` або :keyword:`finally` або оператор :keyword:"
"`with`. Потім попередній виняток додається як атрибут :attr:`__context__` "
"нового винятку::"

msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr ""
"Ланцюжки винятків можна явно придушити, вказавши :const:`None` у пункті "
"``from``::"

msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"Додаткову інформацію про винятки можна знайти в розділі :ref:`exceptions`, а "
"інформацію про обробку винятків — у розділі :ref:`try`."

msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` тепер дозволено як ``Y`` у ``raise X from Y``."

msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr ""
"Атрибут ``__suppress_context__`` для придушення автоматичного відображення "
"контексту винятку."

msgid "The :keyword:`!break` statement"
msgstr "Оператор :keyword:`!break`"

msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` може бути лише синтаксично вкладеним у циклі :keyword:`for` "
"або :keyword:`while`, але не вкладеним у визначення функції чи класу в цьому "
"циклі."

msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
"Він завершує найближчий охоплюючий цикл, пропускаючи необов’язкову "
"пропозицію :keyword:`!else`, якщо вона є в циклі."

msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
"Якщо цикл :keyword:`for` завершується :keyword:`break`, мета керування "
"циклом зберігає своє поточне значення."

msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"Коли :keyword:`break` передає керування оператору :keyword:`try` з "
"пропозицією :keyword:`finally`, ця пропозиція :keyword:`!finally` "
"виконується перед тим, як фактично вийти з циклу."

msgid "The :keyword:`!continue` statement"
msgstr "Оператор :keyword:`!continue`"

msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""
":keyword:`continue` може бути лише синтаксично вкладеним у циклі :keyword:"
"`for` або :keyword:`while`, але не вкладеним у визначення функції чи класу в "
"цьому циклі. Він продовжується наступним циклом найближчого охоплюючого "
"циклу."

msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"Коли :keyword:`continue` передає керування оператору :keyword:`try` з "
"пропозицією :keyword:`finally`, ця пропозиція :keyword:`!finally` "
"виконується перед тим, як справді розпочнеться наступний цикл циклу."

msgid "The :keyword:`!import` statement"
msgstr "Оператор :keyword:`!import`"

msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"Базовий оператор імпорту (без пропозиції :keyword:`from`) виконується у два "
"кроки:"

msgid "find a module, loading and initializing it if necessary"
msgstr "знайти модуль, завантаживши та ініціалізувавши його, якщо необхідно"

msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
"визначте ім’я або імена в локальному просторі імен для області, де виникає "
"оператор :keyword:`import`."

msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"Якщо оператор містить кілька пунктів (розділених комами), два кроки "
"виконуються окремо для кожного пункту, так само, як якщо б пункти були "
"розділені на окремі оператори імпорту."

msgid ""
"The details of the first step, finding and loading modules are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Деталі першого кроку, пошуку та завантаження модулів, описано більш детально "
"в розділі про :ref:`систему імпорту <importsystem>`, де також описано різні "
"типи пакетів і модулів, які можна імпортувати, а також усі хуки, які можна "
"використовувати для налаштування системи імпорту. Зауважте, що помилки на "
"цьому кроці можуть означати те, що модуль не вдалося знайти, *або* те, що "
"під час ініціалізації модуля сталася помилка, яка включає виконання коду "
"модуля."

msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"Якщо запитуваний модуль успішно отримано, він стане доступним у локальному "
"просторі імен одним із трьох способів:"

msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Якщо ім’я модуля супроводжується :keyword:`!as`, тоді ім’я після :keyword:`!"
"as` прив’язується безпосередньо до імпортованого модуля."

msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"Якщо інше ім’я не вказано, а імпортований модуль є модулем верхнього рівня, "
"ім’я модуля зв’язується в локальному просторі імен як посилання на "
"імпортований модуль"

msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"Якщо імпортований модуль *не* є модулем верхнього рівня, тоді ім’я пакета "
"верхнього рівня, який містить модуль, прив’язується до локального простору "
"імен як посилання на пакет верхнього рівня. Доступ до імпортованого модуля "
"потрібно отримати, використовуючи його повне кваліфіковане ім’я, а не "
"безпосередньо"

msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "Форма :keyword:`from` використовує дещо складніший процес:"

msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"знайти модуль, указаний у пункті :keyword:`from`, завантажуючи та "
"ініціалізуючи його, якщо необхідно;"

msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr "для кожного з ідентифікаторів, указаних у пунктах :keyword:`import`:"

msgid "check if the imported module has an attribute by that name"
msgstr "перевірте, чи імпортований модуль має атрибут із таким іменем"

msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"якщо ні, спробуйте імпортувати підмодуль із такою назвою, а потім знову "
"перевірте імпортований модуль на наявність цього атрибута"

msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "якщо атрибут не знайдено, виникає :exc:`ImportError`."

msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"інакше посилання на це значення зберігається в локальному просторі імен, "
"використовуючи ім’я в реченні :keyword:`!as`, якщо воно присутнє, інакше "
"використовується ім’я атрибута"

msgid "Examples::"
msgstr "Приклади::"

msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Якщо список ідентифікаторів замінено зірочкою (``'*'``), усі "
"загальнодоступні імена, визначені в модулі, прив’язуються до локального "
"простору імен для області, де виникає оператор :keyword:`import`."

msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"*Відкриті імена*, визначені модулем, визначаються шляхом перевірки простору "
"імен модуля для змінної з назвою ``__all__``; якщо визначено, це має бути "
"послідовність рядків, які є іменами, визначеними або імпортованими цим "
"модулем. Усі назви, наведені в ``__all__``, вважаються загальнодоступними та "
"мають існувати. Якщо ``__all__`` не визначено, набір загальнодоступних імен "
"включає всі імена, знайдені в просторі імен модуля, які не починаються зі "
"символу підкреслення (``'_'``). ``__all__`` має містити весь публічний API. "
"Це призначено для уникнення випадкового експорту елементів, які не є "
"частиною API (наприклад, бібліотечних модулів, які були імпортовані та "
"використані в модулі)."

msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"Форма імпорту із символом підстановки --- ``з імпорту модуля *`` --- "
"дозволена лише на рівні модуля. Спроба використати його у визначеннях класу "
"чи функції викличе :exc:`SyntaxError`."

msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"Визначаючи, який модуль імпортувати, не потрібно вказувати абсолютну назву "
"модуля. Коли модуль або пакунок міститься в іншому пакунку, можна виконати "
"відносний імпорт у той самий верхній пакунок, не вказуючи назву пакунка. "
"Використовуючи крапки на початку у вказаному модулі чи пакеті після :keyword:"
"`from`, ви можете вказати, наскільки високо потрібно перейти вгору по "
"поточній ієрархії пакету, не вказуючи точні назви. Одна крапка на початку "
"означає поточний пакет, у якому існує модуль, що виконує імпорт. Дві крапки "
"означають підвищення на один рівень пакета. Три крапки — це два рівні вище "
"тощо. Отже, якщо ви виконаєте ``з . імпортуйте mod`` з модуля в пакеті "
"``pkg``, тоді ви імпортуєте ``pkg.mod``. Якщо ви виконаєте ``from ..subpkg2 "
"import mod`` з ``pkg.subpkg1``, ви імпортуєте ``pkg.subpkg2.mod``. "
"Специфікація відносного імпорту міститься в розділі :ref:`relativeimports`."

msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` надається для підтримки програм, які "
"динамічно визначають модулі для завантаження."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``import`` з аргументами ``module``, "
"``filename``, ``sys.path``, ``sys.meta_path``, ``sys.path_hooks``."

msgid "Future statements"
msgstr "Майбутні заяви"

msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
":dfn:`future statement` — це вказівка компілятору про те, що певний модуль "
"має бути скомпільовано з використанням синтаксису чи семантики, які будуть "
"доступні у визначеному майбутньому випуску Python, де ця функція стане "
"стандартною."

msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"Заява майбутнього призначена для полегшення переходу на майбутні версії "
"Python, які вносять несумісні зміни в мову. Це дозволяє використовувати нові "
"функції окремо для кожного модуля до випуску, у якому ця функція стане "
"стандартною."

msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"У верхній частині модуля має бути майбутня заява. Єдині рядки, які можуть "
"відображатися перед майбутнім оператором:"

msgid "the module docstring (if any),"
msgstr "рядок документації модуля (якщо є),"

msgid "comments,"
msgstr "коментарі,"

msgid "blank lines, and"
msgstr "порожні рядки та"

msgid "other future statements."
msgstr "інші майбутні заяви."

msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""
"Єдина функція, яка вимагає використання оператора future, це ``анотації`` "
"(див. :pep:`563`)."

msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Python 3 усе ще розпізнає всі історичні функції, увімкнені оператором "
"future. Список включає ``absolute_import``, ``division``, ``generators``, "
"``generator_stop``, ``unicode_literals``, ``print_function``, "
"``nested_scopes`` і ``with_statement``. Усі вони зайві, оскільки завжди "
"ввімкнені та зберігаються лише для зворотної сумісності."

msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Майбутній оператор розпізнається та обробляється спеціально під час "
"компіляції: зміни в семантиці основних конструкцій часто впроваджуються "
"шляхом генерації іншого коду. Може навіть статися так, що нова функція "
"вводить новий несумісний синтаксис (наприклад, нове зарезервоване слово), і "
"в цьому випадку компілятору може знадобитися розібрати модуль по-іншому. "
"Такі рішення не можуть бути відкладені до часу виконання."

msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"Для будь-якого конкретного випуску компілятор знає, які назви функцій були "
"визначені, і викликає помилку під час компіляції, якщо майбутній оператор "
"містить функцію, яка йому невідома."

msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"Пряма семантика часу виконання така ж, як і для будь-якого оператора "
"імпорту: є стандартний модуль :mod:`__future__`, описаний пізніше, і його "
"буде імпортовано звичайним способом під час виконання оператора майбутнього."

msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"Цікава семантика часу виконання залежить від конкретної функції, увімкненої "
"майбутнім оператором."

msgid "Note that there is nothing special about the statement::"
msgstr "Зауважте, що в заяві немає нічого особливого::"

msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Це не заява про майбутнє; це звичайний оператор імпорту без спеціальних "
"семантичних або синтаксичних обмежень."

msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"Код, скомпільований за допомогою викликів вбудованих функцій :func:`exec` і :"
"func:`compile`, які виникають у модулі :mod:`M`, що містить майбутній "
"оператор, за замовчуванням використовуватиме новий пов’язаний синтаксис або "
"семантику з майбутньою заявою. Цим можна керувати необов’язковими "
"аргументами :func:`compile` --- подробиці дивіться в документації цієї "
"функції."

msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"Майбутній оператор, набраний у підказці інтерактивного перекладача, матиме "
"чинність до кінця сеансу перекладача. Якщо інтерпретатор запускається з "
"параметром :option:`-i`, йому передається ім’я сценарію для виконання, і "
"сценарій містить майбутній оператор, він діятиме в інтерактивному сеансі, "
"розпочатому після виконання сценарію."

msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Назад у __future__"

msgid "The original proposal for the __future__ mechanism."
msgstr "Оригінальна пропозиція щодо механізму __future__."

msgid "The :keyword:`!global` statement"
msgstr "Оператор :keyword:`!global`"

msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
"Оператор :keyword:`global` — це оголошення, яке зберігається для всього "
"поточного блоку коду. Це означає, що перелічені ідентифікатори слід "
"інтерпретувати як глобальні. Було б неможливо призначити глобальну змінну "
"без :keyword:`!global`, хоча вільні змінні можуть посилатися на глобальні, "
"не будучи оголошеними глобальними."

msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`!global` statement."
msgstr ""
"Імена, перелічені в операторі :keyword:`global`, не можна використовувати в "
"тому самому блоці коду, що текстово передує оператору :keyword:`!global`."

msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters, or as targets in :keyword:`with` statements or :keyword:`except` "
"clauses, or in a :keyword:`for` target list, :keyword:`class` definition, "
"function definition, :keyword:`import` statement, or variable annotation."
msgstr ""
"Імена, перелічені в операторі :keyword:`global`, не можна визначати як "
"формальні параметри або як цілі в операторах :keyword:`with` або в пунктах :"
"keyword:`except` або в списку цілей :keyword:`for` , визначення :keyword:"
"`class`, визначення функції, оператор :keyword:`import` або анотація змінної."

msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""
"Поточна реалізація не передбачає дотримання деяких із цих обмежень, але "
"програми не повинні зловживати цією свободою, оскільки майбутні реалізації "
"можуть посилити їх дотримання або мовчки змінити значення програми."

msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**Примітка програміста:** :keyword:`global` — це директива для аналізатора. "
"Це стосується лише коду, аналізованого одночасно з оператором :keyword:`!"
"global`. Зокрема, оператор :keyword:`!global`, що міститься в рядку або "
"об’єкті коду, що надається вбудованій функції :func:`exec`, не впливає на "
"блок коду, *що містить* виклик функції, і код, що міститься в таких на рядок "
"не впливають оператори :keyword:`!global` у коді, що містить виклик функції. "
"Те саме стосується функцій :func:`eval` і :func:`compile`."

msgid "The :keyword:`!nonlocal` statement"
msgstr "Оператор :keyword:`!nonlocal`"

msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals. "
"This is important because the default behavior for binding is to search the "
"local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""
"Оператор :keyword:`nonlocal` змушує перелічені ідентифікатори посилатися на "
"раніше зв’язані змінні в найближчій охоплюючій області, за винятком "
"глобальних. Це важливо, тому що поведінка за замовчуванням для зв’язування "
"полягає в тому, щоб спочатку шукати локальний простір імен. Цей оператор "
"дозволяє інкапсульованому коду перезв’язувати змінні за межами локальної "
"області окрім глобальної (модульної) області."

msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a :"
"keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""
"Імена, перелічені в операторі :keyword:`nonlocal`, на відміну від тих, що "
"перераховані в операторі :keyword:`global`, мають посилатися на вже існуючі "
"прив’язки в охоплюючій області (область, у якій має бути створено нову "
"прив’язку, не може бути визначена однозначно)."

msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""
"Імена, перелічені в операторі :keyword:`nonlocal`, не повинні конфліктувати "
"з уже існуючими зв’язками в локальній області."

msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Доступ до імен у зовнішніх областях"

msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "Специфікація оператора :keyword:`nonlocal`."
