# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Data model"
msgstr "Модель даних"

msgid "Objects, values and types"
msgstr "Об'єкти, значення та типи"

msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`Об’єкти` — це абстракція Python для даних. Усі дані в програмі Python "
"представлені об’єктами або зв’язками між об’єктами. (У певному сенсі та "
"відповідно до моделі фон Неймана \"комп’ютера зі збереженою програмою\" код "
"також представлений об’єктами.)"

msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"Кожен об’єкт має ідентифікатор, тип і значення. *Ідентичність* об'єкта "
"ніколи не змінюється після його створення; ви можете думати про це як про "
"адресу об'єкта в пам'яті. Оператор ':keyword:`is`' порівнює ідентичність "
"двох об'єктів; функція :func:`id` повертає ціле число, що представляє його "
"ідентифікатор."

msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "Для CPython ``id(x)`` — це адреса пам’яті, де зберігається ``x``."

msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"Тип об’єкта визначає операції, які об’єкт підтримує (наприклад, \"чи має він "
"довжину?\"), а також визначає можливі значення для об’єктів цього типу. "
"Функція :func:`type` повертає тип об’єкта (який сам є об’єктом). Як і його "
"ідентифікатор, :dfn:`type` об’єкта також не змінюється. [#]_"

msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"*Значення* деяких об'єктів може змінюватися. Об'єкти, чиє значення може "
"змінюватися, називаються *змінними*; об'єкти, значення яких не змінюються "
"після їх створення, називаються *незмінними*. (Значення незмінного об’єкта-"
"контейнера, що містить посилання на змінний об’єкт, може змінюватися, коли "
"змінюється значення останнього; однак контейнер усе ще вважається незмінним, "
"оскільки набір об’єктів, який він містить, не можна змінити. Таким чином, "
"незмінність не є строго те саме, що має незмінне значення, воно більш "
"тонке.) Змінність об'єкта визначається його типом; наприклад, числа, рядки "
"та кортежі незмінні, тоді як словники та списки змінні."

msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Об'єкти ніколи не знищуються явно; однак, коли вони стають недоступними, "
"вони можуть бути зібрані сміттям. Реалізації дозволено відкладати збирання "
"сміття або взагалі опускати його --- це питання якості реалізації, як "
"реалізовано збирання сміття, доки не збираються об’єкти, які все ще доступні."

msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"Наразі CPython використовує схему підрахунку посилань із (необов’язковим) "
"відкладеним виявленням циклічно пов’язаного сміття, яка збирає більшість "
"об’єктів, щойно вони стають недоступними, але не гарантовано збирає сміття, "
"що містить циклічні посилання. Перегляньте документацію модуля :mod:`gc` для "
"отримання інформації про керування збиранням циклічного сміття. Інші "
"реалізації діють інакше, і CPython може змінитися. Не покладайтеся на "
"негайну фіналізацію об’єктів, коли вони стають недоступними (тому ви завжди "
"повинні явно закривати файли)."

msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"Зауважте, що використання засобів трасування або налагодження реалізації "
"може зберегти живими об’єкти, які зазвичай можна зібрати. Також зауважте, що "
"перехоплення винятку за допомогою оператора ':keyword:`try`...\\ :keyword:"
"`except`' може зберегти об'єкти живими."

msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement and the ':keyword:`with`' statement provide convenient "
"ways to do this."
msgstr ""
"Деякі об’єкти містять посилання на \"зовнішні\" ресурси, такі як відкриті "
"файли або вікна. Зрозуміло, що ці ресурси звільняються, коли об’єкт збирає "
"сміття, але оскільки збір сміття не гарантовано відбудеться, такі об’єкти "
"також надають явний спосіб звільнити зовнішній ресурс, як правило, метод :"
"meth:`close`. Програмам настійно рекомендується явно закривати такі об’єкти. "
"Оператор ':keyword:`try`...\\ :keyword:`finally`' і оператор ':keyword:"
"`with`' пропонують зручні способи зробити це."

msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Деякі об'єкти містять посилання на інші об'єкти; вони називаються "
"*контейнерами*. Прикладами контейнерів є кортежі, списки та словники. "
"Посилання є частиною значення контейнера. У більшості випадків, коли ми "
"говоримо про значення контейнера, ми маємо на увазі значення, а не "
"ідентифікацію об’єктів, що містяться; однак, коли ми говоримо про мінливість "
"контейнера, мається на увазі лише ідентичність об’єктів, які безпосередньо "
"містяться. Отже, якщо незмінний контейнер (наприклад, кортеж) містить "
"посилання на змінний об’єкт, його значення змінюється, якщо змінюється цей "
"змінний об’єкт."

msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"Типи впливають майже на всі аспекти поведінки об'єктів. Навіть важливість "
"ідентичності об’єкта в певному сенсі вплинула: для незмінних типів операції, "
"які обчислюють нові значення, можуть фактично повернути посилання на будь-"
"який існуючий об’єкт з тим самим типом і значенням, тоді як для змінних "
"об’єктів це неприпустимо. Наприклад, після ``a = 1; b = 1``, ``a`` і ``b`` "
"можуть або не можуть посилатися на той самий об’єкт зі значенням один, "
"залежно від реалізації, але після ``c = []; d = []``, ``c`` і ``d`` "
"гарантовано посилаються на два різні, унікальні, щойно створені порожні "
"списки. (Зверніть увагу, що ``c = d = []`` призначає той самий об’єкт як "
"``c``, так і ``d``.)"

msgid "The standard type hierarchy"
msgstr "Стандартна ієрархія типів"

msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Нижче наведено список типів, вбудованих у Python. Модулі розширення "
"(написані мовами C, Java або іншими мовами, залежно від реалізації) можуть "
"визначати додаткові типи. Майбутні версії Python можуть додавати типи до "
"ієрархії типів (наприклад, раціональні числа, ефективно збережені масиви "
"цілих чисел тощо), хоча такі доповнення часто надаватимуться через "
"стандартну бібліотеку."

msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Деякі з наведених нижче описів типів містять абзац із переліком "
"\"спеціальних атрибутів\". Це атрибути, які надають доступ до реалізації і "
"не призначені для загального використання. У майбутньому їх визначення може "
"змінитися."

msgid "None"
msgstr "Жодного"

msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Цей тип має єдине значення. Існує єдиний об’єкт із таким значенням. Доступ "
"до цього об’єкта здійснюється через вбудоване ім’я ``None``. Він "
"використовується для позначення відсутності значення в багатьох ситуаціях, "
"наприклад, його повертають функції, які явно нічого не повертають. Його "
"значення істинності є хибним."

msgid "NotImplemented"
msgstr "Не впроваджений"

msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"Цей тип має єдине значення. Існує єдиний об’єкт із таким значенням. Доступ "
"до цього об’єкта здійснюється через вбудовану назву ``NotImplemented``. "
"Числові методи та методи насиченого порівняння повинні повертати це "
"значення, якщо вони не реалізують операцію для наданих операндів. (Тоді "
"інтерпретатор спробує відображену операцію або інший резервний варіант, "
"залежно від оператора.) Його не слід оцінювати в логічному контексті."

msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""
"Перегляньте :ref:`implementing-the-arithmetic-operations` для отримання "
"додаткової інформації."

msgid ""
"Evaluating ``NotImplemented`` in a boolean context is deprecated. While it "
"currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It "
"will raise a :exc:`TypeError` in a future version of Python."
msgstr ""
"Оцінка ``NotImplemented`` у логічному контексті застаріла. Хоча наразі він "
"оцінюється як істинний, він видасть :exc:`DeprecationWarning`. Це викличе :"
"exc:`TypeError` у наступній версії Python."

msgid "Ellipsis"
msgstr "Еліпсис"

msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Цей тип має єдине значення. Існує єдиний об’єкт із таким значенням. Доступ "
"до цього об’єкта здійснюється за допомогою літералу ``...`` або вбудованої "
"назви ``Ellipsis``. Його істинна цінність є істинною."

msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Вони створюються за допомогою числових літералів і повертаються як "
"результати арифметичними операторами та арифметичними вбудованими функціями. "
"Числові об'єкти незмінні; після створення їхня цінність ніколи не "
"змінюється. Числа Python, звичайно, тісно пов’язані з математичними числами, "
"але підлягають обмеженням числового представлення в комп’ютерах."

msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
"Рядкові представлення числових класів, обчислені за допомогою :meth:`~object."
"__repr__` і :meth:`~object.__str__`, мають такі властивості:"

msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"Це дійсні числові літерали, які, коли їх передають конструктору класу, "
"створюють об’єкт, що має значення вихідного числа."

msgid "The representation is in base 10, when possible."
msgstr "Представлення в базі 10, коли це можливо."

msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""
"Початкові нулі, можливо, за винятком одного нуля перед десятковою комою, не "
"показані."

msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""
"Кінцеві нулі, можливо, за винятком одного нуля після коми, не відображаються."

msgid "A sign is shown only when the number is negative."
msgstr "Знак відображається лише тоді, коли число від’ємне."

msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr ""
"Python розрізняє цілі числа, числа з плаваючою комою та комплексні числа:"

msgid ":class:`numbers.Integral`"
msgstr ":class:`числа.Інтеграл`"

msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Вони представляють елементи з математичного набору цілих чисел (додатних і "
"від’ємних)."

msgid "There are two types of integers:"
msgstr "Є два типи цілих чисел:"

msgid "Integers (:class:`int`)"
msgstr "Цілі числа (:class:`int`)"

msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Вони представляють числа в необмеженому діапазоні, що залежить лише від "
"доступної (віртуальної) пам’яті. Для цілей операцій зсуву та маски "
"передбачається двійкове представлення, а від’ємні числа представлені у "
"варіанті доповнення до 2, що створює ілюзію нескінченного рядка знакових "
"бітів, що тягнеться вліво."

msgid "Booleans (:class:`bool`)"
msgstr "Логічні значення (:class:`bool`)"

msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"Вони представляють істинні значення False і True. Два об’єкти, що "
"представляють значення ``False`` і ``True``, є єдиними логічними об’єктами. "
"Логічний тип є підтипом цілочисельного типу, а логічні значення поводяться "
"як значення 0 і 1 відповідно майже в усіх контекстах, за винятком того, що "
"при перетворенні на рядок рядки ``\"False\"`` або ``\"True\"`` повертаються "
"відповідно."

msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"Правила подання цілих чисел мають на меті дати найбільш змістовну "
"інтерпретацію операцій зсуву та маски, що включають від’ємні цілі числа."

msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""
"Вони представляють числа з плаваючою комою подвійної точності на рівні "
"машини. Ви залежите від базової архітектури машини (і реалізації C або Java) "
"щодо прийнятного діапазону та обробки переповнення. Python не підтримує "
"числа з плаваючою комою одинарної точності; економія використання процесора "
"та пам’яті, яка зазвичай є причиною їх використання, є меншою за накладні "
"витрати на використання об’єктів у Python, тому немає причин ускладнювати "
"мову двома видами чисел з плаваючою комою."

msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Вони представляють комплексні числа як пару чисел з плаваючою комою "
"подвійної точності на рівні машини. Застосовуються ті самі застереження, що "
"й для чисел з плаваючою комою. Дійсні та уявні частини комплексного числа "
"``z`` можна отримати за допомогою атрибутів ``z.real`` і ``z.imag``, "
"доступних лише для читання."

msgid "Sequences"
msgstr "Послідовності"

msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"Вони представляють скінченні впорядковані набори, проіндексовані "
"невід’ємними числами. Вбудована функція :func:`len` повертає кількість "
"елементів послідовності. Якщо довжина послідовності дорівнює *n*, набір "
"індексів містить числа 0, 1, ..., *n*-1. Елемент *i* послідовності *a* "
"вибрано за допомогою ``a[i]``."

msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"Послідовності також підтримують нарізку: ``a[i:j]`` вибирає всі елементи з "
"індексом *k* так, що *i* ``<=`` *k* ``<`` *j*. Коли використовується як "
"вираз, фрагмент є послідовністю одного типу. Це означає, що набір індексів "
"перенумеровано так, що він починається з 0."

msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Деякі послідовності також підтримують \"розширене нарізання\" з третім "
"параметром \"кроку\": ``a[i:j:k]`` вибирає всі елементи *a* з індексом *x*, "
"де ``x = i + n*k ``, *n* ``>=`` ``0`` і *i* ``<=`` *x* ``<`` *j*."

msgid "Sequences are distinguished according to their mutability:"
msgstr "Послідовності розрізняють відповідно до їх мінливості:"

msgid "Immutable sequences"
msgstr "Незмінні послідовності"

msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Об’єкт типу незмінної послідовності не може змінюватися після створення. "
"(Якщо об’єкт містить посилання на інші об’єкти, ці інші об’єкти можуть бути "
"змінними та змінюватися; однак набір об’єктів, на який безпосередньо "
"посилається незмінний об’єкт, не може змінитися.)"

msgid "The following types are immutable sequences:"
msgstr "Наступні типи є незмінними послідовностями:"

msgid "Strings"
msgstr "рядки"

msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:type:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"Рядок — це послідовність значень, які представляють кодові точки Unicode. "
"Усі кодові точки в діапазоні ``U+0000 - U+10FFFF`` можуть бути представлені "
"в рядку. Python не має типу :c:type:`char`; натомість кожна точка коду в "
"рядку представлена як об’єкт рядка довжиною ``1``. Вбудована функція :func:"
"`ord` перетворює кодову точку з її рядкової форми на ціле число в діапазоні "
"``0 - 10FFFF``; :func:`chr` перетворює ціле число в діапазоні ``0 - 10FFFF`` "
"на об’єкт рядка відповідної довжини ``1``. :meth:`str.encode` можна "
"використовувати для перетворення :class:`str` на :class:`bytes` за допомогою "
"заданого текстового кодування, а :meth:`bytes.decode` можна використовувати "
"для досягнення протилежного."

msgid "Tuples"
msgstr "Кортежі"

msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Елементи кортежу є довільними об’єктами Python. Кортежі з двох або більше "
"елементів утворюються списками виразів, розділених комами. Кортеж з одного "
"елемента (\"синглтон\") може бути сформований шляхом додавання коми до "
"виразу (вираз сам по собі не створює кортеж, оскільки дужки повинні "
"використовуватися для групування виразів). Порожній кортеж може бути "
"утворений пустою парою круглих дужок."

msgid "Bytes"
msgstr "Байти"

msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"Об’єкт bytes є незмінним масивом. Елементи є 8-бітовими байтами, "
"представленими цілими числами в діапазоні 0 <= x < 256. Байтові літерали "
"(наприклад, ``b'abc``) і вбудований конструктор :func:`bytes()` можуть бути "
"використовується для створення об'єктів bytes. Крім того, об’єкти bytes "
"можна декодувати в рядки за допомогою методу :meth:`~bytes.decode`."

msgid "Mutable sequences"
msgstr "Змінні послідовності"

msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"Змінні послідовності можна змінювати після їх створення. Нотації підписки та "
"зрізу можна використовувати як ціль операторів призначення та :keyword:`del` "
"(видалити)."

msgid "There are currently two intrinsic mutable sequence types:"
msgstr "На даний момент існує два типи внутрішніх змінних послідовностей:"

msgid "Lists"
msgstr "списки"

msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Елементи списку є довільними об’єктами Python. Списки формуються шляхом "
"розміщення списку виразів, розділених комами, у квадратних дужках. "
"(Зауважте, що для формування списків довжиною 0 або 1 не потрібні особливі "
"випадки.)"

msgid "Byte Arrays"
msgstr "Байтові масиви"

msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Об’єкт bytearray є змінним масивом. Вони створюються за допомогою "
"вбудованого конструктора :func:`bytearray`. Крім того, що байтові масиви є "
"змінними (і, отже, нехешованими), байтові масиви забезпечують той самий "
"інтерфейс і функціональність, що й незмінні об’єкти :class:`bytes`."

msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"Модуль розширення :mod:`array` надає додатковий приклад змінного типу "
"послідовності, як і модуль :mod:`collections`."

msgid "Set types"
msgstr "Встановити типи"

msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Вони представляють невпорядковані, кінцеві набори унікальних, незмінних "
"об’єктів. Таким чином, вони не можуть бути індексовані жодним індексом. "
"Однак їх можна повторювати, а вбудована функція :func:`len` повертає "
"кількість елементів у наборі. Набори зазвичай використовують для швидкого "
"тестування членства, видалення дублікатів із послідовності та обчислення "
"математичних операцій, таких як перетин, об’єднання, різниця та симетрична "
"різниця."

msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"Для елементів набору застосовуються ті ж правила незмінності, що й для "
"ключів словника. Зауважте, що числові типи підкоряються звичайним правилам "
"числового порівняння: якщо два числа порівнюються (наприклад, ``1`` і "
"``1.0``), лише одне з них може міститися в наборі."

msgid "There are currently two intrinsic set types:"
msgstr "Наразі існує два типи внутрішніх наборів:"

msgid "Sets"
msgstr "Набори"

msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"Вони представляють змінний набір. Вони створюються за допомогою вбудованого "
"конструктора :func:`set` і можуть бути змінені згодом кількома методами, "
"наприклад :meth:`~set.add`."

msgid "Frozen sets"
msgstr "Заморожені набори"

msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Вони являють собою незмінний набір. Вони створюються за допомогою "
"вбудованого конструктора :func:`frozenset`. Оскільки заморожений набір є "
"незмінним і :term:`hashable`, його можна знову використовувати як елемент "
"іншого набору або як ключ словника."

msgid "Mappings"
msgstr "Відображення"

msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Вони представляють кінцеві набори об'єктів, індексованих довільними наборами "
"індексів. Підрядкова нотація ``a[k]`` вибирає елемент з індексом ``k`` із "
"відображення ``a``; це можна використовувати у виразах і як ціль присвоєння "
"або операторів :keyword:`del`. Вбудована функція :func:`len` повертає "
"кількість елементів у відображенні."

msgid "There is currently a single intrinsic mapping type:"
msgstr "Наразі існує єдиний внутрішній тип відображення:"

msgid "Dictionaries"
msgstr "словники"

msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Вони представляють кінцеві набори об'єктів, індексованих майже довільними "
"значеннями. Єдиними типами значень, неприйнятними як ключі, є значення, що "
"містять списки, словники чи інші змінні типи, які порівнюються за значенням, "
"а не за ідентичністю об’єкта, тому що для ефективної реалізації словників "
"необхідно, щоб хеш-значення ключа залишалося постійним. Числові типи, що "
"використовуються для ключів, підкоряються звичайним правилам для числового "
"порівняння: якщо два числа порівнюються (наприклад, ``1`` і ``1.0``), тоді "
"їх можна використовувати як взаємозамінні для індексування тієї самої статті "
"словника."

msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Словники зберігають порядок вставки, тобто ключі створюватимуться в тому "
"самому порядку, у якому вони були послідовно додані до словника. Заміна "
"існуючого ключа не змінює порядок, однак видалення ключа та його повторне "
"вставлення додасть його в кінець замість збереження старого місця."

msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Словники змінні; їх можна створити за допомогою нотації ``{...}`` (див. "
"розділ :ref:`dict`)."

msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Модулі розширення :mod:`dbm.ndbm` і :mod:`dbm.gnu` надають додаткові "
"приклади типів зіставлення, як і модуль :mod:`collections`."

msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Словники не зберігали порядок вставки у версіях Python до 3.6. У CPython 3.6 "
"порядок вставки було збережено, але в той час це вважалося деталлю "
"реалізації, а не гарантією мови."

msgid "Callable types"
msgstr "Викличні типи"

msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""
"Це типи, до яких можна застосувати операцію виклику функції (див. розділ :"
"ref:`calls`):"

msgid "User-defined functions"
msgstr "Визначені користувачем функції"

msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Визначений користувачем об’єкт функції створюється визначенням функції (див. "
"розділ :ref:`function`). Її слід викликати зі списком аргументів, що містить "
"таку саму кількість елементів, як і формальний список параметрів функції."

msgid "Special attributes:"
msgstr "Особливі атрибути:"

msgid "Attribute"
msgstr "Атрибут"

msgid "Meaning"
msgstr "Значення"

msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses."
msgstr ""
"Рядок документації функції або ``None``, якщо недоступний; не успадковується "
"підкласами."

msgid "Writable"
msgstr "Можливість запису"

msgid ":attr:`~definition.\\ __name__`"
msgstr ":attr:`~визначення.\\ __ім'я__`"

msgid "The function's name."
msgstr "Ім'я функції."

msgid ":attr:`~definition.\\ __qualname__`"
msgstr ":attr:`~визначення.\\ __qualname__`"

msgid "The function's :term:`qualified name`."
msgstr ":term:`qualified name` функції."

msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"Назва модуля, у якому була визначена функція, або \"Немає\", якщо вона "
"недоступна."

msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr ""
"Кортеж, що містить значення аргументів за замовчуванням для тих аргументів, "
"які мають значення за замовчуванням, або ``None``, якщо жоден аргумент не "
"має значення за замовчуванням."

msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

msgid "The code object representing the compiled function body."
msgstr "Об’єкт коду, що представляє скомпільоване тіло функції."

msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""
"Посилання на словник, який містить глобальні змінні функції --- глобальний "
"простір імен модуля, у якому було визначено функцію."

msgid "Read-only"
msgstr "Лише для читання"

msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~об’єкт.__dict__`"

msgid "The namespace supporting arbitrary function attributes."
msgstr "Простір імен, що підтримує довільні атрибути функції."

msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables. See below for information on the ``cell_contents`` attribute."
msgstr ""
"``None`` або кортеж клітинок, які містять зв’язки для вільних змінних "
"функції. Дивіться нижче інформацію про атрибут ``cell_contents``."

msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, and ``'return'`` for the return annotation, if provided.  "
"For more information on working with this attribute, see :ref:`annotations-"
"howto`."
msgstr ""
"Dict, що містить анотації параметрів. Ключі dict — це назви параметрів і "
"``'return'`` для анотації повернення, якщо є. Для отримання додаткової "
"інформації про роботу з цим атрибутом перегляньте :ref:`annotations-howto`."

msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

msgid "A dict containing defaults for keyword-only parameters."
msgstr "Dict, що містить параметри за замовчуванням лише для ключових слів."

msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""
"Більшість атрибутів із позначкою \"Writable\" перевіряють тип присвоєного "
"значення."

msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""
"Функціональні об’єкти також підтримують отримання та встановлення довільних "
"атрибутів, які можна використовувати, наприклад, для додавання метаданих до "
"функцій. Для отримання та встановлення таких атрибутів використовується "
"звичайна крапкова нотація. *Зауважте, що поточна реалізація підтримує лише "
"атрибути функцій для визначених користувачем функцій. Атрибути вбудованих "
"функцій можуть підтримуватися в майбутньому.*"

msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Об’єкт клітинки має атрибут ``cell_contents``. Це можна використовувати для "
"отримання значення комірки, а також для встановлення значення."

msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below. The :data:"
"`cell <types.CellType>` type can be accessed in the :mod:`types` module."
msgstr ""
"Додаткову інформацію про визначення функції можна отримати з її об’єкта "
"коду; дивіться опис внутрішніх типів нижче. Доступ до типу :data:`cell "
"<types.CellType>` можна отримати в модулі :mod:`types`."

msgid "Instance methods"
msgstr "Методи екземплярів"

msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Об’єкт методу екземпляра поєднує в собі клас, екземпляр класу та будь-який "
"об’єкт, що викликається (зазвичай це функція, визначена користувачем)."

msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); :attr:`~definition."
"__name__` is the method name (same as ``__func__.__name__``); :attr:"
"`__module__` is the name of the module the method was defined in, or "
"``None`` if unavailable."
msgstr ""
"Спеціальні атрибути лише для читання: :attr:`__self__` — об’єкт екземпляра "
"класу, :attr:`__func__` — об’єкт функції; :attr:`__doc__` — це документація "
"методу (те саме, що ``__func__.__doc__``); :attr:`~definition.__name__` — "
"назва методу (те саме, що ``__func__.__name__``); :attr:`__module__` — це "
"назва модуля, у якому було визначено метод, або ``None``, якщо воно "
"недоступне."

msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""
"Методи також підтримують доступ (але не встановлення) довільних атрибутів "
"функції на базовому об’єкті функції."

msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr ""
"Визначені користувачем об’єкти методу можуть бути створені під час отримання "
"атрибута класу (можливо, через екземпляр цього класу), якщо цей атрибут є "
"визначеним користувачем об’єктом функції або об’єктом методу класу."

msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""
"Коли об’єкт методу екземпляра створюється шляхом отримання визначеного "
"користувачем об’єкта функції з класу через один із його екземплярів, його "
"атрибут :attr:`__self__` є екземпляром, а об’єкт методу вважається "
"зв’язаним. Атрибут :attr:`__func__` нового методу є оригінальним об’єктом "
"функції."

msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class "
"itself, and its :attr:`__func__` attribute is the function object underlying "
"the class method."
msgstr ""
"Коли об’єкт методу екземпляра створюється шляхом отримання об’єкта методу "
"класу з класу або екземпляра, його атрибут :attr:`__self__` є самим класом, "
"а його атрибут :attr:`__func__` є об’єктом функції, що лежить в основі "
"методу класу."

msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`__func__`) is called, inserting the class instance (:attr:`__self__`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"Коли викликається об’єкт методу екземпляра, викликається базова функція (:"
"attr:`__func__`), вставляючи екземпляр класу (:attr:`__self__`) перед "
"списком аргументів. Наприклад, коли :class:`C` є класом, який містить "
"визначення для функції :meth:`f`, а ``x`` є екземпляром :class:`C`, виклик "
"``x.f(1 )`` еквівалентно виклику ``C.f(x, 1)``."

msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"Коли об’єкт методу екземпляра походить від об’єкта методу класу, \"примірник "
"класу\", який зберігається в :attr:`__self__`, фактично буде самим класом, "
"тому виклик x.f(1) або C.f( 1)`` еквівалентно виклику ``f(C,1)``, де ``f`` є "
"основною функцією."

msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all non-"
"callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""
"Зауважте, що перетворення з об’єкта функції в об’єкт методу екземпляра "
"відбувається щоразу, коли атрибут отримується з екземпляра. У деяких "
"випадках плідною оптимізацією є призначення атрибута локальній змінній і "
"виклик цієї локальної змінної. Також зауважте, що це перетворення "
"відбувається лише для визначених користувачем функцій; інші викликані "
"об'єкти (і всі невикликові об'єкти) витягуються без перетворення. Також "
"важливо відзначити, що визначені користувачем функції, які є атрибутами "
"примірника класу, не перетворюються на зв’язані методи; це *тільки* "
"трапляється, коли функція є атрибутом класу."

msgid "Generator functions"
msgstr "Функції генератора"

msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's :meth:`iterator."
"__next__` method will cause the function to execute until it provides a "
"value using the :keyword:`!yield` statement.  When the function executes a :"
"keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of "
"values to be returned."
msgstr ""
"Функція або метод, який використовує оператор :keyword:`yield` (див. розділ :"
"ref:`yield`), називається :dfn:`функцією-генератором`. Під час виклику така "
"функція завжди повертає об’єкт :term:`iterator`, який можна використовувати "
"для виконання тіла функції: виклик методу :meth:`iterator.__next__` "
"ітератора призведе до виконання функції, доки вона не надасть значення за "
"допомогою оператора :keyword:`!yield`. Коли функція виконує оператор :"
"keyword:`return` або виходить з кінця, виникає виняток :exc:`StopIteration`, "
"і ітератор досягне кінця набору значень, які потрібно повернути."

msgid "Coroutine functions"
msgstr "Функції співпрограми"

msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
"Функція або метод, визначений за допомогою :keyword:`async def`, "
"називається :dfn:`coroutine function`. Така функція під час виклику повертає "
"об’єкт :term:`coroutine`. Він може містити вирази :keyword:`await`, а також "
"оператори :keyword:`async with` і :keyword:`async for`. Дивіться також "
"розділ :ref:`coroutine-objects`."

msgid "Asynchronous generator functions"
msgstr "Функції асинхронного генератора"

msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"Функція або метод, визначений за допомогою :keyword:`async def` і який "
"використовує оператор :keyword:`yield`, називається :dfn:`функцією "
"асинхронного генератора`. Під час виклику така функція повертає об’єкт :term:"
"`asynchronous iterator`, який можна використовувати в операторі :keyword:"
"`async for` для виконання тіла функції."

msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ <object."
"__anext__>` method will return an :term:`awaitable` which when awaited will "
"execute until it provides a value using the :keyword:`yield` expression.  "
"When the function executes an empty :keyword:`return` statement or falls off "
"the end, a :exc:`StopAsyncIteration` exception is raised and the "
"asynchronous iterator will have reached the end of the set of values to be "
"yielded."
msgstr ""
"Виклик методу :meth:`aiterator.__anext__ <object.__anext__>` асинхронного "
"ітератора поверне :term:`awaitable`, який у разі очікування "
"виконуватиметься, доки не надасть значення за допомогою виразу :keyword:"
"`yield`. Коли функція виконує порожній оператор :keyword:`return` або "
"виходить за межі кінця, виникає виняткова ситуація :exc:"
"`StopAsyncIteration`, і асинхронний ітератор досягне кінця набору значень, "
"які потрібно отримати."

msgid "Built-in functions"
msgstr "Вбудовані функції"

msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`~definition.__name__` is the function's name; :attr:`__self__` is set to "
"``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"Вбудований об’єкт функції є оболонкою навколо функції C. Прикладами "
"вбудованих функцій є :func:`len` і :func:`math.sin` (:mod:`math` є "
"стандартним вбудованим модулем). Кількість і тип аргументів визначається "
"функцією C. Спеціальні атрибути лише для читання: :attr:`__doc__` — рядок "
"документації функції або ``None``, якщо він недоступний; :attr:`~definition."
"__name__` це ім'я функції; :attr:`__self__` має значення ``None`` (але "
"дивіться наступний пункт); :attr:`__module__` — це ім’я модуля, у якому була "
"визначена функція, або ``None``, якщо воно недоступне."

msgid "Built-in methods"
msgstr "Вбудовані методи"

msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"Це дійсно інше маскування вбудованої функції, цього разу містить об’єкт, "
"переданий у функцію C як неявний додатковий аргумент. Прикладом вбудованого "
"методу є ``alist.append()``, припускаючи, що *alist* є об’єктом списку. У "
"цьому випадку спеціальний атрибут лише для читання :attr:`__self__` "
"встановлюється для об’єкта, позначеного *alist*."

msgid "Classes"
msgstr "Заняття"

msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to :"
"meth:`__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""
"Заняття викликні. Ці об’єкти зазвичай діють як фабрики для нових екземплярів "
"самих себе, але можливі варіанти для типів класів, які перевизначають :meth:"
"`~object.__new__`. Аргументи виклику передаються до :meth:`__new__` і, у "
"типовому випадку, до :meth:`~object.__init__` для ініціалізації нового "
"екземпляра."

msgid "Class Instances"
msgstr "Екземпляри класу"

msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`~object.__call__` method in their class."
msgstr ""
"Екземпляри довільних класів можна зробити викликаними, визначивши метод :"
"meth:`~object.__call__` у їхньому класі."

msgid "Modules"
msgstr "Модулі"

msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a dictionary object (this is the dictionary "
"referenced by the ``__globals__`` attribute of functions defined in the "
"module).  Attribute references are translated to lookups in this dictionary, "
"e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module object does "
"not contain the code object used to initialize the module (since it isn't "
"needed once the initialization is done)."
msgstr ""
"Модулі є основною організаційною одиницею коду Python і створюються :ref:"
"`системою імпорту <importsystem>`, яка викликається оператором :keyword:"
"`import` або викликом функцій, таких як :func:`importlib.import_module` і "
"вбудований :func:`__import__`. Об’єкт модуля має простір імен, реалізований "
"об’єктом словника (це словник, на який посилається атрибут ``__globals__`` "
"функцій, визначених у модулі). Посилання на атрибути перекладено на пошуки в "
"цьому словнику, наприклад, ``m.x`` еквівалентно ``m.__dict__[\"x\"]``. "
"Об’єкт модуля не містить об’єкт коду, який використовується для "
"ініціалізації модуля (оскільки він не потрібен після завершення "
"ініціалізації)."

msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"Призначення атрибутів оновлює словник простору імен модуля, наприклад, ``m.x "
"= 1`` еквівалентно ``m.__dict__[\"x\"] = 1``."

msgid "Predefined (writable) attributes:"
msgstr "Попередньо визначені (записувані) атрибути:"

msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

msgid "The module's name."
msgstr "Назва модуля."

msgid "The module's documentation string, or ``None`` if unavailable."
msgstr "Рядок документації модуля або ``None``, якщо він недоступний."

msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

msgid ""
"The pathname of the file from which the module was loaded, if it was loaded "
"from a file. The :attr:`__file__` attribute may be missing for certain types "
"of modules, such as C modules that are statically linked into the "
"interpreter.  For extension modules loaded dynamically from a shared "
"library, it's the pathname of the shared library file."
msgstr ""
"Шлях до файлу, з якого було завантажено модуль, якщо він був завантажений із "
"файлу. Атрибут :attr:`__file__` може бути відсутнім для певних типів "
"модулів, таких як модулі C, які статично пов’язані з інтерпретатором. Для "
"модулів розширення, які динамічно завантажуються зі спільної бібліотеки, це "
"шлях до файлу спільної бібліотеки."

msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"Словник, що містить :term:`анотації змінних <variable annotation>`, зібрані "
"під час виконання тіла модуля. Найкращі методи роботи з :attr:"
"`__annotations__` див. :ref:`annotations-howto`."

msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""
"Спеціальний атрибут лише для читання: :attr:`~object.__dict__` — це простір "
"імен модуля як об’єкт словника."

msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"Через те, як CPython очищає словники модулів, словник модуля буде очищено, "
"коли модуль виходить із області видимості, навіть якщо в словнику все ще є "
"живі посилання. Щоб уникнути цього, скопіюйте словник або збережіть модуль, "
"використовуючи його словник безпосередньо."

msgid "Custom classes"
msgstr "Спеціальні заняття"

msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at https://www."
"python.org/download/releases/2.3/mro/."
msgstr ""
"Спеціальні типи класів зазвичай створюються визначеннями класів (див. "
"розділ :ref:`class`). Клас має простір імен, реалізований об’єктом словника. "
"Посилання на атрибути класу перекладаються на пошуки в цьому словнику, "
"наприклад, ``C.x`` перекладається на ``C.__dict__[\"x\"]`` (хоча є ряд "
"хуків, які дозволяють інші способи пошуку атрибутів) . Якщо ім'я атрибута "
"там не знайдено, пошук атрибута продовжується в базових класах. Цей пошук "
"базових класів використовує порядок розв’язання методів C3, який поводиться "
"правильно навіть за наявності \"діамантових\" структур успадкування, де є "
"кілька шляхів успадкування, що ведуть до спільного предка. Додаткову "
"інформацію про C3 MRO, який використовує Python, можна знайти в "
"документації, що супроводжує випуск 2.3, за адресою https://www.python.org/"
"download/releases/2.3/mro/."

msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`__self__` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__`."
msgstr ""
"Коли посилання на атрибут класу (наприклад, для класу :class:`C`) дає об’єкт "
"методу класу, воно перетворюється на об’єкт методу екземпляра, чий атрибут :"
"attr:`__self__` є :class:`C`. Коли він дає об’єкт статичного методу, він "
"перетворюється на об’єкт, обгорнутий об’єктом статичного методу. Перегляньте "
"розділ :ref:`descriptors` щодо іншого способу, яким атрибути, отримані з "
"класу, можуть відрізнятися від тих, що насправді містяться в його :attr:"
"`~object.__dict__`."

msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"Призначення атрибутів класу оновлює словник класу, а не словник базового "
"класу."

msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Об’єкт класу можна викликати (див. вище), щоб створити екземпляр класу (див. "
"нижче)."

msgid ":attr:`~definition.__name__`"
msgstr ":attr:`~definition.__name__`"

msgid "The class name."
msgstr "Назва класу."

msgid "The name of the module in which the class was defined."
msgstr "Ім'я модуля, в якому було визначено клас."

msgid "The dictionary containing the class's namespace."
msgstr "Словник, що містить простір імен класу."

msgid ":attr:`~class.__bases__`"
msgstr ":attr:`~class.__bases__`"

msgid ""
"A tuple containing the base classes, in the order of their occurrence in the "
"base class list."
msgstr ""
"Кортеж, що містить базові класи в порядку їх появи в списку базових класів."

msgid "The class's documentation string, or ``None`` if undefined."
msgstr "Рядок документації класу або ``None``, якщо не визначено."

msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"Словник, що містить :term:`анотації змінних <variable annotation>`, зібрані "
"під час виконання тіла класу. Найкращі методи роботи з :attr:"
"`__annotations__` див. :ref:`annotations-howto`."

msgid "Class instances"
msgstr "Екземпляри класу"

msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`~object."
"__getattr__` method, that is called to satisfy the lookup."
msgstr ""
"Екземпляр класу створюється шляхом виклику об’єкта класу (див. вище). "
"Екземпляр класу має простір імен, реалізований як словник, який є першим "
"місцем, у якому здійснюється пошук посилань на атрибути. Якщо атрибут там не "
"знайдено, а клас екземпляра має атрибут із таким іменем, пошук продовжується "
"з атрибутами класу. Якщо знайдено атрибут класу, який є визначеним "
"користувачем об’єктом функції, він перетворюється на об’єкт методу "
"екземпляра, атрибут :attr:`__self__` якого є екземпляром. Статичний метод і "
"об’єкти методу класу також трансформуються; див. вище в розділі \"Класи\". "
"Перегляньте розділ :ref:`descriptors` щодо іншого способу, яким атрибути "
"класу, отримані через його екземпляри, можуть відрізнятися від об’єктів, які "
"насправді зберігаються в :attr:`~object.__dict__` класу. Якщо атрибут класу "
"не знайдено, а клас об’єкта має метод :meth:`~object.__getattr__`, який "
"викликається для виконання пошуку."

msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or :"
"meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"Призначення та видалення атрибутів оновлюють словник екземпляра, а не "
"словник класу. Якщо клас має метод :meth:`~object.__setattr__` або :meth:"
"`~object.__delattr__`, він викликається замість безпосереднього оновлення "
"словника примірника."

msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Екземпляри класу можуть видавати себе за числа, послідовності або "
"відображення, якщо вони мають методи з певними спеціальними назвами. "
"Дивіться розділ :ref:`specialnames`."

msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""
"Спеціальні атрибути: :attr:`~object.__dict__` — це словник атрибутів; :attr:"
"`~instance.__class__` є класом екземпляра."

msgid "I/O objects (also known as file objects)"
msgstr "Об’єкти введення-виведення (також відомі як файлові об’єкти)"

msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
":term:`file object` представляє відкритий файл. Для створення файлових "
"об’єктів доступні різні ярлики: вбудована функція :func:`open`, а також :"
"func:`os.popen`, :func:`os.fdopen` і :meth:`~socket. socket.makefile` метод "
"об’єктів сокета (і, можливо, за допомогою інших функцій або методів, наданих "
"модулями розширення)."

msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Об'єкти ``sys.stdin``, ``sys.stdout`` і ``sys.stderr`` ініціалізуються "
"об'єктами файлів, що відповідають стандартним потокам введення, виведення та "
"помилок інтерпретатора; усі вони відкриті в текстовому режимі, тому "
"відповідають інтерфейсу, визначеному :class:`io.TextIOBase` абстрактним "
"класом."

msgid "Internal types"
msgstr "Внутрішні типи"

msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Кілька типів, які використовуються внутрішньо інтерпретатором, доступні "
"користувачеві. Їх визначення можуть змінюватися в майбутніх версіях "
"інтерпретатора, але вони згадуються тут для повноти."

msgid "Code objects"
msgstr "Об'єкти коду"

msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"Об’єкти коду представляють *байт-скомпільований* виконуваний код Python або :"
"term:`bytecode`. Різниця між об’єктом коду та об’єктом функції полягає в "
"тому, що об’єкт функції містить явне посилання на глобальні елементи функції "
"(модуль, у якому вона була визначена), тоді як об’єкт коду не містить "
"контексту; також значення аргументів за замовчуванням зберігаються в об’єкті "
"функції, а не в об’єкті коду (оскільки вони представляють значення, "
"обчислені під час виконання). На відміну від функціональних об’єктів, "
"об’єкти коду є незмінними і не містять посилань (прямих чи опосередкованих) "
"на змінні об’єкти."

msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the total number of positional arguments (including "
"positional-only arguments and arguments with default values); :attr:"
"`co_posonlyargcount` is the number of positional-only arguments (including "
"arguments with default values); :attr:`co_kwonlyargcount` is the number of "
"keyword-only arguments (including arguments with default values); :attr:"
"`co_nlocals` is the number of local variables used by the function "
"(including arguments); :attr:`co_varnames` is a tuple containing the names "
"of the local variables (starting with the argument names); :attr:"
"`co_cellvars` is a tuple containing the names of local variables that are "
"referenced by nested functions; :attr:`co_freevars` is a tuple containing "
"the names of free variables; :attr:`co_code` is a string representing the "
"sequence of bytecode instructions; :attr:`co_consts` is a tuple containing "
"the literals used by the bytecode; :attr:`co_names` is a tuple containing "
"the names used by the bytecode; :attr:`co_filename` is the filename from "
"which the code was compiled; :attr:`co_firstlineno` is the first line number "
"of the function; :attr:`co_lnotab` is a string encoding the mapping from "
"bytecode offsets to line numbers (for details see the source code of the "
"interpreter); :attr:`co_stacksize` is the required stack size; :attr:"
"`co_flags` is an integer encoding a number of flags for the interpreter."
msgstr ""

msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""
"Для :attr:`co_flags` визначено такі біти прапорів: біт ``0x04`` "
"встановлюється, якщо функція використовує синтаксис ``*arguments`` для "
"прийняття довільної кількості позиційних аргументів; біт ``0x08`` "
"встановлено, якщо функція використовує синтаксис ``**keywords`` для "
"прийняття довільних ключових аргументів; біт ``0x20`` встановлено, якщо "
"функція є генератором."

msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"Оголошення майбутніх функцій (``from __future__ import division``) також "
"використовують біти в :attr:`co_flags`, щоб вказати, чи був об’єкт коду "
"скомпільовано з певною функцією: біт ``0x2000`` встановлюється, якщо функція "
"була скомпільована з увімкненим майбутнім поділом; біти ``0x10`` і "
"``0x1000`` використовувалися в попередніх версіях Python."

msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""
"Інші біти в :attr:`co_flags` зарезервовані для внутрішнього використання."

msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"Якщо об’єкт коду представляє функцію, перший елемент у :attr:`co_conts` — це "
"рядок документації функції або ``None``, якщо не визначено."

msgid "Frame objects"
msgstr "Рамкові об'єкти"

msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below), and are also passed to registered trace functions."
msgstr ""
"Об’єкти фрейму представляють кадри виконання. Вони можуть виникнути в "
"об’єктах трасування (див. нижче), а також передаються зареєстрованим "
"функціям трасування."

msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_lasti` gives the precise instruction (this is an index into "
"the bytecode string of the code object)."
msgstr ""
"Спеціальні атрибути лише для читання: :attr:`f_back` до попереднього фрейму "
"стека (до абонента), або ``None``, якщо це нижній фрейм стека; :attr:"
"`f_code` - об'єкт коду, який виконується в цьому кадрі; :attr:`f_locals` - "
"це словник, який використовується для пошуку локальних змінних; :attr:"
"`f_globals` використовується для глобальних змінних; :attr:`f_builtins` "
"використовується для вбудованих (внутрішніх) імен; :attr:`f_lasti` дає точну "
"інструкцію (це індекс у рядку байт-коду об’єкта коду)."

msgid ""
"Accessing ``f_code`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"Доступ до ``f_code`` викликає :ref:`подію аудиту <auditing>` ``object."
"__getattr__`` з аргументами ``obj`` і ``\"f_code\"``."

msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called for various events during code execution (this is used by the "
"debugger). Normally an event is triggered for each new source line - this "
"can be disabled by setting :attr:`f_trace_lines` to :const:`False`."
msgstr ""
"Спеціальні атрибути, доступні для запису: :attr:`f_trace`, якщо не ``None``, "
"це функція, яка викликається для різних подій під час виконання коду (вона "
"використовується налагоджувачем). Зазвичай подія запускається для кожного "
"нового вихідного рядка - це можна вимкнути, встановивши :attr:"
"`f_trace_lines` на :const:`False`."

msgid ""
"Implementations *may* allow per-opcode events to be requested by setting :"
"attr:`f_trace_opcodes` to :const:`True`. Note that this may lead to "
"undefined interpreter behaviour if exceptions raised by the trace function "
"escape to the function being traced."
msgstr ""
"Реалізації *можуть* дозволити надсилати запит на події кожного коду "
"операції, встановивши для :attr:`f_trace_opcodes` значення :const:`True`. "
"Зауважте, що це може призвести до невизначеної поведінки інтерпретатора, "
"якщо винятки, викликані функцією трасування, переходять до функції, що "
"трасується."

msgid ""
":attr:`f_lineno` is the current line number of the frame --- writing to this "
"from within a trace function jumps to the given line (only for the bottom-"
"most frame).  A debugger can implement a Jump command (aka Set Next "
"Statement) by writing to f_lineno."
msgstr ""
":attr:`f_lineno` — поточний номер рядка кадру --- запис у нього з функції "
"трасування переходить до заданого рядка (лише для самого нижнього кадру). "
"Налагоджувач може реалізувати команду Jump (така ж Set Next Statement), "
"записавши f_lineno."

msgid "Frame objects support one method:"
msgstr "Об’єкти фрейму підтримують один метод:"

msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example when "
"catching an exception and storing its traceback for later use)."
msgstr ""
"Цей метод очищає всі посилання на локальні змінні, які містяться у кадрі. "
"Крім того, якщо кадр належав генератору, генератор завершується. Це "
"допомагає розірвати цикли посилань, пов’язані з об’єктами фрейму (наприклад, "
"під час перехоплення винятку та збереження його трасування для подальшого "
"використання)."

msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr ":exc:`RuntimeError` виникає, якщо кадр зараз виконується."

msgid "Traceback objects"
msgstr "Об'єкти відстеження"

msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is implicitly created when an exception occurs, and may also be "
"explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Об'єкти Traceback представляють трасування стека виняткової ситуації. Об’єкт "
"трасування неявно створюється, коли виникає виняткова ситуація, а також може "
"бути явно створений викликом :class:`types.TracebackType`."

msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by ``sys."
"exc_info()``, and as the ``__traceback__`` attribute of the caught exception."
msgstr ""
"Для неявно створених трасування, коли пошук обробника винятків розгортає "
"стек виконання, на кожному розкрученому рівні об’єкт трасування вставляється "
"перед поточним трасуванням. Коли вводиться обробник винятків, трасування "
"стека стає доступним для програми. (Див. розділ :ref:`try`.) Він доступний "
"як третій елемент кортежу, який повертає ``sys.exc_info()``, і як атрибут "
"``__traceback__`` перехопленого винятку."

msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as ``sys.last_traceback``."
msgstr ""
"Якщо програма не містить відповідного обробника, трасування стека "
"записується (добре відформатована) у стандартний потік помилок; якщо "
"інтерпретатор є інтерактивним, він також стає доступним для користувача як "
"``sys.last_traceback``."

msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the ``tb_next`` attributes should be linked to form a full "
"stack trace."
msgstr ""
"Для явно створених зворотних трасувань автор повинен визначити, як атрибути "
"``tb_next`` повинні бути пов’язані, щоб сформувати повну трасування стека."

msgid ""
"Special read-only attributes: :attr:`tb_frame` points to the execution frame "
"of the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction. The "
"line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr ""
"Спеціальні атрибути лише для читання: :attr:`tb_frame` вказує на кадр "
"виконання поточного рівня; :attr:`tb_lineno` вказує номер рядка, де сталася "
"виняток; :attr:`tb_lasti` вказує на точну інструкцію. Номер рядка та остання "
"інструкція в трасуванні можуть відрізнятися від номера рядка його об’єкта "
"фрейму, якщо виняток стався в операторі :keyword:`try` без відповідного "
"пункту крім або з пунктом finally."

msgid ""
"Accessing ``tb_frame`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"Доступ до tb_frame викликає :ref:`подію аудиту <auditing>` ``object."
"__getattr__`` з аргументами ``obj`` і ``\"tb_frame\"``."

msgid ""
"Special writable attribute: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level."
msgstr ""
"Спеціальний атрибут, доступний для запису: :attr:`tb_next` — це наступний "
"рівень трасування стека (до кадру, де сталася виняток), або ``None``, якщо "
"наступного рівня немає."

msgid ""
"Traceback objects can now be explicitly instantiated from Python code, and "
"the ``tb_next`` attribute of existing instances can be updated."
msgstr ""
"Об’єкти відстеження тепер можна явно створювати з коду Python, а атрибут "
"``tb_next`` існуючих екземплярів можна оновлювати."

msgid "Slice objects"
msgstr "Розрізати об'єкти"

msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Об’єкти фрагментів використовуються для представлення фрагментів для "
"методів :meth:`~object.__getitem__`. Вони також створюються за допомогою "
"вбудованої функції :func:`slice`."

msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Спеціальні атрибути лише для читання: :attr:`~slice.start` нижня межа; :attr:"
"`~slice.stop` є верхньою межею; :attr:`~slice.step` — значення кроку; якщо "
"опущено, кожен має значення ``None``. Ці атрибути можуть мати будь-який тип."

msgid "Slice objects support one method:"
msgstr "Об'єкти Slice підтримують один метод:"

msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Цей метод приймає єдиний цілочисельний аргумент *length* і обчислює "
"інформацію про зріз, який описав би об’єкт slice, якщо його застосувати до "
"послідовності елементів *length*. Він повертає кортеж із трьох цілих чисел; "
"відповідно, це індекси *start* і *stop* і *крок* або довжина кроку зрізу. "
"Відсутні індекси або індекси, що виходять за межі, обробляються відповідно "
"до звичайних фрагментів."

msgid "Static method objects"
msgstr "Об’єкти статичних методів"

msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Об’єкти статичних методів забезпечують спосіб відмови від перетворення "
"об’єктів функції в об’єкти методів, описані вище. Статичний об’єкт методу є "
"обгорткою навколо будь-якого іншого об’єкта, зазвичай об’єкта методу, "
"визначеного користувачем. Коли об’єкт статичного методу отримується з класу "
"або екземпляра класу, фактично повернутий об’єкт є об’єктом-огорткою, який "
"не підлягає подальшому перетворенню. Об’єкти статичних методів також можна "
"викликати. Об’єкти статичних методів створюються за допомогою вбудованого "
"конструктора :func:`staticmethod`."

msgid "Class method objects"
msgstr "Об’єкти методу класу"

msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"Об’єкт методу класу, як і статичний об’єкт методу, є оболонкою навколо "
"іншого об’єкта, яка змінює спосіб, у який цей об’єкт отримується з класів та "
"екземплярів класу. Поведінка об’єктів методу класу після такого отримання "
"описана вище, у розділі \"Визначені користувачем методи\". Об’єкти методу "
"класу створюються за допомогою вбудованого конструктора :func:`classmethod`."

msgid "Special method names"
msgstr "Назви спеціальних методів"

msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`~object.__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"Клас може реалізувати певні операції, які викликаються спеціальним "
"синтаксисом (такі як арифметичні операції або індексування та зрізання), "
"визначаючи методи зі спеціальними іменами. Це підхід Python до :dfn:"
"`operator overloading`, що дозволяє класам визначати власну поведінку щодо "
"операторів мови. Наприклад, якщо клас визначає метод із назвою :meth:"
"`~object.__getitem__`, а ``x`` є екземпляром цього класу, то ``x[i]`` "
"приблизно еквівалентний ``type( x).__getitem__(x, i)``. Якщо не зазначено "
"вище, спроби виконати операцію викликають виняток, якщо відповідний метод не "
"визначено (зазвичай :exc:`AttributeError` або :exc:`TypeError`)."

msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`~object."
"__iter__` to ``None``, the class is not iterable, so calling :func:`iter` on "
"its instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`~object.__getitem__`). [#]_"
msgstr ""
"Встановлення для спеціального методу значення ``None`` означає, що "
"відповідна операція недоступна. Наприклад, якщо клас встановлює :meth:"
"`~object.__iter__` на ``None``, клас не піддається ітерації, тому виклик :"
"func:`iter` у його екземплярах викличе :exc:`TypeError` ( не повертаючись "
"до :meth:`~object.__getitem__`). [#]_"

msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"При реалізації класу, який емулює будь-який вбудований тип, важливо, щоб "
"емуляція була реалізована лише в тій мірі, в якій це має сенс для об’єкта, "
"що моделюється. Наприклад, деякі послідовності можуть добре працювати з "
"отриманням окремих елементів, але вилучення фрагмента може не мати сенсу. "
"(Одним із прикладів цього є інтерфейс :class:`~xml.dom.NodeList` в об’єктній "
"моделі документа W3C.)"

msgid "Basic customization"
msgstr "Базове налаштування"

msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Викликається для створення нового екземпляра класу *cls*. :meth:`__new__` — "
"це статичний метод (з особливим регістром, тому вам не потрібно оголошувати "
"його як такий), який приймає клас, екземпляр якого був запитаний, як свій "
"перший аргумент. Решта аргументів передаються у вираз конструктора об’єкта "
"(виклик класу). Поверненим значенням :meth:`__new__` має бути новий "
"екземпляр об’єкта (зазвичай це екземпляр *cls*)."

msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly-created instance as "
"necessary before returning it."
msgstr ""
"Типові реалізації створюють новий екземпляр класу, викликаючи метод :meth:"
"`__new__` суперкласу за допомогою ``super().__new__(cls[, ...])`` з "
"відповідними аргументами, а потім змінюючи новостворений екземпляр перед "
"поверненням."

msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"Якщо :meth:`__new__` викликається під час побудови об’єкта і повертає "
"екземпляр *cls*, тоді новий метод :meth:`__init__` буде викликано як "
"``__init__(self[, ...])``, де *self* — це новий екземпляр, а решта "
"аргументів ті самі, що були передані конструктору об’єкта."

msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Якщо :meth:`__new__` не повертає екземпляр *cls*, то метод :meth:`__init__` "
"нового екземпляра не буде викликано."

msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` призначений головним чином для того, щоб дозволити підкласам "
"незмінних типів (наприклад, int, str або tuple) налаштовувати створення "
"екземплярів. Його також зазвичай перевизначають у власних метакласах, щоб "
"налаштувати створення класу."

msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Викликається після створення екземпляра (за допомогою :meth:`__new__`), але "
"до того, як його буде повернено до викликаючого. Аргументи передаються у "
"вираз конструктора класу. Якщо базовий клас має метод :meth:`__init__`, "
"метод :meth:`__init__` похідного класу, якщо такий є, повинен явно викликати "
"його, щоб забезпечити правильну ініціалізацію частини базового класу "
"примірника; наприклад: ``super().__init__([args...])``."

msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Оскільки :meth:`__new__` і :meth:`__init__` працюють разом у створенні "
"об’єктів (:meth:`__new__`, щоб створити його, і :meth:`__init__`, щоб "
"налаштувати його), немає не-``None`` значення може повертати :meth:"
"`__init__`; це призведе до появи :exc:`TypeError` під час виконання."

msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"Викликається, коли примірник збирається знищити. Це також називається "
"фіналізатором або (неправильно) деструктором. Якщо базовий клас має метод :"
"meth:`__del__`, метод :meth:`__del__` похідного класу, якщо такий є, повинен "
"явно викликати його, щоб забезпечити належне видалення частини базового "
"класу екземпляра."

msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
"Метод :meth:`__del__` може (хоча і не рекомендується!) відкласти знищення "
"екземпляра шляхом створення нового посилання на нього. Це називається "
"*воскресіння* об'єкта. Це залежить від реалізації, чи :meth:`__del__` "
"викликається вдруге, коли воскреслий об’єкт збирається знищити; поточна "
"реалізація :term:`CPython` викликає його лише один раз."

msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr ""
"Не гарантується, що методи :meth:`__del__` викликаються для об’єктів, які "
"все ще існують, коли інтерпретатор завершує роботу."

msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` не викликає напряму ``x.__del__()`` --- перший зменшує кількість "
"посилань для ``x`` на одиницю, а останній викликається лише тоді, коли ``x`` "
"кількість посилань досягає нуля."

msgid "Documentation for the :mod:`gc` module."
msgstr "Документація для модуля :mod:`gc`."

msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"Через ненадійні обставини, за яких викликаються методи :meth:`__del__`, "
"винятки, що виникають під час їх виконання, ігноруються, а попередження "
"друкується в ``sys.stderr``. Зокрема:"

msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` можна викликати, коли виконується довільний код, у тому "
"числі з будь-якого довільного потоку. Якщо :meth:`__del__` потрібно "
"заблокувати або викликати будь-який інший блокуючий ресурс, це може "
"призвести до блокування, оскільки ресурс може вже бути зайнятий кодом, який "
"переривається для виконання :meth:`__del__`."

msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` можна виконати під час завершення роботи інтерпретатора. Як "
"наслідок, глобальні змінні, до яких він має отримати доступ (включно з "
"іншими модулями), можливо, уже були видалені або встановлені на ``None``. "
"Python гарантує, що глобальні елементи, ім’я яких починається з одного "
"підкреслення, будуть видалені з їхнього модуля перед видаленням інших "
"глобальних елементів; якщо немає інших посилань на такі глобали, це може "
"допомогти впевнитися, що імпортовані модулі все ще доступні під час виклику "
"методу :meth:`__del__`."

msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
"Викликається вбудованою функцією :func:`repr` для обчислення \"офіційного\" "
"рядкового представлення об’єкта. Якщо це взагалі можливо, це має виглядати "
"як дійсний вираз Python, який можна використати для відтворення об’єкта з "
"тим самим значенням (за умови відповідного середовища). Якщо це неможливо, "
"слід повернути рядок у формі ``<...some useful description...>``. Повернене "
"значення має бути рядковим об’єктом. Якщо клас визначає :meth:`__repr__`, "
"але не :meth:`__str__`, тоді :meth:`__repr__` також використовується, коли "
"потрібне \"неформальне\" рядкове представлення екземплярів цього класу."

msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""
"Це зазвичай використовується для налагодження, тому важливо, щоб "
"представлення було насиченим інформацією та однозначним."

msgid ""
"Called by :func:`str(object) <str>` and the built-in functions :func:"
"`format` and :func:`print` to compute the \"informal\" or nicely printable "
"string representation of an object.  The return value must be a :ref:`string "
"<textseq>` object."
msgstr ""
"Викликається :func:`str(object) <str>` і вбудованими функціями :func:"
"`format` і :func:`print` для обчислення \"неформального\" або зручного для "
"друку рядкового представлення об’єкта. Повернене значення має бути об’єктом :"
"ref:`string <textseq>`."

msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Цей метод відрізняється від :meth:`object.__repr__` тим, що не очікується, "
"що :meth:`__str__` поверне дійсний вираз Python: можна використовувати більш "
"зручне або стисле представлення."

msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"Стандартна реалізація, визначена вбудованим типом :class:`object`, викликає :"
"meth:`object.__repr__`."

msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object."
msgstr ""
"Викликається :ref:`bytes <func-bytes>` для обчислення байтового "
"представлення об’єкта. Це має повернути об’єкт :class:`bytes`."

msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"Викликається вбудованою функцією :func:`format` і за допомогою розширення "
"обчислення :ref:`форматованих рядкових літералів <f-strings>` і методу :meth:"
"`str.format`, щоб створити \"відформатований\" рядковий представлення "
"об'єкт. Аргумент *format_spec* — це рядок, який містить опис бажаних "
"параметрів форматування. Інтерпретація аргументу *format_spec* залежить від "
"типу, що реалізує :meth:`__format__`, проте більшість класів або делегують "
"форматування одному з вбудованих типів, або використовують подібний "
"синтаксис параметрів форматування."

msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Перегляньте :ref:`formatspec` для опису стандартного синтаксису форматування."

msgid "The return value must be a string object."
msgstr "Повернене значення має бути рядковим об’єктом."

msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"Сам метод __format__ ``object`` викликає :exc:`TypeError`, якщо передати "
"будь-який непорожній рядок."

msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` тепер еквівалентний ``str(x)``, а не "
"``format(str(x), '')``."

msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"Це так звані методи \"багатого порівняння\". Відповідність між символами "
"оператора та назвами методів така: ``x <y`` calls ``x.__lt__(y)``, ``x<=y`` "
"calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, ``x!=y`` calls ``x."
"__ne__(y)``, ``x> y`` викликає ``x.__gt__(y)``, а ``x>=y`` викликає ``x."
"__ge__(y)``."

msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"Розширений метод порівняння може повертати синглтон ``NotImplemented``, якщо "
"він не реалізує операцію для заданої пари аргументів. Згідно з домовленістю, "
"для успішного порівняння повертаються ``False`` і ``True``. Однак ці методи "
"можуть повертати будь-яке значення, тому, якщо оператор порівняння "
"використовується в логічному контексті (наприклад, в умові оператора if), "
"Python викличе :func:`bool` для значення, щоб визначити якщо результат "
"істинний або хибний."

msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning "
"``NotImplemented`` in the case of a false comparison: ``True if x is y else "
"NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is ``NotImplemented``.  There are "
"no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""
"За замовчуванням ``object`` реалізує :meth:`__eq__` за допомогою ``is``, "
"повертаючи ``NotImplemented`` у випадку хибного порівняння: ``True if x is y "
"else NotImplemented``. Для :meth:`__ne__` за замовчуванням він делегує :meth:"
"`__eq__` та інвертує результат, якщо він не ``NotImplemented``. Серед "
"операторів порівняння чи реалізацій за замовчуванням немає інших припущених "
"зв’язків; наприклад, істинність ``(x<y або x==y)`` не означає ``x<=y``. Щоб "
"автоматично генерувати операції впорядкування з однієї кореневої операції, "
"перегляньте :func:`functools.total_ordering`."

msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"Перегляньте параграф про :meth:`__hash__` для деяких важливих приміток щодо "
"створення об’єктів :term:`hashable`, які підтримують спеціальні операції "
"порівняння та використовуються як ключі словника."

msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and right operand's type is a direct or indirect subclass "
"of the left operand's type, the reflected method of the right operand has "
"priority, otherwise the left operand's method has priority.  Virtual "
"subclassing is not considered."
msgstr ""
"Немає версій цих методів із заміною аргументів (для використання, коли лівий "
"аргумент не підтримує операцію, але правий підтримує); швидше, :meth:"
"`__lt__` і :meth:`__gt__` є відображенням одне одного, :meth:`__le__` і :"
"meth:`__ge__` є відображенням одне одного, а :meth:`__eq__` і :meth:`__ne__` "
"є їх власним відображенням. Якщо операнди мають різні типи, а тип правого "
"операнда є прямим або непрямим підкласом типу лівого операнда, відображений "
"метод правого операнда має пріоритет, інакше метод лівого операнда має "
"пріоритет. Віртуальний підклас не розглядається."

msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  The ``__hash__()`` method should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"Викликається вбудованою функцією :func:`hash` і для операцій над членами "
"хешованих колекцій, включаючи :class:`set`, :class:`frozenset` і :class:"
"`dict`. Метод ``__hash__()`` має повертати ціле число. Єдиною необхідною "
"властивістю є те, що об’єкти, які порівнюються, мають однакове хеш-значення; "
"рекомендується змішувати геш-значення компонентів об’єкта, які також "
"відіграють роль у порівнянні об’єктів, упаковуючи їх у кортеж і хешуючи "
"кортеж. Приклад::"

msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` скорочує значення, що повертається користувацьким методом :meth:"
"`__hash__` об’єкта, до розміру :c:type:`Py_ssize_t`. Зазвичай це 8 байтів "
"для 64-розрядних збірок і 4 байти для 32-розрядних збірок. Якщо :meth:"
"`__hash__` об’єкта має взаємодіяти зі збірками різних бітових розмірів, "
"обов’язково перевірте ширину всіх підтримуваних збірок. Простий спосіб "
"зробити це за допомогою ``python -c \"import sys; print(sys.hash_info."
"width)\"``."

msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of hashable collections requires that a key's hash value is "
"immutable (if the object's hash value changes, it will be in the wrong hash "
"bucket)."
msgstr ""
"Якщо клас не визначає метод :meth:`__eq__`, він також не повинен визначати "
"операцію :meth:`__hash__`; якщо він визначає :meth:`__eq__`, але не :meth:"
"`__hash__`, його екземпляри не можна буде використовувати як елементи в "
"хешованих колекціях. Якщо клас визначає змінні об’єкти та реалізує метод :"
"meth:`__eq__`, він не повинен реалізовувати :meth:`__hash__`, оскільки "
"реалізація хешованих колекцій вимагає, щоб хеш-значення ключа було незмінним "
"(якщо хеш-значення об’єкта змінюється, воно буде в неправильному хеш-бакеті)."

msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"Визначені користувачем класи за замовчуванням мають методи :meth:`__eq__` і :"
"meth:`__hash__`; з ними всі об’єкти порівнюються нерівно (крім самих себе), "
"і ``x.__hash__()`` повертає відповідне значення, так що ``x == y`` означає, "
"що ``x є y`` і ``hash (x) == хеш(y)``."

msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"Для класу, який перевизначає :meth:`__eq__` і не визначає :meth:`__hash__`, "
"його :meth:`__hash__` буде неявно встановлено на ``None``. Коли метод :meth:"
"`__hash__` класу має значення ``None``, екземпляри класу викличуть "
"відповідну :exc:`TypeError`, коли програма намагатиметься отримати їх хеш-"
"значення, а також будуть правильно визначені як нехешується під час "
"перевірки ``isinstance(obj, collections.abc.Hashable)``."

msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Якщо клас, який перевизначає :meth:`__eq__`, потребує збереження реалізації :"
"meth:`__hash__` від батьківського класу, інтерпретатор має бути повідомлений "
"про це явно, встановивши ``__hash__ = <ParentClass> .__hash__``."

msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Якщо клас, який не перевизначає :meth:`__eq__`, бажає придушити підтримку "
"хешу, він повинен включити ``__hash__ = None`` у визначення класу. Клас, "
"який визначає власний :meth:`__hash__`, який явно викликає :exc:`TypeError`, "
"буде неправильно ідентифікований як хешований викликом ``isinstance(obj, "
"collections.abc.Hashable)``."

msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"За замовчуванням значення :meth:`__hash__` об’єктів str і bytes "
"\"підсолюються\" непередбачуваним випадковим значенням. Хоча вони "
"залишаються незмінними в окремому процесі Python, вони не передбачувані між "
"повторними викликами Python."

msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully-chosen inputs that exploit the worst case performance of a dict "
"insertion, O(n\\ :sup:`2`) complexity.  See http://www.ocert.org/advisories/"
"ocert-2011-003.html for details."
msgstr ""
"Це призначено для забезпечення захисту від відмови в обслуговуванні, "
"викликаної ретельно вибраними введеннями, які використовують найгіршу "
"продуктивність вставки dict, O(n\\ :sup:`2`) складності. Див. http://www."
"ocert.org/advisories/ocert-2011-003.html для отримання додаткової інформації."

msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Зміна хеш-значень впливає на порядок ітерацій наборів. Python ніколи не "
"надавав гарантій щодо такого порядку (і він зазвичай варіюється між 32-"
"бітними та 64-бітними збірками)."

msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Дивіться також :envvar:`PYTHONHASHSEED`."

msgid "Hash randomization is enabled by default."
msgstr "Хеш-рандомізація ввімкнена за замовчуванням."

msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither :meth:"
"`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""
"Викликається для реалізації перевірки значення істинності та вбудованої "
"операції ``bool()``; має повертати ``False`` або ``True``. Коли цей метод не "
"визначено, викликається :meth:`__len__`, якщо він визначений, і об’єкт "
"вважається істинним, якщо його результат ненульовий. Якщо клас не визначає "
"ані :meth:`__len__`, ані :meth:`__bool__`, усі його екземпляри вважаються "
"істинними."

msgid "Customizing attribute access"
msgstr "Налаштування доступу до атрибутів"

msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Наступні методи можна визначити для налаштування значення доступу до "
"атрибутів (використання, призначення або видалення ``x.name``) для "
"екземплярів класу."

msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"Викликається, коли доступ до атрибута за замовчуванням не вдається через :"
"exc:`AttributeError` (будь-який :meth:`__getattribute__` викликає :exc:"
"`AttributeError`, оскільки *name* не є атрибутом екземпляра або атрибутом у "
"дереві класів для ``self``; або :meth:`__get__` властивості *name* викликає :"
"exc:`AttributeError`). Цей метод має повертати (обчислене) значення атрибута "
"або викликати виняток :exc:`AttributeError`."

msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"Зауважте, що якщо атрибут знайдено за допомогою звичайного механізму, :meth:"
"`__getattr__` не викликається. (Це навмисна асиметрія між :meth:"
"`__getattr__` і :meth:`__setattr__`.) Це зроблено як з міркувань "
"ефективності, так і тому, що інакше :meth:`__getattr__` не матиме доступу до "
"інших атрибутів примірника. Зауважте, що принаймні для змінних екземпляра ви "
"можете імітувати повний контроль, не вставляючи жодних значень у словник "
"атрибутів екземпляра (а натомість вставляючи їх в інший об’єкт). Перегляньте "
"метод :meth:`__getattribute__` нижче, щоб дізнатися, як фактично отримати "
"повний контроль над доступом до атрибутів."

msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Викликається безумовно для реалізації доступу до атрибутів для екземплярів "
"класу. Якщо клас також визначає :meth:`__getattr__`, останній не буде "
"викликаний, якщо :meth:`__getattribute__` не викличе його явно або не "
"викличе :exc:`AttributeError`. Цей метод має повертати (обчислене) значення "
"атрибута або викликати виняток :exc:`AttributeError`. Щоб уникнути "
"нескінченної рекурсії в цьому методі, його реалізація повинна завжди "
"викликати метод базового класу з тим самим іменем для доступу до будь-яких "
"необхідних атрибутів, наприклад, ``object.__getattribute__(self, name)``."

msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""
"Цей метод все ще можна обійти під час пошуку спеціальних методів у "
"результаті неявного виклику через синтаксис мови або вбудовані функції. "
"Перегляньте :ref:`special-lookup`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__getattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``object.__getattr__`` з аргументами "
"``obj``, ``name``."

msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Для доступу до певних конфіденційних атрибутів викликає :ref:`подію аудиту "
"<auditing>` ``object.__getattr__`` з аргументами ``obj`` і ``name``."

msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Викликається під час спроби призначення атрибута. Це викликається замість "
"звичайного механізму (тобто збереження значення в словнику екземпляра). "
"*name* — ім’я атрибута, *value* — значення, яке йому буде присвоєно."

msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
"Якщо :meth:`__setattr__` хоче призначити атрибут екземпляра, він повинен "
"викликати метод базового класу з такою самою назвою, наприклад, ``object."
"__setattr__(self, name, value)``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__setattr__`` with "
"arguments ``obj``, ``name``, ``value``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``object.__setattr__`` з аргументами "
"``obj``, ``name``, ``value``."

msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"Для певних конфіденційних призначень атрибутів створює :ref:`подію аудиту "
"<auditing>` ``object.__setattr__`` з аргументами ``obj``, ``name``, "
"``value``."

msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Як :meth:`__setattr__`, але для видалення атрибута замість призначення. Це "
"слід застосовувати, лише якщо ``del obj.name`` має значення для об’єкта."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__delattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``object.__delattr__`` з аргументами "
"``obj``, ``name``."

msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Для певних видалень конфіденційних атрибутів викликає :ref:`подію аудиту "
"<auditing>` ``object.__delattr__`` з аргументами ``obj`` і ``name``."

msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts it."
msgstr ""
"Викликається, коли :func:`dir` викликається для об’єкта. Необхідно повернути "
"послідовність. :func:`dir` перетворює повернуту послідовність на список і "
"сортує його."

msgid "Customizing module attribute access"
msgstr "Налаштування доступу до атрибутів модуля"

msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"Спеціальні імена ``__getattr__`` і ``__dir__`` також можна використовувати "
"для налаштування доступу до атрибутів модуля. Функція ``__getattr__`` на "
"рівні модуля повинна приймати один аргумент, який є назвою атрибута, і "
"повертати обчислене значення або викликати :exc:`AttributeError`. Якщо "
"атрибут не знайдено в об’єкті модуля за допомогою звичайного пошуку, тобто :"
"meth:`object.__getattribute__`, тоді ``__getattr__`` шукається в модулі "
"``__dict__`` перед тим, як викликати :exc:`AttributeError` . Якщо знайдено, "
"воно викликається з назвою атрибута та повертає результат."

msgid ""
"The ``__dir__`` function should accept no arguments, and return a sequence "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"Функція ``__dir__`` не повинна приймати аргументів і повертати послідовність "
"рядків, яка представляє імена, доступні в модулі. Якщо присутня, ця функція "
"замінює стандартний пошук :func:`dir` у модулі."

msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"Для більш точного налаштування поведінки модуля (встановлення атрибутів, "
"властивостей тощо) можна встановити атрибут ``__class__`` об’єкта модуля до "
"підкласу :class:`types.ModuleType`. Наприклад::"

msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"Визначення модуля ``__getattr__`` і налаштування модуля ``__class__`` "
"впливають лише на пошуки, зроблені за допомогою синтаксису доступу до "
"атрибутів – прямий доступ до глобалів модуля (чи то за допомогою коду в "
"модулі, чи через посилання на словник глобалів модуля) не впливає."

msgid "``__class__`` module attribute is now writable."
msgstr "Атрибут модуля ``__class__`` тепер доступний для запису."

msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "Атрибути модуля ``__getattr__`` і ``__dir__``."

msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - Модуль __getattr__ і __dir__"

msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Описує функції ``__getattr__`` і ``__dir__`` для модулів."

msgid "Implementing Descriptors"
msgstr "Реалізація дескрипторів"

msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`."
msgstr ""
"Наступні методи застосовуються лише тоді, коли екземпляр класу, що містить "
"метод (так званий клас *descriptor*), з’являється в класі *owner* "
"(дескриптор має бути або в словнику класу власника, або в словнику класу для "
"одного з його батьки). У наведених нижче прикладах \"атрибут\" відноситься "
"до атрибута, ім’я якого є ключем властивості в класі власника :attr:`~object."
"__dict__`."

msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Викликається, щоб отримати атрибут класу власника (доступ до атрибуту класу) "
"або екземпляра цього класу (доступ до атрибуту екземпляра). Необов’язковий "
"аргумент *owner* — це клас власника, тоді як *instance* — це екземпляр, "
"через який був доступ до атрибута, або ``None``, коли доступ до атрибута "
"здійснюється через *owner*."

msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr ""
"Цей метод має повертати обчислене значення атрибута або викликати виняток :"
"exc:`AttributeError`."

msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` вказує, що :meth:`__get__` можна викликати за допомогою одного "
"або двох аргументів. Власні вбудовані дескриптори Python підтримують цю "
"специфікацію; проте ймовірно, що деякі інструменти сторонніх розробників "
"мають дескриптори, які потребують обох аргументів. Власна реалізація :meth:"
"`__getattribute__` Python завжди передає обидва аргументи незалежно від "
"того, потрібні вони чи ні."

msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Викликається, щоб встановити атрибуту екземпляра *екземпляру* класу власника "
"нове значення *value*."

msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Зверніть увагу: додавання :meth:`__set__` або :meth:`__delete__` змінює тип "
"дескриптора на \"дескриптор даних\". Перегляньте :ref:`descriptor-"
"invocation` для отримання додаткової інформації."

msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Викликається для видалення атрибута екземпляра *екземпляра* класу власника."

msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"Атрибут :attr:`__objclass__` інтерпретується модулем :mod:`inspect` як "
"визначення класу, де було визначено цей об’єкт (встановлення цього належним "
"чином може допомогти під час інтроспекції динамічних атрибутів класу). Для "
"callables це може вказувати на те, що екземпляр заданого типу (або підкласу) "
"очікується або вимагається як перший позиційний аргумент (наприклад, CPython "
"встановлює цей атрибут для незв’язаних методів, реалізованих у C)."

msgid "Invoking Descriptors"
msgstr "Виклик дескрипторів"

msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and :meth:"
"`~object.__delete__`. If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr ""
"Загалом, дескриптор — це атрибут об’єкта з \"зв’язуючою поведінкою\", доступ "
"до атрибутів якого перевизначено методами в протоколі дескриптора: :meth:"
"`~object.__get__`, :meth:`~object.__set__` і :meth:`~object.__delete__`. "
"Якщо будь-який із цих методів визначено для об’єкта, він називається "
"дескриптором."

msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Поведінка за умовчанням для доступу до атрибутів полягає в отриманні, "
"установці або видаленні атрибута зі словника об’єкта. Наприклад, ``a.x`` має "
"ланцюжок пошуку, який починається з ``a.__dict__['x']``, потім ``type(a)."
"__dict__['x']`` і продовжується через базові класи типу ``type(a)``, за "
"винятком метакласів."

msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"Проте, якщо шукане значення є об’єктом, що визначає один із методів "
"дескриптора, тоді Python може замінити поведінку за замовчуванням і замість "
"цього викликати метод дескриптора. Де це відбувається в ланцюжку "
"пріоритетів, залежить від того, які методи дескриптора були визначені та як "
"вони були викликані."

msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"Початковою точкою для виклику дескриптора є прив’язка, ``a.x``. Спосіб "
"збирання аргументів залежить від ``a``:"

msgid "Direct Call"
msgstr "Прямий дзвінок"

msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"Найпростіший і найменш поширений виклик — це коли код користувача "
"безпосередньо викликає метод дескриптора: ``x.__get__(a)``."

msgid "Instance Binding"
msgstr "Прив'язка екземпляра"

msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"У разі прив’язки до екземпляра об’єкта ``a.x`` перетворюється на виклик: "
"``type(a).__dict__['x'].__get__(a, type(a))``."

msgid "Class Binding"
msgstr "Прив'язка класу"

msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"Якщо прив’язується до класу, ``A.x`` перетворюється на виклик: ``A."
"__dict__['x'].__get__(None, A)``."

msgid "Super Binding"
msgstr "Супер прив'язка"

msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately following ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""

msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and :meth:"
"`~object.__delete__`.  If it does not define :meth:`__get__`, then accessing "
"the attribute will return the descriptor object itself unless there is a "
"value in the object's instance dictionary.  If the descriptor defines :meth:"
"`__set__` and/or :meth:`__delete__`, it is a data descriptor; if it defines "
"neither, it is a non-data descriptor.  Normally, data descriptors define "
"both :meth:`__get__` and :meth:`__set__`, while non-data descriptors have "
"just the :meth:`__get__` method.  Data descriptors with :meth:`__get__` and :"
"meth:`__set__` (and/or :meth:`__delete__`) defined always override a "
"redefinition in an instance dictionary.  In contrast, non-data descriptors "
"can be overridden by instances."
msgstr ""
"Наприклад, прив’язки, пріоритет виклику дескриптора залежить від того, які "
"методи дескриптора визначено. Дескриптор може визначати будь-яку комбінацію :"
"meth:`~object.__get__`, :meth:`~object.__set__` та :meth:`~object."
"__delete__`. Якщо він не визначає :meth:`__get__`, тоді доступ до атрибута "
"поверне сам об’єкт дескриптора, якщо немає значення в словнику екземплярів "
"об’єкта. Якщо дескриптор визначає :meth:`__set__` та/або :meth:`__delete__`, "
"це дескриптор даних; якщо він не визначає жодного, це дескриптор не даних. "
"Зазвичай дескриптори даних визначають і :meth:`__get__`, і :meth:`__set__`, "
"тоді як дескриптори без даних мають лише метод :meth:`__get__`. Дескриптори "
"даних із визначеними :meth:`__get__` і :meth:`__set__` (і/або :meth:"
"`__delete__`) завжди замінюють перевизначення в словнику екземпляра. "
"Навпаки, дескриптори, не пов’язані з даними, можуть бути перевизначені "
"екземплярами."

msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"Методи Python (включаючи ті, що прикрашені :func:`@staticmethod "
"<staticmethod>` і :func:`@classmethod <classmethod>`) реалізовані як "
"дескриптори не даних. Відповідно, екземпляри можуть перевизначати та "
"замінювати методи. Це дозволяє окремим примірникам набувати поведінки, яка "
"відрізняється від інших примірників того самого класу."

msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"Функція :func:`property` реалізована як дескриптор даних. Відповідно, "
"екземпляри не можуть перевизначати поведінку властивості."

msgid "__slots__"
msgstr "__slots__"

msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* дозволяє нам явно оголошувати елементи даних (наприклад, "
"властивості) і забороняти створення :attr:`~object.__dict__` і *__weakref__* "
"(якщо це явно не оголошено в *__slots__* або доступно в батьківському)."

msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
"Місце, збережене за допомогою :attr:`~object.__dict__` може бути значним. "
"Швидкість пошуку атрибутів також можна значно покращити."

msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of :attr:"
"`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"Цій змінній класу можна призначити рядок, ітерацію або послідовність рядків "
"з іменами змінних, які використовуються екземплярами. *__slots__* резервує "
"місце для оголошених змінних і запобігає автоматичному створенню :attr:"
"`~object.__dict__` і *__weakref__* для кожного екземпляра."

msgid "Notes on using *__slots__*"
msgstr "Примітки щодо використання *__slots__*"

msgid ""
"When inheriting from a class without *__slots__*, the :attr:`~object."
"__dict__` and *__weakref__* attribute of the instances will always be "
"accessible."
msgstr ""
"При успадкуванні від класу без *__slots__* атрибути :attr:`~object.__dict__` "
"і *__weakref__* екземплярів завжди будуть доступними."

msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"Без змінної :attr:`~object.__dict__` екземплярам не можна призначати нові "
"змінні, не вказані у визначенні *__slots__*. Спроби призначити змінній, яка "
"не вказана в списку, викликають помилку :exc:`AttributeError`. Якщо потрібне "
"динамічне призначення нових змінних, тоді додайте ``'__dict__'`` до "
"послідовності рядків у декларації *__slots__*."

msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Без змінної *__weakref__* для кожного екземпляра класи, що визначають "
"*__slots__*, не підтримують :mod:`слабкі посилання <weakref>` на його "
"екземпляри. Якщо необхідна підтримка слабких посилань, додайте "
"``'__weakref__'`` до послідовності рядків у декларації *__slots__*."

msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* реалізуються на рівні класу шляхом створення :ref:`дескрипторів "
"<descriptors>` для кожної назви змінної. Як результат, атрибути класу не "
"можна використовувати для встановлення значень за замовчуванням для змінних "
"екземплярів, визначених *__slots__*; інакше атрибут класу перезапише "
"призначення дескриптора."

msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, child subclasses will get a :attr:`~object.__dict__` and "
"*__weakref__* unless they also define *__slots__* (which should only contain "
"names of any *additional* slots)."
msgstr ""
"Дія оголошення *__slots__* не обмежується класом, де воно визначено. "
"*__slots__*, оголошені в батьківських класах, доступні в дочірніх класах. "
"Однак дочірні підкласи отримають :attr:`~object.__dict__` і *__weakref__*, "
"якщо вони також не визначають *__slots__* (які мають містити лише назви будь-"
"яких *додаткових* слотів)."

msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Якщо клас визначає слот, також визначений у базовому класі, змінна "
"екземпляра, визначена слотом базового класу, недоступна (за винятком "
"отримання її дескриптора безпосередньо з базового класу). Це робить значення "
"програми невизначеним. У майбутньому для запобігання цьому може бути додана "
"перевірка."

msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`int`, :class:`bytes` and :class:"
"`tuple`."
msgstr ""
"Nonempty *__slots__* не працює для класів, похідних від вбудованих типів "
"\"змінної довжини\", таких як :class:`int`, :class:`bytes` і :class:`tuple`."

msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr ""
"Будь-який нерядковий :term:`iterable` може бути призначений *__slots__*."

msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised by :"
"func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"Якщо :class:`dictionary <dict>` використовується для призначення "
"*__slots__*, ключі словника будуть використані як імена слотів. Значення "
"словника можна використовувати для надання рядків документів для кожного "
"атрибута, які розпізнаються :func:`inspect.getdoc` і відображаються у "
"виводі :func:`help`."

msgid ""
":attr:`~instance.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""
":attr:`~instance.__class__` призначення працює, лише якщо обидва класи мають "
"однакові *__slots__*."

msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
":ref:`Множинне успадкування <tut-multiple>` з кількома батьківськими класами "
"зі слотами можна використовувати, але лише одному з батьківських класів "
"дозволено мати атрибути, створені слотами (інші бази повинні мати порожні "
"макети слотів) - порушення викликають :exc:`TypeError`."

msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"Якщо :term:`iterator` використовується для *__slots__*, то :term:"
"`descriptor` створюється для кожного значення ітератора. Однак атрибут "
"*__slots__* буде порожнім ітератором."

msgid "Customizing class creation"
msgstr "Налаштування створення класу"

msgid ""
"Whenever a class inherits from another class, :meth:`~object."
"__init_subclass__` is called on the parent class. This way, it is possible "
"to write classes which change the behavior of subclasses. This is closely "
"related to class decorators, but where class decorators only affect the "
"specific class they're applied to, ``__init_subclass__`` solely applies to "
"future subclasses of the class defining the method."
msgstr ""
"Щоразу, коли клас успадковує інший клас, :meth:`~object.__init_subclass__` "
"викликається в батьківському класі. Таким чином можна писати класи, які "
"змінюють поведінку підкласів. Це тісно пов’язане з декораторами класів, але "
"де декоратори класів впливають лише на конкретний клас, до якого вони "
"застосовані, ``__init_subclass__`` застосовується виключно до майбутніх "
"підкласів класу, що визначає метод."

msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Цей метод викликається кожного разу, коли клас, що містить, є підкласом. "
"Тоді *cls* є новим підкласом. Якщо визначено як звичайний метод екземпляра, "
"цей метод неявно перетворюється на метод класу."

msgid ""
"Keyword arguments which are given to a new class are passed to the parent's "
"class ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"Аргументи ключових слів, надані новому класу, передаються до батьківського "
"класу ``__init_subclass__``. Для сумісності з іншими класами, які "
"використовують ``__init_subclass__``, слід вилучити необхідні ключові "
"аргументи та передати інші до базового класу, як у::"

msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"Реалізація за замовчуванням ``object.__init_subclass__`` нічого не робить, "
"але викликає помилку, якщо вона викликається з будь-якими аргументами."

msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"Підказка метакласу ``metaclass`` споживається рештою механізму типів і "
"ніколи не передається реалізаціям ``__init_subclass__``. Фактичний метаклас "
"(а не явна підказка) можна отримати як ``type(cls)``."

msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""
"Коли клас створюється, :meth:`type.__new__` сканує змінні класу та виконує "
"зворотні виклики до тих, що мають хук :meth:`~object.__set_name__`."

msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"Автоматично викликається під час створення класу власника *owner*. Об’єкту "
"було призначено *name* у цьому класі::"

msgid ""
"If the class variable is assigned after the class is created, :meth:"
"`__set_name__` will not be called automatically. If needed, :meth:"
"`__set_name__` can be called directly::"
msgstr ""
"Якщо змінна класу призначається після створення класу, :meth:`__set_name__` "
"не буде викликатися автоматично. За потреби :meth:`__set_name__` можна "
"викликати безпосередньо::"

msgid "See :ref:`class-object-creation` for more details."
msgstr ""
"Дивіться :ref:`class-object-creation` для отримання додаткової інформації."

msgid "Metaclasses"
msgstr "Метакласи"

msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"За замовчуванням класи створюються за допомогою :func:`type`. Тіло класу "
"виконується в новому просторі імен, а ім’я класу прив’язується локально до "
"результату ``type(name, bases, namespace)``."

msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"Процес створення класу можна налаштувати, передавши аргумент ключового слова "
"``metaclass`` у рядку визначення класу або успадкувавши від існуючого класу, "
"який містив такий аргумент. У наступному прикладі і ``MyClass``, і "
"``MySubclass`` є екземплярами ``Meta``::"

msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Будь-які інші ключові аргументи, указані у визначенні класу, передаються до "
"всіх операцій метакласу, описаних нижче."

msgid "When a class definition is executed, the following steps occur:"
msgstr "Коли виконується визначення класу, відбуваються наступні кроки:"

msgid "MRO entries are resolved;"
msgstr "Записи MRO вирішено;"

msgid "the appropriate metaclass is determined;"
msgstr "визначається відповідний метаклас;"

msgid "the class namespace is prepared;"
msgstr "підготовлено простір імен класу;"

msgid "the class body is executed;"
msgstr "виконується тіло класу;"

msgid "the class object is created."
msgstr "створюється об'єкт класу."

msgid "Resolving MRO entries"
msgstr "Вирішення записів MRO"

msgid ""
"If a base that appears in class definition is not an instance of :class:"
"`type`, then an ``__mro_entries__`` method is searched on it. If found, it "
"is called with the original bases tuple. This method must return a tuple of "
"classes that will be used instead of this base. The tuple may be empty, in "
"such case the original base is ignored."
msgstr ""
"Якщо база, яка з’являється у визначенні класу, не є екземпляром :class:"
"`type`, тоді на ній виконується пошук методу ``__mro_entries__``. Якщо "
"знайдено, воно викликається з вихідним базовим кортежем. Цей метод повинен "
"повертати кортеж класів, які будуть використовуватися замість цієї бази. "
"Кортеж може бути порожнім, у такому випадку вихідна база ігнорується."

msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` - Основна підтримка модуля введення та загальних типів"

msgid "Determining the appropriate metaclass"
msgstr "Визначення відповідного метакласу"

msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr "Відповідний метаклас для визначення класу визначається таким чином:"

msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"якщо не вказано жодних баз і явного метакласу, то використовується :func:"
"`type`;"

msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr ""
"якщо задано явний метаклас і він *не* є екземпляром :func:`type`, тоді він "
"використовується безпосередньо як метаклас;"

msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"якщо екземпляр :func:`type` задано як явний метаклас або визначено основи, "
"то використовується найбільш похідний метаклас."

msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"Найбільш похідний метаклас вибирається з явно визначеного метакласу (якщо "
"такий є) і метакласів (тобто ``type(cls)``) усіх указаних базових класів. "
"Найбільш похідним метакласом є той, який є підтипом *усіх* цих метакласів-"
"кандидатів. Якщо жоден із метакласів-кандидатів не відповідає цьому "
"критерію, визначення класу буде невдалим із ``TypeError``."

msgid "Preparing the class namespace"
msgstr "Підготовка простору імен класу"

msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"Після визначення відповідного метакласу готується простір імен класу. Якщо "
"метаклас має атрибут ``__prepare__``, він викликається як ``namespace = "
"metaclass.__prepare__(name, bases, **kwds)`` (де додаткові ключові "
"аргументи, якщо такі є, надходять із визначення класу) . Метод "
"``__prepare__`` має бути реалізований як :func:`classmethod <classmethod>`. "
"Простір імен, повернутий ``__prepare__``, передається в ``__new__``, але "
"коли створюється останній об’єкт класу, простір імен копіюється в новий "
"``dict``."

msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Якщо метаклас не має атрибута ``__prepare__``, тоді простір імен класу "
"ініціалізується як порожнє впорядковане відображення."

msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метакласи в Python 3000"

msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Представлено хук простору імен ``__prepare__``"

msgid "Executing the class body"
msgstr "Виконання тіла класу"

msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"Тіло класу виконується (приблизно) як ``exec(body, globals(), namespace)``. "
"Ключова відмінність від звичайного виклику :func:`exec` полягає в тому, що "
"лексична область видимості дозволяє тілу класу (включаючи будь-які методи) "
"посилатися на імена з поточної та зовнішньої областей, коли визначення класу "
"відбувається всередині функції."

msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"Однак, навіть коли визначення класу відбувається всередині функції, методи, "
"визначені всередині класу, все одно не можуть бачити імена, визначені в "
"області класу. Доступ до змінних класу має здійснюватися через перший "
"параметр екземпляра або методів класу, або через неявне посилання "
"``__class__`` з лексичною областю, описане в наступному розділі."

msgid "Creating the class object"
msgstr "Створення об'єкта класу"

msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"Коли простір імен класу заповнено виконанням тіла класу, об’єкт класу "
"створюється шляхом виклику ``metaclass(name, bases, namespace, **kwds)`` "
"(додаткові ключові слова, передані тут, такі самі, як ті, що передані` "
"`__prepare__``)."

msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"Цей об’єкт класу є тим, на який посилатиметься форма :func:`super` з "
"нульовим аргументом. ``__class__`` — це неявне посилання на закриття, "
"створене компілятором, якщо будь-які методи в тілі класу посилаються на "
"``__class__`` або ``super``. Це дозволяє формі нульового аргументу :func:"
"`super` правильно ідентифікувати клас, який визначається на основі "
"лексичного визначення, тоді як клас або екземпляр, який використовувався для "
"здійснення поточного виклику, ідентифікується на основі першого аргументу, "
"переданого методу."

msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"У CPython 3.6 і пізніших версіях клітинка ``__class__`` передається "
"метакласу як запис ``__classcell__`` у просторі імен класу. Якщо є, це має "
"бути передано до виклику ``type.__new__`` для правильної ініціалізації "
"класу. Якщо цього не зробити, у Python 3.8 виникне :exc:`RuntimeError`."

msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"При використанні метакласу за замовчуванням :class:`type` або будь-якого "
"метакласу, який остаточно викликає ``type.__new__``, наступні додаткові "
"кроки налаштування викликаються після створення об’єкта класу:"

msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"Метод ``type.__new__`` збирає всі атрибути в просторі імен класу, які "
"визначають метод :meth:`~object.__set_name__`;"

msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"Ці методи ``__set_name__`` викликаються з визначеним класом і присвоєною "
"назвою цього конкретного атрибута;"

msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ""
"Хук :meth:`~object.__init_subclass__` викликається на безпосередньому "
"батькові нового класу в порядку вирішення методів."

msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"Після того, як об’єкт класу створено, він передається до декораторів класу, "
"включених у визначення класу (якщо такі є), і отриманий об’єкт зв’язується в "
"локальному просторі імен як визначений клас."

msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~object.__dict__` attribute of the class object."
msgstr ""
"Коли новий клас створюється за допомогою ``type.__new__``, об’єкт, наданий "
"як параметр простору імен, копіюється до нового впорядкованого відображення, "
"а вихідний об’єкт відкидається. Нову копію загортають у проксі-сервер лише "
"для читання, який стає атрибутом :attr:`~object.__dict__` об’єкта класу."

msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - Новий супер"

msgid "Describes the implicit ``__class__`` closure reference"
msgstr "Описує неявне посилання на закриття ``__class__``"

msgid "Uses for metaclasses"
msgstr "Використання для метакласів"

msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"Можливості використання метакласів безмежні. Деякі ідеї, які були "
"досліджені, включають enum, журналювання, перевірку інтерфейсу, автоматичне "
"делегування, автоматичне створення властивостей, проксі, фреймворки та "
"автоматичне блокування/синхронізацію ресурсів."

msgid "Customizing instance and subclass checks"
msgstr "Налаштування перевірок екземплярів і підкласів"

msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Наступні методи використовуються для заміни типової поведінки вбудованих "
"функцій :func:`isinstance` і :func:`issubclass`."

msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"Зокрема, метаклас :class:`abc.ABCMeta` реалізує ці методи, щоб дозволити "
"додавання абстрактних базових класів (ABC) як \"віртуальних базових класів\" "
"до будь-якого класу або типу (включно з вбудованими типами), включаючи інші "
"Азбука."

msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Повертає true, якщо *екземпляр* слід вважати (прямим чи непрямим) "
"екземпляром *класу*. Якщо визначено, викликається для реалізації "
"``isinstance(instance, class)``."

msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"Повертає true, якщо *підклас* слід вважати (прямим чи непрямим) підкласом "
"*класу*. Якщо визначено, викликається для реалізації ``issubclass(subclass, "
"class)``."

msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Зауважте, що ці методи шукаються за типом (метакласом) класу. Вони не можуть "
"бути визначені як методи класу в реальному класі. Це узгоджується з пошуком "
"спеціальних методів, які викликаються для екземплярів, тільки в цьому "
"випадку екземпляр сам по собі є класом."

msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Представляємо абстрактні базові класи"

msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"Включає специфікацію для налаштування поведінки :func:`isinstance` і :func:"
"`issubclass` через :meth:`~class.__instancecheck__` і :meth:`~class."
"__subclasscheck__` з мотивацією для цієї функції в контексті додавання "
"Абстрактні базові класи (див. модуль :mod:`abc`) до мови."

msgid "Emulating generic types"
msgstr "Емуляція загальних типів"

msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"Використовуючи :term:`анотації типу <annotation>`, часто корисно "
"*параметризувати* загальний тип (:term:`generic type`) за допомогою нотації "
"Python у квадратних дужках. Наприклад, анотацію ``list[int]`` можна "
"використовувати для позначення :class:`list`, у якому всі елементи мають "
"тип :class:`int`."

msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - підказки типу"

msgid "Introducing Python's framework for type annotations"
msgstr "Представляємо структуру Python для анотацій типів"

msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Загальні типи псевдонімів <types-genericalias>`"

msgid "Documentation for objects representing parameterized generic classes"
msgstr ""
"Документація для об'єктів, що представляють параметризовані загальні класи"

msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`визначені користувачем узагальнення <user-defined-"
"generics>` і :class:`typing.Generic`"

msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Документація про те, як реалізувати загальні класи, які можна "
"параметризувати під час виконання та розуміти статичними засобами перевірки "
"типів."

msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""
"*Зазвичай* клас може бути параметризований, лише якщо він визначає "
"спеціальний метод класу ``__class_getitem__()``."

msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Повертає об’єкт, який представляє спеціалізацію загального класу за "
"аргументами типу, знайденими в *key*."

msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with :func:"
"`@classmethod<classmethod>` when it is defined."
msgstr ""
"Коли визначено в класі, ``__class_getitem__()`` автоматично стає методом "
"класу. Таким чином, немає необхідності прикрашати його :func:`@classmethod "
"<classmethod>`, коли він визначений."

msgid "The purpose of *__class_getitem__*"
msgstr "Мета *__class_getitem__*"

msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""
"Метою :meth:`~object.__class_getitem__` є можливість параметризації "
"загальних класів стандартної бібліотеки під час виконання, щоб легше "
"застосовувати :term:`підказки типу <type hint>` до цих класів."

msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already implements :meth:`~object."
"__class_getitem__`, or inherit from :class:`typing.Generic`, which has its "
"own implementation of ``__class_getitem__()``."
msgstr ""
"Щоб реалізувати користувальницькі загальні класи, які можна параметризувати "
"під час виконання та розуміти статичними засобами перевірки типів, "
"користувачі повинні або успадкувати від класу стандартної бібліотеки, яка "
"вже реалізує :meth:`~object.__class_getitem__`, або успадкувати від :class:"
"`typing. Generic`, який має власну реалізацію ``__class_getitem__()``."

msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
"Спеціальні реалізації :meth:`~object.__class_getitem__` у класах, визначених "
"за межами стандартної бібліотеки, можуть бути не зрозумілі сторонніми "
"засобами перевірки типів, такими як mypy. Не рекомендується використовувати "
"``__class_getitem__()`` для будь-якого класу для цілей, відмінних від "
"підказки типу."

msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* проти *__getitem__*"

msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"Зазвичай :ref:`підписка <subscriptions>` об’єкта з використанням квадратних "
"дужок викликає метод екземпляра :meth:`~object.__getitem__`, визначений у "
"класі об’єкта. Проте, якщо об’єкт, на який підписується, сам є класом, "
"замість нього можна викликати метод класу :meth:`~object.__class_getitem__`. "
"``__class_getitem__()`` має повертати об’єкт :ref:`GenericAlias <types-"
"genericalias>`, якщо він правильно визначений."

msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether :meth:"
"`~object.__getitem__` or :meth:`~object.__class_getitem__` should be called::"
msgstr ""
"Представлений у вигляді :term:`expression` ``obj[x]``, інтерпретатор Python "
"виконує щось на зразок наступного процесу, щоб вирішити, чи слід :meth:"
"`~object.__getitem__` або :meth:`~object.__class_getitem__` бути викликаним::"

msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not define :"
"meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``, "
"``dict[str, float]`` and ``tuple[str, bytes]`` all result in :meth:`~object."
"__class_getitem__` being called::"
msgstr ""
"У Python усі класи самі є екземплярами інших класів. Клас класу відомий як :"
"term:`metaclass` цього класу, і більшість класів мають клас :class:`type` як "
"метаклас. :class:`type` не визначає :meth:`~object.__getitem__`, тобто такі "
"вирази, як ``list[int]``, ``dict[str, float]`` і ``tuple[str, bytes]`` все "
"призводить до виклику :meth:`~object.__class_getitem__`::"

msgid ""
"However, if a class has a custom metaclass that defines :meth:`~object."
"__getitem__`, subscribing the class may result in different behaviour. An "
"example of this can be found in the :mod:`enum` module::"
msgstr ""
"Однак, якщо клас має спеціальний метаклас, який визначає :meth:`~object."
"__getitem__`, підписка на клас може призвести до іншої поведінки. Приклад "
"цього можна знайти в модулі :mod:`enum`::"

msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ""
":pep:`560` - Основна підтримка модуля введення тексту та загальних типів"

msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a :ref:"
"`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""
"Представляємо :meth:`~object.__class_getitem__` і пояснюємо, коли :ref:"
"`підписка <subscriptions>` призводить до виклику ``__class_getitem__()`` "
"замість :meth:`~object.__getitem__`"

msgid "Emulating callable objects"
msgstr "Емуляція викликаних об'єктів"

msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``."
msgstr ""
"Викликається, коли екземпляр \"викликається\" як функція; якщо цей метод "
"визначено, ``x(arg1, arg2, ...)`` приблизно перекладається як ``type(x)."
"__call__(x, arg1, ...)``."

msgid "Emulating container types"
msgstr "Емуляція типів контейнерів"

msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are :term:`sequences <sequence>` (such as :class:`lists "
"<list>` or :class:`tuples <tuple>`) or :term:`mappings <mapping>` (like :"
"class:`dictionaries <dict>`), but can represent other containers as well.  "
"The first set of methods is used either to emulate a sequence or to emulate "
"a mapping; the difference is that for a sequence, the allowable keys should "
"be the integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or :class:`slice` objects, which define a range of items.  It is "
"also recommended that mappings provide the methods :meth:`keys`, :meth:"
"`values`, :meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :"
"meth:`pop`, :meth:`popitem`, :meth:`!copy`, and :meth:`update` behaving "
"similar to those for Python's standard :class:`dictionary <dict>` objects.  "
"The :mod:`collections.abc` module provides a :class:`~collections.abc."
"MutableMapping` :term:`abstract base class` to help create those methods "
"from a base set of :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, :meth:"
"`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:"
"`reverse` and :meth:`sort`, like Python standard :class:`list` objects. "
"Finally, sequence types should implement addition (meaning concatenation) "
"and multiplication (meaning repetition) by defining the methods :meth:"
"`~object.__add__`, :meth:`~object.__radd__`, :meth:`~object.__iadd__`, :meth:"
"`~object.__mul__`, :meth:`~object.__rmul__` and :meth:`~object.__imul__` "
"described below; they should not define other numerical operators.  It is "
"recommended that both mappings and sequences implement the :meth:`~object."
"__contains__` method to allow efficient use of the ``in`` operator; for "
"mappings, ``in`` should search the mapping's keys; for sequences, it should "
"search through the values.  It is further recommended that both mappings and "
"sequences implement the :meth:`~object.__iter__` method to allow efficient "
"iteration through the container; for mappings, :meth:`__iter__` should "
"iterate through the object's keys; for sequences, it should iterate through "
"the values."
msgstr ""
"Наступні методи можуть бути визначені для реалізації контейнерних об’єктів. "
"Зазвичай контейнерами є :term:`послідовності <sequence>` (такі як :class:"
"`списки <list>` або :class:`кортежі <tuple>`) або :term:`відображення "
"<mapping>` (наприклад, :class:`словник <dict>`), але його представляють "
"також інші контейнери. Перший набір методів використовується або для "
"емуляції послідовності, або для емуляції відображення; різниця полягає в "
"тому, що для послідовності дозволеними ключами мають бути цілі числа *k*, "
"для яких ``0 <= k < N``, де *N* — довжина послідовності, або об’єкти :class:"
"`slice`, які визначають діапазон предметів. Також рекомендується, щоб "
"зіставлення передбачало методи :meth:`keys`, :meth:`values`, :meth:`items`, :"
"meth:`get`, :meth:`clear`, :meth:`setdefault` , :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy` і :meth:`update` поводяться подібно до об’єктів "
"стандарту Python :class:`dictionary <dict>`. Модуль :mod:`collections.abc` "
"надає :class:`~collections.abc.MutableMapping` :term:`abstract base class`, "
"щоб допомогти створити ці методи з базового набору :meth:`~object."
"__getitem__` , :meth:`~object.__setitem__`, :meth:`~object.__delitem__` і :"
"meth:`keys`. Змінні послідовності повинні надавати методи: :meth:`append`, :"
"meth:`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :"
"meth:`remove`, :meth:`reverse` і :meth:`sort`, як стандартні об’єкти Python :"
"class:`list`. Нарешті, типи послідовностей повинні реалізовувати додавання "
"(що означає конкатенацію) і множення (що означає повторення) шляхом "
"визначення методів :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:"
"`~object.__iadd__` , :meth:`~object.__mul__`, :meth:`~object.__rmul__` і :"
"meth:`~object.__imul__`, описані нижче; вони не повинні визначати інші "
"числові оператори. Рекомендується, щоб і відображення, і послідовності "
"реалізовували метод :meth:`~object.__contains__`, щоб забезпечити ефективне "
"використання оператора ``in``; для відображень ``in`` має шукати ключі "
"відображення; для послідовностей слід шукати значення. Крім того, "
"рекомендується, щоб і відображення, і послідовності реалізовували метод :"
"meth:`~object.__iter__`, щоб забезпечити ефективну ітерацію через контейнер; "
"для відображень :meth:`__iter__` має виконувати ітерацію по ключах об’єкта; "
"для послідовностей він повинен перебирати значення."

msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""
"Викликається для реалізації вбудованої функції :func:`len`. Має повертати "
"довжину об’єкта, ціле число ``>=`` 0. Крім того, об’єкт, який не визначає "
"метод :meth:`__bool__` і чий метод :meth:`__len__` повертає нуль, вважається "
"false у логічному контексті."

msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the "
"length is larger than :attr:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`__bool__` method."
msgstr ""
"У CPython довжина не повинна перевищувати :attr:`sys.maxsize`. Якщо довжина "
"більша за :attr:`!sys.maxsize`, деякі функції (такі як :func:`len`) можуть "
"викликати :exc:`OverflowError`. Щоб запобігти виникненню :exc:`!"
"OverflowError` шляхом перевірки значення істинності, об’єкт повинен "
"визначити метод :meth:`__bool__`."

msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :const:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""
"Викликається для реалізації :func:`operator.length_hint`. Має повернути "
"приблизну довжину об’єкта (яка може бути більшою або меншою за фактичну). "
"Довжина має бути цілим числом ``>=`` 0. Поверненим значенням також може "
"бути :const:`NotImplemented`, яке обробляється так само, як якби метод "
"``__length_hint__`` взагалі не існував. Цей метод є виключно оптимізаційним "
"і ніколи не потрібен для коректності."

msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr "Нарізка виконується виключно трьома способами. Дзвінок типу ::"

msgid "is translated to ::"
msgstr "перекладається на ::"

msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "і так далі. Відсутні елементи фрагмента завжди заповнюються ``None``."

msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers and slice objects.  Note that the "
"special interpretation of negative indexes (if the class wishes to emulate "
"a :term:`sequence` type) is up to the :meth:`__getitem__` method. If *key* "
"is of an inappropriate type, :exc:`TypeError` may be raised; if of a value "
"outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For :"
"term:`mapping` types, if *key* is missing (not in the container), :exc:"
"`KeyError` should be raised."
msgstr ""
"Викликається для реалізації оцінки ``self[key]``. Для типів :term:`sequence` "
"прийнятними ключами мають бути цілі числа та об’єкти зрізу. Зверніть увагу, "
"що спеціальна інтерпретація негативних індексів (якщо клас бажає емулювати "
"тип :term:`sequence`) залежить від методу :meth:`__getitem__`. Якщо *key* "
"має невідповідний тип, може виникнути :exc:`TypeError`; якщо значення "
"знаходиться за межами набору індексів для послідовності (після будь-якої "
"спеціальної інтерпретації від’ємних значень), має бути викликано :exc:"
"`IndexError`. Для типів :term:`mapping`, якщо *key* відсутній (не в "
"контейнері), слід викликати :exc:`KeyError`."

msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` цикли очікують, що :exc:`IndexError` буде викликано для "
"недопустимих індексів, щоб забезпечити належне виявлення кінця послідовності."

msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method :"
"meth:`~object.__class_getitem__` may be called instead of ``__getitem__()``. "
"See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"Коли :ref:`індексує <subscriptions>` *клас*, спеціальний метод класу :meth:"
"`~object.__class_getitem__` може викликатися замість ``__getitem__()``. "
"Перегляньте :ref:`classgetitem-versus-getitem` для отримання додаткової "
"інформації."

msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Викликається для реалізації призначення ``self[key]``. Така сама примітка, "
"як і для :meth:`__getitem__`. Це має бути реалізовано лише для відображень, "
"якщо об’єкти підтримують зміни значень для ключів, або якщо можна додати "
"нові ключі, або для послідовностей, якщо елементи можна замінити. Для "
"неправильних значень *key* мають бути викликані ті самі винятки, що й для "
"методу :meth:`__getitem__`."

msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"Викликається для реалізації видалення ``self[key]``. Така сама примітка, як "
"і для :meth:`__getitem__`. Це слід застосовувати лише для відображень, якщо "
"об’єкти підтримують видалення ключів, або для послідовностей, якщо елементи "
"можна видалити з послідовності. Для неправильних значень *key* мають бути "
"викликані ті самі винятки, що й для методу :meth:`__getitem__`."

msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"Викликається :class:`dict`\\ .\\ :meth:`__getitem__` для реалізації "
"``self[key]`` для підкласів dict, коли ключа немає в словнику."

msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"Цей метод викликається, коли для контейнера потрібен :term:`iterator`. Цей "
"метод має повертати новий об’єкт-ітератор, який може виконувати ітерацію по "
"всіх об’єктах у контейнері. Для зіставлення він повинен перебирати ключі "
"контейнера."

msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Викликається (якщо є) вбудованим :func:`reversed` для реалізації зворотної "
"ітерації. Він має повернути новий об’єкт-ітератор, який обходить усі об’єкти "
"в контейнері у зворотному порядку."

msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
"Якщо метод :meth:`__reversed__` не надано, вбудований :func:`reversed` "
"повернеться до використання протоколу послідовності (:meth:`__len__` і :meth:"
"`__getitem__`). Об’єкти, які підтримують протокол послідовності, повинні "
"надавати лише :meth:`__reversed__`, якщо вони можуть забезпечити ефективнішу "
"реалізацію, ніж та, яку надає :func:`reversed`."

msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Оператори перевірки членства (:keyword:`in` і :keyword:`not in`) зазвичай "
"реалізуються як ітерація через контейнер. Однак об’єкти-контейнери можуть "
"надавати наступний спеціальний метод з більш ефективною реалізацією, яка "
"також не вимагає, щоб об’єкт був повторюваним."

msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Викликано реалізувати оператори перевірки членства. Має повертати true, якщо "
"*item* знаходиться в *self*, і false в іншому випадку. Для відображення "
"об’єктів це має враховувати ключі відображення, а не значення або пари ключ-"
"елемент."

msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"Для об’єктів, які не визначають :meth:`__contains__`, тест на приналежність "
"спочатку намагається виконати ітерацію через :meth:`__iter__`, потім старий "
"протокол ітерації послідовності через :meth:`__getitem__`, див. :ref:`цей "
"розділ у посилання на мову <membership-test-details>`."

msgid "Emulating numeric types"
msgstr "Емуляція числових типів"

msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Наступні методи можна визначити для емуляції числових об’єктів. Методи, що "
"відповідають операціям, які не підтримуються конкретним видом реалізованого "
"числа (наприклад, побітові операції для нецілісних чисел), слід залишити "
"невизначеними."

msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to "
"evaluate the expression ``x + y``, where *x* is an instance of a class that "
"has an :meth:`__add__` method, ``x.__add__(y)`` is called.  The :meth:"
"`__divmod__` method should be the equivalent to using :meth:`__floordiv__` "
"and :meth:`__mod__`; it should not be related to :meth:`__truediv__`.  Note "
"that :meth:`__pow__` should be defined to accept an optional third argument "
"if the ternary version of the built-in :func:`pow` function is to be "
"supported."
msgstr ""

msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""
"Якщо один із цих методів не підтримує операцію з наданими аргументами, він "
"має повернути ``NotImplemented``."

msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the left operand does not "
"support the corresponding operation [#]_ and the operands are of different "
"types. [#]_ For instance, to evaluate the expression ``x - y``, where *y* is "
"an instance of a class that has an :meth:`__rsub__` method, ``y."
"__rsub__(x)`` is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""

msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"Зауважте, що тернарний :func:`pow` не намагатиметься викликати :meth:"
"`__rpow__` (правила примусу стануть надто складними)."

msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Якщо тип правого операнда є підкласом типу лівого операнда і цей підклас "
"забезпечує іншу реалізацію відображеного методу для операції, цей метод буде "
"викликаний перед невідображеним методом лівого операнда. Така поведінка "
"дозволяє підкласам перевизначати операції своїх предків."

msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, the "
"augmented assignment falls back to the normal methods.  For instance, if *x* "
"is an instance of a class with an :meth:`__iadd__` method, ``x += y`` is "
"equivalent to ``x = x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y."
"__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""
"Ці методи викликаються для реалізації розширених арифметичних присвоювань "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``// =``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``). Ці методи мають спробувати виконати "
"операцію на місці (змінюючи *self*) і повернути результат (який може бути, "
"але не обов’язково, *self*). Якщо конкретний метод не визначено, доповнене "
"призначення повертається до звичайних методів. Наприклад, якщо *x* є "
"екземпляром класу з методом :meth:`__iadd__`, ``x += y`` еквівалентно ``x = "
"x.__iadd__(y)``. В іншому випадку ``x.__add__(y)`` і ``y.__radd__(x)`` "
"розглядаються, як і з оцінкою ``x + y``. У певних ситуаціях доповнене "
"призначення може призвести до неочікуваних помилок (див. :ref:`faq-augmented-"
"assignment-tuple-error`), але така поведінка насправді є частиною моделі "
"даних."

msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"Викликається для реалізації унарних арифметичних операцій (``-``, ``+``, :"
"func:`abs` і ``~``)."

msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Викликається для реалізації вбудованих функцій :func:`complex`, :func:`int` "
"і :func:`float`. Має повертати значення відповідного типу."

msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Викликається для реалізації :func:`operator.index` і кожного разу, коли "
"Python потребує без втрат перетворити числовий об’єкт у цілочисельний об’єкт "
"(наприклад, у зрізі або у вбудованих :func:`bin`, :func:`hex` і :func:"
"`oct`). Наявність цього методу вказує на те, що числовий об'єкт є цілим "
"типом. Має повертати ціле число."

msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Якщо :meth:`__int__`, :meth:`__float__` і :meth:`__complex__` не визначено, "
"то відповідні вбудовані функції :func:`int`, :func:`float` і :func:`complex` "
"повернутися до :meth:`__index__`."

msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Викликається для реалізації вбудованої функції :func:`round` і :mod:`math` "
"функції :func:`~math.trunc`, :func:`~math.floor` і :func:`~math.ceil`. Якщо "
"*ndigits* не передано в :meth:`!__round__`, усі ці методи повинні повертати "
"значення об’єкта, усічене до :class:`~numbers.Integral` (зазвичай :class:"
"`int`)."

msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""
"Вбудована функція :func:`int` повертається до :meth:`__trunc__`, якщо не "
"визначено ні :meth:`__int__`, ні :meth:`__index__`."

msgid "With Statement Context Managers"
msgstr "З менеджерами контексту операторів"

msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
":dfn:`context manager` — це об’єкт, який визначає контекст виконання, який "
"буде встановлено під час виконання оператора :keyword:`with`. Менеджер "
"контексту керує входом і виходом з потрібного контексту виконання для "
"виконання блоку коду. Менеджери контексту зазвичай викликаються за допомогою "
"оператора :keyword:`!with` (описаного в розділі :ref:`with`), але їх також "
"можна використовувати шляхом безпосереднього виклику їхніх методів."

msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Типове використання контекстних менеджерів включає збереження та відновлення "
"різних видів глобального стану, блокування та розблокування ресурсів, "
"закриття відкритих файлів тощо."

msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""
"Для отримання додаткової інформації про контекстні менеджери див. :ref:"
"`typecontextmanager`."

msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Введіть контекст виконання, пов’язаний із цим об’єктом. Оператор :keyword:"
"`with` прив’яже значення, що повертається цим методом, до цілей(ів), "
"указаних у пункті :keyword:`!as` оператора, якщо такий є."

msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Вийти з контексту виконання, пов’язаного з цим об’єктом. Параметри описують "
"виняток, який спричинив вихід із контексту. Якщо контекст вийшов без "
"винятку, усі три аргументи будуть :const:`None`."

msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Якщо надається виняток, і метод хоче придушити виняток (тобто запобігти його "
"розповсюдженню), він повинен повернути істинне значення. В іншому випадку "
"виняток буде оброблено звичайним чином після виходу з цього методу."

msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
"Зверніть увагу, що методи :meth:`__exit__` не повинні повторно викликати "
"переданий виняток; це відповідальність абонента."

msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - оператор \"з\"."

msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Специфікація, передумови та приклади оператора Python :keyword:`with`."

msgid "Customizing positional arguments in class pattern matching"
msgstr "Налаштування позиційних аргументів у відповідності шаблону класу"

msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"patterns, the class needs to define a *__match_args__* attribute."
msgstr ""
"Під час використання назви класу в шаблоні позиційні аргументи в шаблоні не "
"дозволені за замовчуванням, тобто ``case MyClass(x, y)`` зазвичай недійсний "
"без спеціальної підтримки в ``MyClass``. Щоб мати можливість використовувати "
"такі шаблони, клас повинен визначити атрибут *__match_args__*."

msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"Цій змінній класу можна призначити кортеж рядків. Коли цей клас "
"використовується в шаблоні класу з позиційними аргументами, кожен позиційний "
"аргумент буде перетворено в аргумент ключового слова, використовуючи "
"відповідне значення в *__match_args__* як ключове слово. Відсутність цього "
"атрибута еквівалентна встановленню для нього значення ``()``."

msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a :"
"exc:`TypeError`."
msgstr ""
"Наприклад, якщо ``MyClass.__match_args__`` є ``(\"left\", \"center\", "
"\"right\")``, це означає, що ``case MyClass(x, y)`` еквівалентний ``case "
"MyClass (ліворуч=x, центр=y)``. Зверніть увагу, що кількість аргументів у "
"шаблоні має бути меншою або дорівнювати кількості елементів у "
"*__match_args__*; якщо він більший, спроба збігу шаблону викличе :exc:"
"`TypeError`."

msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - зіставлення структурних шаблонів"

msgid "The specification for the Python ``match`` statement."
msgstr "Специфікація оператора ``match`` Python."

msgid "Special method lookup"
msgstr "Спеціальний метод пошуку"

msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"Для користувальницьких класів неявні виклики спеціальних методів гарантовано "
"працюють правильно, лише якщо вони визначені для типу об’єкта, а не в "
"словнику екземплярів об’єкта. Така поведінка є причиною того, що наступний "
"код викликає виняток::"

msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"Обґрунтування такої поведінки полягає в ряді спеціальних методів, таких як :"
"meth:`~object.__hash__` і :meth:`~object.__repr__`, які реалізуються всіма "
"об’єктами, включаючи об’єкти типу. Якби неявний пошук цих методів "
"використовував звичайний процес пошуку, вони зазнали б помилки під час "
"виклику в самому об’єкті типу:"

msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"Неправильна спроба викликати незв’язаний метод класу таким чином іноді "
"називається \"плутаниною метакласу\", і її можна уникнути шляхом обходу "
"екземпляра під час пошуку спеціальних методів:"

msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"Окрім обходу будь-яких атрибутів екземпляра в інтересах коректності, неявний "
"пошук спеціального методу зазвичай також обходить метод :meth:`~object."
"__getattribute__` навіть метакласу об’єкта::"

msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"Обхід механізму :meth:`~object.__getattribute__` у такий спосіб забезпечує "
"значні можливості для оптимізації швидкості в інтерпретаторі за рахунок "
"певної гнучкості в обробці спеціальних методів (спеціальний метод *має* бути "
"встановлений на об’єкті класу сам для того, щоб бути послідовно викликаним "
"інтерпретатором)."

msgid "Coroutines"
msgstr "Співпрограми"

msgid "Awaitable Objects"
msgstr "Очікувані об'єкти"

msgid ""
"An :term:`awaitable` object generally implements an :meth:`~object."
"__await__` method. :term:`Coroutine objects <coroutine>` returned from :"
"keyword:`async def` functions are awaitable."
msgstr ""
"Об’єкт :term:`awaitable` зазвичай реалізує метод :meth:`~object.__await__`. :"
"term:`Очікуються об’єкти співпрограми <coroutine>`, повернуті функціями :"
"keyword:`async def`."

msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`~object.__await__`."
msgstr ""

msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression."
msgstr ""
"Має повертати :term:`iterator`. Слід використовувати для реалізації "
"об’єктів :term:`awaitable`. Наприклад, :class:`asyncio.Future` реалізує цей "
"метод для сумісності з виразом :keyword:`await`."

msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` для додаткової інформації про очікувані об’єкти."

msgid "Coroutine Objects"
msgstr "Об’єкти співпрограми"

msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's :"
"attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines "
"should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Об’єкти співпрограми <coroutine>` є :term:`awaitable` об’єктами. "
"Виконання співпрограми можна контролювати викликом :meth:`~object.__await__` "
"і повторенням результату. Коли співпрограма завершує виконання та "
"повертається, ітератор викликає :exc:`StopIteration`, а атрибут винятку :"
"attr:`~StopIteration.value` зберігає значення, що повертається. Якщо "
"співпрограма викликає виключення, воно поширюється ітератором. Співпрограми "
"не повинні безпосередньо викликати необроблені винятки :exc:`StopIteration`."

msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"Співпрограми також мають наведені нижче методи, аналогічні генераторам "
"(див. :ref:`generator-methods`). Однак, на відміну від генераторів, "
"співпрограми безпосередньо не підтримують ітерацію."

msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""
"Це :exc:`RuntimeError`, якщо очікувати в співпрограмі більше одного разу."

msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`~object."
"__await__`.  If *value* is not ``None``, this method delegates to the :meth:"
"`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`__await__` return "
"value, described above."
msgstr ""
"Починає або відновлює виконання співпрограми. Якщо *value* дорівнює "
"``None``, це еквівалентно просуванню ітератора, який повертає :meth:`~object."
"__await__`. Якщо *value* не є ``None``, цей метод делегує метод :meth:"
"`~generator.send` ітератора, який викликав призупинення співпрограми. "
"Результат (повернене значення, :exc:`StopIteration` або інший виняток) такий "
"самий, як і під час ітерації по поверненому значенню :meth:`__await__`, "
"описаному вище."

msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`~object.__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"Викликає вказаний виняток у співпрограмі. Цей метод делегує метод :meth:"
"`~generator.throw` ітератора, який викликав призупинення співпрограми, якщо "
"він має такий метод. В іншому випадку виняток виникає в точці призупинення. "
"Результат (повернене значення, :exc:`StopIteration` або інший виняток) такий "
"самий, як і під час ітерації по поверненому значенню :meth:`~object."
"__await__`, описаному вище. Якщо виняток не перехоплюється співпрограмою, "
"він поширюється назад до абонента."

msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"Примушує співпрограму самоочиститися та завершити роботу. Якщо співпрограму "
"призупинено, цей метод спочатку делегує метод :meth:`~generator.close` "
"ітератора, який викликав призупинення співпрограми, якщо він має такий "
"метод. Потім він викликає :exc:`GeneratorExit` у точці призупинення, "
"змушуючи співпрограму негайно очищатися. Нарешті, співпрограма позначається "
"як завершена, навіть якщо вона ніколи не запускалася."

msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"Об’єкти співпрограми автоматично закриваються за допомогою описаного вище "
"процесу, коли їх збираються знищити."

msgid "Asynchronous Iterators"
msgstr "Асинхронні ітератори"

msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"*Асинхронний ітератор* може викликати асинхронний код у своєму методі "
"``__anext__``."

msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""
"Асинхронні ітератори можна використовувати в операторі :keyword:`async for`."

msgid "Must return an *asynchronous iterator* object."
msgstr "Має повертати об’єкт *асинхронного ітератора*."

msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Має повернути *waitable*, що призводить до наступного значення ітератора. "
"Має викликати помилку :exc:`StopAsyncIteration` після завершення ітерації."

msgid "An example of an asynchronous iterable object::"
msgstr "Приклад асинхронного ітерованого об'єкта::"

msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"До Python 3.7 :meth:`~object.__aiter__` міг повертати *waitable*, який "
"перетворювався на :term:`асинхронний ітератор <asynchronous iterator>`."

msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a :exc:"
"`TypeError` error."
msgstr ""
"Починаючи з Python 3.7, :meth:`~object.__aiter__` має повертати об’єкт "
"асинхронного ітератора. Повернення чогось іншого призведе до помилки :exc:"
"`TypeError`."

msgid "Asynchronous Context Managers"
msgstr "Менеджери асинхронного контексту"

msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*Асинхронний контекстний менеджер* — це *контекстний менеджер*, який може "
"призупинити виконання своїх методів ``__aenter__`` і ``__aexit__``."

msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Асинхронні менеджери контексту можна використовувати в операторі :keyword:"
"`async with`."

msgid ""
"Semantically similar to :meth:`__enter__`, the only difference being that it "
"must return an *awaitable*."
msgstr ""
"Семантично подібний до :meth:`__enter__`, єдина відмінність полягає в тому, "
"що він повинен повертати *waitable*."

msgid ""
"Semantically similar to :meth:`__exit__`, the only difference being that it "
"must return an *awaitable*."
msgstr ""
"Семантично подібний до :meth:`__exit__`, єдина відмінність полягає в тому, "
"що він повинен повертати *waitable*."

msgid "An example of an asynchronous context manager class::"
msgstr "Приклад класу диспетчера асинхронного контексту::"

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"У деяких випадках *можливо* змінити тип об’єкта за певних контрольованих "
"умов. Загалом це не дуже гарна ідея, оскільки це може призвести до дуже "
"дивної поведінки, якщо з ним поводитись неправильно."

msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, and :meth:`~object.__contains__` methods have special "
"handling for this; others will still raise a :exc:`TypeError`, but may do so "
"by relying on the behavior that ``None`` is not callable."
msgstr ""
"Методи :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__` і :meth:`~object.__contains__` мають спеціальну обробку для "
"цього; інші все одно викличуть :exc:`TypeError`, але можуть зробити це, "
"покладаючись на поведінку, що ``None`` не викликається."

msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns ``NotImplemented``.  Do not set the method to ``None`` if you "
"want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"\"Не підтримує\" тут означає, що клас не має такого методу, або метод "
"повертає ``NotImplemented``. Не встановлюйте для методу значення ``None``, "
"якщо ви хочете примусово повернутися до відображеного методу правого "
"операнда — це натомість матиме протилежний ефект явного *блокування* такого "
"резерву."

msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not called."
msgstr ""
"Для операндів одного типу передбачається, що якщо невідбитий метод, "
"наприклад :meth:`~object.__add__`, завершується помилкою, тоді загальна "
"операція не підтримується, тому відображений метод не викликається ."
