# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Vadim Kashirny, 2023
# Taras Kuzyo <kuzyo.taras@gmail.com>, 2023
# CrispCrow, 2023
# Dmytro Kazanzhy, 2024
# Yuliia Shevchenko, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-04 14:18+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Yuliia Shevchenko, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "Модель даних"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "Об'єкти, значення та типи"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`Об’єкти` — це абстракція Python для даних. Усі дані в програмі Python "
"представлені об’єктами або зв’язками між об’єктами. (У певному сенсі та "
"відповідно до моделі фон Неймана \"комп’ютера зі збереженою програмою\" код "
"також представлений об’єктами.)"

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The :keyword:`is` operator compares the identity of two "
"objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "Для CPython ``id(x)`` — це адреса пам’яті, де зберігається ``x``."

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects"
" of that type.  The :func:`type` function returns an object's type (which is"
" an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"Тип об’єкта визначає операції, які об’єкт підтримує (наприклад, \"чи має він"
" довжину?\"), а також визначає можливі значення для об’єктів цього типу. "
"Функція :func:`type` повертає тип об’єкта (який сам є об’єктом). Як і його "
"ідентифікатор, :dfn:`type` об’єкта також не змінюється. [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is"
" more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"*Значення* деяких об'єктів може змінюватися. Об'єкти, чиє значення може "
"змінюватися, називаються *змінними*; об'єкти, значення яких не змінюються "
"після їх створення, називаються *незмінними*. (Значення незмінного об’єкта-"
"контейнера, що містить посилання на змінний об’єкт, може змінюватися, коли "
"змінюється значення останнього; однак контейнер усе ще вважається незмінним,"
" оскільки набір об’єктів, який він містить, не можна змінити. Таким чином, "
"незмінність не є строго те саме, що має незмінне значення, воно більш "
"тонке.) Змінність об'єкта визначається його типом; наприклад, числа, рядки "
"та кортежі незмінні, тоді як словники та списки змінні."

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Об'єкти ніколи не знищуються явно; однак, коли вони стають недоступними, "
"вони можуть бути зібрані сміттям. Реалізації дозволено відкладати збирання "
"сміття або взагалі опускати його --- це питання якості реалізації, як "
"реалізовано збирання сміття, доки не збираються об’єкти, які все ще "
"доступні."

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"Наразі CPython використовує схему підрахунку посилань із (необов’язковим) "
"відкладеним виявленням циклічно пов’язаного сміття, яка збирає більшість "
"об’єктів, щойно вони стають недоступними, але не гарантовано збирає сміття, "
"що містить циклічні посилання. Перегляньте документацію модуля :mod:`gc` для"
" отримання інформації про керування збиранням циклічного сміття. Інші "
"реалізації діють інакше, і CPython може змінитися. Не покладайтеся на "
"негайну фіналізацію об’єктів, коли вони стають недоступними (тому ви завжди "
"повинні явно закривати файли)."

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a :keyword:`try`...\\ :keyword:`except` statement"
" may keep objects alive."
msgstr ""

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files"
" or windows.  It is understood that these resources are freed when the "
"object is garbage-collected, but since garbage collection is not guaranteed "
"to happen, such objects also provide an explicit way to release the external"
" resource, usually a :meth:`!close` method. Programs are strongly "
"recommended to explicitly close such objects.  The :keyword:`try`...\\ "
":keyword:`finally` statement and the :keyword:`with` statement provide "
"convenient ways to do this."
msgstr ""

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk"
" about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Деякі об'єкти містять посилання на інші об'єкти; вони називаються "
"*контейнерами*. Прикладами контейнерів є кортежі, списки та словники. "
"Посилання є частиною значення контейнера. У більшості випадків, коли ми "
"говоримо про значення контейнера, ми маємо на увазі значення, а не "
"ідентифікацію об’єктів, що містяться; однак, коли ми говоримо про мінливість"
" контейнера, мається на увазі лише ідентичність об’єктів, які безпосередньо "
"містяться. Отже, якщо незмінний контейнер (наприклад, кортеж) містить "
"посилання на змінний об’єкт, його значення змінюється, якщо змінюється цей "
"змінний об’єкт."

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed. For example, after ``a = 1; b = 1``, *a* and *b* may or may not "
"refer to the same object with the value one, depending on the "
"implementation. This is because :class:`int` is an immutable type, so the "
"reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be "
"aware of when making use of object identity tests. However, after ``c = []; "
"d = []``, *c* and *d* are guaranteed to refer to two different, unique, "
"newly created empty lists. (Note that ``e = f = []`` assigns the *same* "
"object to both *e* and *f*.)"
msgstr ""

#: ../../reference/datamodel.rst:124
msgid "The standard type hierarchy"
msgstr "Стандартна ієрархія типів"

#: ../../reference/datamodel.rst:133
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the"
" type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Нижче наведено список типів, вбудованих у Python. Модулі розширення "
"(написані мовами C, Java або іншими мовами, залежно від реалізації) можуть "
"визначати додаткові типи. Майбутні версії Python можуть додавати типи до "
"ієрархії типів (наприклад, раціональні числа, ефективно збережені масиви "
"цілих чисел тощо), хоча такі доповнення часто надаватимуться через "
"стандартну бібліотеку."

#: ../../reference/datamodel.rst:144
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation"
" and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Деякі з наведених нижче описів типів містять абзац із переліком "
"\"спеціальних атрибутів\". Це атрибути, які надають доступ до реалізації і "
"не призначені для загального використання. У майбутньому їх визначення може "
"змінитися."

#: ../../reference/datamodel.rst:150 ../../reference/datamodel.rst:152
msgid "None"
msgstr "Жодного"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from"
" functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Цей тип має єдине значення. Існує єдиний об’єкт із таким значенням. Доступ "
"до цього об’єкта здійснюється через вбудоване ім’я ``None``. Він "
"використовується для позначення відсутності значення в багатьох ситуаціях, "
"наприклад, його повертають функції, які явно нічого не повертають. Його "
"значення істинності є хибним."

#: ../../reference/datamodel.rst:161 ../../reference/datamodel.rst:163
msgid "NotImplemented"
msgstr "Не впроваджений"

#: ../../reference/datamodel.rst:165
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`. "
"Numeric methods and rich comparison methods should return this value if they"
" do not implement the operation for the operands provided.  (The interpreter"
" will then try the reflected operation, or some other fallback, depending on"
" the operator.)  It should not be evaluated in a boolean context."
msgstr ""

#: ../../reference/datamodel.rst:172
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""
"Перегляньте :ref:`implementing-the-arithmetic-operations` для отримання "
"додаткової інформації."

#: ../../reference/datamodel.rst:176
msgid ""
"Evaluating :data:`NotImplemented` in a boolean context is deprecated. While "
"it currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It"
" will raise a :exc:`TypeError` in a future version of Python."
msgstr ""

#: ../../reference/datamodel.rst:183 ../../reference/datamodel.rst:184
msgid "Ellipsis"
msgstr "Еліпсис"

#: ../../reference/datamodel.rst:188
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Цей тип має єдине значення. Існує єдиний об’єкт із таким значенням. Доступ "
"до цього об’єкта здійснюється за допомогою літералу ``...`` або вбудованої "
"назви ``Ellipsis``. Його істинна цінність є істинною."

#: ../../reference/datamodel.rst:194
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:198
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable;"
" once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Вони створюються за допомогою числових літералів і повертаються як "
"результати арифметичними операторами та арифметичними вбудованими функціями."
" Числові об'єкти незмінні; після створення їхня цінність ніколи не "
"змінюється. Числа Python, звичайно, тісно пов’язані з математичними числами,"
" але підлягають обмеженням числового представлення в комп’ютерах."

#: ../../reference/datamodel.rst:204
msgid ""
"The string representations of the numeric classes, computed by "
":meth:`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
"Рядкові представлення числових класів, обчислені за допомогою "
":meth:`~object.__repr__` і :meth:`~object.__str__`, мають такі властивості:"

#: ../../reference/datamodel.rst:208
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"Це дійсні числові літерали, які, коли їх передають конструктору класу, "
"створюють об’єкт, що має значення вихідного числа."

#: ../../reference/datamodel.rst:212
msgid "The representation is in base 10, when possible."
msgstr "Представлення в базі 10, коли це можливо."

#: ../../reference/datamodel.rst:214
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""
"Початкові нулі, можливо, за винятком одного нуля перед десятковою комою, не "
"показані."

#: ../../reference/datamodel.rst:217
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""
"Кінцеві нулі, можливо, за винятком одного нуля після коми, не "
"відображаються."

#: ../../reference/datamodel.rst:220
msgid "A sign is shown only when the number is negative."
msgstr "Знак відображається лише тоді, коли число від’ємне."

#: ../../reference/datamodel.rst:222
msgid ""
"Python distinguishes between integers, floating-point numbers, and complex "
"numbers:"
msgstr ""

#: ../../reference/datamodel.rst:227
msgid ":class:`numbers.Integral`"
msgstr ":class:`числа.Інтеграл`"

#: ../../reference/datamodel.rst:231
msgid ""
"These represent elements from the mathematical set of integers (positive and"
" negative)."
msgstr ""
"Вони представляють елементи з математичного набору цілих чисел (додатних і "
"від’ємних)."

#: ../../reference/datamodel.rst:237
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"Правила подання цілих чисел мають на меті дати найбільш змістовну "
"інтерпретацію операцій зсуву та маски, що включають від’ємні цілі числа."

#: ../../reference/datamodel.rst:240
msgid "There are two types of integers:"
msgstr "Є два типи цілих чисел:"

#: ../../reference/datamodel.rst:242
msgid "Integers (:class:`int`)"
msgstr "Цілі числа (:class:`int`)"

#: ../../reference/datamodel.rst:243
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Вони представляють числа в необмеженому діапазоні, що залежить лише від "
"доступної (віртуальної) пам’яті. Для цілей операцій зсуву та маски "
"передбачається двійкове представлення, а від’ємні числа представлені у "
"варіанті доповнення до 2, що створює ілюзію нескінченного рядка знакових "
"бітів, що тягнеться вліво."

#: ../../reference/datamodel.rst:249
msgid "Booleans (:class:`bool`)"
msgstr "Логічні значення (:class:`bool`)"

#: ../../reference/datamodel.rst:255
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects."
" The Boolean type is a subtype of the integer type, and Boolean values "
"behave like the values 0 and 1, respectively, in almost all contexts, the "
"exception being that when converted to a string, the strings ``\"False\"`` "
"or ``\"True\"`` are returned, respectively."
msgstr ""
"Вони представляють істинні значення False і True. Два об’єкти, що "
"представляють значення ``False`` і ``True``, є єдиними логічними об’єктами. "
"Логічний тип є підтипом цілочисельного типу, а логічні значення поводяться "
"як значення 0 і 1 відповідно майже в усіх контекстах, за винятком того, що "
"при перетворенні на рядок рядки ``\"False\"`` або ``\"True\"`` повертаються "
"відповідно."

#: ../../reference/datamodel.rst:263
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:271
msgid ""
"These represent machine-level double precision floating-point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does"
" not support single-precision floating-point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to"
" complicate the language with two kinds of floating-point numbers."
msgstr ""

#: ../../reference/datamodel.rst:281
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:287
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating-point numbers.  The same caveats apply as for floating-point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""

#: ../../reference/datamodel.rst:294
msgid "Sequences"
msgstr "Послідовності"

#: ../../reference/datamodel.rst:303
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some "
"sequences, including built-in sequences, interpret negative subscripts by "
"adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, the "
"second to last item of sequence a with length ``n``."
msgstr ""

#: ../../reference/datamodel.rst:313
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type. The comment above about negative indexes also "
"applies to negative slice positions."
msgstr ""

#: ../../reference/datamodel.rst:318
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Деякі послідовності також підтримують \"розширене нарізання\" з третім "
"параметром \"кроку\": ``a[i:j:k]`` вибирає всі елементи *a* з індексом *x*, "
"де ``x = i + n*k ``, *n* ``>=`` ``0`` і *i* ``<=`` *x* ``<`` *j*."

#: ../../reference/datamodel.rst:322
msgid "Sequences are distinguished according to their mutability:"
msgstr "Послідовності розрізняють відповідно до їх мінливості:"

#: ../../reference/datamodel.rst:326
msgid "Immutable sequences"
msgstr "Незмінні послідовності"

#: ../../reference/datamodel.rst:332
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may"
" be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Об’єкт типу незмінної послідовності не може змінюватися після створення. "
"(Якщо об’єкт містить посилання на інші об’єкти, ці інші об’єкти можуть бути "
"змінними та змінюватися; однак набір об’єктів, на який безпосередньо "
"посилається незмінний об’єкт, не може змінитися.)"

#: ../../reference/datamodel.rst:337
msgid "The following types are immutable sequences:"
msgstr "Наступні типи є незмінними послідовностями:"

#: ../../reference/datamodel.rst:342
msgid "Strings"
msgstr "рядки"

#: ../../reference/datamodel.rst:350
msgid ""
"A string is a sequence of values that represent Unicode code points. All the"
" code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form"
" to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string object."
" :meth:`str.encode` can be used to convert a :class:`str` to :class:`bytes` "
"using the given text encoding, and :meth:`bytes.decode` can be used to "
"achieve the opposite."
msgstr ""

#: ../../reference/datamodel.rst:362
msgid "Tuples"
msgstr "Кортежі"

#: ../../reference/datamodel.rst:368
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Елементи кортежу є довільними об’єктами Python. Кортежі з двох або більше "
"елементів утворюються списками виразів, розділених комами. Кортеж з одного "
"елемента (\"синглтон\") може бути сформований шляхом додавання коми до "
"виразу (вираз сам по собі не створює кортеж, оскільки дужки повинні "
"використовуватися для групування виразів). Порожній кортеж може бути "
"утворений пустою парою круглих дужок."

#: ../../reference/datamodel.rst:375
msgid "Bytes"
msgstr "Байти"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to create"
" bytes objects.  Also, bytes objects can be decoded to strings via the "
":meth:`~bytes.decode` method."
msgstr ""

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "Змінні послідовності"

#: ../../reference/datamodel.rst:395
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and "
":keyword:`del` (delete) statements."
msgstr ""
"Змінні послідовності можна змінювати після їх створення. Нотації підписки та"
" зрізу можна використовувати як ціль операторів призначення та "
":keyword:`del` (видалити)."

#: ../../reference/datamodel.rst:403
msgid ""
"The :mod:`collections` and :mod:`array` module provide additional examples "
"of mutable sequence types."
msgstr ""

#: ../../reference/datamodel.rst:406
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "На даний момент існує два типи внутрішніх змінних послідовностей:"

#: ../../reference/datamodel.rst:408
msgid "Lists"
msgstr "списки"

#: ../../reference/datamodel.rst:411
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that"
" there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Елементи списку є довільними об’єктами Python. Списки формуються шляхом "
"розміщення списку виразів, розділених комами, у квадратних дужках. "
"(Зауважте, що для формування списків довжиною 0 або 1 не потрібні особливі "
"випадки.)"

#: ../../reference/datamodel.rst:415
msgid "Byte Arrays"
msgstr "Байтові масиви"

#: ../../reference/datamodel.rst:418
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Об’єкт bytearray є змінним масивом. Вони створюються за допомогою "
"вбудованого конструктора :func:`bytearray`. Крім того, що байтові масиви є "
"змінними (і, отже, нехешованими), байтові масиви забезпечують той самий "
"інтерфейс і функціональність, що й незмінні об’єкти :class:`bytes`."

#: ../../reference/datamodel.rst:425
msgid "Set types"
msgstr "Встановити типи"

#: ../../reference/datamodel.rst:431
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated"
" over, and the built-in function :func:`len` returns the number of items in "
"a set. Common uses for sets are fast membership testing, removing duplicates"
" from a sequence, and computing mathematical operations such as "
"intersection, union, difference, and symmetric difference."
msgstr ""
"Вони представляють невпорядковані, кінцеві набори унікальних, незмінних "
"об’єктів. Таким чином, вони не можуть бути індексовані жодним індексом. "
"Однак їх можна повторювати, а вбудована функція :func:`len` повертає "
"кількість елементів у наборі. Набори зазвичай використовують для швидкого "
"тестування членства, видалення дублікатів із послідовності та обчислення "
"математичних операцій, таких як перетин, об’єднання, різниця та симетрична "
"різниця."

#: ../../reference/datamodel.rst:438
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two"
" numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"Для елементів набору застосовуються ті ж правила незмінності, що й для "
"ключів словника. Зауважте, що числові типи підкоряються звичайним правилам "
"числового порівняння: якщо два числа порівнюються (наприклад, ``1`` і "
"``1.0``), лише одне з них може міститися в наборі."

#: ../../reference/datamodel.rst:443
msgid "There are currently two intrinsic set types:"
msgstr "Наразі існує два типи внутрішніх наборів:"

#: ../../reference/datamodel.rst:446
msgid "Sets"
msgstr "Набори"

#: ../../reference/datamodel.rst:449
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as "
":meth:`~set.add`."
msgstr ""
"Вони представляють змінний набір. Вони створюються за допомогою вбудованого "
"конструктора :func:`set` і можуть бути змінені згодом кількома методами, "
"наприклад :meth:`~set.add`."

#: ../../reference/datamodel.rst:454
msgid "Frozen sets"
msgstr "Заморожені набори"

#: ../../reference/datamodel.rst:457
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or as a"
" dictionary key."
msgstr ""
"Вони являють собою незмінний набір. Вони створюються за допомогою "
"вбудованого конструктора :func:`frozenset`. Оскільки заморожений набір є "
"незмінним і :term:`hashable`, його можна знову використовувати як елемент "
"іншого набору або як ключ словника."

#: ../../reference/datamodel.rst:464
msgid "Mappings"
msgstr "Відображення"

#: ../../reference/datamodel.rst:471
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Вони представляють кінцеві набори об'єктів, індексованих довільними наборами"
" індексів. Підрядкова нотація ``a[k]`` вибирає елемент з індексом ``k`` із "
"відображення ``a``; це можна використовувати у виразах і як ціль присвоєння "
"або операторів :keyword:`del`. Вбудована функція :func:`len` повертає "
"кількість елементів у відображенні."

#: ../../reference/datamodel.rst:477
msgid "There is currently a single intrinsic mapping type:"
msgstr "Наразі існує єдиний внутрішній тип відображення:"

#: ../../reference/datamodel.rst:481
msgid "Dictionaries"
msgstr "словники"

#: ../../reference/datamodel.rst:485
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Вони представляють кінцеві набори об'єктів, індексованих майже довільними "
"значеннями. Єдиними типами значень, неприйнятними як ключі, є значення, що "
"містять списки, словники чи інші змінні типи, які порівнюються за значенням,"
" а не за ідентичністю об’єкта, тому що для ефективної реалізації словників "
"необхідно, щоб хеш-значення ключа залишалося постійним. Числові типи, що "
"використовуються для ключів, підкоряються звичайним правилам для числового "
"порівняння: якщо два числа порівнюються (наприклад, ``1`` і ``1.0``), тоді "
"їх можна використовувати як взаємозамінні для індексування тієї самої статті"
" словника."

#: ../../reference/datamodel.rst:494
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in"
" the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Словники зберігають порядок вставки, тобто ключі створюватимуться в тому "
"самому порядку, у якому вони були послідовно додані до словника. Заміна "
"існуючого ключа не змінює порядок, однак видалення ключа та його повторне "
"вставлення додасть його в кінець замість збереження старого місця."

#: ../../reference/datamodel.rst:499
msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see "
"section :ref:`dict`)."
msgstr ""

#: ../../reference/datamodel.rst:506
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Модулі розширення :mod:`dbm.ndbm` і :mod:`dbm.gnu` надають додаткові "
"приклади типів зіставлення, як і модуль :mod:`collections`."

#: ../../reference/datamodel.rst:510
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an"
" implementation detail at that time rather than a language guarantee."
msgstr ""
"Словники не зберігали порядок вставки у версіях Python до 3.6. У CPython 3.6"
" порядок вставки було збережено, але в той час це вважалося деталлю "
"реалізації, а не гарантією мови."

#: ../../reference/datamodel.rst:517
msgid "Callable types"
msgstr "Викличні типи"

#: ../../reference/datamodel.rst:525
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr ""
"Це типи, до яких можна застосувати операцію виклику функції (див. розділ "
":ref:`calls`):"

#: ../../reference/datamodel.rst:532
msgid "User-defined functions"
msgstr "Визначені користувачем функції"

#: ../../reference/datamodel.rst:539
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Визначений користувачем об’єкт функції створюється визначенням функції (див."
" розділ :ref:`function`). Її слід викликати зі списком аргументів, що "
"містить таку саму кількість елементів, як і формальний список параметрів "
"функції."

#: ../../reference/datamodel.rst:545 ../../reference/datamodel.rst:1395
#: ../../reference/datamodel.rst:1596
msgid "Special read-only attributes"
msgstr ""

#: ../../reference/datamodel.rst:555 ../../reference/datamodel.rst:590
#: ../../reference/datamodel.rst:1170
msgid "Attribute"
msgstr "Атрибут"

#: ../../reference/datamodel.rst:556 ../../reference/datamodel.rst:591
#: ../../reference/datamodel.rst:1171
msgid "Meaning"
msgstr "Значення"

#: ../../reference/datamodel.rst:559
msgid ""
"A reference to the :class:`dictionary <dict>` that holds the function's "
":ref:`global variables <naming>` -- the global namespace of the module in "
"which the function was defined."
msgstr ""

#: ../../reference/datamodel.rst:564
msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the names "
"specified in the :attr:`~codeobject.co_freevars` attribute of the function's"
" :attr:`code object <function.__code__>`."
msgstr ""

#: ../../reference/datamodel.rst:568
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Об’єкт клітинки має атрибут ``cell_contents``. Це можна використовувати для "
"отримання значення комірки, а також для встановлення значення."

#: ../../reference/datamodel.rst:572 ../../reference/datamodel.rst:1638
msgid "Special writable attributes"
msgstr ""

#: ../../reference/datamodel.rst:585
msgid "Most of these attributes check the type of the assigned value:"
msgstr ""

#: ../../reference/datamodel.rst:594
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""

#: ../../reference/datamodel.rst:597
msgid ""
"The function's name. See also: :attr:`__name__ attributes "
"<definition.__name__>`."
msgstr ""

#: ../../reference/datamodel.rst:601
msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""

#: ../../reference/datamodel.rst:607
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"Назва модуля, у якому була визначена функція, або \"Немає\", якщо вона "
"недоступна."

#: ../../reference/datamodel.rst:611
msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a default "
"value."
msgstr ""

#: ../../reference/datamodel.rst:616
msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr ""

#: ../../reference/datamodel.rst:620
msgid ""
"The namespace supporting arbitrary function attributes. See also: "
":attr:`__dict__ attributes <object.__dict__>`."
msgstr ""

#: ../../reference/datamodel.rst:624
msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See also: "
":ref:`annotations-howto`."
msgstr ""

#: ../../reference/datamodel.rst:631
msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-only "
":term:`parameters <parameter>`."
msgstr ""

#: ../../reference/datamodel.rst:635
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a "
":ref:`generic function <generic-functions>`."
msgstr ""

#: ../../reference/datamodel.rst:640
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes."
msgstr ""

#: ../../reference/datamodel.rst:646
msgid ""
"CPython's current implementation only supports function attributes on user-"
"defined functions. Function attributes on :ref:`built-in functions <builtin-"
"functions>` may be supported in the future."
msgstr ""

#: ../../reference/datamodel.rst:651
msgid ""
"Additional information about a function's definition can be retrieved from "
"its :ref:`code object <code-objects>` (accessible via the "
":attr:`~function.__code__` attribute)."
msgstr ""

#: ../../reference/datamodel.rst:659
msgid "Instance methods"
msgstr "Методи екземплярів"

#: ../../reference/datamodel.rst:666
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Об’єкт методу екземпляра поєднує в собі клас, екземпляр класу та будь-який "
"об’єкт, що викликається (зазвичай це функція, визначена користувачем)."

#: ../../reference/datamodel.rst:676 ../../reference/datamodel.rst:1734
msgid "Special read-only attributes:"
msgstr ""

#: ../../reference/datamodel.rst:681
msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr ""

#: ../../reference/datamodel.rst:685
msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr ""

#: ../../reference/datamodel.rst:688
msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ "
"<function.__doc__>`). A :class:`string <str>` if the original function had a"
" docstring, else ``None``."
msgstr ""

#: ../../reference/datamodel.rst:694
msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ "
"<function.__name__>`)"
msgstr ""

#: ../../reference/datamodel.rst:698
msgid ""
"The name of the module the method was defined in, or ``None`` if "
"unavailable."
msgstr ""

#: ../../reference/datamodel.rst:701
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr ""

#: ../../reference/datamodel.rst:704
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined :ref:`function object <user-defined-funcs>` or a "
":class:`classmethod` object."
msgstr ""

#: ../../reference/datamodel.rst:711
msgid ""
"When an instance method object is created by retrieving a user-defined "
":ref:`function object <user-defined-funcs>` from a class via one of its "
"instances, its :attr:`~method.__self__` attribute is the instance, and the "
"method object is said to be *bound*.  The new method's "
":attr:`~method.__func__` attribute is the original function object."
msgstr ""

#: ../../reference/datamodel.rst:717
msgid ""
"When an instance method object is created by retrieving a "
":class:`classmethod` object from a class or instance, its "
":attr:`~method.__self__` attribute is the class itself, and its "
":attr:`~method.__func__` attribute is the function object underlying the "
"class method."
msgstr ""

#: ../../reference/datamodel.rst:722
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`~method.__func__`) is called, inserting the class instance "
"(:attr:`~method.__self__`) in front of the argument list.  For instance, "
"when :class:`!C` is a class which contains a definition for a function "
":meth:`!f`, and ``x`` is an instance of :class:`!C`, calling ``x.f(1)`` is "
"equivalent to calling ``C.f(x, 1)``."
msgstr ""

#: ../../reference/datamodel.rst:729
msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or "
"``C.f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying"
" function."
msgstr ""

#: ../../reference/datamodel.rst:734
msgid ""
"It is important to note that user-defined functions which are attributes of "
"a class instance are not converted to bound methods; this *only* happens "
"when the function is an attribute of the class."
msgstr ""

#: ../../reference/datamodel.rst:741
msgid "Generator functions"
msgstr "Функції генератора"

#: ../../reference/datamodel.rst:747
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section "
":ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's "
":meth:`iterator.__next__` method will cause the function to execute until it"
" provides a value using the :keyword:`!yield` statement.  When the function "
"executes a :keyword:`return` statement or falls off the end, a "
":exc:`StopIteration` exception is raised and the iterator will have reached "
"the end of the set of values to be returned."
msgstr ""
"Функція або метод, який використовує оператор :keyword:`yield` (див. розділ "
":ref:`yield`), називається :dfn:`функцією-генератором`. Під час виклику така"
" функція завжди повертає об’єкт :term:`iterator`, який можна використовувати"
" для виконання тіла функції: виклик методу :meth:`iterator.__next__` "
"ітератора призведе до виконання функції, доки вона не надасть значення за "
"допомогою оператора :keyword:`!yield`. Коли функція виконує оператор "
":keyword:`return` або виходить з кінця, виникає виняток "
":exc:`StopIteration`, і ітератор досягне кінця набору значень, які потрібно "
"повернути."

#: ../../reference/datamodel.rst:759
msgid "Coroutine functions"
msgstr "Функції співпрограми"

#: ../../reference/datamodel.rst:764
msgid ""
"A function or method which is defined using :keyword:`async def` is called a"
" :dfn:`coroutine function`.  Such a function, when called, returns a "
":term:`coroutine` object.  It may contain :keyword:`await` expressions, as "
"well as :keyword:`async with` and :keyword:`async for` statements. See also "
"the :ref:`coroutine-objects` section."
msgstr ""
"Функція або метод, визначений за допомогою :keyword:`async def`, називається"
" :dfn:`coroutine function`. Така функція під час виклику повертає об’єкт "
":term:`coroutine`. Він може містити вирази :keyword:`await`, а також "
"оператори :keyword:`async with` і :keyword:`async for`. Дивіться також "
"розділ :ref:`coroutine-objects`."

#: ../../reference/datamodel.rst:772
msgid "Asynchronous generator functions"
msgstr "Функції асинхронного генератора"

#: ../../reference/datamodel.rst:778
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator"
" function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"Функція або метод, визначений за допомогою :keyword:`async def` і який "
"використовує оператор :keyword:`yield`, називається :dfn:`функцією "
"асинхронного генератора`. Під час виклику така функція повертає об’єкт "
":term:`asynchronous iterator`, який можна використовувати в операторі "
":keyword:`async for` для виконання тіла функції."

#: ../../reference/datamodel.rst:784
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ "
"<object.__anext__>` method will return an :term:`awaitable` which when "
"awaited will execute until it provides a value using the :keyword:`yield` "
"expression.  When the function executes an empty :keyword:`return` statement"
" or falls off the end, a :exc:`StopAsyncIteration` exception is raised and "
"the asynchronous iterator will have reached the end of the set of values to "
"be yielded."
msgstr ""
"Виклик методу :meth:`aiterator.__anext__ <object.__anext__>` асинхронного "
"ітератора поверне :term:`awaitable`, який у разі очікування "
"виконуватиметься, доки не надасть значення за допомогою виразу "
":keyword:`yield`. Коли функція виконує порожній оператор :keyword:`return` "
"або виходить за межі кінця, виникає виняткова ситуація "
":exc:`StopAsyncIteration`, і асинхронний ітератор досягне кінця набору "
"значень, які потрібно отримати."

#: ../../reference/datamodel.rst:797
msgid "Built-in functions"
msgstr "Вбудовані функції"

#: ../../reference/datamodel.rst:804
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""

#: ../../reference/datamodel.rst:809
msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr ""

#: ../../reference/datamodel.rst:811
msgid ""
":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ""

#: ../../reference/datamodel.rst:812
msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ""

#: ../../reference/datamodel.rst:813
msgid ""
":attr:`!__module__` is the name of the module the function was defined in or"
" ``None`` if unavailable. See :attr:`function.__module__`."
msgstr ""

#: ../../reference/datamodel.rst:821
msgid "Built-in methods"
msgstr "Вбудовані методи"

#: ../../reference/datamodel.rst:828
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra argument."
"  An example of a built-in method is ``alist.append()``, assuming *alist* is"
" a list object. In this case, the special read-only attribute "
":attr:`!__self__` is set to the object denoted by *alist*. (The attribute "
"has the same semantics as it does with :attr:`other instance methods "
"<method.__self__>`.)"
msgstr ""

#: ../../reference/datamodel.rst:838
msgid "Classes"
msgstr "Заняття"

#: ../../reference/datamodel.rst:840
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to "
":meth:`!__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""

#: ../../reference/datamodel.rst:848
msgid "Class Instances"
msgstr "Екземпляри класу"

#: ../../reference/datamodel.rst:850
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`~object.__call__` method in their class."
msgstr ""
"Екземпляри довільних класів можна зробити викликаними, визначивши метод "
":meth:`~object.__call__` у їхньому класі."

#: ../../reference/datamodel.rst:857
msgid "Modules"
msgstr "Модулі"

#: ../../reference/datamodel.rst:863
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement, or by calling functions such as "
":func:`importlib.import_module` and built-in :func:`__import__`.  A module "
"object has a namespace implemented by a :class:`dictionary <dict>` object "
"(this is the dictionary referenced by the :attr:`~function.__globals__` "
"attribute of functions defined in the module).  Attribute references are "
"translated to lookups in this dictionary, e.g., ``m.x`` is equivalent to "
"``m.__dict__[\"x\"]``. A module object does not contain the code object used"
" to initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr ""

#: ../../reference/datamodel.rst:876
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"Призначення атрибутів оновлює словник простору імен модуля, наприклад, ``m.x"
" = 1`` еквівалентно ``m.__dict__[\"x\"] = 1``."

#: ../../reference/datamodel.rst:894
msgid "Import-related attributes on module objects"
msgstr ""

#: ../../reference/datamodel.rst:896
msgid ""
"Module objects have the following attributes that relate to the :ref:`import"
" system <importsystem>`. When a module is created using the machinery "
"associated with the import system, these attributes are filled in based on "
"the module's :term:`spec <module spec>`, before the :term:`loader` executes "
"and loads the module."
msgstr ""

#: ../../reference/datamodel.rst:902
msgid ""
"To create a module dynamically rather than using the import system, it's "
"recommended to use :func:`importlib.util.module_from_spec`, which will set "
"the various import-controlled attributes to appropriate values. It's also "
"possible to use the :class:`types.ModuleType` constructor to create modules "
"directly, but this technique is more error-prone, as most attributes must be"
" manually set on the module object after it has been created when using this"
" approach."
msgstr ""

#: ../../reference/datamodel.rst:912
msgid ""
"With the exception of :attr:`~module.__name__`, it is **strongly** "
"recommended that you rely on :attr:`~module.__spec__` and its attributes "
"instead of any of the other individual attributes listed in this subsection."
" Note that updating an attribute on :attr:`!__spec__` will not update the "
"corresponding attribute on the module itself:"
msgstr ""

#: ../../reference/datamodel.rst:918
msgid ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"
msgstr ""

#: ../../reference/datamodel.rst:932
msgid ""
"The name used to uniquely identify the module in the import system. For a "
"directly executed module, this will be set to ``\"__main__\"``."
msgstr ""

#: ../../reference/datamodel.rst:935
msgid ""
"This attribute must be set to the fully qualified name of the module. It is "
"expected to match the value of :attr:`module.__spec__.name "
"<importlib.machinery.ModuleSpec.name>`."
msgstr ""

#: ../../reference/datamodel.rst:941
msgid "A record of the module's import-system-related state."
msgstr ""

#: ../../reference/datamodel.rst:943
msgid ""
"Set to the :class:`module spec <importlib.machinery.ModuleSpec>` that was "
"used when importing the module. See :ref:`module-specs` for more details."
msgstr ""

#: ../../reference/datamodel.rst:950
msgid "The :term:`package` a module belongs to."
msgstr ""

#: ../../reference/datamodel.rst:952
msgid ""
"If the module is top-level (that is, not a part of any specific package) "
"then the attribute should be set to ``''`` (the empty string). Otherwise, it"
" should be set to the name of the module's package (which can be equal to "
":attr:`module.__name__` if the module itself is a package). See :pep:`366` "
"for further details."
msgstr ""

#: ../../reference/datamodel.rst:958
msgid ""
"This attribute is used instead of :attr:`~module.__name__` to calculate "
"explicit relative imports for main modules. It defaults to ``None`` for "
"modules created dynamically using the :class:`types.ModuleType` constructor;"
" use :func:`importlib.util.module_from_spec` instead to ensure the attribute"
" is set to a :class:`str`."
msgstr ""

#: ../../reference/datamodel.rst:964
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` instead of "
":attr:`!module.__package__`. :attr:`__package__` is now only used as a "
"fallback if :attr:`!__spec__.parent` is not set, and this fallback path is "
"deprecated."
msgstr ""

#: ../../reference/datamodel.rst:970 ../../reference/datamodel.rst:1011
msgid ""
"This attribute now defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor. Previously the attribute "
"was optional."
msgstr ""

#: ../../reference/datamodel.rst:975
msgid ""
"The value of :attr:`!__package__` is expected to be the same as "
":attr:`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. "
":attr:`__package__` is now only used as a fallback during import resolution "
"if :attr:`!__spec__.parent` is not defined."
msgstr ""

#: ../../reference/datamodel.rst:981
msgid ""
":exc:`ImportWarning` is raised if an import resolution falls back to "
":attr:`!__package__` instead of :attr:`__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>`."
msgstr ""

#: ../../reference/datamodel.rst:986
msgid ""
"Raise :exc:`DeprecationWarning` instead of :exc:`ImportWarning` when falling"
" back to :attr:`!__package__` during import resolution."
msgstr ""

#: ../../reference/datamodel.rst:990
msgid ""
":attr:`!__package__` will cease to be set or taken into consideration by the"
" import system or standard library."
msgstr ""

#: ../../reference/datamodel.rst:996
msgid ""
"The :term:`loader` object that the import machinery used to load the module."
msgstr ""

#: ../../reference/datamodel.rst:998
msgid ""
"This attribute is mostly useful for introspection, but can be used for "
"additional loader-specific functionality, for example getting data "
"associated with a loader."
msgstr ""

#: ../../reference/datamodel.rst:1002
msgid ""
":attr:`!__loader__` defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor; use "
":func:`importlib.util.module_from_spec` instead to ensure the attribute is "
"set to a :term:`loader` object."
msgstr ""

#: ../../reference/datamodel.rst:1007
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` instead of "
":attr:`!module.__loader__`."
msgstr ""

#: ../../reference/datamodel.rst:1016
msgid ""
"Setting :attr:`!__loader__` on a module while failing to set "
":attr:`!__spec__.loader` is deprecated. In Python 3.16, :attr:`!__loader__` "
"will cease to be set or taken into consideration by the import system or the"
" standard library."
msgstr ""

#: ../../reference/datamodel.rst:1024
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"where the package's submodules will be found. Non-package modules should not"
" have a :attr:`!__path__` attribute. See :ref:`package-path-rules` for more "
"details."
msgstr ""

#: ../../reference/datamodel.rst:1029
msgid ""
"It is **strongly** recommended that you use "
":attr:`module.__spec__.submodule_search_locations "
"<importlib.machinery.ModuleSpec.submodule_search_locations>` instead of "
":attr:`!module.__path__`."
msgstr ""

#: ../../reference/datamodel.rst:1036
msgid ""
":attr:`!__file__` and :attr:`!__cached__` are both optional attributes that "
"may or may not be set. Both attributes should be a :class:`str` when they "
"are available."
msgstr ""

#: ../../reference/datamodel.rst:1040
msgid ""
":attr:`!__file__` indicates the pathname of the file from which the module "
"was loaded (if loaded from a file), or the pathname of the shared library "
"file for extension modules loaded dynamically from a shared library. It "
"might be missing for certain types of modules, such as C modules that are "
"statically linked into the interpreter, and the :ref:`import system "
"<importsystem>` may opt to leave it unset if it has no semantic meaning (for"
" example, a module loaded from a database)."
msgstr ""

#: ../../reference/datamodel.rst:1048
msgid ""
"If :attr:`!__file__` is set then the :attr:`!__cached__` attribute might "
"also be set,  which is the path to any compiled version of the code (for "
"example, a byte-compiled file). The file does not need to exist to set this "
"attribute; the path can simply point to where the compiled file *would* "
"exist (see :pep:`3147`)."
msgstr ""

#: ../../reference/datamodel.rst:1054
msgid ""
"Note that :attr:`!__cached__` may be set even if :attr:`!__file__` is not "
"set.  However, that scenario is quite atypical.  Ultimately, the "
":term:`loader` is what makes use of the module spec provided by the "
":term:`finder` (from which :attr:`!__file__` and :attr:`!__cached__` are "
"derived).  So if a loader can load from a cached module but otherwise does "
"not load from a file, that atypical scenario may be appropriate."
msgstr ""

#: ../../reference/datamodel.rst:1061
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` instead of "
":attr:`!module.__cached__`."
msgstr ""

#: ../../reference/datamodel.rst:1065
msgid ""
"Setting :attr:`!__cached__` on a module while failing to set "
":attr:`!__spec__.cached` is deprecated. In Python 3.15, :attr:`!__cached__` "
"will cease to be set or taken into consideration by the import system or "
"standard library."
msgstr ""

#: ../../reference/datamodel.rst:1072
msgid "Other writable attributes on module objects"
msgstr ""

#: ../../reference/datamodel.rst:1074
msgid ""
"As well as the import-related attributes listed above, module objects also "
"have the following writable attributes:"
msgstr ""

#: ../../reference/datamodel.rst:1079
msgid ""
"The module's documentation string, or ``None`` if unavailable. See also: "
":attr:`__doc__ attributes <definition.__doc__>`."
msgstr ""

#: ../../reference/datamodel.rst:1084
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with "
":attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"Словник, що містить :term:`анотації змінних <variable annotation>`, зібрані "
"під час виконання тіла модуля. Найкращі методи роботи з "
":attr:`__annotations__` див. :ref:`annotations-howto`."

#: ../../reference/datamodel.rst:1090
msgid "Module dictionaries"
msgstr ""

#: ../../reference/datamodel.rst:1092
msgid "Module objects also have the following special read-only attribute:"
msgstr ""

#: ../../reference/datamodel.rst:1097
msgid ""
"The module's namespace as a dictionary object. Uniquely among the attributes"
" listed here, :attr:`!__dict__` cannot be accessed as a global variable from"
" within a module; it can only be accessed as an attribute on module objects."
msgstr ""

#: ../../reference/datamodel.rst:1103
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary"
" will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"Через те, як CPython очищає словники модулів, словник модуля буде очищено, "
"коли модуль виходить із області видимості, навіть якщо в словнику все ще є "
"живі посилання. Щоб уникнути цього, скопіюйте словник або збережіть модуль, "
"використовуючи його словник безпосередньо."

#: ../../reference/datamodel.rst:1112
msgid "Custom classes"
msgstr "Спеціальні заняття"

#: ../../reference/datamodel.rst:1114
msgid ""
"Custom class types are typically created by class definitions (see section "
":ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, "
"e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the"
" base classes. This search of the base classes uses the C3 method resolution"
" order which behaves correctly even in the presence of 'diamond' inheritance"
" structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found at :ref:`python_2.3_mro`."
msgstr ""

#: ../../reference/datamodel.rst:1135
msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield a "
"class method object, it is transformed into an instance method object whose "
":attr:`~method.__self__` attribute is :class:`!C`. When it would yield a "
":class:`staticmethod` object, it is transformed into the object wrapped by "
"the static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""

#: ../../reference/datamodel.rst:1146
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"Призначення атрибутів класу оновлює словник класу, а не словник базового "
"класу."

#: ../../reference/datamodel.rst:1151
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Об’єкт класу можна викликати (див. вище), щоб створити екземпляр класу (див."
" нижче)."

#: ../../reference/datamodel.rst:1154 ../../reference/datamodel.rst:1301
msgid "Special attributes"
msgstr ""

#: ../../reference/datamodel.rst:1174
msgid ""
"The class's name. See also: :attr:`__name__ attributes "
"<definition.__name__>`."
msgstr ""

#: ../../reference/datamodel.rst:1178
msgid ""
"The class's :term:`qualified name`. See also: :attr:`__qualname__ attributes"
" <definition.__qualname__>`."
msgstr ""

#: ../../reference/datamodel.rst:1182
msgid "The name of the module in which the class was defined."
msgstr "Ім'я модуля, в якому було визначено клас."

#: ../../reference/datamodel.rst:1185
msgid ""
"A :class:`mapping proxy <types.MappingProxyType>` providing a read-only view"
" of the class's namespace. See also: :attr:`__dict__ attributes "
"<object.__dict__>`."
msgstr ""

#: ../../reference/datamodel.rst:1190
msgid ""
"A :class:`tuple` containing the class's bases. In most cases, for a class "
"defined as ``class X(A, B, C)``, ``X.__bases__`` will be exactly equal to "
"``(A, B, C)``."
msgstr ""

#: ../../reference/datamodel.rst:1195
msgid ""
"The class's documentation string, or ``None`` if undefined. Not inherited by"
" subclasses."
msgstr ""

#: ../../reference/datamodel.rst:1199
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution. For best practices on working with "
":attr:`!__annotations__`, please see :ref:`annotations-howto`."
msgstr ""

#: ../../reference/datamodel.rst:1206
msgid ""
"Accessing the :attr:`!__annotations__` attribute of a class object directly "
"may yield incorrect results in the presence of metaclasses. In addition, the"
" attribute may not exist for some classes. Use "
":func:`inspect.get_annotations` to retrieve class annotations safely."
msgstr ""

#: ../../reference/datamodel.rst:1213
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a "
":ref:`generic class <generic-classes>`."
msgstr ""

#: ../../reference/datamodel.rst:1219
msgid ""
"A :class:`tuple` containing names of attributes of this class which are "
"assigned through ``self.X`` from any function in its body."
msgstr ""

#: ../../reference/datamodel.rst:1225
msgid ""
"The line number of the first line of the class definition, including "
"decorators. Setting the :attr:`__module__` attribute removes the "
":attr:`!__firstlineno__` item from the type's dictionary."
msgstr ""

#: ../../reference/datamodel.rst:1233
msgid ""
"The :class:`tuple` of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""

#: ../../reference/datamodel.rst:1238
msgid "Special methods"
msgstr ""

#: ../../reference/datamodel.rst:1240
msgid ""
"In addition to the special attributes described above, all Python classes "
"also have the following two methods available:"
msgstr ""

#: ../../reference/datamodel.rst:1245
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~type.__mro__`."
msgstr ""

#: ../../reference/datamodel.rst:1251
msgid ""
"Each class keeps a list of weak references to its immediate subclasses. This"
" method returns a list of all those references still alive. The list is in "
"definition order. Example:"
msgstr ""

#: ../../reference/datamodel.rst:1255
msgid ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"
msgstr ""

#: ../../reference/datamodel.rst:1263
msgid "Class instances"
msgstr "Екземпляри класу"

#: ../../reference/datamodel.rst:1271
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`~method.__self__` attribute is the instance.  "
"Static method and class method objects are also transformed; see above under"
" \"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a "
":meth:`~object.__getattr__` method, that is called to satisfy the lookup."
msgstr ""

#: ../../reference/datamodel.rst:1287
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or "
":meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"Призначення та видалення атрибутів оновлюють словник екземпляра, а не "
"словник класу. Якщо клас має метод :meth:`~object.__setattr__` або "
":meth:`~object.__delattr__`, він викликається замість безпосереднього "
"оновлення словника примірника."

#: ../../reference/datamodel.rst:1297
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Екземпляри класу можуть видавати себе за числа, послідовності або "
"відображення, якщо вони мають методи з певними спеціальними назвами. "
"Дивіться розділ :ref:`specialnames`."

#: ../../reference/datamodel.rst:1309
msgid "The class to which a class instance belongs."
msgstr "Клас, до якого належить екземпляр класу."

#: ../../reference/datamodel.rst:1313
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes. Not all instances have a :attr:`!__dict__` attribute; see the "
"section on :ref:`slots` for more details."
msgstr ""

#: ../../reference/datamodel.rst:1319
msgid "I/O objects (also known as file objects)"
msgstr "Об’єкти введення-виведення (також відомі як файлові об’єкти)"

#: ../../reference/datamodel.rst:1334
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
":term:`file object` представляє відкритий файл. Для створення файлових "
"об’єктів доступні різні ярлики: вбудована функція :func:`open`, а також "
":func:`os.popen`, :func:`os.fdopen` і :meth:`~socket. socket.makefile` метод"
" об’єктів сокета (і, можливо, за допомогою інших функцій або методів, "
"наданих модулями розширення)."

#: ../../reference/datamodel.rst:1340
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized"
" to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Об'єкти ``sys.stdin``, ``sys.stdout`` і ``sys.stderr`` ініціалізуються "
"об'єктами файлів, що відповідають стандартним потокам введення, виведення та"
" помилок інтерпретатора; усі вони відкриті в текстовому режимі, тому "
"відповідають інтерфейсу, визначеному :class:`io.TextIOBase` абстрактним "
"класом."

#: ../../reference/datamodel.rst:1348
msgid "Internal types"
msgstr "Внутрішні типи"

#: ../../reference/datamodel.rst:1354
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Кілька типів, які використовуються внутрішньо інтерпретатором, доступні "
"користувачеві. Їх визначення можуть змінюватися в майбутніх версіях "
"інтерпретатора, але вони згадуються тут для повноти."

#: ../../reference/datamodel.rst:1362
msgid "Code objects"
msgstr "Об'єкти коду"

#: ../../reference/datamodel.rst:1366
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function object"
" is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code object"
" contains no context; also the default argument values are stored in the "
"function object, not in the code object (because they represent values "
"calculated at run-time).  Unlike function objects, code objects are "
"immutable and contain no references (directly or indirectly) to mutable "
"objects."
msgstr ""
"Об’єкти коду представляють *байт-скомпільований* виконуваний код Python або "
":term:`bytecode`. Різниця між об’єктом коду та об’єктом функції полягає в "
"тому, що об’єкт функції містить явне посилання на глобальні елементи функції"
" (модуль, у якому вона була визначена), тоді як об’єкт коду не містить "
"контексту; також значення аргументів за замовчуванням зберігаються в об’єкті"
" функції, а не в об’єкті коду (оскільки вони представляють значення, "
"обчислені під час виконання). На відміну від функціональних об’єктів, "
"об’єкти коду є незмінними і не містять посилань (прямих чи опосередкованих) "
"на змінні об’єкти."

#: ../../reference/datamodel.rst:1400
msgid "The function name"
msgstr ""

#: ../../reference/datamodel.rst:1403
msgid "The fully qualified function name"
msgstr ""

#: ../../reference/datamodel.rst:1408
msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""

#: ../../reference/datamodel.rst:1413
msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""

#: ../../reference/datamodel.rst:1417
msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""

#: ../../reference/datamodel.rst:1421
msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""

#: ../../reference/datamodel.rst:1425
msgid ""
"A :class:`tuple` containing the names of the local variables in the function"
" (starting with the parameter names)"
msgstr ""

#: ../../reference/datamodel.rst:1429
msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced from at least one :term:`nested scope` inside the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1433
msgid ""
"A :class:`tuple` containing the names of :term:`free (closure) variables "
"<closure variable>` that a :term:`nested scope` references in an outer "
"scope. See also :attr:`function.__closure__`."
msgstr ""

#: ../../reference/datamodel.rst:1437
msgid "Note: references to global and builtin names are *not* included."
msgstr ""

#: ../../reference/datamodel.rst:1440
msgid ""
"A string representing the sequence of :term:`bytecode` instructions in the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1444
msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in the"
" function"
msgstr ""

#: ../../reference/datamodel.rst:1448
msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1452
msgid "The name of the file from which the code was compiled"
msgstr ""

#: ../../reference/datamodel.rst:1455
msgid "The line number of the first line of the function"
msgstr ""

#: ../../reference/datamodel.rst:1458
msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line numbers."
" For details, see the source code of the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:1461
msgid ""
"This attribute of code objects is deprecated, and may be removed in Python "
"3.15."
msgstr ""

#: ../../reference/datamodel.rst:1466
msgid "The required stack size of the code object"
msgstr ""

#: ../../reference/datamodel.rst:1469
msgid ""
"An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:1474
msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit "
"``0x04`` is set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. See "
":ref:`inspect-module-co-flags` for details on the semantics of each flags "
"that might be present."
msgstr ""

#: ../../reference/datamodel.rst:1482
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`~codeobject.co_flags` to indicate whether a code object was "
"compiled with a particular feature enabled: bit ``0x2000`` is set if the "
"function was compiled with future division enabled; bits ``0x10`` and "
"``0x1000`` were used in earlier versions of Python."
msgstr ""

#: ../../reference/datamodel.rst:1488
msgid ""
"Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ""

#: ../../reference/datamodel.rst:1492
msgid ""
"If a code object represents a function, the first item in "
":attr:`~codeobject.co_consts` is the documentation string of the function, "
"or ``None`` if undefined."
msgstr ""

#: ../../reference/datamodel.rst:1497
msgid "Methods on code objects"
msgstr ""

#: ../../reference/datamodel.rst:1501
msgid ""
"Returns an iterable over the source code positions of each :term:`bytecode` "
"instruction in the code object."
msgstr ""

#: ../../reference/datamodel.rst:1504
msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to the "
"position of the source code that compiled to the *i-th* code unit. Column "
"information is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""

#: ../../reference/datamodel.rst:1510
msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr ""

#: ../../reference/datamodel.rst:1513
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr ""

#: ../../reference/datamodel.rst:1514
msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""

#: ../../reference/datamodel.rst:1515
msgid "Position tuples corresponding to artificial instructions."
msgstr ""

#: ../../reference/datamodel.rst:1516
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""

#: ../../reference/datamodel.rst:1519
msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""

#: ../../reference/datamodel.rst:1525
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""

#: ../../reference/datamodel.rst:1534
msgid ""
"Returns an iterator that yields information about successive ranges of "
":term:`bytecode`\\s. Each item yielded is a ``(start, end, lineno)`` "
":class:`tuple`:"
msgstr ""

#: ../../reference/datamodel.rst:1538
msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the start "
"of the :term:`bytecode` range"
msgstr ""

#: ../../reference/datamodel.rst:1540
msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of "
"the :term:`bytecode` range"
msgstr ""

#: ../../reference/datamodel.rst:1542
msgid ""
"``lineno`` is an :class:`int` representing the line number of the "
":term:`bytecode` range, or ``None`` if the bytecodes in the given range have"
" no line number"
msgstr ""

#: ../../reference/datamodel.rst:1546
msgid "The items yielded will have the following properties:"
msgstr ""

#: ../../reference/datamodel.rst:1548
msgid "The first range yielded will have a ``start`` of 0."
msgstr ""

#: ../../reference/datamodel.rst:1549
msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That is,"
" for any pair of :class:`tuple`\\s, the ``start`` of the second will be "
"equal to the ``end`` of the first."
msgstr ""

#: ../../reference/datamodel.rst:1552
msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr ""

#: ../../reference/datamodel.rst:1553
msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of the "
":term:`bytecode`."
msgstr ""

#: ../../reference/datamodel.rst:1556
msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges "
"are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""

#: ../../reference/datamodel.rst:1564
msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ""

#: ../../reference/datamodel.rst:1565
msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr ""

#: ../../reference/datamodel.rst:1569
msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr "Повернути копію об’єкта коду з новими значеннями для вказаних полів."

#: ../../reference/datamodel.rst:1571
msgid ""
"Code objects are also supported by the generic function "
":func:`copy.replace`."
msgstr ""

#: ../../reference/datamodel.rst:1579
msgid "Frame objects"
msgstr "Рамкові об'єкти"

#: ../../reference/datamodel.rst:1583
msgid ""
"Frame objects represent execution frames.  They may occur in :ref:`traceback"
" objects <traceback-objects>`, and are also passed to registered trace "
"functions."
msgstr ""

#: ../../reference/datamodel.rst:1601
msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if this"
" is the bottom stack frame"
msgstr ""

#: ../../reference/datamodel.rst:1605
msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""

#: ../../reference/datamodel.rst:1610
msgid ""
"The mapping used by the frame to look up :ref:`local variables <naming>`. If"
" the frame refers to an :term:`optimized scope`, this may return a write-"
"through proxy object."
msgstr ""

#: ../../reference/datamodel.rst:1615
msgid "Return a proxy for optimized scopes."
msgstr ""

#: ../../reference/datamodel.rst:1619
msgid ""
"The dictionary used by the frame to look up :ref:`global variables <naming>`"
msgstr ""

#: ../../reference/datamodel.rst:1623
msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) names"
" <naming>`"
msgstr ""

#: ../../reference/datamodel.rst:1627
msgid ""
"The \"precise instruction\" of the frame object (this is an index into the "
":term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""

#: ../../reference/datamodel.rst:1643
msgid ""
"If not ``None``, this is a function called for various events during code "
"execution (this is used by debuggers). Normally an event is triggered for "
"each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""

#: ../../reference/datamodel.rst:1648
msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing event "
"for each source line."
msgstr ""

#: ../../reference/datamodel.rst:1652
msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being traced."
msgstr ""

#: ../../reference/datamodel.rst:1658
msgid ""
"The current line number of the frame -- writing to this from within a trace "
"function jumps to the given line (only for the bottom-most frame).  A "
"debugger can implement a Jump command (aka Set Next Statement) by writing to"
" this attribute."
msgstr ""

#: ../../reference/datamodel.rst:1664
msgid "Frame object methods"
msgstr ""

#: ../../reference/datamodel.rst:1666
msgid "Frame objects support one method:"
msgstr "Об’єкти фрейму підтримують один метод:"

#: ../../reference/datamodel.rst:1670
msgid ""
"This method clears all references to :ref:`local variables <naming>` held by"
" the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving frame "
"objects (for example when catching an :ref:`exception <bltin-exceptions>` "
"and storing its :ref:`traceback <traceback-objects>` for later use)."
msgstr ""

#: ../../reference/datamodel.rst:1676
msgid ""
":exc:`RuntimeError` is raised if the frame is currently executing or "
"suspended."
msgstr ""

#: ../../reference/datamodel.rst:1681
msgid ""
"Attempting to clear a suspended frame raises :exc:`RuntimeError` (as has "
"always been the case for executing frames)."
msgstr ""

#: ../../reference/datamodel.rst:1689
msgid "Traceback objects"
msgstr "Об'єкти відстеження"

#: ../../reference/datamodel.rst:1702
msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception occurs,"
" and may also be explicitly created by calling :class:`types.TracebackType`."
msgstr ""

#: ../../reference/datamodel.rst:1707
msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr ""

#: ../../reference/datamodel.rst:1710
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section "
":ref:`try`.) It is accessible as the third item of the tuple returned by "
":func:`sys.exc_info`, and as the :attr:`~BaseException.__traceback__` "
"attribute of the caught exception."
msgstr ""

#: ../../reference/datamodel.rst:1719
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as "
":data:`sys.last_traceback`."
msgstr ""

#: ../../reference/datamodel.rst:1724
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the :attr:`~traceback.tb_next` attributes should be linked "
"to form a full stack trace."
msgstr ""

#: ../../reference/datamodel.rst:1739
msgid ""
"Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr ""

#: ../../reference/datamodel.rst:1742
msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""

#: ../../reference/datamodel.rst:1747
msgid "Gives the line number where the exception occurred"
msgstr ""

#: ../../reference/datamodel.rst:1750
msgid "Indicates the \"precise instruction\"."
msgstr ""

#: ../../reference/datamodel.rst:1752
msgid ""
"The line number and last instruction in the traceback may differ from the "
"line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""

#: ../../reference/datamodel.rst:1763
msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None`` if"
" there is no next level."
msgstr ""

#: ../../reference/datamodel.rst:1767
msgid "This attribute is now writable"
msgstr ""

#: ../../reference/datamodel.rst:1772
msgid "Slice objects"
msgstr "Розрізати об'єкти"

#: ../../reference/datamodel.rst:1776
msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Об’єкти фрагментів використовуються для представлення фрагментів для методів"
" :meth:`~object.__getitem__`. Вони також створюються за допомогою вбудованої"
" функції :func:`slice`."

#: ../../reference/datamodel.rst:1785
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Спеціальні атрибути лише для читання: :attr:`~slice.start` нижня межа; "
":attr:`~slice.stop` є верхньою межею; :attr:`~slice.step` — значення кроку; "
"якщо опущено, кожен має значення ``None``. Ці атрибути можуть мати будь-який"
" тип."

#: ../../reference/datamodel.rst:1789
msgid "Slice objects support one method:"
msgstr "Об'єкти Slice підтримують один метод:"

#: ../../reference/datamodel.rst:1793
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Цей метод приймає єдиний цілочисельний аргумент *length* і обчислює "
"інформацію про зріз, який описав би об’єкт slice, якщо його застосувати до "
"послідовності елементів *length*. Він повертає кортеж із трьох цілих чисел; "
"відповідно, це індекси *start* і *stop* і *крок* або довжина кроку зрізу. "
"Відсутні індекси або індекси, що виходять за межі, обробляються відповідно "
"до звичайних фрагментів."

#: ../../reference/datamodel.rst:1802
msgid "Static method objects"
msgstr "Об’єкти статичних методів"

#: ../../reference/datamodel.rst:1804
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Об’єкти статичних методів забезпечують спосіб відмови від перетворення "
"об’єктів функції в об’єкти методів, описані вище. Статичний об’єкт методу є "
"обгорткою навколо будь-якого іншого об’єкта, зазвичай об’єкта методу, "
"визначеного користувачем. Коли об’єкт статичного методу отримується з класу "
"або екземпляра класу, фактично повернутий об’єкт є об’єктом-огорткою, який "
"не підлягає подальшому перетворенню. Об’єкти статичних методів також можна "
"викликати. Об’єкти статичних методів створюються за допомогою вбудованого "
"конструктора :func:`staticmethod`."

#: ../../reference/datamodel.rst:1814
msgid "Class method objects"
msgstr "Об’єкти методу класу"

#: ../../reference/datamodel.rst:1816
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such"
" retrieval is described above, under :ref:`\"instance methods\" <instance-"
"methods>`. Class method objects are created by the built-in "
":func:`classmethod` constructor."
msgstr ""

#: ../../reference/datamodel.rst:1826
msgid "Special method names"
msgstr "Назви спеціальних методів"

#: ../../reference/datamodel.rst:1832
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named "
":meth:`~object.__getitem__`, and ``x`` is an instance of this class, then "
"``x[i]`` is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except "
"where mentioned, attempts to execute an operation raise an exception when no"
" appropriate method is defined (typically :exc:`AttributeError` or "
":exc:`TypeError`)."
msgstr ""
"Клас може реалізувати певні операції, які викликаються спеціальним "
"синтаксисом (такі як арифметичні операції або індексування та зрізання), "
"визначаючи методи зі спеціальними іменами. Це підхід Python до "
":dfn:`operator overloading`, що дозволяє класам визначати власну поведінку "
"щодо операторів мови. Наприклад, якщо клас визначає метод із назвою "
":meth:`~object.__getitem__`, а ``x`` є екземпляром цього класу, то ``x[i]`` "
"приблизно еквівалентний ``type( x).__getitem__(x, i)``. Якщо не зазначено "
"вище, спроби виконати операцію викликають виняток, якщо відповідний метод не"
" визначено (зазвичай :exc:`AttributeError` або :exc:`TypeError`)."

#: ../../reference/datamodel.rst:1843
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets "
":meth:`~object.__iter__` to ``None``, the class is not iterable, so calling "
":func:`iter` on its instances will raise a :exc:`TypeError` (without falling"
" back to :meth:`~object.__getitem__`). [#]_"
msgstr ""
"Встановлення для спеціального методу значення ``None`` означає, що "
"відповідна операція недоступна. Наприклад, якщо клас встановлює "
":meth:`~object.__iter__` на ``None``, клас не піддається ітерації, тому "
"виклик :func:`iter` у його екземплярах викличе :exc:`TypeError` ( не "
"повертаючись до :meth:`~object.__getitem__`). [#]_"

#: ../../reference/datamodel.rst:1849
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for"
" the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make sense."
"  (One example of this is the :class:`~xml.dom.NodeList` interface in the "
"W3C's Document Object Model.)"
msgstr ""
"При реалізації класу, який емулює будь-який вбудований тип, важливо, щоб "
"емуляція була реалізована лише в тій мірі, в якій це має сенс для об’єкта, "
"що моделюється. Наприклад, деякі послідовності можуть добре працювати з "
"отриманням окремих елементів, але вилучення фрагмента може не мати сенсу. "
"(Одним із прикладів цього є інтерфейс :class:`~xml.dom.NodeList` в об’єктній"
" моделі документа W3C.)"

#: ../../reference/datamodel.rst:1860
msgid "Basic customization"
msgstr "Базове налаштування"

#: ../../reference/datamodel.rst:1866
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static"
" method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Викликається для створення нового екземпляра класу *cls*. :meth:`__new__` — "
"це статичний метод (з особливим регістром, тому вам не потрібно оголошувати "
"його як такий), який приймає клас, екземпляр якого був запитаний, як свій "
"перший аргумент. Решта аргументів передаються у вираз конструктора об’єкта "
"(виклик класу). Поверненим значенням :meth:`__new__` має бути новий "
"екземпляр об’єкта (зазвичай це екземпляр *cls*)."

#: ../../reference/datamodel.rst:1873
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""

#: ../../reference/datamodel.rst:1878
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and"
" the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"Якщо :meth:`__new__` викликається під час побудови об’єкта і повертає "
"екземпляр *cls*, тоді новий метод :meth:`__init__` буде викликано як "
"``__init__(self[, ...])``, де *self* — це новий екземпляр, а решта "
"аргументів ті самі, що були передані конструктору об’єкта."

#: ../../reference/datamodel.rst:1883
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Якщо :meth:`__new__` не повертає екземпляр *cls*, то метод :meth:`__init__` "
"нового екземпляра не буде викликано."

#: ../../reference/datamodel.rst:1886
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` призначений головним чином для того, щоб дозволити підкласам"
" незмінних типів (наприклад, int, str або tuple) налаштовувати створення "
"екземплярів. Його також зазвичай перевизначають у власних метакласах, щоб "
"налаштувати створення класу."

#: ../../reference/datamodel.rst:1895
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the"
" derived class's :meth:`__init__` method, if any, must explicitly call it to"
" ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Викликається після створення екземпляра (за допомогою :meth:`__new__`), але "
"до того, як його буде повернено до викликаючого. Аргументи передаються у "
"вираз конструктора класу. Якщо базовий клас має метод :meth:`__init__`, "
"метод :meth:`__init__` похідного класу, якщо такий є, повинен явно викликати"
" його, щоб забезпечити правильну ініціалізацію частини базового класу "
"примірника; наприклад: ``super().__init__([args...])``."

#: ../../reference/datamodel.rst:1902
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Оскільки :meth:`__new__` і :meth:`__init__` працюють разом у створенні "
"об’єктів (:meth:`__new__`, щоб створити його, і :meth:`__init__`, щоб "
"налаштувати його), немає не-``None`` значення може повертати "
":meth:`__init__`; це призведе до появи :exc:`TypeError` під час виконання."

#: ../../reference/datamodel.rst:1915
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a "
":meth:`__del__` method, the derived class's :meth:`__del__` method, if any, "
"must explicitly call it to ensure proper deletion of the base class part of "
"the instance."
msgstr ""
"Викликається, коли примірник збирається знищити. Це також називається "
"фіналізатором або (неправильно) деструктором. Якщо базовий клас має метод "
":meth:`__del__`, метод :meth:`__del__` похідного класу, якщо такий є, "
"повинен явно викликати його, щоб забезпечити належне видалення частини "
"базового класу екземпляра."

#: ../../reference/datamodel.rst:1921
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is"
" about to be destroyed; the current :term:`CPython` implementation only "
"calls it once."
msgstr ""
"Метод :meth:`__del__` може (хоча і не рекомендується!) відкласти знищення "
"екземпляра шляхом створення нового посилання на нього. Це називається "
"*воскресіння* об'єкта. Це залежить від реалізації, чи :meth:`__del__` "
"викликається вдруге, коли воскреслий об’єкт збирається знищити; поточна "
"реалізація :term:`CPython` викликає його лише один раз."

#: ../../reference/datamodel.rst:1928
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be called "
"when an object is garbage collected."
msgstr ""

#: ../../reference/datamodel.rst:1935
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` не викликає напряму ``x.__del__()`` --- перший зменшує кількість "
"посилань для ``x`` на одиницю, а останній викликається лише тоді, коли ``x``"
" кількість посилань досягає нуля."

#: ../../reference/datamodel.rst:1940
msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A"
" common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""

#: ../../reference/datamodel.rst:1950
msgid "Documentation for the :mod:`gc` module."
msgstr "Документація для модуля :mod:`gc`."

#: ../../reference/datamodel.rst:1954
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"Через ненадійні обставини, за яких викликаються методи :meth:`__del__`, "
"винятки, що виникають під час їх виконання, ігноруються, а попередження "
"друкується в ``sys.stderr``. Зокрема:"

#: ../../reference/datamodel.rst:1958
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute "
":meth:`__del__`."
msgstr ""
":meth:`__del__` можна викликати, коли виконується довільний код, у тому "
"числі з будь-якого довільного потоку. Якщо :meth:`__del__` потрібно "
"заблокувати або викликати будь-який інший блокуючий ресурс, це може "
"призвести до блокування, оскільки ресурс може вже бути зайнятий кодом, який "
"переривається для виконання :meth:`__del__`."

#: ../../reference/datamodel.rst:1964
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees"
" that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` можна виконати під час завершення роботи інтерпретатора. Як "
"наслідок, глобальні змінні, до яких він має отримати доступ (включно з "
"іншими модулями), можливо, уже були видалені або встановлені на ``None``. "
"Python гарантує, що глобальні елементи, ім’я яких починається з одного "
"підкреслення, будуть видалені з їхнього модуля перед видаленням інших "
"глобальних елементів; якщо немає інших посилань на такі глобали, це може "
"допомогти впевнитися, що імпортовані модулі все ще доступні під час виклику "
"методу :meth:`__del__`."

#: ../../reference/datamodel.rst:1979
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with"
" the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should be"
" returned. The return value must be a string object. If a class defines "
":meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used"
" when an \"informal\" string representation of instances of that class is "
"required."
msgstr ""
"Викликається вбудованою функцією :func:`repr` для обчислення \"офіційного\" "
"рядкового представлення об’єкта. Якщо це взагалі можливо, це має виглядати "
"як дійсний вираз Python, який можна використати для відтворення об’єкта з "
"тим самим значенням (за умови відповідного середовища). Якщо це неможливо, "
"слід повернути рядок у формі ``<...some useful description...>``. Повернене "
"значення має бути рядковим об’єктом. Якщо клас визначає :meth:`__repr__`, "
"але не :meth:`__str__`, тоді :meth:`__repr__` також використовується, коли "
"потрібне \"неформальне\" рядкове представлення екземплярів цього класу."

#: ../../reference/datamodel.rst:1988
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous. A default implementation"
" is provided by the :class:`object` class itself."
msgstr ""

#: ../../reference/datamodel.rst:2000
msgid ""
"Called by :func:`str(object) <str>`, the default :meth:`__format__` "
"implementation, and the built-in function :func:`print`, to compute the "
"\"informal\" or nicely printable string representation of an object.  The "
"return value must be a :ref:`str <textseq>` object."
msgstr ""

#: ../../reference/datamodel.rst:2005
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Цей метод відрізняється від :meth:`object.__repr__` тим, що не очікується, "
"що :meth:`__str__` поверне дійсний вираз Python: можна використовувати більш"
" зручне або стисле представлення."

#: ../../reference/datamodel.rst:2009
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"Стандартна реалізація, визначена вбудованим типом :class:`object`, викликає "
":meth:`object.__repr__`."

#: ../../reference/datamodel.rst:2019
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object. The "
":class:`object` class itself does not provide this method."
msgstr ""

#: ../../reference/datamodel.rst:2031
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation"
" of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument"
" is up to the type implementing :meth:`__format__`, however most classes "
"will either delegate formatting to one of the built-in types, or use a "
"similar formatting option syntax."
msgstr ""
"Викликається вбудованою функцією :func:`format` і за допомогою розширення "
"обчислення :ref:`форматованих рядкових літералів <f-strings>` і методу "
":meth:`str.format`, щоб створити \"відформатований\" рядковий представлення "
"об'єкт. Аргумент *format_spec* — це рядок, який містить опис бажаних "
"параметрів форматування. Інтерпретація аргументу *format_spec* залежить від "
"типу, що реалізує :meth:`__format__`, проте більшість класів або делегують "
"форматування одному з вбудованих типів, або використовують подібний "
"синтаксис параметрів форматування."

#: ../../reference/datamodel.rst:2041
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Перегляньте :ref:`formatspec` для опису стандартного синтаксису "
"форматування."

#: ../../reference/datamodel.rst:2043
msgid "The return value must be a string object."
msgstr "Повернене значення має бути рядковим об’єктом."

#: ../../reference/datamodel.rst:2045
msgid ""
"The default implementation by the :class:`object` class should be given an "
"empty *format_spec* string. It delegates to :meth:`__str__`."
msgstr ""

#: ../../reference/datamodel.rst:2048
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"Сам метод __format__ ``object`` викликає :exc:`TypeError`, якщо передати "
"будь-який непорожній рядок."

#: ../../reference/datamodel.rst:2052
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` тепер еквівалентний ``str(x)``, а не "
"``format(str(x), '')``."

#: ../../reference/datamodel.rst:2068
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"Це так звані методи \"багатого порівняння\". Відповідність між символами "
"оператора та назвами методів така: ``x <y`` calls ``x.__lt__(y)``, ``x<=y`` "
"calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, ``x!=y`` calls "
"``x.__ne__(y)``, ``x> y`` викликає ``x.__gt__(y)``, а ``x>=y`` викликає "
"``x.__ge__(y)``."

#: ../../reference/datamodel.rst:2074
msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison."
" However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""

#: ../../reference/datamodel.rst:2081
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning "
":data:`NotImplemented` in the case of a false comparison: ``True if x is y "
"else NotImplemented``. For :meth:`__ne__`, by default it delegates to "
":meth:`__eq__` and inverts the result unless it is :data:`!NotImplemented`."
"  There are no other implied relationships among the comparison operators or"
" default implementations; for example, the truth of ``(x<y or x==y)`` does "
"not imply ``x<=y``. To automatically generate ordering operations from a "
"single root operation, see :func:`functools.total_ordering`."
msgstr ""

#: ../../reference/datamodel.rst:2090
msgid ""
"By default, the :class:`object` class provides implementations consistent "
"with :ref:`expressions-value-comparisons`: equality compares according to "
"object identity, and order comparisons raise :exc:`TypeError`. Each default "
"method may generate these results directly, but may also return "
":data:`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:2096
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating "
":term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"Перегляньте параграф про :meth:`__hash__` для деяких важливих приміток щодо "
"створення об’єктів :term:`hashable`, які підтримують спеціальні операції "
"порівняння та використовуються як ключі словника."

#: ../../reference/datamodel.rst:2100
msgid ""
"There are no swapped-argument versions of these methods (to be used when the"
" left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, "
":meth:`__le__` and :meth:`__ge__` are each other's reflection, and "
":meth:`__eq__` and :meth:`__ne__` are their own reflection. If the operands "
"are of different types, and the right operand's type is a direct or indirect"
" subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""

#: ../../reference/datamodel.rst:2111
msgid ""
"When no appropriate method returns any value other than "
":data:`NotImplemented`, the ``==`` and ``!=`` operators will fall back to "
"``is`` and ``is not``, respectively."
msgstr ""

#: ../../reference/datamodel.rst:2120
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  The ``__hash__()`` method should return an integer. The only"
" required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"Викликається вбудованою функцією :func:`hash` і для операцій над членами "
"хешованих колекцій, включаючи :class:`set`, :class:`frozenset` і "
":class:`dict`. Метод ``__hash__()`` має повертати ціле число. Єдиною "
"необхідною властивістю є те, що об’єкти, які порівнюються, мають однакове "
"хеш-значення; рекомендується змішувати геш-значення компонентів об’єкта, які"
" також відіграють роль у порівнянні об’єктів, упаковуючи їх у кортеж і "
"хешуючи кортеж. Приклад::"

#: ../../reference/datamodel.rst:2128
msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""

#: ../../reference/datamodel.rst:2133
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way to "
"do this is with ``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` скорочує значення, що повертається користувацьким методом "
":meth:`__hash__` об’єкта, до розміру :c:type:`Py_ssize_t`. Зазвичай це 8 "
"байтів для 64-розрядних збірок і 4 байти для 32-розрядних збірок. Якщо "
":meth:`__hash__` об’єкта має взаємодіяти зі збірками різних бітових "
"розмірів, обов’язково перевірте ширину всіх підтримуваних збірок. Простий "
"спосіб зробити це за допомогою ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."

#: ../../reference/datamodel.rst:2141
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a "
":meth:`__hash__` operation either; if it defines :meth:`__eq__` but not "
":meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of :term:`hashable` collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the "
"wrong hash bucket)."
msgstr ""

#: ../../reference/datamodel.rst:2150
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default (inherited from the :class:`object` class); with them, all objects "
"compare unequal (except with themselves) and ``x.__hash__()`` returns an "
"appropriate value such that ``x == y`` implies both that ``x is y`` and "
"``hash(x) == hash(y)``."
msgstr ""

#: ../../reference/datamodel.rst:2155
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the "
":meth:`__hash__` method of a class is ``None``, instances of the class will "
"raise an appropriate :exc:`TypeError` when a program attempts to retrieve "
"their hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"Для класу, який перевизначає :meth:`__eq__` і не визначає :meth:`__hash__`, "
"його :meth:`__hash__` буде неявно встановлено на ``None``. Коли метод "
":meth:`__hash__` класу має значення ``None``, екземпляри класу викличуть "
"відповідну :exc:`TypeError`, коли програма намагатиметься отримати їх хеш-"
"значення, а також будуть правильно визначені як нехешується під час "
"перевірки ``isinstance(obj, collections.abc.Hashable)``."

#: ../../reference/datamodel.rst:2162
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Якщо клас, який перевизначає :meth:`__eq__`, потребує збереження реалізації "
":meth:`__hash__` від батьківського класу, інтерпретатор має бути "
"повідомлений про це явно, встановивши ``__hash__ = <ParentClass> "
".__hash__``."

#: ../../reference/datamodel.rst:2166
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Якщо клас, який не перевизначає :meth:`__eq__`, бажає придушити підтримку "
"хешу, він повинен включити ``__hash__ = None`` у визначення класу. Клас, "
"який визначає власний :meth:`__hash__`, який явно викликає :exc:`TypeError`,"
" буде неправильно ідентифікований як хешований викликом ``isinstance(obj, "
"collections.abc.Hashable)``."

#: ../../reference/datamodel.rst:2175
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"За замовчуванням значення :meth:`__hash__` об’єктів str і bytes "
"\"підсолюються\" непередбачуваним випадковим значенням. Хоча вони "
"залишаються незмінними в окремому процесі Python, вони не передбачувані між "
"повторними викликами Python."

#: ../../reference/datamodel.rst:2180
msgid ""
"This is intended to provide protection against a denial-of-service caused by"
" carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See "
"http://ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""

#: ../../reference/datamodel.rst:2185
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Зміна хеш-значень впливає на порядок ітерацій наборів. Python ніколи не "
"надавав гарантій щодо такого порядку (і він зазвичай варіюється між "
"32-бітними та 64-бітними збірками)."

#: ../../reference/datamodel.rst:2189
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Дивіться також :envvar:`PYTHONHASHSEED`."

#: ../../reference/datamodel.rst:2191
msgid "Hash randomization is enabled by default."
msgstr "Хеш-рандомізація ввімкнена за замовчуванням."

#: ../../reference/datamodel.rst:2199
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`~object.__len__` is called, if it is defined, and the object"
" is considered true if its result is nonzero.  If a class defines neither "
":meth:`!__len__` nor :meth:`!__bool__` (which is true of the :class:`object`"
" class itself), all its instances are considered true."
msgstr ""

#: ../../reference/datamodel.rst:2210
msgid "Customizing attribute access"
msgstr "Налаштування доступу до атрибутів"

#: ../../reference/datamodel.rst:2212
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Наступні методи можна визначити для налаштування значення доступу до "
"атрибутів (використання, призначення або видалення ``x.name``) для "
"екземплярів класу."

#: ../../reference/datamodel.rst:2220
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError`"
" (either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises "
":exc:`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. The "
":class:`object` class itself does not provide this method."
msgstr ""

#: ../../reference/datamodel.rst:2228
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can take total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""

#: ../../reference/datamodel.rst:2241
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be"
" called unless :meth:`__getattribute__` either calls it explicitly or raises"
" an :exc:`AttributeError`. This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. In order to "
"avoid infinite recursion in this method, its implementation should always "
"call the base class method with the same name to access any attributes it "
"needs, for example, ``object.__getattribute__(self, name)``."
msgstr ""
"Викликається безумовно для реалізації доступу до атрибутів для екземплярів "
"класу. Якщо клас також визначає :meth:`__getattr__`, останній не буде "
"викликаний, якщо :meth:`__getattribute__` не викличе його явно або не "
"викличе :exc:`AttributeError`. Цей метод має повертати (обчислене) значення "
"атрибута або викликати виняток :exc:`AttributeError`. Щоб уникнути "
"нескінченної рекурсії в цьому методі, його реалізація повинна завжди "
"викликати метод базового класу з тим самим іменем для доступу до будь-яких "
"необхідних атрибутів, наприклад, ``object.__getattribute__(self, name)``."

#: ../../reference/datamodel.rst:2252
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""

#: ../../reference/datamodel.rst:2257 ../../reference/datamodel.rst:2259
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Для доступу до певних конфіденційних атрибутів викликає :ref:`подію аудиту "
"<auditing>` ``object.__getattr__`` з аргументами ``obj`` і ``name``."

#: ../../reference/datamodel.rst:2266
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of"
" the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Викликається під час спроби призначення атрибута. Це викликається замість "
"звичайного механізму (тобто збереження значення в словнику екземпляра). "
"*name* — ім’я атрибута, *value* — значення, яке йому буде присвоєно."

#: ../../reference/datamodel.rst:2270
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
"Якщо :meth:`__setattr__` хоче призначити атрибут екземпляра, він повинен "
"викликати метод базового класу з такою самою назвою, наприклад, "
"``object.__setattr__(self, name, value)``."

#: ../../reference/datamodel.rst:2274 ../../reference/datamodel.rst:2276
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"Для певних конфіденційних призначень атрибутів створює :ref:`подію аудиту "
"<auditing>` ``object.__setattr__`` з аргументами ``obj``, ``name``, "
"``value``."

#: ../../reference/datamodel.rst:2283
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Як :meth:`__setattr__`, але для видалення атрибута замість призначення. Це "
"слід застосовувати, лише якщо ``del obj.name`` має значення для об’єкта."

#: ../../reference/datamodel.rst:2286 ../../reference/datamodel.rst:2288
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Для певних видалень конфіденційних атрибутів викликає :ref:`подію аудиту "
"<auditing>` ``object.__delattr__`` з аргументами ``obj`` і ``name``."

#: ../../reference/datamodel.rst:2295
msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts it."
msgstr ""

#: ../../reference/datamodel.rst:2300
msgid "Customizing module attribute access"
msgstr "Налаштування доступу до атрибутів модуля"

#: ../../reference/datamodel.rst:2307
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute"
" is not found on a module object through the normal lookup, i.e. "
":meth:`object.__getattribute__`, then ``__getattr__`` is searched in the "
"module ``__dict__`` before raising an :exc:`AttributeError`. If found, it is"
" called with the attribute name and the result is returned."
msgstr ""
"Спеціальні імена ``__getattr__`` і ``__dir__`` також можна використовувати "
"для налаштування доступу до атрибутів модуля. Функція ``__getattr__`` на "
"рівні модуля повинна приймати один аргумент, який є назвою атрибута, і "
"повертати обчислене значення або викликати :exc:`AttributeError`. Якщо "
"атрибут не знайдено в об’єкті модуля за допомогою звичайного пошуку, тобто "
":meth:`object.__getattribute__`, тоді ``__getattr__`` шукається в модулі "
"``__dict__`` перед тим, як викликати :exc:`AttributeError` . Якщо знайдено, "
"воно викликається з назвою атрибута та повертає результат."

#: ../../reference/datamodel.rst:2316
msgid ""
"The ``__dir__`` function should accept no arguments, and return an iterable "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""

#: ../../reference/datamodel.rst:2320
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"Для більш точного налаштування поведінки модуля (встановлення атрибутів, "
"властивостей тощо) можна встановити атрибут ``__class__`` об’єкта модуля до "
"підкласу :class:`types.ModuleType`. Наприклад::"

#: ../../reference/datamodel.rst:2324
msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""

#: ../../reference/datamodel.rst:2338
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect"
" lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the"
" module's globals dictionary) is unaffected."
msgstr ""
"Визначення модуля ``__getattr__`` і налаштування модуля ``__class__`` "
"впливають лише на пошуки, зроблені за допомогою синтаксису доступу до "
"атрибутів – прямий доступ до глобалів модуля (чи то за допомогою коду в "
"модулі, чи через посилання на словник глобалів модуля) не впливає."

#: ../../reference/datamodel.rst:2343
msgid "``__class__`` module attribute is now writable."
msgstr "Атрибут модуля ``__class__`` тепер доступний для запису."

#: ../../reference/datamodel.rst:2346
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "Атрибути модуля ``__getattr__`` і ``__dir__``."

#: ../../reference/datamodel.rst:2351
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - Модуль __getattr__ і __dir__"

#: ../../reference/datamodel.rst:2352
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Описує функції ``__getattr__`` і ``__dir__`` для модулів."

#: ../../reference/datamodel.rst:2358
msgid "Implementing Descriptors"
msgstr "Реалізація дескрипторів"

#: ../../reference/datamodel.rst:2360
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the"
" descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in"
" the owner class' :attr:`~object.__dict__`.  The :class:`object` class "
"itself does not implement any of these protocols."
msgstr ""

#: ../../reference/datamodel.rst:2370
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Викликається, щоб отримати атрибут класу власника (доступ до атрибуту класу)"
" або екземпляра цього класу (доступ до атрибуту екземпляра). Необов’язковий "
"аргумент *owner* — це клас власника, тоді як *instance* — це екземпляр, "
"через який був доступ до атрибута, або ``None``, коли доступ до атрибута "
"здійснюється через *owner*."

#: ../../reference/datamodel.rst:2376
msgid ""
"This method should return the computed attribute value or raise an "
":exc:`AttributeError` exception."
msgstr ""
"Цей метод має повертати обчислене значення атрибута або викликати виняток "
":exc:`AttributeError`."

#: ../../reference/datamodel.rst:2379
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` вказує, що :meth:`__get__` можна викликати за допомогою одного "
"або двох аргументів. Власні вбудовані дескриптори Python підтримують цю "
"специфікацію; проте ймовірно, що деякі інструменти сторонніх розробників "
"мають дескриптори, які потребують обох аргументів. Власна реалізація "
":meth:`__getattribute__` Python завжди передає обидва аргументи незалежно "
"від того, потрібні вони чи ні."

#: ../../reference/datamodel.rst:2388
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Викликається, щоб встановити атрибуту екземпляра *екземпляру* класу власника"
" нове значення *value*."

#: ../../reference/datamodel.rst:2391
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Зверніть увагу: додавання :meth:`__set__` або :meth:`__delete__` змінює тип "
"дескриптора на \"дескриптор даних\". Перегляньте :ref:`descriptor-"
"invocation` для отримання додаткової інформації."

#: ../../reference/datamodel.rst:2397
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Викликається для видалення атрибута екземпляра *екземпляра* класу власника."

#: ../../reference/datamodel.rst:2399
msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` attribute "
"present:"
msgstr ""

#: ../../reference/datamodel.rst:2404
msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""

#: ../../reference/datamodel.rst:2415
msgid "Invoking Descriptors"
msgstr "Виклик дескрипторів"

#: ../../reference/datamodel.rst:2417
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and "
":meth:`~object.__delete__`. If any of those methods are defined for an "
"object, it is said to be a descriptor."
msgstr ""
"Загалом, дескриптор — це атрибут об’єкта з \"зв’язуючою поведінкою\", доступ"
" до атрибутів якого перевизначено методами в протоколі дескриптора: "
":meth:`~object.__get__`, :meth:`~object.__set__` і "
":meth:`~object.__delete__`. Якщо будь-який із цих методів визначено для "
"об’єкта, він називається дескриптором."

#: ../../reference/datamodel.rst:2423
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Поведінка за умовчанням для доступу до атрибутів полягає в отриманні, "
"установці або видаленні атрибута зі словника об’єкта. Наприклад, ``a.x`` має"
" ланцюжок пошуку, який починається з ``a.__dict__['x']``, потім "
"``type(a).__dict__['x']`` і продовжується через базові класи типу "
"``type(a)``, за винятком метакласів."

#: ../../reference/datamodel.rst:2428
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"Проте, якщо шукане значення є об’єктом, що визначає один із методів "
"дескриптора, тоді Python може замінити поведінку за замовчуванням і замість "
"цього викликати метод дескриптора. Де це відбувається в ланцюжку "
"пріоритетів, залежить від того, які методи дескриптора були визначені та як "
"вони були викликані."

#: ../../reference/datamodel.rst:2433
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"Початковою точкою для виклику дескриптора є прив’язка, ``a.x``. Спосіб "
"збирання аргументів залежить від ``a``:"

#: ../../reference/datamodel.rst:2436
msgid "Direct Call"
msgstr "Прямий дзвінок"

#: ../../reference/datamodel.rst:2437
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"Найпростіший і найменш поширений виклик — це коли код користувача "
"безпосередньо викликає метод дескриптора: ``x.__get__(a)``."

#: ../../reference/datamodel.rst:2440
msgid "Instance Binding"
msgstr "Прив'язка екземпляра"

#: ../../reference/datamodel.rst:2441
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"У разі прив’язки до екземпляра об’єкта ``a.x`` перетворюється на виклик: "
"``type(a).__dict__['x'].__get__(a, type(a))``."

#: ../../reference/datamodel.rst:2444
msgid "Class Binding"
msgstr "Прив'язка класу"

#: ../../reference/datamodel.rst:2445
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr ""
"Якщо прив’язується до класу, ``A.x`` перетворюється на виклик: "
"``A.__dict__['x'].__get__(None, A)``."

#: ../../reference/datamodel.rst:2448
msgid "Super Binding"
msgstr "Супер прив'язка"

#: ../../reference/datamodel.rst:2449
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns "
"``B.__dict__['x'].__get__(a, A)``.  If not a descriptor, ``x`` is returned "
"unchanged."
msgstr ""

#: ../../reference/datamodel.rst:2486
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and "
":meth:`~object.__delete__`.  If it does not define :meth:`!__get__`, then "
"accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  Normally, "
"data descriptors define both :meth:`!__get__` and :meth:`!__set__`, while "
"non-data descriptors have just the :meth:`!__get__` method.  Data "
"descriptors with :meth:`!__get__` and :meth:`!__set__` (and/or "
":meth:`!__delete__`) defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""

#: ../../reference/datamodel.rst:2501
msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"Методи Python (включаючи ті, що прикрашені :func:`@staticmethod "
"<staticmethod>` і :func:`@classmethod <classmethod>`) реалізовані як "
"дескриптори не даних. Відповідно, екземпляри можуть перевизначати та "
"замінювати методи. Це дозволяє окремим примірникам набувати поведінки, яка "
"відрізняється від інших примірників того самого класу."

#: ../../reference/datamodel.rst:2507
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"Функція :func:`property` реалізована як дескриптор даних. Відповідно, "
"екземпляри не можуть перевизначати поведінку властивості."

#: ../../reference/datamodel.rst:2514
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:2516
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* дозволяє нам явно оголошувати елементи даних (наприклад, "
"властивості) і забороняти створення :attr:`~object.__dict__` і *__weakref__*"
" (якщо це явно не оголошено в *__slots__* або доступно в батьківському)."

#: ../../reference/datamodel.rst:2520
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
"Місце, збережене за допомогою :attr:`~object.__dict__` може бути значним. "
"Швидкість пошуку атрибутів також можна значно покращити."

#: ../../reference/datamodel.rst:2525
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of "
":attr:`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"Цій змінній класу можна призначити рядок, ітерацію або послідовність рядків "
"з іменами змінних, які використовуються екземплярами. *__slots__* резервує "
"місце для оголошених змінних і запобігає автоматичному створенню "
":attr:`~object.__dict__` і *__weakref__* для кожного екземпляра."

#: ../../reference/datamodel.rst:2534
msgid "Notes on using *__slots__*:"
msgstr ""

#: ../../reference/datamodel.rst:2536
msgid ""
"When inheriting from a class without *__slots__*, the "
":attr:`~object.__dict__` and *__weakref__* attribute of the instances will "
"always be accessible."
msgstr ""
"При успадкуванні від класу без *__slots__* атрибути :attr:`~object.__dict__`"
" і *__weakref__* екземплярів завжди будуть доступними."

#: ../../reference/datamodel.rst:2540
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"Без змінної :attr:`~object.__dict__` екземплярам не можна призначати нові "
"змінні, не вказані у визначенні *__slots__*. Спроби призначити змінній, яка "
"не вказана в списку, викликають помилку :exc:`AttributeError`. Якщо потрібне"
" динамічне призначення нових змінних, тоді додайте ``'__dict__'`` до "
"послідовності рядків у декларації *__slots__*."

#: ../../reference/datamodel.rst:2547
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Без змінної *__weakref__* для кожного екземпляра класи, що визначають "
"*__slots__*, не підтримують :mod:`слабкі посилання <weakref>` на його "
"екземпляри. Якщо необхідна підтримка слабких посилань, додайте "
"``'__weakref__'`` до послідовності рядків у декларації *__slots__*."

#: ../../reference/datamodel.rst:2553
msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors"
" <descriptors>` for each variable name.  As a result, class attributes "
"cannot be used to set default values for instance variables defined by "
"*__slots__*; otherwise, the class attribute would overwrite the descriptor "
"assignment."
msgstr ""
"*__slots__* реалізуються на рівні класу шляхом створення :ref:`дескрипторів "
"<descriptors>` для кожної назви змінної. Як результат, атрибути класу не "
"можна використовувати для встановлення значень за замовчуванням для змінних "
"екземплярів, визначених *__slots__*; інакше атрибут класу перезапише "
"призначення дескриптора."

#: ../../reference/datamodel.rst:2559
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it"
" is defined.  *__slots__* declared in parents are available in child "
"classes. However, instances of a child subclass will get a "
":attr:`~object.__dict__` and *__weakref__* unless the subclass also defines "
"*__slots__* (which should only contain names of any *additional* slots)."
msgstr ""

#: ../../reference/datamodel.rst:2565
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Якщо клас визначає слот, також визначений у базовому класі, змінна "
"екземпляра, визначена слотом базового класу, недоступна (за винятком "
"отримання її дескриптора безпосередньо з базового класу). Це робить значення"
" програми невизначеним. У майбутньому для запобігання цьому може бути додана"
" перевірка."

#: ../../reference/datamodel.rst:2570
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and "
":class:`tuple`."
msgstr ""

#: ../../reference/datamodel.rst:2575
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr ""
"Будь-який нерядковий :term:`iterable` може бути призначений *__slots__*."

#: ../../reference/datamodel.rst:2577
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary"
" can be used to provide per-attribute docstrings that will be recognised by "
":func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"Якщо :class:`dictionary <dict>` використовується для призначення "
"*__slots__*, ключі словника будуть використані як імена слотів. Значення "
"словника можна використовувати для надання рядків документів для кожного "
"атрибута, які розпізнаються :func:`inspect.getdoc` і відображаються у виводі"
" :func:`help`."

#: ../../reference/datamodel.rst:2582
msgid ""
":attr:`~object.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""

#: ../../reference/datamodel.rst:2585
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations"
" raise :exc:`TypeError`."
msgstr ""
":ref:`Множинне успадкування <tut-multiple>` з кількома батьківськими класами"
" зі слотами можна використовувати, але лише одному з батьківських класів "
"дозволено мати атрибути, створені слотами (інші бази повинні мати порожні "
"макети слотів) - порушення викликають :exc:`TypeError`."

#: ../../reference/datamodel.rst:2591
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"Якщо :term:`iterator` використовується для *__slots__*, то "
":term:`descriptor` створюється для кожного значення ітератора. Однак атрибут"
" *__slots__* буде порожнім ітератором."

#: ../../reference/datamodel.rst:2599
msgid "Customizing class creation"
msgstr "Налаштування створення класу"

#: ../../reference/datamodel.rst:2601
msgid ""
"Whenever a class inherits from another class, "
":meth:`~object.__init_subclass__` is called on the parent class. This way, "
"it is possible to write classes which change the behavior of subclasses. "
"This is closely related to class decorators, but where class decorators only"
" affect the specific class they're applied to, ``__init_subclass__`` solely "
"applies to future subclasses of the class defining the method."
msgstr ""
"Щоразу, коли клас успадковує інший клас, :meth:`~object.__init_subclass__` "
"викликається в батьківському класі. Таким чином можна писати класи, які "
"змінюють поведінку підкласів. Це тісно пов’язане з декораторами класів, але "
"де декоратори класів впливають лише на конкретний клас, до якого вони "
"застосовані, ``__init_subclass__`` застосовується виключно до майбутніх "
"підкласів класу, що визначає метод."

#: ../../reference/datamodel.rst:2610
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Цей метод викликається кожного разу, коли клас, що містить, є підкласом. "
"Тоді *cls* є новим підкласом. Якщо визначено як звичайний метод екземпляра, "
"цей метод неявно перетворюється на метод класу."

#: ../../reference/datamodel.rst:2614
msgid ""
"Keyword arguments which are given to a new class are passed to the parent "
"class's ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""

#: ../../reference/datamodel.rst:2620
msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""

#: ../../reference/datamodel.rst:2628
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"Реалізація за замовчуванням ``object.__init_subclass__`` нічого не робить, "
"але викликає помилку, якщо вона викликається з будь-якими аргументами."

#: ../../reference/datamodel.rst:2633
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The"
" actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"Підказка метакласу ``metaclass`` споживається рештою механізму типів і "
"ніколи не передається реалізаціям ``__init_subclass__``. Фактичний метаклас "
"(а не явна підказка) можна отримати як ``type(cls)``."

#: ../../reference/datamodel.rst:2641
msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""
"Коли клас створюється, :meth:`type.__new__` сканує змінні класу та виконує "
"зворотні виклики до тих, що мають хук :meth:`~object.__set_name__`."

#: ../../reference/datamodel.rst:2646
msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"Автоматично викликається під час створення класу власника *owner*. Об’єкту "
"було призначено *name* у цьому класі::"

#: ../../reference/datamodel.rst:2649
msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""

#: ../../reference/datamodel.rst:2652
msgid ""
"If the class variable is assigned after the class is created, "
":meth:`__set_name__` will not be called automatically. If needed, "
":meth:`__set_name__` can be called directly::"
msgstr ""
"Якщо змінна класу призначається після створення класу, :meth:`__set_name__` "
"не буде викликатися автоматично. За потреби :meth:`__set_name__` можна "
"викликати безпосередньо::"

#: ../../reference/datamodel.rst:2656
msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""

#: ../../reference/datamodel.rst:2663
msgid "See :ref:`class-object-creation` for more details."
msgstr ""
"Дивіться :ref:`class-object-creation` для отримання додаткової інформації."

#: ../../reference/datamodel.rst:2671
msgid "Metaclasses"
msgstr "Метакласи"

#: ../../reference/datamodel.rst:2678
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"За замовчуванням класи створюються за допомогою :func:`type`. Тіло класу "
"виконується в новому просторі імен, а ім’я класу прив’язується локально до "
"результату ``type(name, bases, namespace)``."

#: ../../reference/datamodel.rst:2682
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"Процес створення класу можна налаштувати, передавши аргумент ключового слова"
" ``metaclass`` у рядку визначення класу або успадкувавши від існуючого "
"класу, який містив такий аргумент. У наступному прикладі і ``MyClass``, і "
"``MySubclass`` є екземплярами ``Meta``::"

#: ../../reference/datamodel.rst:2687
msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""

#: ../../reference/datamodel.rst:2696
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Будь-які інші ключові аргументи, указані у визначенні класу, передаються до "
"всіх операцій метакласу, описаних нижче."

#: ../../reference/datamodel.rst:2699
msgid "When a class definition is executed, the following steps occur:"
msgstr "Коли виконується визначення класу, відбуваються наступні кроки:"

#: ../../reference/datamodel.rst:2701
msgid "MRO entries are resolved;"
msgstr "Записи MRO вирішено;"

#: ../../reference/datamodel.rst:2702
msgid "the appropriate metaclass is determined;"
msgstr "визначається відповідний метаклас;"

#: ../../reference/datamodel.rst:2703
msgid "the class namespace is prepared;"
msgstr "підготовлено простір імен класу;"

#: ../../reference/datamodel.rst:2704
msgid "the class body is executed;"
msgstr "виконується тіло класу;"

#: ../../reference/datamodel.rst:2705
msgid "the class object is created."
msgstr "створюється об'єкт класу."

#: ../../reference/datamodel.rst:2709
msgid "Resolving MRO entries"
msgstr "Вирішення записів MRO"

#: ../../reference/datamodel.rst:2713
msgid ""
"If a base that appears in a class definition is not an instance of "
":class:`type`, then an :meth:`!__mro_entries__` method is searched on the "
"base. If an :meth:`!__mro_entries__` method is found, the base is "
"substituted with the result of a call to :meth:`!__mro_entries__` when "
"creating the class. The method is called with the original bases tuple "
"passed to the *bases* parameter, and must return a tuple of classes that "
"will be used instead of the base. The returned tuple may be empty: in these "
"cases, the original base is ignored."
msgstr ""

#: ../../reference/datamodel.rst:2724
msgid ":func:`types.resolve_bases`"
msgstr ""

#: ../../reference/datamodel.rst:2725
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr ""

#: ../../reference/datamodel.rst:2727
msgid ":func:`types.get_original_bases`"
msgstr ""

#: ../../reference/datamodel.rst:2728
msgid ""
"Retrieve a class's \"original bases\" prior to modifications by "
":meth:`~object.__mro_entries__`."
msgstr ""

#: ../../reference/datamodel.rst:2731
msgid ":pep:`560`"
msgstr ""

#: ../../reference/datamodel.rst:2732
msgid "Core support for typing module and generic types."
msgstr ""

#: ../../reference/datamodel.rst:2736
msgid "Determining the appropriate metaclass"
msgstr "Визначення відповідного метакласу"

#: ../../reference/datamodel.rst:2740
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr "Відповідний метаклас для визначення класу визначається таким чином:"

#: ../../reference/datamodel.rst:2742
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"якщо не вказано жодних баз і явного метакласу, то використовується "
":func:`type`;"

#: ../../reference/datamodel.rst:2743
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass;"
msgstr ""
"якщо задано явний метаклас і він *не* є екземпляром :func:`type`, тоді він "
"використовується безпосередньо як метаклас;"

#: ../../reference/datamodel.rst:2745
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"якщо екземпляр :func:`type` задано як явний метаклас або визначено основи, "
"то використовується найбільш похідний метаклас."

#: ../../reference/datamodel.rst:2748
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified"
" base classes. The most derived metaclass is one which is a subtype of *all*"
" of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"Найбільш похідний метаклас вибирається з явно визначеного метакласу (якщо "
"такий є) і метакласів (тобто ``type(cls)``) усіх указаних базових класів. "
"Найбільш похідним метакласом є той, який є підтипом *усіх* цих метакласів-"
"кандидатів. Якщо жоден із метакласів-кандидатів не відповідає цьому "
"критерію, визначення класу буде невдалим із ``TypeError``."

#: ../../reference/datamodel.rst:2758
msgid "Preparing the class namespace"
msgstr "Підготовка простору імен класу"

#: ../../reference/datamodel.rst:2763
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace"
" is prepared. If the metaclass has a ``__prepare__`` attribute, it is called"
" as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"Після визначення відповідного метакласу готується простір імен класу. Якщо "
"метаклас має атрибут ``__prepare__``, він викликається як ``namespace = "
"metaclass.__prepare__(name, bases, **kwds)`` (де додаткові ключові "
"аргументи, якщо такі є, надходять із визначення класу) . Метод "
"``__prepare__`` має бути реалізований як :func:`classmethod <classmethod>`. "
"Простір імен, повернутий ``__prepare__``, передається в ``__new__``, але "
"коли створюється останній об’єкт класу, простір імен копіюється в новий "
"``dict``."

#: ../../reference/datamodel.rst:2772
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Якщо метаклас не має атрибута ``__prepare__``, тоді простір імен класу "
"ініціалізується як порожнє впорядковане відображення."

#: ../../reference/datamodel.rst:2777
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метакласи в Python 3000"

#: ../../reference/datamodel.rst:2778
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Представлено хук простору імен ``__prepare__``"

#: ../../reference/datamodel.rst:2782
msgid "Executing the class body"
msgstr "Виконання тіла класу"

#: ../../reference/datamodel.rst:2787
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"Тіло класу виконується (приблизно) як ``exec(body, globals(), namespace)``. "
"Ключова відмінність від звичайного виклику :func:`exec` полягає в тому, що "
"лексична область видимості дозволяє тілу класу (включаючи будь-які методи) "
"посилатися на імена з поточної та зовнішньої областей, коли визначення класу"
" відбувається всередині функції."

#: ../../reference/datamodel.rst:2793
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"Однак, навіть коли визначення класу відбувається всередині функції, методи, "
"визначені всередині класу, все одно не можуть бачити імена, визначені в "
"області класу. Доступ до змінних класу має здійснюватися через перший "
"параметр екземпляра або методів класу, або через неявне посилання "
"``__class__`` з лексичною областю, описане в наступному розділі."

#: ../../reference/datamodel.rst:2802
msgid "Creating the class object"
msgstr "Створення об'єкта класу"

#: ../../reference/datamodel.rst:2809
msgid ""
"Once the class namespace has been populated by executing the class body, the"
" class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"Коли простір імен класу заповнено виконанням тіла класу, об’єкт класу "
"створюється шляхом виклику ``metaclass(name, bases, namespace, **kwds)`` "
"(додаткові ключові слова, передані тут, такі самі, як ті, що передані` "
"`__prepare__``)."

#: ../../reference/datamodel.rst:2814
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on lexical"
" scoping, while the class or instance that was used to make the current call"
" is identified based on the first argument passed to the method."
msgstr ""
"Цей об’єкт класу є тим, на який посилатиметься форма :func:`super` з "
"нульовим аргументом. ``__class__`` — це неявне посилання на закриття, "
"створене компілятором, якщо будь-які методи в тілі класу посилаються на "
"``__class__`` або ``super``. Це дозволяє формі нульового аргументу "
":func:`super` правильно ідентифікувати клас, який визначається на основі "
"лексичного визначення, тоді як клас або екземпляр, який використовувався для"
" здійснення поточного виклику, ідентифікується на основі першого аргументу, "
"переданого методу."

#: ../../reference/datamodel.rst:2824
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError`"
" in Python 3.8."
msgstr ""
"У CPython 3.6 і пізніших версіях клітинка ``__class__`` передається "
"метакласу як запис ``__classcell__`` у просторі імен класу. Якщо є, це має "
"бути передано до виклику ``type.__new__`` для правильної ініціалізації "
"класу. Якщо цього не зробити, у Python 3.8 виникне :exc:`RuntimeError`."

#: ../../reference/datamodel.rst:2830
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"При використанні метакласу за замовчуванням :class:`type` або будь-якого "
"метакласу, який остаточно викликає ``type.__new__``, наступні додаткові "
"кроки налаштування викликаються після створення об’єкта класу:"

#: ../../reference/datamodel.rst:2834
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"Метод ``type.__new__`` збирає всі атрибути в просторі імен класу, які "
"визначають метод :meth:`~object.__set_name__`;"

#: ../../reference/datamodel.rst:2836
msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"Ці методи ``__set_name__`` викликаються з визначеним класом і присвоєною "
"назвою цього конкретного атрибута;"

#: ../../reference/datamodel.rst:2838
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent"
" of the new class in its method resolution order."
msgstr ""
"Хук :meth:`~object.__init_subclass__` викликається на безпосередньому "
"батькові нового класу в порядку вирішення методів."

#: ../../reference/datamodel.rst:2841
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"Після того, як об’єкт класу створено, він передається до декораторів класу, "
"включених у визначення класу (якщо такі є), і отриманий об’єкт зв’язується в"
" локальному просторі імен як визначений клас."

#: ../../reference/datamodel.rst:2845
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~type.__dict__` attribute of the class object."
msgstr ""

#: ../../reference/datamodel.rst:2852
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - Новий супер"

#: ../../reference/datamodel.rst:2853
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "Описує неявне посилання на закриття ``__class__``"

#: ../../reference/datamodel.rst:2857
msgid "Uses for metaclasses"
msgstr "Використання для метакласів"

#: ../../reference/datamodel.rst:2859
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"Можливості використання метакласів безмежні. Деякі ідеї, які були "
"досліджені, включають enum, журналювання, перевірку інтерфейсу, автоматичне "
"делегування, автоматичне створення властивостей, проксі, фреймворки та "
"автоматичне блокування/синхронізацію ресурсів."

#: ../../reference/datamodel.rst:2866
msgid "Customizing instance and subclass checks"
msgstr "Налаштування перевірок екземплярів і підкласів"

#: ../../reference/datamodel.rst:2868
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Наступні методи використовуються для заміни типової поведінки вбудованих "
"функцій :func:`isinstance` і :func:`issubclass`."

#: ../../reference/datamodel.rst:2871
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"Зокрема, метаклас :class:`abc.ABCMeta` реалізує ці методи, щоб дозволити "
"додавання абстрактних базових класів (ABC) як \"віртуальних базових класів\""
" до будь-якого класу або типу (включно з вбудованими типами), включаючи інші"
" Азбука."

#: ../../reference/datamodel.rst:2878
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Повертає true, якщо *екземпляр* слід вважати (прямим чи непрямим) "
"екземпляром *класу*. Якщо визначено, викликається для реалізації "
"``isinstance(instance, class)``."

#: ../../reference/datamodel.rst:2885
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass,"
" class)``."
msgstr ""
"Повертає true, якщо *підклас* слід вважати (прямим чи непрямим) підкласом "
"*класу*. Якщо визначено, викликається для реалізації ``issubclass(subclass, "
"class)``."

#: ../../reference/datamodel.rst:2890
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Зауважте, що ці методи шукаються за типом (метакласом) класу. Вони не можуть"
" бути визначені як методи класу в реальному класі. Це узгоджується з пошуком"
" спеціальних методів, які викликаються для екземплярів, тільки в цьому "
"випадку екземпляр сам по собі є класом."

#: ../../reference/datamodel.rst:2897
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Представляємо абстрактні базові класи"

#: ../../reference/datamodel.rst:2898
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~type.__instancecheck__` and "
":meth:`~type.__subclasscheck__`, with motivation for this functionality in "
"the context of adding Abstract Base Classes (see the :mod:`abc` module) to "
"the language."
msgstr ""

#: ../../reference/datamodel.rst:2906
msgid "Emulating generic types"
msgstr "Емуляція загальних типів"

#: ../../reference/datamodel.rst:2908
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify"
" a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"Використовуючи :term:`анотації типу <annotation>`, часто корисно "
"*параметризувати* загальний тип (:term:`generic type`) за допомогою нотації "
"Python у квадратних дужках. Наприклад, анотацію ``list[int]`` можна "
"використовувати для позначення :class:`list`, у якому всі елементи мають тип"
" :class:`int`."

#: ../../reference/datamodel.rst:2915
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - підказки типу"

#: ../../reference/datamodel.rst:2916
msgid "Introducing Python's framework for type annotations"
msgstr "Представляємо структуру Python для анотацій типів"

#: ../../reference/datamodel.rst:2918
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Загальні типи псевдонімів <types-genericalias>`"

#: ../../reference/datamodel.rst:2919
msgid "Documentation for objects representing parameterized generic classes"
msgstr ""
"Документація для об'єктів, що представляють параметризовані загальні класи"

#: ../../reference/datamodel.rst:2921
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and "
":class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`визначені користувачем узагальнення <user-defined-"
"generics>` і :class:`typing.Generic`"

#: ../../reference/datamodel.rst:2922
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Документація про те, як реалізувати загальні класи, які можна "
"параметризувати під час виконання та розуміти статичними засобами перевірки "
"типів."

#: ../../reference/datamodel.rst:2925
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""
"*Зазвичай* клас може бути параметризований, лише якщо він визначає "
"спеціальний метод класу ``__class_getitem__()``."

#: ../../reference/datamodel.rst:2930
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Повертає об’єкт, який представляє спеціалізацію загального класу за "
"аргументами типу, знайденими в *key*."

#: ../../reference/datamodel.rst:2933
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with "
":func:`@classmethod<classmethod>` when it is defined."
msgstr ""
"Коли визначено в класі, ``__class_getitem__()`` автоматично стає методом "
"класу. Таким чином, немає необхідності прикрашати його :func:`@classmethod "
"<classmethod>`, коли він визначений."

#: ../../reference/datamodel.rst:2939
msgid "The purpose of *__class_getitem__*"
msgstr "Мета *__class_getitem__*"

#: ../../reference/datamodel.rst:2941
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily"
" apply :term:`type hints<type hint>` to these classes."
msgstr ""
"Метою :meth:`~object.__class_getitem__` є можливість параметризації "
"загальних класів стандартної бібліотеки під час виконання, щоб легше "
"застосовувати :term:`підказки типу <type hint>` до цих класів."

#: ../../reference/datamodel.rst:2945
msgid ""
"To implement custom generic classes that can be parameterized at runtime and"
" understood by static type-checkers, users should either inherit from a "
"standard library class that already implements "
":meth:`~object.__class_getitem__`, or inherit from :class:`typing.Generic`, "
"which has its own implementation of ``__class_getitem__()``."
msgstr ""
"Щоб реалізувати користувальницькі загальні класи, які можна параметризувати "
"під час виконання та розуміти статичними засобами перевірки типів, "
"користувачі повинні або успадкувати від класу стандартної бібліотеки, яка "
"вже реалізує :meth:`~object.__class_getitem__`, або успадкувати від "
":class:`typing. Generic`, який має власну реалізацію "
"``__class_getitem__()``."

#: ../../reference/datamodel.rst:2951
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party"
" type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
"Спеціальні реалізації :meth:`~object.__class_getitem__` у класах, визначених"
" за межами стандартної бібліотеки, можуть бути не зрозумілі сторонніми "
"засобами перевірки типів, такими як mypy. Не рекомендується використовувати "
"``__class_getitem__()`` для будь-якого класу для цілей, відмінних від "
"підказки типу."

#: ../../reference/datamodel.rst:2961
msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* проти *__getitem__*"

#: ../../reference/datamodel.rst:2963
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"Зазвичай :ref:`підписка <subscriptions>` об’єкта з використанням квадратних "
"дужок викликає метод екземпляра :meth:`~object.__getitem__`, визначений у "
"класі об’єкта. Проте, якщо об’єкт, на який підписується, сам є класом, "
"замість нього можна викликати метод класу :meth:`~object.__class_getitem__`."
" ``__class_getitem__()`` має повертати об’єкт :ref:`GenericAlias <types-"
"genericalias>`, якщо він правильно визначений."

#: ../../reference/datamodel.rst:2970
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether "
":meth:`~object.__getitem__` or :meth:`~object.__class_getitem__` should be "
"called::"
msgstr ""
"Представлений у вигляді :term:`expression` ``obj[x]``, інтерпретатор Python "
"виконує щось на зразок наступного процесу, щоб вирішити, чи слід "
":meth:`~object.__getitem__` або :meth:`~object.__class_getitem__` бути "
"викликаним::"

#: ../../reference/datamodel.rst:2975
msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""

#: ../../reference/datamodel.rst:2998
msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have"
" the :class:`type` class as their metaclass. :class:`type` does not define "
":meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``,"
" ``dict[str, float]`` and ``tuple[str, bytes]`` all result in "
":meth:`~object.__class_getitem__` being called::"
msgstr ""
"У Python усі класи самі є екземплярами інших класів. Клас класу відомий як "
":term:`metaclass` цього класу, і більшість класів мають клас :class:`type` "
"як метаклас. :class:`type` не визначає :meth:`~object.__getitem__`, тобто "
"такі вирази, як ``list[int]``, ``dict[str, float]`` і ``tuple[str, bytes]`` "
"все призводить до виклику :meth:`~object.__class_getitem__`::"

#: ../../reference/datamodel.rst:3005
msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""

#: ../../reference/datamodel.rst:3017
msgid ""
"However, if a class has a custom metaclass that defines "
":meth:`~object.__getitem__`, subscribing the class may result in different "
"behaviour. An example of this can be found in the :mod:`enum` module::"
msgstr ""
"Однак, якщо клас має спеціальний метаклас, який визначає "
":meth:`~object.__getitem__`, підписка на клас може призвести до іншої "
"поведінки. Приклад цього можна знайти в модулі :mod:`enum`::"

#: ../../reference/datamodel.rst:3021
msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""

#: ../../reference/datamodel.rst:3040
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ""
":pep:`560` - Основна підтримка модуля введення тексту та загальних типів"

#: ../../reference/datamodel.rst:3041
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a "
":ref:`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""
"Представляємо :meth:`~object.__class_getitem__` і пояснюємо, коли "
":ref:`підписка <subscriptions>` призводить до виклику "
"``__class_getitem__()`` замість :meth:`~object.__getitem__`"

#: ../../reference/datamodel.rst:3049
msgid "Emulating callable objects"
msgstr "Емуляція викликаних об'єктів"

#: ../../reference/datamodel.rst:3056
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``. The :class:`object` class itself does not provide this method."
msgstr ""

#: ../../reference/datamodel.rst:3064
msgid "Emulating container types"
msgstr "Емуляція типів контейнерів"

#: ../../reference/datamodel.rst:3066
msgid ""
"The following methods can be defined to implement container objects. None of"
" them are provided by the :class:`object` class itself. Containers usually "
"are :term:`sequences <sequence>` (such as :class:`lists <list>` or "
":class:`tuples <tuple>`) or :term:`mappings <mapping>` (like "
":term:`dictionaries <dictionary>`), but can represent other containers as "
"well.  The first set of methods is used either to emulate a sequence or to "
"emulate a mapping; the difference is that for a sequence, the allowable keys"
" should be the integers *k* for which ``0 <= k < N`` where *N* is the length"
" of the sequence, or :class:`slice` objects, which define a range of items."
"  It is also recommended that mappings provide the methods :meth:`!keys`, "
":meth:`!values`, :meth:`!items`, :meth:`!get`, :meth:`!clear`, "
":meth:`!setdefault`, :meth:`!pop`, :meth:`!popitem`, :meth:`!copy`, and "
":meth:`!update` behaving similar to those for Python's standard "
":class:`dictionary <dict>` objects.  The :mod:`collections.abc` module "
"provides a :class:`~collections.abc.MutableMapping` :term:`abstract base "
"class` to help create those methods from a base set of "
":meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__delitem__`, and :meth:`!keys`. Mutable sequences should "
"provide methods :meth:`!append`, :meth:`!count`, :meth:`!index`, "
":meth:`!extend`, :meth:`!insert`, :meth:`!pop`, :meth:`!remove`, "
":meth:`!reverse` and :meth:`!sort`, like Python standard :class:`list` "
"objects. Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`~object.__add__`, :meth:`~object.__radd__`, "
":meth:`~object.__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` "
"and :meth:`~object.__imul__` described below; they should not define other "
"numerical operators.  It is recommended that both mappings and sequences "
"implement the :meth:`~object.__contains__` method to allow efficient use of "
"the ``in`` operator; for mappings, ``in`` should search the mapping's keys; "
"for sequences, it should search through the values.  It is further "
"recommended that both mappings and sequences implement the "
":meth:`~object.__iter__` method to allow efficient iteration through the "
"container; for mappings, :meth:`!__iter__` should iterate through the "
"object's keys; for sequences, it should iterate through the values."
msgstr ""

#: ../../reference/datamodel.rst:3108
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`~object.__bool__` method and whose :meth:`!__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""

#: ../../reference/datamodel.rst:3115
msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If the"
" length is larger than :data:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`~object.__bool__` method."
msgstr ""

#: ../../reference/datamodel.rst:3124
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated"
" length for the object (which may be greater or less than the actual "
"length). The length must be an integer ``>=`` 0. The return value may also "
"be :data:`NotImplemented`, which is treated the same as if the "
"``__length_hint__`` method didn't exist at all. This method is purely an "
"optimization and is never required for correctness."
msgstr ""

#: ../../reference/datamodel.rst:3138
msgid ""
"Slicing is done exclusively with the following three methods.  A call like "
"::"
msgstr "Нарізка виконується виключно трьома способами. Дзвінок типу ::"

#: ../../reference/datamodel.rst:3140
msgid "a[1:2] = b"
msgstr ""

#: ../../reference/datamodel.rst:3142
msgid "is translated to ::"
msgstr "перекладається на ::"

#: ../../reference/datamodel.rst:3144
msgid "a[slice(1, 2, None)] = b"
msgstr ""

#: ../../reference/datamodel.rst:3146
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "і так далі. Відсутні елементи фрагмента завжди заповнюються ``None``."

#: ../../reference/datamodel.rst:3151
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types,"
" the accepted keys should be integers. Optionally, they may support "
":class:`slice` objects as well.  Negative index support is also optional. If"
" *key* is of an inappropriate type, :exc:`TypeError` may be raised; if *key*"
" is a value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For "
":term:`mapping` types, if *key* is missing (not in the container), "
":exc:`KeyError` should be raised."
msgstr ""

#: ../../reference/datamodel.rst:3163
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` цикли очікують, що :exc:`IndexError` буде викликано для "
"недопустимих індексів, щоб забезпечити належне виявлення кінця "
"послідовності."

#: ../../reference/datamodel.rst:3168
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method "
":meth:`~object.__class_getitem__` may be called instead of "
"``__getitem__()``. See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"Коли :ref:`індексує <subscriptions>` *клас*, спеціальний метод класу "
":meth:`~object.__class_getitem__` може викликатися замість "
"``__getitem__()``. Перегляньте :ref:`classgetitem-versus-getitem` для "
"отримання додаткової інформації."

#: ../../reference/datamodel.rst:3176
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support changes to the values for keys, or if new keys can be added,"
" or for sequences if elements can be replaced.  The same exceptions should "
"be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Викликається для реалізації призначення ``self[key]``. Така сама примітка, "
"як і для :meth:`__getitem__`. Це має бути реалізовано лише для відображень, "
"якщо об’єкти підтримують зміни значень для ключів, або якщо можна додати "
"нові ключі, або для послідовностей, якщо елементи можна замінити. Для "
"неправильних значень *key* мають бути викликані ті самі винятки, що й для "
"методу :meth:`__getitem__`."

#: ../../reference/datamodel.rst:3185
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the "
"objects support removal of keys, or for sequences if elements can be removed"
" from the sequence.  The same exceptions should be raised for improper *key*"
" values as for the :meth:`__getitem__` method."
msgstr ""
"Викликається для реалізації видалення ``self[key]``. Така сама примітка, як "
"і для :meth:`__getitem__`. Це слід застосовувати лише для відображень, якщо "
"об’єкти підтримують видалення ключів, або для послідовностей, якщо елементи "
"можна видалити з послідовності. Для неправильних значень *key* мають бути "
"викликані ті самі винятки, що й для методу :meth:`__getitem__`."

#: ../../reference/datamodel.rst:3194
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]``"
" for dict subclasses when key is not in the dictionary."
msgstr ""
"Викликається :class:`dict`\\ .\\ :meth:`__getitem__` для реалізації "
"``self[key]`` для підкласів dict, коли ключа немає в словнику."

#: ../../reference/datamodel.rst:3200
msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys"
" of the container."
msgstr ""
"Цей метод викликається, коли для контейнера потрібен :term:`iterator`. Цей "
"метод має повертати новий об’єкт-ітератор, який може виконувати ітерацію по "
"всіх об’єктах у контейнері. Для зіставлення він повинен перебирати ключі "
"контейнера."

#: ../../reference/datamodel.rst:3208
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Викликається (якщо є) вбудованим :func:`reversed` для реалізації зворотної "
"ітерації. Він має повернути новий об’єкт-ітератор, який обходить усі об’єкти"
" в контейнері у зворотному порядку."

#: ../../reference/datamodel.rst:3212
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and "
":meth:`__getitem__`).  Objects that support the sequence protocol should "
"only provide :meth:`__reversed__` if they can provide an implementation that"
" is more efficient than the one provided by :func:`reversed`."
msgstr ""
"Якщо метод :meth:`__reversed__` не надано, вбудований :func:`reversed` "
"повернеться до використання протоколу послідовності (:meth:`__len__` і "
":meth:`__getitem__`). Об’єкти, які підтримують протокол послідовності, "
"повинні надавати лише :meth:`__reversed__`, якщо вони можуть забезпечити "
"ефективнішу реалізацію, ніж та, яку надає :func:`reversed`."

#: ../../reference/datamodel.rst:3219
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container"
" objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Оператори перевірки членства (:keyword:`in` і :keyword:`not in`) зазвичай "
"реалізуються як ітерація через контейнер. Однак об’єкти-контейнери можуть "
"надавати наступний спеціальний метод з більш ефективною реалізацією, яка "
"також не вимагає, щоб об’єкт був повторюваним."

#: ../../reference/datamodel.rst:3226
msgid ""
"Called to implement membership test operators.  Should return true if *item*"
" is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Викликано реалізувати оператори перевірки членства. Має повертати true, якщо"
" *item* знаходиться в *self*, і false в іншому випадку. Для відображення "
"об’єктів це має враховувати ключі відображення, а не значення або пари ключ-"
"елемент."

#: ../../reference/datamodel.rst:3230
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"Для об’єктів, які не визначають :meth:`__contains__`, тест на приналежність "
"спочатку намагається виконати ітерацію через :meth:`__iter__`, потім старий "
"протокол ітерації послідовності через :meth:`__getitem__`, див. :ref:`цей "
"розділ у посилання на мову <membership-test-details>`."

#: ../../reference/datamodel.rst:3239
msgid "Emulating numeric types"
msgstr "Емуляція числових типів"

#: ../../reference/datamodel.rst:3241
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of"
" number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Наступні методи можна визначити для емуляції числових об’єктів. Методи, що "
"відповідають операціям, які не підтримуються конкретним видом реалізованого "
"числа (наприклад, побітові операції для нецілісних чисел), слід залишити "
"невизначеними."

#: ../../reference/datamodel.rst:3267
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to"
" evaluate the expression ``x + y``, where *x* is an instance of a class that"
" has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is called.  The "
":meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to accept "
"an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""

#: ../../reference/datamodel.rst:3278
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:3301
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of "
"different types. [#]_ For instance, to evaluate the expression ``x - y``, "
"where *y* is an instance of a class that has an :meth:`__rsub__` method, "
"``type(y).__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` returns "
":data:`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:3313
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"Зауважте, що тернарний :func:`pow` не намагатиметься викликати "
":meth:`__rpow__` (правила примусу стануть надто складними)."

#: ../../reference/datamodel.rst:3318
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Якщо тип правого операнда є підкласом типу лівого операнда і цей підклас "
"забезпечує іншу реалізацію відображеного методу для операції, цей метод буде"
" викликаний перед невідображеним методом лівого операнда. Така поведінка "
"дозволяє підкласам перевизначати операції своїх предків."

#: ../../reference/datamodel.rst:3339
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be,"
" but does not have to be, *self*).  If a specific method is not defined, or "
"if that method returns :data:`NotImplemented`, the augmented assignment "
"falls back to the normal methods.  For instance, if *x* is an instance of a "
"class with an :meth:`__iadd__` method, ``x += y`` is equivalent to ``x = "
"x.__iadd__(y)`` . If :meth:`__iadd__` does not exist, or if "
"``x.__iadd__(y)`` returns :data:`!NotImplemented`, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""

#: ../../reference/datamodel.rst:3362
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr ""
"Викликається для реалізації унарних арифметичних операцій (``-``, ``+``, "
":func:`abs` і ``~``)."

#: ../../reference/datamodel.rst:3375
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and "
":func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Викликається для реалізації вбудованих функцій :func:`complex`, :func:`int` "
"і :func:`float`. Має повертати значення відповідного типу."

#: ../../reference/datamodel.rst:3382
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Викликається для реалізації :func:`operator.index` і кожного разу, коли "
"Python потребує без втрат перетворити числовий об’єкт у цілочисельний об’єкт"
" (наприклад, у зрізі або у вбудованих :func:`bin`, :func:`hex` і "
":func:`oct`). Наявність цього методу вказує на те, що числовий об'єкт є "
"цілим типом. Має повертати ціле число."

#: ../../reference/datamodel.rst:3388
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` and"
" :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Якщо :meth:`__int__`, :meth:`__float__` і :meth:`__complex__` не визначено, "
"то відповідні вбудовані функції :func:`int`, :func:`float` і :func:`complex`"
" повернутися до :meth:`__index__`."

#: ../../reference/datamodel.rst:3400
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Викликається для реалізації вбудованої функції :func:`round` і :mod:`math` "
"функції :func:`~math.trunc`, :func:`~math.floor` і :func:`~math.ceil`. Якщо "
"*ndigits* не передано в :meth:`!__round__`, усі ці методи повинні повертати "
"значення об’єкта, усічене до :class:`~numbers.Integral` (зазвичай "
":class:`int`)."

#: ../../reference/datamodel.rst:3406
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if neither"
" :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""
"Вбудована функція :func:`int` повертається до :meth:`__trunc__`, якщо не "
"визначено ні :meth:`__int__`, ні :meth:`__index__`."

#: ../../reference/datamodel.rst:3409
msgid "The delegation of :func:`int` to :meth:`__trunc__` is deprecated."
msgstr ""

#: ../../reference/datamodel.rst:3416
msgid "With Statement Context Managers"
msgstr "З менеджерами контексту операторів"

#: ../../reference/datamodel.rst:3418
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be"
" established when executing a :keyword:`with` statement. The context manager"
" handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but"
" can also be used by directly invoking their methods."
msgstr ""
":dfn:`context manager` — це об’єкт, який визначає контекст виконання, який "
"буде встановлено під час виконання оператора :keyword:`with`. Менеджер "
"контексту керує входом і виходом з потрібного контексту виконання для "
"виконання блоку коду. Менеджери контексту зазвичай викликаються за допомогою"
" оператора :keyword:`!with` (описаного в розділі :ref:`with`), але їх також "
"можна використовувати шляхом безпосереднього виклику їхніх методів."

#: ../../reference/datamodel.rst:3429
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Типове використання контекстних менеджерів включає збереження та відновлення"
" різних видів глобального стану, блокування та розблокування ресурсів, "
"закриття відкритих файлів тощо."

#: ../../reference/datamodel.rst:3432
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`. The"
" :class:`object` class itself does not provide the context manager methods."
msgstr ""

#: ../../reference/datamodel.rst:3438
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in"
" the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Введіть контекст виконання, пов’язаний із цим об’єктом. Оператор "
":keyword:`with` прив’яже значення, що повертається цим методом, до "
"цілей(ів), указаних у пункті :keyword:`!as` оператора, якщо такий є."

#: ../../reference/datamodel.rst:3445
msgid ""
"Exit the runtime context related to this object. The parameters describe the"
" exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Вийти з контексту виконання, пов’язаного з цим об’єктом. Параметри описують "
"виняток, який спричинив вихід із контексту. Якщо контекст вийшов без "
"винятку, усі три аргументи будуть :const:`None`."

#: ../../reference/datamodel.rst:3449
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception"
" (i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Якщо надається виняток, і метод хоче придушити виняток (тобто запобігти його"
" розповсюдженню), він повинен повернути істинне значення. В іншому випадку "
"виняток буде оброблено звичайним чином після виходу з цього методу."

#: ../../reference/datamodel.rst:3453
msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: ../../reference/datamodel.rst:3459
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - оператор \"з\"."

#: ../../reference/datamodel.rst:3460
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"Специфікація, передумови та приклади оператора Python :keyword:`with`."

#: ../../reference/datamodel.rst:3467
msgid "Customizing positional arguments in class pattern matching"
msgstr "Налаштування позиційних аргументів у відповідності шаблону класу"

#: ../../reference/datamodel.rst:3469
msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid"
" without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""

#: ../../reference/datamodel.rst:3476
msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent"
" to setting it to ``()``."
msgstr ""
"Цій змінній класу можна призначити кортеж рядків. Коли цей клас "
"використовується в шаблоні класу з позиційними аргументами, кожен позиційний"
" аргумент буде перетворено в аргумент ключового слова, використовуючи "
"відповідне значення в *__match_args__* як ключове слово. Відсутність цього "
"атрибута еквівалентна встановленню для нього значення ``()``."

#: ../../reference/datamodel.rst:3482
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a "
":exc:`TypeError`."
msgstr ""
"Наприклад, якщо ``MyClass.__match_args__`` є ``(\"left\", \"center\", "
"\"right\")``, це означає, що ``case MyClass(x, y)`` еквівалентний ``case "
"MyClass (ліворуч=x, центр=y)``. Зверніть увагу, що кількість аргументів у "
"шаблоні має бути меншою або дорівнювати кількості елементів у "
"*__match_args__*; якщо він більший, спроба збігу шаблону викличе "
":exc:`TypeError`."

#: ../../reference/datamodel.rst:3492
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - зіставлення структурних шаблонів"

#: ../../reference/datamodel.rst:3493
msgid "The specification for the Python ``match`` statement."
msgstr "Специфікація оператора ``match`` Python."

#: ../../reference/datamodel.rst:3499
msgid "Emulating buffer types"
msgstr ""

#: ../../reference/datamodel.rst:3501
msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python objects"
" to expose efficient access to a low-level memory array. This protocol is "
"implemented by builtin types such as :class:`bytes` and :class:`memoryview`,"
" and third-party libraries may define additional buffer types."
msgstr ""

#: ../../reference/datamodel.rst:3506
msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""

#: ../../reference/datamodel.rst:3511
msgid ""
"Called when a buffer is requested from *self* (for example, by the "
":class:`memoryview` constructor). The *flags* argument is an integer "
"representing the kind of buffer requested, affecting for example whether the"
" returned buffer is read-only or writable. :class:`inspect.BufferFlags` "
"provides a convenient way to interpret the flags. The method must return a "
":class:`memoryview` object."
msgstr ""

#: ../../reference/datamodel.rst:3520
msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is a "
":class:`memoryview` object that was previously returned by "
":meth:`~object.__buffer__`. The method must release any resources associated"
" with the buffer. This method should return ``None``. Buffer objects that do"
" not need to perform any cleanup are not required to implement this method."
msgstr ""

#: ../../reference/datamodel.rst:3531
msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ""

#: ../../reference/datamodel.rst:3532
msgid ""
"Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr ""

#: ../../reference/datamodel.rst:3534
msgid ":class:`collections.abc.Buffer`"
msgstr ""

#: ../../reference/datamodel.rst:3535
msgid "ABC for buffer types."
msgstr ""

#: ../../reference/datamodel.rst:3540
msgid "Special method lookup"
msgstr "Спеціальний метод пошуку"

#: ../../reference/datamodel.rst:3542
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"Для користувальницьких класів неявні виклики спеціальних методів гарантовано"
" працюють правильно, лише якщо вони визначені для типу об’єкта, а не в "
"словнику екземплярів об’єкта. Така поведінка є причиною того, що наступний "
"код викликає виняток::"

#: ../../reference/datamodel.rst:3547
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""

#: ../../reference/datamodel.rst:3557
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"Обґрунтування такої поведінки полягає в ряді спеціальних методів, таких як "
":meth:`~object.__hash__` і :meth:`~object.__repr__`, які реалізуються всіма "
"об’єктами, включаючи об’єкти типу. Якби неявний пошук цих методів "
"використовував звичайний процес пошуку, вони зазнали б помилки під час "
"виклику в самому об’єкті типу:"

#: ../../reference/datamodel.rst:3564
msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""

#: ../../reference/datamodel.rst:3571
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is"
" sometimes referred to as 'metaclass confusion', and is avoided by bypassing"
" the instance when looking up special methods::"
msgstr ""
"Неправильна спроба викликати незв’язаний метод класу таким чином іноді "
"називається \"плутаниною метакласу\", і її можна уникнути шляхом обходу "
"екземпляра під час пошуку спеціальних методів:"

#: ../../reference/datamodel.rst:3575
msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""

#: ../../reference/datamodel.rst:3580
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"Окрім обходу будь-яких атрибутів екземпляра в інтересах коректності, неявний"
" пошук спеціального методу зазвичай також обходить метод "
":meth:`~object.__getattribute__` навіть метакласу об’єкта::"

#: ../../reference/datamodel.rst:3584
msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""

#: ../../reference/datamodel.rst:3606
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"Обхід механізму :meth:`~object.__getattribute__` у такий спосіб забезпечує "
"значні можливості для оптимізації швидкості в інтерпретаторі за рахунок "
"певної гнучкості в обробці спеціальних методів (спеціальний метод *має* бути"
" встановлений на об’єкті класу сам для того, щоб бути послідовно викликаним "
"інтерпретатором)."

#: ../../reference/datamodel.rst:3617
msgid "Coroutines"
msgstr "Співпрограми"

#: ../../reference/datamodel.rst:3621
msgid "Awaitable Objects"
msgstr "Очікувані об'єкти"

#: ../../reference/datamodel.rst:3623
msgid ""
"An :term:`awaitable` object generally implements an "
":meth:`~object.__await__` method. :term:`Coroutine objects <coroutine>` "
"returned from :keyword:`async def` functions are awaitable."
msgstr ""
"Об’єкт :term:`awaitable` зазвичай реалізує метод :meth:`~object.__await__`. "
":term:`Очікуються об’єкти співпрограми <coroutine>`, повернуті функціями "
":keyword:`async def`."

#: ../../reference/datamodel.rst:3629
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not implement "
":meth:`~object.__await__`."
msgstr ""

#: ../../reference/datamodel.rst:3635
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` implements"
" this method to be compatible with the :keyword:`await` expression. The "
":class:`object` class itself is not awaitable and does not provide this "
"method."
msgstr ""

#: ../../reference/datamodel.rst:3643
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework (e.g."
" :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""

#: ../../reference/datamodel.rst:3651
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` для додаткової інформації про очікувані об’єкти."

#: ../../reference/datamodel.rst:3657
msgid "Coroutine Objects"
msgstr "Об’єкти співпрограми"

#: ../../reference/datamodel.rst:3659
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__`"
" and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's "
":attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines"
" should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Об’єкти співпрограми <coroutine>` є :term:`awaitable` об’єктами. "
"Виконання співпрограми можна контролювати викликом :meth:`~object.__await__`"
" і повторенням результату. Коли співпрограма завершує виконання та "
"повертається, ітератор викликає :exc:`StopIteration`, а атрибут винятку "
":attr:`~StopIteration.value` зберігає значення, що повертається. Якщо "
"співпрограма викликає виключення, воно поширюється ітератором. Співпрограми "
"не повинні безпосередньо викликати необроблені винятки :exc:`StopIteration`."

#: ../../reference/datamodel.rst:3667
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"Співпрограми також мають наведені нижче методи, аналогічні генераторам (див."
" :ref:`generator-methods`). Однак, на відміну від генераторів, співпрограми "
"безпосередньо не підтримують ітерацію."

#: ../../reference/datamodel.rst:3671
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""
"Це :exc:`RuntimeError`, якщо очікувати в співпрограмі більше одного разу."

#: ../../reference/datamodel.rst:3677
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by "
":meth:`~object.__await__`.  If *value* is not ``None``, this method "
"delegates to the :meth:`~generator.send` method of the iterator that caused "
"the coroutine to suspend.  The result (return value, :exc:`StopIteration`, "
"or other exception) is the same as when iterating over the "
":meth:`!__await__` return value, described above."
msgstr ""

#: ../../reference/datamodel.rst:3688
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating over"
" the :meth:`~object.__await__` return value, described above.  If the "
"exception is not caught in the coroutine, it propagates back to the caller."
msgstr ""
"Викликає вказаний виняток у співпрограмі. Цей метод делегує метод "
":meth:`~generator.throw` ітератора, який викликав призупинення співпрограми,"
" якщо він має такий метод. В іншому випадку виняток виникає в точці "
"призупинення. Результат (повернене значення, :exc:`StopIteration` або інший "
"виняток) такий самий, як і під час ітерації по поверненому значенню "
":meth:`~object.__await__`, описаному вище. Якщо виняток не перехоплюється "
"співпрограмою, він поширюється назад до абонента."

#: ../../reference/datamodel.rst:3699
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""

#: ../../reference/datamodel.rst:3704
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine"
" is marked as having finished executing, even if it was never started."
msgstr ""
"Примушує співпрограму самоочиститися та завершити роботу. Якщо співпрограму "
"призупинено, цей метод спочатку делегує метод :meth:`~generator.close` "
"ітератора, який викликав призупинення співпрограми, якщо він має такий "
"метод. Потім він викликає :exc:`GeneratorExit` у точці призупинення, "
"змушуючи співпрограму негайно очищатися. Нарешті, співпрограма позначається "
"як завершена, навіть якщо вона ніколи не запускалася."

#: ../../reference/datamodel.rst:3712
msgid ""
"Coroutine objects are automatically closed using the above process when they"
" are about to be destroyed."
msgstr ""
"Об’єкти співпрограми автоматично закриваються за допомогою описаного вище "
"процесу, коли їх збираються знищити."

#: ../../reference/datamodel.rst:3718
msgid "Asynchronous Iterators"
msgstr "Асинхронні ітератори"

#: ../../reference/datamodel.rst:3720
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"*Асинхронний ітератор* може викликати асинхронний код у своєму методі "
"``__anext__``."

#: ../../reference/datamodel.rst:3723
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""
"Асинхронні ітератори можна використовувати в операторі :keyword:`async for`."

#: ../../reference/datamodel.rst:3725 ../../reference/datamodel.rst:3774
msgid "The :class:`object` class itself does not provide these methods."
msgstr ""

#: ../../reference/datamodel.rst:3730
msgid "Must return an *asynchronous iterator* object."
msgstr "Має повертати об’єкт *асинхронного ітератора*."

#: ../../reference/datamodel.rst:3734
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Має повернути *waitable*, що призводить до наступного значення ітератора. "
"Має викликати помилку :exc:`StopAsyncIteration` після завершення ітерації."

#: ../../reference/datamodel.rst:3737
msgid "An example of an asynchronous iterable object::"
msgstr "Приклад асинхронного ітерованого об'єкта::"

#: ../../reference/datamodel.rst:3739
msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""

#: ../../reference/datamodel.rst:3754
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"До Python 3.7 :meth:`~object.__aiter__` міг повертати *waitable*, який "
"перетворювався на :term:`асинхронний ітератор <asynchronous iterator>`."

#: ../../reference/datamodel.rst:3759
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a "
":exc:`TypeError` error."
msgstr ""
"Починаючи з Python 3.7, :meth:`~object.__aiter__` має повертати об’єкт "
"асинхронного ітератора. Повернення чогось іншого призведе до помилки "
":exc:`TypeError`."

#: ../../reference/datamodel.rst:3767
msgid "Asynchronous Context Managers"
msgstr "Менеджери асинхронного контексту"

#: ../../reference/datamodel.rst:3769
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*Асинхронний контекстний менеджер* — це *контекстний менеджер*, який може "
"призупинити виконання своїх методів ``__aenter__`` і ``__aexit__``."

#: ../../reference/datamodel.rst:3772
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Асинхронні менеджери контексту можна використовувати в операторі "
":keyword:`async with`."

#: ../../reference/datamodel.rst:3778
msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference being"
" that it must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:3783
msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:3786
msgid "An example of an asynchronous context manager class::"
msgstr "Приклад класу диспетчера асинхронного контексту::"

#: ../../reference/datamodel.rst:3788
msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""

#: ../../reference/datamodel.rst:3799
msgid "Footnotes"
msgstr "Виноски"

#: ../../reference/datamodel.rst:3800
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"У деяких випадках *можливо* змінити тип об’єкта за певних контрольованих "
"умов. Загалом це не дуже гарна ідея, оскільки це може призвести до дуже "
"дивної поведінки, якщо з ним поводитись неправильно."

#: ../../reference/datamodel.rst:3804
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, "
":meth:`~object.__reversed__`, :meth:`~object.__contains__`, "
":meth:`~object.__class_getitem__` and :meth:`~os.PathLike.__fspath__` "
"methods have special handling for this. Others will still raise a "
":exc:`TypeError`, but may do so by relying on the behavior that ``None`` is "
"not callable."
msgstr ""

#: ../../reference/datamodel.rst:3811
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns :data:`NotImplemented`.  Do not set the method to ``None`` if"
" you want to force fallback to the right operand's reflected method—that "
"will instead have the opposite effect of explicitly *blocking* such "
"fallback."
msgstr ""

#: ../../reference/datamodel.rst:3817
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not called."
msgstr ""
"Для операндів одного типу передбачається, що якщо невідбитий метод, "
"наприклад :meth:`~object.__add__`, завершується помилкою, тоді загальна "
"операція не підтримується, тому відображений метод не викликається ."

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:152
#: ../../reference/datamodel.rst:163 ../../reference/datamodel.rst:184
#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:229
#: ../../reference/datamodel.rst:250 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:328 ../../reference/datamodel.rst:363
#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:409
#: ../../reference/datamodel.rst:427 ../../reference/datamodel.rst:447
#: ../../reference/datamodel.rst:455 ../../reference/datamodel.rst:466
#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:519
#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:661
#: ../../reference/datamodel.rst:799 ../../reference/datamodel.rst:823
#: ../../reference/datamodel.rst:859 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:1265 ../../reference/datamodel.rst:1292
#: ../../reference/datamodel.rst:1364 ../../reference/datamodel.rst:1472
#: ../../reference/datamodel.rst:1581 ../../reference/datamodel.rst:1691
#: ../../reference/datamodel.rst:2116 ../../reference/datamodel.rst:3134
msgid "object"
msgstr "об'єкт"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:126
msgid "data"
msgstr "даних"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:343 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:799
#: ../../reference/datamodel.rst:1321 ../../reference/datamodel.rst:1774
#: ../../reference/datamodel.rst:2017 ../../reference/datamodel.rst:2023
#: ../../reference/datamodel.rst:2116 ../../reference/datamodel.rst:2673
#: ../../reference/datamodel.rst:3104 ../../reference/datamodel.rst:3262
#: ../../reference/datamodel.rst:3297 ../../reference/datamodel.rst:3311
#: ../../reference/datamodel.rst:3360 ../../reference/datamodel.rst:3370
#: ../../reference/datamodel.rst:3398
msgid "built-in function"
msgstr "вбудована функція"

#: ../../reference/datamodel.rst:23
msgid "id"
msgstr "id"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:126
#: ../../reference/datamodel.rst:2673
msgid "type"
msgstr "тип"

#: ../../reference/datamodel.rst:23
msgid "identity of an object"
msgstr ""

#: ../../reference/datamodel.rst:23
msgid "value of an object"
msgstr ""

#: ../../reference/datamodel.rst:23
msgid "type of an object"
msgstr ""

#: ../../reference/datamodel.rst:23
msgid "mutable object"
msgstr ""

#: ../../reference/datamodel.rst:23
msgid "immutable object"
msgstr ""

#: ../../reference/datamodel.rst:60
msgid "garbage collection"
msgstr "збір сміття"

#: ../../reference/datamodel.rst:60
msgid "reference counting"
msgstr ""

#: ../../reference/datamodel.rst:60
msgid "unreachable object"
msgstr ""

#: ../../reference/datamodel.rst:95 ../../reference/datamodel.rst:1126
msgid "container"
msgstr ""

#: ../../reference/datamodel.rst:126
msgid "hierarchy"
msgstr ""

#: ../../reference/datamodel.rst:126
msgid "extension"
msgstr ""

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:400
#: ../../reference/datamodel.rst:401 ../../reference/datamodel.rst:502
#: ../../reference/datamodel.rst:859 ../../reference/datamodel.rst:879
#: ../../reference/datamodel.rst:1321
msgid "module"
msgstr "модуль"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:799
msgid "C"
msgstr "C"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:799
msgid "language"
msgstr ""

#: ../../reference/datamodel.rst:139 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:1144 ../../reference/datamodel.rst:1265
#: ../../reference/datamodel.rst:1285
msgid "attribute"
msgstr "атрибут"

#: ../../reference/datamodel.rst:139
msgid "special"
msgstr ""

#: ../../reference/datamodel.rst:139
msgid "generic"
msgstr ""

#: ../../reference/datamodel.rst:184
msgid "..."
msgstr ""

#: ../../reference/datamodel.rst:184
msgid "ellipsis literal"
msgstr ""

#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:1292
msgid "numeric"
msgstr "числовий"

#: ../../reference/datamodel.rst:229 ../../reference/datamodel.rst:235
#: ../../reference/datamodel.rst:343
msgid "integer"
msgstr "ціле число"

#: ../../reference/datamodel.rst:235
msgid "representation"
msgstr ""

#: ../../reference/datamodel.rst:250
msgid "Boolean"
msgstr "Булевий"

#: ../../reference/datamodel.rst:250
msgid "False"
msgstr "помилковий"

#: ../../reference/datamodel.rst:250
msgid "True"
msgstr "правда"

#: ../../reference/datamodel.rst:265
msgid "floating-point"
msgstr ""

#: ../../reference/datamodel.rst:265 ../../reference/datamodel.rst:283
msgid "number"
msgstr "номер"

#: ../../reference/datamodel.rst:265
msgid "Java"
msgstr ""

#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:3370
msgid "complex"
msgstr ""

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:3104
msgid "len"
msgstr ""

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:1292
msgid "sequence"
msgstr "послідовність"

#: ../../reference/datamodel.rst:296
msgid "index operation"
msgstr ""

#: ../../reference/datamodel.rst:296
msgid "item selection"
msgstr ""

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:388
#: ../../reference/datamodel.rst:466
msgid "subscription"
msgstr ""

#: ../../reference/datamodel.rst:311 ../../reference/datamodel.rst:388
msgid "slicing"
msgstr ""

#: ../../reference/datamodel.rst:328
msgid "immutable sequence"
msgstr ""

#: ../../reference/datamodel.rst:328
msgid "immutable"
msgstr "незмінний"

#: ../../reference/datamodel.rst:339 ../../reference/datamodel.rst:1992
#: ../../reference/datamodel.rst:2023
msgid "string"
msgstr "рядок"

#: ../../reference/datamodel.rst:339
msgid "immutable sequences"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "chr"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "ord"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "character"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "Unicode"
msgstr "Unicode"

#: ../../reference/datamodel.rst:363
msgid "tuple"
msgstr "кортеж"

#: ../../reference/datamodel.rst:363
msgid "singleton"
msgstr ""

#: ../../reference/datamodel.rst:363
msgid "empty"
msgstr ""

#: ../../reference/datamodel.rst:376 ../../reference/datamodel.rst:2017
msgid "bytes"
msgstr "байтів"

#: ../../reference/datamodel.rst:376
msgid "byte"
msgstr ""

#: ../../reference/datamodel.rst:388
msgid "mutable sequence"
msgstr ""

#: ../../reference/datamodel.rst:388
msgid "mutable"
msgstr "мінливий"

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:1144
#: ../../reference/datamodel.rst:1285
msgid "assignment"
msgstr ""

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:859
#: ../../reference/datamodel.rst:1728 ../../reference/datamodel.rst:1910
#: ../../reference/datamodel.rst:3425
msgid "statement"
msgstr "заява"

#: ../../reference/datamodel.rst:400
msgid "array"
msgstr "масив"

#: ../../reference/datamodel.rst:401
msgid "collections"
msgstr "колекції"

#: ../../reference/datamodel.rst:409
msgid "list"
msgstr "список"

#: ../../reference/datamodel.rst:416
msgid "bytearray"
msgstr ""

#: ../../reference/datamodel.rst:427
msgid "set type"
msgstr ""

#: ../../reference/datamodel.rst:447
msgid "set"
msgstr "встановити"

#: ../../reference/datamodel.rst:455
msgid "frozenset"
msgstr ""

#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:1292
msgid "mapping"
msgstr "відображення"

#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:2116
msgid "dictionary"
msgstr "словник"

#: ../../reference/datamodel.rst:502
msgid "dbm.ndbm"
msgstr ""

#: ../../reference/datamodel.rst:502
msgid "dbm.gnu"
msgstr ""

#: ../../reference/datamodel.rst:519
msgid "callable"
msgstr "викликний"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:534
#: ../../reference/datamodel.rst:743 ../../reference/datamodel.rst:761
#: ../../reference/datamodel.rst:774 ../../reference/datamodel.rst:799
msgid "function"
msgstr "функція"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:1149 ../../reference/datamodel.rst:3054
msgid "call"
msgstr "виклик"

#: ../../reference/datamodel.rst:519
msgid "invocation"
msgstr ""

#: ../../reference/datamodel.rst:519
msgid "argument"
msgstr "аргумент"

#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:661
msgid "user-defined"
msgstr ""

#: ../../reference/datamodel.rst:534
msgid "user-defined function"
msgstr ""

#: ../../reference/datamodel.rst:547
msgid "__closure__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:547
msgid "__globals__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:547
msgid "global"
msgstr ""

#: ../../reference/datamodel.rst:547 ../../reference/datamodel.rst:879
msgid "namespace"
msgstr "простір імен"

#: ../../reference/datamodel.rst:574
msgid "__doc__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__name__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__module__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__dict__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__defaults__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__code__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__annotations__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__kwdefaults__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__type_params__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:661 ../../reference/datamodel.rst:823
msgid "method"
msgstr "метод"

#: ../../reference/datamodel.rst:661
msgid "user-defined method"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__func__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__self__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__doc__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__name__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__module__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:743 ../../reference/datamodel.rst:1472
msgid "generator"
msgstr "generator"

#: ../../reference/datamodel.rst:743
msgid "iterator"
msgstr "ітератор"

#: ../../reference/datamodel.rst:761 ../../reference/datamodel.rst:3613
msgid "coroutine"
msgstr "coroutine"

#: ../../reference/datamodel.rst:774
msgid "asynchronous generator"
msgstr "асинхронний генератор"

#: ../../reference/datamodel.rst:774
msgid "asynchronous iterator"
msgstr "асинхронний ітератор"

#: ../../reference/datamodel.rst:823
msgid "built-in method"
msgstr ""

#: ../../reference/datamodel.rst:823
msgid "built-in"
msgstr ""

#: ../../reference/datamodel.rst:859
msgid "import"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__name__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__spec__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__package__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__loader__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__path__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__file__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__cached__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__doc__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__annotations__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1094
msgid "__dict__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1144
#: ../../reference/datamodel.rst:1265 ../../reference/datamodel.rst:1893
#: ../../reference/datamodel.rst:2784
msgid "class"
msgstr "клас"

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1265
#: ../../reference/datamodel.rst:1285
msgid "class instance"
msgstr ""

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1265
#: ../../reference/datamodel.rst:3054
msgid "instance"
msgstr ""

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1149
msgid "class object"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__name__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__module__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__dict__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__bases__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__doc__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__annotations__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__type_params__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__static_attributes__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__firstlineno__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1303
msgid "__dict__ (instance attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1303
msgid "__class__ (instance attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "open"
msgstr "ВІДЧИНЕНО"

#: ../../reference/datamodel.rst:1321
msgid "io"
msgstr "io"

#: ../../reference/datamodel.rst:1321
msgid "popen() (in module os)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "makefile() (socket method)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "sys.stdin"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "sys.stdout"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "sys.stderr"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stdio"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stdin (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stdout (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stderr (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1350
msgid "internal type"
msgstr ""

#: ../../reference/datamodel.rst:1350
msgid "types, internal"
msgstr ""

#: ../../reference/datamodel.rst:1364
msgid "bytecode"
msgstr "байт-код"

#: ../../reference/datamodel.rst:1364
msgid "code"
msgstr "код"

#: ../../reference/datamodel.rst:1364
msgid "code object"
msgstr "об'єкт коду"

#: ../../reference/datamodel.rst:1375
msgid "co_argcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_posonlyargcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_kwonlyargcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_code (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_consts (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_filename (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_firstlineno (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_flags (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_lnotab (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_name (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_names (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_nlocals (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_stacksize (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_varnames (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_cellvars (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_freevars (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_qualname (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1490
msgid "documentation string"
msgstr "рядок документації"

#: ../../reference/datamodel.rst:1581
msgid "frame"
msgstr "frame"

#: ../../reference/datamodel.rst:1587
msgid "f_back (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_code (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_globals (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_locals (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_lasti (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_builtins (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_trace (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_trace_lines (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_trace_opcodes (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_lineno (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "traceback"
msgstr "traceback"

#: ../../reference/datamodel.rst:1691
msgid "stack"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "trace"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "exception"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "handler"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "execution"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "exc_info (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "last_traceback (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "sys.exc_info"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "sys.exception"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "sys.last_traceback"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "tb_frame (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "tb_lineno (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "tb_lasti (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "try"
msgstr ""

#: ../../reference/datamodel.rst:1758
msgid "tb_next (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1774 ../../reference/datamodel.rst:3134
msgid "slice"
msgstr "шматочок"

#: ../../reference/datamodel.rst:1780
msgid "start (slice object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1780
msgid "stop (slice object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1780
msgid "step (slice object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1828
msgid "operator"
msgstr "оператор"

#: ../../reference/datamodel.rst:1828
msgid "overloading"
msgstr ""

#: ../../reference/datamodel.rst:1828
msgid "__getitem__() (mapping object method)"
msgstr ""

#: ../../reference/datamodel.rst:1864
msgid "subclassing"
msgstr ""

#: ../../reference/datamodel.rst:1864
msgid "immutable types"
msgstr ""

#: ../../reference/datamodel.rst:1893
msgid "constructor"
msgstr ""

#: ../../reference/datamodel.rst:1910
msgid "destructor"
msgstr ""

#: ../../reference/datamodel.rst:1910
msgid "finalizer"
msgstr ""

#: ../../reference/datamodel.rst:1910
msgid "del"
msgstr ""

#: ../../reference/datamodel.rst:1974
msgid "repr() (built-in function)"
msgstr ""

#: ../../reference/datamodel.rst:1974
msgid "__repr__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:1992
msgid "__str__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:1992
msgid "format() (built-in function)"
msgstr ""

#: ../../reference/datamodel.rst:1992
msgid "print() (built-in function)"
msgstr ""

#: ../../reference/datamodel.rst:2023
msgid "__format__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:2023
msgid "conversion"
msgstr ""

#: ../../reference/datamodel.rst:2023
msgid "print"
msgstr ""

#: ../../reference/datamodel.rst:2065
msgid "comparisons"
msgstr ""

#: ../../reference/datamodel.rst:2116
msgid "hash"
msgstr ""

#: ../../reference/datamodel.rst:2197
msgid "__len__() (mapping object method)"
msgstr ""

#: ../../reference/datamodel.rst:2302
msgid "__getattr__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:2302
msgid "__dir__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:2302
msgid "__class__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:2673
msgid "metaclass"
msgstr "метаклас"

#: ../../reference/datamodel.rst:2673
msgid "= (equals)"
msgstr ""

#: ../../reference/datamodel.rst:2673
msgid "class definition"
msgstr ""

#: ../../reference/datamodel.rst:2737
msgid "metaclass hint"
msgstr ""

#: ../../reference/datamodel.rst:2760
msgid "__prepare__ (metaclass method)"
msgstr ""

#: ../../reference/datamodel.rst:2784
msgid "body"
msgstr ""

#: ../../reference/datamodel.rst:2804
msgid "__class__ (method cell)"
msgstr ""

#: ../../reference/datamodel.rst:2804
msgid "__classcell__ (class namespace entry)"
msgstr ""

#: ../../reference/datamodel.rst:3104
msgid "__bool__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:3262 ../../reference/datamodel.rst:3297
msgid "divmod"
msgstr ""

#: ../../reference/datamodel.rst:3262 ../../reference/datamodel.rst:3297
#: ../../reference/datamodel.rst:3311
msgid "pow"
msgstr ""

#: ../../reference/datamodel.rst:3360
msgid "abs"
msgstr ""

#: ../../reference/datamodel.rst:3370
msgid "int"
msgstr "int"

#: ../../reference/datamodel.rst:3370
msgid "float"
msgstr "плавати"

#: ../../reference/datamodel.rst:3398
msgid "round"
msgstr ""

#: ../../reference/datamodel.rst:3425
msgid "with"
msgstr ""

#: ../../reference/datamodel.rst:3425
msgid "context manager"
msgstr "контекстний менеджер"
