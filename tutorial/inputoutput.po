# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Input and Output"
msgstr "Вхід і вихід"

msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""
"Є кілька способів представити вихідні дані програми; дані можна роздрукувати "
"у формі, зрозумілій людині, або записати у файл для подальшого використання. "
"У цьому розділі будуть розглянуті деякі з можливостей."

msgid "Fancier Output Formatting"
msgstr "Вишуканіше форматування виводу"

msgid ""
"So far we've encountered two ways of writing values: *expression statements* "
"and the :func:`print` function.  (A third way is using the :meth:`write` "
"method of file objects; the standard output file can be referenced as ``sys."
"stdout``. See the Library Reference for more information on this.)"
msgstr ""
"Поки що ми стикалися з двома способами запису значень: *операторами виразу* "
"та функцією :func:`print`. (Третій спосіб — використання методу :meth:"
"`write` для об’єктів файлу; на стандартний файл виводу можна посилатися як "
"на ``sys.stdout``. Додаткову інформацію про це див. у Довіднику до "
"бібліотеки.)"

msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"Часто вам знадобиться більше контролювати форматування вихідних даних, ніж "
"просто друкувати значення, розділені пробілами. Існує кілька способів "
"форматування виводу."

msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string with "
"``f`` or ``F`` before the opening quotation mark or triple quotation mark. "
"Inside this string, you can write a Python expression between ``{`` and ``}"
"`` characters that can refer to variables or literal values."
msgstr ""
"Щоб використовувати :ref:`відформатовані рядкові літерали <tut-f-strings>`, "
"починайте рядок з ``f`` або ``F`` перед лапками, що відкривають або "
"потрійними лапками. Усередині цього рядка можна написати вираз Python між "
"символами ``{`` і ``}``, які можуть посилатися на змінні або літеральні "
"значення."

msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll also "
"need to provide the information to be formatted."
msgstr ""
"Метод рядків :meth:`str.format` вимагає більше ручних зусиль. Ви все одно "
"використовуватимете ``{`` і ``}``, щоб позначити місце заміни змінної, і "
"можете надати детальні директиви форматування, але вам також потрібно буде "
"надати інформацію для форматування."

msgid ""
"Finally, you can do all the string handling yourself by using string slicing "
"and concatenation operations to create any layout you can imagine.  The "
"string type has some methods that perform useful operations for padding "
"strings to a given column width."
msgstr ""
"Нарешті, ви можете виконувати всю обробку рядків самостійно, використовуючи "
"операції зрізання рядків і конкатенації для створення будь-якого макета, "
"який тільки можете собі уявити. Рядковий тип має деякі методи, які виконують "
"корисні операції для доповнення рядків до заданої ширини стовпця."

msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string with "
"the :func:`repr` or :func:`str` functions."
msgstr ""
"Якщо вам не потрібен вигадливий вихід, а просто потрібно швидко відобразити "
"деякі змінні для цілей налагодження, ви можете перетворити будь-яке значення "
"на рядок за допомогою функцій :func:`repr` або :func:`str`."

msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a :exc:"
"`SyntaxError` if there is no equivalent syntax).  For objects which don't "
"have a particular representation for human consumption, :func:`str` will "
"return the same value as :func:`repr`.  Many values, such as numbers or "
"structures like lists and dictionaries, have the same representation using "
"either function.  Strings, in particular, have two distinct representations."
msgstr ""
"Функція :func:`str` призначена для повернення представлень значень, які "
"досить зрозумілі людині, тоді як :func:`repr` призначена для створення "
"представлень, які може читати інтерпретатор (або примусово :exc:"
"`SyntaxError`, якщо немає еквівалентного синтаксису). Для об’єктів, які не "
"мають спеціального представлення для споживання людиною, :func:`str` поверне "
"те саме значення, що й :func:`repr`. Багато значень, наприклад чисел або "
"структур, таких як списки та словники, мають однакове представлення за "
"допомогою будь-якої функції. Рядки, зокрема, мають два різних представлення."

msgid "Some examples::"
msgstr "Деякі приклади::"

msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using placeholders "
"like ``$x`` and replacing them with values from a dictionary, but offers "
"much less control of the formatting."
msgstr ""
"Модуль :mod:`string` містить клас :class:`~string.Template`, який пропонує "
"ще один спосіб заміни значень у рядки, використовуючи заповнювачі, такі як "
"``$x``, і замінюючи їх значеннями зі словника, але пропонує набагато менше "
"контролю над форматуванням."

msgid "Formatted String Literals"
msgstr "Відформатовані рядкові літерали"

msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by "
"prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`Форматовані рядкові літерали <f-strings>` (які також скорочено "
"називаються f-рядками) дозволяють включити значення виразів Python у рядок, "
"додавши до рядка префікс ``f`` або ``F`` і записавши вирази як` `{expression}"
"``."

msgid ""
"An optional format specifier can follow the expression. This allows greater "
"control over how the value is formatted. The following example rounds pi to "
"three places after the decimal::"
msgstr ""
"За виразом може слідувати необов’язковий специфікатор формату. Це дозволяє "
"краще контролювати форматування значення. У наступному прикладі число pi "
"округлюється до трьох знаків після коми:"

msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making columns line up. ::"
msgstr ""
"Передача цілого числа після ``':''`` призведе до того, що це поле матиме "
"мінімальну кількість символів. Це корисно для того, щоб вирівняти колони. ::"

msgid ""
"Other modifiers can be used to convert the value before it is formatted. ``'!"
"a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'`` "
"applies :func:`repr`::"
msgstr ""
"Для перетворення значення перед його форматуванням можна використовувати "
"інші модифікатори. ``'!a''`` застосовується :func:`ascii`, ``'!s''`` "
"застосовується :func:`str`, а ``'!r''`` застосовується :func:`repr`::"

msgid ""
"For a reference on these format specifications, see the reference guide for "
"the :ref:`formatspec`."
msgstr ""
"Щоб отримати довідку щодо цих специфікацій формату, перегляньте довідковий "
"посібник для :ref:`formatspec`."

msgid "The String format() Method"
msgstr "Метод String format()."

msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr "Основне використання методу :meth:`str.format` виглядає так:"

msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the "
"brackets can be used to refer to the position of the object passed into the :"
"meth:`str.format` method. ::"
msgstr ""
"Дужки та символи в них (так звані поля форматування) замінюються об’єктами, "
"переданими в метод :meth:`str.format`. Число в дужках можна використовувати "
"для позначення позиції об’єкта, переданого в метод :meth:`str.format`. ::"

msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values "
"are referred to by using the name of the argument. ::"
msgstr ""
"Якщо ключові аргументи використовуються в методі :meth:`str.format`, їх "
"значення посилаються за допомогою назви аргументу. ::"

msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "Позиційні та ключові аргументи можна довільно комбінувати:"

msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"Якщо у вас є дуже довгий рядок формату, який ви не хочете розділяти, було б "
"непогано, якби ви могли посилатися на змінні, які потрібно відформатувати за "
"назвою, а не за позицією. Це можна зробити, просто передавши dict і "
"використовуючи квадратні дужки ``''[]'`` для доступу до ключів. ::"

msgid ""
"This could also be done by passing the table as keyword arguments with the "
"'**' notation. ::"
msgstr ""
"Це також можна зробити, передавши таблицю як ключові аргументи з нотацією "
"\"**\". ::"

msgid ""
"This is particularly useful in combination with the built-in function :func:"
"`vars`, which returns a dictionary containing all local variables."
msgstr ""
"Це особливо корисно в поєднанні з вбудованою функцією :func:`vars`, яка "
"повертає словник, що містить усі локальні змінні."

msgid ""
"As an example, the following lines produce a tidily-aligned set of columns "
"giving integers and their squares and cubes::"
msgstr ""
"Як приклад, наступні рядки створюють акуратно вирівняний набір стовпців, що "
"дають цілі числа та їх квадрати та куби:"

msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see :"
"ref:`formatstrings`."
msgstr ""
"Щоб отримати повний огляд форматування рядка за допомогою :meth:`str."
"format`, перегляньте :ref:`formatstrings`."

msgid "Manual String Formatting"
msgstr "Ручне форматування рядка"

msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "Ось та сама таблиця квадратів і кубів, відформатована вручну:"

msgid ""
"(Note that the one space between each column was added by the way :func:"
"`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(Зверніть увагу, що один пробіл між кожним стовпцем було додано так, як "
"працює :func:`print`: він завжди додає пробіли між своїми аргументами.)"

msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string in a "
"field of a given width by padding it with spaces on the left. There are "
"similar methods :meth:`str.ljust` and :meth:`str.center`. These methods do "
"not write anything, they just return a new string. If the input string is "
"too long, they don't truncate it, but return it unchanged; this will mess up "
"your column lay-out but that's usually better than the alternative, which "
"would be lying about a value. (If you really want truncation you can always "
"add a slice operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"Метод :meth:`str.rjust` рядкових об’єктів вирівнює рядок по правому краю в "
"полі заданої ширини, доповнюючи його пробілами зліва. Існують схожі методи :"
"meth:`str.ljust` і :meth:`str.center`. Ці методи нічого не записують, вони "
"просто повертають новий рядок. Якщо вхідний рядок надто довгий, вони не "
"скорочують його, а повертають без змін; це зіпсує ваш макет стовпців, але це "
"зазвичай краще, ніж альтернатива, яка б брехала про значення. (Якщо вам "
"дійсно потрібно скорочення, ви завжди можете додати операцію зрізу, як у ``x."
"ljust(n)[:n]``.)"

msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"Є інший метод, :meth:`str.zfill`, який доповнює числовий рядок зліва нулями. "
"Він розуміє знаки плюс і мінус:"

msgid "Old string formatting"
msgstr "Старе форматування рядка"

msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``'string' % values``, instances of ``%`` in ``string`` are replaced with "
"zero or more elements of ``values``. This operation is commonly known as "
"string interpolation. For example::"
msgstr ""
"Оператор % (по модулю) також можна використовувати для форматування рядків. "
"З урахуванням % значень ``'string'`` екземпляри ``%`` в ``string`` "
"замінюються нулем або більше елементами ``values``. Ця операція широко "
"відома як інтерполяція рядків. Наприклад::"

msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr "Більше інформації можна знайти в розділі :ref:`old-string-formatting`."

msgid "Reading and Writing Files"
msgstr "Читання та запис файлів"

msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two positional arguments and one keyword argument: ``open(filename, mode, "
"encoding=None)``"
msgstr ""
":func:`open` повертає об’єкт :term:`file object` і найчастіше "
"використовується з двома позиційними аргументами та одним ключовим "
"аргументом: ``open(filename, mode, encoding=None)``"

msgid ""
"The first argument is a string containing the filename.  The second argument "
"is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""
"Перший аргумент - це рядок, що містить назву файлу. Другий аргумент — це "
"інший рядок, що містить декілька символів, що описують спосіб використання "
"файлу. *режим* може бути ``'r'``, коли файл буде лише читатися, ``'w''`` "
"лише для запису (існуючий файл із такою ж назвою буде стерто) і ``'a'`` "
"відкриває файл для додавання; будь-які дані, записані у файл, автоматично "
"додаються в кінець. ``'r+'`` відкриває файл як для читання, так і для "
"запису. Аргумент *mode* необов’язковий; ``'r'`` передбачається, якщо його "
"опустити."

msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"*encoding*. If *encoding* is not specified, the default is platform "
"dependent (see :func:`open`). Because UTF-8 is the modern de-facto standard, "
"``encoding=\"utf-8\"`` is recommended unless you know that you need to use a "
"different encoding. Appending a ``'b'`` to the mode opens the file in :dfn:"
"`binary mode`. Binary mode data is read and written as :class:`bytes` "
"objects. You can not specify *encoding* when opening file in binary mode."
msgstr ""
"Зазвичай файли відкриваються в :dfn:`text mode`, це означає, що ви читаєте "
"та записуєте рядки з і до файлу, які закодовані в певному *кодуванні*. Якщо "
"*кодування* не вказано, типове значення залежить від платформи (див. :func:"
"`open`). Оскільки UTF-8 є сучасним стандартом де-факто, рекомендується "
"``encoding=\"utf-8\"``, якщо ви не знаєте, що вам потрібно використовувати "
"інше кодування. Додавання ``'b'`` до режиму відкриває файл у :dfn:`binary "
"mode`. Дані у двійковому режимі читаються та записуються як об’єкти :class:"
"`bytes`. Ви не можете вказати *кодування* під час відкриття файлу в "
"двійковому режимі."

msgid ""
"In text mode, the default when reading is to convert platform-specific line "
"endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When "
"writing in text mode, the default is to convert occurrences of ``\\n`` back "
"to platform-specific line endings.  This behind-the-scenes modification to "
"file data is fine for text files, but will corrupt binary data like that in :"
"file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when "
"reading and writing such files."
msgstr ""
"У текстовому режимі під час читання за замовчуванням закінчення рядків для "
"певної платформи (``\\n`` в Unix, ``\\r\\n`` у Windows) перетворюються лише "
"на ``\\n``. Під час написання в текстовому режимі за замовчуванням символи "
"``\\n`` перетворюються на закінчення рядків, що залежать від платформи. Ця "
"закулісна модифікація даних файлу підходить для текстових файлів, але "
"пошкодить двійкові дані, як у файлах :file:`JPEG` або :file:`EXE`. Будьте "
"дуже обережні, використовуйте двійковий режим під час читання та запису "
"таких файлів."

msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after its "
"suite finishes, even if an exception is raised at some point.  Using :"
"keyword:`!with` is also much shorter than writing equivalent :keyword:"
"`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"Під час роботи з файловими об’єктами корисно використовувати ключове слово :"
"keyword:`with`. Перевагою є те, що файл закривається належним чином після "
"завершення його набору, навіть якщо в якийсь момент виникає виняток. "
"Використання :keyword:`!with` також набагато коротше, ніж написання "
"еквівалента :keyword:`try`\\ -\\ :keyword:`finally` блоків::"

msgid ""
"If you're not using the :keyword:`with` keyword, then you should call ``f."
"close()`` to close the file and immediately free up any system resources "
"used by it."
msgstr ""
"Якщо ви не використовуєте ключове слово :keyword:`with`, вам слід викликати "
"``f.close()``, щоб закрити файл і негайно звільнити всі системні ресурси, "
"які він використовує."

msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or calling "
"``f.close()`` **might** result in the arguments of ``f.write()`` not being "
"completely written to the disk, even if the program exits successfully."
msgstr ""
"Виклик ``f.write()`` без використання ключового слова :keyword:`!with` або "
"виклик ``f.close()`` **може** привести до аргументів ``f.write()`` не "
"повністю записується на диск, навіть якщо програма успішно завершує роботу."

msgid ""
"After a file object is closed, either by a :keyword:`with` statement or by "
"calling ``f.close()``, attempts to use the file object will automatically "
"fail. ::"
msgstr ""
"Після того, як файловий об’єкт закрито за допомогою оператора :keyword:"
"`with` або виклику ``f.close()``, спроби використати файловий об’єкт "
"автоматично зазнають невдачі. ::"

msgid "Methods of File Objects"
msgstr "Методи файлових об'єктів"

msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""
"У решті прикладів у цьому розділі буде припущено, що файловий об’єкт під "
"назвою ``f`` уже створено."

msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string (in text mode) or bytes object (in binary "
"mode). *size* is an optional numeric argument.  When *size* is omitted or "
"negative, the entire contents of the file will be read and returned; it's "
"your problem if the file is twice as large as your machine's memory. "
"Otherwise, at most *size* characters (in text mode) or *size* bytes (in "
"binary mode) are read and returned. If the end of the file has been reached, "
"``f.read()`` will return an empty string (``''``).  ::"
msgstr ""
"Щоб прочитати вміст файлу, викличте ``f.read(size)``, який зчитує певну "
"кількість даних і повертає їх як рядок (у текстовому режимі) або об’єкт "
"байтів (у двійковому режимі). *розмір* є необов’язковим числовим аргументом. "
"Якщо *size* пропущений або негативний, весь вміст файлу буде прочитано та "
"повернено; це ваша проблема, якщо розмір файлу вдвічі перевищує пам'ять "
"вашої машини. В іншому випадку зчитуються та повертаються щонайбільше *size* "
"символів (у текстовому режимі) або *size* байтів (у двійковому режимі). Якщо "
"досягнуто кінця файлу, f.read() поверне порожній рядок (``''``). ::"

msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` читає один рядок із файлу; символ нового рядка (``\\n``) "
"залишається в кінці рядка та пропускається лише в останньому рядку файлу, "
"якщо файл не закінчується символом нового рядка. Це робить значення, що "
"повертається, однозначним; якщо ``f.readline()`` повертає порожній рядок, це "
"означає, що кінець файлу досягнуто, тоді як порожній рядок представлений "
"``'\\n'``, рядок, що містить лише один новий рядок. ::"

msgid ""
"For reading lines from a file, you can loop over the file object. This is "
"memory efficient, fast, and leads to simple code::"
msgstr ""
"Щоб прочитати рядки з файлу, ви можете виконати цикл по об'єкту файлу. Це "
"ефективне використання пам’яті, швидке та веде до простого коду::"

msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"Якщо ви хочете прочитати всі рядки файлу у списку, ви також можете "
"скористатися ``list(f)`` або ``f.readlines()``."

msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""
"``f.write(string)`` записує вміст *string* у файл, повертаючи кількість "
"записаних символів. ::"

msgid ""
"Other types of objects need to be converted -- either to a string (in text "
"mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"Інші типи об’єктів потрібно перетворити — або на рядок (у текстовому "
"режимі), або на об’єкт bytes (у двійковому режимі) — перед їх записом:"

msgid ""
"``f.tell()`` returns an integer giving the file object's current position in "
"the file represented as number of bytes from the beginning of the file when "
"in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` повертає ціле число, що вказує поточну позицію файлового "
"об’єкта у файлі, представлену як кількість байтів від початку файлу в "
"двійковому режимі та непрозоре число в текстовому режимі."

msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  The "
"position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value of 0 "
"measures from the beginning of the file, 1 uses the current file position, "
"and 2 uses the end of the file as the reference point.  *whence* can be "
"omitted and defaults to 0, using the beginning of the file as the reference "
"point. ::"
msgstr ""
"Щоб змінити позицію об’єкта файлу, використовуйте ``f.seek(offset, "
"wherece)``. Положення обчислюється шляхом додавання *зміщення* до опорної "
"точки; опорна точка вибирається аргументом *whence*. Значення *whence* 0 "
"вимірюється від початку файлу, 1 використовує поточну позицію файлу, а 2 "
"використовує кінець файлу як контрольну точку. *whence* можна опустити і за "
"умовчанням дорівнює 0, використовуючи початок файлу як контрольну точку. ::"

msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``) and the only valid "
"*offset* values are those returned from the ``f.tell()``, or zero. Any other "
"*offset* value produces undefined behaviour."
msgstr ""
"У текстових файлах (відкритих без ``b`` у рядку режиму) дозволений лише "
"пошук відносно початку файлу (виняток полягає в пошуку до самого кінця файлу "
"за допомогою ``seek(0, 2)``), і єдиними дійсними значеннями *offset* є ті, "
"які повертає ``f.tell()`` або нуль. Будь-яке інше значення *offset* "
"призводить до невизначеної поведінки."

msgid ""
"File objects have some additional methods, such as :meth:`~file.isatty` and :"
"meth:`~file.truncate` which are less frequently used; consult the Library "
"Reference for a complete guide to file objects."
msgstr ""
"Файлові об’єкти мають деякі додаткові методи, такі як :meth:`~file.isatty` "
"і :meth:`~file.truncate`, які використовуються рідше; зверніться до "
"бібліотечного довідника, щоб отримати повний посібник щодо файлових об’єктів."

msgid "Saving structured data with :mod:`json`"
msgstr "Збереження структурованих даних за допомогою :mod:`json`"

msgid ""
"Strings can easily be written to and read from a file.  Numbers take a bit "
"more effort, since the :meth:`read` method only returns strings, which will "
"have to be passed to a function like :func:`int`, which takes a string like "
"``'123'`` and returns its numeric value 123.  When you want to save more "
"complex data types like nested lists and dictionaries, parsing and "
"serializing by hand becomes complicated."
msgstr ""
"Рядки можна легко записувати та читати з файлу. Числа вимагають трохи більше "
"зусиль, оскільки метод :meth:`read` повертає лише рядки, які потрібно буде "
"передати до функції на зразок :func:`int`, яка приймає рядок типу ``'123'`` "
"і повертає числове значення 123. Якщо ви хочете зберегти складніші типи "
"даних, як-от вкладені списки та словники, розбір і серіалізація вручну "
"ускладнюються."

msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular data "
"interchange format called `JSON (JavaScript Object Notation) <http://json."
"org>`_.  The standard module called :mod:`json` can take Python data "
"hierarchies, and convert them to string representations; this process is "
"called :dfn:`serializing`.  Reconstructing the data from the string "
"representation is called :dfn:`deserializing`.  Between serializing and "
"deserializing, the string representing the object may have been stored in a "
"file or data, or sent over a network connection to some distant machine."
msgstr ""
"Замість того, щоб користувачі постійно писали та налагоджували код для "
"збереження складних типів даних у файли, Python дозволяє використовувати "
"популярний формат обміну даними під назвою `JSON (JavaScript Object "
"Notation) <http://json.org>`_. Стандартний модуль під назвою :mod:`json` "
"може приймати ієрархії даних Python і перетворювати їх у представлення "
"рядків; цей процес називається :dfn:`serializing`. Реконструкція даних із "
"представлення рядка називається :dfn:`deserializing`. Між серіалізацією та "
"десеріалізацією рядок, що представляє об’єкт, міг бути збережений у файлі чи "
"даних або надісланий через мережеве з’єднання на якусь віддалену машину."

msgid ""
"The JSON format is commonly used by modern applications to allow for data "
"exchange.  Many programmers are already familiar with it, which makes it a "
"good choice for interoperability."
msgstr ""
"Формат JSON зазвичай використовується сучасними програмами для обміну "
"даними. Багато програмістів уже знайомі з ним, що робить його хорошим "
"вибором для сумісності."

msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"Якщо у вас є об’єкт ``x``, ви можете переглянути його представлення рядка "
"JSON за допомогою простого рядка коду::"

msgid ""
"Another variant of the :func:`~json.dumps` function, called :func:`~json."
"dump`, simply serializes the object to a :term:`text file`.  So if ``f`` is "
"a :term:`text file` object opened for writing, we can do this::"
msgstr ""
"Інший варіант функції :func:`~json.dumps`, який називається :func:`~json."
"dump`, просто серіалізує об’єкт у :term:`text file`. Отже, якщо ``f`` є "
"об'єктом :term:`text file`, відкритим для запису, ми можемо зробити це:"

msgid ""
"To decode the object again, if ``f`` is a :term:`binary file` or :term:`text "
"file` object which has been opened for reading::"
msgstr ""
"Щоб знову декодувати об’єкт, якщо ``f`` є об’єктом :term:`binary file` або :"
"term:`text file`, який було відкрито для читання::"

msgid ""
"JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when opening "
"JSON file as a :term:`text file` for both of reading and writing."
msgstr ""
"Файли JSON мають бути закодовані в UTF-8. Використовуйте "
"``encoding=\"utf-8\"``, коли відкриваєте файл JSON як :term:`text file` як "
"для читання, так і для запису."

msgid ""
"This simple serialization technique can handle lists and dictionaries, but "
"serializing arbitrary class instances in JSON requires a bit of extra "
"effort. The reference for the :mod:`json` module contains an explanation of "
"this."
msgstr ""
"Ця проста техніка серіалізації може працювати зі списками та словниками, але "
"серіалізація довільних екземплярів класу в JSON потребує додаткових зусиль. "
"Посилання на модуль :mod:`json` містить пояснення цього."

msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - модуль pickle"

msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows the "
"serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: deserializing "
"pickle data coming from an untrusted source can execute arbitrary code, if "
"the data was crafted by a skilled attacker."
msgstr ""
"На відміну від :ref:`JSON <tut-json>`, *pickle* — це протокол, який дозволяє "
"серіалізувати довільно складні об’єкти Python. Як такий, він специфічний для "
"Python і не може використовуватися для зв’язку з програмами, написаними "
"іншими мовами. Це також небезпечно за замовчуванням: десеріалізація даних "
"pickle, що надходять із ненадійного джерела, може виконувати довільний код, "
"якщо дані були створені кваліфікованим зловмисником."
