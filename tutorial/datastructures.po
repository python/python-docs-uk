# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Data Structures"
msgstr "Структури даних"

msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"У цьому розділі більш детально описано деякі речі, про які ви вже вивчили, а "
"також додано деякі нові речі."

msgid "More on Lists"
msgstr "Більше про списки"

msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"Тип даних списку має ще кілька методів. Ось усі методи об’єктів списку:"

msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "Додайте елемент у кінець списку. Еквівалент ``a[len(a):] = [x]``."

msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to "
"``a[len(a):] = iterable``."
msgstr ""
"Розширте список, додавши всі елементи з iterable. Еквівалент ``a[len(a):] = "
"iterable``."

msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Вставте елемент у задану позицію. Перший аргумент — це індекс елемента, "
"перед яким потрібно вставити, тому ``a.insert(0, x)`` вставляє на початку "
"списку, а ``a.insert(len(a), x)`` еквівалентно ``a.append(x)``."

msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Видаліть зі списку перший елемент, значення якого дорівнює *x*. Це викликає :"
"exc:`ValueError`, якщо такого елемента немає."

msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"Видаліть елемент у вказаній позиції у списку та поверніть його. Якщо індекс "
"не вказано, ``a.pop()`` видаляє та повертає останній елемент у списку. "
"(Квадратні дужки навколо *i* в сигнатурі методу означають, що параметр є "
"необов’язковим, а не те, що ви повинні вводити квадратні дужки в цій "
"позиції. Ви часто побачите це позначення в Довіднику з бібліотеки Python.)"

msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "Видалити всі елементи зі списку. Еквівалент ``del a[:]``."

msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Повертає індекс від нуля в списку першого елемента, значення якого дорівнює "
"*x*. Викликає :exc:`ValueError`, якщо такого елемента немає."

msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"Необов’язкові аргументи *start* і *end* інтерпретуються так само, як і в "
"нотації фрагментів, і використовуються для обмеження пошуку певною "
"підпослідовністю списку. Повернений індекс обчислюється відносно початку "
"повної послідовності, а не аргументу *start*."

msgid "Return the number of times *x* appears in the list."
msgstr "Повертає кількість разів *x* у списку."

msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Відсортуйте елементи списку за місцем (аргументи можна використовувати для "
"налаштування сортування, див. :func:`sorted` для їх пояснення)."

msgid "Reverse the elements of the list in place."
msgstr "Переверніть елементи списку на місці."

msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "Поверніть мілку копію списку. Еквівалент ``a[:]``."

msgid "An example that uses most of the list methods::"
msgstr "Приклад, який використовує більшість методів списку::"

msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Можливо, ви помітили, що такі методи, як ``insert``, ``remove`` або "
"``sort``, які лише змінюють список, не мають надрукованого значення – вони "
"повертають типове значення ``None``. [1]_ Це принцип дизайну для всіх "
"змінних структур даних у Python."

msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and *None* can't be compared to other "
"types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"Інша річ, яку ви можете помітити, це те, що не всі дані можна відсортувати "
"або порівняти. Наприклад, ``[None, 'hello', 10]`` не сортує, оскільки цілі "
"числа не можна порівняти з рядками, а *None* не можна порівняти з іншими "
"типами. Крім того, є деякі типи, які не мають визначеного зв’язку порядку. "
"Наприклад, ``3+4j < 5+7j`` не є дійсним порівнянням."

msgid "Using Lists as Stacks"
msgstr "Використання списків як стеків"

msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"Методи списку дозволяють дуже легко використовувати список як стек, де "
"останній доданий елемент є першим отриманим елементом (\"останній прийшов, "
"перший вийшов\"). Щоб додати елемент на вершину стека, використовуйте :meth:"
"`append`. Щоб отримати елемент із вершини стека, використовуйте :meth:`pop` "
"без явного індексу. Наприклад::"

msgid "Using Lists as Queues"
msgstr "Використання списків як черг"

msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Також можна використовувати список як чергу, де перший доданий елемент є "
"першим отриманим елементом (\"першим увійшов, першим вийшов\"); однак списки "
"не ефективні для цієї мети. У той час як додавання та висування з кінця "
"списку є швидкими, виконання вставок або висунення з початку списку "
"відбувається повільно (оскільки всі інші елементи мають бути зміщені на "
"одиницю)."

msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Щоб реалізувати чергу, використовуйте :class:`collections.deque`, який був "
"розроблений для швидкого додавання та висування з обох кінців. Наприклад::"

msgid "List Comprehensions"
msgstr "Розуміння списку"

msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"Розуміння списків забезпечує стислий спосіб створення списків. Загальні "
"застосування полягають у створенні нових списків, де кожен елемент є "
"результатом деяких операцій, застосованих до кожного члена іншої "
"послідовності або ітерації, або створення підпослідовності тих елементів, "
"які задовольняють певну умову."

msgid "For example, assume we want to create a list of squares, like::"
msgstr ""
"Наприклад, припустимо, що ми хочемо створити список квадратів, наприклад:"

msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Зауважте, що це створює (або перезаписує) змінну з назвою ``x``, яка все ще "
"існує після завершення циклу. Ми можемо обчислити список квадратів без "
"побічних ефектів за допомогою:"

msgid "or, equivalently::"
msgstr "або, що еквівалентно::"

msgid "which is more concise and readable."
msgstr "який більш стислий і читабельний."

msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"Розуміння списку складається з дужок, які містять вираз, після якого йде "
"речення :keyword:`!for`, потім нуль або більше речень :keyword:`!for` або :"
"keyword:`!if`. Результатом буде новий список, отриманий в результаті "
"обчислення виразу в контексті речень :keyword:`!for` і :keyword:`!if`, які "
"слідують за ним. Наприклад, цей listcomp поєднує елементи двох списків, якщо "
"вони не рівні:"

msgid "and it's equivalent to::"
msgstr "і це еквівалентно::"

msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Зверніть увагу, що порядок операторів :keyword:`for` і :keyword:`if` "
"однаковий в обох цих фрагментах."

msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Якщо вираз є кортежем (наприклад, ``(x, y)`` у попередньому прикладі), його "
"потрібно взяти в дужки. ::"

msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "Розуміння списків може містити складні вирази та вкладені функції:"

msgid "Nested List Comprehensions"
msgstr "Розуміння вкладених списків"

msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"Початковим виразом у розуміння списку може бути будь-який довільний вираз, "
"включаючи інший розуміння списку."

msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Розглянемо наступний приклад матриці 3x4, реалізованої як список із 3 "
"списків довжини 4::"

msgid "The following list comprehension will transpose rows and columns::"
msgstr "Наступне розуміння списку транспонує рядки та стовпці:"

msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent "
"to::"
msgstr ""
"Як ми бачили в попередньому розділі, вкладений listcomp оцінюється в "
"контексті :keyword:`for`, який слідує за ним, тому цей приклад "
"еквівалентний::"

msgid "which, in turn, is the same as::"
msgstr "що, у свою чергу, те саме, що::"

msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"У реальному світі вам слід віддавати перевагу вбудованим функціям перед "
"складними операторами потоку. Функція :func:`zip` чудово впорається з цим "
"випадком використання::"

msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"Перегляньте :ref:`tut-unpacking-arguments`, щоб дізнатися більше про зірочку "
"в цьому рядку."

msgid "The :keyword:`!del` statement"
msgstr "Оператор :keyword:`!del`"

msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Існує спосіб видалити елемент зі списку, враховуючи його індекс замість "
"значення: оператор :keyword:`del`. Це відрізняється від методу :meth:`pop`, "
"який повертає значення. Оператор :keyword:`!del` також можна використовувати "
"для видалення фрагментів зі списку або очищення всього списку (що ми зробили "
"раніше, призначивши фрагменту порожній список). Наприклад::"

msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ""
":keyword:`del` також можна використовувати для видалення змінних повністю::"

msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Посилання на назву ``a`` у подальшому є помилкою (принаймні доти, доки їй не "
"буде присвоєно інше значення). Пізніше ми знайдемо інші способи "
"використання :keyword:`del`."

msgid "Tuples and Sequences"
msgstr "Кортежі та послідовності"

msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Ми побачили, що списки та рядки мають багато спільних властивостей, таких як "
"операції індексування та нарізки. Це два приклади типів даних *sequence* "
"(див. :ref:`typesseq`). Оскільки Python є мовою, що розвивається, можна "
"додавати інші типи даних послідовності. Існує ще один стандартний тип даних "
"послідовності: *кортеж*."

msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr "Кортеж складається з кількох значень, розділених комами, наприклад::"

msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Як ви бачите, на виході кортежі завжди взяті в круглі дужки, так що вкладені "
"кортежі інтерпретуються правильно; вони можуть бути введені з круглими "
"дужками або без них, хоча часто дужки все одно необхідні (якщо кортеж є "
"частиною більшого виразу). Неможливо призначити окремі елементи кортежу, "
"однак можна створити кортежі, які містять змінні об’єкти, наприклад списки."

msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Хоча кортежі можуть здаватися схожими на списки, вони часто використовуються "
"в різних ситуаціях і для різних цілей. Кортежі є :term:`immutable` і "
"зазвичай містять різнорідну послідовність елементів, доступ до яких "
"здійснюється через розпакування (див. далі в цьому розділі) або індексування "
"(або навіть за атрибутом у випадку :func:`namedtuples <collections."
"namedtuple>`). Списки є :term:`mutable`, і їхні елементи, як правило, є "
"однорідними та доступні за допомогою ітерації по списку."

msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Особливою проблемою є побудова кортежів, що містять 0 або 1 елемент: "
"синтаксис має деякі додаткові примхи для їх врахування. Порожні кортежі "
"будуються за допомогою порожньої пари круглих дужок; кортеж з одним "
"елементом створюється шляхом коми після значення (недостатньо взяти одне "
"значення в дужки). Негарно, але ефективно. Наприклад::"

msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"Оператор ``t = 12345, 54321, 'hello!'`` є прикладом *упакування кортежів*: "
"значення ``12345``, ``54321`` і ``'hello!''`` упаковуються разом в кортежі. "
"Можлива і зворотна операція:"

msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Це називається, доречно, *розпакуванням послідовності* і працює для будь-"
"якої послідовності в правій частині. Розпакування послідовності вимагає, щоб "
"ліворуч від знака рівності було стільки змінних, скільки елементів у "
"послідовності. Зауважте, що множинне призначення насправді є лише "
"комбінацією упаковки кортежів і розпакування послідовності."

msgid "Sets"
msgstr "Набори"

msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python також містить тип даних для *наборів*. Набір — це невпорядкована "
"колекція без повторюваних елементів. Основні способи використання включають "
"тестування членства та усунення повторюваних записів. Об’єкти множини також "
"підтримують математичні операції, такі як об’єднання, перетин, різниця та "
"симетрична різниця."

msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Для створення наборів можна використовувати фігурні дужки або функцію :func:"
"`set`. Примітка: щоб створити порожній набір, потрібно використовувати "
"``set()``, а не ``{}``; останній створює порожній словник, структуру даних, "
"яку ми обговоримо в наступному розділі."

msgid "Here is a brief demonstration::"
msgstr "Ось коротка демонстрація:"

msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"Подібно до :ref:`списків розуміння <tut-listcomps>`, також підтримуються "
"набір розуміння::"

msgid "Dictionaries"
msgstr "словники"

msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`append` and :meth:`extend`."
msgstr ""
"Іншим корисним типом даних, вбудованим у Python, є *словник* (див. :ref:"
"`typesmapping`). Словники іноді зустрічаються в інших мовах як \"асоціативні "
"пам’яті\" або \"асоціативні масиви\". На відміну від послідовностей, які "
"індексуються діапазоном чисел, словники індексуються *ключами*, які можуть "
"бути будь-якого незмінного типу; рядки та числа завжди можуть бути ключами. "
"Кортежі можна використовувати як ключі, якщо вони містять лише рядки, числа "
"або кортежі; якщо кортеж містить будь-який змінний об'єкт прямо чи "
"опосередковано, його не можна використовувати як ключ. Ви не можете "
"використовувати списки як ключі, оскільки списки можна змінювати на місці за "
"допомогою призначення індексу, призначення фрагментів або таких методів, як :"
"meth:`append` і :meth:`extend`."

msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Найкраще думати про словник як про набір пар *ключ:значення* з вимогою, щоб "
"ключі були унікальними (в межах одного словника). Пара фігурних дужок "
"створює порожній словник: ``{}``. Розміщення розділених комами списку пар "
"ключ:значення в фігурних дужках додає початкові пари ключ:значення до "
"словника; це також спосіб написання словників на виході."

msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"Основними операціями зі словником є збереження значення з деяким ключем і "
"вилучення значення з заданим ключем. Також можна видалити пару ключ:значення "
"за допомогою ``del``. Якщо ви зберігаєте за допомогою ключа, який уже "
"використовується, старе значення, пов’язане з цим ключем, забувається. "
"Видобування значення за допомогою неіснуючого ключа є помилкою."

msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Виконання ``list(d)`` для словника повертає список усіх ключів, використаних "
"у словнику, у порядку вставки (якщо ви хочете, щоб він був відсортований, "
"просто використовуйте ``sorted(d)``). Щоб перевірити, чи є один ключ у "
"словнику, використовуйте ключове слово :keyword:`in`."

msgid "Here is a small example using a dictionary::"
msgstr "Ось невеликий приклад використання словника::"

msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"Конструктор :func:`dict` створює словники безпосередньо з послідовностей пар "
"ключ-значення:"

msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Крім того, розуміння dict можна використовувати для створення словників із "
"довільних ключів і виразів значень:"

msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Коли ключі є простими рядками, інколи легше вказати пари за допомогою "
"аргументів ключових слів::"

msgid "Looping Techniques"
msgstr "Техніка циклу"

msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr ""
"Під час циклічного перегляду словників ключ і відповідне значення можна "
"отримати одночасно за допомогою методу :meth:`items`. ::"

msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"Під час циклічного перегляду послідовності індекс позиції та відповідне "
"значення можна отримати одночасно за допомогою функції :func:`enumerate`. ::"

msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Щоб перейти до двох або більше послідовностей одночасно, записи можна "
"поєднати з функцією :func:`zip`. ::"

msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Щоб виконати цикл у зворотному напрямку, спочатку вкажіть послідовність у "
"прямому напрямку, а потім викличте функцію :func:`reversed`. ::"

msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Щоб перейти до послідовності у відсортованому порядку, використовуйте "
"функцію :func:`sorted`, яка повертає новий відсортований список, залишаючи "
"джерело без змін. ::"

msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"Використання :func:`set` у послідовності усуває повторювані елементи. "
"Використання :func:`sorted` у поєднанні з :func:`set` над послідовністю є "
"ідіоматичним способом проходження унікальних елементів послідовності в "
"порядку сортування. ::"

msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Іноді виникає спокуса змінити список, поки ви переглядаєте його; однак часто "
"простіше й безпечніше створити новий список. ::"

msgid "More on Conditions"
msgstr "Детальніше про умови"

msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"Умови, які використовуються в операторах while і if, можуть містити будь-які "
"оператори, а не лише порівняння."

msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"Оператори порівняння ``in`` і ``not in`` — це тести на приналежність, які "
"визначають, чи є значення в контейнері (чи ні). Оператори ``is`` і ``is "
"not`` порівнюють, чи дійсно два об’єкти є одним і тим же об’єктом. Усі "
"оператори порівняння мають однаковий пріоритет, який нижчий, ніж у всіх "
"числових операторів."

msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Порівняння можуть бути ланцюжками. Наприклад, ``a < b == c`` перевіряє, чи "
"``a`` є меншим за ``b`` і, крім того, ``b`` дорівнює ``c``."

msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Порівняння можна комбінувати за допомогою логічних операторів ``and`` і "
"``or``, а результат порівняння (або будь-якого іншого логічного виразу) "
"можна заперечувати за допомогою ``not``. Вони мають нижчий пріоритет, ніж "
"оператори порівняння; між ними ``not`` має найвищий пріоритет, а ``or`` "
"найнижчий, так що ``A and not B or C`` еквівалентно ``(A and (not B)) or "
"C`` . Як завжди, дужки можна використовувати для вираження бажаної "
"композиції."

msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Логічні оператори ``and`` і ``or`` є так званими операторами *короткого "
"замикання*: їхні аргументи обчислюються зліва направо, і обчислення "
"припиняється, щойно визначається результат. Наприклад, якщо ``A`` і ``C`` є "
"істинними, ``B`` є хибними, ``A and B and C`` не обчислює вираз ``C``. Якщо "
"використовується як загальне значення, а не як логічне, значення, що "
"повертається оператором короткого замикання, є останнім обчисленим "
"аргументом."

msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Змінній можна призначити результат порівняння або інший логічний вираз. "
"Наприклад, ::"

msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"Зауважте, що в Python, на відміну від C, призначення всередині виразів має "
"виконуватися явно за допомогою оператора :ref:`walrus <why-can-t-i-use-an-"
"assignment-in-an-expression>` ``:=``. Це дозволяє уникнути типових проблем, "
"які виникають у програмах на C: введення ``=`` у виразі, коли передбачалося "
"``==``."

msgid "Comparing Sequences and Other Types"
msgstr "Порівняння послідовностей та інших типів"

msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"Об’єкти послідовності зазвичай можна порівнювати з іншими об’єктами того "
"самого типу послідовності. Порівняння використовує *лексикографічне* "
"впорядкування: спочатку порівнюються перші два елементи, і якщо вони "
"відрізняються, це визначає результат порівняння; якщо вони рівні, наступні "
"два елементи порівнюються і так далі, поки будь-яка послідовність не буде "
"вичерпана. Якщо два елементи для порівняння самі є послідовностями одного "
"типу, лексикографічне порівняння виконується рекурсивно. Якщо всі елементи "
"двох послідовностей порівняно однакові, послідовності вважаються рівними. "
"Якщо одна послідовність є початковою підпослідовністю іншої, коротша "
"послідовність є меншою (меншою). Лексикографічне впорядкування для рядків "
"використовує номер кодової точки Unicode для впорядкування окремих символів. "
"Деякі приклади порівнянь між послідовностями одного типу:"

msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Зауважте, що порівняння об’єктів різних типів за допомогою ``<`` or ``>`` є "
"законним за умови, що об’єкти мають відповідні методи порівняння. Наприклад, "
"змішані числові типи порівнюються відповідно до їхнього числового значення, "
"тому 0 дорівнює 0,0 тощо. В іншому випадку, замість надання довільного "
"порядку, інтерпретатор викличе виняток :exc:`TypeError`."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Інші мови можуть повертати змінений об’єкт, що дозволяє об’єднувати методи, "
"наприклад ``d->insert(\"a\")->remove(\"b\")->sort();``."
