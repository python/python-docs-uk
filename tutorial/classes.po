# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Classes"
msgstr "Класи"

msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Класи надають засоби об’єднання даних і функціональних можливостей. "
"Створення нового класу створює новий *тип* об’єкта, що дозволяє створювати "
"нові *примірники* цього типу. Кожен екземпляр класу може мати атрибути, "
"приєднані до нього для підтримки його стану. Екземпляри класу також можуть "
"мати методи (визначені його класом) для зміни свого стану."

msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Порівняно з іншими мовами програмування, механізм класів Python додає класи "
"з мінімумом нового синтаксису та семантики. Це суміш механізмів класів, "
"знайдених у C++ і Modula-3. Класи Python забезпечують усі стандартні функції "
"об’єктно-орієнтованого програмування: механізм успадкування класів дозволяє "
"створювати кілька базових класів, похідний клас може перевизначати будь-які "
"методи свого базового класу або класів, а метод може викликати метод "
"базового класу з тим самим іменем. . Об’єкти можуть містити довільні обсяги "
"та типи даних. Як і для модулів, класи мають динамічну природу Python: вони "
"створюються під час виконання та можуть бути змінені далі після створення."

msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"У термінології C++ зазвичай члени класу (включно з членами даних) є "
"*публічними* (за винятком див. нижче :ref:`tut-private`), а всі функції-"
"члени є *віртуальними*. Як і в Modula-3, немає скорочень для посилань на "
"члени об’єкта з його методів: функція методу оголошується з явним першим "
"аргументом, що представляє об’єкт, який неявно надається викликом. Як і в "
"Smalltalk, класи самі є об'єктами. Це забезпечує семантику для імпортування "
"та перейменування. На відміну від C++ і Modula-3, вбудовані типи можуть "
"використовуватися як базові класи для розширення користувачем. Також, як і в "
"C++, більшість вбудованих операторів зі спеціальним синтаксисом (арифметичні "
"оператори, індексування тощо) можна перевизначати для екземплярів класу."

msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Через відсутність загальноприйнятої термінології для розмови про класи, я "
"час від часу використовую терміни Smalltalk і C++. Я б використовував "
"терміни Modula-3, оскільки його об’єктно-орієнтована семантика ближча до "
"семантики Python, ніж C++, але я очікую, що мало читачів чув про це.)"

msgid "A Word About Names and Objects"
msgstr "Слово про імена та предмети"

msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Об’єкти мають індивідуальність, і кілька імен (у кількох областях) можуть "
"бути прив’язані до одного об’єкта. Це відоме як псевдонім в інших мовах. Це "
"зазвичай не оцінюється з першого погляду на Python, і його можна сміливо "
"ігнорувати, коли маєте справу з незмінними базовими типами (числа, рядки, "
"кортежі). Однак псевдонім має, можливо, дивовижний ефект на семантику коду "
"Python, що включає змінні об’єкти, такі як списки, словники та більшість "
"інших типів. Зазвичай це використовується на користь програми, оскільки "
"псевдоніми в деяких аспектах поводяться як покажчики. Наприклад, передача "
"об'єкта дешева, оскільки реалізація передає лише покажчик; і якщо функція "
"змінює об’єкт, переданий як аргумент, абонент побачить зміни --- це усуває "
"потребу у двох різних механізмах передачі аргументів, як у Pascal."

msgid "Python Scopes and Namespaces"
msgstr "Області та простори імен Python"

msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Перш ніж представити класи, я спершу маю розповісти вам дещо про правила "
"видимості Python. Визначення класів грають влучні трюки з просторами імен, і "
"вам потрібно знати, як працюють області та простори імен, щоб повністю "
"зрозуміти, що відбувається. До речі, знання з цієї теми знадобляться будь-"
"якому досвідченому програмісту на Python."

msgid "Let's begin with some definitions."
msgstr "Почнемо з деяких визначень."

msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"*Простір імен* — це відображення імен на об’єкти. Більшість просторів імен "
"наразі реалізовано як словники Python, але зазвичай це нічим не помітно (за "
"винятком продуктивності), і це може змінитися в майбутньому. Прикладами "
"просторів імен є: набір вбудованих імен (що містять такі функції, як :func:"
"`abs`, і вбудовані імена винятків); глобальні імена в модулі; і локальні "
"імена під час виклику функції. У певному сенсі набір атрибутів об'єкта також "
"формує простір імен. Важливо знати про простори імен, що між іменами в "
"різних просторах імен немає абсолютно ніякого зв’язку; наприклад, обидва "
"різні модулі можуть визначати функцію ``maximize`` без плутанини --- "
"користувачі модулів повинні додавати перед нею назву модуля."

msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"До речі, я використовую слово *attribute* для будь-якого імені після крапки "
"--- наприклад, у виразі ``z.real``, ``real`` є атрибутом об’єкта ``z`` . "
"Строго кажучи, посилання на імена в модулях є посиланнями на атрибути: у "
"виразі ``modname.funcname``, ``modname`` є об’єктом модуля, а ``funcname`` є "
"його атрибутом. У цьому випадку відбувається пряме відображення між "
"атрибутами модуля та глобальними іменами, визначеними в модулі: вони спільно "
"використовують той самий простір імен! [#]_"

msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by ``modname``."
msgstr ""
"Атрибути можуть бути доступними лише для читання або запису. В останньому "
"випадку можливе призначення атрибутів. Атрибути модуля доступні для запису: "
"ви можете написати ``modname.the_answer = 42``. Атрибути, доступні для "
"запису, також можна видалити за допомогою оператора :keyword:`del`. "
"Наприклад, ``del modname.the_answer`` видалить атрибут :attr:`the_answer` з "
"об’єкта, названого ``modname``."

msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Простори імен створюються в різний момент і мають різний час життя. Простір "
"імен, що містить вбудовані імена, створюється під час запуску інтерпретатора "
"Python і ніколи не видаляється. Глобальний простір імен для модуля "
"створюється, коли зчитується визначення модуля; зазвичай простори імен "
"модулів також зберігаються, доки інтерпретатор не завершить роботу. "
"Інструкції, що виконуються за допомогою виклику інтерпретатора верхнього "
"рівня, або прочитані з файлу сценарію, або в інтерактивному режимі, "
"вважаються частиною модуля під назвою :mod:`__main__`, тому вони мають "
"власний глобальний простір імен. (Вбудовані імена насправді також містяться "
"в модулі; це називається :mod:`builtins`.)"

msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"Локальний простір імен для функції створюється під час виклику функції та "
"видаляється, коли функція повертає або викликає виняткову ситуацію, яка не "
"обробляється цією функцією. (Насправді, забування було б кращим способом "
"описати те, що насправді відбувається.) Звичайно, кожен рекурсивний виклик "
"має свій власний локальний простір імен."

msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"*Область* — це текстова область програми Python, де простір імен доступний "
"безпосередньо. \"Безпосередній доступ\" тут означає, що некваліфіковане "
"посилання на ім’я намагається знайти ім’я в просторі імен."

msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Хоча області визначаються статично, вони використовуються динамічно. У будь-"
"який час під час виконання є 3 або 4 вкладені області, простори імен яких "
"доступні безпосередньо:"

msgid "the innermost scope, which is searched first, contains the local names"
msgstr "внутрішня область, яка шукається першою, містить локальні назви"

msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"області будь-яких охоплюючих функцій, які шукаються, починаючи з найближчої "
"охоплюючої області, містить не локальні, але також і неглобальні імена"

msgid "the next-to-last scope contains the current module's global names"
msgstr "передостання область містить глобальні імена поточного модуля"

msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"крайня область (шукається останньою) — це простір імен, що містить вбудовані "
"імена"

msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Якщо ім’я оголошено глобальним, тоді всі посилання та призначення переходять "
"безпосередньо до середньої області, що містить глобальні імена модуля. Щоб "
"повторно прив’язати змінні, знайдені за межами внутрішньої області, можна "
"використати оператор :keyword:`nonlocal`; якщо не оголошено нелокальними, ці "
"змінні доступні лише для читання (спроба запису в таку змінну просто "
"створить *нову* локальну змінну у внутрішній області видимості, залишаючи "
"зовнішню змінну з однаковою назвою без змін)."

msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Зазвичай локальна область посилається на локальні імена поточної (текстової) "
"функції. Поза функціями локальна область посилається на той самий простір "
"імен, що й глобальна область: простір імен модуля. Визначення класу "
"розміщують ще один простір імен у локальній області."

msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Важливо розуміти, що області визначаються текстово: глобальна область дії "
"функції, визначеної в модулі, є простором імен цього модуля, незалежно від "
"того, звідки чи яким псевдонімом викликається функція. З іншого боку, "
"фактичний пошук імен виконується динамічно, під час виконання --- однак "
"визначення мови розвивається в бік статичного дозволу імен під час "
"\"компіляції\", тому не покладайтеся на динамічне дозвіл імен! (Насправді "
"локальні змінні вже визначені статично.)"

msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Особлива примха Python полягає в тому, що, якщо не діють оператори :keyword:"
"`global` або :keyword:`nonlocal`, призначення імен завжди потрапляють у "
"найглибшу область видимості. Призначення не копіюють дані --- вони просто "
"прив’язують імена до об’єктів. Те саме стосується видалень: оператор ``del "
"x`` видаляє прив’язку ``x`` із простору імен, на який посилається локальна "
"область видимості. Насправді всі операції, які вводять нові імена, "
"використовують локальну область видимості: зокрема, оператори :keyword:"
"`import` і визначення функцій прив’язують назву модуля або функції в "
"локальній області видимості."

msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"Інструкція :keyword:`global` може бути використана, щоб вказати, що певні "
"змінні живуть у глобальній області видимості та мають бути перенаправлені "
"туди; оператор :keyword:`nonlocal` вказує на те, що певні змінні живуть в "
"охоплюючій області видимості і мають бути перенаправлені туди."

msgid "Scopes and Namespaces Example"
msgstr "Приклад областей і просторів імен"

msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Це приклад, який демонструє, як посилатися на різні області та простори "
"імен, і як :keyword:`global` і :keyword:`nonlocal` впливають на зв’язування "
"змінних::"

msgid "The output of the example code is:"
msgstr "Результат коду прикладу:"

msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Зверніть увагу, що призначення *local* (яке є типовим) не змінило прив’язки "
"*scope_test* до *spam*. Призначення :keyword:`nonlocal` змінило прив’язку "
"*scope_test*\\ до *спаму*, а призначення :keyword:`global` змінило прив’язку "
"на рівні модуля."

msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Ви також можете побачити, що не було попереднього зв’язування для *spam* "
"перед призначенням :keyword:`global`."

msgid "A First Look at Classes"
msgstr "Перший погляд на заняття"

msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Класи представляють трохи нового синтаксису, три нових типи об’єктів і нову "
"семантику."

msgid "Class Definition Syntax"
msgstr "Синтаксис визначення класу"

msgid "The simplest form of class definition looks like this::"
msgstr "Найпростіша форма визначення класу виглядає так:"

msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Визначення класів, як і визначення функцій (оператори :keyword:`def`), мають "
"бути виконані, перш ніж вони матимуть будь-який ефект. (Імовірно, ви можете "
"розмістити визначення класу в гілці оператора :keyword:`if` або всередині "
"функції.)"

msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"На практиці оператори всередині визначення класу зазвичай є визначеннями "
"функцій, але допускаються й інші оператори, іноді корисні --- ми повернемося "
"до цього пізніше. Визначення функції всередині класу зазвичай мають особливу "
"форму списку аргументів, продиктовану умовами виклику методів --- знову ж "
"таки, це пояснюється пізніше."

msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Коли вводиться визначення класу, створюється новий простір імен і "
"використовується як локальна область --- таким чином, усі призначення "
"локальним змінним переходять до цього нового простору імен. Зокрема, "
"визначення функції прив’язують тут назву нової функції."

msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:"
"`ClassName` in the example)."
msgstr ""
"Коли визначення класу залишається звичайним способом (через кінець), "
"створюється *об’єкт класу*. По суті, це оболонка навколо вмісту простору "
"імен, створеного визначенням класу; ми дізнаємось більше про об’єкти класу в "
"наступному розділі. Початкова локальна область (та, що діяла безпосередньо "
"перед тим, як було введено визначення класу) відновлюється, а об’єкт класу "
"прив’язується тут до імені класу, указаного в заголовку визначення класу (:"
"class:`ClassName` у прикладі)."

msgid "Class Objects"
msgstr "Об'єкти класу"

msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Об’єкти класу підтримують два типи операцій: посилання на атрибути та "
"інстанціювання."

msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Посилання на атрибути* використовують стандартний синтаксис, який "
"використовується для всіх посилань на атрибути в Python: ``obj.name``. "
"Дійсні імена атрибутів — це всі імена, які були в просторі імен класу під "
"час створення об’єкта класу. Отже, якби визначення класу виглядало так::"

msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"тоді ``MyClass.i`` і ``MyClass.f`` є дійсними посиланнями на атрибути, які "
"повертають ціле число та об’єкт функції відповідно. Атрибути класу також "
"можна призначити, тому ви можете змінити значення ``MyClass.i`` шляхом "
"призначення. :attr:`__doc__` також є дійсним атрибутом, який повертає рядок "
"документації, що належить до класу: ``\"Простий приклад класу\"``."

msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Клас *instantiation* використовує нотацію функції. Просто уявіть, що об’єкт "
"класу є функцією без параметрів, яка повертає новий екземпляр класу. "
"Наприклад (припускаючи вищезгаданий клас):"

msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"створює новий *примірник* класу та призначає цей об’єкт локальній змінній "
"``x``."

msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`__init__`, like this::"
msgstr ""
"Операція інстанціювання (\"виклик\" об’єкта класу) створює порожній об’єкт. "
"Багато класів люблять створювати об’єкти з екземплярами, налаштованими на "
"певний початковий стан. Тому клас може визначати спеціальний метод під "
"назвою :meth:`__init__`, наприклад:"

msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Коли клас визначає метод :meth:`__init__`, екземпляр класу автоматично "
"викликає :meth:`__init__` для щойно створеного примірника класу. Тож у цьому "
"прикладі новий ініціалізований екземпляр можна отримати за допомогою:"

msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Звичайно, метод :meth:`__init__` може мати аргументи для більшої гнучкості. "
"У цьому випадку аргументи, надані оператору інстанції класу, передаються до :"
"meth:`__init__`. Наприклад, ::"

msgid "Instance Objects"
msgstr "Об’єкти екземпляра"

msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Тепер що ми можемо робити з об’єктами екземплярів? Єдиними операціями, які "
"розуміють об’єкти екземплярів, є посилання на атрибути. Є два типи дійсних "
"імен атрибутів: атрибути даних і методи."

msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*атрибути даних* відповідають \"змінним екземплярів\" у Smalltalk і \"членам "
"даних\" у C++. Атрибути даних не потрібно оголошувати; як і локальні змінні, "
"вони виникають, коли їх вперше призначають. Наприклад, якщо ``x`` є "
"екземпляром :class:`MyClass`, створеним вище, наступний фрагмент коду виведе "
"значення ``16``, не залишаючи слідів::"

msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"Іншим типом посилання на атрибут екземпляра є *метод*. Метод — це функція, "
"яка \"належить\" об’єкту. (У Python термін метод не є унікальним для "
"екземплярів класу: інші типи об’єктів також можуть мати методи. Наприклад, "
"об’єкти списку мають методи, що називаються додаванням, вставкою, "
"видаленням, сортуванням тощо. Однак у наступному обговоренні, ми будемо "
"використовувати термін метод виключно для позначення методів об’єктів "
"екземпляра класу, якщо явно не вказано інше.)"

msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Дійсні імена методів екземпляра об’єкта залежать від його класу. За "
"визначенням, усі атрибути класу, які є функціональними об’єктами, визначають "
"відповідні методи його екземплярів. Отже, у нашому прикладі ``x.f`` є "
"дійсним посиланням на метод, оскільки ``MyClass.f`` є функцією, але ``x.i`` "
"ні, оскільки ``MyClass.i`` не є таким. Але ``x.f`` — це не те саме, що "
"``MyClass.f`` --- це *об’єкт методу*, а не об’єкт функції."

msgid "Method Objects"
msgstr "Об’єкти методу"

msgid "Usually, a method is called right after it is bound::"
msgstr "Зазвичай метод викликається одразу після його зв’язування::"

msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"У прикладі :class:`MyClass` це поверне рядок ``'hello world'``. Однак не "
"обов’язково викликати метод одразу: ``x.f`` є об’єктом методу, його можна "
"зберегти та викликати пізніше. Наприклад::"

msgid "will continue to print ``hello world`` until the end of time."
msgstr "продовжуватиме друкувати ``hello world`` до кінця часу."

msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Що саме відбувається під час виклику методу? Можливо, ви помітили, що ``x."
"f()`` було викликано без аргументу вище, навіть якщо визначення функції для :"
"meth:`f` вказало аргумент. Що сталося з суперечкою? Звичайно, Python створює "
"виняток, коли функція, яка вимагає аргументу, викликається без будь-якого "
"--- навіть якщо аргумент насправді не використовується..."

msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Насправді, ви, можливо, здогадалися відповідь: особливість методів полягає в "
"тому, що об’єкт екземпляра передається як перший аргумент функції. У нашому "
"прикладі виклик ``x.f()`` точно еквівалентний ``MyClass.f(x)``. Загалом, "
"виклик методу зі списком *n* аргументів еквівалентний виклику відповідної "
"функції зі списком аргументів, який створюється шляхом вставки об’єкта "
"екземпляра методу перед першим аргументом."

msgid ""
"If you still don't understand how methods work, a look at the implementation "
"can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found "
"together in an abstract object: this is the method object.  When the method "
"object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""
"Якщо ви все ще не розумієте, як працюють методи, погляд на реалізацію може "
"прояснити ситуацію. Коли посилається на атрибут екземпляра, що не є даними, "
"виконується пошук у класі екземпляра. Якщо ім’я вказує на дійсний атрибут "
"класу, який є об’єктом функції, об’єкт методу створюється шляхом упаковки "
"(вказівників на) об’єкта екземпляра та об’єкта функції, щойно знайдених "
"разом в абстрактному об’єкті: це об’єкт методу. Коли об’єкт методу "
"викликається зі списком аргументів, новий список аргументів створюється з "
"об’єкта екземпляра та списку аргументів, а об’єкт функції викликається з цим "
"новим списком аргументів."

msgid "Class and Instance Variables"
msgstr "Змінні класу та екземпляра"

msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"Загалом, змінні екземпляра призначені для даних, унікальних для кожного "
"екземпляра, а змінні класу призначені для атрибутів і методів, спільних для "
"всіх екземплярів класу::"

msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Як обговорювалося в :ref:`tut-object`, спільні дані можуть мати несподіваний "
"ефект із залученням :term:`mutable` об’єктів, таких як списки та словники. "
"Наприклад, список *tricks* у наступному коді не слід використовувати як "
"змінну класу, тому що лише один список буде спільний для всіх екземплярів "
"*Dog*::"

msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Правильний дизайн класу повинен використовувати замість змінної екземпляра::"

msgid "Random Remarks"
msgstr "Випадкові зауваження"

msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Якщо однакове ім’я атрибута зустрічається як в екземплярі, так і в класі, "
"пошук атрибутів визначає пріоритет екземпляру::"

msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"На атрибути даних можуть посилатися як методи, так і звичайні користувачі "
"(\"клієнти\") об'єкта. Іншими словами, класи не можна використовувати для "
"реалізації чистих абстрактних типів даних. Фактично, ніщо в Python не "
"дозволяє примусово приховувати дані --- все базується на конвенції. (З "
"іншого боку, реалізація Python, написана мовою C, може повністю приховати "
"деталі реалізації та контролювати доступ до об’єкта, якщо це необхідно; це "
"можна використовувати розширеннями Python, написаними мовою C.)"

msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Клієнти повинні використовувати атрибути даних обережно --- клієнти можуть "
"зіпсувати інваріанти, які підтримуються методами, штампуючи свої атрибути "
"даних. Зауважте, що клієнти можуть додавати власні атрибути даних до об’єкта "
"екземпляра, не впливаючи на валідність методів, за умови уникнення "
"конфліктів імен --- знову ж таки, угода про іменування може позбавити тут "
"багато головного болю."

msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Не існує скорочення для посилання на атрибути даних (або інші методи!) з "
"методів. Я вважаю, що це фактично підвищує читабельність методів: немає "
"жодного шансу сплутати локальні змінні та змінні екземпляра під час "
"перегляду методу."

msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Часто перший аргумент методу називається ``self``. Це не що інше, як "
"конвенція: назва ``self`` не має абсолютно ніякого особливого значення для "
"Python. Зауважте, однак, що через недотримання угоди ваш код може бути менш "
"читабельним для інших програмістів на Python, і також можливо, що програма "
"*браузера класів* може бути написана, яка спирається на таку угоду."

msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Будь-який функціональний об’єкт, який є атрибутом класу, визначає метод для "
"екземплярів цього класу. Не обов’язково, щоб визначення функції було "
"текстово укладено у визначення класу: присвоєння об’єкта функції локальній "
"змінній у класі також є нормальним. Наприклад::"

msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer "
"to function objects, and consequently they are all methods of instances of :"
"class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Тепер ``f``, ``g`` і ``h`` — усі атрибути класу :class:`C`, які посилаються "
"на функціональні об’єкти, і, отже, всі вони є методами екземплярів :class:"
"`C` --- ``h`` є точним еквівалентом ``g``. Зауважте, що ця практика зазвичай "
"служить лише для того, щоб заплутати читача програми."

msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Методи можуть викликати інші методи, використовуючи атрибути методу "
"аргументу ``self``::"

msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Методи можуть посилатися на глобальні імена так само, як і звичайні функції. "
"Глобальною областю, пов’язаною з методом, є модуль, що містить його "
"визначення. (Клас ніколи не використовується як глобальна область "
"видимості.) Хоча рідко можна зустріти вагому причину для використання "
"глобальних даних у методі, існує багато законних застосувань глобальної "
"області видимості: з одного боку, функції та модулі, імпортовані в глобальну "
"область видимості, можуть використовуватися методами, а також функціями та "
"класами, визначеними в ньому. Зазвичай клас, що містить метод, сам "
"визначений у цій глобальній області видимості, і в наступному розділі ми "
"знайдемо кілька вагомих причин, чому метод хоче посилатися на власний клас."

msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Кожне значення є об’єктом і, отже, має *клас* (також називається його "
"*типом*). Він зберігається як ``object.__class__``."

msgid "Inheritance"
msgstr "Спадщина"

msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Звичайно, функція мови не була б гідною назви \"клас\" без підтримки "
"успадкування. Синтаксис для визначення похідного класу виглядає так:"

msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"Ім’я :class:`BaseClassName` має бути визначено в області, що містить "
"визначення похідного класу. Замість назви базового класу також допускаються "
"інші довільні вирази. Це може бути корисно, наприклад, коли базовий клас "
"визначено в іншому модулі:"

msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"Виконання визначення похідного класу відбувається так само, як і для "
"базового класу. Коли об'єкт класу створено, базовий клас запам'ятовується. "
"Це використовується для вирішення посилань на атрибути: якщо запитуваний "
"атрибут не знайдено в класі, пошук продовжується до базового класу. Це "
"правило застосовується рекурсивно, якщо сам базовий клас є похідним від "
"якогось іншого класу."

msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"У створенні похідних класів немає нічого особливого: ``DerivedClassName()`` "
"створює новий екземпляр класу. Посилання на метод розв’язуються наступним "
"чином: виконується пошук відповідного атрибута класу, спускаючись вниз по "
"ланцюжку базових класів, якщо необхідно, і посилання на метод є дійсним, "
"якщо це дає об’єкт функції."

msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Похідні класи можуть перевизначати методи своїх базових класів. Оскільки "
"методи не мають спеціальних привілеїв під час виклику інших методів того "
"самого об’єкта, метод базового класу, який викликає інший метод, визначений "
"у тому самому базовому класі, може призвести до виклику методу похідного "
"класу, який замінює його. (Для програмістів C++: усі методи в Python "
"фактично \"віртуальні\".)"

msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Перевизначений метод у похідному класі може фактично захотіти розширити, а "
"не просто замінити однойменний метод базового класу. Існує простий спосіб "
"безпосередньо викликати метод базового класу: просто викличте "
"``BaseClassName.methodname(self, arguments)``. Це також іноді корисно для "
"клієнтів. (Зауважте, що це працює, лише якщо базовий клас доступний як "
"``BaseClassName`` у глобальній області.)"

msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python має дві вбудовані функції, які працюють із успадкуванням:"

msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Використовуйте :func:`isinstance`, щоб перевірити тип екземпляра: "
"``isinstance(obj, int)`` буде ``True`` лише якщо ``obj.__class__`` є :class:"
"`int` або якийсь похідний клас з :class:`int`."

msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Використовуйте :func:`issubclass`, щоб перевірити успадкування класу: "
"``issubclass(bool, int)`` має значення ``True``, оскільки :class:`bool` є "
"підкласом :class:`int`. Однак ``issubclass(float, int)`` є ``False``, "
"оскільки :class:`float` не є підкласом :class:`int`."

msgid "Multiple Inheritance"
msgstr "Множинне успадкування"

msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python також підтримує форму множинного успадкування. Визначення класу з "
"кількома базовими класами виглядає так:"

msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes "
"of :class:`Base1`, and if it was not found there, it was searched for in :"
"class:`Base2`, and so on."
msgstr ""
"Для більшості цілей, у найпростіших випадках, ви можете думати про пошук "
"атрибутів, успадкованих від батьківського класу, як про пошук у глибину, "
"зліва направо, а не пошук двічі в тому самому класі, де є перекриття в "
"ієрархії. Таким чином, якщо атрибут не знайдено в :class:`DerivedClassName`, "
"він шукається в :class:`Base1`, потім (рекурсивно) в базових класах :class:"
"`Base1`, а якщо він не знайдений там його шукали в :class:`Base2` і так далі."

msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"Насправді це трохи складніше; порядок вирішення методів динамічно змінюється "
"для підтримки кооперативних викликів :func:`super`. Цей підхід відомий у "
"деяких інших мовах із множинним успадкуванням як call-next-method і є "
"потужнішим, ніж супервиклик у мовах з одним успадкуванням."

msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""
"Динамічне впорядкування є необхідним, тому що всі випадки множинного "
"успадкування демонструють один або більше ромбоподібних зв’язків (де "
"принаймні до одного з батьківських класів можна отримати доступ через кілька "
"шляхів із найнижчого класу). Наприклад, усі класи успадковуються від :class:"
"`object`, тому будь-який випадок множинного успадкування забезпечує більше "
"ніж один шлях для досягнення :class:`object`. Щоб запобігти повторному "
"доступу до базових класів, динамічний алгоритм лінеаризує порядок пошуку "
"таким чином, що зберігає порядок зліва направо, визначений у кожному класі, "
"що викликає кожного батьківського елемента лише один раз, і це є монотонним "
"(це означає, що клас може бути підкласом, не впливаючи на порядок пріоритету "
"його батьків). У сукупності ці властивості дозволяють створювати надійні та "
"розширювані класи з множинним успадкуванням. Для отримання додаткової "
"інформації див. https://www.python.org/download/releases/2.3/mro/."

msgid "Private Variables"
msgstr "Приватні змінні"

msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"\"Приватні\" змінні екземпляра, до яких можна отримати доступ лише зсередини "
"об’єкта, не існують у Python. Проте існує конвенція, якої дотримується "
"більшість коду Python: ім’я з префіксом підкреслення (наприклад, ``_spam``) "
"має розглядатися як непублічна частина API (незалежно від того, чи це "
"функція, метод чи член даних). Це слід розглядати як деталь впровадження та "
"може бути змінено без попередження."

msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Оскільки існує дійсний варіант використання для приватних членів класу (а "
"саме, щоб уникнути зіткнень імен імен з іменами, визначеними підкласами), "
"існує обмежена підтримка такого механізму, що називається :dfn:`name "
"mangling`. Будь-який ідентифікатор у формі ``__spam`` (принаймні два символи "
"підкреслення на початку, не більше одного символу підкреслення в кінці) "
"текстово замінюється на ``_classname__spam``, де ``classname`` є поточною "
"назвою класу з підкресленням на початку оголений. Це спотворення виконується "
"без урахування синтаксичної позиції ідентифікатора, доки воно трапляється у "
"визначенні класу."

msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Викривлення імен корисне для того, щоб дозволити підкласам перевизначати "
"методи, не порушуючи виклики внутрішньокласових методів. Наприклад::"

msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"Наведений вище приклад працював би, навіть якби ``MappingSubclass`` вводив "
"ідентифікатор ``__update``, оскільки він замінений на ``_Mapping__update`` у "
"``Mapping`` класі ``_MappingSubclass__update`` у ``Клас MappingSubclass`` "
"відповідно."

msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Зауважте, що правила псування призначені здебільшого для уникнення нещасних "
"випадків; все ще можна отримати доступ або змінити змінну, яка вважається "
"приватною. Це навіть може бути корисним за особливих обставин, наприклад, у "
"налагоджувачі."

msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Зауважте, що код, переданий у ``exec()`` або ``eval()``, не вважає назву "
"класу викликаного класу поточним класом; це схоже на дію оператора "
"``global``, дія якого так само обмежена кодом, який скомпільовано разом. Те "
"саме обмеження стосується getattr(), setattr() і delattr(), а також прямого "
"посилання на __dict__."

msgid "Odds and Ends"
msgstr "Обривки"

msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Іноді корисно мати тип даних, схожий на Pascal \"record\" або C \"struct\", "
"об'єднуючи кілька іменованих елементів даних. Порожнє визначення класу "
"підійде:"

msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`read` and :meth:`!"
"readline` that get the data from a string buffer instead, and pass it as an "
"argument."
msgstr ""
"Фрагмент коду Python, який очікує певний абстрактний тип даних, часто можна "
"передати класу, який емулює методи цього типу даних. Наприклад, якщо у вас є "
"функція, яка форматує деякі дані з файлового об’єкта, ви можете визначити "
"клас за допомогою методів :meth:`read` і :meth:`!readline`, які натомість "
"отримують дані з рядкового буфера та передають це як аргумент."

msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance "
"object with the method :meth:`m`, and ``m.__func__`` is the function object "
"corresponding to the method."
msgstr ""
"Об’єкти методів екземплярів також мають атрибути: ``m.__self__`` — об’єкт "
"екземпляра з методом :meth:`m`, а ``m.__func__`` — об’єкт функції, що "
"відповідає методу."

msgid "Iterators"
msgstr "Ітератори"

msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Наразі ви, мабуть, помітили, що більшість об’єктів-контейнерів можна "
"зациклювати за допомогою оператора :keyword:`for`::"

msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Цей стиль доступу є зрозумілим, лаконічним і зручним. Використання "
"ітераторів пронизує й уніфікує Python. За лаштунками оператор :keyword:`for` "
"викликає :func:`iter` об’єкта контейнера. Функція повертає об’єкт-ітератор, "
"який визначає метод :meth:`~iterator.__next__`, який отримує доступ до "
"елементів у контейнері по одному. Коли елементів більше немає, :meth:"
"`~iterator.__next__` викликає виняток :exc:`StopIteration`, який повідомляє "
"циклу :keyword:`!for` про завершення. Ви можете викликати метод :meth:"
"`~iterator.__next__` за допомогою вбудованої функції :func:`next`; цей "
"приклад показує, як це все працює:"

msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""
"Побачивши механіку протоколу ітератора, можна легко додати поведінку "
"ітератора до своїх класів. Визначте метод :meth:`__iter__`, який повертає "
"об’єкт за допомогою методу :meth:`~iterator.__next__`. Якщо клас визначає :"
"meth:`__next__`, тоді :meth:`__iter__` може просто повернути ``self``::"

msgid "Generators"
msgstr "Генератори"

msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` — простий і потужний інструмент для створення "
"ітераторів. Вони написані як звичайні функції, але використовують оператор :"
"keyword:`yield`, коли вони хочуть повернути дані. Кожного разу, коли на "
"ньому викликається :func:`next`, генератор продовжує роботу з того місця, де "
"зупинився (він запам’ятовує всі значення даних і який оператор був виконаний "
"останнім). Приклад показує, що генератори можна тривіально легко створити:"

msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods "
"are created automatically."
msgstr ""
"Усе, що можна зробити за допомогою генераторів, також можна зробити за "
"допомогою ітераторів на основі класів, як описано в попередньому розділі. Що "
"робить генератори такими компактними, так це те, що методи :meth:`__iter__` "
"і :meth:`~generator.__next__` створюються автоматично."

msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Інша ключова особливість полягає в тому, що локальні змінні та стан "
"виконання автоматично зберігаються між викликами. Це зробило функцію легшою "
"для написання та набагато зрозумілішою, ніж підхід із використанням змінних "
"екземплярів, таких як ``self.index`` і ``self.data``."

msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"На додаток до автоматичного створення методу та збереження стану програми, "
"коли генератори завершуються, вони автоматично викликають :exc:"
"`StopIteration`. У поєднанні ці функції дозволяють легко створювати "
"ітератори без зусиль, ніж написання звичайної функції."

msgid "Generator Expressions"
msgstr "Генератор виразів"

msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Деякі прості генератори можна коротко закодувати як вирази за допомогою "
"синтаксису, схожого на розуміння списків, але з круглими дужками замість "
"квадратних. Ці вирази розроблені для ситуацій, коли генератор "
"використовується одразу функцією охоплення. Вирази генератора є більш "
"компактними, але менш універсальними, ніж повні визначення генераторів, і, "
"як правило, більш зручні для пам’яті, ніж еквівалентні списки."

msgid "Examples::"
msgstr "Приклади::"

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"За винятком одного. Об’єкти модуля мають секретний атрибут лише для читання "
"під назвою :attr:`~object.__dict__`, який повертає словник, використаний для "
"реалізації простору імен модуля; ім'я :attr:`~object.__dict__` є атрибутом, "
"але не глобальним іменем. Очевидно, що використання цього порушує абстракцію "
"реалізації простору імен, і його слід обмежити такими речами, як посмертні "
"відладчики."
