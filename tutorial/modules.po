# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Modules"
msgstr "Модулі"

msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Якщо ви вийшли з інтерпретатора Python і ввели його знову, зроблені вами "
"визначення (функції та змінні) буде втрачено. Тому, якщо ви хочете написати "
"дещо довшу програму, вам краще використовувати текстовий редактор, щоб "
"підготувати вхідні дані для інтерпретатора, а замість цього запустити її з "
"цим файлом як вхідними. Це відоме як створення *сценарію*. Коли ваша "
"програма стає довшою, ви можете розділити її на кілька файлів для полегшення "
"обслуговування. Ви також можете використати зручну функцію, яку ви написали "
"в кількох програмах, не копіюючи її визначення в кожну програму."

msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"Для підтримки цього Python має спосіб помістити визначення у файл і "
"використовувати їх у сценарії або в інтерактивному екземплярі "
"інтерпретатора. Такий файл називається *модулем*; визначення з модуля можна "
"*імпортувати* в інші модулі або в *головний* модуль (набір змінних, до яких "
"ви маєте доступ у сценарії, що виконується на верхньому рівні та в режимі "
"калькулятора)."

msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"Модуль — це файл, що містить визначення та оператори Python. Ім’я файлу — це "
"ім’я модуля з суфіксом :file:`.py`. У межах модуля ім’я модуля (у вигляді "
"рядка) доступне як значення глобальної змінної ``__name__``. Наприклад, "
"скористайтеся своїм улюбленим текстовим редактором, щоб створити файл під "
"назвою :file:`fibo.py` у поточному каталозі з таким вмістом::"

msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"Тепер увійдіть до інтерпретатора Python та імпортуйте цей модуль за "
"допомогою наступної команди:"

msgid ""
"This does not enter the names of the functions defined in ``fibo``  directly "
"in the current symbol table; it only enters the module name ``fibo`` there. "
"Using the module name you can access the functions::"
msgstr ""
"Це не вводить назви функцій, визначених у ``fibo``  безпосередньо в поточну "
"таблицю символів; він вводить туди лише назву модуля ``fibo``. "
"Використовуючи назву модуля, ви можете отримати доступ до функцій::"

msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"Якщо ви маєте намір часто використовувати функцію, ви можете призначити їй "
"локальну назву:"

msgid "More on Modules"
msgstr "Детальніше про модулі"

msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"Модуль може містити виконувані оператори, а також визначення функцій. Ці "
"оператори призначені для ініціалізації модуля. Вони виконуються лише "
"*вперше*, коли ім’я модуля зустрічається в операторі імпорту. [#]_ (Вони "
"також запускаються, якщо файл виконується як сценарій.)"

msgid ""
"Each module has its own private symbol table, which is used as the global "
"symbol table by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"Кожен модуль має власну приватну таблицю символів, яка використовується як "
"глобальна таблиця символів усіма функціями, визначеними в модулі. Таким "
"чином, автор модуля може використовувати глобальні змінні в модулі, не "
"турбуючись про випадкові зіткнення з глобальними змінними користувача. З "
"іншого боку, якщо ви знаєте, що робите, ви можете торкнутися глобальних "
"змінних модуля за допомогою тієї самої нотації, яка використовується для "
"посилань на його функції, ``modname.itemname``."

msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names are placed in the importing "
"module's global symbol table."
msgstr ""
"Модулі можуть імпортувати інші модулі. Зазвичай, але не обов’язково, "
"розміщувати всі оператори :keyword:`import` на початку модуля (або сценарію, "
"якщо на те пішло). Назви імпортованих модулів розміщуються в глобальній "
"таблиці символів модуля імпорту."

msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's symbol table.  For "
"example::"
msgstr ""
"Існує варіант оператора :keyword:`import`, який імпортує імена з модуля "
"безпосередньо в таблицю символів модуля імпорту. Наприклад::"

msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local symbol table (so in the example, ``fibo`` is not defined)."
msgstr ""
"Це не вводить назву модуля, з якого беруться імпорти, у локальній таблиці "
"символів (тому в прикладі, ``fibo`` не визначено)."

msgid "There is even a variant to import all names that a module defines::"
msgstr "Існує навіть варіант імпорту всіх імен, які визначає модуль:"

msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"Це імпортує всі імена, крім тих, що починаються з підкреслення (``_``). У "
"більшості випадків програмісти Python не використовують цю можливість, "
"оскільки вона вводить невідомий набір імен в інтерпретатор, можливо, "
"приховуючи деякі речі, які ви вже визначили."

msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"Зауважте, що загалом практика імпортування ``*`` з модуля чи пакету викликає "
"негативне ставлення, оскільки це часто призводить до поганої читабельності "
"коду. Однак його можна використовувати, щоб не вводити текст під час "
"інтерактивних сеансів."

msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Якщо ім’я модуля супроводжується :keyword:`!as`, тоді ім’я після :keyword:`!"
"as` прив’язується безпосередньо до імпортованого модуля."

msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"Це фактично імпортує модуль таким же чином, як і ``import fibo``, з тією "
"лише різницею, що він доступний як ``fib``."

msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"Його також можна використовувати при використанні :keyword:`from` з "
"подібними ефектами::"

msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
"З міркувань ефективності кожен модуль імпортується лише один раз за сеанс "
"інтерпретатора. Таким чином, якщо ви змінюєте свої модулі, ви повинні "
"перезапустити інтерпретатор -- або, якщо це лише один модуль, який ви хочете "
"протестувати в інтерактивному режимі, використайте :func:`importlib.reload`, "
"напр. ``імпорт importlib; importlib.reload(modulename)``."

msgid "Executing modules as scripts"
msgstr "Виконання модулів у вигляді скриптів"

msgid "When you run a Python module with ::"
msgstr "Коли ви запускаєте модуль Python з ::"

msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"код у модулі буде виконано так само, як якщо б ви його імпортували, але з "
"``__name__`` встановленим на ``\"__main__\"``. Це означає, що додавши цей "
"код у кінці вашого модуля:"

msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"ви можете зробити файл придатним для використання як сценарій, а також як "
"імпортований модуль, оскільки код, який аналізує командний рядок, "
"запускається, лише якщо модуль виконується як \"основний\" файл:"

msgid "If the module is imported, the code is not run::"
msgstr "Якщо модуль імпортовано, код не виконується::"

msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"Це часто використовується або для забезпечення зручного інтерфейсу "
"користувача для модуля, або для цілей тестування (запуск модуля як сценарію "
"виконує набір тестів)."

msgid "The Module Search Path"
msgstr "Шлях пошуку модуля"

msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. These module names are listed in :data:"
"`sys.builtin_module_names`. If not found, it then searches for a file named :"
"file:`spam.py` in a list of directories given by the variable :data:`sys."
"path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"Коли імпортується модуль із назвою :mod:`spam`, інтерпретатор спочатку шукає "
"вбудований модуль із такою назвою. Назви цих модулів перераховані в :data:"
"`sys.builtin_module_names`. Якщо не знайдено, він шукає файл із назвою :file:"
"`spam.py` у списку каталогів, заданому змінною :data:`sys.path`. :data:`sys."
"path` ініціалізується з цих місць:"

msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"Каталог, що містить вхідний сценарій (або поточний каталог, якщо файл не "
"вказано)."

msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (список імен каталогів із тим самим синтаксисом, що й "
"змінна оболонки :envvar:`PATH`)."

msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"Типове значення, що залежить від встановлення (за домовленістю включає "
"каталог ``site-packages``, який обробляється модулем :mod:`site`)."

msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"У файлових системах, які підтримують символічні посилання, каталог, що "
"містить вхідний сценарій, обчислюється після переходу за символічним "
"посиланням. Іншими словами, каталог, що містить символічне посилання, **не** "
"додається до шляху пошуку модуля."

msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"Після ініціалізації програми Python можуть змінювати :data:`sys.path`. "
"Каталог, що містить запущений скрипт, розміщується на початку шляху пошуку, "
"перед стандартним шляхом до бібліотеки. Це означає, що скрипти в цьому "
"каталозі будуть завантажені замість однойменних модулів у каталозі "
"бібліотеки. Це помилка, якщо заміна не призначена. Перегляньте розділ :ref:"
"`tut-standardmodules` для отримання додаткової інформації."

msgid "\"Compiled\" Python files"
msgstr "\"Компільовані\" файли Python"

msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"Щоб прискорити завантаження модулів, Python кешує скомпільовану версію "
"кожного модуля в каталозі ``__pycache__`` під назвою :file:`module.{version}."
"pyc`, де версія кодує формат скомпільованого файлу; зазвичай містить номер "
"версії Python. Наприклад, у випуску CPython 3.3 скомпільована версія spam.py "
"буде кешована як ``__pycache__/spam.cpython-33.pyc``. Ця угода про "
"іменування дозволяє співіснувати скомпільованим модулям з різних випусків і "
"різних версій Python."

msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"Python порівнює дату модифікації вихідного коду зі скомпільованою версією, "
"щоб перевірити, чи вона застаріла та потребує перекомпіляції. Це повністю "
"автоматичний процес. Крім того, скомпільовані модулі не залежать від "
"платформи, тому одна й та сама бібліотека може використовуватися між "
"системами з різними архітектурами."

msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"Python не перевіряє кеш у двох випадках. По-перше, він завжди перекомпілює і "
"не зберігає результат для модуля, який завантажується безпосередньо з "
"командного рядка. По-друге, він не перевіряє кеш, якщо немає вихідного "
"модуля. Щоб підтримувати дистрибутив без вихідного коду (лише "
"скомпільований), скомпільований модуль має бути у вихідному каталозі, а "
"вихідного модуля не повинно бути."

msgid "Some tips for experts:"
msgstr "Деякі поради експертам:"

msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"Ви можете використовувати перемикачі :option:`-O` або :option:`-OO` у "
"команді Python, щоб зменшити розмір скомпільованого модуля. Перемикач ``-O`` "
"видаляє оператори assert, перемикач ``-OO`` видаляє як оператори assert, так "
"і рядки __doc__. Оскільки деякі програми можуть покладатися на їх наявність, "
"вам слід використовувати цей параметр, лише якщо ви знаєте, що робите. "
"\"Оптимізовані\" модулі мають тег ``opt-`` і зазвичай менші. Майбутні "
"випуски можуть змінити результати оптимізації."

msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"Програма не працює швидше, коли вона читається з файлу ``.pyc``, ніж коли "
"вона зчитується з файлу ``.py``; єдине, що є швидшим у файлах ``.pyc``, це "
"швидкість, з якою вони завантажуються."

msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
"Модуль :mod:`compileall` може створювати файли .pyc для всіх модулів у "
"каталозі."

msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
"Більш детальну інформацію про цей процес, включаючи блок-схему рішень, можна "
"знайти в :pep:`3147`."

msgid "Standard Modules"
msgstr "Стандартні модулі"

msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python постачається з бібліотекою стандартних модулів, описаних в окремому "
"документі, Довідник бібліотеки Python (далі \"Довідник бібліотеки\"). Деякі "
"модулі вбудовані в інтерпретатор; вони надають доступ до операцій, які не є "
"частиною ядра мови, але, тим не менш, вбудовані, або для ефективності, або "
"для забезпечення доступу до примітивів операційної системи, таких як "
"системні виклики. Набір таких модулів є опцією конфігурації, яка також "
"залежить від базової платформи. Наприклад, модуль :mod:`winreg` доступний "
"лише в системах Windows. Один окремий модуль заслуговує на увагу: :mod:"
"`sys`, який вбудовано в кожен інтерпретатор Python. Змінні ``sys.ps1`` і "
"``sys.ps2`` визначають рядки, які використовуються як первинні та додаткові "
"підказки:"

msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr ""
"Ці дві змінні визначені, лише якщо інтерпретатор перебуває в інтерактивному "
"режимі."

msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"Змінна ``sys.path`` - це список рядків, який визначає шлях пошуку модулів "
"інтерпретатором. Він ініціалізується шляхом за замовчуванням, взятим із "
"змінної середовища :envvar:`PYTHONPATH`, або з вбудованого за замовчуванням, "
"якщо :envvar:`PYTHONPATH` не встановлено. Ви можете змінити його за "
"допомогою стандартних операцій зі списком:"

msgid "The :func:`dir` Function"
msgstr "Функція :func:`dir`"

msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"Вбудована функція :func:`dir` використовується, щоб дізнатися, які імена "
"визначає модуль. Він повертає відсортований список рядків::"

msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr ""
"Без аргументів :func:`dir` перераховує імена, які ви визначили на даний "
"момент::"

msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"Зверніть увагу, що в ньому перераховано всі типи імен: змінні, модулі, "
"функції тощо."

msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` не містить списку вбудованих функцій і змінних. Якщо вам "
"потрібен їх список, вони визначені в стандартному модулі :mod:`builtins`::"

msgid "Packages"
msgstr "пакети"

msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or Pillow from having to worry "
"about each other's module names."
msgstr ""
"Пакети — це спосіб структурування простору імен модулів Python за допомогою "
"\"пунктирних імен модулів\". Наприклад, назва модуля :mod:`A.B` позначає "
"підмодуль під назвою ``B`` у пакеті під назвою ``A``. Подібно до того, як "
"використання модулів позбавляє авторів різних модулів від необхідності "
"турбуватися про глобальні імена змінних один одного, використання пунктирних "
"імен модулів позбавляє авторів багатомодульних пакетів, таких як NumPy або "
"Pillow, від необхідності турбуватися про імена модулів один одного ."

msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"Припустімо, ви хочете розробити набір модулів (\"пакет\") для однакової "
"обробки звукових файлів і звукових даних. Існує багато різних форматів "
"звукових файлів (зазвичай розпізнаються за їх розширенням, наприклад: :file:"
"`.wav`, :file:`.aiff`, :file:`.au`), тому вам може знадобитися створювати та "
"підтримувати зростаюча колекція модулів для перетворення між різними "
"форматами файлів. Існує також багато різних операцій, які ви можете виконати "
"зі звуковими даними (наприклад, мікшування, додавання відлуння, застосування "
"функції еквалайзера, створення штучного стереоефекту), тож на додаток ви "
"будете писати нескінченний потік модулів для виконання ці операції. Ось "
"можлива структура для вашого пакета (виражена в термінах ієрархічної "
"файлової системи):"

msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"Під час імпортування пакета Python шукає підкаталог пакета в каталогах ``sys."
"path``."

msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages.  This prevents directories with a common "
"name, such as ``string``, unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"Файли :file:`__init__.py` потрібні, щоб Python розглядав каталоги, що "
"містять файл, як пакети. Це запобігає випадковому приховуванню дійсних "
"модулів у каталогах із загальною назвою, як-от ``рядок``, які з’являються "
"пізніше на шляху пошуку модуля. У найпростішому випадку :file:`__init__.py` "
"може бути просто порожнім файлом, але він також може виконувати код "
"ініціалізації для пакета або встановлювати змінну ``__all__``, описану "
"пізніше."

msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"Користувачі пакету можуть імпортувати окремі модулі з пакета, наприклад:"

msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"Це завантажує підмодуль :mod:`sound.effects.echo`. На нього має бути повна "
"назва. ::"

msgid "An alternative way of importing the submodule is::"
msgstr "Альтернативний спосіб імпорту субмодуля:"

msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"Це також завантажує підмодуль :mod:`echo` і робить його доступним без "
"префікса пакету, тому його можна використовувати наступним чином::"

msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"Ще одним варіантом є імпорт потрібної функції або змінної безпосередньо:"

msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""
"Знову ж таки, це завантажує підмодуль :mod:`echo`, але це робить його "
"функцію :func:`echofilter` безпосередньо доступною::"

msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"Зауважте, що при використанні ``з елемента імпорту пакета``, елемент може "
"бути або підмодулем (або підпакетом) пакета, або іншим ім’ям, визначеним у "
"пакеті, як-от функція, клас або змінна. Оператор ``import`` спочатку "
"перевіряє, чи визначено елемент у пакеті; якщо ні, він припускає, що це "
"модуль, і намагається його завантажити. Якщо не вдається знайти його, "
"виникає виняток :exc:`ImportError`."

msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"Навпаки, при використанні такого синтаксису, як ``import item.subitem."
"subsubitem``, кожен елемент, крім останнього, має бути пакетом; останній "
"елемент може бути модулем або пакетом, але не може бути класом, функцією чи "
"змінною, визначеною в попередньому елементі."

msgid "Importing \\* From a Package"
msgstr "Імпортування \\* з пакету"

msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"Тепер що відбувається, коли користувач пише ``from sound.effects import *``? "
"В ідеалі можна було б сподіватися, що це якимось чином переходить до "
"файлової системи, знаходить, які підмодулі присутні в пакунку, і імпортує їх "
"усі. Це може зайняти багато часу, а імпортування субмодулів може мати "
"небажані побічні ефекти, які мають статися лише тоді, коли субмодуль "
"імпортовано явно."

msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"Єдине рішення полягає в тому, щоб автор пакета надав явний індекс пакета. "
"Інструкція :keyword:`import` використовує таку умову: якщо код :file:"
"`__init__.py` пакета визначає список під назвою ``__all__``, він вважається "
"списком імен модулів, які слід імпортувати, коли Зустрічається ``from "
"package import *``. Автор пакета повинен підтримувати цей список актуальним, "
"коли виходить нова версія пакета. Автори пакетів також можуть вирішити не "
"підтримувати його, якщо вони не бачать користі для імпортування \\* зі свого "
"пакета. Наприклад, файл :file:`sound/effects/__init__.py` може містити такий "
"код:"

msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound.effects` package."
msgstr ""
"Це означатиме, що ``from sound.effects import *`` імпортуватиме три названі "
"підмодулі пакета :mod:`sound.effects`."

msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""
"Якщо ``__all__`` не визначено, оператор ``from sound.effects import *`` *не* "
"імпортує всі субмодулі з пакета :mod:`sound.effects` в поточний простір "
"імен; він лише гарантує, що пакунок :mod:`sound.effects` було імпортовано "
"(можливо, запустивши будь-який код ініціалізації в :file:`__init__.py`), а "
"потім імпортує всі імена, визначені в пакунку. Це включає будь-які імена, "
"визначені (і підмодулі, явно завантажені) :file:`__init__.py`. Він також "
"включає будь-які підмодулі пакета, які були явно завантажені попередніми "
"операторами :keyword:`import`. Розгляньте цей код::"

msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""
"У цьому прикладі модулі :mod:`echo` і :mod:`surround` імпортовано в поточний "
"простір імен, оскільки вони визначені в пакеті :mod:`sound.effects`, коли "
"``from...import`` виконується оператор. (Це також працює, якщо визначено "
"``__all__``.)"

msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"Хоча певні модулі призначені для експорту лише імен, які відповідають певним "
"шаблонам, коли ви використовуєте ``import *``, це все ще вважається поганою "
"практикою у робочому коді."

msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"Пам’ятайте, що немає нічого поганого у використанні ``from package import "
"specific_submodule``! Фактично, це рекомендована нотація, якщо тільки "
"імпортуючому модулю не потрібно використовувати підмодулі з однаковими "
"назвами з різних пакунків."

msgid "Intra-package References"
msgstr "Внутрішньопакетні посилання"

msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"Коли пакунки структуровані на підпакунки (як у випадку з пакетом :mod:"
"`sound` у прикладі), ви можете використовувати абсолютний імпорт для "
"посилання на підмодулі пакетів-братів. Наприклад, якщо модуль :mod:`sound."
"filters.vocoder` потребує використання модуля :mod:`echo` у пакунку :mod:"
"`sound.effects`, він може використовувати ``from sound.effects import echo``."

msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`surround` module for example, you might use::"
msgstr ""
"Ви також можете написати відносні імпорти за допомогою форми оператора "
"імпорту ``from module import name``. У цих імпортах використовуються крапки "
"на початку для позначення поточного та батьківського пакетів, які беруть "
"участь у відносному імпорті. Наприклад, у модулі :mod:`surround` можна "
"використовувати::"

msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"Зауважте, що відносний імпорт базується на назві поточного модуля. Оскільки "
"назва головного модуля завжди ``\"__main__\"``, модулі, призначені для "
"використання як головного модуля програми Python, повинні завжди "
"використовувати абсолютний імпорт."

msgid "Packages in Multiple Directories"
msgstr "Пакунки в кількох каталогах"

msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""
"Пакунки підтримують ще один спеціальний атрибут, :attr:`__path__`. Це "
"ініціалізується як список, що містить ім’я каталогу, що містить :file:"
"`__init__.py` пакета перед виконанням коду в цьому файлі. Ця змінна може "
"бути змінена; це впливає на майбутній пошук модулів і підпакетів, що "
"містяться в пакеті."

msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"Хоча ця функція не часто потрібна, її можна використовувати для розширення "
"набору модулів, які містяться в пакеті."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition enters the function name in "
"the module's global symbol table."
msgstr ""
"Насправді визначення функцій також є \"операторами\", які \"виконуються\"; "
"виконання визначення функції на рівні модуля вводить назву функції в "
"глобальну таблицю символів модуля."
