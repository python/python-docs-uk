# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Functional Programming HOWTO"
msgstr "Функціональне програмування HOWTO"

msgid "Author"
msgstr "Автор"

msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

msgid "Release"
msgstr "Реліз"

msgid "0.32"
msgstr "0,32"

msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"У цьому документі ми ознайомимося з функціями Python, придатними для "
"реалізації програм у функціональному стилі. Після вступу до концепцій "
"функціонального програмування ми розглянемо функції мови, такі як :term:"
"`iterator`\\s і :term:`generator`\\s, а також відповідні бібліотечні модулі, "
"такі як :mod:`itertools` і  :mod:`functools`."

msgid "Introduction"
msgstr "вступ"

msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"У цьому розділі пояснюється основна концепція функціонального програмування; "
"якщо вам просто цікаво дізнатися про функції мови Python, перейдіть до "
"наступного розділу :ref:`functional-howto-iterators`."

msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr ""
"Мови програмування підтримують декомпозицію проблем кількома різними "
"способами:"

msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"Більшість мов програмування є **процедурними**: програми — це списки "
"інструкцій, які вказують комп’ютеру, що робити з вхідними даними програми. "
"C, Pascal і навіть оболонки Unix є процедурними мовами."

msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"У **декларативних** мовах ви пишете специфікацію, яка описує проблему, яку "
"потрібно вирішити, а реалізація мови визначає, як виконати обчислення "
"ефективно. SQL — це декларативна мова, з якою ви, швидше за все, знайомі; "
"SQL-запит описує набір даних, який ви хочете отримати, і механізм SQL "
"вирішує, сканувати таблиці чи використовувати індекси, які підпункти слід "
"виконати першими тощо."

msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"**Об’єктно-орієнтовані** програми маніпулюють колекціями об’єктів. Об’єкти "
"мають внутрішній стан і підтримують методи, які певним чином запитують або "
"змінюють цей внутрішній стан. Smalltalk і Java є об'єктно-орієнтованими "
"мовами. C++ і Python — це мови, які підтримують об’єктно-орієнтоване "
"програмування, але не примусово використовують об’єктно-орієнтовані функції."

msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**Функціональне** програмування розкладає проблему на набір функцій. В "
"ідеалі функції лише приймають вхідні дані та виробляють виходи, і не мають "
"жодного внутрішнього стану, який впливає на вихідні дані, отримані для "
"даного вхідного елемента. Добре відомі функціональні мови включають "
"сімейство ML (Standard ML, OCaml та інші варіанти) і Haskell."

msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"Розробники деяких комп’ютерних мов вирішують наголосити на одному "
"конкретному підході до програмування. Це часто ускладнює написання програм, "
"які використовують інший підхід. Інші мови є мовами з кількома парадигмами, "
"які підтримують кілька різних підходів. Lisp, C++ і Python є "
"мультипарадигмальними; ви можете писати програми або бібліотеки, які в "
"основному є процедурними, об'єктно-орієнтованими або функціональними на всіх "
"цих мовах. У великій програмі різні розділи можуть бути написані з "
"використанням різних підходів; GUI може бути об'єктно-орієнтованим, тоді як "
"логіка обробки є процедурною або функціональною, наприклад."

msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"У функціональній програмі введення проходить через набір функцій. Кожна "
"функція працює зі своїм входом і видає певний результат. Функціональний "
"стиль не заохочує функції з побічними ефектами, які змінюють внутрішній стан "
"або вносять інші зміни, які не видно у значенні, що повертається функцією. "
"Функції, які взагалі не мають побічних ефектів, називаються **чисто "
"функціональними**. Уникати побічних ефектів означає не використовувати "
"структури даних, які оновлюються під час виконання програми; кожен вихід "
"функції повинен залежати лише від її входу."

msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"Деякі мови дуже суворі щодо чистоти й навіть не мають операторів присвоєння, "
"таких як ``a=3`` або ``c = a + b``, але важко уникнути всіх побічних "
"ефектів, таких як друк на екрані або запис у файл диска. Іншим прикладом є "
"виклик функції :func:`print` або :func:`time.sleep`, жодна з яких не "
"повертає корисне значення. Обидва викликаються лише через побічні ефекти "
"надсилання тексту на екран або призупинення виконання на секунду."

msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Програми на Python, написані у функціональному стилі, зазвичай не йдуть до "
"крайнощів, щоб уникнути всього вводу-виводу або всіх призначень; замість "
"цього вони забезпечуватимуть функціональний інтерфейс, але "
"використовуватимуть нефункціональні функції всередині. Наприклад, реалізація "
"функції все одно використовуватиме призначення локальним змінним, але не "
"змінюватиме глобальні змінні чи матиме інші побічні ефекти."

msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"Функціональне програмування можна вважати протилежністю об'єктно-"
"орієнтованого програмування. Об’єкти — це маленькі капсули, що містять "
"певний внутрішній стан разом із набором викликів методів, які дозволяють "
"змінювати цей стан, а програми складаються із внесення правильних змін "
"стану. Функціональне програмування хоче якомога більше уникати змін стану та "
"працює з потоком даних між функціями. У Python ви можете поєднати два "
"підходи, написавши функції, які приймають і повертають екземпляри, що "
"представляють об’єкти у вашій програмі (повідомлення електронної пошти, "
"транзакції тощо)."

msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"Функціональний дизайн може здатися дивним обмеженням для роботи. Чому слід "
"уникати предметів і побічних ефектів? Існують теоретичні та практичні "
"переваги функціонального стилю:"

msgid "Formal provability."
msgstr "Формальна доказовість."

msgid "Modularity."
msgstr "Модульність."

msgid "Composability."
msgstr "Композиційність."

msgid "Ease of debugging and testing."
msgstr "Простота налагодження та тестування."

msgid "Formal provability"
msgstr "Формальна доказовість"

msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"Теоретична перевага полягає в тому, що легше побудувати математичний доказ "
"правильності функціональної програми."

msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"Довгий час дослідники були зацікавлені в пошуку способів математичної "
"перевірки правильності програм. Це відрізняється від тестування програми на "
"численних вхідних даних і висновку, що її вихід зазвичай правильний, або "
"читання вихідного коду програми та висновку, що код виглядає правильно; "
"натомість метою є суворий доказ того, що програма дає правильний результат "
"для всіх можливих вхідних даних."

msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"Техніка, яка використовується для підтвердження правильності програм, "
"полягає в записі **інваріантів**, властивостей вхідних даних і змінних "
"програми, які завжди є істинними. Для кожного рядка коду ви потім показуєте, "
"що якщо інваріанти X і Y істинні **до** виконання рядка, дещо інші "
"інваріанти X' і Y' є істинними **після** виконання рядка. Це продовжується, "
"доки ви не досягнете кінця програми, після чого інваріанти повинні "
"відповідати бажаним умовам на виході програми."

msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"Уникання присвоєння у функціональному програмуванні виникло тому, що "
"присвоєння важко обробляти за допомогою цієї техніки; призначення можуть "
"порушувати інваріанти, які були істинними до призначення, не створюючи "
"жодних нових інваріантів, які можна поширювати далі."

msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"На жаль, перевірка правильності програм в основному непрактична і не "
"стосується програмного забезпечення Python. Навіть тривіальні програми "
"вимагають доказів довжиною кілька сторінок; докази правильності для помірно "
"складної програми були б величезними, і мало або жодна з програм, якими ви "
"користуєтеся щодня (інтерпретатор Python, ваш аналізатор XML, ваш веб-"
"браузер), може бути доведена правильною. Навіть якщо ви записали або "
"згенерували доказ, тоді виникне питання перевірки доказу; можливо, у ньому є "
"помилка, і ви помилково вважаєте, що довели правильність програми."

msgid "Modularity"
msgstr "Модульність"

msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"Більш практична перевага функціонального програмування полягає в тому, що "
"воно змушує вас розбивати проблему на дрібні частини. В результаті програми "
"стають більш модульними. Простіше вказати та написати невелику функцію, яка "
"виконує щось одне, ніж велику функцію, яка виконує складне перетворення. "
"Невеликі функції також легше читати та перевіряти на наявність помилок."

msgid "Ease of debugging and testing"
msgstr "Простота налагодження та тестування"

msgid "Testing and debugging a functional-style program is easier."
msgstr "Тестування та налагодження програми у функціональному стилі легше."

msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"Налагодження спрощене, оскільки функції, як правило, невеликі та чітко "
"визначені. Коли програма не працює, кожна функція є точкою інтерфейсу, де "
"можна перевірити правильність даних. Ви можете переглянути проміжні входи та "
"виходи, щоб швидко виділити функцію, яка є відповідальною за помилку."

msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Тестування легше, тому що кожна функція є потенційним предметом модульного "
"тесту. Функції не залежать від стану системи, який потрібно відтворити перед "
"виконанням тесту; натомість вам потрібно лише синтезувати правильні вхідні "
"дані, а потім перевірити, чи результат відповідає очікуванням."

msgid "Composability"
msgstr "Композиційність"

msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"Працюючи над програмою функціонального стилю, ви напишете ряд функцій із "
"різними входами та виходами. Деякі з цих функцій неминуче будуть "
"спеціалізовані для конкретної програми, але інші будуть корисні в широкому "
"спектрі програм. Наприклад, функцію, яка приймає шлях до каталогу та "
"повертає всі файли XML у каталозі, або функцію, яка приймає ім’я файлу та "
"повертає його вміст, можна застосувати до багатьох різних ситуацій."

msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"З часом ви сформуєте особисту бібліотеку утиліт. Часто ви збираєте нові "
"програми, організовуючи існуючі функції в новій конфігурації та написавши "
"кілька функцій, спеціалізованих для поточного завдання."

msgid "Iterators"
msgstr "Ітератори"

msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Я почну з вивчення функції мови Python, яка є важливою основою для написання "
"програм у функціональному стилі: ітератори."

msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"Ітератор - це об'єкт, що представляє потік даних; цей об’єкт повертає дані "
"по одному елементу за раз. Ітератор Python має підтримувати метод під "
"назвою :meth:`~iterator.__next__`, який не приймає аргументів і завжди "
"повертає наступний елемент потоку. Якщо в потоці більше немає елементів, :"
"meth:`~iterator.__next__` має викликати виняток :exc:`StopIteration`. Проте "
"ітератори не обов’язково мають бути кінцевими; цілком розумно написати "
"ітератор, який створює нескінченний потік даних."

msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"Вбудована функція :func:`iter` приймає довільний об’єкт і намагається "
"повернути ітератор, який повертатиме вміст або елементи об’єкта, викликаючи :"
"exc:`TypeError`, якщо об’єкт не підтримує ітерацію. Кілька вбудованих типів "
"даних Python підтримують ітерацію, найпоширенішими з яких є списки та "
"словники. Об’єкт називається :term:`iterable`, якщо ви можете отримати для "
"нього ітератор."

msgid "You can experiment with the iteration interface manually:"
msgstr "Ви можете експериментувати з інтерфейсом ітерації вручну:"

msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python очікує ітерованих об’єктів у кількох різних контекстах, найважливішим "
"з яких є оператор :keyword:`for`. У операторі ``для X в Y`` Y має бути "
"ітератором або деяким об’єктом, для якого :func:`iter` може створити "
"ітератор. Ці два твердження еквівалентні:"

msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Ітератори можна матеріалізувати як списки або кортежі за допомогою функцій "
"конструктора :func:`list` або :func:`tuple`:"

msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"Розпакування послідовності також підтримує ітератори: якщо ви знаєте, що "
"ітератор поверне N елементів, ви можете розпакувати їх у N-кортеж:"

msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Вбудовані функції, такі як :func:`max` і :func:`min`, можуть приймати один "
"аргумент ітератора та повертати найбільший або найменший елемент. Оператори "
"``\"in\"`` і ``\"not in\"`` також підтримують ітератори: ``X в ітераторі`` є "
"істинним, якщо X знайдено в потоці, повернутому ітератором. Ви зіткнетеся з "
"очевидними проблемами, якщо ітератор нескінченний; :func:`max`, :func:`min` "
"ніколи не повертаються, а якщо елемент X ніколи не з’являється в потоці, "
"оператори ``\"in\"`` і ``\"not in\"`` не повертаються або."

msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"Зауважте, що в ітераторі можна рухатися лише вперед; немає способу отримати "
"попередній елемент, скинути ітератор або зробити його копію. Об’єкти-"
"ітератори можуть додатково надавати ці додаткові можливості, але протокол "
"ітераторів визначає лише метод :meth:`~iterator.__next__`. Тому функції "
"можуть споживати весь вихід ітератора, і якщо вам потрібно зробити щось інше "
"з тим самим потоком, вам доведеться створити новий ітератор."

msgid "Data Types That Support Iterators"
msgstr "Типи даних, які підтримують ітератори"

msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Ми вже бачили, як списки та кортежі підтримують ітератори. Насправді будь-"
"який тип послідовності Python, наприклад рядки, автоматично підтримуватиме "
"створення ітератора."

msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr ""
"Виклик :func:`iter` для словника повертає ітератор, який перебиратиме ключі "
"словника::"

msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Зауважте, що, починаючи з Python 3.7, порядок ітерацій словника гарантовано "
"збігається з порядком вставки. У попередніх версіях поведінка була "
"невизначеною та могла відрізнятися в різних реалізаціях."

msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"Застосування :func:`iter` до словника завжди повторює ключі, але словники "
"мають методи, які повертають інші ітератори. Якщо ви хочете перебирати "
"значення або пари ключ/значення, ви можете явно викликати методи :meth:"
"`~dict.values` або :meth:`~dict.items`, щоб отримати відповідний ітератор."

msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"Конструктор :func:`dict` може приймати ітератор, який повертає кінцевий "
"потік кортежів ``(ключ, значення)``:"

msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"Файли також підтримують ітерацію шляхом виклику методу :meth:`~io.TextIOBase."
"readline`, доки у файлі не залишиться рядків. Це означає, що ви можете "
"читати кожен рядок файлу таким чином:"

msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Набори можуть брати свій вміст із ітерованого елемента й дозволяти вам "
"перебирати елементи набору:"

msgid "Generator expressions and list comprehensions"
msgstr "Генератор виразів і розуміння списків"

msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Дві загальні операції на виході ітератора: 1) виконання певної операції для "
"кожного елемента, 2) вибір підмножини елементів, які відповідають певній "
"умові. Наприклад, маючи список рядків, ви можете видалити кінцеві пробіли з "
"кожного рядка або витягти всі рядки, що містять певний підрядок."

msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"Розуміння списків і вирази генератора (скорочена форма: \"listcomps\" і "
"\"genexps\") є короткою нотацією для таких операцій, запозиченої з "
"функціональної мови програмування Haskell (https://www.haskell.org/). Ви "
"можете видалити всі пробіли з потоку рядків за допомогою такого коду::"

msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "Ви можете вибрати лише певні елементи, додавши умову ``\"if\"``::"

msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"З розумінням списку ви отримуєте список Python; ``stripped_list`` – це "
"список, що містить отримані рядки, а не ітератор. Вирази генератора "
"повертають ітератор, який обчислює значення за потреби, не потребуючи "
"матеріалізації всіх значень одночасно. Це означає, що розуміння списку не є "
"корисним, якщо ви працюєте з ітераторами, які повертають нескінченний потік "
"або дуже великий обсяг даних. Вирази-генератори є кращими в цих ситуаціях."

msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"Вирази генератора оточені дужками (\"()\"), а розуміння списків оточені "
"квадратними дужками (\"[]\"). Вирази генератора мають вигляд::"

msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"Знову ж таки, для розуміння списку відрізняються лише зовнішні дужки "
"(квадратні дужки замість дужок)."

msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Елементи згенерованого результату будуть послідовними значеннями ``виразу``. "
"Речення ``if`` є необов'язковими; якщо присутнє, ``вираз`` обчислюється та "
"додається до результату лише тоді, коли ``умова`` є істинною."

msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"Вирази генератора завжди мають бути записані в дужках, але дужки, що "
"сигналізують про виклик функції, також враховуються. Якщо ви хочете створити "
"ітератор, який буде негайно передано функції, ви можете написати::"

msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"Речення ``for...in`` містять послідовності, які потрібно повторити. "
"Послідовності не обов’язково мають бути однакової довжини, оскільки вони "
"повторюються зліва направо, **не** паралельно. Для кожного елемента в "
"``sequence1`` ``sequence2`` повторюється з самого початку. Після цього "
"``sequence3`` виконується в циклі для кожної отриманої пари елементів з "
"``sequence1`` і ``sequence2``."

msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"Іншими словами, вираз розуміння списку або генератор еквівалентний такому "
"коду Python::"

msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Це означає, що коли є кілька пропозицій ``for...in``, але немає пропозицій "
"``if``, довжина результату буде дорівнювати добутку довжин усіх "
"послідовностей. Якщо у вас є два списки довжиною 3, вихідний список "
"складається з 9 елементів:"

msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Щоб уникнути неоднозначності в граматиці Python, якщо ``вираз`` створює "
"кортеж, він повинен бути оточений дужками. Перше розуміння списку нижче є "
"синтаксичною помилкою, тоді як друге є правильним:"

msgid "Generators"
msgstr "Генератори"

msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Генератори — це спеціальний клас функцій, які спрощують завдання написання "
"ітераторів. Звичайні функції обчислюють значення та повертають його, але "
"генератори повертають ітератор, який повертає потік значень."

msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Ви, безсумнівно, знайомі з тим, як працюють звичайні виклики функцій у "
"Python або C. Коли ви викликаєте функцію, вона отримує приватний простір "
"імен, де створюються її локальні змінні. Коли функція досягає оператора "
"``return``, локальні змінні знищуються, а значення повертається "
"викликаючому. Пізніший виклик тієї ж функції створює новий приватний простір "
"імен і новий набір локальних змінних. Але що, якби локальні змінні не були "
"викинуті під час виходу з функції? Що, якби ви могли пізніше відновити "
"функцію, де вона була зупинена? Це те, що забезпечують генератори; їх можна "
"розглядати як відновлювані функції."

msgid "Here's the simplest example of a generator function:"
msgstr "Ось найпростіший приклад функції генератора:"

msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"Будь-яка функція, що містить ключове слово :keyword:`yield`, є функцією-"
"генератором; це виявляється компілятором :term:`bytecode` Python, який "
"спеціально компілює функцію в результаті."

msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"Коли ви викликаєте функцію генератора, вона не повертає жодного значення; "
"замість цього він повертає об'єкт генератора, який підтримує протокол "
"ітератора. Під час виконання виразу ``yield`` генератор виводить значення "
"``i``, подібно до оператора ``return``. Велика різниця між оператором "
"``yield`` і оператором ``return`` полягає в тому, що після досягнення "
"``yield`` стан виконання генератора призупиняється, а локальні змінні "
"зберігаються. Під час наступного виклику методу генератора :meth:`~generator."
"__next__` функція відновить виконання."

msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Ось приклад використання генератора ``generate_ints()``:"

msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"Так само можна написати ``для i в generate_ints(5)`` або ``a, b, c = "
"generate_ints(3)``."

msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"Усередині функції-генератора ``повернене значення`` викликає "
"``StopIteration(value)``, яке буде викликано з методу :meth:`~generator."
"__next__`. Як тільки це станеться, або коли функція досягне дна, обробка "
"значень закінчується, і генератор не зможе видавати жодних додаткових "
"значень."

msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"Ви можете досягти ефекту генераторів вручну, написавши власний клас і "
"зберігши всі локальні змінні генератора як змінні екземпляра. Наприклад, "
"повернути список цілих чисел можна, встановивши ``self.count`` на 0, і "
"дозволивши методу :meth:`~iterator.__next__` збільшити ``self.count`` і "
"повернути його. Однак для помірно складного генератора написання "
"відповідного класу може бути набагато складнішим."

msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"Набір тестів, що входить до бібліотеки Python, :source:`Lib/test/"
"test_generators.py`, містить низку більш цікавих прикладів. Ось один "
"генератор, який реалізує рекурсивний обхід дерева за допомогою "
"генераторів. ::"

msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Два інших приклади в ``test_generators.py`` створюють рішення для проблеми N-"
"Queens (розміщення N ферзів на NxN шахівниці так, щоб жодна королева не "
"загрожувала іншій) і Knight's Tour (пошук маршруту, який веде лицаря до "
"кожної клітинки). шахової дошки NxN, не відвідуючи жодного поля двічі)."

msgid "Passing values into a generator"
msgstr "Передача значень у генератор"

msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"У Python 2.4 і раніших версіях генератори створювали лише вихідні дані. Як "
"тільки код генератора був викликаний для створення ітератора, не було "
"можливості передати будь-яку нову інформацію у функцію, коли її виконання "
"відновилося. Ви можете об’єднати цю здатність, змусивши генератор дивитися "
"на глобальну змінну або передавши якийсь змінний об’єкт, який потім змінюють "
"абоненти, але ці підходи є безладними."

msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"У Python 2.5 є простий спосіб передачі значень у генератор. :keyword:`yield` "
"став виразом, який повертає значення, яке можна присвоїти змінній або іншим "
"чином оперувати:"

msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Я рекомендую вам **завжди** брати дужки навколо виразу ``yield``, коли ви "
"робите щось із повернутим значенням, як у прикладі вище. Дужки не завжди "
"потрібні, але простіше завжди додавати їх замість того, щоб запам’ятовувати, "
"коли вони потрібні."

msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` пояснює точні правила, які полягають у тому, що вираз ``yield`` "
"завжди повинен бути взятий у дужки, за винятком випадків, коли він "
"зустрічається у виразі верхнього рівня в правій частині призначення. Це "
"означає, що ви можна написати ``val = yield i``, але потрібно "
"використовувати дужки, коли є операція, як у ``val = (yield i) + 12``.)"

msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"Значення надсилаються в генератор шляхом виклику його методу :meth:"
"`send(value) <generator.send>`. Цей метод відновлює код генератора, а вираз "
"``yield`` повертає вказане значення. Якщо викликається звичайний метод :meth:"
"`~generator.__next__`, ``yield`` повертає ``None``."

msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Ось простий лічильник, який збільшується на 1 і дозволяє змінювати значення "
"внутрішнього лічильника."

msgid "And here's an example of changing the counter:"
msgstr "А ось приклад зміни лічильника:"

msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"Оскільки ``yield`` часто повертатиме ``None``, ви завжди повинні перевіряти "
"цей випадок. Не просто використовуйте його значення у виразах, якщо ви не "
"впевнені, що метод :meth:`~generator.send` буде єдиним методом, використаним "
"для відновлення вашої функції генератора."

msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "Окрім :meth:`~generator.send`, у генераторах є ще два методи:"

msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the "
"generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` використовується для створення "
"винятку всередині генератора; виняток викликає вираз ``yield``, де виконання "
"генератора призупинено."

msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close` викликає виняткову ситуацію :exc:`GeneratorExit` "
"всередині генератора, щоб завершити ітерацію. Отримавши цей виняток, код "
"генератора повинен викликати :exc:`GeneratorExit` або :exc:`StopIteration`; "
"перехоплення винятку та будь-що інше є незаконним і спричинить :exc:"
"`RuntimeError`. :meth:`~generator.close` також буде викликано збирачем "
"сміття Python, коли генератор збирає сміття."

msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"Якщо вам потрібно запустити код очищення, коли виникає :exc:`GeneratorExit`, "
"я пропоную використовувати набір ``try: ... finally:`` замість перехоплення :"
"exc:`GeneratorExit`."

msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"Кумулятивний ефект цих змін полягає в тому, щоб перетворити генераторів з "
"односторонніх виробників інформації на виробників і споживачів."

msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Генератори також стають **співпрограмами**, більш узагальненою формою "
"підпрограм. Підпрограми вводяться в одній точці та виходять з іншої точки "
"(верхня частина функції та оператор \"return\"), але підпрограми можна "
"входити, виходити та продовжувати в багатьох різних точках (оператори "
"\"yield\" )."

msgid "Built-in functions"
msgstr "Вбудовані функції"

msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Давайте детальніше розглянемо вбудовані функції, які часто використовуються "
"з ітераторами."

msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Дві вбудовані функції Python, :func:`map` і :func:`filter` дублюють функції "
"генераторних виразів:"

msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` повертає ітератор у послідовності"

msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."

msgid "You can of course achieve the same effect with a list comprehension."
msgstr ""
"Звичайно, ви можете досягти такого ж ефекту за допомогою розуміння списку."

msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` повертає ітератор над усіма "
"елементами послідовності, які відповідають певній умові, і подібним чином "
"дублюється за допомогою списків. **Предикат** – це функція, яка повертає "
"значення істинності певної умови; для використання з :func:`filter` предикат "
"має приймати одне значення."

msgid "This can also be written as a list comprehension:"
msgstr "Це також можна записати як розуміння списку:"

msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` відраховує елементи в "
"ітераційному повертаючому 2-кортежі, що містить кількість (від *start*) і "
"кожен елемент. ::"

msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` часто використовується під час циклічного перегляду списку "
"та запису індексів, при яких виконуються певні умови:"

msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` збирає всі "
"елементи iterable у список, сортує список і повертає відсортований "
"результат. Аргументи *key* і *reverse* передаються до методу :meth:`~list."
"sort` створеного списку. ::"

msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"(Для більш детального обговорення сортування див. :ref:`sortinghowto`.)"

msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"Вбудовані функції :func:`any(iter) <any>` і :func:`all(iter) <all>` "
"переглядають значення істинності вмісту ітерованого елемента. :func:`any` "
"повертає ``True``, якщо будь-який елемент в iterable є істинним значенням, "
"а :func:`all` повертає ``True``, якщо всі елементи є істинними значеннями:"

msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` бере по одному елементу з кожного "
"iterable і повертає їх у кортежі::"

msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"Він не створює список у пам’яті та не вичерпує всі ітератори введення перед "
"поверненням; натомість кортежі створюються та повертаються лише за запитом. "
"(Технічний термін для такої поведінки — `лінива оцінка <https://en.wikipedia."
"org/wiki/Lazy_evaluation>`__.)"

msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Цей ітератор призначений для використання з ітераторами, які мають однакову "
"довжину. Якщо ітератори мають різну довжину, результуючий потік буде такої ж "
"довжини, як і найкоротший ітератор. ::"

msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Однак вам слід уникати цього, оскільки елемент може бути взято з довших "
"ітераторів і відкинуто. Це означає, що ви не можете продовжувати "
"використовувати ітератори, оскільки ризикуєте пропустити відкинутий елемент."

msgid "The itertools module"
msgstr "Модуль itertools"

msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"Модуль :mod:`itertools` містить кілька часто використовуваних ітераторів, а "
"також функції для об’єднання кількох ітераторів. У цьому розділі буде "
"представлено зміст модуля на невеликих прикладах."

msgid "The module's functions fall into a few broad classes:"
msgstr "Функції модуля поділяються на кілька широких класів:"

msgid "Functions that create a new iterator based on an existing iterator."
msgstr "Функції, які створюють новий ітератор на основі існуючого ітератора."

msgid "Functions for treating an iterator's elements as function arguments."
msgstr "Функції для обробки елементів ітератора як аргументів функції."

msgid "Functions for selecting portions of an iterator's output."
msgstr "Функції для вибору частин виводу ітератора."

msgid "A function for grouping an iterator's output."
msgstr "Функція для групування виводу ітератора."

msgid "Creating new iterators"
msgstr "Створення нових ітераторів"

msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` повертає нескінченний "
"потік рівномірно розподілених значень. Додатково можна вказати початкове "
"число, яке за замовчуванням дорівнює 0, і інтервал між числами, який за "
"замовчуванням дорівнює 1::"

msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` зберігає копію вмісту "
"наданого ітератора та повертає новий ітератор, який повертає елементи від "
"першого до останнього. Новий ітератор буде нескінченно повторювати ці "
"елементи. ::"

msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` повертає наданий "
"елемент *n* разів або нескінченно повертає елемент, якщо *n* не надано. ::"

msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` приймає "
"довільну кількість ітераторів як вхідні дані та повертає всі елементи "
"першого ітератора, потім усі елементи другого і так далі, доки усі ітерації "
"вичерпано. ::"

msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"повертає потік, який є фрагментом ітератора. З одним аргументом *stop* він "
"повертає перші елементи *stop*. Якщо ви вкажете початковий індекс, ви "
"отримаєте елементи *stop-start*, а якщо ви вкажете значення для *step*, "
"елементи будуть відповідно пропущені. На відміну від нарізки рядків і "
"списків Python, ви не можете використовувати від’ємні значення для *start*, "
"*stop* або *step*. ::"

msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` повторює ітератор; він "
"повертає *n* незалежних ітераторів, які повертатимуть вміст вихідного "
"ітератора. Якщо ви не вкажете значення для *n*, за замовчуванням буде 2. "
"Реплікація ітераторів вимагає збереження частини вмісту вихідного ітератора, "
"тому це може споживати значну кількість пам’яті, якщо ітератор великий і "
"один із нових ітераторів споживається більше ніж інші. ::"

msgid "Calling functions on elements"
msgstr "Виклик функцій на елементах"

msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"Модуль :mod:`operator` містить набір функцій, що відповідають операторам "
"Python. Деякі приклади: :func:`operator.add(a, b) <operator.add>` (додає два "
"значення), :func:`operator.ne(a, b) <operator.ne>` (те саме, що ``a != b``), "
"і :func:`operator.attrgetter('id') <operator.attrgetter>` (повертає виклик, "
"який отримує атрибут ``.id``)."

msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` припускає, що "
"iterable поверне потік кортежів, і викликає *func*, використовуючи ці "
"кортежі як аргументи:"

msgid "Selecting elements"
msgstr "Вибір елементів"

msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"Інша група функцій вибирає підмножину елементів ітератора на основі "
"предикату."

msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` є "
"протилежністю :func:`filter`, повертаючи всі елементи, для яких предикат "
"повертає false::"

msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` повертає "
"елементи до тих пір, поки предикат повертає true. Як тільки предикат "
"повертає false, ітератор сигналізує про закінчення своїх результатів. ::"

msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` відкидає "
"елементи, поки предикат повертає true, а потім повертає решту результатів "
"ітерації. ::"

msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` приймає два "
"ітератори та повертає лише ті елементи *data*, для яких відповідний елемент "
"*selectors* є істинним, зупиняючись щоразу, коли один із них вичерпується::"

msgid "Combinatoric functions"
msgstr "Комбінаторні функції"

msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"повертає ітератор, що містить усі можливі *r*-кортежні комбінації елементів, "
"що містяться в *iterable*. ::"

msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"Елементи в кожному кортежі залишаються в тому самому порядку, у якому їх "
"повернув *iterable*. Наприклад, число 1 завжди стоїть перед 2, 3, 4 або 5 у "
"наведених вище прикладах. Подібна функція, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, усуває це "
"обмеження на порядок, повертаючи всі можливі розташування довжини *r*::"

msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"Якщо ви не вказуєте значення для *r*, використовується довжина ітерованого, "
"що означає, що всі елементи переставлені."

msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"Зауважте, що ці функції створюють усі можливі комбінації за позицією та не "
"вимагають, щоб вміст *iterable* був унікальним::"

msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"Ідентичний кортеж ``('a', 'a', 'b')`` зустрічається двічі, але два рядки 'a' "
"походять з різних позицій."

msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
"Функція :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` послаблює інше обмеження: "
"елементи можуть повторюватися в одному кортежі. Концептуально елемент "
"вибирається для першої позиції кожного кортежу, а потім замінюється перед "
"вибором другого елемента. ::"

msgid "Grouping elements"
msgstr "Групування елементів"

msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"Остання функція, яку я розповім, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, є найскладнішою. ``key_func(elem)`` - "
"це функція, яка може обчислити значення ключа для кожного елемента, "
"повернутого ітерованим. Якщо ви не надаєте ключову функцію, ключем буде "
"просто кожен елемент сам по собі."

msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` збирає всі послідовні елементи з основного "
"ітератора, які мають однакове значення ключа, і повертає потік 2-кортежів, "
"що містить значення ключа та ітератор для елементів із цим ключем."

msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` припускає, що вміст базового ітератора вже буде "
"відсортовано на основі ключа. Зверніть увагу, що повернуті ітератори також "
"використовують базовий ітератор, тому ви повинні споживати результати "
"ітератора-1 перед запитом ітератора-2 та його відповідного ключа."

msgid "The functools module"
msgstr "Модуль functools"

msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as input "
"and returns a new function.  The most useful tool in this module is the :"
"func:`functools.partial` function."
msgstr ""
"Модуль :mod:`functools` у Python 2.5 містить деякі функції вищого порядку. "
"**Функція вищого порядку** приймає одну або кілька функцій як вхідні дані та "
"повертає нову функцію. Найкориснішим інструментом у цьому модулі є функція :"
"func:`functools.partial`."

msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"Для програм, написаних у функціональному стилі, ви іноді захочете побудувати "
"варіанти існуючих функцій із заповненими деякими параметрами. Розглянемо "
"функцію Python ``f(a, b, c)``; ви можете створити нову функцію ``g(b, c)``, "
"еквівалентну ``f(1, b, c)``; ви вводите значення для одного з параметрів "
"``f()``. Це називається \"часткове застосування функції\"."

msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
"Конструктор для :func:`~functools.partial` приймає аргументи ``(функція, "
"arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``. Отриманий об’єкт можна "
"викликати, тому ви можете просто викликати його, щоб викликати ``функцію`` "
"із заповненими аргументами."

msgid "Here's a small but realistic example::"
msgstr "Ось маленький, але реалістичний приклад:"

msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"кумулятивно виконує операцію над усіма елементами iterable і, отже, не може "
"бути застосовано до нескінченних iterables. *func* має бути функцією, яка "
"приймає два елементи та повертає одне значення. :func:`functools.reduce` "
"бере перші два елементи A і B, повернуті ітератором, і обчислює ``func(A, "
"B)``. Потім він запитує третій елемент, C, обчислює ``func(func(A, B), C)``, "
"поєднує цей результат із повернутим четвертим елементом і продовжує роботу, "
"доки не вичерпається ітерація. Якщо ітерація не повертає жодних значень, "
"виникає виняток :exc:`TypeError`. Якщо вказано початкове значення, воно "
"використовується як початкова точка, а ``func(initial_value, A)`` є першим "
"обчисленням. ::"

msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"Якщо ви використовуєте :func:`operator.add` з :func:`functools.reduce`, ви "
"додасте всі елементи iterable. Цей випадок настільки поширений, що для його "
"обчислення існує спеціальна вбудована функція під назвою :func:`sum`:"

msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"Однак для багатьох застосувань :func:`functools.reduce` може бути "
"зрозумілішим просто написати очевидний :keyword:`for` цикл::"

msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`accumulate` returns an iterator "
"that also yields each partial result::"
msgstr ""
"Пов’язаною функцією є :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`. Він виконує ті самі обчислення, але замість "
"того, щоб повертати лише кінцевий результат, :func:`accumulate` повертає "
"ітератор, який також дає кожен частковий результат::"

msgid "The operator module"
msgstr "Операторський модуль"

msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"Модуль :mod:`operator` згадувався раніше. Він містить набір функцій, що "
"відповідають операторам Python. Ці функції часто корисні в коді "
"функціонального стилю, оскільки вони позбавляють вас від написання "
"тривіальних функцій, які виконують одну операцію."

msgid "Some of the functions in this module are:"
msgstr "Деякі з функцій цього модуля:"

msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"Математичні операції: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Логічні операції: ``not_()``, ``truth()``."

msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Побітові операції: ``and_()``, ``or_()``, ``invert()``."

msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Порівняння: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()`` і ``ge()`` ."

msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "Ідентифікація об'єкта: ``is_()``, ``is_not()``."

msgid "Consult the operator module's documentation for a complete list."
msgstr ""
"Зверніться до документації модуля оператора, щоб отримати повний список."

msgid "Small functions and the lambda expression"
msgstr "Малі функції та лямбда-вираз"

msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"Під час написання програм у функціональному стилі вам часто знадобляться "
"невеликі функції, які виконують роль предикатів або якимось чином поєднують "
"елементи."

msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"Якщо є вбудована функція Python або функція модуля, яка підходить, вам "
"взагалі не потрібно визначати нову функцію::"

msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"Якщо потрібної вам функції не існує, її потрібно написати. Один із способів "
"написання невеликих функцій — це використання виразу :keyword:`lambda`. "
"``лямбда`` приймає кілька параметрів і вираз, що поєднує ці параметри, і "
"створює анонімну функцію, яка повертає значення виразу::"

msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr ""
"Альтернативою є просто використання оператора ``def`` і визначення функції "
"звичайним способом::"

msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"Яка альтернатива є кращою? Це питання стилю; мій звичайний курс — уникати "
"використання ``лямбда``."

msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"Однією з причин моїх переваг є те, що ``лямбда`` досить обмежена у функціях, "
"які вона може визначати. Результат має бути обчислюваним як один вираз, що "
"означає, що ви не можете мати багатосторонні порівняння ``if... elif... "
"else`` або ``try... osim`` операторів. Якщо ви спробуєте зробити занадто "
"багато в операторі ``лямбда``, ви отримаєте надто складний вираз, який важко "
"прочитати. Швидко, що робить наступний код? ::"

msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"Ви можете це зрозуміти, але потрібен час, щоб розібрати вираз, щоб "
"зрозуміти, що відбувається. Використання коротких вкладених операторів "
"``def`` покращує ситуацію:"

msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "Але було б найкраще, якби я просто використав цикл ``for``::"

msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "Або вбудований :func:`sum` і вираз генератора::"

msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"Багато способів використання :func:`functools.reduce` зрозуміліші, коли "
"записуються як цикли ``for``."

msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Фредрік Лунд одного разу запропонував наступний набір правил для "
"рефакторингу використання ``лямбда``:"

msgid "Write a lambda function."
msgstr "Напишіть лямбда-функцію."

msgid "Write a comment explaining what the heck that lambda does."
msgstr "Напишіть коментар, пояснюючи, що в біса робить ця лямбда."

msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr ""
"Вивчіть коментар деякий час і придумайте назву, яка б передавала суть "
"коментаря."

msgid "Convert the lambda to a def statement, using that name."
msgstr "Перетворіть лямбда-вираз на оператор def, використовуючи це ім’я."

msgid "Remove the comment."
msgstr "Видалити коментар."

msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"Мені дуже подобаються ці правила, але ви можете не погоджуватися щодо того, "
"чи цей стиль без лямбда кращий."

msgid "Revision History and Acknowledgements"
msgstr "Історія переглядів і подяки"

msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"Автор хотів би подякувати наступним особам за пропозиції, виправлення та "
"допомогу з різними чернетками цієї статті: Іен Бікінґ, Нік Коглан, Нік "
"Еффорд, Реймонд Геттінгер, Джим Джеветт, Майк Крелл, Леандро Ламейро, Юссі "
"Салмела, Коллін Вінтер, Блейк Вінтон."

msgid "Version 0.1: posted June 30 2006."
msgstr "Версія 0.1: опубліковано 30 червня 2006 р."

msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr ""
"Версія 0.11: опубліковано 1 липня 2006 р. Виправлення друкарських помилок."

msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Версія 0.2: опубліковано 10 липня 2006 р. Об’єднано розділи genexp і "
"listcomp в один. Виправлення друкарських помилок."

msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Версія 0.21: додано більше посилань, запропонованих у списку розсилки "
"викладачів."

msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Версія 0.30: додано розділ про ``функціональний`` модуль, написаний Колліном "
"Вінтером; додає короткий розділ про модуль оператора; кілька інших правок."

msgid "References"
msgstr "Список літератури"

msgid "General"
msgstr "Загальний"

msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  Full text at https://mitpress.mit."
"edu/sicp/.  In this classic textbook of computer science, chapters 2 and 3 "
"discuss the use of sequences and streams to organize the data flow inside a "
"program.  The book uses Scheme for its examples, but many of the design "
"approaches described in these chapters are applicable to functional-style "
"Python code."
msgstr ""
"**Структура та інтерпретація комп’ютерних програм**, Гарольд Абельсон і "
"Джеральд Джей Сассман з Джулі Сассман. Повний текст на https://mitpress.mit."
"edu/sicp/. У цьому класичному підручнику з інформатики в розділах 2 і 3 "
"обговорюється використання послідовностей і потоків для організації потоку "
"даних у програмі. У книзі для прикладів використовується Scheme, але багато "
"підходів до проектування, описаних у цих розділах, можна застосувати до коду "
"Python у функціональному стилі."

msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html: Загальний вступ до "
"функціонального програмування, який використовує приклади Java і містить "
"довгий історичний вступ."

msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: загальний запис у "
"Вікіпедії, що описує функціональне програмування."

msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: Запис для співпрограм."

msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: Початок поняття каррі."

msgid "Python-specific"
msgstr "Специфічний для Python"

msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/: Перший розділ книги Девіда Мерца :title-reference:"
"`Обробка тексту в Python` обговорює функціональне програмування для обробки "
"тексту в розділі під назвою \"Використання функцій вищого порядку в обробці "
"тексту\". ."

msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Мерц також написав серію статей із 3 частин про функціональне програмування "
"для сайту IBM DeveloperWorks; див. `частина 1 <https://developer.ibm.com/"
"articles/l-prog/>`__, `частина 2 <https://developer.ibm.com/tutorials/l-"
"prog2/>`__ та `частина 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"

msgid "Python documentation"
msgstr "Документація Python"

msgid "Documentation for the :mod:`itertools` module."
msgstr "Документація для модуля :mod:`itertools`."

msgid "Documentation for the :mod:`functools` module."
msgstr "Документація для модуля :mod:`functools`."

msgid "Documentation for the :mod:`operator` module."
msgstr "Документація для модуля :mod:`operator`."

msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Генератор виразів\""

msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Сопрограми через розширені генератори\" описує нові функції "
"генератора в Python 2.5."
