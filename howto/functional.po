# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../howto/functional.rst:5
msgid "Functional Programming HOWTO"
msgstr "Функціональне програмування HOWTO"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/functional.rst:7
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "Реліз"

#: ../../howto/functional.rst:8
msgid "0.32"
msgstr "0,32"

#: ../../howto/functional.rst:10
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as "
":term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"У цьому документі ми ознайомимося з функціями Python, придатними для "
"реалізації програм у функціональному стилі. Після вступу до концепцій "
"функціонального програмування ми розглянемо функції мови, такі як "
":term:`iterator`\\s і :term:`generator`\\s, а також відповідні бібліотечні "
"модулі, такі як :mod:`itertools` і  :mod:`functools`."

#: ../../howto/functional.rst:18
msgid "Introduction"
msgstr "вступ"

#: ../../howto/functional.rst:20
msgid ""
"This section explains the basic concept of functional programming; if you're"
" just interested in learning about Python language features, skip to the "
"next section on :ref:`functional-howto-iterators`."
msgstr ""
"У цьому розділі пояснюється основна концепція функціонального програмування;"
" якщо вам просто цікаво дізнатися про функції мови Python, перейдіть до "
"наступного розділу :ref:`functional-howto-iterators`."

#: ../../howto/functional.rst:24
msgid ""
"Programming languages support decomposing problems in several different "
"ways:"
msgstr ""
"Мови програмування підтримують декомпозицію проблем кількома різними "
"способами:"

#: ../../howto/functional.rst:26
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C,"
" Pascal, and even Unix shells are procedural languages."
msgstr ""
"Більшість мов програмування є **процедурними**: програми — це списки "
"інструкцій, які вказують комп’ютеру, що робити з вхідними даними програми. "
"C, Pascal і навіть оболонки Unix є процедурними мовами."

#: ../../howto/functional.rst:30
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're"
" most likely to be familiar with; a SQL query describes the data set you "
"want to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"У **декларативних** мовах ви пишете специфікацію, яка описує проблему, яку "
"потрібно вирішити, а реалізація мови визначає, як виконати обчислення "
"ефективно. SQL — це декларативна мова, з якою ви, швидше за все, знайомі; "
"SQL-запит описує набір даних, який ви хочете отримати, і механізм SQL "
"вирішує, сканувати таблиці чи використовувати індекси, які підпункти слід "
"виконати першими тощо."

#: ../../howto/functional.rst:37
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't"
" force the use of object-oriented features."
msgstr ""
"**Об’єктно-орієнтовані** програми маніпулюють колекціями об’єктів. Об’єкти "
"мають внутрішній стан і підтримують методи, які певним чином запитують або "
"змінюють цей внутрішній стан. Smalltalk і Java є об'єктно-орієнтованими "
"мовами. C++ і Python — це мови, які підтримують об’єктно-орієнтоване "
"програмування, але не примусово використовують об’єктно-орієнтовані функції."

#: ../../howto/functional.rst:43
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**Функціональне** програмування розкладає проблему на набір функцій. В "
"ідеалі функції лише приймають вхідні дані та виробляють виходи, і не мають "
"жодного внутрішнього стану, який впливає на вихідні дані, отримані для "
"даного вхідного елемента. Добре відомі функціональні мови включають "
"сімейство ML (Standard ML, OCaml та інші варіанти) і Haskell."

#: ../../howto/functional.rst:49
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages"
" that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the"
" GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"Розробники деяких комп’ютерних мов вирішують наголосити на одному "
"конкретному підході до програмування. Це часто ускладнює написання програм, "
"які використовують інший підхід. Інші мови є мовами з кількома парадигмами, "
"які підтримують кілька різних підходів. Lisp, C++ і Python є "
"мультипарадигмальними; ви можете писати програми або бібліотеки, які в "
"основному є процедурними, об'єктно-орієнтованими або функціональними на всіх"
" цих мовах. У великій програмі різні розділи можуть бути написані з "
"використанням різних підходів; GUI може бути об'єктно-орієнтованим, тоді як "
"логіка обробки є процедурною або функціональною, наприклад."

#: ../../howto/functional.rst:60
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions"
" that have no side effects at all are called **purely functional**.  "
"Avoiding side effects means not using data structures that get updated as a "
"program runs; every function's output must only depend on its input."
msgstr ""
"У функціональній програмі введення проходить через набір функцій. Кожна "
"функція працює зі своїм входом і видає певний результат. Функціональний "
"стиль не заохочує функції з побічними ефектами, які змінюють внутрішній стан"
" або вносять інші зміни, які не видно у значенні, що повертається функцією. "
"Функції, які взагалі не мають побічних ефектів, називаються **чисто "
"функціональними**. Уникати побічних ефектів означає не використовувати "
"структури даних, які оновлюються під час виконання програми; кожен вихід "
"функції повинен залежати лише від її входу."

#: ../../howto/functional.rst:68
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all"
" side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"Деякі мови дуже суворі щодо чистоти й навіть не мають операторів присвоєння,"
" таких як ``a=3`` або ``c = a + b``, але важко уникнути всіх побічних "
"ефектів, таких як друк на екрані або запис у файл диска. Іншим прикладом є "
"виклик функції :func:`print` або :func:`time.sleep`, жодна з яких не "
"повертає корисне значення. Обидва викликаються лише через побічні ефекти "
"надсилання тексту на екран або призупинення виконання на секунду."

#: ../../howto/functional.rst:75
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Програми на Python, написані у функціональному стилі, зазвичай не йдуть до "
"крайнощів, щоб уникнути всього вводу-виводу або всіх призначень; замість "
"цього вони забезпечуватимуть функціональний інтерфейс, але "
"використовуватимуть нефункціональні функції всередині. Наприклад, реалізація"
" функції все одно використовуватиме призначення локальним змінним, але не "
"змінюватиме глобальні змінні чи матиме інші побічні ефекти."

#: ../../howto/functional.rst:81
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"Функціональне програмування можна вважати протилежністю об'єктно-"
"орієнтованого програмування. Об’єкти — це маленькі капсули, що містять "
"певний внутрішній стан разом із набором викликів методів, які дозволяють "
"змінювати цей стан, а програми складаються із внесення правильних змін "
"стану. Функціональне програмування хоче якомога більше уникати змін стану та"
" працює з потоком даних між функціями. У Python ви можете поєднати два "
"підходи, написавши функції, які приймають і повертають екземпляри, що "
"представляють об’єкти у вашій програмі (повідомлення електронної пошти, "
"транзакції тощо)."

#: ../../howto/functional.rst:90
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should"
" you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"Функціональний дизайн може здатися дивним обмеженням для роботи. Чому слід "
"уникати предметів і побічних ефектів? Існують теоретичні та практичні "
"переваги функціонального стилю:"

#: ../../howto/functional.rst:94
msgid "Formal provability."
msgstr "Формальна доказовість."

#: ../../howto/functional.rst:95
msgid "Modularity."
msgstr "Модульність."

#: ../../howto/functional.rst:96
msgid "Composability."
msgstr "Композиційність."

#: ../../howto/functional.rst:97
msgid "Ease of debugging and testing."
msgstr "Простота налагодження та тестування."

#: ../../howto/functional.rst:101
msgid "Formal provability"
msgstr "Формальна доказовість"

#: ../../howto/functional.rst:103
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"Теоретична перевага полягає в тому, що легше побудувати математичний доказ "
"правильності функціональної програми."

#: ../../howto/functional.rst:106
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"Довгий час дослідники були зацікавлені в пошуку способів математичної "
"перевірки правильності програм. Це відрізняється від тестування програми на "
"численних вхідних даних і висновку, що її вихід зазвичай правильний, або "
"читання вихідного коду програми та висновку, що код виглядає правильно; "
"натомість метою є суворий доказ того, що програма дає правильний результат "
"для всіх можливих вхідних даних."

#: ../../howto/functional.rst:113
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"Техніка, яка використовується для підтвердження правильності програм, "
"полягає в записі **інваріантів**, властивостей вхідних даних і змінних "
"програми, які завжди є істинними. Для кожного рядка коду ви потім показуєте,"
" що якщо інваріанти X і Y істинні **до** виконання рядка, дещо інші "
"інваріанти X' і Y' є істинними **після** виконання рядка. Це продовжується, "
"доки ви не досягнете кінця програми, після чого інваріанти повинні "
"відповідати бажаним умовам на виході програми."

#: ../../howto/functional.rst:121
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"Уникання присвоєння у функціональному програмуванні виникло тому, що "
"присвоєння важко обробляти за допомогою цієї техніки; призначення можуть "
"порушувати інваріанти, які були істинними до призначення, не створюючи "
"жодних нових інваріантів, які можна поширювати далі."

#: ../../howto/functional.rst:126
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"На жаль, перевірка правильності програм в основному непрактична і не "
"стосується програмного забезпечення Python. Навіть тривіальні програми "
"вимагають доказів довжиною кілька сторінок; докази правильності для помірно "
"складної програми були б величезними, і мало або жодна з програм, якими ви "
"користуєтеся щодня (інтерпретатор Python, ваш аналізатор XML, ваш веб-"
"браузер), може бути доведена правильною. Навіть якщо ви записали або "
"згенерували доказ, тоді виникне питання перевірки доказу; можливо, у ньому є"
" помилка, і ви помилково вважаєте, що довели правильність програми."

#: ../../howto/functional.rst:137
msgid "Modularity"
msgstr "Модульність"

#: ../../howto/functional.rst:139
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"Більш практична перевага функціонального програмування полягає в тому, що "
"воно змушує вас розбивати проблему на дрібні частини. В результаті програми "
"стають більш модульними. Простіше вказати та написати невелику функцію, яка "
"виконує щось одне, ніж велику функцію, яка виконує складне перетворення. "
"Невеликі функції також легше читати та перевіряти на наявність помилок."

#: ../../howto/functional.rst:147
msgid "Ease of debugging and testing"
msgstr "Простота налагодження та тестування"

#: ../../howto/functional.rst:149
msgid "Testing and debugging a functional-style program is easier."
msgstr "Тестування та налагодження програми у функціональному стилі легше."

#: ../../howto/functional.rst:151
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point"
" where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"Налагодження спрощене, оскільки функції, як правило, невеликі та чітко "
"визначені. Коли програма не працює, кожна функція є точкою інтерфейсу, де "
"можна перевірити правильність даних. Ви можете переглянути проміжні входи та"
" виходи, щоб швидко виділити функцію, яка є відповідальною за помилку."

#: ../../howto/functional.rst:156
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Тестування легше, тому що кожна функція є потенційним предметом модульного "
"тесту. Функції не залежать від стану системи, який потрібно відтворити перед"
" виконанням тесту; натомість вам потрібно лише синтезувати правильні вхідні "
"дані, а потім перевірити, чи результат відповідає очікуванням."

#: ../../howto/functional.rst:163
msgid "Composability"
msgstr "Композиційність"

#: ../../howto/functional.rst:165
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function"
" that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"Працюючи над програмою функціонального стилю, ви напишете ряд функцій із "
"різними входами та виходами. Деякі з цих функцій неминуче будуть "
"спеціалізовані для конкретної програми, але інші будуть корисні в широкому "
"спектрі програм. Наприклад, функцію, яка приймає шлях до каталогу та "
"повертає всі файли XML у каталозі, або функцію, яка приймає ім’я файлу та "
"повертає його вміст, можна застосувати до багатьох різних ситуацій."

#: ../../howto/functional.rst:172
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration"
" and writing a few functions specialized for the current task."
msgstr ""
"З часом ви сформуєте особисту бібліотеку утиліт. Часто ви збираєте нові "
"програми, організовуючи існуючі функції в новій конфігурації та написавши "
"кілька функцій, спеціалізованих для поточного завдання."

#: ../../howto/functional.rst:180
msgid "Iterators"
msgstr "Ітератори"

#: ../../howto/functional.rst:182
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Я почну з вивчення функції мови Python, яка є важливою основою для написання"
" програм у функціональному стилі: ітератори."

#: ../../howto/functional.rst:185
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns"
" the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"Ітератор - це об'єкт, що представляє потік даних; цей об’єкт повертає дані "
"по одному елементу за раз. Ітератор Python має підтримувати метод під назвою"
" :meth:`~iterator.__next__`, який не приймає аргументів і завжди повертає "
"наступний елемент потоку. Якщо в потоці більше немає елементів, "
":meth:`~iterator.__next__` має викликати виняток :exc:`StopIteration`. Проте"
" ітератори не обов’язково мають бути кінцевими; цілком розумно написати "
"ітератор, який створює нескінченний потік даних."

#: ../../howto/functional.rst:193
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get"
" an iterator for it."
msgstr ""
"Вбудована функція :func:`iter` приймає довільний об’єкт і намагається "
"повернути ітератор, який повертатиме вміст або елементи об’єкта, викликаючи "
":exc:`TypeError`, якщо об’єкт не підтримує ітерацію. Кілька вбудованих типів"
" даних Python підтримують ітерацію, найпоширенішими з яких є списки та "
"словники. Об’єкт називається :term:`iterable`, якщо ви можете отримати для "
"нього ітератор."

#: ../../howto/functional.rst:200
msgid "You can experiment with the iteration interface manually:"
msgstr "Ви можете експериментувати з інтерфейсом ітерації вручну:"

#: ../../howto/functional.rst:218
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python очікує ітерованих об’єктів у кількох різних контекстах, найважливішим"
" з яких є оператор :keyword:`for`. У операторі ``для X в Y`` Y має бути "
"ітератором або деяким об’єктом, для якого :func:`iter` може створити "
"ітератор. Ці два твердження еквівалентні:"

#: ../../howto/functional.rst:224
msgid ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"
msgstr ""

#: ../../howto/functional.rst:230
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Ітератори можна матеріалізувати як списки або кортежі за допомогою функцій "
"конструктора :func:`list` або :func:`tuple`:"

#: ../../howto/functional.rst:239
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"Розпакування послідовності також підтримує ітератори: якщо ви знаєте, що "
"ітератор поверне N елементів, ви можете розпакувати їх у N-кортеж:"

#: ../../howto/functional.rst:248
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, "
":func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Вбудовані функції, такі як :func:`max` і :func:`min`, можуть приймати один "
"аргумент ітератора та повертати найбільший або найменший елемент. Оператори "
"``\"in\"`` і ``\"not in\"`` також підтримують ітератори: ``X в ітераторі`` є"
" істинним, якщо X знайдено в потоці, повернутому ітератором. Ви зіткнетеся з"
" очевидними проблемами, якщо ітератор нескінченний; :func:`max`, :func:`min`"
" ніколи не повертаються, а якщо елемент X ніколи не з’являється в потоці, "
"оператори ``\"in\"`` і ``\"not in\"`` не повертаються або."

#: ../../howto/functional.rst:256
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a"
" new iterator."
msgstr ""
"Зауважте, що в ітераторі можна рухатися лише вперед; немає способу отримати "
"попередній елемент, скинути ітератор або зробити його копію. Об’єкти-"
"ітератори можуть додатково надавати ці додаткові можливості, але протокол "
"ітераторів визначає лише метод :meth:`~iterator.__next__`. Тому функції "
"можуть споживати весь вихід ітератора, і якщо вам потрібно зробити щось інше"
" з тим самим потоком, вам доведеться створити новий ітератор."

#: ../../howto/functional.rst:266
msgid "Data Types That Support Iterators"
msgstr "Типи даних, які підтримують ітератори"

#: ../../howto/functional.rst:268
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Ми вже бачили, як списки та кортежі підтримують ітератори. Насправді будь-"
"який тип послідовності Python, наприклад рядки, автоматично підтримуватиме "
"створення ітератора."

#: ../../howto/functional.rst:272
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over"
" the dictionary's keys::"
msgstr ""
"Виклик :func:`iter` для словника повертає ітератор, який перебиратиме ключі "
"словника::"

#: ../../howto/functional.rst:275
msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"
msgstr ""

#: ../../howto/functional.rst:292
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed"
" to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Зауважте, що, починаючи з Python 3.7, порядок ітерацій словника гарантовано "
"збігається з порядком вставки. У попередніх версіях поведінка була "
"невизначеною та могла відрізнятися в різних реалізаціях."

#: ../../howto/functional.rst:296
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the "
":meth:`~dict.values` or :meth:`~dict.items` methods to get an appropriate "
"iterator."
msgstr ""
"Застосування :func:`iter` до словника завжди повторює ключі, але словники "
"мають методи, які повертають інші ітератори. Якщо ви хочете перебирати "
"значення або пари ключ/значення, ви можете явно викликати методи "
":meth:`~dict.values` або :meth:`~dict.items`, щоб отримати відповідний "
"ітератор."

#: ../../howto/functional.rst:302
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"Конструктор :func:`dict` може приймати ітератор, який повертає кінцевий "
"потік кортежів ``(ключ, значення)``:"

#: ../../howto/functional.rst:309
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"Файли також підтримують ітерацію шляхом виклику методу "
":meth:`~io.TextIOBase.readline`, доки у файлі не залишиться рядків. Це "
"означає, що ви можете читати кожен рядок файлу таким чином:"

#: ../../howto/functional.rst:313
msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""

#: ../../howto/functional.rst:317
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Набори можуть брати свій вміст із ітерованого елемента й дозволяти вам "
"перебирати елементи набору:"

#: ../../howto/functional.rst:320
msgid ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"
msgstr ""

#: ../../howto/functional.rst:333
msgid "Generator expressions and list comprehensions"
msgstr "Генератор виразів і розуміння списків"

#: ../../howto/functional.rst:335
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Дві загальні операції на виході ітератора: 1) виконання певної операції для "
"кожного елемента, 2) вибір підмножини елементів, які відповідають певній "
"умові. Наприклад, маючи список рядків, ви можете видалити кінцеві пробіли з "
"кожного рядка або витягти всі рядки, що містять певний підрядок."

#: ../../howto/functional.rst:341
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and"
" \"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can"
" strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"Розуміння списків і вирази генератора (скорочена форма: \"listcomps\" і "
"\"genexps\") є короткою нотацією для таких операцій, запозиченої з "
"функціональної мови програмування Haskell (https://www.haskell.org/). Ви "
"можете видалити всі пробіли з потоку рядків за допомогою такого коду::"

#: ../../howto/functional.rst:346
msgid ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # Generator expression -- returns iterator\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # List comprehension -- returns list\n"
">>> stripped_list = [line.strip() for line in line_list]"
msgstr ""

#: ../../howto/functional.rst:354
msgid "You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "Ви можете вибрати лише певні елементи, додавши умову ``\"if\"``::"

#: ../../howto/functional.rst:356
msgid ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"
msgstr ""

#: ../../howto/functional.rst:359
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an"
" infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"З розумінням списку ви отримуєте список Python; ``stripped_list`` – це "
"список, що містить отримані рядки, а не ітератор. Вирази генератора "
"повертають ітератор, який обчислює значення за потреби, не потребуючи "
"матеріалізації всіх значень одночасно. Це означає, що розуміння списку не є "
"корисним, якщо ви працюєте з ітераторами, які повертають нескінченний потік "
"або дуже великий обсяг даних. Вирази-генератори є кращими в цих ситуаціях."

#: ../../howto/functional.rst:366
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"Вирази генератора оточені дужками (\"()\"), а розуміння списків оточені "
"квадратними дужками (\"[]\"). Вирази генератора мають вигляд::"

#: ../../howto/functional.rst:370
msgid ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"
msgstr ""

#: ../../howto/functional.rst:380
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"Знову ж таки, для розуміння списку відрізняються лише зовнішні дужки "
"(квадратні дужки замість дужок)."

#: ../../howto/functional.rst:383
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Елементи згенерованого результату будуть послідовними значеннями ``виразу``."
" Речення ``if`` є необов'язковими; якщо присутнє, ``вираз`` обчислюється та "
"додається до результату лише тоді, коли ``умова`` є істинною."

#: ../../howto/functional.rst:387
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an"
" iterator that will be immediately passed to a function you can write::"
msgstr ""
"Вирази генератора завжди мають бути записані в дужках, але дужки, що "
"сигналізують про виклик функції, також враховуються. Якщо ви хочете створити"
" ітератор, який буде негайно передано функції, ви можете написати::"

#: ../../howto/functional.rst:391
msgid "obj_total = sum(obj.count for obj in list_all_objects())"
msgstr ""

#: ../../howto/functional.rst:393
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``,"
" ``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"Речення ``for...in`` містять послідовності, які потрібно повторити. "
"Послідовності не обов’язково мають бути однакової довжини, оскільки вони "
"повторюються зліва направо, **не** паралельно. Для кожного елемента в "
"``sequence1`` ``sequence2`` повторюється з самого початку. Після цього "
"``sequence3`` виконується в циклі для кожної отриманої пари елементів з "
"``sequence1`` і ``sequence2``."

#: ../../howto/functional.rst:399
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"Іншими словами, вираз розуміння списку або генератор еквівалентний такому "
"коду Python::"

#: ../../howto/functional.rst:402
msgid ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # Skip this element\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # Skip this element\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # Skip this element\n"
"\n"
"            # Output the value of\n"
"            # the expression."
msgstr ""

#: ../../howto/functional.rst:416
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Це означає, що коли є кілька пропозицій ``for...in``, але немає пропозицій "
"``if``, довжина результату буде дорівнювати добутку довжин усіх "
"послідовностей. Якщо у вас є два списки довжиною 3, вихідний список "
"складається з 9 елементів:"

#: ../../howto/functional.rst:428
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list"
" comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Щоб уникнути неоднозначності в граматиці Python, якщо ``вираз`` створює "
"кортеж, він повинен бути оточений дужками. Перше розуміння списку нижче є "
"синтаксичною помилкою, тоді як друге є правильним:"

#: ../../howto/functional.rst:432
msgid ""
"# Syntax error\n"
"[x, y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[(x, y) for x in seq1 for y in seq2]"
msgstr ""

#: ../../howto/functional.rst:439
msgid "Generators"
msgstr "Генератори"

#: ../../howto/functional.rst:441
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Генератори — це спеціальний клас функцій, які спрощують завдання написання "
"ітераторів. Звичайні функції обчислюють значення та повертають його, але "
"генератори повертають ітератор, який повертає потік значень."

#: ../../howto/functional.rst:445
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Ви, безсумнівно, знайомі з тим, як працюють звичайні виклики функцій у "
"Python або C. Коли ви викликаєте функцію, вона отримує приватний простір "
"імен, де створюються її локальні змінні. Коли функція досягає оператора "
"``return``, локальні змінні знищуються, а значення повертається "
"викликаючому. Пізніший виклик тієї ж функції створює новий приватний простір"
" імен і новий набір локальних змінних. Але що, якби локальні змінні не були "
"викинуті під час виходу з функції? Що, якби ви могли пізніше відновити "
"функцію, де вона була зупинена? Це те, що забезпечують генератори; їх можна "
"розглядати як відновлювані функції."

#: ../../howto/functional.rst:454
msgid "Here's the simplest example of a generator function:"
msgstr "Ось найпростіший приклад функції генератора:"

#: ../../howto/functional.rst:460
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"Будь-яка функція, що містить ключове слово :keyword:`yield`, є функцією-"
"генератором; це виявляється компілятором :term:`bytecode` Python, який "
"спеціально компілює функцію в результаті."

#: ../../howto/functional.rst:464
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"Коли ви викликаєте функцію генератора, вона не повертає жодного значення; "
"замість цього він повертає об'єкт генератора, який підтримує протокол "
"ітератора. Під час виконання виразу ``yield`` генератор виводить значення "
"``i``, подібно до оператора ``return``. Велика різниця між оператором "
"``yield`` і оператором ``return`` полягає в тому, що після досягнення "
"``yield`` стан виконання генератора призупиняється, а локальні змінні "
"зберігаються. Під час наступного виклику методу генератора "
":meth:`~generator.__next__` функція відновить виконання."

#: ../../howto/functional.rst:473
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Ось приклад використання генератора ``generate_ints()``:"

#: ../../howto/functional.rst:490
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"Так само можна написати ``для i в generate_ints(5)`` або ``a, b, c = "
"generate_ints(3)``."

#: ../../howto/functional.rst:493
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"Усередині функції-генератора ``повернене значення`` викликає "
"``StopIteration(value)``, яке буде викликано з методу "
":meth:`~generator.__next__`. Як тільки це станеться, або коли функція "
"досягне дна, обробка значень закінчується, і генератор не зможе видавати "
"жодних додаткових значень."

#: ../../howto/functional.rst:498
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"Ви можете досягти ефекту генераторів вручну, написавши власний клас і "
"зберігши всі локальні змінні генератора як змінні екземпляра. Наприклад, "
"повернути список цілих чисел можна, встановивши ``self.count`` на 0, і "
"дозволивши методу :meth:`~iterator.__next__` збільшити ``self.count`` і "
"повернути його. Однак для помірно складного генератора написання "
"відповідного класу може бути набагато складнішим."

#: ../../howto/functional.rst:506
msgid ""
"The test suite included with Python's library, "
":source:`Lib/test/test_generators.py`, contains a number of more interesting"
" examples.  Here's one generator that implements an in-order traversal of a "
"tree using generators recursively. ::"
msgstr ""
"Набір тестів, що входить до бібліотеки Python, "
":source:`Lib/test/test_generators.py`, містить низку більш цікавих "
"прикладів. Ось один генератор, який реалізує рекурсивний обхід дерева за "
"допомогою генераторів. ::"

#: ../../howto/functional.rst:511
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""

#: ../../howto/functional.rst:522
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the "
"N-Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Два інших приклади в ``test_generators.py`` створюють рішення для проблеми "
"N-Queens (розміщення N ферзів на NxN шахівниці так, щоб жодна королева не "
"загрожувала іншій) і Knight's Tour (пошук маршруту, який веде лицаря до "
"кожної клітинки). шахової дошки NxN, не відвідуючи жодного поля двічі)."

#: ../../howto/functional.rst:530
msgid "Passing values into a generator"
msgstr "Передача значень у генератор"

#: ../../howto/functional.rst:532
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass"
" any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"У Python 2.4 і раніших версіях генератори створювали лише вихідні дані. Як "
"тільки код генератора був викликаний для створення ітератора, не було "
"можливості передати будь-яку нову інформацію у функцію, коли її виконання "
"відновилося. Ви можете об’єднати цю здатність, змусивши генератор дивитися "
"на глобальну змінну або передавши якийсь змінний об’єкт, який потім змінюють"
" абоненти, але ці підходи є безладними."

#: ../../howto/functional.rst:539
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. "
":keyword:`yield` became an expression, returning a value that can be "
"assigned to a variable or otherwise operated on::"
msgstr ""
"У Python 2.5 є простий спосіб передачі значень у генератор. :keyword:`yield`"
" став виразом, який повертає значення, яке можна присвоїти змінній або іншим"
" чином оперувати:"

#: ../../howto/functional.rst:543
msgid "val = (yield i)"
msgstr ""

#: ../../howto/functional.rst:545
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Я рекомендую вам **завжди** брати дужки навколо виразу ``yield``, коли ви "
"робите щось із повернутим значенням, як у прикладі вище. Дужки не завжди "
"потрібні, але простіше завжди додавати їх замість того, щоб запам’ятовувати,"
" коли вони потрібні."

#: ../../howto/functional.rst:550
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` пояснює точні правила, які полягають у тому, що вираз ``yield`` "
"завжди повинен бути взятий у дужки, за винятком випадків, коли він "
"зустрічається у виразі верхнього рівня в правій частині призначення. Це "
"означає, що ви можна написати ``val = yield i``, але потрібно "
"використовувати дужки, коли є операція, як у ``val = (yield i) + 12``.)"

#: ../../howto/functional.rst:556
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular "
":meth:`~generator.__next__` method is called, the ``yield`` returns "
"``None``."
msgstr ""
"Значення надсилаються в генератор шляхом виклику його методу "
":meth:`send(value) <generator.send>`. Цей метод відновлює код генератора, а "
"вираз ``yield`` повертає вказане значення. Якщо викликається звичайний метод"
" :meth:`~generator.__next__`, ``yield`` повертає ``None``."

#: ../../howto/functional.rst:561
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Ось простий лічильник, який збільшується на 1 і дозволяє змінювати значення "
"внутрішнього лічильника."

#: ../../howto/functional.rst:564
msgid ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"
msgstr ""

#: ../../howto/functional.rst:576
msgid "And here's an example of changing the counter:"
msgstr "А ось приклад зміни лічильника:"

#: ../../howto/functional.rst:593
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"Оскільки ``yield`` часто повертатиме ``None``, ви завжди повинні перевіряти "
"цей випадок. Не просто використовуйте його значення у виразах, якщо ви не "
"впевнені, що метод :meth:`~generator.send` буде єдиним методом, використаним"
" для відновлення вашої функції генератора."

#: ../../howto/functional.rst:598
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "Окрім :meth:`~generator.send`, у генераторах є ще два методи:"

#: ../../howto/functional.rst:601
msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the"
" generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` використовується для створення "
"винятку всередині генератора; виняток викликає вираз ``yield``, де виконання"
" генератора призупинено."

#: ../../howto/functional.rst:605
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`; catching the exception and doing anything else is "
"illegal and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` "
"will also be called by Python's garbage collector when the generator is "
"garbage-collected."
msgstr ""
":meth:`~generator.close` викликає виняткову ситуацію :exc:`GeneratorExit` "
"всередині генератора, щоб завершити ітерацію. Отримавши цей виняток, код "
"генератора повинен викликати :exc:`GeneratorExit` або :exc:`StopIteration`; "
"перехоплення винятку та будь-що інше є незаконним і спричинить "
":exc:`RuntimeError`. :meth:`~generator.close` також буде викликано збирачем "
"сміття Python, коли генератор збирає сміття."

#: ../../howto/functional.rst:613
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching "
":exc:`GeneratorExit`."
msgstr ""
"Якщо вам потрібно запустити код очищення, коли виникає :exc:`GeneratorExit`,"
" я пропоную використовувати набір ``try: ... finally:`` замість перехоплення"
" :exc:`GeneratorExit`."

#: ../../howto/functional.rst:616
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"Кумулятивний ефект цих змін полягає в тому, щоб перетворити генераторів з "
"односторонніх виробників інформації на виробників і споживачів."

#: ../../howto/functional.rst:619
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Генератори також стають **співпрограмами**, більш узагальненою формою "
"підпрограм. Підпрограми вводяться в одній точці та виходять з іншої точки "
"(верхня частина функції та оператор \"return\"), але підпрограми можна "
"входити, виходити та продовжувати в багатьох різних точках (оператори "
"\"yield\" )."

#: ../../howto/functional.rst:626
msgid "Built-in functions"
msgstr "Вбудовані функції"

#: ../../howto/functional.rst:628
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Давайте детальніше розглянемо вбудовані функції, які часто використовуються "
"з ітераторами."

#: ../../howto/functional.rst:630
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate"
" the features of generator expressions:"
msgstr ""
"Дві вбудовані функції Python, :func:`map` і :func:`filter` дублюють функції "
"генераторних виразів:"

#: ../../howto/functional.rst:633
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the "
"sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` повертає ітератор у послідовності"

#: ../../howto/functional.rst:634
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."

#: ../../howto/functional.rst:644
msgid "You can of course achieve the same effect with a list comprehension."
msgstr ""
"Звичайно, ви можете досягти такого ж ефекту за допомогою розуміння списку."

#: ../../howto/functional.rst:646
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated"
" by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` повертає ітератор над усіма "
"елементами послідовності, які відповідають певній умові, і подібним чином "
"дублюється за допомогою списків. **Предикат** – це функція, яка повертає "
"значення істинності певної умови; для використання з :func:`filter` предикат"
" має приймати одне значення."

#: ../../howto/functional.rst:659
msgid "This can also be written as a list comprehension:"
msgstr "Це також можна записати як розуміння списку:"

#: ../../howto/functional.rst:665
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` відраховує елементи в "
"ітераційному повертаючому 2-кортежі, що містить кількість (від *start*) і "
"кожен елемент. ::"

#: ../../howto/functional.rst:669
msgid ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"
msgstr ""

#: ../../howto/functional.rst:675
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` часто використовується під час циклічного перегляду списку"
" та запису індексів, при яких виконуються певні умови:"

#: ../../howto/functional.rst:678
msgid ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"
msgstr ""

#: ../../howto/functional.rst:683
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted"
" result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` збирає всі "
"елементи iterable у список, сортує список і повертає відсортований "
"результат. Аргументи *key* і *reverse* передаються до методу "
":meth:`~list.sort` створеного списку. ::"

#: ../../howto/functional.rst:688
msgid ""
">>> import random\n"
">>> # Generate 8 random numbers between [0, 10000)\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list  \n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)  \n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)  \n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"
msgstr ""

#: ../../howto/functional.rst:698
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"(Для більш детального обговорення сортування див. :ref:`sortinghowto`.)"

#: ../../howto/functional.rst:701
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if"
" any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"Вбудовані функції :func:`any(iter) <any>` і :func:`all(iter) <all>` "
"переглядають значення істинності вмісту ітерованого елемента. :func:`any` "
"повертає ``True``, якщо будь-який елемент в iterable є істинним значенням, а"
" :func:`all` повертає ``True``, якщо всі елементи є істинними значеннями:"

#: ../../howto/functional.rst:720
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` бере по одному елементу з кожного "
"iterable і повертає їх у кортежі::"

#: ../../howto/functional.rst:723
msgid ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"
msgstr ""

#: ../../howto/functional.rst:726
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"Він не створює список у пам’яті та не вичерпує всі ітератори введення перед "
"поверненням; натомість кортежі створюються та повертаються лише за запитом. "
"(Технічний термін для такої поведінки — `лінива оцінка "
"<https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"

#: ../../howto/functional.rst:731
msgid ""
"This iterator is intended to be used with iterables that are all of the same"
" length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Цей ітератор призначений для використання з ітераторами, які мають однакову "
"довжину. Якщо ітератори мають різну довжину, результуючий потік буде такої ж"
" довжини, як і найкоротший ітератор. ::"

#: ../../howto/functional.rst:735
msgid ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"
msgstr ""

#: ../../howto/functional.rst:738
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Однак вам слід уникати цього, оскільки елемент може бути взято з довших "
"ітераторів і відкинуто. Це означає, що ви не можете продовжувати "
"використовувати ітератори, оскільки ризикуєте пропустити відкинутий елемент."

#: ../../howto/functional.rst:744
msgid "The itertools module"
msgstr "Модуль itertools"

#: ../../howto/functional.rst:746
msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""

#: ../../howto/functional.rst:750
msgid "The module's functions fall into a few broad classes:"
msgstr "Функції модуля поділяються на кілька широких класів:"

#: ../../howto/functional.rst:752
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "Функції, які створюють новий ітератор на основі існуючого ітератора."

#: ../../howto/functional.rst:753
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "Функції для обробки елементів ітератора як аргументів функції."

#: ../../howto/functional.rst:754
msgid "Functions for selecting portions of an iterator's output."
msgstr "Функції для вибору частин виводу ітератора."

#: ../../howto/functional.rst:755
msgid "A function for grouping an iterator's output."
msgstr "Функція для групування виводу ітератора."

#: ../../howto/functional.rst:758
msgid "Creating new iterators"
msgstr "Створення нових ітераторів"

#: ../../howto/functional.rst:760
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` повертає нескінченний"
" потік рівномірно розподілених значень. Додатково можна вказати початкове "
"число, яке за замовчуванням дорівнює 0, і інтервал між числами, який за "
"замовчуванням дорівнює 1::"

#: ../../howto/functional.rst:764
msgid ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."
msgstr ""

#: ../../howto/functional.rst:771
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents"
" of a provided iterable and returns a new iterator that returns its elements"
" from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` зберігає копію вмісту "
"наданого ітератора та повертає новий ітератор, який повертає елементи від "
"першого до останнього. Новий ітератор буде нескінченно повторювати ці "
"елементи. ::"

#: ../../howto/functional.rst:775
msgid ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."
msgstr ""

#: ../../howto/functional.rst:778
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not provided. "
"::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` повертає наданий "
"елемент *n* разів або нескінченно повертає елемент, якщо *n* не надано. ::"

#: ../../howto/functional.rst:781
msgid ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"
msgstr ""

#: ../../howto/functional.rst:786
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of"
" the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` приймає "
"довільну кількість ітераторів як вхідні дані та повертає всі елементи "
"першого ітератора, потім усі елементи другого і так далі, доки усі ітерації "
"вичерпано. ::"

#: ../../howto/functional.rst:791
msgid ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"
msgstr ""

#: ../../howto/functional.rst:794
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"повертає потік, який є фрагментом ітератора. З одним аргументом *stop* він "
"повертає перші елементи *stop*. Якщо ви вкажете початковий індекс, ви "
"отримаєте елементи *stop-start*, а якщо ви вкажете значення для *step*, "
"елементи будуть відповідно пропущені. На відміну від нарізки рядків і "
"списків Python, ви не можете використовувати від’ємні значення для *start*, "
"*stop* або *step*. ::"

#: ../../howto/functional.rst:801
msgid ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"
msgstr ""

#: ../../howto/functional.rst:808
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` повторює ітератор; він "
"повертає *n* незалежних ітераторів, які повертатимуть вміст вихідного "
"ітератора. Якщо ви не вкажете значення для *n*, за замовчуванням буде 2. "
"Реплікація ітераторів вимагає збереження частини вмісту вихідного ітератора,"
" тому це може споживати значну кількість пам’яті, якщо ітератор великий і "
"один із нових ітераторів споживається більше ніж інші. ::"

#: ../../howto/functional.rst:816
msgid ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."
msgstr ""

#: ../../howto/functional.rst:827
msgid "Calling functions on elements"
msgstr "Виклик функцій на елементах"

#: ../../howto/functional.rst:829
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) "
"<operator.add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` "
"(same as ``a != b``), and :func:`operator.attrgetter('id') "
"<operator.attrgetter>` (returns a callable that fetches the ``.id`` "
"attribute)."
msgstr ""
"Модуль :mod:`operator` містить набір функцій, що відповідають операторам "
"Python. Деякі приклади: :func:`operator.add(a, b) <operator.add>` (додає два"
" значення), :func:`operator.ne(a, b) <operator.ne>` (те саме, що ``a != "
"b``), і :func:`operator.attrgetter('id') <operator.attrgetter>` (повертає "
"виклик, який отримує атрибут ``.id``)."

#: ../../howto/functional.rst:835
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples"
" as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` припускає, що "
"iterable поверне потік кортежів, і викликає *func*, використовуючи ці "
"кортежі як аргументи:"

#: ../../howto/functional.rst:839
msgid ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"
msgstr ""

#: ../../howto/functional.rst:847
msgid "Selecting elements"
msgstr "Вибір елементів"

#: ../../howto/functional.rst:849
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"Інша група функцій вибирає підмножину елементів ітератора на основі "
"предикату."

#: ../../howto/functional.rst:852
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` є "
"протилежністю :func:`filter`, повертаючи всі елементи, для яких предикат "
"повертає false::"

#: ../../howto/functional.rst:856
msgid ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."
msgstr ""

#: ../../howto/functional.rst:859
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` повертає "
"елементи до тих пір, поки предикат повертає true. Як тільки предикат "
"повертає false, ітератор сигналізує про закінчення своїх результатів. ::"

#: ../../howto/functional.rst:863
msgid ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"
msgstr ""

#: ../../howto/functional.rst:872
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` відкидає "
"елементи, поки предикат повертає true, а потім повертає решту результатів "
"ітерації. ::"

#: ../../howto/functional.rst:876
msgid ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."
msgstr ""

#: ../../howto/functional.rst:882
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` приймає два"
" ітератори та повертає лише ті елементи *data*, для яких відповідний елемент"
" *selectors* є істинним, зупиняючись щоразу, коли один із них вичерпується::"

#: ../../howto/functional.rst:886
msgid ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"
msgstr ""

#: ../../howto/functional.rst:891
msgid "Combinatoric functions"
msgstr "Комбінаторні функції"

#: ../../howto/functional.rst:893
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"повертає ітератор, що містить усі можливі *r*-кортежні комбінації елементів,"
" що містяться в *iterable*. ::"

#: ../../howto/functional.rst:897
msgid ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"
msgstr ""

#: ../../howto/functional.rst:908
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, "
":func:`itertools.permutations(iterable, r=None) <itertools.permutations>`, "
"removes this constraint on the order, returning all possible arrangements of"
" length *r*::"
msgstr ""
"Елементи в кожному кортежі залишаються в тому самому порядку, у якому їх "
"повернув *iterable*. Наприклад, число 1 завжди стоїть перед 2, 3, 4 або 5 у "
"наведених вище прикладах. Подібна функція, "
":func:`itertools.permutations(iterable, r=None) <itertools.permutations>`, "
"усуває це обмеження на порядок, повертаючи всі можливі розташування довжини "
"*r*::"

#: ../../howto/functional.rst:915
msgid ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"
msgstr ""

#: ../../howto/functional.rst:927
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"Якщо ви не вказуєте значення для *r*, використовується довжина ітерованого, "
"що означає, що всі елементи переставлені."

#: ../../howto/functional.rst:930
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"Зауважте, що ці функції створюють усі можливі комбінації за позицією та не "
"вимагають, щоб вміст *iterable* був унікальним::"

#: ../../howto/functional.rst:933
msgid ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"
msgstr ""

#: ../../howto/functional.rst:937
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"Ідентичний кортеж ``('a', 'a', 'b')`` зустрічається двічі, але два рядки 'a'"
" походять з різних позицій."

#: ../../howto/functional.rst:940
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` function relaxes a different "
"constraint: elements can be repeated within a single tuple.  Conceptually an"
" element is selected for the first position of each tuple and then is "
"replaced before the second element is selected.  ::"
msgstr ""
"Функція :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` послаблює інше обмеження: "
"елементи можуть повторюватися в одному кортежі. Концептуально елемент "
"вибирається для першої позиції кожного кортежу, а потім замінюється перед "
"вибором другого елемента. ::"

#: ../../howto/functional.rst:946
msgid ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"
msgstr ""

#: ../../howto/functional.rst:955
msgid "Grouping elements"
msgstr "Групування елементів"

#: ../../howto/functional.rst:957
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"Остання функція, яку я розповім, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, є найскладнішою. ``key_func(elem)`` - "
"це функція, яка може обчислити значення ключа для кожного елемента, "
"повернутого ітерованим. Якщо ви не надаєте ключову функцію, ключем буде "
"просто кожен елемент сам по собі."

#: ../../howto/functional.rst:962
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of "
"2-tuples containing a key value and an iterator for the elements with that "
"key."
msgstr ""
":func:`~itertools.groupby` збирає всі послідовні елементи з основного "
"ітератора, які мають однакове значення ключа, і повертає потік 2-кортежів, "
"що містить значення ключа та ітератор для елементів із цим ключем."

#: ../../howto/functional.rst:968
msgid ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"
msgstr ""

#: ../../howto/functional.rst:990
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` припускає, що вміст базового ітератора вже буде "
"відсортовано на основі ключа. Зверніть увагу, що повернуті ітератори також "
"використовують базовий ітератор, тому ви повинні споживати результати "
"ітератора-1 перед запитом ітератора-2 та його відповідного ключа."

#: ../../howto/functional.rst:997
msgid "The functools module"
msgstr "Модуль functools"

#: ../../howto/functional.rst:999
msgid ""
"The :mod:`functools` module contains some higher-order functions. A "
"**higher-order function** takes one or more functions as input and returns a"
" new function.  The most useful tool in this module is the "
":func:`functools.partial` function."
msgstr ""

#: ../../howto/functional.rst:1004
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create"
" a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"Для програм, написаних у функціональному стилі, ви іноді захочете побудувати"
" варіанти існуючих функцій із заповненими деякими параметрами. Розглянемо "
"функцію Python ``f(a, b, c)``; ви можете створити нову функцію ``g(b, c)``, "
"еквівалентну ``f(1, b, c)``; ви вводите значення для одного з параметрів "
"``f()``. Це називається \"часткове застосування функції\"."

#: ../../howto/functional.rst:1010
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function``"
" with the filled-in arguments."
msgstr ""
"Конструктор для :func:`~functools.partial` приймає аргументи ``(функція, "
"arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``. Отриманий об’єкт можна "
"викликати, тому ви можете просто викликати його, щоб викликати ``функцію`` "
"із заповненими аргументами."

#: ../../howto/functional.rst:1015
msgid "Here's a small but realistic example::"
msgstr "Ось маленький, але реалістичний приклад:"

#: ../../howto/functional.rst:1017
msgid ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"
msgstr ""

#: ../../howto/functional.rst:1027
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function"
" that takes two elements and returns a single value.  "
":func:`functools.reduce` takes the first two elements A and B returned by "
"the iterator and calculates ``func(A, B)``.  It then requests the third "
"element, C, calculates ``func(func(A, B), C)``, combines this result with "
"the fourth element returned, and continues until the iterable is exhausted."
"  If the iterable returns no values at all, a :exc:`TypeError` exception is "
"raised.  If the initial value is supplied, it's used as a starting point and"
" ``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"кумулятивно виконує операцію над усіма елементами iterable і, отже, не може "
"бути застосовано до нескінченних iterables. *func* має бути функцією, яка "
"приймає два елементи та повертає одне значення. :func:`functools.reduce` "
"бере перші два елементи A і B, повернуті ітератором, і обчислює ``func(A, "
"B)``. Потім він запитує третій елемент, C, обчислює ``func(func(A, B), C)``,"
" поєднує цей результат із повернутим четвертим елементом і продовжує роботу,"
" доки не вичерпається ітерація. Якщо ітерація не повертає жодних значень, "
"виникає виняток :exc:`TypeError`. Якщо вказано початкове значення, воно "
"використовується як початкова точка, а ``func(initial_value, A)`` є першим "
"обчисленням. ::"

#: ../../howto/functional.rst:1039
msgid ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"
msgstr ""

#: ../../howto/functional.rst:1051
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up"
" all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"Якщо ви використовуєте :func:`operator.add` з :func:`functools.reduce`, ви "
"додасте всі елементи iterable. Цей випадок настільки поширений, що для його "
"обчислення існує спеціальна вбудована функція під назвою :func:`sum`:"

#: ../../howto/functional.rst:1063
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just"
" write the obvious :keyword:`for` loop::"
msgstr ""
"Однак для багатьох застосувань :func:`functools.reduce` може бути "
"зрозумілішим просто написати очевидний :keyword:`for` цикл::"

#: ../../howto/functional.rst:1066
msgid ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"
msgstr ""

#: ../../howto/functional.rst:1075
msgid ""
"A related function is :func:`itertools.accumulate(iterable, "
"func=operator.add) <itertools.accumulate>`.  It performs the same "
"calculation, but instead of returning only the final result, "
":func:`~itertools.accumulate` returns an iterator that also yields each "
"partial result::"
msgstr ""

#: ../../howto/functional.rst:1080
msgid ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"
msgstr ""

#: ../../howto/functional.rst:1088
msgid "The operator module"
msgstr "Операторський модуль"

#: ../../howto/functional.rst:1090
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"Модуль :mod:`operator` згадувався раніше. Він містить набір функцій, що "
"відповідають операторам Python. Ці функції часто корисні в коді "
"функціонального стилю, оскільки вони позбавляють вас від написання "
"тривіальних функцій, які виконують одну операцію."

#: ../../howto/functional.rst:1095
msgid "Some of the functions in this module are:"
msgstr "Деякі з функцій цього модуля:"

#: ../../howto/functional.rst:1097
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``,"
" ..."
msgstr ""
"Математичні операції: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

#: ../../howto/functional.rst:1098
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Логічні операції: ``not_()``, ``truth()``."

#: ../../howto/functional.rst:1099
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Побітові операції: ``and_()``, ``or_()``, ``invert()``."

#: ../../howto/functional.rst:1100
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Порівняння: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()`` і ``ge()`` ."

#: ../../howto/functional.rst:1101
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "Ідентифікація об'єкта: ``is_()``, ``is_not()``."

#: ../../howto/functional.rst:1103
msgid "Consult the operator module's documentation for a complete list."
msgstr ""
"Зверніться до документації модуля оператора, щоб отримати повний список."

#: ../../howto/functional.rst:1107
msgid "Small functions and the lambda expression"
msgstr "Малі функції та лямбда-вираз"

#: ../../howto/functional.rst:1109
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"Під час написання програм у функціональному стилі вам часто знадобляться "
"невеликі функції, які виконують роль предикатів або якимось чином поєднують "
"елементи."

#: ../../howto/functional.rst:1112
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't"
" need to define a new function at all::"
msgstr ""
"Якщо є вбудована функція Python або функція модуля, яка підходить, вам "
"взагалі не потрібно визначати нову функцію::"

#: ../../howto/functional.rst:1115
msgid ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"
msgstr ""

#: ../../howto/functional.rst:1118
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"Якщо потрібної вам функції не існує, її потрібно написати. Один із способів "
"написання невеликих функцій — це використання виразу :keyword:`lambda`. "
"``лямбда`` приймає кілька параметрів і вираз, що поєднує ці параметри, і "
"створює анонімну функцію, яка повертає значення виразу::"

#: ../../howto/functional.rst:1123
msgid ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"
msgstr ""

#: ../../howto/functional.rst:1127
msgid ""
"An alternative is to just use the ``def`` statement and define a function in"
" the usual way::"
msgstr ""
"Альтернативою є просто використання оператора ``def`` і визначення функції "
"звичайним способом::"

#: ../../howto/functional.rst:1130
msgid ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"
msgstr ""

#: ../../howto/functional.rst:1136
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"Яка альтернатива є кращою? Це питання стилю; мій звичайний курс — уникати "
"використання ``лямбда``."

#: ../../howto/functional.rst:1139
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a"
" ``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"Однією з причин моїх переваг є те, що ``лямбда`` досить обмежена у функціях,"
" які вона може визначати. Результат має бути обчислюваним як один вираз, що "
"означає, що ви не можете мати багатосторонні порівняння ``if... elif... "
"else`` або ``try... osim`` операторів. Якщо ви спробуєте зробити занадто "
"багато в операторі ``лямбда``, ви отримаєте надто складний вираз, який важко"
" прочитати. Швидко, що робить наступний код? ::"

#: ../../howto/functional.rst:1146
msgid ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"
msgstr ""

#: ../../howto/functional.rst:1149
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"Ви можете це зрозуміти, але потрібен час, щоб розібрати вираз, щоб "
"зрозуміти, що відбувається. Використання коротких вкладених операторів "
"``def`` покращує ситуацію:"

#: ../../howto/functional.rst:1153
msgid ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"
msgstr ""

#: ../../howto/functional.rst:1159
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "Але було б найкраще, якби я просто використав цикл ``for``::"

#: ../../howto/functional.rst:1161
msgid ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"
msgstr ""

#: ../../howto/functional.rst:1165
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "Або вбудований :func:`sum` і вираз генератора::"

#: ../../howto/functional.rst:1167
msgid "total = sum(b for a, b in items)"
msgstr ""

#: ../../howto/functional.rst:1169
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"Багато способів використання :func:`functools.reduce` зрозуміліші, коли "
"записуються як цикли ``for``."

#: ../../howto/functional.rst:1171
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses"
" of ``lambda``:"
msgstr ""
"Фредрік Лунд одного разу запропонував наступний набір правил для "
"рефакторингу використання ``лямбда``:"

#: ../../howto/functional.rst:1174
msgid "Write a lambda function."
msgstr "Напишіть лямбда-функцію."

#: ../../howto/functional.rst:1175
msgid "Write a comment explaining what the heck that lambda does."
msgstr "Напишіть коментар, пояснюючи, що в біса робить ця лямбда."

#: ../../howto/functional.rst:1176
msgid ""
"Study the comment for a while, and think of a name that captures the essence"
" of the comment."
msgstr ""
"Вивчіть коментар деякий час і придумайте назву, яка б передавала суть "
"коментаря."

#: ../../howto/functional.rst:1178
msgid "Convert the lambda to a def statement, using that name."
msgstr "Перетворіть лямбда-вираз на оператор def, використовуючи це ім’я."

#: ../../howto/functional.rst:1179
msgid "Remove the comment."
msgstr "Видалити коментар."

#: ../../howto/functional.rst:1181
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"Мені дуже подобаються ці правила, але ви можете не погоджуватися щодо того, "
"чи цей стиль без лямбда кращий."

#: ../../howto/functional.rst:1186
msgid "Revision History and Acknowledgements"
msgstr "Історія переглядів і подяки"

#: ../../howto/functional.rst:1188
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article:"
" Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike"
" Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"Автор хотів би подякувати наступним особам за пропозиції, виправлення та "
"допомогу з різними чернетками цієї статті: Іен Бікінґ, Нік Коглан, Нік "
"Еффорд, Реймонд Геттінгер, Джим Джеветт, Майк Крелл, Леандро Ламейро, Юссі "
"Салмела, Коллін Вінтер, Блейк Вінтон."

#: ../../howto/functional.rst:1193
msgid "Version 0.1: posted June 30 2006."
msgstr "Версія 0.1: опубліковано 30 червня 2006 р."

#: ../../howto/functional.rst:1195
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr ""
"Версія 0.11: опубліковано 1 липня 2006 р. Виправлення друкарських помилок."

#: ../../howto/functional.rst:1197
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Версія 0.2: опубліковано 10 липня 2006 р. Об’єднано розділи genexp і "
"listcomp в один. Виправлення друкарських помилок."

#: ../../howto/functional.rst:1200
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Версія 0.21: додано більше посилань, запропонованих у списку розсилки "
"викладачів."

#: ../../howto/functional.rst:1202
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Версія 0.30: додано розділ про ``функціональний`` модуль, написаний Колліном"
" Вінтером; додає короткий розділ про модуль оператора; кілька інших правок."

#: ../../howto/functional.rst:1207
msgid "References"
msgstr "Список літератури"

#: ../../howto/functional.rst:1210
msgid "General"
msgstr "Загальний"

#: ../../howto/functional.rst:1212
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and"
" Gerald Jay Sussman with Julie Sussman.  The book can be found at "
"https://mitpress.mit.edu/sicp.  In this classic textbook of computer "
"science, chapters 2 and 3 discuss the use of sequences and streams to "
"organize the data flow inside a program.  The book uses Scheme for its "
"examples, but many of the design approaches described in these chapters are "
"applicable to functional-style Python code."
msgstr ""

#: ../../howto/functional.rst:1220
msgid ""
"https://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""

#: ../../howto/functional.rst:1223
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: загальний запис у "
"Вікіпедії, що описує функціональне програмування."

#: ../../howto/functional.rst:1226
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: Запис для співпрограм."

#: ../../howto/functional.rst:1228
msgid ""
"https://en.wikipedia.org/wiki/Partial_application: Entry for the concept of "
"partial function application."
msgstr ""

#: ../../howto/functional.rst:1230
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: Початок поняття каррі."

#: ../../howto/functional.rst:1233
msgid "Python-specific"
msgstr "Специфічний для Python"

#: ../../howto/functional.rst:1235
msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in"
" Text Processing\"."
msgstr ""

#: ../../howto/functional.rst:1240
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 "
"<https://developer.ibm.com/articles/l-prog/>`__, `part 2 "
"<https://developer.ibm.com/tutorials/l-prog2/>`__, and `part 3 "
"<https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Мерц також написав серію статей із 3 частин про функціональне програмування "
"для сайту IBM DeveloperWorks; див. `частина 1 "
"<https://developer.ibm.com/articles/l-prog/>`__, `частина 2 "
"<https://developer.ibm.com/tutorials/l-prog2/>`__ та `частина 3 "
"<https://developer.ibm.com/tutorials/l-prog3/>`__,"

#: ../../howto/functional.rst:1248
msgid "Python documentation"
msgstr "Документація Python"

#: ../../howto/functional.rst:1250
msgid "Documentation for the :mod:`itertools` module."
msgstr "Документація для модуля :mod:`itertools`."

#: ../../howto/functional.rst:1252
msgid "Documentation for the :mod:`functools` module."
msgstr "Документація для модуля :mod:`functools`."

#: ../../howto/functional.rst:1254
msgid "Documentation for the :mod:`operator` module."
msgstr "Документація для модуля :mod:`operator`."

#: ../../howto/functional.rst:1256
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Генератор виразів\""

#: ../../howto/functional.rst:1258
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Сопрограми через розширені генератори\" описує нові функції "
"генератора в Python 2.5."
