# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-22 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "Рекомендації щодо анотацій"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "автор"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rst-1
msgid "Abstract"
msgstr "Анотація"

#: ../../howto/annotations.rst:11
msgid ""
"This document is designed to encapsulate the best practices for working with"
" annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Цей документ розроблено, щоб узагальнити найкращі методи роботи з анотаціями"
" dicts. Якщо ви пишете код на Python, який перевіряє ``__annotations__`` на "
"об’єктах Python, радимо дотримуватися вказівок, описаних нижче."

#: ../../howto/annotations.rst:16
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"Документ складається з чотирьох розділів: найкращі методи доступу до "
"анотацій об’єкта в Python версії 3.10 і новіших, найкращі методи доступу до "
"анотацій об’єктів у Python 3.9 і старіших версій, інші найкращі практики для"
" ``__annotations__``, які застосовуються до будь-якої версії Python, а "
"особливості ``__annotations__``."

#: ../../howto/annotations.rst:26
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the "
":mod:`typing` module."
msgstr ""
"Зверніть увагу, що в цьому документі йдеться саме про роботу з "
"``__annotations__``, а не про використання анотацій *for*. Якщо ви шукаєте "
"інформацію про те, як використовувати \"підказки типу\" у вашому коді, "
"перегляньте модуль :mod:`typing`."

#: ../../howto/annotations.rst:33
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "Доступ до анотацій Dict об’єкта в Python 3.10 і новіших версіях"

#: ../../howto/annotations.rst:35
msgid ""
"Python 3.10 adds a new function to the standard library: "
":func:`inspect.get_annotations`.  In Python versions 3.10 and newer, calling"
" this function is the best practice for accessing the annotations dict of "
"any object that supports annotations.  This function can also \"un-"
"stringize\" stringized annotations for you."
msgstr ""
"Python 3.10 додає нову функцію до стандартної бібліотеки: "
":func:`inspect.get_annotations`. У версіях Python 3.10 і новіших, виклик "
"цієї функції є найкращою практикою для доступу до dict анотацій будь-якого "
"об’єкта, який підтримує анотації. Ця функція також може \"відмінювати\" "
"рядкові анотації для вас."

#: ../../howto/annotations.rst:42
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use"
" case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, "
"``o.__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Якщо з якоїсь причини :func:`inspect.get_annotations` непридатний для вашого"
" випадку використання, ви можете отримати доступ до елемента даних "
"``__annotations__`` вручну. У Python 3.10 також змінилася найкраща практика "
"щодо цього: починаючи з Python 3.10, ``o.__annotations__`` гарантовано "
"*завжди* працюватиме з функціями, класами та модулями Python. Якщо ви "
"впевнені, що об’єкт, який ви досліджуєте, є одним із цих трьох *специфічних*"
" об’єктів, ви можете просто використати ``o.__annotations__``, щоб отримати "
"dict анотацій об’єкта."

#: ../../howto/annotations.rst:52
msgid ""
"However, other types of callables--for example, callables created by "
":func:`functools.partial`--may not have an ``__annotations__`` attribute "
"defined.  When accessing the ``__annotations__`` of a possibly unknown "
"object,  best practice in Python versions 3.10 and newer is to call "
":func:`getattr` with three arguments, for example ``getattr(o, "
"'__annotations__', None)``."
msgstr ""
"Однак інші типи викликів, наприклад, виклики, створені "
":func:`functools.partial`, можуть не мати визначеного атрибута "
"``__annotations__``. Під час доступу до ``__annotations__`` можливо "
"невідомого об’єкта, найкраща практика в Python версії 3.10 і новіших — "
"викликати :func:`getattr` з трьома аргументами, наприклад ``getattr(o, "
"'__annotations__', None)``."

#: ../../howto/annotations.rst:60
msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no"
" annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""

#: ../../howto/annotations.rst:68
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "Доступ до анотацій Dict об’єкта в Python 3.9 і старіших версіях"

#: ../../howto/annotations.rst:70
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much"
" more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"У Python 3.9 і старіших версіях доступ до анотацій dict об’єкта набагато "
"складніший, ніж у новіших версіях. Проблема полягає в недоліку дизайну в цих"
" старих версіях Python, зокрема щодо анотацій класів."

#: ../../howto/annotations.rst:75
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"Найкраща практика доступу до анотацій dict інших об’єктів — функцій, інших "
"викликів і модулів — така ж, як і найкраща практика для 3.10, припускаючи, "
"що ви не викликаєте :func:`inspect.get_annotations`: вам слід "
"використовувати три- аргумент :func:`getattr` для доступу до атрибута "
"``__annotations__`` об’єкта."

#: ../../howto/annotations.rst:82
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"На жаль, це не найкраща практика для занять. Проблема полягає в тому, що, "
"оскільки ``__annotations__`` є необов’язковим для класів, і оскільки класи "
"можуть успадковувати атрибути від своїх базових класів, доступ до атрибута "
"``__annotations__`` класу може ненавмисно повернути анотації dict *base "
"class*. Як приклад::"

#: ../../howto/annotations.rst:89
msgid ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"
msgstr ""

#: ../../howto/annotations.rst:98
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr "Це надрукує анотації dict з ``Base``, а не ``Derived``."

#: ../../howto/annotations.rst:101
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's :attr:`~type.__dict__` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the :meth:`~dict.get` method on the class dict."
msgstr ""

#: ../../howto/annotations.rst:109
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"Ось приклад коду, який безпечно отримує доступ до атрибута "
"``__annotations__`` довільного об’єкта в Python 3.9 і раніше:"

#: ../../howto/annotations.rst:113
msgid ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"
msgstr ""

#: ../../howto/annotations.rst:118
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``."
"  You're encouraged to double-check the type of ``ann`` using "
":func:`isinstance` before further examination."
msgstr ""
"Після виконання цього коду ``ann`` має бути або словником, або ``None``. "
"Перед подальшим вивченням радимо ще раз перевірити тип ``ann`` за допомогою "
":func:`isinstance`."

#: ../../howto/annotations.rst:123
msgid ""
"Note that some exotic or malformed type objects may not have a "
":attr:`~type.__dict__` attribute, so for extra safety you may also wish to "
"use :func:`getattr` to access :attr:`!__dict__`."
msgstr ""

#: ../../howto/annotations.rst:129
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Ручне видалення струнних анотацій"

#: ../../howto/annotations.rst:131
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"У ситуаціях, коли деякі анотації можуть бути \"рядковими\", і ви бажаєте "
"оцінити ці рядки для створення значень Python, які вони представляють, "
"дійсно найкраще викликати :func:`inspect.get_annotations`, щоб зробити цю "
"роботу за вас."

#: ../../howto/annotations.rst:137
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use "
":func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're"
" encouraged to examine the implementation of :func:`inspect.get_annotations`"
" in the current Python version and follow a similar approach."
msgstr ""
"Якщо ви використовуєте Python 3.9 або старішу версію, або якщо з якоїсь "
"причини ви не можете використовувати :func:`inspect.get_annotations`, вам "
"потрібно буде скопіювати його логіку. Радимо перевірити реалізацію "
":func:`inspect.get_annotations` у поточній версії Python і застосувати "
"подібний підхід."

#: ../../howto/annotations.rst:143
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"У двох словах, якщо ви бажаєте оцінити рядкову анотацію довільного об’єкта "
"``o``:"

#: ../../howto/annotations.rst:146
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling "
":func:`eval`."
msgstr ""
"Якщо ``o`` є модулем, використовуйте ``o.__dict__`` як ``globals`` під час "
"виклику :func:`eval`."

#: ../../howto/annotations.rst:148
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling "
":func:`eval`."
msgstr ""
"Якщо ``o`` є класом, використовуйте ``sys.modules[o.__module__].__dict__`` "
"як ``globals``, а ``dict(vars(o))`` як ``locals``, під час виклику "
":func:`eval`."

#: ../../howto/annotations.rst:151
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, "
":func:`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it"
" by accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until "
"you have found the root unwrapped function."
msgstr ""
"Якщо ``o`` є обернутим викликом за допомогою "
":func:`functools.update_wrapper`, :func:`functools.wraps` або "
":func:`functools.partial`, ітеративно розгортайте його, звертаючись до "
"``o.__wrapped__`` або ``o.func`` відповідно, доки ви не знайдете кореневу "
"розгорнуту функцію."

#: ../../howto/annotations.rst:155
msgid ""
"If ``o`` is a callable (but not a class), use :attr:`o.__globals__ "
"<function.__globals__>` as the globals when calling :func:`eval`."
msgstr ""

#: ../../howto/annotations.rst:159
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically"
" contain any valid string, and in practice there are valid use cases for "
"type hints that require annotating with string values that specifically "
"*can't* be evaluated.  For example:"
msgstr ""
"Однак не всі рядкові значення, які використовуються як анотації, можна "
"успішно перетворити на значення Python за допомогою :func:`eval`. Рядкові "
"значення теоретично можуть містити будь-який дійсний рядок, і на практиці є "
"дійсні випадки використання підказок типу, які вимагають анотування "
"рядковими значеннями, які конкретно *неможливо* оцінити. Наприклад:"

#: ../../howto/annotations.rst:166
msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
":pep:`604` типи об’єднання з використанням ``|``, перш ніж підтримку цього "
"було додано в Python 3.10."

#: ../../howto/annotations.rst:168
msgid ""
"Definitions that aren't needed at runtime, only imported when "
":const:`typing.TYPE_CHECKING` is true."
msgstr ""
"Визначення, які не потрібні під час виконання, імпортуються лише тоді, коли "
":const:`typing.TYPE_CHECKING` має значення true."

#: ../../howto/annotations.rst:171
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Якщо :func:`eval` спробує обчислити такі значення, це зазнає невдачі та "
"викличе виняток. Таким чином, під час розробки API бібліотеки, яка працює з "
"анотаціями, рекомендується намагатися оцінити значення рядка лише тоді, коли"
" це явно вимагається від викликаючого."

#: ../../howto/annotations.rst:179
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr ""
"Найкращі методи роботи з ``__annotations__`` в будь-якій версії Python"

#: ../../howto/annotations.rst:181
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Вам слід уникати безпосереднього призначення члену ``__annotations__`` "
"об’єктів. Дозвольте Python керувати налаштуванням ``__annotations__``."

#: ../../howto/annotations.rst:184
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Якщо ви призначаєте безпосередньо члену ``__annotations__`` об’єкта, ви "
"завжди повинні встановлювати його на об’єкт ``dict``."

#: ../../howto/annotations.rst:187
msgid ""
"If you directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""
"Якщо ви здійснюєте прямий доступ до елемента ``__annotations__`` об’єкта, ви"
" повинні переконатися, що це словник, перш ніж намагатися перевірити його "
"вміст."

#: ../../howto/annotations.rst:191
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Слід уникати змінення ``__annotations__`` dicts."

#: ../../howto/annotations.rst:193
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "Слід уникати видалення атрибута ``__annotations__`` об’єкта."

#: ../../howto/annotations.rst:198
msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` Примхи"

#: ../../howto/annotations.rst:200
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"У всіх версіях Python 3 функціональні об’єкти відкладено створюють анотації "
"dict, якщо для цього об’єкта не визначено анотацій. Ви можете видалити "
"атрибут ``__annotations__`` за допомогою ``del fn.__annotations__``, але "
"якщо ви потім отримаєте доступ до ``fn.__annotations__``, об’єкт створить "
"новий порожній dict, який він зберігатиме та повертатиме як свої анотації. "
"Видалення анотацій у функції до того, як вона ліниво створить свої анотації "
"dict, викличе ``AttributeError``; використання ``del fn.__annotations__`` "
"двічі поспіль гарантовано завжди викидає ``AttributeError``."

#: ../../howto/annotations.rst:210
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"Усе, що наведено вище, також стосується об’єктів класу та модуля в Python "
"3.10 і новіших версіях."

#: ../../howto/annotations.rst:213
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that"
" object using ``fn.__annotations__`` will lazy-create an empty dictionary as"
" per the first paragraph of this section.  This is *not* true of modules and"
" classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"У всіх версіях Python 3 для ``__annotations__`` для об’єкта функції можна "
"встановити значення ``None``. Однак подальший доступ до анотацій цього "
"об’єкта за допомогою ``fn.__annotations__`` призведе до відкладеного "
"створення порожнього словника згідно з першим параграфом цього розділу. Це "
"*не* стосується модулів і класів у будь-якій версії Python; ці об’єкти "
"дозволяють установлювати ``__annotations__`` на будь-яке значення Python і "
"збережуть будь-яке встановлене значення."

#: ../../howto/annotations.rst:221
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string"
" will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Якщо Python створить для вас рядкові анотації (за допомогою ``from "
"__future__ import annotations``), і ви вкажете рядок як анотацію, сам рядок "
"буде взято в лапки. По суті, анотація взята в лапки *двічі.* Наприклад::"

#: ../../howto/annotations.rst:227
msgid ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"
msgstr ""

#: ../../howto/annotations.rst:232
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Це друкує ``{'a': \"'str'\"}``. Це насправді не слід вважати \"химерністю\";"
" це згадується тут просто тому, що це може бути несподіваним."
