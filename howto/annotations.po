# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Annotations Best Practices"
msgstr "Рекомендації щодо анотацій"

msgid "author"
msgstr "автор"

msgid "Larry Hastings"
msgstr "Larry Hastings"

msgid "Abstract"
msgstr "Анотація"

msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Цей документ розроблено, щоб узагальнити найкращі методи роботи з анотаціями "
"dicts. Якщо ви пишете код на Python, який перевіряє ``__annotations__`` на "
"об’єктах Python, радимо дотримуватися вказівок, описаних нижче."

msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"Документ складається з чотирьох розділів: найкращі методи доступу до "
"анотацій об’єкта в Python версії 3.10 і новіших, найкращі методи доступу до "
"анотацій об’єктів у Python 3.9 і старіших версій, інші найкращі практики для "
"``__annotations__``, які застосовуються до будь-якої версії Python, а "
"особливості ``__annotations__``."

msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"Зверніть увагу, що в цьому документі йдеться саме про роботу з "
"``__annotations__``, а не про використання анотацій *for*. Якщо ви шукаєте "
"інформацію про те, як використовувати \"підказки типу\" у вашому коді, "
"перегляньте модуль :mod:`typing`."

msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "Доступ до анотацій Dict об’єкта в Python 3.10 і новіших версіях"

msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 and newer, calling this function "
"is the best practice for accessing the annotations dict of any object that "
"supports annotations.  This function can also \"un-stringize\" stringized "
"annotations for you."
msgstr ""
"Python 3.10 додає нову функцію до стандартної бібліотеки: :func:`inspect."
"get_annotations`. У версіях Python 3.10 і новіших, виклик цієї функції є "
"найкращою практикою для доступу до dict анотацій будь-якого об’єкта, який "
"підтримує анотації. Ця функція також може \"відмінювати\" рядкові анотації "
"для вас."

msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Якщо з якоїсь причини :func:`inspect.get_annotations` непридатний для вашого "
"випадку використання, ви можете отримати доступ до елемента даних "
"``__annotations__`` вручну. У Python 3.10 також змінилася найкраща практика "
"щодо цього: починаючи з Python 3.10, ``o.__annotations__`` гарантовано "
"*завжди* працюватиме з функціями, класами та модулями Python. Якщо ви "
"впевнені, що об’єкт, який ви досліджуєте, є одним із цих трьох *специфічних* "
"об’єктів, ви можете просто використати ``o.__annotations__``, щоб отримати "
"dict анотацій об’єкта."

msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"Однак інші типи викликів, наприклад, виклики, створені :func:`functools."
"partial`, можуть не мати визначеного атрибута ``__annotations__``. Під час "
"доступу до ``__annotations__`` можливо невідомого об’єкта, найкраща практика "
"в Python версії 3.10 і новіших — викликати :func:`getattr` з трьома "
"аргументами, наприклад ``getattr(o, '__annotations__', None)``."

msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "Доступ до анотацій Dict об’єкта в Python 3.9 і старіших версіях"

msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"У Python 3.9 і старіших версіях доступ до анотацій dict об’єкта набагато "
"складніший, ніж у новіших версіях. Проблема полягає в недоліку дизайну в цих "
"старих версіях Python, зокрема щодо анотацій класів."

msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"Найкраща практика доступу до анотацій dict інших об’єктів — функцій, інших "
"викликів і модулів — така ж, як і найкраща практика для 3.10, припускаючи, "
"що ви не викликаєте :func:`inspect.get_annotations`: вам слід "
"використовувати три- аргумент :func:`getattr` для доступу до атрибута "
"``__annotations__`` об’єкта."

msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"На жаль, це не найкраща практика для занять. Проблема полягає в тому, що, "
"оскільки ``__annotations__`` є необов’язковим для класів, і оскільки класи "
"можуть успадковувати атрибути від своїх базових класів, доступ до атрибута "
"``__annotations__`` класу може ненавмисно повернути анотації dict *base "
"class*. Як приклад::"

msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr "Це надрукує анотації dict з ``Base``, а не ``Derived``."

msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's ``__dict__`` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the ``get`` method on the class dict."
msgstr ""
"Ваш код повинен мати окремий кодовий шлях, якщо об’єкт, який ви перевіряєте, "
"є класом (``isinstance(o, type)``). У цьому випадку найкраща практика "
"покладається на деталі реалізації Python 3.9 і раніше: якщо клас має "
"визначені анотації, вони зберігаються в словнику ``__dict__`` класу. "
"Оскільки клас може мати або не мати визначених анотацій, найкращою практикою "
"є виклик методу ``get`` у dict класу."

msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"Ось приклад коду, який безпечно отримує доступ до атрибута "
"``__annotations__`` довільного об’єкта в Python 3.9 і раніше:"

msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"Після виконання цього коду ``ann`` має бути або словником, або ``None``. "
"Перед подальшим вивченням радимо ще раз перевірити тип ``ann`` за допомогою :"
"func:`isinstance`."

msgid ""
"Note that some exotic or malformed type objects may not have a ``__dict__`` "
"attribute, so for extra safety you may also wish to use :func:`getattr` to "
"access ``__dict__``."
msgstr ""
"Зауважте, що деякі об’єкти екзотичного чи неправильного типу можуть не мати "
"атрибута ``__dict__``, тому для додаткової безпеки ви також можете "
"використовувати :func:`getattr` для доступу до ``__dict__``."

msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Ручне видалення струнних анотацій"

msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"У ситуаціях, коли деякі анотації можуть бути \"рядковими\", і ви бажаєте "
"оцінити ці рядки для створення значень Python, які вони представляють, "
"дійсно найкраще викликати :func:`inspect.get_annotations`, щоб зробити цю "
"роботу за вас."

msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"Якщо ви використовуєте Python 3.9 або старішу версію, або якщо з якоїсь "
"причини ви не можете використовувати :func:`inspect.get_annotations`, вам "
"потрібно буде скопіювати його логіку. Радимо перевірити реалізацію :func:"
"`inspect.get_annotations` у поточній версії Python і застосувати подібний "
"підхід."

msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"У двох словах, якщо ви бажаєте оцінити рядкову анотацію довільного об’єкта "
"``o``:"

msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr ""
"Якщо ``o`` є модулем, використовуйте ``o.__dict__`` як ``globals`` під час "
"виклику :func:`eval`."

msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"Якщо ``o`` є класом, використовуйте ``sys.modules[o.__module__].__dict__`` "
"як ``globals``, а ``dict(vars(o))`` як ``locals``, під час виклику :func:"
"`eval`."

msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"Якщо ``o`` є обернутим викликом за допомогою :func:`functools."
"update_wrapper`, :func:`functools.wraps` або :func:`functools.partial`, "
"ітеративно розгортайте його, звертаючись до ``o.__wrapped__`` або ``o.func`` "
"відповідно, доки ви не знайдете кореневу розгорнуту функцію."

msgid ""
"If ``o`` is a callable (but not a class), use ``o.__globals__`` as the "
"globals when calling :func:`eval`."
msgstr ""
"Якщо ``o`` є викликаним (але не класом), використовуйте ``o.__globals__`` як "
"глобальні під час виклику :func:`eval`."

msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"Однак не всі рядкові значення, які використовуються як анотації, можна "
"успішно перетворити на значення Python за допомогою :func:`eval`. Рядкові "
"значення теоретично можуть містити будь-який дійсний рядок, і на практиці є "
"дійсні випадки використання підказок типу, які вимагають анотування "
"рядковими значеннями, які конкретно *неможливо* оцінити. Наприклад:"

msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
":pep:`604` типи об’єднання з використанням ``|``, перш ніж підтримку цього "
"було додано в Python 3.10."

msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr ""
"Визначення, які не потрібні під час виконання, імпортуються лише тоді, коли :"
"const:`typing.TYPE_CHECKING` має значення true."

msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Якщо :func:`eval` спробує обчислити такі значення, це зазнає невдачі та "
"викличе виняток. Таким чином, під час розробки API бібліотеки, яка працює з "
"анотаціями, рекомендується намагатися оцінити значення рядка лише тоді, коли "
"це явно вимагається від викликаючого."

msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "Найкращі методи роботи з ``__annotations__`` в будь-якій версії Python"

msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Вам слід уникати безпосереднього призначення члену ``__annotations__`` "
"об’єктів. Дозвольте Python керувати налаштуванням ``__annotations__``."

msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Якщо ви призначаєте безпосередньо члену ``__annotations__`` об’єкта, ви "
"завжди повинні встановлювати його на об’єкт ``dict``."

msgid ""
"If you directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""
"Якщо ви здійснюєте прямий доступ до елемента ``__annotations__`` об’єкта, ви "
"повинні переконатися, що це словник, перш ніж намагатися перевірити його "
"вміст."

msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Слід уникати змінення ``__annotations__`` dicts."

msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "Слід уникати видалення атрибута ``__annotations__`` об’єкта."

msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` Примхи"

msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"У всіх версіях Python 3 функціональні об’єкти відкладено створюють анотації "
"dict, якщо для цього об’єкта не визначено анотацій. Ви можете видалити "
"атрибут ``__annotations__`` за допомогою ``del fn.__annotations__``, але "
"якщо ви потім отримаєте доступ до ``fn.__annotations__``, об’єкт створить "
"новий порожній dict, який він зберігатиме та повертатиме як свої анотації. "
"Видалення анотацій у функції до того, як вона ліниво створить свої анотації "
"dict, викличе ``AttributeError``; використання ``del fn.__annotations__`` "
"двічі поспіль гарантовано завжди викидає ``AttributeError``."

msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"Усе, що наведено вище, також стосується об’єктів класу та модуля в Python "
"3.10 і новіших версіях."

msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"У всіх версіях Python 3 для ``__annotations__`` для об’єкта функції можна "
"встановити значення ``None``. Однак подальший доступ до анотацій цього "
"об’єкта за допомогою ``fn.__annotations__`` призведе до відкладеного "
"створення порожнього словника згідно з першим параграфом цього розділу. Це "
"*не* стосується модулів і класів у будь-якій версії Python; ці об’єкти "
"дозволяють установлювати ``__annotations__`` на будь-яке значення Python і "
"збережуть будь-яке встановлене значення."

msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Якщо Python створить для вас рядкові анотації (за допомогою ``from "
"__future__ import annotations``), і ви вкажете рядок як анотацію, сам рядок "
"буде взято в лапки. По суті, анотація взята в лапки *двічі.* Наприклад::"

msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Це друкує ``{'a': \"'str'\"}``. Це насправді не слід вважати \"химерністю\"; "
"це згадується тут просто тому, що це може бути несподіваним."
