# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Regular Expression HOWTO"
msgstr "Регулярний вираз HOWTO"

msgid "Author"
msgstr "Автор"

msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

msgid "Abstract"
msgstr "Анотація"

msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Цей документ є вступним посібником із використання регулярних виразів у "
"Python із модулем :mod:`re`. Він містить більш лагідний вступ, ніж "
"відповідний розділ довідника бібліотеки."

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Регулярні вирази (так звані RE, або регулярні вирази, або шаблони регулярних "
"виразів) — це, по суті, крихітна вузькоспеціалізована мова програмування, "
"вбудована в Python і доступна через модуль :mod:`re`. Використовуючи цю "
"маленьку мову, ви визначаєте правила для набору можливих рядків, які ви "
"хочете зіставити; цей набір може містити англійські речення, або адреси "
"електронної пошти, або команди TeX, або будь-що, що вам подобається. Потім "
"ви можете поставити такі запитання, як \"Чи відповідає цей рядок шаблону?\" "
"або \"Чи є відповідність шаблону десь у цьому рядку?\". Ви також можете "
"використовувати RE, щоб змінити рядок або розділити його різними способами."

msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Шаблони регулярних виразів компілюються в серію байт-кодів, які потім "
"виконуються механізмом відповідності, написаним мовою C. Для розширеного "
"використання може знадобитися звернути особливу увагу на те, як механізм "
"виконуватиме заданий RE, і записати RE у певним чином, щоб створити байт-"
"код, який працює швидше. Оптимізація не розглядається в цьому документі, "
"оскільки вона вимагає, щоб ви добре розуміли внутрішні механізми "
"відповідності."

msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"Мова регулярних виразів є відносно невеликою та обмеженою, тому не всі "
"можливі завдання обробки рядків можна виконати за допомогою регулярних "
"виразів. Також є завдання, які *можна* виконувати регулярними виразами, але "
"вирази виявляються дуже складними. У цих випадках вам може бути краще "
"написати код Python для виконання обробки; Хоча код Python буде повільнішим, "
"ніж складний регулярний вираз, він також, ймовірно, буде більш зрозумілим."

msgid "Simple Patterns"
msgstr "Прості візерунки"

msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Ми почнемо з вивчення найпростіших регулярних виразів. Оскільки регулярні "
"вирази використовуються для роботи з рядками, ми почнемо з найпоширенішого "
"завдання: зіставлення символів."

msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"Для детального пояснення інформатики, що лежить в основі регулярних виразів "
"(детермінованих і недетермінованих кінцевих автоматів), ви можете звернутися "
"до майже будь-якого підручника з написання компіляторів."

msgid "Matching Characters"
msgstr "Відповідні символи"

msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"Більшість літер і символів просто збігаються. Наприклад, регулярний вираз "
"``test`` точно збігатиметься з рядком ``test``. (Ви можете ввімкнути режим "
"без урахування регістру, який дозволив би цьому RE відповідати також "
"``Test`` або ``TEST``; докладніше про це пізніше.)"

msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"З цього правила є винятки; деякі символи є спеціальними :dfn:"
"`metacharacters` і не відповідають самі собі. Натомість вони сигналізують "
"про те, що потрібно зіставити щось незвичайне, або впливають на інші частини "
"RE, повторюючи їх або змінюючи їх значення. Велика частина цього документа "
"присвячена обговоренню різних метасимволів і того, що вони роблять."

msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Ось повний список метасимволів; їхнє значення буде обговорено в решті цього "
"HOWTO."

msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"Перші метасимволи, які ми розглянемо, це ``[`` і ``]``. Вони "
"використовуються для вказівки класу символів, який є набором символів, які "
"ви хочете зіставити. Символи можна перераховувати окремо або діапазон "
"символів можна вказати двома символами та розділити їх символом ``'-'``. "
"Наприклад, \"[abc]\" відповідатиме будь-якому із символів \"a\", \"b\" або "
"\"c\"; це те саме, що ``[a-c]``, який використовує діапазон для вираження "
"того самого набору символів. Якщо ви хочете зіставити лише малі літери, "
"вашим RE буде ``[a-z]``."

msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"Метасимволи (крім ``\\``) неактивні всередині класів. Наприклад, ``[akm$]`` "
"відповідатиме будь-якому із символів ``'a'``, ``'k'``, ``'m'`` або ``'$'``; "
"``'$'`` зазвичай є метасимволом, але всередині класу символів він "
"позбавлений особливої природи."

msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
"Ви можете зіставити символи, яких немає в списку в класі, :dfn:"
"`complementing` набір. Це вказується додаванням ``'^'`` як першого символу "
"класу. Наприклад, ``[^5]`` відповідатиме будь-якому символу, крім ``'5'``. "
"Якщо каретка з’являється в іншому місці класу символів, вона не має "
"особливого значення. Наприклад: ``[5^]`` відповідатиме або ``'5''``, або "
"``'^'``."

msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Мабуть, найважливішим метасимволом є зворотна коса риска, ``\\``. Як і в "
"рядкових літералах Python, за зворотною скісною рискою можуть слідувати "
"різні символи, щоб позначити різні спеціальні послідовності. Він також "
"використовується для екранування всіх метасимволів, щоб ви все ще могли "
"зіставляти їх у шаблонах; наприклад, якщо вам потрібно знайти відповідність "
"``[`` або ``\\``, ви можете поставити перед ними зворотну скісну риску, щоб "
"видалити їхнє спеціальне значення: ``\\[`` або ``\\\\``."

msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"Деякі спеціальні послідовності, що починаються з ``'\\'``, представляють "
"заздалегідь визначені набори символів, які часто є корисними, наприклад "
"набір цифр, набір літер або набір будь-чого, що не є пробілами."

msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"Розглянемо приклад: ``\\w`` відповідає будь-якому буквено-цифровому символу. "
"Якщо шаблон регулярного виразу виражено в байтах, це еквівалентно класу ``[a-"
"zA-Z0-9_]``. Якщо шаблон регулярного виразу є рядком, ``\\w`` відповідатиме "
"всім символам, позначеним як літери в базі даних Unicode, наданій модулем :"
"mod:`unicodedata`. Ви можете використовувати більш обмежене визначення "
"``\\w`` у шаблоні рядка, поставивши прапорець :const:`re.ASCII` під час "
"компіляції регулярного виразу."

msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"Наступний список спеціальних послідовностей не є повним. Щоб отримати повний "
"список послідовностей і розширених визначень класів для шаблонів рядків "
"Unicode, перегляньте останню частину :ref:`Синтаксису регулярного виразу <re-"
"syntax>` у довіднику стандартної бібліотеки. Загалом, версії Unicode "
"відповідають будь-якому символу, який знаходиться у відповідній категорії "
"бази даних Unicode."

msgid "``\\d``"
msgstr "``\\d``"

msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr ""
"Збігається з будь-якою десятковою цифрою; це еквівалентно класу ``[0-9]``."

msgid "``\\D``"
msgstr "``\\D``"

msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"Відповідає будь-якому нецифровому символу; це еквівалентно класу ``[^0-9]``."

msgid "``\\s``"
msgstr "``\\s``"

msgid ""
"Matches any whitespace character; this is equivalent to the class "
"``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає будь-якому пробілу; це еквівалентно класу ``[ \\t\\n\\r\\f\\v]``."

msgid "``\\S``"
msgstr "``\\S``"

msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає будь-якому непробільному символу; це еквівалентно класу ``[^ "
"\\t\\n\\r\\f\\v]``."

msgid "``\\w``"
msgstr "``\\w``"

msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr ""
"Відповідає будь-якому буквено-цифровому символу; це еквівалентно класу ``[a-"
"zA-Z0-9_]``."

msgid "``\\W``"
msgstr "``\\W``"

msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"Відповідає будь-якому небуквено-цифровому символу; це еквівалентно класу "
"``[^a-zA-Z0-9_]``."

msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Ці послідовності можна включити в клас символів. Наприклад, ``[\\s,.]`` — це "
"клас символів, який відповідатиме будь-якому пробілу, або ``',''`` чи "
"``'.''``."

msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"Останнім метасимволом у цьому розділі є ``.``. Він відповідає будь-чому, "
"крім символу нового рядка, і є альтернативний режим (:const:`re.DOTALL`), де "
"він відповідатиме навіть новому рядку. ``.`` часто використовується, коли "
"потрібно знайти відповідність \"будь-якому символу\"."

msgid "Repeating Things"
msgstr "Повторення речей"

msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Здатність зіставляти різні набори символів — це перше, що можуть зробити "
"регулярні вирази, що ще не можливо за допомогою методів, доступних для "
"рядків. Однак, якби це була єдина додаткова можливість регулярних виразів, "
"вони не були б великим прогресом. Інша можливість полягає в тому, що ви "
"можете вказати, що частини RE мають повторюватися певну кількість разів."

msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"Перший метасимвол для повторення речей, які ми розглянемо, це ``*``. ``*`` "
"не відповідає буквальному символу ``'*'``; натомість він визначає, що "
"попередній символ може бути зіставлений нуль або більше разів замість точно "
"одного разу."

msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Наприклад, ``ca*t`` відповідатиме ``'ct'`` (0 символів ``'a'``), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 символи ``'a'``) і так далі."

msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Такі повтори, як ``*`` є :dfn:`greedy`; при повторенні RE механізм пошуку "
"відповідності намагатиметься повторити його якомога більше разів. Якщо "
"пізніші частини шаблону не збігаються, механізм пошуку відповідностей "
"створить резервну копію та спробує знову з меншою кількістю повторень."

msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Покроковий приклад зробить це більш очевидним. Розглянемо вираз "
"``a[bcd]*b``. Це відповідає літері ``'a'``, нулю або більше літер з класу "
"``[bcd]`` і, нарешті, закінчується ``'b'``. Тепер уявіть, що зіставлення "
"цього RE з рядком ``'abcbd``."

msgid "Step"
msgstr "Крок"

msgid "Matched"
msgstr "Збіг"

msgid "Explanation"
msgstr "Пояснення"

msgid "1"
msgstr "1"

msgid "``a``"
msgstr "``a``"

msgid "The ``a`` in the RE matches."
msgstr "``a`` у RE відповідає."

msgid "2"
msgstr "2"

msgid "``abcbd``"
msgstr "``abcbd``"

msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"Механізм збігається з ``[bcd]*``, просуваючись якомога далі, тобто до кінця "
"рядка."

msgid "3"
msgstr "3"

msgid "*Failure*"
msgstr "*Невдача*"

msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"Механізм намагається знайти відповідність ``b``, але поточна позиція "
"знаходиться в кінці рядка, тому це не вдається."

msgid "4"
msgstr "4"

msgid "``abcb``"
msgstr "``abcb``"

msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr ""
"Зробіть резервну копію, щоб ``[bcd]*`` відповідав на один символ менше."

msgid "5"
msgstr "5"

msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr ""
"Спробуйте ``b`` ще раз, але поточна позиція знаходиться на останньому "
"символі, який є ``'d'``."

msgid "6"
msgstr "6"

msgid "``abc``"
msgstr "``abc``"

msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "Знову створіть резервну копію, щоб ``[bcd]*`` відповідало лише ``bc``."

msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Спробуйте ``b`` знову. Цього разу символом у поточній позиції є ``'b'``, "
"отже, це вдалось."

msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"Кінець RE вже досягнуто, і він відповідає ``'abcb``. Це демонструє, як "
"система пошуку відповідностей спочатку йде так далеко, як тільки може, і "
"якщо відповідності не знайдено, вона поступово створюватиме резервні копії "
"та повторюватиме решту RE знову і знову. Він виконуватиме резервне "
"копіювання, доки не знайде нульових збігів для ``[bcd]*``, і якщо це згодом "
"не вдасться, система зробить висновок, що рядок взагалі не відповідає RE."

msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Ще один повторюваний метасимвол – це ``+``, який збігається один або кілька "
"разів. Зверніть увагу на різницю між ``*`` і ``+``; ``*`` відповідає *нуль* "
"або більше разів, тому все, що повторюється, може взагалі не бути присутнім, "
"тоді як ``+`` вимагає принаймні *одного* входження. Щоб використати подібний "
"приклад, ``ca+t`` відповідатиме ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), але не відповідатиме ``'ct``."

msgid ""
"There are two more repeating qualifiers.  The question mark character, ``?"
"``, matches either once or zero times; you can think of it as marking "
"something as being optional.  For example, ``home-?brew`` matches either "
"``'homebrew'`` or ``'home-brew'``."
msgstr ""

msgid ""
"The most complicated repeated qualifier is ``{m,n}``, where *m* and *n* are "
"decimal integers.  This qualifier means there must be at least *m* "
"repetitions, and at most *n*.  For example, ``a/{1,3}b`` will match ``'a/"
"b'``, ``'a//b'``, and ``'a///b'``.  It won't match ``'ab'``, which has no "
"slashes, or ``'a////b'``, which has four."
msgstr ""

msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Ви можете опустити *m* або *n*; у цьому випадку для відсутнього значення "
"приймається розумне значення. Пропуск *m* інтерпретується як нижня межа 0, "
"тоді як пропуск *n* призводить до верхньої межі нескінченності."

msgid ""
"Readers of a reductionist bent may notice that the three other qualifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""

msgid "Using Regular Expressions"
msgstr "Використання регулярних виразів"

msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"Тепер, коли ми розглянули деякі прості регулярні вирази, як ми насправді "
"використовуємо їх у Python? Модуль :mod:`re` надає інтерфейс механізму "
"регулярних виразів, дозволяючи вам компілювати RE в об’єкти, а потім "
"виконувати з ними збіги."

msgid "Compiling Regular Expressions"
msgstr "Компіляція регулярних виразів"

msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"Регулярні вирази компілюються в об’єкти шаблонів, які мають методи для "
"різноманітних операцій, таких як пошук збігів шаблону або виконання "
"підстановок рядків. ::"

msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` також приймає необов’язковий аргумент *flags*, який "
"використовується для ввімкнення різних спеціальних функцій і варіантів "
"синтаксису. Пізніше ми розглянемо доступні параметри, а поки підійде один "
"приклад:"

msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"RE передається до :func:`re.compile` як рядок. RE обробляються як рядки, "
"оскільки регулярні вирази не є частиною основної мови Python, і для їх "
"вираження не створено спеціального синтаксису. (Існують програми, які "
"взагалі не потребують RE, тому немає потреби роздувати специфікацію мови, "
"включаючи їх.) Натомість модуль :mod:`re` є просто модулем розширення C, що "
"входить до складу Python, як і модулі :mod:`socket` або :mod:`zlib`."

msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Розміщення RE в рядках робить мову Python простішою, але має один недолік, "
"який є темою наступного розділу."

msgid "The Backslash Plague"
msgstr "Зворотна коса чума"

msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Як було сказано раніше, у регулярних виразах використовується символ "
"зворотної косої риски (``'\\'``), щоб позначити спеціальні форми або "
"дозволити використовувати спеціальні символи без виклику їх особливого "
"значення. Це суперечить використанню Python того самого символу для тієї ж "
"мети в рядкових літералах."

msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"Припустімо, ви хочете написати RE, який відповідає рядку ``\\section``, який "
"можна знайти у файлі LaTeX. Щоб зрозуміти, що писати в коді програми, "
"почніть із потрібного рядка, який потрібно знайти. Далі ви повинні уникнути "
"будь-яких зворотних похилих рисок та інших метасимволів, поставивши перед "
"ними зворотну похилу риску, що призведе до рядка ``\\\\section``. Отриманий "
"рядок, який потрібно передати в :func:`re.compile`, має бути ``\\"
"\\section``. Однак, щоб виразити це як рядковий літерал Python, обидві "
"зворотні похилі риски потрібно екранувати *знову*."

msgid "Characters"
msgstr "Персонажі"

msgid "Stage"
msgstr "етап"

msgid "``\\section``"
msgstr "``\\розділ``"

msgid "Text string to be matched"
msgstr "Текстовий рядок, який потрібно знайти"

msgid "``\\\\section``"
msgstr "``\\\\розділ``"

msgid "Escaped backslash for :func:`re.compile`"
msgstr "Екранований зворотний слеш для :func:`re.compile`"

msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\розділ\"``"

msgid "Escaped backslashes for a string literal"
msgstr "Екрановані зворотні косі риски для рядкового літералу"

msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"Коротше кажучи, щоб відповідати буквальному зворотному слешу, потрібно "
"написати ``'\\\\\\\\'`` як рядок RE, тому що регулярний вираз має бути ``\\"
"\\``, а кожен зворотний слеш має бути виражений як ``\\\\`` всередині "
"звичайного рядкового літералу Python. У RE, які неодноразово містять "
"зворотні косі риски, це призводить до великої кількості повторюваних "
"зворотних косих риск і ускладнює розуміння результуючих рядків."

msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"Рішення полягає у використанні необробленої рядкової нотації Python для "
"регулярних виразів; зворотні косі риски не обробляються спеціальним чином у "
"рядковому літералі з префіксом ``'r'``, тому ``r\"\\n\"`` є двосимвольним "
"рядком, що містить ``'\\'`` і ``' n'``, тоді як ``\"\\n\"`` є односимвольним "
"рядком, що містить новий рядок. Регулярні вирази часто записуються в коді "
"Python з використанням цієї необробленої рядкової нотації."

msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"Крім того, спеціальні керуючі послідовності, дійсні в регулярних виразах, "
"але недійсні як рядкові літерали Python, тепер призводять до :exc:"
"`DeprecationWarning` і згодом стануть :exc:`SyntaxError`, що означає, що "
"послідовності будуть недійсними якщо не використовується необроблений "
"рядковий запис або екранування зворотних скісних риск."

msgid "Regular String"
msgstr "Звичайний рядок"

msgid "Raw string"
msgstr "Необроблений рядок"

msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\розділ\"``"

msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

msgid "Performing Matches"
msgstr "Виконання матчів"

msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"Якщо у вас є об’єкт, що представляє скомпільований регулярний вираз, що ви з "
"ним робите? Об’єкти шаблонів мають кілька методів і атрибутів. Тут будуть "
"розглянуті лише найважливіші з них; зверніться до документів :mod:`re` для "
"отримання повного списку."

msgid "Method/Attribute"
msgstr "Метод/атрибут"

msgid "Purpose"
msgstr "призначення"

msgid "``match()``"
msgstr "``match()``"

msgid "Determine if the RE matches at the beginning of the string."
msgstr "Визначте, чи відповідає RE на початку рядка."

msgid "``search()``"
msgstr "``search()``"

msgid "Scan through a string, looking for any location where this RE matches."
msgstr "Проскануйте рядок, шукаючи будь-яке місце, де цей RE відповідає."

msgid "``findall()``"
msgstr "``findall()``"

msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr ""
"Знайти всі підрядки, де відповідає RE, і повернути їх у вигляді списку."

msgid "``finditer()``"
msgstr "``finditer()``"

msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr ""
"Знайти всі підрядки, де відповідає RE, і повернути їх як :term:`iterator`."

msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` і :meth:`~re.Pattern.search` повертають ``None``, "
"якщо збіг не знайдено. Якщо вони успішні, повертається екземпляр :ref:`match "
"object <match-objects>`, який містить інформацію про збіг: де він "
"починається і закінчується, підрядок, з яким він збігся, тощо."

msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module.  If you have :mod:`tkinter` available, you may also want to look at :"
"source:`Tools/demo/redemo.py`, a demonstration program included with the "
"Python distribution.  It allows you to enter REs and strings, and displays "
"whether the RE matches or fails. :file:`redemo.py` can be quite useful when "
"trying to debug a complicated RE."
msgstr ""
"Ви можете дізнатися про це, інтерактивно поекспериментувавши з модулем :mod:"
"`re`. Якщо у вас є :mod:`tkinter`, ви також можете переглянути :source:"
"`Tools/demo/redemo.py`, демонстраційну програму, що входить до дистрибутива "
"Python. Він дозволяє вводити RE та рядки, а також показує, чи RE збігається "
"чи не відповідає. :file:`redemo.py` може бути дуже корисним при спробі "
"налагодити складне RE."

msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"Цей HOWTO використовує стандартний інтерпретатор Python для своїх прикладів. "
"Спочатку запустіть інтерпретатор Python, імпортуйте модуль :mod:`re` і "
"скомпілюйте RE::"

msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Тепер ви можете спробувати зіставити різні рядки з RE ``[a-z]+``. Порожній "
"рядок взагалі не повинен збігатися, оскільки ``+`` означає 'одне або більше "
"повторень'. :meth:`~re.Pattern.match` має повернути ``None`` у цьому "
"випадку, що призведе до того, що інтерпретатор не друкуватиме вихідні дані. "
"Ви можете явно надрукувати результат :meth:`!match`, щоб це було "
"зрозуміло. ::"

msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"Тепер давайте спробуємо це на рядку, який має збігатися, наприклад "
"``tempo``. У цьому випадку :meth:`~re.Pattern.match` поверне :ref:`об’єкт "
"відповідності <match-objects>`, тому ви повинні зберегти результат у змінній "
"для подальшого використання. ::"

msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"Тепер ви можете запитати :ref:`match object <match-objects>` для отримання "
"інформації про відповідний рядок. Екземпляри об’єктів зіставлення також "
"мають кілька методів і атрибутів; найважливіші з них:"

msgid "``group()``"
msgstr "``group()``"

msgid "Return the string matched by the RE"
msgstr "Повертає рядок, який відповідає RE"

msgid "``start()``"
msgstr "``start()``"

msgid "Return the starting position of the match"
msgstr "Повернути вихідну позицію матчу"

msgid "``end()``"
msgstr "``end()``"

msgid "Return the ending position of the match"
msgstr "Повернення кінцевої позиції матчу"

msgid "``span()``"
msgstr "``span()``"

msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "Повертає кортеж, що містить (початкову, кінцеву) позиції збігу"

msgid "Trying these methods will soon clarify their meaning::"
msgstr "Спроба цих методів незабаром прояснить їх значення:"

msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` повертає підрядок, який був зіставлений RE. :meth:"
"`~re.Match.start` і :meth:`~re.Match.end` повертають початковий і кінцевий "
"індекси збігу. :meth:`~re.Match.span` повертає початковий і кінцевий індекси "
"в одному кортежі. Оскільки метод :meth:`~re.Pattern.match` лише перевіряє, "
"чи відповідає RE на початку рядка, :meth:`!start` завжди дорівнюватиме нулю. "
"Однак метод шаблонів :meth:`~re.Pattern.search` сканує рядок, тому в цьому "
"випадку збіг може не початися з нуля. ::"

msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"У реальних програмах найпоширенішим стилем є збереження :ref:`match object "
"<match-objects>` у змінній, а потім перевірка, чи вона була ``None``. "
"Зазвичай це виглядає так::"

msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"Два методи шаблону повертають усі збіги шаблону. :meth:`~re.Pattern.findall` "
"повертає список відповідних рядків::"

msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"Префікс ``r``, який робить літерал необробленим рядковим літералом, потрібен "
"у цьому прикладі, тому що escape-послідовності у звичайному \"вареному\" "
"рядковому літералі, які не розпізнаються Python, на відміну від регулярних "
"виразів, тепер призводять до :exc:`DeprecationWarning` і з часом стане :exc:"
"`SyntaxError`. Дивіться :ref:`the-backslash-plague`."

msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` має створити весь список, перш ніж його можна "
"буде повернути як результат. Метод :meth:`~re.Pattern.finditer` повертає "
"послідовність екземплярів :ref:`match object <match-objects>` як :term:"
"`iterator`::"

msgid "Module-Level Functions"
msgstr "Функції рівня модуля"

msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Вам не потрібно створювати шаблонний об’єкт і викликати його методи; модуль :"
"mod:`re` також надає функції верхнього рівня під назвою :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` і так далі. Ці "
"функції приймають ті самі аргументи, що й відповідний метод шаблону з рядком "
"RE, доданим як перший аргумент, і все одно повертають ``None`` або "
"екземпляр :ref:`match object <match-objects>`. ::"

msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"Під капотом ці функції просто створюють для вас шаблонний об’єкт і "
"викликають для нього відповідний метод. Вони також зберігають скомпільований "
"об’єкт у кеш-пам’яті, тому для майбутніх викликів із використанням того "
"самого RE не потрібно буде аналізувати шаблон знову і знову."

msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Ви повинні використовувати ці функції на рівні модуля, чи вам слід отримати "
"шаблон і викликати його методи самостійно? Якщо ви отримуєте доступ до "
"регулярного виразу в циклі, його попередня компіляція заощадить кілька "
"викликів функцій. За межами циклів немає великої різниці завдяки "
"внутрішньому кешу."

msgid "Compilation Flags"
msgstr "Прапори компіляції"

msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"Прапори компіляції дозволяють змінювати деякі аспекти роботи регулярних "
"виразів. Прапори доступні в модулі :mod:`re` під двома назвами: довгою "
"назвою, як-от :const:`IGNORECASE`, і короткою однолітерною формою, як-от :"
"const:`I`. (Якщо ви знайомі з модифікаторами шаблонів Perl, однолітерні "
"форми використовують ті самі літери; наприклад, коротка форма :const:`re."
"VERBOSE` це :const:`re.X`.) Кілька прапорів можуть вказувати їх порозрядним "
"АБО; ``re.I | re.M`` встановлює, наприклад, прапорці :const:`I` і :const:`M`."

msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Ось таблиця доступних прапорів із більш детальним поясненням кожного з них."

msgid "Flag"
msgstr "Прапор"

msgid "Meaning"
msgstr "Значення"

msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Декілька символів екранування, як-от ``\\w``, ``\\b``, ``\\s`` і ``\\d``, "
"збігаються лише з символами ASCII з відповідною властивістю."

msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

msgid "Make ``.`` match any character, including newlines."
msgstr ""
"Зробіть \".\" відповідним будь-якому символу, включно з новими рядками."

msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

msgid "Do case-insensitive matches."
msgstr "Збіги без урахування регістру."

msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

msgid "Do a locale-aware match."
msgstr "Виконайте відповідність з урахуванням локалі."

msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "Багаторядкова відповідність, що впливає на ``^`` і ``$``."

msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` (для \"розширеного\")"

msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Увімкніть докладні RE, які можна організувати більш чітко та зрозуміло."

msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: "
"'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin "
"small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This "
"lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Виконуйте зіставлення без урахування регістру; клас символів і літеральні "
"рядки будуть відповідати буквам, ігноруючи регістр. Наприклад, ``[A-Z]`` "
"також відповідатиме малим регістрам. Повна відповідність Unicode також "
"працює, якщо не використовується прапорець :const:`ASCII`, щоб вимкнути "
"збіги, відмінні від ASCII. Коли шаблони Unicode ``[a-z]`` або ``[A-Z]`` "
"використовуються в поєднанні з прапором :const:`IGNORECASE`, вони "
"відповідатимуть 52 літерам ASCII і 4 додатковим літерам, які не належать до "
"ASCII: 'İ ' (U+0130, латинська велика літера I з крапкою вгорі), "
"'ı' (U+0131, латинська мала літера без крапки), 'ſ' (U+017F, латинська мала "
"літера довге s) і 'K' (U +212A, знак Кельвіна). ``Spam`` відповідатиме "
"``'Spam'``, ``'spam'``, ``'spAM'`` або ``'ſpam'`` (останній збігається лише "
"в режимі Unicode). Цей нижній регістр не враховує поточну мову; це буде, "
"якщо ви також установите прапорець :const:`LOCALE`."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Зробіть ``\\w``, ``\\W``, ``\\b``, ``\\B`` і відповідність без урахування "
"регістру залежною від поточної мови замість бази даних Unicode."

msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Локалі — це функція бібліотеки C, призначена для допомоги в написанні "
"програм, які враховують мовні відмінності. Наприклад, якщо ви обробляєте "
"закодований французький текст, ви б хотіли мати можливість писати ``\\w+`` "
"для відповідності слів, але ``\\w`` відповідає лише класу символів ``[A-Za- "
"z]`` у шаблонах байтів; він не співпадатиме з байтами, що відповідають ``é`` "
"або ``ç``. Якщо ваша система налаштована належним чином і вибрано французьку "
"мову, певні функції C повідомлять програмі, що байт, який відповідає ``é``, "
"також слід вважати літерою. Встановлення прапорця :const:`LOCALE` під час "
"компіляції регулярного виразу змусить отриманий скомпільований об’єкт "
"використовувати ці функції C для ``\\w``; це повільніше, але також дозволяє "
"``\\w+`` відповідати французьким словам, як ви очікуєте. Використання цього "
"прапора не рекомендується в Python 3, оскільки механізм локалізації дуже "
"ненадійний, він обробляє лише одну \"культуру\" за раз і працює лише з 8-"
"бітними локалями. Зіставлення Unicode вже ввімкнено за замовчуванням у "
"Python 3 для шаблонів Unicode (str), і він здатний обробляти різні локалі/"
"мови."

msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` і ``$`` ще не пояснено; їх буде введено в розділі :ref:`more-"
"metacharacters`.)"

msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Зазвичай ``^`` збігається лише на початку рядка, а ``$`` збігається лише в "
"кінці рядка та безпосередньо перед символом нового рядка (якщо є) у кінці "
"рядка. Якщо вказано цей прапорець, ``^`` збігається на початку рядка та на "
"початку кожного рядка в рядку, відразу після кожного нового рядка. Подібним "
"чином, метасимвол ``$`` збігається або в кінці рядка, і в кінці кожного "
"рядка (безпосередньо перед кожним новим рядком)."

msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Робить спеціальний символ `''.''` відповідним будь-якому символу взагалі, "
"включно з символом нового рядка; без цього прапорця `''.''` відповідатиме "
"будь-чому *крім* нового рядка."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Змусити ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` і ``\\S`` виконувати "
"відповідність лише ASCII замість повної Зіставлення Unicode. Це має значення "
"лише для шаблонів Unicode та ігнорується для шаблонів байтів."

msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Цей прапорець дозволяє вам писати регулярні вирази, які є більш "
"читабельними, надаючи вам більше гнучкості у тому, як ви можете їх "
"форматувати. Якщо вказано цей прапорець, пробіли в рядку RE ігноруються, за "
"винятком випадків, коли пробіли знаходяться в класі символів або перед ними "
"стоїть неекранована зворотна похила риска; це дозволяє більш чітко "
"організувати та зробити відступи RE. Цей прапор також дозволяє розміщувати "
"коментарі в RE, які ігноруватимуться механізмом; коментарі позначаються "
"символом ``'#'``, якого немає в класі символів або якому передує "
"неекранований зворотний слеш."

msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Наприклад, ось RE, який використовує :const:`re.VERBOSE`; бачите, наскільки "
"легше читати? ::"

msgid "Without the verbose setting, the RE would look like this::"
msgstr "Без параметра verbose RE виглядатиме так:"

msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"У наведеному вище прикладі автоматичне об’єднання рядкових літералів Python "
"було використано для розбиття RE на менші частини, але це все ще важче "
"зрозуміти, ніж версію з використанням :const:`re.VERBOSE`."

msgid "More Pattern Power"
msgstr "Більше потужності шаблону"

msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"Поки що ми розглянули лише частину функцій регулярних виразів. У цьому "
"розділі ми розглянемо деякі нові метасимволи, а також те, як використовувати "
"групи для отримання частин тексту, які збігаються."

msgid "More Metacharacters"
msgstr "Більше метасимволів"

msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Є деякі метасимволи, які ми ще не розглянули. Більшість із них буде "
"розглянуто в цьому розділі."

msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Деякі метасимволи, які залишилися для обговорення, це :dfn:`затвердження "
"нульової ширини`. Вони не змушують двигун просуватися по струні; натомість "
"вони взагалі не використовують жодних символів і просто досягають успіху або "
"зазнають невдачі. Наприклад, ``\\b`` - це твердження, що поточна позиція "
"розташована на межі слова; позиція взагалі не змінюється ``\\b``. Це "
"означає, що твердження нульової ширини ніколи не повинні повторюватися, "
"оскільки якщо вони збігаються один раз у заданому місці, вони, очевидно, "
"можуть бути зіставлені нескінченну кількість разів."

msgid "``|``"
msgstr "``|``"

msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Чергування або оператор \"або\". Якщо *A* і *B* є регулярними виразами, ``A|"
"B`` відповідатиме будь-якому рядку, який відповідає *A* або *B*. ``|`` має "
"дуже низький пріоритет, щоб він працював розумно, коли ви чергуєте "
"багатосимвольні рядки. ``Crow|Servo`` відповідатиме ``'Crow'`` або "
"``'Servo'``, а не ``'Cro'``, ``'w'`` чи ``'S'`` і ``'ervo''``."

msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Щоб відповідати літералу ``'|'``, використовуйте ``\\|`` або вкладіть його в "
"клас символів, як у ``[|]``."

msgid "``^``"
msgstr "``^``"

msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"Збіги на початку рядків. Якщо не встановлено прапорець :const:`MULTILINE`, "
"він збігатиметься лише на початку рядка. У режимі :const:`MULTILINE` це "
"також збігається відразу після кожного нового рядка в рядку."

msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"Наприклад, якщо ви бажаєте зіставити слово ``From`` лише на початку рядка, "
"використовуйте RE ``^From``. ::"

msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Щоб відповідати літералу ``'^'``, використовуйте ``\\^``."

msgid "``$``"
msgstr "``$``"

msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Збігається в кінці рядка, який визначається як кінець рядка або будь-яке "
"місце, після якого йде символ нового рядка. ::"

msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Щоб відповідати літералу ``'$'``, використовуйте ``\\$`` або вкладіть його в "
"клас символів, як у ``[$]``."

msgid "``\\A``"
msgstr "``\\A``"

msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"Збігається лише на початку рядка. Якщо не в режимі :const:`MULTILINE`, "
"``\\A`` і ``^`` фактично однакові. У режимі :const:`MULTILINE` вони "
"відрізняються: ``\\A`` все ще збігається лише на початку рядка, але ``^`` "
"може збігатися в будь-якому місці всередині рядка, яке слідує за символом "
"нового рядка."

msgid "``\\Z``"
msgstr "``\\Z``"

msgid "Matches only at the end of the string."
msgstr "Збігається лише в кінці рядка."

msgid "``\\b``"
msgstr "``\\b``"

msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Кордон слова. Це твердження нульової ширини, яке збігається лише на початку "
"або в кінці слова. Слово визначається як послідовність буквено-цифрових "
"символів, тому кінець слова позначається пробілом або неалфавітно-цифровим "
"символом."

msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"Наступний приклад відповідає ``класу`` лише тоді, коли це повне слово; воно "
"не збігається, якщо міститься всередині іншого слова. ::"

msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"Використовуючи цю особливу послідовність, слід пам’ятати про дві тонкощі. По-"
"перше, це найгірша колізія між рядковими літералами Python і послідовностями "
"регулярних виразів. У рядкових літералах Python ``\\b`` є символом "
"повернення, значення ASCII 8. Якщо ви не використовуєте необроблені рядки, "
"тоді Python перетворить ``\\b`` на пропуск, а ваш RE не буде відповідати, як "
"ви очікуєте. Наступний приклад виглядає так само, як наш попередній RE, але "
"опущено ``'r'`` перед рядком RE. ::"

msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"По-друге, всередині класу символів, де немає користі для цього твердження, "
"``\\b`` представляє символ зворотного простору для сумісності з рядковими "
"літералами Python."

msgid "``\\B``"
msgstr "``\\B``"

msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"Інше твердження нульової ширини, це протилежність ``\\b``, збігається лише "
"тоді, коли поточна позиція не знаходиться на межі слова."

msgid "Grouping"
msgstr "Групування"

msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Часто вам потрібно отримати більше інформації, ніж просто відповідність RE "
"чи ні. Регулярні вирази часто використовуються для аналізу рядків шляхом "
"запису RE, розділеного на кілька підгруп, які відповідають різним цікавим "
"компонентам. Наприклад, рядок заголовка RFC-822 розділено на ім’я заголовка "
"та значення, розділені символом ``':'``, ось так:"

msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Це можна вирішити, написавши регулярний вираз, який відповідає всьому рядку "
"заголовка та має одну групу, яка відповідає імені заголовка, та іншу групу, "
"яка відповідає значенню заголовка."

msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a repeating qualifier, such as ``*``, "
"``+``, ``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""

msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"Групи, позначені ``'('``, ``')'`` також фіксують початковий і кінцевий "
"індекс тексту, якому вони відповідають; це можна отримати, передавши "
"аргумент до :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end` і :meth:`~re.Match.span`. Групи нумеруються, починаючи з 0. Група "
"0 завжди присутня; це весь RE, тому всі методи :ref:`match object <match-"
"objects>` мають групу 0 як аргумент за замовчуванням. Пізніше ми побачимо, "
"як виражати групи, які не фіксують діапазон тексту, якому вони "
"відповідають. ::"

msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Підгрупи нумеруються зліва направо, починаючи з 1 і вище. Групи можуть бути "
"вкладеними; щоб визначити число, просто порахуйте символи відкриваючих "
"дужок, рухаючись зліва направо. ::"

msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` можна передати кілька номерів груп одночасно, і в "
"цьому випадку він поверне кортеж, що містить відповідні значення для цих "
"груп. ::"

msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"Метод :meth:`~re.Match.groups` повертає кортеж, що містить рядки для всіх "
"підгруп, від 1 до будь-якої кількості. ::"

msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Зворотні посилання в шаблоні дозволяють вказати, що вміст попередньої групи "
"захоплення також має бути знайдений у поточному місці в рядку. Наприклад, "
"``\\1`` буде успішним, якщо точний вміст групи 1 можна знайти в поточній "
"позиції, і не вдасться в іншому випадку. Пам’ятайте, що рядкові літерали "
"Python також використовують зворотну скісну риску, за якою слідують числа, "
"щоб дозволити включати довільні символи в рядок, тому обов’язково "
"використовуйте необроблений рядок, коли включаєте зворотні посилання в RE."

msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "Наприклад, наступний RE виявляє подвоєні слова в рядку. ::"

msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Подібні зворотні посилання не часто корисні лише для пошуку в рядку --- є "
"кілька текстових форматів, які повторюють дані таким чином --- але незабаром "
"ви зрозумієте, що вони *дуже* корисні під час виконання замін рядків ."

msgid "Non-capturing and Named Groups"
msgstr "Неперехоплювані та іменовані групи"

msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"Розроблені RE можуть використовувати багато груп як для захоплення цікавих "
"підрядків, так і для групування та структурування самого RE. У складних RE "
"стає важко відслідковувати номери груп. Є дві функції, які допомагають "
"вирішити цю проблему. Обидва вони використовують загальний синтаксис для "
"розширень регулярних виразів, тому ми розглянемо це спочатку."

msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 добре відомий своїми потужними доповненнями до стандартних регулярних "
"виразів. Для цих нових можливостей розробники Perl не могли вибрати нові "
"одноклавішні метасимволи або нові спеціальні послідовності, що починаються з "
"``\\``, не зробивши регулярні вирази Perl різко відмінними від стандартних "
"RE. Наприклад, якби вони вибрали ``&`` як новий метасимвол, старі вирази "
"припускали б, що ``&`` був звичайним символом і не міг би уникнути його, "
"написавши ``\\&`` або ``[ &]``."

msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Рішенням, обраним розробниками Perl, було використання ``(?...)`` як "
"синтаксису розширення. ``?`` відразу після дужок було синтаксичною помилкою, "
"оскільки ``?`` не було б чого повторювати, тому це не створювало жодних "
"проблем із сумісністю. Символи відразу після ``?`` вказують на те, яке "
"розширення використовується, тому ``(?=foo)`` це одне (позитивне твердження "
"попереднього перегляду), а ``(?:foo)`` це щось інше ( група без захоплення, "
"що містить підвираз ``foo``)."

msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python підтримує кілька розширень Perl і додає синтаксис розширення до "
"синтаксису розширення Perl. Якщо першим символом після знака питання є "
"``P``, ви знаєте, що це розширення, специфічне для Python."

msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Тепер, коли ми розглянули загальний синтаксис розширення, ми можемо "
"повернутися до функцій, які спрощують роботу з групами в складних RE."

msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Іноді вам потрібно використати групу для позначення частини регулярного "
"виразу, але ви не зацікавлені в отриманні вмісту групи. Ви можете зробити "
"цей факт явним, використовуючи групу без захоплення: ``(?:...)``, де ви "
"можете замінити ``...`` будь-яким іншим регулярним виразом. ::"

msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"За винятком того факту, що ви не можете отримати вміст того, що відповідає "
"групі, група без захоплення поводиться точно так само, як група захоплення; "
"ви можете помістити в нього що завгодно, повторити це з метасимволом "
"повторення, таким як ``*``, і вкладати його в інші групи (захоплюючі чи "
"незахоплюючі). ``(?:...)`` особливо корисний під час зміни існуючого "
"шаблону, оскільки ви можете додавати нові групи, не змінюючи спосіб "
"нумерації всіх інших груп. Слід зазначити, що немає різниці в продуктивності "
"пошуку між групами захоплення та групами без захоплення; жодна форма не є "
"швидшою за іншу."

msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"Більш важливою особливістю є іменовані групи: замість того, щоб посилатися "
"на них номерами, на групи можна посилатися за назвою."

msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"Синтаксис іменованої групи є одним із специфічних для Python розширень: ``(?"
"P <name> ...)``. *name* — це, очевидно, назва групи. Іменовані групи "
"поводяться так само, як групи захоплення, і додатково пов’язують назву з "
"групою. Усі методи :ref:`match object <match-objects>`, які мають справу із "
"захопленням груп, приймають або цілі числа, які посилаються на групу за "
"номером, або рядки, які містять назву потрібної групи. Іменовані групи все "
"ще мають номери, тому ви можете отримати інформацію про групу двома "
"способами:"

msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"Крім того, ви можете отримати іменовані групи як словник за допомогою :meth:"
"`~re.Match.groupdict`::"

msgid ""
"Named groups are handy because they let you use easily-remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"Іменовані групи зручні, оскільки вони дозволяють використовувати імена, які "
"легко запам’ятовуються, замість того, щоб запам’ятовувати числа. Ось приклад "
"RE з модуля :mod:`imaplib`::"

msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"Очевидно, набагато простіше отримати ``m.group('zonem')``, замість того, щоб "
"пам'ятати, що потрібно отримати групу 9."

msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"Синтаксис зворотних посилань у такому виразі, як ``(...)\\1``, посилається "
"на номер групи. Природно, існує варіант, який використовує назву групи "
"замість номера. Це ще одне розширення Python: ``(?P=name)`` вказує на те, що "
"вміст групи з назвою *name* знову повинен бути зіставлений у поточній точці. "
"Регулярний вираз для пошуку подвоєних слів ``\\b(\\w+)\\s+\\1\\b`` також "
"можна записати як ``\\b(?P <word> \\w+)\\s+(?P=слово)\\b``::"

msgid "Lookahead Assertions"
msgstr "Попередні твердження"

msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Іншим твердженням нульової ширини є твердження прогнозу. Попередні "
"твердження доступні як у позитивній, так і в негативній формі та виглядають "
"так:"

msgid "``(?=...)``"
msgstr "``(?=...)``"

msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Позитивне прогнозне твердження. Це виконується успішно, якщо регулярний "
"вираз, представлений тут ``...``, успішно збігається в поточному місці, і не "
"вдається в іншому випадку. Але після спроби виразу, що міститься, механізм "
"пошуку відповідностей взагалі не переходить; решта шаблону пробується там, "
"де почалося твердження."

msgid "``(?!...)``"
msgstr "``(?!...)``"

msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Негативне прогнозне твердження. Це протилежне до позитивного твердження; це "
"вдається, якщо вираз, що міститься, *не* збігається з поточною позицією в "
"рядку."

msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"Щоб зробити це конкретним, давайте подивимося на випадок, де корисний погляд "
"наперед. Розглянемо простий шаблон для відповідності назві файлу та "
"розділення його на базове ім’я та розширення, розділені символом ``.``. "
"Наприклад, у ``news.rc`` ``news`` є базовою назвою, а ``rc`` є розширенням "
"назви файлу."

msgid "The pattern to match this is quite simple:"
msgstr "Викрійка для цього досить проста:"

msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Зауважте, що ``.`` потрібно обробляти спеціально, оскільки це метасимвол, "
"тому він знаходиться всередині класу символів, щоб відповідати лише цьому "
"конкретному символу. Також зверніть увагу на закінчення ``$``; це додається, "
"щоб переконатися, що вся решта рядка повинна бути включена в розширення. Цей "
"регулярний вираз відповідає ``foo.bar`` і ``autoexec.bat``, ``sendmail.cf`` "
"і ``printers.conf``."

msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Тепер подумайте про те, щоб трохи ускладнити проблему; що, якщо ви хочете "
"зіставити назви файлів, розширення яких не є ``bat``? Деякі неправильні "
"спроби:"

msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is "
"wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` Перша спроба вище намагається виключити ``bat``, вимагаючи, "
"щоб перший символ розширення не був ``b``. Це неправильно, оскільки шаблон "
"також не відповідає ``foo.bar``."

msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"Вираз стає складнішим, коли ви намагаєтеся виправити перше рішення, "
"вимагаючи збігу одного з наступних випадків: перший символ розширення не є "
"``b``; другий символ не є ``a``; або третій символ не є ``t``. Це приймає "
"``foo.bar`` і відхиляє ``autoexec.bat``, але воно вимагає розширення з трьох "
"літер і не приймає ім’я файлу з дволітерним розширенням, наприклад "
"``sendmail.cf``. Ми знову ускладнимо шаблон, намагаючись його виправити."

msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"Під час третьої спроби друга та третя літери стають необов’язковими, щоб "
"дозволити відповідні розширення коротші за три символи, наприклад ``sendmail."
"cf``."

msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Зараз шаблон стає дуже складним, тому його важко прочитати та зрозуміти. "
"Гірше того, якщо проблема зміниться і ви захочете виключити і ``bat``, і "
"``exe`` як розширення, шаблон стане ще більш складним і заплутаним."

msgid "A negative lookahead cuts through all this confusion:"
msgstr "Негативний прогноз прорізає всю цю плутанину:"

msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension "
"only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` Негативний перегляд означає: якщо вираз ``bat`` не "
"збігається на цьому етапі, спробуйте решту шаблону; якщо ``bat$`` "
"збігається, весь шаблон буде невдалим. Кінцевий ``$`` потрібен, щоб "
"переконатися, що щось на зразок ``sample.batch``, де розширення починається "
"лише з ``bat``, буде дозволено. ``[^.]*`` гарантує, що шаблон працює, якщо в "
"назві файлу є кілька крапок."

msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Виключити інше розширення імені файлу тепер легко; просто додайте його як "
"альтернативу всередину твердження. Наступний шаблон виключає імена файлів, "
"які закінчуються на ``bat`` або ``exe``:"

msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

msgid "Modifying Strings"
msgstr "Зміна рядків"

msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"До цього моменту ми просто виконували пошук у статичному рядку. Регулярні "
"вирази також часто використовуються для зміни рядків різними способами, "
"використовуючи такі методи шаблонів:"

msgid "``split()``"
msgstr "``split()``"

msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "Розділіть рядок на список, розділивши його там, де відповідає RE"

msgid "``sub()``"
msgstr "``sub()``"

msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr "Знайдіть усі підрядки, де відповідає RE, і замініть їх іншим рядком"

msgid "``subn()``"
msgstr "``subn()``"

msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Робить те саме, що :meth:`!sub`, але повертає новий рядок і кількість замін"

msgid "Splitting Strings"
msgstr "Розбиття рядків"

msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"Метод шаблону :meth:`~re.Pattern.split` розділяє рядок на частини, де "
"збігається RE, повертаючи список фрагментів. Він подібний до методу рядків :"
"meth:`~str.split`, але надає набагато більшу загальність роздільників, за "
"якими можна розділяти; string :meth:`!split` підтримує лише поділ за "
"пробілами або за фіксованим рядком. Як і слід було очікувати, також існує "
"функція :func:`re.split` на рівні модуля."

msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Розділити *рядок* за збігами регулярного виразу. Якщо в RE використовуються "
"круглі дужки, їхній вміст також повертатиметься як частина результуючого "
"списку. Якщо *maxsplit* відмінний від нуля, виконується не більше ніж "
"*maxsplit*."

msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Ви можете обмежити кількість зроблених поділів, передавши значення "
"*maxsplit*. Якщо *maxsplit* відмінний від нуля, буде виконано щонайбільше "
"*maxsplit* розбиття, а залишок рядка повертається як останній елемент "
"списку. У наступному прикладі роздільником є будь-яка послідовність не "
"буквено-цифрових символів. ::"

msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Іноді вам не тільки цікаво, що таке текст між роздільниками, а й потрібно "
"знати, що це за роздільник. Якщо в RE використовуються круглі дужки, їх "
"значення також повертаються як частина списку. Порівняйте наступні виклики:"

msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"Функція рівня модуля :func:`re.split` додає RE, який буде використовуватися "
"як перший аргумент, але в іншому вона така сама. ::"

msgid "Search and Replace"
msgstr "Пошук і заміна"

msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"Ще одне поширене завдання — знайти всі збіги для шаблону та замінити їх "
"іншим рядком. Метод :meth:`~re.Pattern.sub` приймає значення заміни, яке "
"може бути або рядком, або функцією, і рядок, який потрібно обробити."

msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Повертає рядок, отриманий шляхом заміни крайніх лівих неперекриваючих "
"входжень RE в *рядку* на заміну *replacement*. Якщо шаблон не знайдено, "
"*рядок* повертається без змін."

msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"Необов’язковий аргумент *count* — це максимальна кількість шаблонів, які "
"потрібно замінити; *count* має бути невід’ємним цілим числом. Значення за "
"замовчуванням 0 означає заміну всіх входжень."

msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Ось простий приклад використання методу :meth:`~re.Pattern.sub`. Він замінює "
"назви кольорів словом ``колір``::"

msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
"Метод :meth:`~re.Pattern.subn` виконує ту саму роботу, але повертає 2-"
"кортеж, що містить нове значення рядка та кількість виконаних замін:"

msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Порожні збіги замінюються лише тоді, коли вони не суміжні з попереднім "
"порожнім збігом. ::"

msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Якщо *replacement* є рядком, будь-які вихідні символи зворотної косої риски "
"в ньому обробляються. Тобто ``\\n`` перетворюється на один символ нового "
"рядка, ``\\r`` перетворюється на повернення каретки і так далі. Невідомі "
"вихідні коди, такі як ``\\&`` залишаються в спокої. Зворотні посилання, такі "
"як ``\\6``, замінюються підрядком, який відповідає відповідній групі в RE. "
"Це дає змогу включати частини вихідного тексту в отриманий рядок заміни."

msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Цей приклад відповідає слову ``розділ``, за яким слідує рядок, укладений у "
"``{``, ``}``, і змінює ``розділ`` на ``підрозділ``::"

msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"Існує також синтаксис для посилань на іменовані групи, як визначено "
"синтаксисом ``(?P <name> ...)``. ``\\g <name>`` використовуватиме підрядок, "
"який відповідає групі з назвою ``name``, а ``\\g <number>`` використовує "
"відповідний номер групи. ``\\g <2>``, отже, еквівалентний ``\\2``, але не є "
"неоднозначним у рядку заміни, такому як ``\\g <2> 0``. (``\\20`` буде "
"інтерпретуватися як посилання на групу 20, а не як посилання на групу 2, за "
"якою йде літеральний символ ``'0''``.) Усі наступні заміни еквівалентні, але "
"використовують усі три варіанти рядок заміни. ::"

msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"*заміна* також може бути функцією, яка дає вам ще більше контролю. Якщо "
"*replacement* є функцією, функція викликається для кожного неперекриваючого "
"входження *pattern*. Під час кожного виклику функції передається аргумент :"
"ref:`match object <match-objects>` для відповідності, і ця інформація може "
"використовуватися для обчислення потрібного рядка заміни та повернення його."

msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"У наступному прикладі функція заміни перетворює десяткові числа в "
"шістнадцяткові:"

msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"Під час використання функції :func:`re.sub` на рівні модуля шаблон "
"передається як перший аргумент. Шаблон може бути наданий як об'єкт або як "
"рядок; якщо вам потрібно вказати прапорці регулярного виразу, ви повинні або "
"використовувати об’єкт шаблону як перший параметр, або використати вбудовані "
"модифікатори в рядок шаблону, напр. ``sub(\"(?i)b+\", \"x\", \"bbbb "
"BBBB\")`` повертає ``'x x''``."

msgid "Common Problems"
msgstr "Загальні проблеми"

msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"Регулярні вирази є потужним інструментом для деяких програм, але в певному "
"сенсі їх поведінка не є інтуїтивно зрозумілою, а іноді вони поводяться не "
"так, як ви від них можете очікувати. У цьому розділі буде вказано на деякі з "
"найпоширеніших пасток."

msgid "Use String Methods"
msgstr "Використовуйте рядкові методи"

msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"Іноді використання модуля :mod:`re` є помилкою. Якщо ви зіставляєте "
"фіксований рядок або одиничний клас символів і не використовуєте жодних "
"функцій :mod:`re`, таких як прапор :const:`~re.IGNORECASE`, тоді повна "
"потужність регулярних виразів може не знадобитися. Рядки мають кілька "
"методів для виконання операцій із фіксованими рядками, і зазвичай вони "
"набагато швидші, оскільки реалізація являє собою один маленький цикл C, "
"оптимізований для цієї мети, замість великого, більш узагальненого механізму "
"регулярних виразів."

msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"Одним із прикладів може бути заміна одного фіксованого рядка іншим; "
"наприклад, ви можете замінити ``слово`` на ``справа``. :func:`re.sub` "
"здається функцією для цього, але розгляньте метод :meth:`~str.replace`. "
"Зауважте, що :meth:`!replace` також замінить ``word`` всередині слів, "
"перетворивши ``swordfish`` на ``sdeedfish``, але наївний RE ``word`` також "
"зробив би це. (Щоб уникнути виконання заміни на частинах слів, шаблон має "
"бути ``\\bword\\b``, щоб вимагати, щоб ``слово`` мало межу слова з обох "
"боків. Це виводить роботу за межі :meth:`!replace`.)"

msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"Інше поширене завдання — видалення кожного входження одного символу з рядка "
"або заміна його іншим окремим символом. Ви можете зробити це за допомогою "
"чогось на зразок ``re.sub('\\n', ' ', S)``, але :meth:`~str.translate` "
"здатний виконувати обидва завдання та буде швидшим за будь-який регулярний "
"вираз операція може бути."

msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Коротше кажучи, перш ніж звернутися до модуля :mod:`re`, подумайте, чи можна "
"вирішити вашу проблему швидшим і простішим методом рядка."

msgid "match() versus search()"
msgstr "match() проти search()"

msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"Функція :func:`~re.match` лише перевіряє, чи RE збігається на початку рядка, "
"тоді як :func:`~re.search` скануватиме рядок вперед у пошуках відповідності. "
"Важливо пам’ятати про цю відмінність. Пам’ятайте, :func:`!match` "
"повідомлятиме лише про успішний збіг, який розпочнеться з 0; якщо збіг не "
"починається з нуля, :func:`!match` *не* повідомить про це. ::"

msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"З іншого боку, :func:`~re.search` скануватиме рядок вперед, повідомляючи про "
"перший знайдений збіг. ::"

msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"Іноді у вас виникне спокуса продовжувати використовувати :func:`re.match` і "
"просто додати ``.*`` на початку вашого RE. Утримайтесь від цієї спокуси та "
"використовуйте замість цього :func:`re.search`. Компілятор регулярних "
"виразів виконує деякий аналіз RE, щоб прискорити процес пошуку "
"відповідності. Один такий аналіз визначає, яким повинен бути перший символ "
"відповідності; наприклад, шаблон, що починається з ``Crow``, повинен "
"збігатися з ``'C``. Аналіз дозволяє механізму швидко сканувати рядок у "
"пошуках початкового символу, лише намагаючись знайти повну відповідність, "
"якщо знайдено ``'C'``."

msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Додавання ``.*`` руйнує цю оптимізацію, вимагаючи сканування до кінця рядка, "
"а потім повернення назад, щоб знайти збіг для решти RE. Натомість "
"використовуйте :func:`re.search`."

msgid "Greedy versus Non-Greedy"
msgstr "Жадібний проти нежадібного"

msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"Під час повторення регулярного виразу, як у ``a*``, результуюча дія полягає "
"в споживанні якомога більшої частини шаблону. Цей факт часто кусає вас, коли "
"ви намагаєтеся зіставити пару збалансованих розділювачів, таких як кутові "
"дужки, що оточують тег HTML. Наївний шаблон для відповідності одному тегу "
"HTML не працює через жадібний характер ``.*``. ::"

msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"RE відповідає ``'<'`` in ``'<html>'``, а ``.*`` займає решту рядка. Однак у "
"RE залишилося ще більше, і ``>`` не може збігатися в кінці рядка, тому "
"система регулярних виразів має відстежувати символ за символом, поки не "
"знайде відповідність ``>``. Фінальний збіг поширюється від ``' <'`` in "
"``'<html> ''`` до ``'>''`` в ``' </title> ''``, що не те, чого ви хочете."

msgid ""
"In this case, the solution is to use the non-greedy qualifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""

msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(Зауважте, що синтаксичний аналіз HTML або XML за допомогою регулярних "
"виразів є болючим. Швидкі та брудні шаблони впораються з типовими випадками, "
"але HTML і XML мають особливі випадки, які порушують очевидний регулярний "
"вираз; коли ви напишете регулярний вираз, обробляє всі можливі випадки, "
"шаблони будуть *дуже* складними. Для таких завдань використовуйте модуль "
"аналізатора HTML або XML.)"

msgid "Using re.VERBOSE"
msgstr "Використання re.VERBOSE"

msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"Наразі ви, напевно, помітили, що регулярні вирази є дуже компактним записом, "
"але їх не дуже добре читати. RE помірної складності можуть перетворитися на "
"довгі набори зворотних скісних риск, круглих дужок і метасимволів, що "
"ускладнює їх читання та розуміння."

msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"Для таких RE вказівка прапорця :const:`re.VERBOSE` під час компіляції "
"регулярного виразу може бути корисною, оскільки це дозволяє форматувати "
"регулярний вираз більш чітко."

msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"Прапор ``re.VERBOSE`` має кілька ефектів. Пробіли в регулярному виразі, яких "
"*не* всередині класу символів, ігноруються. Це означає, що такий вираз, як "
"``собака | cat`` еквівалентний менш читабельному ``dog|cat``, але ``[a b]`` "
"все одно відповідатиме символам ``'a'``, ``'b'`` або пробілу. Крім того, ви "
"також можете розмістити коментарі всередині RE; коментарі поширюються від "
"символу ``#`` до наступного нового рядка. При використанні з рядками в "
"потрійних лапках це дає змогу форматувати RE більш акуратно::"

msgid "This is far more readable than::"
msgstr "Це набагато читабельніше, ніж:"

msgid "Feedback"
msgstr "Зворотній зв'язок"

msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Регулярні вирази – це складна тема. Чи допоміг вам цей документ зрозуміти "
"їх? Чи були частини, які були незрозумілими, або проблеми, з якими ви "
"зіткнулися, які не були розглянуті тут? Якщо так, будь ласка, надішліть "
"пропозиції щодо покращення автору."

msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"Найповнішою книгою про регулярні вирази майже напевно є \"Опанування "
"регулярних виразів\" Джеффрі Фрідла, опублікована O'Reilly. На жаль, він "
"зосереджений виключно на стилях регулярних виразів Perl і Java і взагалі не "
"містить жодного матеріалу Python, тому він не буде корисним як довідник для "
"програмування на Python. (Перше видання охоплювало видалений модуль Python :"
"mod:`!regex`, який вам не дуже допоможе.) Подумайте про те, щоб перевірити "
"його у своїй бібліотеці."
