# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "Регулярний вираз HOWTO"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rst-1
msgid "Abstract"
msgstr "Анотація"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Цей документ є вступним посібником із використання регулярних виразів у "
"Python із модулем :mod:`re`. Він містить більш лагідний вступ, ніж "
"відповідний розділ довідника бібліотеки."

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "Вступ"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Регулярні вирази (так звані RE, або регулярні вирази, або шаблони регулярних"
" виразів) — це, по суті, крихітна вузькоспеціалізована мова програмування, "
"вбудована в Python і доступна через модуль :mod:`re`. Використовуючи цю "
"маленьку мову, ви визначаєте правила для набору можливих рядків, які ви "
"хочете зіставити; цей набір може містити англійські речення, або адреси "
"електронної пошти, або команди TeX, або будь-що, що вам подобається. Потім "
"ви можете поставити такі запитання, як \"Чи відповідає цей рядок шаблону?\" "
"або \"Чи є відповідність шаблону десь у цьому рядку?\". Ви також можете "
"використовувати RE, щоб змінити рядок або розділити його різними способами."

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Шаблони регулярних виразів компілюються в серію байт-кодів, які потім "
"виконуються механізмом відповідності, написаним мовою C. Для розширеного "
"використання може знадобитися звернути особливу увагу на те, як механізм "
"виконуватиме заданий RE, і записати RE у певним чином, щоб створити байт-"
"код, який працює швидше. Оптимізація не розглядається в цьому документі, "
"оскільки вона вимагає, щоб ви добре розуміли внутрішні механізми "
"відповідності."

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions."
"  There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"Мова регулярних виразів є відносно невеликою та обмеженою, тому не всі "
"можливі завдання обробки рядків можна виконати за допомогою регулярних "
"виразів. Також є завдання, які *можна* виконувати регулярними виразами, але "
"вирази виявляються дуже складними. У цих випадках вам може бути краще "
"написати код Python для виконання обробки; Хоча код Python буде повільнішим,"
" ніж складний регулярний вираз, він також, ймовірно, буде більш зрозумілим."

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "Прості візерунки"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Ми почнемо з вивчення найпростіших регулярних виразів. Оскільки регулярні "
"вирази використовуються для роботи з рядками, ми почнемо з найпоширенішого "
"завдання: зіставлення символів."

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"Для детального пояснення інформатики, що лежить в основі регулярних виразів "
"(детермінованих і недетермінованих кінцевих автоматів), ви можете звернутися"
" до майже будь-якого підручника з написання компіляторів."

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "Відповідні символи"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"Більшість літер і символів просто збігаються. Наприклад, регулярний вираз "
"``test`` точно збігатиметься з рядком ``test``. (Ви можете ввімкнути режим "
"без урахування регістру, який дозволив би цьому RE відповідати також "
"``Test`` або ``TEST``; докладніше про це пізніше.)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special "
":dfn:`metacharacters`, and don't match themselves.  Instead, they signal "
"that some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"З цього правила є винятки; деякі символи є спеціальними "
":dfn:`metacharacters` і не відповідають самі собі. Натомість вони "
"сигналізують про те, що потрібно зіставити щось незвичайне, або впливають на"
" інші частини RE, повторюючи їх або змінюючи їх значення. Велика частина "
"цього документа присвячена обговоренню різних метасимволів і того, що вони "
"роблять."

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Ось повний список метасимволів; їхнє значення буде обговорено в решті цього "
"HOWTO."

#: ../../howto/regex.rst:79
msgid ". ^ $ * + ? { } [ ] \\ | ( )"
msgstr ""

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for"
" specifying a character class, which is a set of characters that you wish to"
" match.  Characters can be listed individually, or a range of characters can"
" be indicated by giving two characters and separating them by a ``'-'``.  "
"For example, ``[abc]`` will match any of the characters ``a``, ``b``, or "
"``c``; this is the same as ``[a-c]``, which uses a range to express the same"
" set of characters.  If you wanted to match only lowercase letters, your RE "
"would be ``[a-z]``."
msgstr ""
"Перші метасимволи, які ми розглянемо, це ``[`` і ``]``. Вони "
"використовуються для вказівки класу символів, який є набором символів, які "
"ви хочете зіставити. Символи можна перераховувати окремо або діапазон "
"символів можна вказати двома символами та розділити їх символом ``'-'``. "
"Наприклад, \"[abc]\" відповідатиме будь-якому із символів \"a\", \"b\" або "
"\"c\"; це те саме, що ``[a-c]``, який використовує діапазон для вираження "
"того самого набору символів. Якщо ви хочете зіставити лише малі літери, "
"вашим RE буде ``[a-z]``."

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"Метасимволи (крім ``\\``) неактивні всередині класів. Наприклад, ``[akm$]`` "
"відповідатиме будь-якому із символів ``'a'``, ``'k'``, ``'m'`` або ``'$'``; "
"``'$'`` зазвичай є метасимволом, але всередині класу символів він "
"позбавлений особливої природи."

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by "
":dfn:`complementing` the set.  This is indicated by including a ``'^'`` as "
"the first character of the class. For example, ``[^5]`` will match any "
"character except ``'5'``.  If the caret appears elsewhere in a character "
"class, it does not have special meaning. For example: ``[5^]`` will match "
"either a ``'5'`` or a ``'^'``."
msgstr ""
"Ви можете зіставити символи, яких немає в списку в класі, "
":dfn:`complementing` набір. Це вказується додаванням ``'^'`` як першого "
"символу класу. Наприклад, ``[^5]`` відповідатиме будь-якому символу, крім "
"``'5'``. Якщо каретка з’являється в іншому місці класу символів, вона не має"
" особливого значення. Наприклад: ``[5^]`` відповідатиме або ``'5''``, або "
"``'^'``."

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Мабуть, найважливішим метасимволом є зворотна коса риска, ``\\``. Як і в "
"рядкових літералах Python, за зворотною скісною рискою можуть слідувати "
"різні символи, щоб позначити різні спеціальні послідовності. Він також "
"використовується для екранування всіх метасимволів, щоб ви все ще могли "
"зіставляти їх у шаблонах; наприклад, якщо вам потрібно знайти відповідність "
"``[`` або ``\\``, ви можете поставити перед ними зворотну скісну риску, щоб "
"видалити їхнє спеціальне значення: ``\\[`` або ``\\\\``."

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set"
" of letters, or the set of anything that isn't whitespace."
msgstr ""
"Деякі спеціальні послідовності, що починаються з ``'\\'``, представляють "
"заздалегідь визначені набори символів, які часто є корисними, наприклад "
"набір цифр, набір літер або набір будь-чого, що не є пробілами."

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class "
"``[a-zA-Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all "
"the characters marked as letters in the Unicode database provided by the "
":mod:`unicodedata` module.  You can use the more restricted definition of "
"``\\w`` in a string pattern by supplying the :const:`re.ASCII` flag when "
"compiling the regular expression."
msgstr ""
"Розглянемо приклад: ``\\w`` відповідає будь-якому буквено-цифровому символу."
" Якщо шаблон регулярного виразу виражено в байтах, це еквівалентно класу "
"``[a-zA-Z0-9_]``. Якщо шаблон регулярного виразу є рядком, ``\\w`` "
"відповідатиме всім символам, позначеним як літери в базі даних Unicode, "
"наданій модулем :mod:`unicodedata`. Ви можете використовувати більш обмежене"
" визначення ``\\w`` у шаблоні рядка, поставивши прапорець :const:`re.ASCII` "
"під час компіляції регулярного виразу."

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see"
" the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"Наступний список спеціальних послідовностей не є повним. Щоб отримати повний"
" список послідовностей і розширених визначень класів для шаблонів рядків "
"Unicode, перегляньте останню частину :ref:`Синтаксису регулярного виразу "
"<re-syntax>` у довіднику стандартної бібліотеки. Загалом, версії Unicode "
"відповідають будь-якому символу, який знаходиться у відповідній категорії "
"бази даних Unicode."

#: ../../howto/regex.rst:130
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr ""
"Збігається з будь-якою десятковою цифрою; це еквівалентно класу ``[0-9]``."

#: ../../howto/regex.rst:133
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"Відповідає будь-якому нецифровому символу; це еквівалентно класу ``[^0-9]``."

#: ../../howto/regex.rst:136
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr "Відповідає будь-якому пробілу; це еквівалентно класу ``[ \\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:140
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає будь-якому непробільному символу; це еквівалентно класу ``[^ "
"\\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:144
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class "
"``[a-zA-Z0-9_]``."
msgstr ""
"Відповідає будь-якому буквено-цифровому символу; це еквівалентно класу "
"``[a-zA-Z0-9_]``."

#: ../../howto/regex.rst:148
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"Відповідає будь-якому небуквено-цифровому символу; це еквівалентно класу "
"``[^a-zA-Z0-9_]``."

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Ці послідовності можна включити в клас символів. Наприклад, ``[\\s,.]`` — це"
" клас символів, який відповідатиме будь-якому пробілу, або ``',''`` чи "
"``'.''``."

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode "
"(:const:`re.DOTALL`) where it will match even a newline.  ``.`` is often "
"used where you want to match \"any character\"."
msgstr ""
"Останнім метасимволом у цьому розділі є ``.``. Він відповідає будь-чому, "
"крім символу нового рядка, і є альтернативний режим (:const:`re.DOTALL`), де"
" він відповідатиме навіть новому рядку. ``.`` часто використовується, коли "
"потрібно знайти відповідність \"будь-якому символу\"."

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "Повторення речей"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on"
" strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Здатність зіставляти різні набори символів — це перше, що можуть зробити "
"регулярні вирази, що ще не можливо за допомогою методів, доступних для "
"рядків. Однак, якби це була єдина додаткова можливість регулярних виразів, "
"вони не були б великим прогресом. Інша можливість полягає в тому, що ви "
"можете вказати, що частини RE мають повторюватися певну кількість разів."

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"Перший метасимвол для повторення речей, які ми розглянемо, це ``*``. ``*`` "
"не відповідає буквальному символу ``'*'``; натомість він визначає, що "
"попередній символ може бути зіставлений нуль або більше разів замість точно "
"одного разу."

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Наприклад, ``ca*t`` відповідатиме ``'ct'`` (0 символів ``'a'``), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 символи ``'a'``) і так далі."

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Такі повтори, як ``*`` є :dfn:`greedy`; при повторенні RE механізм пошуку "
"відповідності намагатиметься повторити його якомога більше разів. Якщо "
"пізніші частини шаблону не збігаються, механізм пошуку відповідностей "
"створить резервну копію та спробує знову з меншою кількістю повторень."

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Покроковий приклад зробить це більш очевидним. Розглянемо вираз "
"``a[bcd]*b``. Це відповідає літері ``'a'``, нулю або більше літер з класу "
"``[bcd]`` і, нарешті, закінчується ``'b'``. Тепер уявіть, що зіставлення "
"цього RE з рядком ``'abcbd``."

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "Крок"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "Збіг"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "Пояснення"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "``a`` у RE відповідає."

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"Механізм збігається з ``[bcd]*``, просуваючись якомога далі, тобто до кінця "
"рядка."

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*Невдача*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"Механізм намагається знайти відповідність ``b``, але поточна позиція "
"знаходиться в кінці рядка, тому це не вдається."

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr ""
"Зробіть резервну копію, щоб ``[bcd]*`` відповідав на один символ менше."

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is"
" a ``'d'``."
msgstr ""
"Спробуйте ``b`` ще раз, але поточна позиція знаходиться на останньому "
"символі, який є ``'d'``."

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr ""
"Знову створіть резервну копію, щоб ``[bcd]*`` відповідало лише ``bc``."

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Спробуйте ``b`` знову. Цього разу символом у поточній позиції є ``'b'``, "
"отже, це вдалось."

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This"
" demonstrates how the matching engine goes as far as it can at first, and if"
" no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for"
" ``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"Кінець RE вже досягнуто, і він відповідає ``'abcb``. Це демонструє, як "
"система пошуку відповідностей спочатку йде так далеко, як тільки може, і "
"якщо відповідності не знайдено, вона поступово створюватиме резервні копії "
"та повторюватиме решту RE знову і знову. Він виконуватиме резервне "
"копіювання, доки не знайде нульових збігів для ``[bcd]*``, і якщо це згодом "
"не вдасться, система зробить висновок, що рядок взагалі не відповідає RE."

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Ще один повторюваний метасимвол – це ``+``, який збігається один або кілька "
"разів. Зверніть увагу на різницю між ``*`` і ``+``; ``*`` відповідає *нуль* "
"або більше разів, тому все, що повторюється, може взагалі не бути присутнім,"
" тоді як ``+`` вимагає принаймні *одного* входження. Щоб використати "
"подібний приклад, ``ca+t`` відповідатиме ``'cat'`` (1 ``'a'``), ``'caaat'`` "
"(3 ``'a'``\\ s), але не відповідатиме ``'ct``."

#: ../../howto/regex.rst:233
msgid ""
"There are two more repeating operators or quantifiers.  The question mark "
"character, ``?``, matches either once or zero times; you can think of it as "
"marking something as being optional.  For example, ``home-?brew`` matches "
"either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"Є ще два повторювані оператори або квантори. Знак питання, ``?``, збігається"
" або один раз, або нуль разів; ви можете розглядати це як позначення чогось "
"як необов’язкового. Наприклад, ``home-?brew`` matches either ``'homebrew'`` "
"або ``'home-brew'``."

#: ../../howto/regex.rst:238
msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are decimal "
"integers.  This quantifier means there must be at least *m* repetitions, and"
" at most *n*.  For example, ``a/{1,3}b`` will match ``'a/b'``, ``'a//b'``, "
"and ``'a///b'``.  It won't match ``'ab'``, which has no slashes, or "
"``'a////b'``, which has four."
msgstr ""
"Найскладнішим квантором є ``{m,n}``, де *m* і *n* є десятковими цілими "
"числами. Цей квантор означає, що має бути принаймні *m* повторень і не "
"більше *n*.  Наприклад, ``a/{1,3}b`` відповідатиме ``'a/b'``, ``'a//b'``, та"
" ``'a///b'``. Він не збігатиметься з ``'ab'``, який не має похилих рисок, "
"або ``'a////b'``, який має чотири."

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Ви можете опустити *m* або *n*; у цьому випадку для відсутнього значення "
"приймається розумне значення. Пропуск *m* інтерпретується як нижня межа 0, "
"тоді як пропуск *n* призводить до верхньої межі нескінченності."

#: ../../howto/regex.rst:248
msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. For "
"example, ``a/{2}b`` will only match ``'a//b'``."
msgstr ""

#: ../../howto/regex.rst:251
msgid ""
"Readers of a reductionist bent may notice that the three other quantifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"Редукціоністські читачі можуть помітити, що всі три інші квантори можна "
"виразити за допомогою цієї нотації.  ``{0,}`` те саме, що ` ``*``, ``{1,}`` "
"еквівалентно ``+``, and ``{0,1}`` is the same as ``?``. Краще "
"використовувати ``*``, ``+``, або ``?``, коли є така можливість, просто "
"тому, що вони коротші та легші для читання."

#: ../../howto/regex.rst:259
msgid "Using Regular Expressions"
msgstr "Використання регулярних виразів"

#: ../../howto/regex.rst:261
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually"
" use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then"
" perform matches with them."
msgstr ""
"Тепер, коли ми розглянули деякі прості регулярні вирази, як ми насправді "
"використовуємо їх у Python? Модуль :mod:`re` надає інтерфейс механізму "
"регулярних виразів, дозволяючи вам компілювати RE в об’єкти, а потім "
"виконувати з ними збіги."

#: ../../howto/regex.rst:268
msgid "Compiling Regular Expressions"
msgstr "Компіляція регулярних виразів"

#: ../../howto/regex.rst:270
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"Регулярні вирази компілюються в об’єкти шаблонів, які мають методи для "
"різноманітних операцій, таких як пошук збігів шаблону або виконання "
"підстановок рядків. ::"

#: ../../howto/regex.rst:274
msgid ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"
msgstr ""

#: ../../howto/regex.rst:279
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable"
" various special features and syntax variations.  We'll go over the "
"available settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` також приймає необов’язковий аргумент *flags*, який "
"використовується для ввімкнення різних спеціальних функцій і варіантів "
"синтаксису. Пізніше ми розглянемо доступні параметри, а поки підійде один "
"приклад:"

#: ../../howto/regex.rst:283
msgid ">>> p = re.compile('ab*', re.IGNORECASE)"
msgstr ""

#: ../../howto/regex.rst:285
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language,"
" and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the "
":mod:`socket` or :mod:`zlib` modules."
msgstr ""
"RE передається до :func:`re.compile` як рядок. RE обробляються як рядки, "
"оскільки регулярні вирази не є частиною основної мови Python, і для їх "
"вираження не створено спеціального синтаксису. (Існують програми, які "
"взагалі не потребують RE, тому немає потреби роздувати специфікацію мови, "
"включаючи їх.) Натомість модуль :mod:`re` є просто модулем розширення C, що "
"входить до складу Python, як і модулі :mod:`socket` або :mod:`zlib`."

#: ../../howto/regex.rst:292
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Розміщення RE в рядках робить мову Python простішою, але має один недолік, "
"який є темою наступного розділу."

#: ../../howto/regex.rst:299
msgid "The Backslash Plague"
msgstr "Зворотна коса чума"

#: ../../howto/regex.rst:301
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Як було сказано раніше, у регулярних виразах використовується символ "
"зворотної косої риски (``'\\'``), щоб позначити спеціальні форми або "
"дозволити використовувати спеціальні символи без виклику їх особливого "
"значення. Це суперечить використанню Python того самого символу для тієї ж "
"мети в рядкових літералах."

#: ../../howto/regex.rst:306
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However,"
" to express this as a Python string literal, both backslashes must be "
"escaped *again*."
msgstr ""
"Припустімо, ви хочете написати RE, який відповідає рядку ``\\section``, який"
" можна знайти у файлі LaTeX. Щоб зрозуміти, що писати в коді програми, "
"почніть із потрібного рядка, який потрібно знайти. Далі ви повинні уникнути "
"будь-яких зворотних похилих рисок та інших метасимволів, поставивши перед "
"ними зворотну похилу риску, що призведе до рядка ``\\\\section``. Отриманий "
"рядок, який потрібно передати в :func:`re.compile`, має бути "
"``\\\\section``. Однак, щоб виразити це як рядковий літерал Python, обидві "
"зворотні похилі риски потрібно екранувати *знову*."

#: ../../howto/regex.rst:315
msgid "Characters"
msgstr "Персонажі"

#: ../../howto/regex.rst:315
msgid "Stage"
msgstr "етап"

#: ../../howto/regex.rst:317
msgid "``\\section``"
msgstr "``\\розділ``"

#: ../../howto/regex.rst:317
msgid "Text string to be matched"
msgstr "Текстовий рядок, який потрібно знайти"

#: ../../howto/regex.rst:319
msgid "``\\\\section``"
msgstr "``\\\\розділ``"

#: ../../howto/regex.rst:319
msgid "Escaped backslash for :func:`re.compile`"
msgstr "Екранований зворотний слеш для :func:`re.compile`"

#: ../../howto/regex.rst:321 ../../howto/regex.rst:348
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\розділ\"``"

#: ../../howto/regex.rst:321
msgid "Escaped backslashes for a string literal"
msgstr "Екрановані зворотні косі риски для рядкового літералу"

#: ../../howto/regex.rst:324
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to "
"understand."
msgstr ""
"Коротше кажучи, щоб відповідати буквальному зворотному слешу, потрібно "
"написати ``'\\\\\\\\'`` як рядок RE, тому що регулярний вираз має бути "
"``\\\\``, а кожен зворотний слеш має бути виражений як ``\\\\`` всередині "
"звичайного рядкового літералу Python. У RE, які неодноразово містять "
"зворотні косі риски, це призводить до великої кількості повторюваних "
"зворотних косих риск і ускладнює розуміння результуючих рядків."

#: ../../howto/regex.rst:330
msgid ""
"The solution is to use Python's raw string notation for regular expressions;"
" backslashes are not handled in any special way in a string literal prefixed"
" with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'``"
" and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this"
" raw string notation."
msgstr ""
"Рішення полягає у використанні необробленої рядкової нотації Python для "
"регулярних виразів; зворотні косі риски не обробляються спеціальним чином у "
"рядковому літералі з префіксом ``'r'``, тому ``r\"\\n\"`` є двосимвольним "
"рядком, що містить ``'\\'`` і ``' n'``, тоді як ``\"\\n\"`` є односимвольним"
" рядком, що містить новий рядок. Регулярні вирази часто записуються в коді "
"Python з використанням цієї необробленої рядкової нотації."

#: ../../howto/regex.rst:336
msgid ""
"In addition, special escape sequences that are valid in regular expressions,"
" but not valid as Python string literals, now result in a "
":exc:`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, "
"which means the sequences will be invalid if raw string notation or escaping"
" the backslashes isn't used."
msgstr ""
"Крім того, спеціальні керуючі послідовності, дійсні в регулярних виразах, "
"але недійсні як рядкові літерали Python, тепер призводять до "
":exc:`DeprecationWarning` і згодом стануть :exc:`SyntaxError`, що означає, "
"що послідовності будуть недійсними якщо не використовується необроблений "
"рядковий запис або екранування зворотних скісних риск."

#: ../../howto/regex.rst:344
msgid "Regular String"
msgstr "Звичайний рядок"

#: ../../howto/regex.rst:344
msgid "Raw string"
msgstr "Необроблений рядок"

#: ../../howto/regex.rst:346
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:346
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:348
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\розділ\"``"

#: ../../howto/regex.rst:350
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:350
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:355
msgid "Performing Matches"
msgstr "Виконання матчів"

#: ../../howto/regex.rst:357
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"Якщо у вас є об’єкт, що представляє скомпільований регулярний вираз, що ви з"
" ним робите? Об’єкти шаблонів мають кілька методів і атрибутів. Тут будуть "
"розглянуті лише найважливіші з них; зверніться до документів :mod:`re` для "
"отримання повного списку."

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1065
msgid "Method/Attribute"
msgstr "Метод/атрибут"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1065
msgid "Purpose"
msgstr "призначення"

#: ../../howto/regex.rst:365
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:365
msgid "Determine if the RE matches at the beginning of the string."
msgstr "Визначте, чи відповідає RE на початку рядка."

#: ../../howto/regex.rst:368
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:368
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "Проскануйте рядок, шукаючи будь-яке місце, де цей RE відповідає."

#: ../../howto/regex.rst:371
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:371
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr ""
"Знайти всі підрядки, де відповідає RE, і повернути їх у вигляді списку."

#: ../../howto/regex.rst:374
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:374
msgid ""
"Find all substrings where the RE matches, and returns them as an "
":term:`iterator`."
msgstr ""
"Знайти всі підрядки, де відповідає RE, і повернути їх як :term:`iterator`."

#: ../../howto/regex.rst:378
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` і :meth:`~re.Pattern.search` повертають ``None``, "
"якщо збіг не знайдено. Якщо вони успішні, повертається екземпляр :ref:`match"
" object <match-objects>`, який містить інформацію про збіг: де він "
"починається і закінчується, підрядок, з яким він збігся, тощо."

#: ../../howto/regex.rst:383
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module."
msgstr ""
"Ви можете дізнатися про це, інтерактивно поекспериментувавши з модулем "
":mod:`re`."

#: ../../howto/regex.rst:386
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run"
" the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"Цей HOWTO використовує стандартний інтерпретатор Python для своїх прикладів."
" Спочатку запустіть інтерпретатор Python, імпортуйте модуль :mod:`re` і "
"скомпілюйте RE::"

#: ../../howto/regex.rst:389
msgid ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"
msgstr ""

#: ../../howto/regex.rst:394
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case,"
" which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Тепер ви можете спробувати зіставити різні рядки з RE ``[a-z]+``. Порожній "
"рядок взагалі не повинен збігатися, оскільки ``+`` означає 'одне або більше "
"повторень'. :meth:`~re.Pattern.match` має повернути ``None`` у цьому "
"випадку, що призведе до того, що інтерпретатор не друкуватиме вихідні дані. "
"Ви можете явно надрукувати результат :meth:`!match`, щоб це було зрозуміло. "
"::"

#: ../../howto/regex.rst:400
msgid ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:404
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object "
"<match-objects>`, so you should store the result in a variable for later "
"use. ::"
msgstr ""
"Тепер давайте спробуємо це на рядку, який має збігатися, наприклад "
"``tempo``. У цьому випадку :meth:`~re.Pattern.match` поверне :ref:`об’єкт "
"відповідності <match-objects>`, тому ви повинні зберегти результат у змінній"
" для подальшого використання. ::"

#: ../../howto/regex.rst:408
msgid ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"
msgstr ""

#: ../../howto/regex.rst:412
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods"
" and attributes; the most important ones are:"
msgstr ""
"Тепер ви можете запитати :ref:`match object <match-objects>` для отримання "
"інформації про відповідний рядок. Екземпляри об’єктів зіставлення також "
"мають кілька методів і атрибутів; найважливіші з них:"

#: ../../howto/regex.rst:419
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:419
msgid "Return the string matched by the RE"
msgstr "Повертає рядок, який відповідає RE"

#: ../../howto/regex.rst:421
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:421
msgid "Return the starting position of the match"
msgstr "Повернути вихідну позицію матчу"

#: ../../howto/regex.rst:423
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:423
msgid "Return the ending position of the match"
msgstr "Повернення кінцевої позиції матчу"

#: ../../howto/regex.rst:425
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:425
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "Повертає кортеж, що містить (початкову, кінцеву) позиції збігу"

#: ../../howto/regex.rst:429
msgid "Trying these methods will soon clarify their meaning::"
msgstr "Спроба цих методів незабаром прояснить їх значення:"

#: ../../howto/regex.rst:431
msgid ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"
msgstr ""

#: ../../howto/regex.rst:438
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  "
":meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end"
" indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only"
" checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that case. "
"::"
msgstr ""
":meth:`~re.Match.group` повертає підрядок, який був зіставлений RE. "
":meth:`~re.Match.start` і :meth:`~re.Match.end` повертають початковий і "
"кінцевий індекси збігу. :meth:`~re.Match.span` повертає початковий і "
"кінцевий індекси в одному кортежі. Оскільки метод :meth:`~re.Pattern.match` "
"лише перевіряє, чи відповідає RE на початку рядка, :meth:`!start` завжди "
"дорівнюватиме нулю. Однак метод шаблонів :meth:`~re.Pattern.search` сканує "
"рядок, тому в цьому випадку збіг може не початися з нуля. ::"

#: ../../howto/regex.rst:446
msgid ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"
msgstr ""

#: ../../howto/regex.rst:455
msgid ""
"In actual programs, the most common style is to store the :ref:`match object"
" <match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"У реальних програмах найпоширенішим стилем є збереження :ref:`match object "
"<match-objects>` у змінній, а потім перевірка, чи вона була ``None``. "
"Зазвичай це виглядає так::"

#: ../../howto/regex.rst:459
msgid ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"
msgstr ""

#: ../../howto/regex.rst:466
msgid ""
"Two pattern methods return all of the matches for a pattern. "
":meth:`~re.Pattern.findall` returns a list of matching strings::"
msgstr ""
"Два методи шаблону повертають усі збіги шаблону. :meth:`~re.Pattern.findall`"
" повертає список відповідних рядків::"

#: ../../howto/regex.rst:469
msgid ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"
msgstr ""

#: ../../howto/regex.rst:473
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this"
" example because escape sequences in a normal \"cooked\" string literal that"
" are not recognized by Python, as opposed to regular expressions, now result"
" in a :exc:`DeprecationWarning` and will eventually become a "
":exc:`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"Префікс ``r``, який робить літерал необробленим рядковим літералом, потрібен"
" у цьому прикладі, тому що escape-послідовності у звичайному \"вареному\" "
"рядковому літералі, які не розпізнаються Python, на відміну від регулярних "
"виразів, тепер призводять до :exc:`DeprecationWarning` і з часом стане "
":exc:`SyntaxError`. Дивіться :ref:`the-backslash-plague`."

#: ../../howto/regex.rst:479
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an "
":term:`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` має створити весь список, перш ніж його можна "
"буде повернути як результат. Метод :meth:`~re.Pattern.finditer` повертає "
"послідовність екземплярів :ref:`match object <match-objects>` як "
":term:`iterator`::"

#: ../../howto/regex.rst:483
msgid ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator  \n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"
msgstr ""

#: ../../howto/regex.rst:495
msgid "Module-Level Functions"
msgstr "Функції рівня модуля"

#: ../../howto/regex.rst:497
msgid ""
"You don't have to create a pattern object and call its methods; the "
":mod:`re` module also provides top-level functions called :func:`~re.match`,"
" :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Вам не потрібно створювати шаблонний об’єкт і викликати його методи; модуль "
":mod:`re` також надає функції верхнього рівня під назвою :func:`~re.match`, "
":func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` і так далі. Ці "
"функції приймають ті самі аргументи, що й відповідний метод шаблону з рядком"
" RE, доданим як перший аргумент, і все одно повертають ``None`` або "
"екземпляр :ref:`match object <match-objects>`. ::"

#: ../../howto/regex.rst:504
msgid ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')  \n"
"<re.Match object; span=(0, 5), match='From '>"
msgstr ""

#: ../../howto/regex.rst:509
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a"
" cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"Під капотом ці функції просто створюють для вас шаблонний об’єкт і "
"викликають для нього відповідний метод. Вони також зберігають скомпільований"
" об’єкт у кеш-пам’яті, тому для майбутніх викликів із використанням того "
"самого RE не потрібно буде аналізувати шаблон знову і знову."

#: ../../howto/regex.rst:514
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Ви повинні використовувати ці функції на рівні модуля, чи вам слід отримати "
"шаблон і викликати його методи самостійно? Якщо ви отримуєте доступ до "
"регулярного виразу в циклі, його попередня компіляція заощадить кілька "
"викликів функцій. За межами циклів немає великої різниці завдяки "
"внутрішньому кешу."

#: ../../howto/regex.rst:522
msgid "Compilation Flags"
msgstr "Прапори компіляції"

#: ../../howto/regex.rst:526
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as "
":const:`I`.  (If you're familiar with Perl's pattern modifiers, the one-"
"letter forms use the same letters; the short form of :const:`re.VERBOSE` is "
":const:`re.X`, for example.) Multiple flags can be specified by bitwise OR-"
"ing them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for"
" example."
msgstr ""
"Прапори компіляції дозволяють змінювати деякі аспекти роботи регулярних "
"виразів. Прапори доступні в модулі :mod:`re` під двома назвами: довгою "
"назвою, як-от :const:`IGNORECASE`, і короткою однолітерною формою, як-от "
":const:`I`. (Якщо ви знайомі з модифікаторами шаблонів Perl, однолітерні "
"форми використовують ті самі літери; наприклад, коротка форма "
":const:`re.VERBOSE` це :const:`re.X`.) Кілька прапорів можуть вказувати їх "
"порозрядним АБО; ``re.I | re.M`` встановлює, наприклад, прапорці :const:`I` "
"і :const:`M`."

#: ../../howto/regex.rst:534
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Ось таблиця доступних прапорів із більш детальним поясненням кожного з них."

#: ../../howto/regex.rst:538
msgid "Flag"
msgstr "Прапор"

#: ../../howto/regex.rst:538
msgid "Meaning"
msgstr "Значення"

#: ../../howto/regex.rst:540
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:540
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Декілька символів екранування, як-от ``\\w``, ``\\b``, ``\\s`` і ``\\d``, "
"збігаються лише з символами ASCII з відповідною властивістю."

#: ../../howto/regex.rst:544
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:544
msgid "Make ``.`` match any character, including newlines."
msgstr "Зробіть \".\" відповідним будь-якому символу, включно з новими рядками."

#: ../../howto/regex.rst:547
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:547
msgid "Do case-insensitive matches."
msgstr "Збіги без урахування регістру."

#: ../../howto/regex.rst:549
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:549
msgid "Do a locale-aware match."
msgstr "Виконайте відповідність з урахуванням локалі."

#: ../../howto/regex.rst:551
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:551
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "Багаторядкова відповідність, що впливає на ``^`` і ``$``."

#: ../../howto/regex.rst:554
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` (для \"розширеного\")"

#: ../../howto/regex.rst:554
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Увімкніть докладні RE, які можна організувати більш чітко та зрозуміло."

#: ../../howto/regex.rst:563
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase"
" letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns "
"``[a-z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` "
"flag, they will match the 52 ASCII letters and 4 additional non-ASCII "
"letters: 'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, "
"Latin small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This"
" lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Виконуйте зіставлення без урахування регістру; клас символів і літеральні "
"рядки будуть відповідати буквам, ігноруючи регістр. Наприклад, ``[A-Z]`` "
"також відповідатиме малим регістрам. Повна відповідність Unicode також "
"працює, якщо не використовується прапорець :const:`ASCII`, щоб вимкнути "
"збіги, відмінні від ASCII. Коли шаблони Unicode ``[a-z]`` або ``[A-Z]`` "
"використовуються в поєднанні з прапором :const:`IGNORECASE`, вони "
"відповідатимуть 52 літерам ASCII і 4 додатковим літерам, які не належать до "
"ASCII: 'İ ' (U+0130, латинська велика літера I з крапкою вгорі), 'ı' "
"(U+0131, латинська мала літера без крапки), 'ſ' (U+017F, латинська мала "
"літера довге s) і 'K' (U +212A, знак Кельвіна). ``Spam`` відповідатиме "
"``'Spam'``, ``'spam'``, ``'spAM'`` або ``'ſpam'`` (останній збігається лише "
"в режимі Unicode). Цей нижній регістр не враховує поточну мову; це буде, "
"якщо ви також установите прапорець :const:`LOCALE`."

#: ../../howto/regex.rst:581
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Зробіть ``\\w``, ``\\W``, ``\\b``, ``\\B`` і відповідність без урахування "
"регістру залежною від поточної мови замість бази даних Unicode."

#: ../../howto/regex.rst:584
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+``"
" to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Локалі — це функція бібліотеки C, призначена для допомоги в написанні "
"програм, які враховують мовні відмінності. Наприклад, якщо ви обробляєте "
"закодований французький текст, ви б хотіли мати можливість писати ``\\w+`` "
"для відповідності слів, але ``\\w`` відповідає лише класу символів ``[A-Za- "
"z]`` у шаблонах байтів; він не співпадатиме з байтами, що відповідають ``é``"
" або ``ç``. Якщо ваша система налаштована належним чином і вибрано "
"французьку мову, певні функції C повідомлять програмі, що байт, який "
"відповідає ``é``, також слід вважати літерою. Встановлення прапорця "
":const:`LOCALE` під час компіляції регулярного виразу змусить отриманий "
"скомпільований об’єкт використовувати ці функції C для ``\\w``; це "
"повільніше, але також дозволяє ``\\w+`` відповідати французьким словам, як "
"ви очікуєте. Використання цього прапора не рекомендується в Python 3, "
"оскільки механізм локалізації дуже ненадійний, він обробляє лише одну "
"\"культуру\" за раз і працює лише з 8-бітними локалями. Зіставлення Unicode "
"вже ввімкнено за замовчуванням у Python 3 для шаблонів Unicode (str), і він "
"здатний обробляти різні локалі/мови."

#: ../../howto/regex.rst:606
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` і ``$`` ще не пояснено; їх буде введено в розділі :ref:`more-"
"metacharacters`.)"

#: ../../howto/regex.rst:609
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches"
" only at the end of the string and immediately before the newline (if any) "
"at the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string,"
" immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Зазвичай ``^`` збігається лише на початку рядка, а ``$`` збігається лише в "
"кінці рядка та безпосередньо перед символом нового рядка (якщо є) у кінці "
"рядка. Якщо вказано цей прапорець, ``^`` збігається на початку рядка та на "
"початку кожного рядка в рядку, відразу після кожного нового рядка. Подібним "
"чином, метасимвол ``$`` збігається або в кінці рядка, і в кінці кожного "
"рядка (безпосередньо перед кожним новим рядком)."

#: ../../howto/regex.rst:622
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Робить спеціальний символ `''.''` відповідним будь-якому символу взагалі, "
"включно з символом нового рядка; без цього прапорця `''.''` відповідатиме "
"будь-чому *крім* нового рядка."

#: ../../howto/regex.rst:630
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Змусити ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` і ``\\S`` виконувати "
"відповідність лише ASCII замість повної Зіставлення Unicode. Це має значення"
" лише для шаблонів Unicode та ігнорується для шаблонів байтів."

#: ../../howto/regex.rst:639
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag"
" also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Цей прапорець дозволяє вам писати регулярні вирази, які є більш "
"читабельними, надаючи вам більше гнучкості у тому, як ви можете їх "
"форматувати. Якщо вказано цей прапорець, пробіли в рядку RE ігноруються, за "
"винятком випадків, коли пробіли знаходяться в класі символів або перед ними "
"стоїть неекранована зворотна похила риска; це дозволяє більш чітко "
"організувати та зробити відступи RE. Цей прапор також дозволяє розміщувати "
"коментарі в RE, які ігноруватимуться механізмом; коментарі позначаються "
"символом ``'#'``, якого немає в класі символів або якому передує "
"неекранований зворотний слеш."

#: ../../howto/regex.rst:648
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Наприклад, ось RE, який використовує :const:`re.VERBOSE`; бачите, наскільки "
"легше читати? ::"

#: ../../howto/regex.rst:651
msgid ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Start of a numeric entity reference\n"
" (\n"
"     0[0-7]+         # Octal form\n"
"   | [0-9]+          # Decimal form\n"
"   | x[0-9a-fA-F]+   # Hexadecimal form\n"
" )\n"
" ;                   # Trailing semicolon\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:661
msgid "Without the verbose setting, the RE would look like this::"
msgstr "Без параметра verbose RE виглядатиме так:"

#: ../../howto/regex.rst:663
msgid ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"
msgstr ""

#: ../../howto/regex.rst:667
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"У наведеному вище прикладі автоматичне об’єднання рядкових літералів Python "
"було використано для розбиття RE на менші частини, але це все ще важче "
"зрозуміти, ніж версію з використанням :const:`re.VERBOSE`."

#: ../../howto/regex.rst:673
msgid "More Pattern Power"
msgstr "Більше потужності шаблону"

#: ../../howto/regex.rst:675
msgid ""
"So far we've only covered a part of the features of regular expressions.  In"
" this section, we'll cover some new metacharacters, and how to use groups to"
" retrieve portions of the text that was matched."
msgstr ""
"Поки що ми розглянули лише частину функцій регулярних виразів. У цьому "
"розділі ми розглянемо деякі нові метасимволи, а також те, як використовувати"
" групи для отримання частин тексту, які збігаються."

#: ../../howto/regex.rst:683
msgid "More Metacharacters"
msgstr "Більше метасимволів"

#: ../../howto/regex.rst:685
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Є деякі метасимволи, які ми ще не розглянули. Більшість із них буде "
"розглянуто в цьому розділі."

#: ../../howto/regex.rst:688
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For"
" example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means"
" that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Деякі метасимволи, які залишилися для обговорення, це :dfn:`затвердження "
"нульової ширини`. Вони не змушують двигун просуватися по струні; натомість "
"вони взагалі не використовують жодних символів і просто досягають успіху або"
" зазнають невдачі. Наприклад, ``\\b`` - це твердження, що поточна позиція "
"розташована на межі слова; позиція взагалі не змінюється ``\\b``. Це "
"означає, що твердження нульової ширини ніколи не повинні повторюватися, "
"оскільки якщо вони збігаються один раз у заданому місці, вони, очевидно, "
"можуть бути зіставлені нескінченну кількість разів."

#: ../../howto/regex.rst:696
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:697
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either"
" ``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Чергування або оператор \"або\". Якщо *A* і *B* є регулярними виразами, "
"``A|B`` відповідатиме будь-якому рядку, який відповідає *A* або *B*. ``|`` "
"має дуже низький пріоритет, щоб він працював розумно, коли ви чергуєте "
"багатосимвольні рядки. ``Crow|Servo`` відповідатиме ``'Crow'`` або "
"``'Servo'``, а не ``'Cro'``, ``'w'`` чи ``'S'`` і ``'ervo''``."

#: ../../howto/regex.rst:703
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Щоб відповідати літералу ``'|'``, використовуйте ``\\|`` або вкладіть його в"
" клас символів, як у ``[|]``."

#: ../../howto/regex.rst:706
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:707
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In "
":const:`MULTILINE` mode, this also matches immediately after each newline "
"within the string."
msgstr ""
"Збіги на початку рядків. Якщо не встановлено прапорець :const:`MULTILINE`, "
"він збігатиметься лише на початку рядка. У режимі :const:`MULTILINE` це "
"також збігається відразу після кожного нового рядка в рядку."

#: ../../howto/regex.rst:711
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of"
" a line, the RE to use is ``^From``. ::"
msgstr ""
"Наприклад, якщо ви бажаєте зіставити слово ``From`` лише на початку рядка, "
"використовуйте RE ``^From``. ::"

#: ../../howto/regex.rst:714
msgid ""
">>> print(re.search('^From', 'From Here to Eternity'))  \n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:719
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Щоб відповідати літералу ``'^'``, використовуйте ``\\^``."

#: ../../howto/regex.rst:721
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:722
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Збігається в кінці рядка, який визначається як кінець рядка або будь-яке "
"місце, після якого йде символ нового рядка. ::"

#: ../../howto/regex.rst:725
msgid ""
">>> print(re.search('}$', '{block}'))  \n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))  \n"
"<re.Match object; span=(6, 7), match='}'>"
msgstr ""

#: ../../howto/regex.rst:732
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Щоб відповідати літералу ``'$'``, використовуйте ``\\$`` або вкладіть його в"
" клас символів, як у ``[$]``."

#: ../../howto/regex.rst:735
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:736
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a"
" newline character."
msgstr ""
"Збігається лише на початку рядка. Якщо не в режимі :const:`MULTILINE`, "
"``\\A`` і ``^`` фактично однакові. У режимі :const:`MULTILINE` вони "
"відрізняються: ``\\A`` все ще збігається лише на початку рядка, але ``^`` "
"може збігатися в будь-якому місці всередині рядка, яке слідує за символом "
"нового рядка."

#: ../../howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:742
msgid "Matches only at the end of the string."
msgstr "Збігається лише в кінці рядка."

#: ../../howto/regex.rst:744
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:745
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric"
" characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Кордон слова. Це твердження нульової ширини, яке збігається лише на початку "
"або в кінці слова. Слово визначається як послідовність буквено-цифрових "
"символів, тому кінець слова позначається пробілом або неалфавітно-цифровим "
"символом."

#: ../../howto/regex.rst:750
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"Наступний приклад відповідає ``класу`` лише тоді, коли це повне слово; воно "
"не збігається, якщо міститься всередині іншого слова. ::"

#: ../../howto/regex.rst:753
msgid ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:761
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our"
" previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"Використовуючи цю особливу послідовність, слід пам’ятати про дві тонкощі. "
"По-перше, це найгірша колізія між рядковими літералами Python і "
"послідовностями регулярних виразів. У рядкових літералах Python ``\\b`` є "
"символом повернення, значення ASCII 8. Якщо ви не використовуєте необроблені"
" рядки, тоді Python перетворить ``\\b`` на пропуск, а ваш RE не буде "
"відповідати, як ви очікуєте. Наступний приклад виглядає так само, як наш "
"попередній RE, але опущено ``'r'`` перед рядком RE. ::"

#: ../../howto/regex.rst:769
msgid ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"
msgstr ""

#: ../../howto/regex.rst:775
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"По-друге, всередині класу символів, де немає користі для цього твердження, "
"``\\b`` представляє символ зворотного простору для сумісності з рядковими "
"літералами Python."

#: ../../howto/regex.rst:779
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:780
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching"
" when the current position is not at a word boundary."
msgstr ""
"Інше твердження нульової ширини, це протилежність ``\\b``, збігається лише "
"тоді, коли поточна позиція не знаходиться на межі слова."

#: ../../howto/regex.rst:785
msgid "Grouping"
msgstr "Групування"

#: ../../howto/regex.rst:787
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components"
" of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Часто вам потрібно отримати більше інформації, ніж просто відповідність RE "
"чи ні. Регулярні вирази часто використовуються для аналізу рядків шляхом "
"запису RE, розділеного на кілька підгруп, які відповідають різним цікавим "
"компонентам. Наприклад, рядок заголовка RFC-822 розділено на ім’я заголовка "
"та значення, розділені символом ``':'``, ось так:"

#: ../../howto/regex.rst:793
msgid ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"
msgstr ""

#: ../../howto/regex.rst:800
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Це можна вирішити, написавши регулярний вираз, який відповідає всьому рядку "
"заголовка та має одну групу, яка відповідає імені заголовка, та іншу групу, "
"яка відповідає значенню заголовка."

#: ../../howto/regex.rst:804
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a quantifier, such as ``*``, ``+``, "
"``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"Групи позначені метасимволами ``'('`` та ``')'``. ``'('`` і ``')'`` мають "
"майже те саме значення, що й у математичних виразах; вони групують вирази, "
"що містяться в них, і ви можете повторити вміст групи за допомогою квантора,"
" наприклад ``*``, ``+``, ``?``, або ``{m,n}``.  Наприклад, ``(ab)*`` "
"відповідатиме нулю або більше повторень ``ab``. ::"

#: ../../howto/regex.rst:811
msgid ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"
msgstr ""

#: ../../howto/regex.rst:815
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end`, and :meth:`~re.Match.span`.  Groups are numbered "
"starting with 0.  Group 0 is always present; it's the whole RE, so "
":ref:`match object <match-objects>` methods all have group 0 as their "
"default argument.  Later we'll see how to express groups that don't capture "
"the span of text that they match. ::"
msgstr ""
"Групи, позначені ``'('``, ``')'`` також фіксують початковий і кінцевий "
"індекс тексту, якому вони відповідають; це можна отримати, передавши "
"аргумент до :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end` і :meth:`~re.Match.span`. Групи нумеруються, починаючи"
" з 0. Група 0 завжди присутня; це весь RE, тому всі методи :ref:`match "
"object <match-objects>` мають групу 0 як аргумент за замовчуванням. Пізніше "
"ми побачимо, як виражати групи, які не фіксують діапазон тексту, якому вони "
"відповідають. ::"

#: ../../howto/regex.rst:824
msgid ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"
msgstr ""

#: ../../howto/regex.rst:831
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Підгрупи нумеруються зліва направо, починаючи з 1 і вище. Групи можуть бути "
"вкладеними; щоб визначити число, просто порахуйте символи відкриваючих "
"дужок, рухаючись зліва направо. ::"

#: ../../howto/regex.rst:835
msgid ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"
msgstr ""

#: ../../howto/regex.rst:844
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` можна передати кілька номерів груп одночасно, і в "
"цьому випадку він поверне кортеж, що містить відповідні значення для цих "
"груп. ::"

#: ../../howto/regex.rst:847
msgid ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"
msgstr ""

#: ../../howto/regex.rst:850
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"Метод :meth:`~re.Match.groups` повертає кортеж, що містить рядки для всіх "
"підгруп, від 1 до будь-якої кількості. ::"

#: ../../howto/regex.rst:853
msgid ""
">>> m.groups()\n"
"('abc', 'b')"
msgstr ""

#: ../../howto/regex.rst:856
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Зворотні посилання в шаблоні дозволяють вказати, що вміст попередньої групи "
"захоплення також має бути знайдений у поточному місці в рядку. Наприклад, "
"``\\1`` буде успішним, якщо точний вміст групи 1 можна знайти в поточній "
"позиції, і не вдасться в іншому випадку. Пам’ятайте, що рядкові літерали "
"Python також використовують зворотну скісну риску, за якою слідують числа, "
"щоб дозволити включати довільні символи в рядок, тому обов’язково "
"використовуйте необроблений рядок, коли включаєте зворотні посилання в RE."

#: ../../howto/regex.rst:864
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "Наприклад, наступний RE виявляє подвоєні слова в рядку. ::"

#: ../../howto/regex.rst:866
msgid ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""

#: ../../howto/regex.rst:870
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Подібні зворотні посилання не часто корисні лише для пошуку в рядку --- є "
"кілька текстових форматів, які повторюють дані таким чином --- але незабаром"
" ви зрозумієте, що вони *дуже* корисні під час виконання замін рядків ."

#: ../../howto/regex.rst:876
msgid "Non-capturing and Named Groups"
msgstr "Неперехоплювані та іменовані групи"

#: ../../howto/regex.rst:878
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"Розроблені RE можуть використовувати багато груп як для захоплення цікавих "
"підрядків, так і для групування та структурування самого RE. У складних RE "
"стає важко відслідковувати номери груп. Є дві функції, які допомагають "
"вирішити цю проблему. Обидва вони використовують загальний синтаксис для "
"розширень регулярних виразів, тому ми розглянемо це спочатку."

#: ../../howto/regex.rst:884
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 добре відомий своїми потужними доповненнями до стандартних регулярних"
" виразів. Для цих нових можливостей розробники Perl не могли вибрати нові "
"одноклавішні метасимволи або нові спеціальні послідовності, що починаються з"
" ``\\``, не зробивши регулярні вирази Perl різко відмінними від стандартних "
"RE. Наприклад, якби вони вибрали ``&`` як новий метасимвол, старі вирази "
"припускали б, що ``&`` був звичайним символом і не міг би уникнути його, "
"написавши ``\\&`` або ``[ &]``."

#: ../../howto/regex.rst:891
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any"
" compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Рішенням, обраним розробниками Perl, було використання ``(?...)`` як "
"синтаксису розширення. ``?`` відразу після дужок було синтаксичною помилкою,"
" оскільки ``?`` не було б чого повторювати, тому це не створювало жодних "
"проблем із сумісністю. Символи відразу після ``?`` вказують на те, яке "
"розширення використовується, тому ``(?=foo)`` це одне (позитивне твердження "
"попереднього перегляду), а ``(?:foo)`` це щось інше ( група без захоплення, "
"що містить підвираз ``foo``)."

#: ../../howto/regex.rst:899
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to"
" Perl's extension syntax.  If the first character after the question mark is"
" a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python підтримує кілька розширень Perl і додає синтаксис розширення до "
"синтаксису розширення Perl. Якщо першим символом після знака питання є "
"``P``, ви знаєте, що це розширення, специфічне для Python."

#: ../../howto/regex.rst:904
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Тепер, коли ми розглянули загальний синтаксис розширення, ми можемо "
"повернутися до функцій, які спрощують роботу з групами в складних RE."

#: ../../howto/regex.rst:907
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Іноді вам потрібно використати групу для позначення частини регулярного "
"виразу, але ви не зацікавлені в отриманні вмісту групи. Ви можете зробити "
"цей факт явним, використовуючи групу без захоплення: ``(?:...)``, де ви "
"можете замінити ``...`` будь-яким іншим регулярним виразом. ::"

#: ../../howto/regex.rst:912
msgid ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"
msgstr ""

#: ../../howto/regex.rst:919
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"За винятком того факту, що ви не можете отримати вміст того, що відповідає "
"групі, група без захоплення поводиться точно так само, як група захоплення; "
"ви можете помістити в нього що завгодно, повторити це з метасимволом "
"повторення, таким як ``*``, і вкладати його в інші групи (захоплюючі чи "
"незахоплюючі). ``(?:...)`` особливо корисний під час зміни існуючого "
"шаблону, оскільки ви можете додавати нові групи, не змінюючи спосіб "
"нумерації всіх інших груп. Слід зазначити, що немає різниці в продуктивності"
" пошуку між групами захоплення та групами без захоплення; жодна форма не є "
"швидшою за іншу."

#: ../../howto/regex.rst:928
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"Більш важливою особливістю є іменовані групи: замість того, щоб посилатися "
"на них номерами, на групи можна посилатися за назвою."

#: ../../howto/regex.rst:931
msgid ""
"The syntax for a named group is one of the Python-specific extensions: "
"``(?P<name>...)``.  *name* is, obviously, the name of the group.  Named "
"groups behave exactly like capturing groups, and additionally associate a "
"name with a group.  The :ref:`match object <match-objects>` methods that "
"deal with capturing groups all accept either integers that refer to the "
"group by number or strings that contain the desired group's name.  Named "
"groups are still given numbers, so you can retrieve information about a "
"group in two ways::"
msgstr ""
"Синтаксис іменованої групи є одним із специфічних для Python розширень: "
"``(?P <name> ...)``. *name* — це, очевидно, назва групи. Іменовані групи "
"поводяться так само, як групи захоплення, і додатково пов’язують назву з "
"групою. Усі методи :ref:`match object <match-objects>`, які мають справу із "
"захопленням груп, приймають або цілі числа, які посилаються на групу за "
"номером, або рядки, які містять назву потрібної групи. Іменовані групи все "
"ще мають номери, тому ви можете отримати інформацію про групу двома "
"способами:"

#: ../../howto/regex.rst:939
msgid ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"
msgstr ""

#: ../../howto/regex.rst:946
msgid ""
"Additionally, you can retrieve named groups as a dictionary with "
":meth:`~re.Match.groupdict`::"
msgstr ""
"Крім того, ви можете отримати іменовані групи як словник за допомогою "
":meth:`~re.Match.groupdict`::"

#: ../../howto/regex.rst:949
msgid ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"
msgstr ""

#: ../../howto/regex.rst:953
msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the "
":mod:`imaplib` module::"
msgstr ""
"Іменовані групи зручні, оскільки вони дозволяють використовувати імена, які "
"легко запам’ятовуються, замість того, щоб запам’ятовувати числа. Ось приклад"
" RE з модуля :mod:`imaplib`::"

#: ../../howto/regex.rst:957
msgid ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"
msgstr ""

#: ../../howto/regex.rst:964
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"Очевидно, набагато простіше отримати ``m.group('zonem')``, замість того, щоб"
" пам'ятати, що потрібно отримати групу 9."

#: ../../howto/regex.rst:967
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group"
" name instead of the number. This is another Python extension: ``(?P=name)``"
" indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"Синтаксис зворотних посилань у такому виразі, як ``(...)\\1``, посилається "
"на номер групи. Природно, існує варіант, який використовує назву групи "
"замість номера. Це ще одне розширення Python: ``(?P=name)`` вказує на те, що"
" вміст групи з назвою *name* знову повинен бути зіставлений у поточній "
"точці. Регулярний вираз для пошуку подвоєних слів ``\\b(\\w+)\\s+\\1\\b`` "
"також можна записати як ``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"

#: ../../howto/regex.rst:974
msgid ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""

#: ../../howto/regex.rst:980
msgid "Lookahead Assertions"
msgstr "Попередні твердження"

#: ../../howto/regex.rst:982
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Іншим твердженням нульової ширини є твердження прогнозу. Попередні "
"твердження доступні як у позитивній, так і в негативній формі та виглядають "
"так:"

#: ../../howto/regex.rst:985
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:986
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current"
" location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Позитивне прогнозне твердження. Це виконується успішно, якщо регулярний "
"вираз, представлений тут ``...``, успішно збігається в поточному місці, і не"
" вдається в іншому випадку. Але після спроби виразу, що міститься, механізм "
"пошуку відповідностей взагалі не переходить; решта шаблону пробується там, "
"де почалося твердження."

#: ../../howto/regex.rst:992
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:993
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Негативне прогнозне твердження. Це протилежне до позитивного твердження; це "
"вдається, якщо вираз, що міститься, *не* збігається з поточною позицією в "
"рядку."

#: ../../howto/regex.rst:997
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base"
" name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"Щоб зробити це конкретним, давайте подивимося на випадок, де корисний погляд"
" наперед. Розглянемо простий шаблон для відповідності назві файлу та "
"розділення його на базове ім’я та розширення, розділені символом ``.``. "
"Наприклад, у ``news.rc`` ``news`` є базовою назвою, а ``rc`` є розширенням "
"назви файлу."

#: ../../howto/regex.rst:1002
msgid "The pattern to match this is quite simple:"
msgstr "Викрійка для цього досить проста:"

#: ../../howto/regex.rst:1004
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1006
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all"
" the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Зауважте, що ``.`` потрібно обробляти спеціально, оскільки це метасимвол, "
"тому він знаходиться всередині класу символів, щоб відповідати лише цьому "
"конкретному символу. Також зверніть увагу на закінчення ``$``; це додається,"
" щоб переконатися, що вся решта рядка повинна бути включена в розширення. "
"Цей регулярний вираз відповідає ``foo.bar`` і ``autoexec.bat``, "
"``sendmail.cf`` і ``printers.conf``."

#: ../../howto/regex.rst:1013
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Тепер подумайте про те, щоб трохи ускладнити проблему; що, якщо ви хочете "
"зіставити назви файлів, розширення яких не є ``bat``? Деякі неправильні "
"спроби:"

#: ../../howto/regex.rst:1016
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is"
" wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` Перша спроба вище намагається виключити ``bat``, вимагаючи,"
" щоб перший символ розширення не був ``b``. Це неправильно, оскільки шаблон "
"також не відповідає ``foo.bar``."

#: ../../howto/regex.rst:1020
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1022
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects "
"``autoexec.bat``, but it requires a three-letter extension and won't accept "
"a filename with a two-letter extension such as ``sendmail.cf``.  We'll "
"complicate the pattern again in an effort to fix it."
msgstr ""
"Вираз стає складнішим, коли ви намагаєтеся виправити перше рішення, "
"вимагаючи збігу одного з наступних випадків: перший символ розширення не є "
"``b``; другий символ не є ``a``; або третій символ не є ``t``. Це приймає "
"``foo.bar`` і відхиляє ``autoexec.bat``, але воно вимагає розширення з трьох"
" літер і не приймає ім’я файлу з дволітерним розширенням, наприклад "
"``sendmail.cf``. Ми знову ускладнимо шаблон, намагаючись його виправити."

#: ../../howto/regex.rst:1030
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1032
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"Під час третьої спроби друга та третя літери стають необов’язковими, щоб "
"дозволити відповідні розширення коротші за три символи, наприклад "
"``sendmail.cf``."

#: ../../howto/regex.rst:1036
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Зараз шаблон стає дуже складним, тому його важко прочитати та зрозуміти. "
"Гірше того, якщо проблема зміниться і ви захочете виключити і ``bat``, і "
"``exe`` як розширення, шаблон стане ще більш складним і заплутаним."

#: ../../howto/regex.rst:1041
msgid "A negative lookahead cuts through all this confusion:"
msgstr "Негативний прогноз прорізає всю цю плутанину:"

#: ../../howto/regex.rst:1043
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension"
" only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` Негативний перегляд означає: якщо вираз ``bat`` не "
"збігається на цьому етапі, спробуйте решту шаблону; якщо ``bat$`` "
"збігається, весь шаблон буде невдалим. Кінцевий ``$`` потрібен, щоб "
"переконатися, що щось на зразок ``sample.batch``, де розширення починається "
"лише з ``bat``, буде дозволено. ``[^.]*`` гарантує, що шаблон працює, якщо в"
" назві файлу є кілька крапок."

#: ../../howto/regex.rst:1050
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Виключити інше розширення імені файлу тепер легко; просто додайте його як "
"альтернативу всередину твердження. Наступний шаблон виключає імена файлів, "
"які закінчуються на ``bat`` або ``exe``:"

#: ../../howto/regex.rst:1054
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1058
msgid "Modifying Strings"
msgstr "Зміна рядків"

#: ../../howto/regex.rst:1060
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"До цього моменту ми просто виконували пошук у статичному рядку. Регулярні "
"вирази також часто використовуються для зміни рядків різними способами, "
"використовуючи такі методи шаблонів:"

#: ../../howto/regex.rst:1067
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1067
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "Розділіть рядок на список, розділивши його там, де відповідає RE"

#: ../../howto/regex.rst:1070
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1070
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr "Знайдіть усі підрядки, де відповідає RE, і замініть їх іншим рядком"

#: ../../howto/regex.rst:1073
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1073
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Робить те саме, що :meth:`!sub`, але повертає новий рядок і кількість замін"

#: ../../howto/regex.rst:1080
msgid "Splitting Strings"
msgstr "Розбиття рядків"

#: ../../howto/regex.rst:1082
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to the"
" :meth:`~str.split` method of strings but provides much more generality in "
"the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"Метод шаблону :meth:`~re.Pattern.split` розділяє рядок на частини, де "
"збігається RE, повертаючи список фрагментів. Він подібний до методу рядків "
":meth:`~str.split`, але надає набагато більшу загальність роздільників, за "
"якими можна розділяти; string :meth:`!split` підтримує лише поділ за "
"пробілами або за фіксованим рядком. Як і слід було очікувати, також існує "
"функція :func:`re.split` на рівні модуля."

#: ../../howto/regex.rst:1093
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as"
" part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Розділити *рядок* за збігами регулярного виразу. Якщо в RE використовуються "
"круглі дужки, їхній вміст також повертатиметься як частина результуючого "
"списку. Якщо *maxsplit* відмінний від нуля, виконується не більше ніж "
"*maxsplit*."

#: ../../howto/regex.rst:1098
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Ви можете обмежити кількість зроблених поділів, передавши значення "
"*maxsplit*. Якщо *maxsplit* відмінний від нуля, буде виконано щонайбільше "
"*maxsplit* розбиття, а залишок рядка повертається як останній елемент "
"списку. У наступному прикладі роздільником є будь-яка послідовність не "
"буквено-цифрових символів. ::"

#: ../../howto/regex.rst:1104
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"
msgstr ""

#: ../../howto/regex.rst:1110
msgid ""
"Sometimes you're not only interested in what the text between delimiters is,"
" but also need to know what the delimiter was.  If capturing parentheses are"
" used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Іноді вам не тільки цікаво, що таке текст між роздільниками, а й потрібно "
"знати, що це за роздільник. Якщо в RE використовуються круглі дужки, їх "
"значення також повертаються як частина списку. Порівняйте наступні виклики:"

#: ../../howto/regex.rst:1115
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"
msgstr ""

#: ../../howto/regex.rst:1122
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"Функція рівня модуля :func:`re.split` додає RE, який буде використовуватися "
"як перший аргумент, але в іншому вона така сама. ::"

#: ../../howto/regex.rst:1125
msgid ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"
msgstr ""

#: ../../howto/regex.rst:1134
msgid "Search and Replace"
msgstr "Пошук і заміна"

#: ../../howto/regex.rst:1136
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"Ще одне поширене завдання — знайти всі збіги для шаблону та замінити їх "
"іншим рядком. Метод :meth:`~re.Pattern.sub` приймає значення заміни, яке "
"може бути або рядком, або функцією, і рядок, який потрібно обробити."

#: ../../howto/regex.rst:1143
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Повертає рядок, отриманий шляхом заміни крайніх лівих неперекриваючих "
"входжень RE в *рядку* на заміну *replacement*. Якщо шаблон не знайдено, "
"*рядок* повертається без змін."

#: ../../howto/regex.rst:1147
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"Необов’язковий аргумент *count* — це максимальна кількість шаблонів, які "
"потрібно замінити; *count* має бути невід’ємним цілим числом. Значення за "
"замовчуванням 0 означає заміну всіх входжень."

#: ../../howto/regex.rst:1151
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Ось простий приклад використання методу :meth:`~re.Pattern.sub`. Він замінює"
" назви кольорів словом ``колір``::"

#: ../../howto/regex.rst:1154
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"
msgstr ""

#: ../../howto/regex.rst:1160
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a "
"2-tuple containing the new string value and the number of replacements  that"
" were performed::"
msgstr ""
"Метод :meth:`~re.Pattern.subn` виконує ту саму роботу, але повертає "
"2-кортеж, що містить нове значення рядка та кількість виконаних замін:"

#: ../../howto/regex.rst:1163
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"
msgstr ""

#: ../../howto/regex.rst:1169
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Порожні збіги замінюються лише тоді, коли вони не суміжні з попереднім "
"порожнім збігом. ::"

#: ../../howto/regex.rst:1172
msgid ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"
msgstr ""

#: ../../howto/regex.rst:1176
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Якщо *replacement* є рядком, будь-які вихідні символи зворотної косої риски "
"в ньому обробляються. Тобто ``\\n`` перетворюється на один символ нового "
"рядка, ``\\r`` перетворюється на повернення каретки і так далі. Невідомі "
"вихідні коди, такі як ``\\&`` залишаються в спокої. Зворотні посилання, такі"
" як ``\\6``, замінюються підрядком, який відповідає відповідній групі в RE. "
"Це дає змогу включати частини вихідного тексту в отриманий рядок заміни."

#: ../../howto/regex.rst:1183
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Цей приклад відповідає слову ``розділ``, за яким слідує рядок, укладений у "
"``{``, ``}``, і змінює ``розділ`` на ``підрозділ``::"

#: ../../howto/regex.rst:1186
msgid ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"
msgstr ""

#: ../../howto/regex.rst:1190
msgid ""
"There's also a syntax for referring to named groups as defined by the "
"``(?P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by "
"the group named ``name``, and  ``\\g<number>``  uses the corresponding group"
" number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous"
" in a replacement string such as ``\\g<2>0``.  (``\\20`` would be "
"interpreted as a reference to group 20, not a reference to group 2 followed "
"by the literal character ``'0'``.)  The following substitutions are all "
"equivalent, but use all three variations of the replacement string. ::"
msgstr ""
"Існує також синтаксис для посилань на іменовані групи, як визначено "
"синтаксисом ``(?P <name> ...)``. ``\\g <name>`` використовуватиме підрядок, "
"який відповідає групі з назвою ``name``, а ``\\g <number>`` використовує "
"відповідний номер групи. ``\\g <2>``, отже, еквівалентний ``\\2``, але не є "
"неоднозначним у рядку заміни, такому як ``\\g <2> 0``. (``\\20`` буде "
"інтерпретуватися як посилання на групу 20, а не як посилання на групу 2, за "
"якою йде літеральний символ ``'0''``.) Усі наступні заміни еквівалентні, але"
" використовують усі три варіанти рядок заміни. ::"

#: ../../howto/regex.rst:1199
msgid ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"
msgstr ""

#: ../../howto/regex.rst:1207
msgid ""
"*replacement* can also be a function, which gives you even more control.  If"
" *replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed a"
" :ref:`match object <match-objects>` argument for the match and can use this"
" information to compute the desired replacement string and return it."
msgstr ""
"*заміна* також може бути функцією, яка дає вам ще більше контролю. Якщо "
"*replacement* є функцією, функція викликається для кожного неперекриваючого "
"входження *pattern*. Під час кожного виклику функції передається аргумент "
":ref:`match object <match-objects>` для відповідності, і ця інформація може "
"використовуватися для обчислення потрібного рядка заміни та повернення його."

#: ../../howto/regex.rst:1213
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"У наступному прикладі функція заміни перетворює десяткові числа в "
"шістнадцяткові:"

#: ../../howto/regex.rst:1216
msgid ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"
msgstr ""

#: ../../howto/regex.rst:1225
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use"
" a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"Під час використання функції :func:`re.sub` на рівні модуля шаблон "
"передається як перший аргумент. Шаблон може бути наданий як об'єкт або як "
"рядок; якщо вам потрібно вказати прапорці регулярного виразу, ви повинні або"
" використовувати об’єкт шаблону як перший параметр, або використати "
"вбудовані модифікатори в рядок шаблону, напр. ``sub(\"(?i)b+\", \"x\", "
"\"bbbb BBBB\")`` повертає ``'x x''``."

#: ../../howto/regex.rst:1233
msgid "Common Problems"
msgstr "Загальні проблеми"

#: ../../howto/regex.rst:1235
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common"
" pitfalls."
msgstr ""
"Регулярні вирази є потужним інструментом для деяких програм, але в певному "
"сенсі їх поведінка не є інтуїтивно зрозумілою, а іноді вони поводяться не "
"так, як ви від них можете очікувати. У цьому розділі буде вказано на деякі з"
" найпоширеніших пасток."

#: ../../howto/regex.rst:1241
msgid "Use String Methods"
msgstr "Використовуйте рядкові методи"

#: ../../howto/regex.rst:1243
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any "
":mod:`re` features such as the :const:`~re.IGNORECASE` flag, then the full "
"power of regular expressions may not be required. Strings have several "
"methods for performing operations with fixed strings and they're usually "
"much faster, because the implementation is a single small C loop that's been"
" optimized for the purpose, instead of the large, more generalized regular "
"expression engine."
msgstr ""
"Іноді використання модуля :mod:`re` є помилкою. Якщо ви зіставляєте "
"фіксований рядок або одиничний клас символів і не використовуєте жодних "
"функцій :mod:`re`, таких як прапор :const:`~re.IGNORECASE`, тоді повна "
"потужність регулярних виразів може не знадобитися. Рядки мають кілька "
"методів для виконання операцій із фіксованими рядками, і зазвичай вони "
"набагато швидші, оскільки реалізація являє собою один маленький цикл C, "
"оптимізований для цієї мети, замість великого, більш узагальненого механізму"
" регулярних виразів."

#: ../../howto/regex.rst:1251
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words,"
" turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that"
" ``word`` have a word boundary on either side.  This takes the job beyond  "
":meth:`!replace`'s abilities.)"
msgstr ""
"Одним із прикладів може бути заміна одного фіксованого рядка іншим; "
"наприклад, ви можете замінити ``слово`` на ``справа``. :func:`re.sub` "
"здається функцією для цього, але розгляньте метод :meth:`~str.replace`. "
"Зауважте, що :meth:`!replace` також замінить ``word`` всередині слів, "
"перетворивши ``swordfish`` на ``sdeedfish``, але наївний RE ``word`` також "
"зробив би це. (Щоб уникнути виконання заміни на частинах слів, шаблон має "
"бути ``\\bword\\b``, щоб вимагати, щоб ``слово`` мало межу слова з обох "
"боків. Це виводить роботу за межі :meth:`!replace`.)"

#: ../../howto/regex.rst:1260
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is"
" capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"Інше поширене завдання — видалення кожного входження одного символу з рядка "
"або заміна його іншим окремим символом. Ви можете зробити це за допомогою "
"чогось на зразок ``re.sub('\\n', ' ', S)``, але :meth:`~str.translate` "
"здатний виконувати обидва завдання та буде швидшим за будь-який регулярний "
"вираз операція може бути."

#: ../../howto/regex.rst:1266
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Коротше кажучи, перш ніж звернутися до модуля :mod:`re`, подумайте, чи можна"
" вирішити вашу проблему швидшим і простішим методом рядка."

#: ../../howto/regex.rst:1271
msgid "match() versus search()"
msgstr "match() проти search()"

#: ../../howto/regex.rst:1273
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"Функція :func:`~re.match` лише перевіряє, чи RE збігається на початку рядка,"
" тоді як :func:`~re.search` скануватиме рядок вперед у пошуках "
"відповідності. Важливо пам’ятати про цю відмінність. Пам’ятайте, "
":func:`!match` повідомлятиме лише про успішний збіг, який розпочнеться з 0; "
"якщо збіг не починається з нуля, :func:`!match` *не* повідомить про це. ::"

#: ../../howto/regex.rst:1279
msgid ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:1284
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"З іншого боку, :func:`~re.search` скануватиме рядок вперед, повідомляючи про"
" перший знайдений збіг. ::"

#: ../../howto/regex.rst:1287
msgid ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"
msgstr ""

#: ../../howto/regex.rst:1292
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add "
"``.*`` to the front of your RE.  Resist this temptation and use "
":func:`re.search` instead.  The regular expression compiler does some "
"analysis of REs in order to speed up the process of looking for a match.  "
"One such analysis figures out what the first character of a match must be; "
"for example, a pattern starting with ``Crow`` must match starting with a "
"``'C'``.  The analysis lets the engine quickly scan through the string "
"looking for the starting character, only trying the full match if a ``'C'`` "
"is found."
msgstr ""
"Іноді у вас виникне спокуса продовжувати використовувати :func:`re.match` і "
"просто додати ``.*`` на початку вашого RE. Утримайтесь від цієї спокуси та "
"використовуйте замість цього :func:`re.search`. Компілятор регулярних "
"виразів виконує деякий аналіз RE, щоб прискорити процес пошуку "
"відповідності. Один такий аналіз визначає, яким повинен бути перший символ "
"відповідності; наприклад, шаблон, що починається з ``Crow``, повинен "
"збігатися з ``'C``. Аналіз дозволяє механізму швидко сканувати рядок у "
"пошуках початкового символу, лише намагаючись знайти повну відповідність, "
"якщо знайдено ``'C'``."

#: ../../howto/regex.rst:1301
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Додавання ``.*`` руйнує цю оптимізацію, вимагаючи сканування до кінця рядка,"
" а потім повернення назад, щоб знайти збіг для решти RE. Натомість "
"використовуйте :func:`re.search`."

#: ../../howto/regex.rst:1307
msgid "Greedy versus Non-Greedy"
msgstr "Жадібний проти нежадібного"

#: ../../howto/regex.rst:1309
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle"
" brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"Під час повторення регулярного виразу, як у ``a*``, результуюча дія полягає "
"в споживанні якомога більшої частини шаблону. Цей факт часто кусає вас, коли"
" ви намагаєтеся зіставити пару збалансованих розділювачів, таких як кутові "
"дужки, що оточують тег HTML. Наївний шаблон для відповідності одному тегу "
"HTML не працює через жадібний характер ``.*``. ::"

#: ../../howto/regex.rst:1315
msgid ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"
msgstr ""

#: ../../howto/regex.rst:1323
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest"
" of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"RE відповідає ``'<'`` in ``'<html>'``, а ``.*`` займає решту рядка. Однак у "
"RE залишилося ще більше, і ``>`` не може збігатися в кінці рядка, тому "
"система регулярних виразів має відстежувати символ за символом, поки не "
"знайде відповідність ``>``. Фінальний збіг поширюється від ``' <'`` in "
"``'<html> ''`` до ``'>''`` в ``' </title> ''``, що не те, чого ви хочете."

#: ../../howto/regex.rst:1330
msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, "
"``+?``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In"
" the above example, the ``'>'`` is tried immediately after the first ``'<'``"
" matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"У цьому випадку рішенням є використання нежадібних кванторів ``*?``, ``+?``,"
" ``??``, або ``{m,n}?``, які відповідають як *якомога менше* тексту. У "
"наведеному вище прикладі ``'>'`` виконується відразу після перших збігів "
"``'<'``, і коли це не вдається, система пересуває на символ за раз, "
"повторюючи ``'>'`` на кожному кроці. Це дає правильний результат:"

#: ../../howto/regex.rst:1336
msgid ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"
msgstr ""

#: ../../howto/regex.rst:1339
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(Зауважте, що синтаксичний аналіз HTML або XML за допомогою регулярних "
"виразів є болючим. Швидкі та брудні шаблони впораються з типовими випадками,"
" але HTML і XML мають особливі випадки, які порушують очевидний регулярний "
"вираз; коли ви напишете регулярний вираз, обробляє всі можливі випадки, "
"шаблони будуть *дуже* складними. Для таких завдань використовуйте модуль "
"аналізатора HTML або XML.)"

#: ../../howto/regex.rst:1347
msgid "Using re.VERBOSE"
msgstr "Використання re.VERBOSE"

#: ../../howto/regex.rst:1349
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can"
" become lengthy collections of backslashes, parentheses, and metacharacters,"
" making them difficult to read and understand."
msgstr ""
"Наразі ви, напевно, помітили, що регулярні вирази є дуже компактним записом,"
" але їх не дуже добре читати. RE помірної складності можуть перетворитися на"
" довгі набори зворотних скісних риск, круглих дужок і метасимволів, що "
"ускладнює їх читання та розуміння."

#: ../../howto/regex.rst:1354
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"Для таких RE вказівка прапорця :const:`re.VERBOSE` під час компіляції "
"регулярного виразу може бути корисною, оскільки це дозволяє форматувати "
"регулярний вираз більш чітко."

#: ../../howto/regex.rst:1358
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``,"
" or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"Прапор ``re.VERBOSE`` має кілька ефектів. Пробіли в регулярному виразі, яких"
" *не* всередині класу символів, ігноруються. Це означає, що такий вираз, як "
"``собака | cat`` еквівалентний менш читабельному ``dog|cat``, але ``[a b]`` "
"все одно відповідатиме символам ``'a'``, ``'b'`` або пробілу. Крім того, ви "
"також можете розмістити коментарі всередині RE; коментарі поширюються від "
"символу ``#`` до наступного нового рядка. При використанні з рядками в "
"потрійних лапках це дає змогу форматувати RE більш акуратно::"

#: ../../howto/regex.rst:1366
msgid ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:1375
msgid "This is far more readable than::"
msgstr "Це набагато читабельніше, ніж:"

#: ../../howto/regex.rst:1377
msgid "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"
msgstr ""

#: ../../howto/regex.rst:1381
msgid "Feedback"
msgstr "Зворотній зв'язок"

#: ../../howto/regex.rst:1383
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Регулярні вирази – це складна тема. Чи допоміг вам цей документ зрозуміти "
"їх? Чи були частини, які були незрозумілими, або проблеми, з якими ви "
"зіткнулися, які не були розглянуті тут? Якщо так, будь ласка, надішліть "
"пропозиції щодо покращення автору."

#: ../../howto/regex.rst:1388
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"Найповнішою книгою про регулярні вирази майже напевно є \"Опанування "
"регулярних виразів\" Джеффрі Фрідла, опублікована O'Reilly. На жаль, він "
"зосереджений виключно на стилях регулярних виразів Perl і Java і взагалі не "
"містить жодного матеріалу Python, тому він не буде корисним як довідник для "
"програмування на Python. (Перше видання охоплювало видалений модуль Python "
":mod:`!regex`, який вам не дуже допоможе.) Подумайте про те, щоб перевірити "
"його у своїй бібліотеці."
