# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Sorting HOW TO"
msgstr "Сортування ЯК"

msgid "Author"
msgstr "Автор"

msgid "Andrew Dalke and Raymond Hettinger"
msgstr ""

msgid "Release"
msgstr "Реліз"

msgid "0.1"
msgstr "0,1"

msgid ""
"Python lists have a built-in :meth:`list.sort` method that modifies the list "
"in-place.  There is also a :func:`sorted` built-in function that builds a "
"new sorted list from an iterable."
msgstr ""
"Списки Python мають вбудований метод :meth:`list.sort`, який змінює список "
"на місці. Існує також вбудована функція :func:`sorted`, яка створює новий "
"відсортований список із ітерованого."

msgid ""
"In this document, we explore the various techniques for sorting data using "
"Python."
msgstr ""
"У цьому документі ми досліджуємо різні техніки сортування даних за допомогою "
"Python."

msgid "Sorting Basics"
msgstr "Основи сортування"

msgid ""
"A simple ascending sort is very easy: just call the :func:`sorted` function. "
"It returns a new sorted list:"
msgstr ""
"Просте сортування за зростанням дуже просте: просто викличте функцію :func:"
"`sorted`. Він повертає новий відсортований список:"

msgid ""
"You can also use the :meth:`list.sort` method. It modifies the list in-place "
"(and returns ``None`` to avoid confusion). Usually it's less convenient "
"than :func:`sorted` - but if you don't need the original list, it's slightly "
"more efficient."
msgstr ""
"Ви також можете використовувати метод :meth:`list.sort`. Він змінює список "
"на місці (і повертає ``None``, щоб уникнути плутанини). Зазвичай це менш "
"зручно, ніж :func:`sorted`, але якщо вам не потрібен оригінальний список, це "
"трохи ефективніше."

msgid ""
"Another difference is that the :meth:`list.sort` method is only defined for "
"lists. In contrast, the :func:`sorted` function accepts any iterable."
msgstr ""
"Ще одна відмінність полягає в тому, що метод :meth:`list.sort` визначено "
"лише для списків. На відміну від цього, функція :func:`sorted` приймає будь-"
"яку ітерацію."

msgid "Key Functions"
msgstr "Ключові функції"

msgid ""
"Both :meth:`list.sort` and :func:`sorted` have a *key* parameter to specify "
"a function (or other callable) to be called on each list element prior to "
"making comparisons."
msgstr ""
"І :meth:`list.sort`, і :func:`sorted` мають параметр *key* для вказівки "
"функції (або іншого виклику), яка буде викликана для кожного елемента списку "
"перед проведенням порівнянь."

msgid "For example, here's a case-insensitive string comparison:"
msgstr "Наприклад, ось порівняння рядків без урахування регістру:"

msgid ""
"The value of the *key* parameter should be a function (or other callable) "
"that takes a single argument and returns a key to use for sorting purposes. "
"This technique is fast because the key function is called exactly once for "
"each input record."
msgstr ""
"Значення параметра *key* має бути функцією (або іншою можливістю виклику), "
"яка приймає один аргумент і повертає ключ для використання в цілях "
"сортування. Ця техніка є швидкою, оскільки ключова функція викликається "
"рівно один раз для кожного вхідного запису."

msgid ""
"A common pattern is to sort complex objects using some of the object's "
"indices as keys. For example:"
msgstr ""
"Загальним шаблоном є сортування складних об’єктів за допомогою деяких "
"індексів об’єктів як ключів. Наприклад:"

msgid ""
"The same technique works for objects with named attributes. For example:"
msgstr ""
"Така ж техніка працює для об’єктів з іменованими атрибутами. Наприклад:"

msgid "Operator Module Functions"
msgstr "Функції модуля оператора"

msgid ""
"The key-function patterns shown above are very common, so Python provides "
"convenience functions to make accessor functions easier and faster. The :mod:"
"`operator` module has :func:`~operator.itemgetter`, :func:`~operator."
"attrgetter`, and a :func:`~operator.methodcaller` function."
msgstr ""
"Наведені вище шаблони клавіш-функцій дуже поширені, тому Python надає зручні "
"функції, щоб зробити функції доступу простішими та швидшими. Модуль :mod:"
"`operator` має :func:`~operator.itemgetter`, :func:`~operator.attrgetter` і "
"функцію :func:`~operator.methodcaller`."

msgid "Using those functions, the above examples become simpler and faster:"
msgstr ""
"Використовуючи ці функції, наведені вище приклади стають простішими та "
"швидшими:"

msgid ""
"The operator module functions allow multiple levels of sorting. For example, "
"to sort by *grade* then by *age*:"
msgstr ""
"Функції модуля оператора дозволяють сортувати кілька рівнів. Наприклад, щоб "
"відсортувати за *класом*, а потім за *віком*:"

msgid "Ascending and Descending"
msgstr "Висхідний і спадний"

msgid ""
"Both :meth:`list.sort` and :func:`sorted` accept a *reverse* parameter with "
"a boolean value. This is used to flag descending sorts. For example, to get "
"the student data in reverse *age* order:"
msgstr ""
"І :meth:`list.sort`, і :func:`sorted` приймають параметр *reverse* із "
"логічним значенням. Це використовується для позначення сортування за "
"спаданням. Наприклад, щоб отримати дані про студентів у зворотному порядку "
"*віку*:"

msgid "Sort Stability and Complex Sorts"
msgstr "Стійкість сортування та складні сорти"

msgid ""
"Sorts are guaranteed to be `stable <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. That means that when multiple records have "
"the same key, their original order is preserved."
msgstr ""
"Сортування гарантовано буде `стабільним <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. Це означає, що коли кілька записів мають "
"однаковий ключ, їхній початковий порядок зберігається."

msgid ""
"Notice how the two records for *blue* retain their original order so that "
"``('blue', 1)`` is guaranteed to precede ``('blue', 2)``."
msgstr ""
"Зверніть увагу, як два записи для *blue* зберігають свій початковий порядок, "
"тому ``('blue', 1)`` гарантовано передує ``('blue', 2)``."

msgid ""
"This wonderful property lets you build complex sorts in a series of sorting "
"steps. For example, to sort the student data by descending *grade* and then "
"ascending *age*, do the *age* sort first and then sort again using *grade*:"
msgstr ""
"Ця чудова властивість дозволяє вам створювати складні сорти за допомогою "
"серії кроків сортування. Наприклад, щоб відсортувати дані студента за "
"зменшенням *оцінки*, а потім за зростанням *віку*, спочатку виконайте "
"сортування за *віком*, а потім знову за допомогою *оцінки*:"

msgid ""
"This can be abstracted out into a wrapper function that can take a list and "
"tuples of field and order to sort them on multiple passes."
msgstr ""
"Це можна абстрагувати у функцію-обгортку, яка може брати список і кортежі "
"полів і впорядковувати їх, щоб сортувати їх за кілька проходів."

msgid ""
"The `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ algorithm used in "
"Python does multiple sorts efficiently because it can take advantage of any "
"ordering already present in a dataset."
msgstr ""
"Алгоритм `Timsort <https://en.wikipedia.org/wiki/Timsort>`_, що "
"використовується в Python, ефективно виконує багаторазове сортування, "
"оскільки він може використовувати будь-яке впорядкування, яке вже є в наборі "
"даних."

msgid "The Old Way Using Decorate-Sort-Undecorate"
msgstr ""
"Старий спосіб за допомогою \"Прикрасити-Сортувати-Скасувати декорування\"."

msgid "This idiom is called Decorate-Sort-Undecorate after its three steps:"
msgstr "Ця ідіома називається Decorate-Sort-Undecorate після трьох кроків:"

msgid ""
"First, the initial list is decorated with new values that control the sort "
"order."
msgstr ""
"По-перше, початковий список прикрашається новими значеннями, які контролюють "
"порядок сортування."

msgid "Second, the decorated list is sorted."
msgstr "По-друге, оформлений список сортується."

msgid ""
"Finally, the decorations are removed, creating a list that contains only the "
"initial values in the new order."
msgstr ""
"Нарешті, декорації видаляються, створюючи список, який містить лише "
"початкові значення в новому порядку."

msgid ""
"For example, to sort the student data by *grade* using the DSU approach:"
msgstr ""
"Наприклад, щоб відсортувати дані студента за *класом* за допомогою підходу "
"DSU:"

msgid ""
"This idiom works because tuples are compared lexicographically; the first "
"items are compared; if they are the same then the second items are compared, "
"and so on."
msgstr ""
"Ця ідіома працює, тому що кортежі порівнюються лексикографічно; порівнюються "
"перші предмети; якщо вони однакові, то порівнюються другі елементи і так "
"далі."

msgid ""
"It is not strictly necessary in all cases to include the index *i* in the "
"decorated list, but including it gives two benefits:"
msgstr ""
"Не обов’язково в усіх випадках включати індекс *i* в оформлений список, але "
"це дає дві переваги:"

msgid ""
"The sort is stable -- if two items have the same key, their order will be "
"preserved in the sorted list."
msgstr ""
"Сортування є стабільним — якщо два елементи мають однаковий ключ, їхній "
"порядок буде збережено у відсортованому списку."

msgid ""
"The original items do not have to be comparable because the ordering of the "
"decorated tuples will be determined by at most the first two items. So for "
"example the original list could contain complex numbers which cannot be "
"sorted directly."
msgstr ""
"Оригінальні елементи не обов’язково мають бути порівнянними, тому що порядок "
"оформлених кортежів визначатиметься щонайбільше першими двома елементами. "
"Так, наприклад, вихідний список може містити комплексні числа, які неможливо "
"відсортувати безпосередньо."

msgid ""
"Another name for this idiom is `Schwartzian transform <https://en.wikipedia."
"org/wiki/Schwartzian_transform>`_\\, after Randal L. Schwartz, who "
"popularized it among Perl programmers."
msgstr ""
"Інша назва цієї ідіоми — `перетворення Шварца <https://en.wikipedia.org/wiki/"
"Schwartzian_transform>`_\\, на честь Рендала Л. Шварца, який популяризував "
"її серед програмістів на Perl."

msgid ""
"Now that Python sorting provides key-functions, this technique is not often "
"needed."
msgstr ""
"Тепер, коли сортування Python надає ключові функції, ця техніка не часто "
"потрібна."

msgid "The Old Way Using the *cmp* Parameter"
msgstr "Старий спосіб з використанням параметра *cmp*"

msgid ""
"Many constructs given in this HOWTO assume Python 2.4 or later. Before that, "
"there was no :func:`sorted` builtin and :meth:`list.sort` took no keyword "
"arguments. Instead, all of the Py2.x versions supported a *cmp* parameter to "
"handle user specified comparison functions."
msgstr ""
"Багато конструкцій, наведених у цьому HOWTO, припускають Python 2.4 або "
"новішої версії. До цього не було вбудованого :func:`sorted`, а :meth:`list."
"sort` не приймав ключових аргументів. Замість цього всі версії Py2.x "
"підтримували параметр *cmp* для обробки визначених користувачем функцій "
"порівняння."

msgid ""
"In Py3.0, the *cmp* parameter was removed entirely (as part of a larger "
"effort to simplify and unify the language, eliminating the conflict between "
"rich comparisons and the :meth:`__cmp__` magic method)."
msgstr ""
"У Py3.0 параметр *cmp* було повністю видалено (як частина більших зусиль зі "
"спрощення та уніфікації мови, усунення конфлікту між розширеними "
"порівняннями та магічним методом :meth:`__cmp__`)."

msgid ""
"In Py2.x, sort allowed an optional function which can be called for doing "
"the comparisons. That function should take two arguments to be compared and "
"then return a negative value for less-than, return zero if they are equal, "
"or return a positive value for greater-than. For example, we can do:"
msgstr ""
"У Py2.x сортування допускає додаткову функцію, яку можна викликати для "
"порівняння. Ця функція має приймати два аргументи для порівняння, а потім "
"повертати від’ємне значення для меншого, повертати нуль, якщо вони рівні, "
"або повертати додатне значення для більшого. Наприклад, ми можемо зробити:"

msgid "Or you can reverse the order of comparison with:"
msgstr "Або ви можете змінити порядок порівняння:"

msgid ""
"When porting code from Python 2.x to 3.x, the situation can arise when you "
"have the user supplying a comparison function and you need to convert that "
"to a key function. The following wrapper makes that easy to do:"
msgstr ""
"Під час перенесення коду з Python 2.x на 3.x може виникнути ситуація, коли "
"користувач надає функцію порівняння, а вам потрібно перетворити її на "
"ключову функцію. Це легко зробити за допомогою наступної оболонки:"

msgid "To convert to a key function, just wrap the old comparison function:"
msgstr ""
"Щоб перетворити на ключову функцію, просто оберніть стару функцію порівняння:"

msgid ""
"In Python 3.2, the :func:`functools.cmp_to_key` function was added to the :"
"mod:`functools` module in the standard library."
msgstr ""
"У Python 3.2 функція :func:`functools.cmp_to_key` була додана до модуля :mod:"
"`functools` стандартної бібліотеки."

msgid "Odd and Ends"
msgstr ""

msgid ""
"For locale aware sorting, use :func:`locale.strxfrm` for a key function or :"
"func:`locale.strcoll` for a comparison function."
msgstr ""
"Для сортування з урахуванням локалі використовуйте :func:`locale.strxfrm` "
"для функції ключа або :func:`locale.strcoll` для функції порівняння."

msgid ""
"The *reverse* parameter still maintains sort stability (so that records with "
"equal keys retain the original order). Interestingly, that effect can be "
"simulated without the parameter by using the builtin :func:`reversed` "
"function twice:"
msgstr ""
"Параметр *reverse* усе ще підтримує стабільність сортування (щоб записи з "
"однаковими ключами зберігали вихідний порядок). Цікаво, що цей ефект можна "
"моделювати без параметра, використовуючи двічі вбудовану функцію :func:"
"`reversed`:"

msgid ""
"The sort routines use ``<`` when making comparisons between two objects. So, "
"it is easy to add a standard sort order to a class by defining an :meth:"
"`__lt__` method:"
msgstr ""
"Процедури сортування використовують ``<`` під час порівняння між двома "
"об’єктами. Отже, легко додати стандартний порядок сортування до класу, "
"визначивши метод :meth:`__lt__`:"

msgid ""
"However, note that ``<`` can fall back to using :meth:`__gt__` if :meth:"
"`__lt__` is not implemented (see :func:`object.__lt__`)."
msgstr ""
"Однак зауважте, що ``<`` може повернутися до використання :meth:`__gt__`, "
"якщо :meth:`__lt__` не реалізовано (див. :func:`object.__lt__`)."

msgid ""
"Key functions need not depend directly on the objects being sorted. A key "
"function can also access external resources. For instance, if the student "
"grades are stored in a dictionary, they can be used to sort a separate list "
"of student names:"
msgstr ""
"Ключові функції не повинні безпосередньо залежати від об’єктів, які "
"сортуються. Ключова функція також може отримувати доступ до зовнішніх "
"ресурсів. Наприклад, якщо оцінки студентів зберігаються в словнику, їх можна "
"використовувати для сортування окремого списку імен студентів:"
