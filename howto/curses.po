# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../howto/curses.rst:5
msgid "Curses Programming with Python"
msgstr "Програмування Curses на Python"

#: ../../howto/curses.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/curses.rst:9
msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

#: ../../howto/curses.rst:0
msgid "Release"
msgstr "Реліз"

#: ../../howto/curses.rst:10
msgid "2.04"
msgstr "2.04"

#: ../../howto/curses.rst-1
msgid "Abstract"
msgstr "Анотація"

#: ../../howto/curses.rst:15
msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr ""
"У цьому документі описано, як використовувати модуль розширення "
":mod:`curses` для керування відображеннями в текстовому режимі."

#: ../../howto/curses.rst:20
msgid "What is curses?"
msgstr "Що таке прокляття?"

#: ../../howto/curses.rst:22
msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals include "
"VT100s, the Linux console, and the simulated terminal provided by various "
"programs.  Display terminals support various control codes to perform common"
" operations such as moving the cursor, scrolling the screen, and erasing "
"areas.  Different terminals use widely differing codes, and often have their"
" own minor quirks."
msgstr ""
"Бібліотека curses надає незалежне від терміналу засіб малювання екрану та "
"керування клавіатурою для текстових терміналів; такі термінали включають "
"VT100s, консоль Linux і імітований термінал, що надається різними "
"програмами. Дисплейні термінали підтримують різні керуючі коди для виконання"
" типових операцій, таких як переміщення курсору, прокручування екрана та "
"стирання областей. Різні термінали використовують дуже різні коди та часто "
"мають власні незначні особливості."

#: ../../howto/curses.rst:30
msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's true "
"that character-cell display terminals are an obsolete technology, but there "
"are niches in which being able to do fancy things with them are still "
"valuable.  One niche is on small-footprint or embedded Unixes that don't run"
" an X server.  Another is tools such as OS installers and kernel "
"configurators that may have to run before any graphical support is "
"available."
msgstr ""
"У світі графічних дисплеїв хтось може запитати \"навіщо турбуватися\"? Це "
"правда, що дисплеї з символьними комірками є застарілою технологією, але є "
"ніші, в яких можливість робити з ними фантастичні речі все ще цінна. Одна "
"ніша займає малогабаритні або вбудовані системи Unix, на яких не працює "
"X-сервер. Інші інструменти, такі як інсталятори ОС і конфігуратори ядра, "
"які, можливо, доведеться запустити, перш ніж буде доступна будь-яка графічна"
" підтримка."

#: ../../howto/curses.rst:38
msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the "
"curses library will figure out what control codes need to be sent to the "
"terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need such"
" features, consider a user interface library such as :pypi:`Urwid`."
msgstr ""

#: ../../howto/curses.rst:48
msgid ""
"The curses library was originally written for BSD Unix; the later System V "
"versions of Unix from AT&T added many enhancements and new functions. BSD "
"curses is no longer maintained, having been replaced by ncurses, which is an"
" open-source implementation of the AT&T interface.  If you're using an open-"
"source Unix such as Linux or FreeBSD, your system almost certainly uses "
"ncurses.  Since most current commercial Unix versions are based on System V "
"code, all the functions described here will probably be available.  The "
"older versions of curses carried by some proprietary Unixes may not support "
"everything, though."
msgstr ""
"Бібліотека curses спочатку була написана для BSD Unix; пізніші версії System"
" V Unix від AT&T додали багато вдосконалень і нових функцій. BSD curses "
"більше не підтримується, їх замінив ncurses, який є реалізацією інтерфейсу "
"AT&T з відкритим кодом. Якщо ви використовуєте Unix з відкритим кодом, "
"наприклад Linux або FreeBSD, ваша система майже напевно використовує "
"ncurses. Оскільки більшість сучасних комерційних версій Unix базується на "
"коді System V, усі описані тут функції, ймовірно, будуть доступні. Однак "
"старіші версії curses, які містяться в деяких пропрієтарних системах Unix, "
"можуть не підтримувати все."

#: ../../howto/curses.rst:58
msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  A "
"ported version called :pypi:`UniCurses` is available."
msgstr ""

#: ../../howto/curses.rst:63
msgid "The Python curses module"
msgstr "Модуль проклинань Python"

#: ../../howto/curses.rst:65
msgid ""
"The Python module is a fairly simple wrapper over the C functions provided "
"by curses; if you're already familiar with curses programming in C, it's "
"really easy to transfer that knowledge to Python.  The biggest difference is"
" that the Python interface makes things simpler by merging different C "
"functions such as :c:func:`!addstr`, :c:func:`!mvaddstr`, and "
":c:func:`!mvwaddstr` into a single :meth:`~curses.window.addstr` method.  "
"You'll see this covered in more detail later."
msgstr ""

#: ../../howto/curses.rst:73
msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses and "
"Python. It doesn't attempt to be a complete guide to the curses API; for "
"that, see the Python library guide's section on ncurses, and the C manual "
"pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"Цей HOWTO є вступом до написання програм у текстовому режимі за допомогою "
"curses і Python. Він не намагається бути повним посібником з curses API; для"
" цього дивіться розділ посібника з бібліотеки Python про ncurses і сторінки "
"посібника C для ncurses. Однак це дасть вам основні ідеї."

#: ../../howto/curses.rst:80
msgid "Starting and ending a curses application"
msgstr "Запуск і завершення програми curses"

#: ../../howto/curses.rst:82
msgid ""
"Before doing anything, curses must be initialized.  This is done by calling "
"the :func:`~curses.initscr` function, which will determine the terminal "
"type, send any required setup codes to the terminal, and create various "
"internal data structures.  If successful, :func:`!initscr` returns a window "
"object representing the entire screen; this is usually called ``stdscr`` "
"after the name of the corresponding C variable. ::"
msgstr ""

#: ../../howto/curses.rst:90
msgid ""
"import curses\n"
"stdscr = curses.initscr()"
msgstr ""

#: ../../howto/curses.rst:93
msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under certain"
" circumstances.  This requires calling the :func:`~curses.noecho` function. "
"::"
msgstr ""
"Зазвичай програми curses вимикають автоматичне відлуння клавіш на екрані, "
"щоб мати можливість читати клавіші та відображати їх лише за певних "
"обставин. Для цього потрібно викликати функцію :func:`~curses.noecho`. ::"

#: ../../howto/curses.rst:98
msgid "curses.noecho()"
msgstr ""

#: ../../howto/curses.rst:100
msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr ""
"Додаткам також зазвичай потрібно миттєво реагувати на натискання клавіш, не "
"вимагаючи натискання клавіші Enter; це називається режимом cbreak, на "
"відміну від звичайного режиму буферизованого введення. ::"

#: ../../howto/curses.rst:104
msgid "curses.cbreak()"
msgstr ""

#: ../../howto/curses.rst:106
msgid ""
"Terminals usually return special keys, such as the cursor keys or navigation"
" keys such as Page Up and Home, as a multibyte escape sequence.  While you "
"could write your application to expect such sequences and process them "
"accordingly, curses can do it for you, returning a special value such as "
":const:`curses.KEY_LEFT`.  To get curses to do the job, you'll have to "
"enable keypad mode. ::"
msgstr ""
"Термінали зазвичай повертають спеціальні клавіші, такі як клавіші керування "
"курсором або навігаційні клавіші, такі як Page Up і Home, як багатобайтову "
"escape-послідовність. Хоча ви можете написати свою програму так, щоб "
"очікувати такі послідовності та обробляти їх відповідно, curses може зробити"
" це за вас, повертаючи спеціальне значення, наприклад "
":const:`curses.KEY_LEFT`. Щоб змусити прокляття виконувати роботу, вам "
"потрібно буде ввімкнути режим клавіатури. ::"

#: ../../howto/curses.rst:113
msgid "stdscr.keypad(True)"
msgstr ""

#: ../../howto/curses.rst:115
msgid ""
"Terminating a curses application is much easier than starting one. You'll "
"need to call::"
msgstr ""
"Завершити роботу програми curses набагато легше, ніж розпочати її. Вам "
"потрібно зателефонувати::"

#: ../../howto/curses.rst:118
msgid ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"
msgstr ""

#: ../../howto/curses.rst:122
msgid ""
"to reverse the curses-friendly terminal settings. Then call the "
":func:`~curses.endwin` function to restore the terminal to its original "
"operating mode. ::"
msgstr ""
"щоб змінити налаштування терміналу, зручні для curses. Потім викличте "
"функцію :func:`~curses.endwin`, щоб відновити термінал до вихідного режиму "
"роботи. ::"

#: ../../howto/curses.rst:126
msgid "curses.endwin()"
msgstr ""

#: ../../howto/curses.rst:128
msgid ""
"A common problem when debugging a curses application is to get your terminal"
" messed up when the application dies without restoring the terminal to its "
"previous state.  In Python this commonly happens when your code is buggy and"
" raises an uncaught exception.  Keys are no longer echoed to the screen when"
" you type them, for example, which makes using the shell difficult."
msgstr ""
"Поширеною проблемою під час налагодження програми curses є псування "
"терміналу, коли програма вимикається без відновлення попереднього стану "
"терміналу. У Python це зазвичай трапляється, коли ваш код має помилки та "
"викликає неперехоплений виняток. Наприклад, клавіші більше не відтворюються "
"на екрані, коли ви їх вводите, що ускладнює використання оболонки."

#: ../../howto/curses.rst:134
msgid ""
"In Python you can avoid these complications and make debugging much easier "
"by importing the :func:`curses.wrapper` function and using it like this::"
msgstr ""
"У Python ви можете уникнути цих ускладнень і значно полегшити налагодження, "
"імпортувавши функцію :func:`curses.wrapper` і використовуючи її таким "
"чином::"

#: ../../howto/curses.rst:137
msgid ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # Clear screen\n"
"    stdscr.clear()\n"
"\n"
"    # This raises ZeroDivisionError when i == 10.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"    stdscr.refresh()\n"
"    stdscr.getkey()\n"
"\n"
"wrapper(main)"
msgstr ""

#: ../../howto/curses.rst:153
msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the "
"initializations described above, also initializing colors if color support "
"is present.  :func:`!wrapper` then runs your provided callable. Once the "
"callable returns, :func:`!wrapper` will restore the original state of the "
"terminal.  The callable is called inside a :keyword:`try`...\\ "
":keyword:`except` that catches exceptions, restores the state of the "
"terminal, and then re-raises the exception.  Therefore your terminal won't "
"be left in a funny state on exception and you'll be able to read the "
"exception's message and traceback."
msgstr ""

#: ../../howto/curses.rst:165
msgid "Windows and Pads"
msgstr "Вікна та колодки"

#: ../../howto/curses.rst:167
msgid ""
"Windows are the basic abstraction in curses.  A window object represents a "
"rectangular area of the screen, and supports methods to display text, erase "
"it, allow the user to input strings, and so forth."
msgstr ""
"Вікна є основною абстракцією в curses. Об’єкт вікна представляє прямокутну "
"область екрана та підтримує методи відображення тексту, його стирання, "
"дозволу користувачеві вводити рядки тощо."

#: ../../howto/curses.rst:171
msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is a "
"window object that covers the entire screen.  Many programs may need only "
"this single window, but you might wish to divide the screen into smaller "
"windows, in order to redraw or clear them separately. The "
":func:`~curses.newwin` function creates a new window of a given size, "
"returning the new window object. ::"
msgstr ""
"Об’єкт ``stdscr``, що повертається функцією :func:`~curses.initscr`, є "
"об’єктом вікна, що покриває весь екран. Багатьом програмам може знадобитися "
"лише це одне вікно, але ви можете розділити екран на менші вікна, щоб "
"перемалювати або очистити їх окремо. Функція :func:`~curses.newwin` створює "
"нове вікно заданого розміру, повертаючи новий об’єкт вікна. ::"

#: ../../howto/curses.rst:178
msgid ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"
msgstr ""

#: ../../howto/curses.rst:182
msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates are "
"always passed in the order *y,x*, and the top-left corner of a window is "
"coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate "
"difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things now."
msgstr ""
"Зверніть увагу, що система координат, яка використовується в curses, є "
"незвичною. Координати завжди передаються в порядку *y,x*, а верхній лівий "
"кут вікна є координатою (0,0). Це порушує звичайну угоду щодо обробки "
"координат, де координата *x* стоїть першою. Це прикра відмінність від "
"більшості інших комп’ютерних програм, але вона була частиною прокляття "
"відтоді, як була написана, і зараз надто пізно щось змінювати."

#: ../../howto/curses.rst:190
msgid ""
"Your application can determine the size of the screen by using the "
":data:`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* and"
" *x* sizes.  Legal coordinates will then extend from ``(0,0)`` to "
"``(curses.LINES - 1, curses.COLS - 1)``."
msgstr ""
"Ваша програма може визначити розмір екрана за допомогою змінних "
":data:`curses.LINES` і :data:`curses.COLS` для отримання розмірів *y* і *x*."
" Тоді юридичні координати розширюватимуться від ``(0,0)`` до ``(curses.LINES"
" - 1, curses.COLS - 1)``."

#: ../../howto/curses.rst:195
msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the "
":meth:`~curses.window.refresh` method of window objects to update the "
"screen."
msgstr ""
"Коли ви викликаєте метод для відображення або стирання тексту, ефект не "
"відразу відображається на дисплеї. Натомість ви повинні викликати метод "
":meth:`~curses.window.refresh` об’єктів вікна, щоб оновити екран."

#: ../../howto/curses.rst:200
msgid ""
"This is because curses was originally written with slow 300-baud terminal "
"connections in mind; with these terminals, minimizing the time required to "
"redraw the screen was very important.  Instead curses accumulates changes to"
" the screen and displays them in the most efficient manner when you call "
":meth:`!refresh`.  For example, if your program displays some text in a "
"window and then clears the window, there's no need to send the original text"
" because they're never visible."
msgstr ""

#: ../../howto/curses.rst:209
msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry of "
"activity, and then pause waiting for a keypress or some other action on the "
"part of the user.  All you have to do is to be sure that the screen has been"
" redrawn before pausing to wait for user input, by first calling "
":meth:`!stdscr.refresh` or the :meth:`!refresh` method of some other "
"relevant window."
msgstr ""

#: ../../howto/curses.rst:217
msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. Creating "
"a pad requires the pad's height and width, while refreshing a pad requires "
"giving the coordinates of the on-screen area where a subsection of the pad "
"will be displayed.  ::"
msgstr ""
"Колодка — окремий випадок вікна; він може бути більшим, ніж фактичний екран "
"дисплея, і одночасно відображатися лише частина панелі. Щоб створити "
"блокнот, потрібно вказати його висоту та ширину, тоді як для оновлення "
"блокнота потрібно вказати координати області на екрані, де відображатиметься"
" його підрозділ. ::"

#: ../../howto/curses.rst:223
msgid ""
"pad = curses.newpad(100, 100)\n"
"# These loops fill the pad with letters; addch() is\n"
"# explained in the next section\n"
"for y in range(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# Displays a section of the pad in the middle of the screen.\n"
"# (0,0) : coordinate of upper-left corner of pad area to display.\n"
"# (5,5) : coordinate of upper-left corner of window area to be filled\n"
"#         with pad content.\n"
"# (20, 75) : coordinate of lower-right corner of window area to be\n"
"#          : filled with pad content.\n"
"pad.refresh( 0,0, 5,5, 20,75)"
msgstr ""

#: ../../howto/curses.rst:238
msgid ""
"The :meth:`!refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the pad.  "
"Beyond that difference, pads are exactly like ordinary windows and support "
"the same methods."
msgstr ""

#: ../../howto/curses.rst:244
msgid ""
"If you have multiple windows and pads on screen there is a more efficient "
"way to update the screen and prevent annoying screen flicker as each part of"
" the screen gets updated.  :meth:`!refresh` actually does two things:"
msgstr ""

#: ../../howto/curses.rst:249
msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to update"
" an underlying data structure representing the desired state of the screen."
msgstr ""
"Викликає метод :meth:`~curses.window.noutrefresh` кожного вікна, щоб оновити"
" базову структуру даних, що представляє потрібний стан екрана."

#: ../../howto/curses.rst:252
msgid ""
"Calls the function :func:`~curses.doupdate` function to change the physical "
"screen to match the desired state recorded in the data structure."
msgstr ""
"Викликає функцію :func:`~curses.doupdate`, щоб змінити фізичний екран "
"відповідно до потрібного стану, записаного в структурі даних."

#: ../../howto/curses.rst:255
msgid ""
"Instead you can call :meth:`!noutrefresh` on a number of windows to update "
"the data structure, and then call :func:`!doupdate` to update the screen."
msgstr ""

#: ../../howto/curses.rst:261
msgid "Displaying Text"
msgstr "Відображення тексту"

#: ../../howto/curses.rst:263
msgid ""
"From a C programmer's point of view, curses may sometimes look like a twisty"
" maze of functions, all subtly different.  For example, :c:func:`!addstr` "
"displays a string at the current cursor location in the ``stdscr`` window, "
"while :c:func:`!mvaddstr` moves to a given y,x coordinate first before "
"displaying the string. :c:func:`!waddstr` is just like :c:func:`!addstr`, "
"but allows specifying a window to use instead of using ``stdscr`` by "
"default. :c:func:`!mvwaddstr` allows specifying both a window and a "
"coordinate."
msgstr ""

#: ../../howto/curses.rst:272
msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is a "
"window object like any other, and methods such as "
":meth:`~curses.window.addstr` accept multiple argument forms.  Usually there"
" are four different forms."
msgstr ""
"На щастя, інтерфейс Python приховує всі ці деталі. ``stdscr`` є віконним "
"об’єктом, як і будь-який інший, і такі методи, як "
":meth:`~curses.window.addstr` приймають кілька форм аргументів. Зазвичай є "
"чотири різні форми."

#: ../../howto/curses.rst:278
msgid "Form"
msgstr "Форма"

#: ../../howto/curses.rst:278 ../../howto/curses.rst:346
msgid "Description"
msgstr "опис"

#: ../../howto/curses.rst:280
msgid "*str* or *ch*"
msgstr "*str* або *ch*"

#: ../../howto/curses.rst:280
msgid "Display the string *str* or character *ch* at the current position"
msgstr "Відобразити рядок *str* або символ *ch* у поточній позиції"

#: ../../howto/curses.rst:283
msgid "*str* or *ch*, *attr*"
msgstr "*str* або *ch*, *attr*"

#: ../../howto/curses.rst:283
msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the "
"current position"
msgstr ""
"Відобразити рядок *str* або символ *ch*, використовуючи атрибут *attr* у "
"поточній позиції"

#: ../../howto/curses.rst:287
msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*, *x*, *str* або *ch*"

#: ../../howto/curses.rst:287
msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr "Перейдіть до позиції *y,x* у вікні та відобразіть *str* або *ch*"

#: ../../howto/curses.rst:290
msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*, *x*, *str* або *ch*, *attr*"

#: ../../howto/curses.rst:290
msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, using "
"attribute *attr*"
msgstr ""
"Перейдіть до позиції *y,x* у вікні та відобразіть *str* або *ch*, "
"використовуючи атрибут *attr*"

#: ../../howto/curses.rst:294
msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more detail "
"in the next subsection."
msgstr ""
"Атрибути дозволяють відображати текст у виділених формах, наприклад жирним "
"шрифтом, підкресленням, зворотним кодом або кольором. Вони будуть пояснені "
"більш детально в наступному підрозділі."

#: ../../howto/curses.rst:299
msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or bytestring"
" as the value to be displayed.  The contents of bytestrings are sent to the "
"terminal as-is.  Strings are encoded to bytes using the value of the "
"window's :attr:`~window.encoding` attribute; this defaults to the default "
"system encoding as returned by :func:`locale.getencoding`."
msgstr ""

#: ../../howto/curses.rst:305
msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ""
"Методи :meth:`~curses.window.addch` приймають символ, який може бути рядком "
"довжини 1, байтовим рядком довжини 1 або цілим числом."

#: ../../howto/curses.rst:308
msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box (handy "
"for drawing borders).  You can also use the appropriate Unicode character."
msgstr ""
"Константи надаються для символів розширення; ці константи є цілими числами, "
"більшими за 255. Наприклад, :const:`ACS_PLMINUS` — це символ +/-, а "
":const:`ACS_ULCORNER` — верхній лівий кут прямокутника (зручно для малювання"
" меж). Ви також можете використовувати відповідний символ Unicode."

#: ../../howto/curses.rst:314
msgid ""
"Windows remember where the cursor was left after the last operation, so if "
"you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always display"
" a flashing cursor, you may want to ensure that the cursor is positioned in "
"some location where it won't be distracting; it can be confusing to have the"
" cursor blinking at some apparently random location."
msgstr ""
"Windows запам’ятовує, де був залишений курсор після останньої операції, "
"тому, якщо ви пропустите координати *y,x*, рядок або символ "
"відображатиметься там, де зупинилася остання операція. Ви також можете "
"перемістити курсор за допомогою методу ``move(y,x)``. Оскільки деякі "
"термінали завжди відображають блимаючий курсор, ви можете переконатися, що "
"курсор розташований у певному місці, де він не буде відволікати; блимання "
"курсора в певному, начебто випадковому, місці може бути збентеженим."

#: ../../howto/curses.rst:322
msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym for "
":func:`~curses.curs_set`.  When *bool* is true, the curses library will "
"attempt to suppress the flashing cursor, and you won't need to worry about "
"leaving it in odd locations."
msgstr ""
"Якщо вашій програмі зовсім не потрібен мерехтливий курсор, ви можете "
"викликати ``curs_set(False)``, щоб зробити його невидимим. Для сумісності зі"
" старішими версіями curses існує функція ``leaveok(bool)``, яка є синонімом "
":func:`~curses.curs_set`. Якщо *bool* має значення true, бібліотека curses "
"намагатиметься придушити миготливий курсор, і вам не потрібно буде "
"турбуватися про те, щоб залишити його в незвичних місцях."

#: ../../howto/curses.rst:331
msgid "Attributes and Color"
msgstr "Атрибути та колір"

#: ../../howto/curses.rst:333
msgid ""
"Characters can be displayed in different ways.  Status lines in a text-based"
" application are commonly shown in reverse video, or a text viewer may need "
"to highlight certain words.  curses supports this by allowing you to specify"
" an attribute for each cell on the screen."
msgstr ""
"Символи можуть відображатися різними способами. Рядки стану в текстовій "
"програмі зазвичай відображаються у зворотному відео, або програмі перегляду "
"тексту може знадобитися виділити певні слова. curses підтримує це, "
"дозволяючи вам вказати атрибут для кожної клітинки на екрані."

#: ../../howto/curses.rst:338
msgid ""
"An attribute is an integer, each bit representing a different attribute.  "
"You can try to display text with multiple attribute bits set, but curses "
"doesn't guarantee that all the possible combinations are available, or that "
"they're all visually distinct.  That depends on the ability of the terminal "
"being used, so it's safest to stick to the most commonly available "
"attributes, listed here."
msgstr ""
"Атрибут — це ціле число, кожен біт якого представляє окремий атрибут. Ви "
"можете спробувати відобразити текст з кількома встановленими бітами "
"атрибутів, але curses не гарантує, що всі можливі комбінації доступні, або "
"що всі вони візуально відрізняються. Це залежить від можливостей "
"використовуваного терміналу, тому найбезпечніше дотримуватися найпоширеніших"
" атрибутів, перелічених тут."

#: ../../howto/curses.rst:346
msgid "Attribute"
msgstr "Атрибут"

#: ../../howto/curses.rst:348
msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLINK`"

#: ../../howto/curses.rst:348
msgid "Blinking text"
msgstr "Миготливий текст"

#: ../../howto/curses.rst:350
msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

#: ../../howto/curses.rst:350
msgid "Extra bright or bold text"
msgstr "Дуже яскравий або жирний текст"

#: ../../howto/curses.rst:352
msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

#: ../../howto/curses.rst:352
msgid "Half bright text"
msgstr "Наполовину яскравий текст"

#: ../../howto/curses.rst:354
msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

#: ../../howto/curses.rst:354
msgid "Reverse-video text"
msgstr "Зворотний відеотекст"

#: ../../howto/curses.rst:356
msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

#: ../../howto/curses.rst:356
msgid "The best highlighting mode available"
msgstr "Найкращий доступний режим підсвічування"

#: ../../howto/curses.rst:358
msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

#: ../../howto/curses.rst:358
msgid "Underlined text"
msgstr "Підкреслений текст"

#: ../../howto/curses.rst:361
msgid ""
"So, to display a reverse-video status line on the top line of the screen, "
"you could code::"
msgstr ""
"Отже, щоб відобразити рядок стану реверсивного відео у верхньому рядку "
"екрана, ви можете закодувати:"

#: ../../howto/curses.rst:364
msgid ""
"stdscr.addstr(0, 0, \"Current mode: Typing mode\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"
msgstr ""

#: ../../howto/curses.rst:368
msgid ""
"The curses library also supports color on those terminals that provide it. "
"The most common such terminal is probably the Linux console, followed by "
"color xterms."
msgstr ""
"Бібліотека curses також підтримує колір на тих терміналах, які його надають."
" Найпоширенішим таким терміналом, ймовірно, є консоль Linux, за якою "
"слідують кольорові xterms."

#: ../../howto/curses.rst:372
msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon "
"after calling :func:`~curses.initscr`, to initialize the default color set "
"(the :func:`curses.wrapper` function does this automatically).  Once that's "
"done, the :func:`~curses.has_colors` function returns TRUE if the terminal "
"in use can actually display color.  (Note: curses uses the American spelling"
" 'color', instead of the Canadian/British spelling 'colour'.  If you're used"
" to the British spelling, you'll have to resign yourself to misspelling it "
"for the sake of these functions.)"
msgstr ""
"Щоб використовувати колір, ви повинні викликати функцію "
":func:`~curses.start_color` відразу після виклику :func:`~curses.initscr`, "
"щоб ініціалізувати набір кольорів за замовчуванням (це робить функція "
":func:`curses.wrapper` автоматично). Після цього функція "
":func:`~curses.has_colors` повертає TRUE, якщо термінал, що "
"використовується, справді може відображати колір. (Примітка: curses "
"використовує американське написання \"колір\" замість канадсько-британського"
" написання \"колір\". Якщо ви звикли до британського написання, вам "
"доведеться змиритися з орфографічною помилкою заради цих функцій. )"

#: ../../howto/curses.rst:382
msgid ""
"The curses library maintains a finite number of color pairs, containing a "
"foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the "
":func:`~curses.color_pair` function; this can be bitwise-OR'ed with other "
"attributes such as :const:`A_REVERSE`, but again, such combinations are not "
"guaranteed to work on all terminals."
msgstr ""
"Бібліотека curses підтримує кінцеву кількість пар кольорів, що містять колір"
" переднього плану (або тексту) і колір фону. Ви можете отримати значення "
"атрибута, що відповідає парі кольорів, за допомогою функції "
":func:`~curses.color_pair`; це можна об’єднати порозрядним АБО з іншими "
"атрибутами, такими як :const:`A_REVERSE`, але знову ж таки, такі комбінації "
"не гарантовано працюють на всіх терміналах."

#: ../../howto/curses.rst:389
msgid "An example, which displays a line of text using color pair 1::"
msgstr "Приклад, який відображає рядок тексту за допомогою пари кольорів 1::"

#: ../../howto/curses.rst:391
msgid ""
"stdscr.addstr(\"Pretty text\", curses.color_pair(1))\n"
"stdscr.refresh()"
msgstr ""

#: ../../howto/curses.rst:394
msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of color "
"pair *n*, to foreground color f and background color b.  Color pair 0 is "
"hard-wired to white on black, and cannot be changed."
msgstr ""
"Як я вже говорив раніше, пара кольорів складається з кольору переднього "
"плану та кольору фону. Функція ``init_pair(n, f, b)`` змінює визначення пари"
" кольорів *n* на колір переднього плану f і колір фону b. Пара кольорів 0 "
"жорстко з’єднана з білим на чорному, і її неможливо змінити."

#: ../../howto/curses.rst:399
msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors when"
" it activates color mode.  They are: 0:black, 1:red, 2:green, 3:yellow, "
"4:blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` module defines "
"named constants for each of these colors: :const:`curses.COLOR_BLACK`, "
":const:`curses.COLOR_RED`, and so forth."
msgstr ""
"Кольори пронумеровані, і :func:`start_color` ініціалізує 8 основних "
"кольорів, коли він активує колірний режим. Це: 0:чорний, 1:червоний, "
"2:зелений, 3:жовтий, 4:синій, 5:пурпурний, 6:блакитний і 7:білий. Модуль "
":mod:`curses` визначає іменовані константи для кожного з цих кольорів: "
":const:`curses.COLOR_BLACK`, :const:`curses.COLOR_RED` і так далі."

#: ../../howto/curses.rst:405
msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr ""
"Давайте все це разом. Щоб змінити колір 1 на червоний текст на білому фоні, "
"ви повинні викликати:"

#: ../../howto/curses.rst:408
msgid "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"
msgstr ""

#: ../../howto/curses.rst:410
msgid ""
"When you change a color pair, any text already displayed using that color "
"pair will change to the new colors.  You can also display new text in this "
"color with::"
msgstr ""
"Коли ви змінюєте пару кольорів, будь-який текст, який уже відображається за "
"допомогою цієї пари кольорів, зміниться на нові кольори. Ви також можете "
"відобразити новий текст у цьому кольорі за допомогою:"

#: ../../howto/curses.rst:414
msgid "stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1))"
msgstr ""

#: ../../howto/curses.rst:416
msgid ""
"Very fancy terminals can change the definitions of the actual colors to a "
"given RGB value.  This lets you change color 1, which is usually red, to "
"purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't provide"
" any examples.  You can check if your terminal can do this by calling "
":func:`~curses.can_change_color`, which returns ``True`` if the capability "
"is there.  If you're lucky enough to have such a talented terminal, consult "
"your system's man pages for more information."
msgstr ""
"Дуже модні термінали можуть змінювати визначення фактичних кольорів на "
"задане значення RGB. Це дозволяє змінити колір 1, який зазвичай червоний, на"
" фіолетовий, синій або будь-який інший колір, який вам подобається. На жаль,"
" консоль Linux не підтримує це, тому я не можу випробувати це й не можу "
"надати жодних прикладів. Ви можете перевірити, чи ваш термінал може зробити "
"це, викликавши :func:`~curses.can_change_color`, який повертає ``True``, "
"якщо така можливість є. Якщо вам пощастило мати такий талановитий термінал, "
"зверніться до сторінок керівництва вашої системи для отримання додаткової "
"інформації."

#: ../../howto/curses.rst:427
msgid "User Input"
msgstr "Введення користувача"

#: ../../howto/curses.rst:429
msgid ""
"The C curses library offers only very simple input mechanisms. Python's "
":mod:`curses` module adds a basic text-input widget.  (Other libraries such "
"as :pypi:`Urwid` have more extensive collections of widgets.)"
msgstr ""

#: ../../howto/curses.rst:433
msgid "There are two methods for getting input from a window:"
msgstr "Існує два способи отримання даних із вікна:"

#: ../../howto/curses.rst:435
msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the cursor"
" should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch` оновлює екран, а потім чекає, поки користувач "
"натисне клавішу, відображаючи клавішу, якщо :func:`~curses.echo` було "
"викликано раніше. Додатково можна вказати координату, до якої слід "
"перемістити курсор перед паузою."

#: ../../howto/curses.rst:440
msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the integer "
"to a string.  Individual characters are returned as 1-character strings, and"
" special keys such as function keys return longer strings containing a key "
"name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey` робить те саме, але перетворює ціле число на "
"рядок. Окремі символи повертаються як рядки з 1 символу, а спеціальні "
"клавіші, такі як функціональні клавіші, повертають довші рядки, що містять "
"ім’я ключа, наприклад ``KEY_UP`` або ``^G``."

#: ../../howto/curses.rst:445
msgid ""
"It's possible to not wait for the user using the "
":meth:`~curses.window.nodelay` window method. After ``nodelay(True)``, "
":meth:`!getch` and :meth:`!getkey` for the window become non-blocking. To "
"signal that no input is ready, :meth:`!getch` returns ``curses.ERR`` (a "
"value of -1) and :meth:`!getkey` raises an exception. There's also a "
":func:`~curses.halfdelay` function, which can be used to (in effect) set a "
"timer on each :meth:`!getch`; if no input becomes available within a "
"specified delay (measured in tenths of a second), curses raises an "
"exception."
msgstr ""

#: ../../howto/curses.rst:455
msgid ""
"The :meth:`!getch` method returns an integer; if it's between 0 and 255, it "
"represents the ASCII code of the key pressed.  Values greater than 255 are "
"special keys such as Page Up, Home, or the cursor keys. You can compare the "
"value returned to constants such as :const:`curses.KEY_PPAGE`, "
":const:`curses.KEY_HOME`, or :const:`curses.KEY_LEFT`.  The main loop of "
"your program may look something like this::"
msgstr ""

#: ../../howto/curses.rst:462
msgid ""
"while True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break  # Exit the while loop\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"
msgstr ""

#: ../../howto/curses.rst:471
msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, :func:`curses.ascii.ctrl` "
"returns the control character corresponding to its argument."
msgstr ""
"Модуль :mod:`curses.ascii` надає функції приналежності до класу ASCII, які "
"приймають цілі або односимвольні рядкові аргументи; вони можуть бути "
"корисними для написання більш читабельних тестів для таких циклів. Він також"
" надає функції перетворення, які приймають цілі або односимвольні аргументи "
"та повертають той самий тип. Наприклад, :func:`curses.ascii.ctrl` повертає "
"керуючий символ, що відповідає його аргументу."

#: ../../howto/curses.rst:478
msgid ""
"There's also a method to retrieve an entire string, "
":meth:`~curses.window.getstr`.  It isn't used very often, because its "
"functionality is quite limited; the only editing keys available are the "
"backspace key and the Enter key, which terminates the string.  It can "
"optionally be limited to a fixed number of characters. ::"
msgstr ""
"Існує також метод для отримання цілого рядка, :meth:`~curses.window.getstr`."
" Використовується не дуже часто, оскільки його функціональність досить "
"обмежена; єдиними доступними клавішами редагування є клавіша повернення та "
"клавіша Enter, яка завершує рядок. За бажанням його можна обмежити "
"фіксованою кількістю символів. ::"

#: ../../howto/curses.rst:484
msgid ""
"curses.echo()            # Enable echoing of characters\n"
"\n"
"# Get a 15-character string, with the cursor on the top line\n"
"s = stdscr.getstr(0,0, 15)"
msgstr ""

#: ../../howto/curses.rst:489
msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an Emacs-"
"like set of keybindings.  Various methods of the "
":class:`~curses.textpad.Textbox` class support editing with input validation"
" and gathering the edit results either with or without trailing spaces.  "
"Here's an example::"
msgstr ""
"Модуль :mod:`curses.textpad` надає текстове поле, яке підтримує Emacs-"
"подібний набір сполучень клавіш. Різні методи класу "
":class:`~curses.textpad.Textbox` підтримують редагування з перевіркою "
"введених даних і збиранням результатів редагування з пробілами в кінці або "
"без них. Ось приклад::"

#: ../../howto/curses.rst:495
msgid ""
"import curses\n"
"from curses.textpad import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Enter IM message: (hit Ctrl-G to send)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Let the user edit until Ctrl-G is struck.\n"
"    box.edit()\n"
"\n"
"    # Get resulting contents\n"
"    message = box.gather()"
msgstr ""

#: ../../howto/curses.rst:513
msgid ""
"See the library documentation on :mod:`curses.textpad` for more details."
msgstr ""
"Перегляньте документацію бібліотеки на :mod:`curses.textpad` для отримання "
"додаткової інформації."

#: ../../howto/curses.rst:517
msgid "For More Information"
msgstr "Для отримання додаткової інформації"

#: ../../howto/curses.rst:519
msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the contents "
"of the screen or capturing mouse events from an xterm instance, but the "
"Python library page for the :mod:`curses` module is now reasonably complete."
"  You should browse it next."
msgstr ""
"Цей HOWTO не охоплює деякі складні теми, такі як читання вмісту екрана чи "
"захоплення подій миші з екземпляра xterm, але сторінка бібліотеки Python для"
" модуля :mod:`curses` тепер досить повна. Ви повинні переглянути його далі."

#: ../../howto/curses.rst:524
msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document any "
"quirks, and provide complete lists of all the functions, attributes, and "
":ref:`ACS_\\* <curses-acs-codes>` characters available to you."
msgstr ""

#: ../../howto/curses.rst:531
msgid ""
"Because the curses API is so large, some functions aren't supported in the "
"Python interface.  Often this isn't because they're difficult to implement, "
"but because no one has needed them yet.  Also, Python doesn't yet support "
"the menu library associated with ncurses. Patches adding support for these "
"would be welcome; see `the Python Developer's Guide "
"<https://devguide.python.org/>`_ to learn more about submitting patches to "
"Python."
msgstr ""
"Оскільки API curses дуже великий, деякі функції не підтримуються в "
"інтерфейсі Python. Часто це відбувається не тому, що їх важко реалізувати, а"
" тому, що вони ще нікому не потрібні. Крім того, Python ще не підтримує "
"бібліотеку меню, пов’язану з ncurses. Латки, що додають підтримку для них, "
"будуть вітатися; див. `Посібник розробника Python "
"<https://devguide.python.org/>`_, щоб дізнатися більше про надсилання "
"виправлень у Python."

#: ../../howto/curses.rst:539
msgid ""
"`Writing Programs with NCURSES <https://invisible-"
"island.net/ncurses/ncurses-intro.html>`_: a lengthy tutorial for C "
"programmers."
msgstr ""

#: ../../howto/curses.rst:541
msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "`Довідкова сторінка ncurses <https://linux.die.net/man/3/ncurses>`_"

#: ../../howto/curses.rst:542
msgid ""
"`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr ""

#: ../../howto/curses.rst:543
msgid ""
"`\"Use curses... don't swear\" "
"<https://www.youtube.com/watch?v=eN1eZtjLEnU>`_: video of a PyCon 2013 talk "
"on controlling terminals using curses or Urwid."
msgstr ""
"`\"Використовуйте прокляття... не лайтеся\" "
"<https://www.youtube.com/watch?v=eN1eZtjLEnU>`_: відео розмови на PyCon 2013"
" про керування терміналами за допомогою проклять або Urwid."

#: ../../howto/curses.rst:545
msgid ""
"`\"Console Applications with Urwid\" "
"<https://pyvideo.org/video/1568/console-applications-with-urwid>`_: video of"
" a PyCon CA 2012 talk demonstrating some applications written using Urwid."
msgstr ""
