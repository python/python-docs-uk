# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Logging HOWTO"
msgstr "Журнал HOWTO"

msgid "Author"
msgstr "Автор"

msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

msgid "Basic Logging Tutorial"
msgstr "Підручник з базового журналювання"

msgid ""
"Logging is a means of tracking events that happen when some software runs. "
"The software's developer adds logging calls to their code to indicate that "
"certain events have occurred. An event is described by a descriptive message "
"which can optionally contain variable data (i.e. data that is potentially "
"different for each occurrence of the event). Events also have an importance "
"which the developer ascribes to the event; the importance can also be called "
"the *level* or *severity*."
msgstr ""
"Ведення журналу — це засіб відстеження подій, які відбуваються під час "
"роботи певного програмного забезпечення. Розробник програмного забезпечення "
"додає до свого коду виклики реєстрації, щоб вказати, що відбулися певні "
"події. Подія описується описовим повідомленням, яке може додатково містити "
"змінні дані (тобто дані, які потенційно відрізняються для кожного випадку "
"події). Події також мають важливість, яку розробник приписує події; "
"важливість також можна назвати *рівнем* або *серйозністю*."

msgid "When to use logging"
msgstr "Коли використовувати журналювання"

msgid ""
"Logging provides a set of convenience functions for simple logging usage. "
"These are :func:`debug`, :func:`info`, :func:`warning`, :func:`error` and :"
"func:`critical`. To determine when to use logging, see the table below, "
"which states, for each of a set of common tasks, the best tool to use for it."
msgstr ""
"Logging надає набір зручних функцій для простого використання журналу. Це :"
"func:`debug`, :func:`info`, :func:`warning`, :func:`error` і :func:"
"`critical`. Щоб визначити, коли використовувати журналювання, перегляньте "
"наведену нижче таблицю, у якій зазначено найкращий інструмент для кожного з "
"набору поширених завдань."

msgid "Task you want to perform"
msgstr "Завдання, яке ви хочете виконати"

msgid "The best tool for the task"
msgstr "Найкращий інструмент для завдання"

msgid ""
"Display console output for ordinary usage of a command line script or program"
msgstr ""
"Відображення виводу консолі для звичайного використання сценарію або "
"програми командного рядка"

msgid ":func:`print`"
msgstr ":func:`print`"

msgid ""
"Report events that occur during normal operation of a program (e.g. for "
"status monitoring or fault investigation)"
msgstr ""
"Повідомлення про події, які відбуваються під час нормальної роботи програми "
"(наприклад, для моніторингу стану або дослідження помилок)"

msgid ""
":func:`logging.info` (or :func:`logging.debug` for very detailed output for "
"diagnostic purposes)"
msgstr ""
":func:`logging.info` (або :func:`logging.debug` для дуже детального виводу "
"для діагностичних цілей)"

msgid "Issue a warning regarding a particular runtime event"
msgstr "Видавати попередження щодо певної події виконання"

msgid ""
":func:`warnings.warn` in library code if the issue is avoidable and the "
"client application should be modified to eliminate the warning"
msgstr ""
":func:`warnings.warn` у коді бібліотеки, якщо проблеми можна уникнути і "
"клієнтську програму слід змінити, щоб усунути попередження"

msgid ""
":func:`logging.warning` if there is nothing the client application can do "
"about the situation, but the event should still be noted"
msgstr ""
":func:`logging.warning`, якщо клієнтська програма нічого не може вдіяти з "
"ситуацією, але подію все одно слід зазначити"

msgid "Report an error regarding a particular runtime event"
msgstr "Повідомити про помилку щодо певної події виконання"

msgid "Raise an exception"
msgstr "Викликати виняток"

msgid ""
"Report suppression of an error without raising an exception (e.g. error "
"handler in a long-running server process)"
msgstr ""
"Повідомити про придушення помилки без виклику винятку (наприклад, обробник "
"помилок у тривалому серверному процесі)"

msgid ""
":func:`logging.error`, :func:`logging.exception` or :func:`logging.critical` "
"as appropriate for the specific error and application domain"
msgstr ""
":func:`logging.error`, :func:`logging.exception` або :func:`logging."
"critical` відповідно до конкретної помилки та домену програми"

msgid ""
"The logging functions are named after the level or severity of the events "
"they are used to track. The standard levels and their applicability are "
"described below (in increasing order of severity):"
msgstr ""
"Функції журналювання називаються відповідно до рівня або серйозності подій, "
"які вони використовують для відстеження. Стандартні рівні та їх "
"застосовність описані нижче (у порядку зростання суворості):"

msgid "Level"
msgstr "Рівень"

msgid "When it's used"
msgstr "Коли він використовується"

msgid "``DEBUG``"
msgstr "``НАЛАШТУВАННЯ``"

msgid ""
"Detailed information, typically of interest only when diagnosing problems."
msgstr ""
"Детальна інформація, яка зазвичай цікава лише під час діагностики проблем."

msgid "``INFO``"
msgstr "``ІНФО``"

msgid "Confirmation that things are working as expected."
msgstr "Підтвердження того, що все працює належним чином."

msgid "``WARNING``"
msgstr "``ПОПЕРЕДЖЕННЯ``"

msgid ""
"An indication that something unexpected happened, or indicative of some "
"problem in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr ""
"Ознака того, що трапилося щось несподіване, або вказує на певну проблему в "
"найближчому майбутньому (наприклад, \"замало місця на диску\"). Програмне "
"забезпечення все ще працює належним чином."

msgid "``ERROR``"
msgstr "``ПОМИЛКА``"

msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr ""
"Через більш серйозну проблему програмне забезпечення не може виконувати "
"деякі функції."

msgid "``CRITICAL``"
msgstr "``КРИТИЧНО``"

msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr ""
"Серйозна помилка, яка вказує на те, що сама програма може не працювати далі."

msgid ""
"The default level is ``WARNING``, which means that only events of this level "
"and above will be tracked, unless the logging package is configured to do "
"otherwise."
msgstr ""
"Рівень за замовчуванням – ``ПОПЕРЕДЖЕННЯ``, що означає, що "
"відстежуватимуться лише події цього рівня та вище, якщо пакет журналювання "
"не налаштовано на інше."

msgid ""
"Events that are tracked can be handled in different ways. The simplest way "
"of handling tracked events is to print them to the console. Another common "
"way is to write them to a disk file."
msgstr ""
"Події, які відстежуються, можна обробляти різними способами. Найпростіший "
"спосіб обробки відстежуваних подій — роздрукувати їх на консолі. Ще один "
"поширений спосіб - записати їх у файл на диску."

msgid "A simple example"
msgstr "Простий приклад"

msgid "A very simple example is::"
msgstr "Дуже простий приклад::"

msgid "If you type these lines into a script and run it, you'll see:"
msgstr "Якщо ви введете ці рядки в сценарій і запустите його, ви побачите:"

msgid ""
"printed out on the console. The ``INFO`` message doesn't appear because the "
"default level is ``WARNING``. The printed message includes the indication of "
"the level and the description of the event provided in the logging call, i."
"e. 'Watch out!'. Don't worry about the 'root' part for now: it will be "
"explained later. The actual output can be formatted quite flexibly if you "
"need that; formatting options will also be explained later."
msgstr ""
"роздрукований на консолі. Повідомлення ``ІНФО`` не з'являється, оскільки "
"рівень за замовчуванням ``ПОПЕРЕДЖЕННЯ``. Роздруковане повідомлення містить "
"індикацію рівня та опис події, наданої у виклику реєстрації, тобто "
"\"Обережно!\". Наразі не турбуйтеся про \"кореневу\" частину: це буде "
"пояснено пізніше. Фактичний вихід можна відформатувати досить гнучко, якщо "
"вам це потрібно; параметри форматування також будуть пояснені пізніше."

msgid "Logging to a file"
msgstr "Запис у файл"

msgid ""
"A very common situation is that of recording logging events in a file, so "
"let's look at that next. Be sure to try the following in a newly-started "
"Python interpreter, and don't just continue from the session described "
"above::"
msgstr ""
"Дуже поширеною ситуацією є запис подій журналювання у файл, тому давайте "
"розглянемо це далі. Обов’язково спробуйте наступне у нещодавно запущеному "
"інтерпретаторі Python, а не просто продовжуйте сеанс, описаний вище:"

msgid ""
"The *encoding* argument was added. In earlier Python versions, or if not "
"specified, the encoding used is the default value used by :func:`open`. "
"While not shown in the above example, an *errors* argument can also now be "
"passed, which determines how encoding errors are handled. For available "
"values and the default, see the documentation for :func:`open`."
msgstr ""
"Додано аргумент *кодування*. У попередніх версіях Python або, якщо не "
"вказано, використовувалося кодування за замовчуванням, яке використовується :"
"func:`open`. Хоча це не показано в наведеному вище прикладі, тепер також "
"можна передати аргумент *errors*, який визначає, як обробляються помилки "
"кодування. Доступні значення та типові значення дивіться в документації для :"
"func:`open`."

msgid ""
"And now if we open the file and look at what we have, we should find the log "
"messages:"
msgstr ""
"А тепер, якщо ми відкриємо файл і подивимося, що у нас є, ми повинні знайти "
"повідомлення журналу:"

msgid ""
"This example also shows how you can set the logging level which acts as the "
"threshold for tracking. In this case, because we set the threshold to "
"``DEBUG``, all of the messages were printed."
msgstr ""
"У цьому прикладі також показано, як можна встановити рівень журналювання, "
"який діє як порогове значення для відстеження. У цьому випадку, оскільки ми "
"встановили порогове значення ``DEBUG``, усі повідомлення було надруковано."

msgid ""
"If you want to set the logging level from a command-line option such as:"
msgstr ""
"Якщо ви хочете встановити рівень журналювання за допомогою параметра "
"командного рядка, наприклад:"

msgid ""
"and you have the value of the parameter passed for ``--log`` in some "
"variable *loglevel*, you can use::"
msgstr ""
"і у вас є значення параметра, переданого для ``--log`` у деякій змінній "
"*loglevel*, ви можете використовувати::"

msgid ""
"to get the value which you'll pass to :func:`basicConfig` via the *level* "
"argument. You may want to error check any user input value, perhaps as in "
"the following example::"
msgstr ""
"щоб отримати значення, яке ви передасте :func:`basicConfig` через аргумент "
"*level*. Можливо, ви захочете перевірити помилки будь-якого введеного "
"користувачем значення, можливо, як у наступному прикладі::"

msgid ""
"The call to :func:`basicConfig` should come *before* any calls to :func:"
"`debug`, :func:`info`, etc. Otherwise, those functions will call :func:"
"`basicConfig` for you with the default options. As it's intended as a one-"
"off simple configuration facility, only the first call will actually do "
"anything: subsequent calls are effectively no-ops."
msgstr ""
"Виклик :func:`basicConfig` має надходити *перед* будь-якими викликами :func:"
"`debug`, :func:`info` тощо. Інакше ці функції викличуть :func:`basicConfig` "
"для вас із значенням за замовчуванням параметри. Оскільки це призначено як "
"одноразовий простий засіб конфігурації, лише перший виклик насправді щось "
"зробить: наступні виклики фактично не виконують жодних операцій."

msgid ""
"If you run the above script several times, the messages from successive runs "
"are appended to the file *example.log*. If you want each run to start "
"afresh, not remembering the messages from earlier runs, you can specify the "
"*filemode* argument, by changing the call in the above example to::"
msgstr ""
"Якщо ви запустите наведений вище сценарій кілька разів, повідомлення від "
"послідовних запусків буде додано до файлу *example.log*. Якщо ви хочете, щоб "
"кожен запуск починався заново, не запам’ятовуючи повідомлення з попередніх "
"запусків, ви можете вказати аргумент *filemode*, змінивши виклик у прикладі "
"вище на::"

msgid ""
"The output will be the same as before, but the log file is no longer "
"appended to, so the messages from earlier runs are lost."
msgstr ""
"Результат буде таким же, як і раніше, але файл журналу більше не додається, "
"тому повідомлення від попередніх запусків буде втрачено."

msgid "Logging from multiple modules"
msgstr "Логування з кількох модулів"

msgid ""
"If your program consists of multiple modules, here's an example of how you "
"could organize logging in it::"
msgstr ""
"Якщо ваша програма складається з кількох модулів, ось приклад того, як ви "
"можете організувати в ній реєстрацію:"

msgid "If you run *myapp.py*, you should see this in *myapp.log*:"
msgstr "Якщо ви запускаєте *myapp.py*, ви повинні побачити це в *myapp.log*:"

msgid ""
"which is hopefully what you were expecting to see. You can generalize this "
"to multiple modules, using the pattern in *mylib.py*. Note that for this "
"simple usage pattern, you won't know, by looking in the log file, *where* in "
"your application your messages came from, apart from looking at the event "
"description. If you want to track the location of your messages, you'll need "
"to refer to the documentation beyond the tutorial level -- see :ref:`logging-"
"advanced-tutorial`."
msgstr ""
"що, сподіваюся, ви очікували побачити. Ви можете узагальнити це на кілька "
"модулів, використовуючи шаблон у *mylib.py*. Зауважте, що для цього простого "
"шаблону використання ви не знатимете, дивлячись у файл журналу, *звідки* у "
"вашій програмі надійшли ваші повідомлення, окрім перегляду опису події. Якщо "
"ви бажаєте відстежувати місцезнаходження своїх повідомлень, вам потрібно "
"буде звернутися до документації за межами навчального рівня – див. :ref:"
"`logging-advanced-tutorial`."

msgid "Logging variable data"
msgstr "Журналування змінних даних"

msgid ""
"To log variable data, use a format string for the event description message "
"and append the variable data as arguments. For example::"
msgstr ""
"Щоб зареєструвати змінні дані, використовуйте рядок формату для повідомлення "
"з описом події та додайте змінні дані як аргументи. Наприклад::"

msgid "will display:"
msgstr "буде відображатися:"

msgid ""
"As you can see, merging of variable data into the event description message "
"uses the old, %-style of string formatting. This is for backwards "
"compatibility: the logging package pre-dates newer formatting options such "
"as :meth:`str.format` and :class:`string.Template`. These newer formatting "
"options *are* supported, but exploring them is outside the scope of this "
"tutorial: see :ref:`formatting-styles` for more information."
msgstr ""
"Як бачите, об’єднання змінних даних у повідомлення опису події використовує "
"старий, %-style форматування рядків. Це для зворотної сумісності: пакет "
"журналювання передує новішим параметрам форматування, таким як :meth:`str."
"format` і :class:`string.Template`. Ці нові параметри форматування "
"*підтримуються*, але їх вивчення виходить за рамки цього підручника: див. :"
"ref:`formatting-styles` для отримання додаткової інформації."

msgid "Changing the format of displayed messages"
msgstr "Зміна формату повідомлень, що відображаються"

msgid ""
"To change the format which is used to display messages, you need to specify "
"the format you want to use::"
msgstr ""
"Щоб змінити формат, який використовується для відображення повідомлень, вам "
"потрібно вказати формат, який ви хочете використовувати:"

msgid "which would print:"
msgstr "який буде друкувати:"

msgid ""
"Notice that the 'root' which appeared in earlier examples has disappeared. "
"For a full set of things that can appear in format strings, you can refer to "
"the documentation for :ref:`logrecord-attributes`, but for simple usage, you "
"just need the *levelname* (severity), *message* (event description, "
"including variable data) and perhaps to display when the event occurred. "
"This is described in the next section."
msgstr ""
"Зверніть увагу, що \"корінь\", який з’явився в попередніх прикладах, зник. "
"Щоб отримати повний набір речей, які можуть відображатися в рядках формату, "
"ви можете звернутися до документації для :ref:`logrecord-attributes`, але "
"для простого використання вам потрібні лише *levelname* (серйозність), "
"*message* (подія). опис, включаючи змінні дані) і, можливо, для "
"відображення, коли сталася подія. Це описано в наступному розділі."

msgid "Displaying the date/time in messages"
msgstr "Відображення дати/часу в повідомленнях"

msgid ""
"To display the date and time of an event, you would place '%(asctime)s' in "
"your format string::"
msgstr ""
"Щоб відобразити дату й час події, потрібно розмістити \"%(asctime)s\" у "
"рядку формату::"

msgid "which should print something like this:"
msgstr "який має надрукувати щось на зразок цього:"

msgid ""
"The default format for date/time display (shown above) is like ISO8601 or :"
"rfc:`3339`. If you need more control over the formatting of the date/time, "
"provide a *datefmt* argument to ``basicConfig``, as in this example::"
msgstr ""
"Формат за замовчуванням для відображення дати/часу (показаний вище) такий, "
"як ISO8601 або :rfc:`3339`. Якщо вам потрібен більший контроль над "
"форматуванням дати/часу, надайте аргумент *datefmt* для ``basicConfig``, як "
"у цьому прикладі::"

msgid "which would display something like this:"
msgstr "який відображатиме щось на зразок цього:"

msgid ""
"The format of the *datefmt* argument is the same as supported by :func:`time."
"strftime`."
msgstr ""
"Формат аргументу *datefmt* такий самий, як підтримується :func:`time."
"strftime`."

msgid "Next Steps"
msgstr "Наступні кроки"

msgid ""
"That concludes the basic tutorial. It should be enough to get you up and "
"running with logging. There's a lot more that the logging package offers, "
"but to get the best out of it, you'll need to invest a little more of your "
"time in reading the following sections. If you're ready for that, grab some "
"of your favourite beverage and carry on."
msgstr ""
"На цьому основний підручник завершується. Цього має бути достатньо, щоб "
"розпочати роботу з журналюванням. Пакет журналювання пропонує багато іншого, "
"але щоб отримати від нього найкраще, вам потрібно буде витратити трохи "
"більше часу на читання наступних розділів. Якщо ви готові до цього, візьміть "
"свій улюблений напій і продовжуйте."

msgid ""
"If your logging needs are simple, then use the above examples to incorporate "
"logging into your own scripts, and if you run into problems or don't "
"understand something, please post a question on the comp.lang.python Usenet "
"group (available at https://groups.google.com/forum/#!forum/comp.lang."
"python) and you should receive help before too long."
msgstr ""
"Якщо ваші потреби в журналі прості, скористайтеся наведеними вище "
"прикладами, щоб включити вхід у ваші власні сценарії, і якщо ви зіткнетеся з "
"проблемами або щось не зрозумієте, опублікуйте запитання в групі comp.lang."
"python Usenet (доступна за адресою https ://groups.google.com/forum/#!forum/"
"comp.lang.python), і ви незабаром отримаєте допомогу."

msgid ""
"Still here? You can carry on reading the next few sections, which provide a "
"slightly more advanced/in-depth tutorial than the basic one above. After "
"that, you can take a look at the :ref:`logging-cookbook`."
msgstr ""
"Досі тут? Ви можете продовжувати читати кілька наступних розділів, які "
"містять дещо більш просунутий/поглиблений підручник, ніж основний вище. "
"Після цього ви можете переглянути :ref:`logging-cookbook`."

msgid "Advanced Logging Tutorial"
msgstr "Навчальний посібник із розширеного журналювання"

msgid ""
"The logging library takes a modular approach and offers several categories "
"of components: loggers, handlers, filters, and formatters."
msgstr ""
"Бібліотека журналювання має модульний підхід і пропонує кілька категорій "
"компонентів: журнали, обробники, фільтри та засоби форматування."

msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"Логери відкривають інтерфейс, який безпосередньо використовує код програми."

msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"Обробники надсилають записи журналу (створені реєстраторами) у відповідне "
"місце призначення."

msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"Фільтри забезпечують точніші засоби для визначення того, які записи журналу "
"виводити."

msgid "Formatters specify the layout of log records in the final output."
msgstr ""
"Засоби форматування вказують макет записів журналу в кінцевому виведенні."

msgid ""
"Log event information is passed between loggers, handlers, filters and "
"formatters in a :class:`LogRecord` instance."
msgstr ""
"Інформація про подію журналу передається між реєстраторами, обробниками, "
"фільтрами та форматувальниками в екземплярі :class:`LogRecord`."

msgid ""
"Logging is performed by calling methods on instances of the :class:`Logger` "
"class (hereafter called :dfn:`loggers`). Each instance has a name, and they "
"are conceptually arranged in a namespace hierarchy using dots (periods) as "
"separators. For example, a logger named 'scan' is the parent of loggers "
"'scan.text', 'scan.html' and 'scan.pdf'. Logger names can be anything you "
"want, and indicate the area of an application in which a logged message "
"originates."
msgstr ""
"Логування виконується шляхом виклику методів екземплярів класу :class:"
"`Logger` (надалі :dfn:`loggers`). Кожен екземпляр має назву, і вони "
"концептуально впорядковані в ієрархії простору імен із використанням крапок "
"(крапок) як роздільників. Наприклад, реєстратор під назвою \"scan\" є "
"батьківським для реєстраторів \"scan.text\", \"scan.html\" і \"scan.pdf\". "
"Імена реєстратора можуть бути будь-якими, і вони вказують на область "
"програми, з якої походить повідомлення, що реєструється."

msgid ""
"A good convention to use when naming loggers is to use a module-level "
"logger, in each module which uses logging, named as follows::"
msgstr ""
"Хороша угода для використання під час іменування реєстраторів полягає в "
"тому, щоб використовувати реєстратор на рівні модуля, у кожному модулі, який "
"використовує журналювання, названий таким чином:"

msgid ""
"This means that logger names track the package/module hierarchy, and it's "
"intuitively obvious where events are logged just from the logger name."
msgstr ""
"Це означає, що імена реєстраторів відстежують ієрархію пакетів/модулів, і "
"інтуїтивно зрозуміло, де події реєструються лише з імені реєстратора."

msgid ""
"The root of the hierarchy of loggers is called the root logger. That's the "
"logger used by the functions :func:`debug`, :func:`info`, :func:`warning`, :"
"func:`error` and :func:`critical`, which just call the same-named method of "
"the root logger. The functions and the methods have the same signatures. The "
"root logger's name is printed as 'root' in the logged output."
msgstr ""
"Корінь ієрархії реєстраторів називається кореневим реєстратором. Це "
"реєстратор, який використовують функції :func:`debug`, :func:`info`, :func:"
"`warning`, :func:`error` і :func:`critical`, які просто викликають "
"одноіменний метод кореневого реєстратора. Функції та методи мають однакові "
"сигнатури. Ім'я кореневого реєстратора друкується як 'root' у зареєстрованих "
"результатах."

msgid ""
"It is, of course, possible to log messages to different destinations. "
"Support is included in the package for writing log messages to files, HTTP "
"GET/POST locations, email via SMTP, generic sockets, queues, or OS-specific "
"logging mechanisms such as syslog or the Windows NT event log. Destinations "
"are served by :dfn:`handler` classes. You can create your own log "
"destination class if you have special requirements not met by any of the "
"built-in handler classes."
msgstr ""
"Звичайно, можна записувати повідомлення до різних адресатів. У пакет "
"включено підтримку для запису повідомлень журналу у файли, розташування HTTP "
"GET/POST, електронну пошту через SMTP, загальні сокети, черги або специфічні "
"для ОС механізми журналювання, такі як syslog або журнал подій Windows NT. "
"Пункти призначення обслуговуються класами :dfn:`handler`. Ви можете створити "
"власний клас призначення журналу, якщо у вас є особливі вимоги, яких не "
"задовольняє жоден із вбудованих класів обробки."

msgid ""
"By default, no destination is set for any logging messages. You can specify "
"a destination (such as console or file) by using :func:`basicConfig` as in "
"the tutorial examples. If you call the functions  :func:`debug`, :func:"
"`info`, :func:`warning`, :func:`error` and :func:`critical`, they will check "
"to see if no destination is set; and if one is not set, they will set a "
"destination of the console (``sys.stderr``) and a default format for the "
"displayed message before delegating to the root logger to do the actual "
"message output."
msgstr ""
"За замовчуванням адресат не встановлено для будь-яких повідомлень журналу. "
"Ви можете вказати призначення (наприклад, консоль або файл) за допомогою :"
"func:`basicConfig`, як у прикладах підручника. Якщо ви викликаєте функції :"
"func:`debug`, :func:`info`, :func:`warning`, :func:`error` і :func:"
"`critical`, вони перевірять, чи не встановлено місце призначення ; і якщо "
"його не встановлено, вони встановлять призначення консолі (``sys.stderr``) і "
"формат за замовчуванням для відображеного повідомлення перед делегуванням "
"кореневому реєстратору для фактичного виведення повідомлення."

msgid "The default format set by :func:`basicConfig` for messages is:"
msgstr "Типовий формат, встановлений :func:`basicConfig` для повідомлень:"

msgid ""
"You can change this by passing a format string to :func:`basicConfig` with "
"the *format* keyword argument. For all options regarding how a format string "
"is constructed, see :ref:`formatter-objects`."
msgstr ""
"Ви можете змінити це, передавши рядок формату в :func:`basicConfig` з "
"ключовим аргументом *format*. Щоб дізнатися про всі варіанти створення рядка "
"формату, перегляньте :ref:`formatter-objects`."

msgid "Logging Flow"
msgstr "Потік журналювання"

msgid ""
"The flow of log event information in loggers and handlers is illustrated in "
"the following diagram."
msgstr ""
"Потік інформації про подію журналу в реєстраторах і обробниках показано на "
"наступній діаграмі."

msgid "Loggers"
msgstr "Лісоруби"

msgid ""
":class:`Logger` objects have a threefold job.  First, they expose several "
"methods to application code so that applications can log messages at "
"runtime. Second, logger objects determine which log messages to act upon "
"based upon severity (the default filtering facility) or filter objects.  "
"Third, logger objects pass along relevant log messages to all interested log "
"handlers."
msgstr ""
"Об’єкти :class:`Logger` виконують потрійну роботу. По-перше, вони надають "
"кілька методів коду програми, щоб програми могли реєструвати повідомлення "
"під час виконання. По-друге, об’єкти реєстратора визначають, з якими "
"повідомленнями журналу діяти, залежно від серйозності (засоби фільтрації за "
"замовчуванням) або об’єктів фільтрації. По-третє, об’єкти журналу передають "
"відповідні повідомлення журналу всім зацікавленим обробникам журналів."

msgid ""
"The most widely used methods on logger objects fall into two categories: "
"configuration and message sending."
msgstr ""
"Найбільш широко використовувані методи для об’єктів журналу діляться на дві "
"категорії: конфігурація та надсилання повідомлень."

msgid "These are the most common configuration methods:"
msgstr "Ось найпоширеніші методи налаштування:"

msgid ""
":meth:`Logger.setLevel` specifies the lowest-severity log message a logger "
"will handle, where debug is the lowest built-in severity level and critical "
"is the highest built-in severity.  For example, if the severity level is "
"INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL "
"messages and will ignore DEBUG messages."
msgstr ""
":meth:`Logger.setLevel` визначає повідомлення журналу з найнижчим рівнем "
"серйозності, яке обробить реєстратор, де debug — найнижчий вбудований рівень "
"серйозності, а критичний — найвищий вбудований рівень серйозності. "
"Наприклад, якщо рівень серйозності INFO, реєстратор оброблятиме лише "
"повідомлення INFO, WARNING, ERROR і CRITICAL і ігноруватиме повідомлення "
"DEBUG."

msgid ""
":meth:`Logger.addHandler` and :meth:`Logger.removeHandler` add and remove "
"handler objects from the logger object.  Handlers are covered in more detail "
"in :ref:`handler-basic`."
msgstr ""
":meth:`Logger.addHandler` і :meth:`Logger.removeHandler` додають і видаляють "
"об’єкти обробки з об’єкта реєстратора. Обробники описані більш детально в :"
"ref:`handler-basic`."

msgid ""
":meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove "
"filter objects from the logger object.  Filters are covered in more detail "
"in :ref:`filter`."
msgstr ""
":meth:`Logger.addFilter` і :meth:`Logger.removeFilter` додають і видаляють "
"об’єкти фільтрів з об’єкта реєстратора. Фільтри описані більш детально в :"
"ref:`filter`."

msgid ""
"You don't need to always call these methods on every logger you create. See "
"the last two paragraphs in this section."
msgstr ""
"Вам не потрібно завжди викликати ці методи в кожному створеному вами "
"реєстраторі. Дивіться останні два абзаци цього розділу."

msgid ""
"With the logger object configured, the following methods create log messages:"
msgstr ""
"Якщо об’єкт журналу налаштовано, такі методи створюють повідомлення журналу:"

msgid ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error`, and :meth:`Logger.critical` all create log records with a "
"message and a level that corresponds to their respective method names. The "
"message is actually a format string, which may contain the standard string "
"substitution syntax of ``%s``, ``%d``, ``%f``, and so on.  The rest of their "
"arguments is a list of objects that correspond with the substitution fields "
"in the message.  With regard to ``**kwargs``, the logging methods care only "
"about a keyword of ``exc_info`` and use it to determine whether to log "
"exception information."
msgstr ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error` і :meth:`Logger.critical` створюють записи журналу з "
"повідомлення та рівень, що відповідає їх відповідним назвам методів. "
"Повідомлення фактично є рядком формату, який може містити стандартний "
"синтаксис заміни рядка ``%s``, ``%d``, ``%f`` і так далі. Решта аргументів — "
"це список об’єктів, які відповідають полям підстановки в повідомленні. Щодо "
"``**kwargs``, методи журналювання дбають лише про ключове слово ``exc_info`` "
"і використовують його, щоб визначити, чи потрібно реєструвати інформацію про "
"винятки."

msgid ""
":meth:`Logger.exception` creates a log message similar to :meth:`Logger."
"error`.  The difference is that :meth:`Logger.exception` dumps a stack trace "
"along with it.  Call this method only from an exception handler."
msgstr ""
":meth:`Logger.exception` створює повідомлення журналу, подібне до :meth:"
"`Logger.error`. Різниця полягає в тому, що :meth:`Logger.exception` виводить "
"трасування стека разом із ним. Викликайте цей метод лише з обробника "
"винятків."

msgid ""
":meth:`Logger.log` takes a log level as an explicit argument.  This is a "
"little more verbose for logging messages than using the log level "
"convenience methods listed above, but this is how to log at custom log "
"levels."
msgstr ""
":meth:`Logger.log` приймає рівень журналу як явний аргумент. Це трохи "
"докладніше для реєстрації повідомлень, ніж використання зручних методів на "
"рівні журналу, перелічених вище, але це те, як реєструвати на спеціальних "
"рівнях журналу."

msgid ""
":func:`getLogger` returns a reference to a logger instance with the "
"specified name if it is provided, or ``root`` if not.  The names are period-"
"separated hierarchical structures.  Multiple calls to :func:`getLogger` with "
"the same name will return a reference to the same logger object.  Loggers "
"that are further down in the hierarchical list are children of loggers "
"higher up in the list. For example, given a logger with a name of ``foo``, "
"loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all "
"descendants of ``foo``."
msgstr ""
":func:`getLogger` повертає посилання на екземпляр журналу з указаним іменем, "
"якщо воно надано, або ``root``, якщо ні. Назви є ієрархічними структурами, "
"розділеними на періоди. Кілька викликів :func:`getLogger` з однаковою назвою "
"повертатимуть посилання на той самий об’єкт журналу. Реєстратори, "
"розташовані нижче в ієрархічному списку, є нащадками реєстраторів, "
"розташованих вище в списку. Наприклад, якщо задано реєстратор із іменем "
"``foo``, усі реєстратори з іменами ``foo.bar``, ``foo.bar.baz`` і ``foo."
"bam`` є нащадками ``фу``."

msgid ""
"Loggers have a concept of *effective level*. If a level is not explicitly "
"set on a logger, the level of its parent is used instead as its effective "
"level. If the parent has no explicit level set, *its* parent is examined, "
"and so on - all ancestors are searched until an explicitly set level is "
"found. The root logger always has an explicit level set (``WARNING`` by "
"default). When deciding whether to process an event, the effective level of "
"the logger is used to determine whether the event is passed to the logger's "
"handlers."
msgstr ""
"Лісоруби мають поняття *ефективного рівня*. Якщо рівень не встановлено явно "
"в реєстраторі, рівень його батьківського елемента використовується замість "
"цього як ефективний рівень. Якщо батьківський елемент не має явно "
"встановленого рівня, перевіряється *його* батьківський елемент, і так далі - "
"шукаються всі предки, доки не буде знайдено явно встановлений рівень. "
"Кореневий реєстратор завжди має чітко встановлений рівень (``ПОПЕРЕДЖЕННЯ`` "
"за замовчуванням). При прийнятті рішення про обробку події ефективний рівень "
"реєстратора використовується для визначення того, чи подія передається "
"обробникам реєстратора."

msgid ""
"Child loggers propagate messages up to the handlers associated with their "
"ancestor loggers. Because of this, it is unnecessary to define and configure "
"handlers for all the loggers an application uses. It is sufficient to "
"configure handlers for a top-level logger and create child loggers as "
"needed. (You can, however, turn off propagation by setting the *propagate* "
"attribute of a logger to ``False``.)"
msgstr ""
"Дочірні реєстратори поширюють повідомлення до обробників, пов’язаних із "
"їхніми попередніми реєстраторами. Через це немає необхідності визначати та "
"налаштовувати обробники для всіх реєстраторів, які використовує програма. "
"Достатньо налаштувати обробники для реєстратора верхнього рівня та створити "
"дочірні реєстратори за потреби. (Проте ви можете вимкнути розповсюдження, "
"встановивши для атрибута *propagate* реєстратора значення ``False``.)"

msgid "Handlers"
msgstr "Обробники"

msgid ""
":class:`~logging.Handler` objects are responsible for dispatching the "
"appropriate log messages (based on the log messages' severity) to the "
"handler's specified destination.  :class:`Logger` objects can add zero or "
"more handler objects to themselves with an :meth:`~Logger.addHandler` "
"method.  As an example scenario, an application may want to send all log "
"messages to a log file, all log messages of error or higher to stdout, and "
"all messages of critical to an email address. This scenario requires three "
"individual handlers where each handler is responsible for sending messages "
"of a specific severity to a specific location."
msgstr ""
"Об’єкти :class:`~logging.Handler` відповідають за надсилання відповідних "
"повідомлень журналу (залежно від серйозності повідомлень журналу) до "
"вказаного призначення обробника. Об’єкти :class:`Logger` можуть додавати до "
"себе нуль або більше об’єктів обробки за допомогою методу :meth:`~Logger."
"addHandler`. Як приклад сценарію, програма може захотіти надіслати всі "
"повідомлення журналу до файлу журналу, усі повідомлення журналу про помилку "
"або вище до stdout, а всі критичні повідомлення на адресу електронної пошти. "
"Цей сценарій потребує трьох окремих обробників, де кожен обробник відповідає "
"за надсилання повідомлень певного рівня серйозності в певне місце."

msgid ""
"The standard library includes quite a few handler types (see :ref:`useful-"
"handlers`); the tutorials use mainly :class:`StreamHandler` and :class:"
"`FileHandler` in its examples."
msgstr ""
"Стандартна бібліотека включає досить багато типів обробників (див. :ref:"
"`useful-handlers`); навчальні посібники в основному використовують :class:"
"`StreamHandler` і :class:`FileHandler` у своїх прикладах."

msgid ""
"There are very few methods in a handler for application developers to "
"concern themselves with.  The only handler methods that seem relevant for "
"application developers who are using the built-in handler objects (that is, "
"not creating custom handlers) are the following configuration methods:"
msgstr ""
"У обробнику дуже мало методів, якими можуть зайнятися розробники програм. "
"Єдиними методами обробки, які здаються актуальними для розробників додатків, "
"які використовують вбудовані об’єкти обробки (тобто не створюють спеціальні "
"обробники), є такі методи конфігурації:"

msgid ""
"The :meth:`~Handler.setLevel` method, just as in logger objects, specifies "
"the lowest severity that will be dispatched to the appropriate destination.  "
"Why are there two :func:`setLevel` methods?  The level set in the logger "
"determines which severity of messages it will pass to its handlers.  The "
"level set in each handler determines which messages that handler will send "
"on."
msgstr ""
"Метод :meth:`~Handler.setLevel`, як і в об’єктах реєстратора, визначає "
"найнижчий рівень серйозності, який буде відправлено до відповідного пункту "
"призначення. Чому існує два методи :func:`setLevel`? Рівень, встановлений у "
"реєстраторі, визначає, яку серйозність повідомлень він передаватиме своїм "
"обробникам. Рівень, встановлений у кожному обробнику, визначає, які "
"повідомлення цей обробник надсилатиме."

msgid ""
":meth:`~Handler.setFormatter` selects a Formatter object for this handler to "
"use."
msgstr ""
":meth:`~Handler.setFormatter` вибирає об’єкт Formatter для використання цим "
"обробником."

msgid ""
":meth:`~Handler.addFilter` and :meth:`~Handler.removeFilter` respectively "
"configure and deconfigure filter objects on handlers."
msgstr ""
":meth:`~Handler.addFilter` і :meth:`~Handler.removeFilter` відповідно "
"налаштовують і деконфігурують об’єкти фільтрів на обробниках."

msgid ""
"Application code should not directly instantiate and use instances of :class:"
"`Handler`.  Instead, the :class:`Handler` class is a base class that defines "
"the interface that all handlers should have and establishes some default "
"behavior that child classes can use (or override)."
msgstr ""
"Код програми не повинен безпосередньо створювати та використовувати "
"екземпляри :class:`Handler`. Натомість клас :class:`Handler` є базовим "
"класом, який визначає інтерфейс, який повинні мати всі обробники, і "
"встановлює певну поведінку за замовчуванням, яку дочірні класи можуть "
"використовувати (або замінювати)."

msgid "Formatters"
msgstr "Форматери"

msgid ""
"Formatter objects configure the final order, structure, and contents of the "
"log message.  Unlike the base :class:`logging.Handler` class, application "
"code may instantiate formatter classes, although you could likely subclass "
"the formatter if your application needs special behavior.  The constructor "
"takes three optional arguments -- a message format string, a date format "
"string and a style indicator."
msgstr ""
"Об’єкти форматувальника налаштовують остаточний порядок, структуру та вміст "
"повідомлення журналу. На відміну від базового класу :class:`logging."
"Handler`, код програми може створювати екземпляри класів форматера, хоча ви, "
"ймовірно, можете створити підкласи форматера, якщо ваша програма потребує "
"особливої поведінки. Конструктор приймає три необов'язкові аргументи - рядок "
"формату повідомлення, рядок формату дати та індикатор стилю."

msgid ""
"If there is no message format string, the default is to use the raw "
"message.  If there is no date format string, the default date format is:"
msgstr ""
"Якщо рядок формату повідомлення відсутній, за умовчанням використовується "
"необроблене повідомлення. Якщо рядок формату дати відсутній, стандартний "
"формат дати:"

msgid ""
"with the milliseconds tacked on at the end. The ``style`` is one of `%`, '{' "
"or '$'. If one of these is not specified, then '%' will be used."
msgstr ""
"з мілісекундами в кінці. ``Стиль`` є одним із `%`, '{' або '$'. Якщо один із "
"них не вказано, буде використано \"%\"."

msgid ""
"If the ``style`` is '%', the message format string uses ``%(<dictionary "
"key>)s`` styled string substitution; the possible keys are documented in :"
"ref:`logrecord-attributes`. If the style is '{', the message format string "
"is assumed to be compatible with :meth:`str.format` (using keyword "
"arguments), while if the style is '$' then the message format string should "
"conform to what is expected by :meth:`string.Template.substitute`."
msgstr ""
"Якщо ``стиль`` є '%', рядок формату повідомлення використовує "
"``%( <dictionary key> )s`` заміну рядка стилю; можливі ключі задокументовані "
"в :ref:`logrecord-attributes`. Якщо стиль \"{\", передбачається, що рядок "
"формату повідомлення сумісний із :meth:`str.format` (з використанням "
"ключових аргументів), тоді як якщо стиль — \"$\", то рядок формату "
"повідомлення має відповідати тому, що є очікується :meth:`string.Template."
"substitute`."

msgid "Added the ``style`` parameter."
msgstr "Додано параметр ``style``."

msgid ""
"The following message format string will log the time in a human-readable "
"format, the severity of the message, and the contents of the message, in "
"that order::"
msgstr ""
"Наступний рядок формату повідомлення реєструватиме час у зрозумілому для "
"людини форматі, серйозність повідомлення та вміст повідомлення в такому "
"порядку:"

msgid ""
"Formatters use a user-configurable function to convert the creation time of "
"a record to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute of "
"the instance to a function with the same signature as :func:`time.localtime` "
"or :func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` attribute "
"in the Formatter class (to ``time.gmtime`` for GMT display)."
msgstr ""
"Форматери використовують настроювану користувачем функцію для перетворення "
"часу створення запису в кортеж. За замовчуванням використовується :func:"
"`time.localtime`; щоб змінити це для певного екземпляра форматера, "
"установіть атрибут ``converter`` екземпляра на функцію з тим самим підписом, "
"що й :func:`time.localtime` або :func:`time.gmtime`. Щоб змінити його для "
"всіх засобів форматування, наприклад, якщо ви хочете, щоб усі часи "
"журналювання відображалися за GMT, установіть атрибут ``converter`` у класі "
"Formatter (на ``time.gmtime`` для відображення GMT)."

msgid "Configuring Logging"
msgstr "Налаштування журналювання"

msgid "Programmers can configure logging in three ways:"
msgstr "Програмісти можуть налаштувати журналювання трьома способами:"

msgid ""
"Creating loggers, handlers, and formatters explicitly using Python code that "
"calls the configuration methods listed above."
msgstr ""
"Створення реєстраторів, обробників і форматувальників явно за допомогою коду "
"Python, який викликає перелічені вище методи конфігурації."

msgid ""
"Creating a logging config file and reading it using the :func:`fileConfig` "
"function."
msgstr ""
"Створення файлу конфігурації журналу та його читання за допомогою функції :"
"func:`fileConfig`."

msgid ""
"Creating a dictionary of configuration information and passing it to the :"
"func:`dictConfig` function."
msgstr ""
"Створення словника конфігураційної інформації та передача його функції :func:"
"`dictConfig`."

msgid ""
"For the reference documentation on the last two options, see :ref:`logging-"
"config-api`.  The following example configures a very simple logger, a "
"console handler, and a simple formatter using Python code::"
msgstr ""
"Довідкову документацію щодо останніх двох параметрів див. :ref:`logging-"
"config-api`. У наступному прикладі налаштовується дуже простий реєстратор, "
"обробник консолі та простий засіб форматування за допомогою коду Python::"

msgid ""
"Running this module from the command line produces the following output:"
msgstr "Запуск цього модуля з командного рядка дає такий результат:"

msgid ""
"The following Python module creates a logger, handler, and formatter nearly "
"identical to those in the example listed above, with the only difference "
"being the names of the objects::"
msgstr ""
"Наступний модуль Python створює реєстратор, обробник і форматування, майже "
"ідентичні тим, що в наведеному вище прикладі, з тією лише різницею, як імена "
"об’єктів:"

msgid "Here is the logging.conf file:"
msgstr "Ось файл logging.conf:"

msgid ""
"The output is nearly identical to that of the non-config-file-based example:"
msgstr "Результат майже ідентичний прикладу без конфігураційного файлу:"

msgid ""
"You can see that the config file approach has a few advantages over the "
"Python code approach, mainly separation of configuration and code and the "
"ability of noncoders to easily modify the logging properties."
msgstr ""
"Ви бачите, що підхід із конфігураційним файлом має кілька переваг перед "
"підходом до коду Python, головним чином розділення конфігурації та коду та "
"можливість некодерів легко змінювати властивості журналювання."

msgid ""
"The :func:`fileConfig` function takes a default parameter, "
"``disable_existing_loggers``, which defaults to ``True`` for reasons of "
"backward compatibility. This may or may not be what you want, since it will "
"cause any non-root loggers existing before the :func:`fileConfig` call to be "
"disabled unless they (or an ancestor) are explicitly named in the "
"configuration. Please refer to the reference documentation for more "
"information, and specify ``False`` for this parameter if you wish."
msgstr ""
"Функція :func:`fileConfig` приймає параметр за замовчуванням, "
"``disable_existing_loggers``, який за умовчанням має значення ``True`` з "
"причин зворотної сумісності. Це може бути або не те, що ви хочете, оскільки "
"це призведе до вимкнення будь-яких некореневих реєстраторів, які існують до "
"виклику :func:`fileConfig`, якщо вони (або предок) явно не вказані в "
"конфігурації. Будь ласка, зверніться до довідкової документації для "
"отримання додаткової інформації та вкажіть ``False`` для цього параметра, "
"якщо хочете."

msgid ""
"The dictionary passed to :func:`dictConfig` can also specify a Boolean value "
"with key ``disable_existing_loggers``, which if not specified explicitly in "
"the dictionary also defaults to being interpreted as ``True``. This leads to "
"the logger-disabling behaviour described above, which may not be what you "
"want - in which case, provide the key explicitly with a value of ``False``."
msgstr ""
"Словник, переданий у :func:`dictConfig`, також може вказати логічне значення "
"з ключем ``disable_existing_loggers``, яке, якщо не вказано явно в словнику, "
"також за умовчанням інтерпретується як ``True``. Це призводить до поведінки "
"вимкнення реєстратора, описаної вище, яка може не відповідати вашим "
"побажанням - у такому випадку вкажіть ключ явно зі значенням ``False``."

msgid ""
"Note that the class names referenced in config files need to be either "
"relative to the logging module, or absolute values which can be resolved "
"using normal import mechanisms. Thus, you could use either :class:`~logging."
"handlers.WatchedFileHandler` (relative to the logging module) or ``mypackage."
"mymodule.MyHandler`` (for a class defined in package ``mypackage`` and "
"module ``mymodule``, where ``mypackage`` is available on the Python import "
"path)."
msgstr ""
"Зауважте, що назви класів, на які посилаються у конфігураційних файлах, "
"мають бути або відносними до модуля журналювання, або абсолютними "
"значеннями, які можна вирішити за допомогою звичайних механізмів імпорту. "
"Таким чином, ви можете використовувати :class:`~logging.handlers."
"WatchedFileHandler` (щодо модуля журналювання) або ``mypackage.mymodule."
"MyHandler`` (для класу, визначеного в пакунку ``mypackage`` і модулі "
"``mymodule``, де ``mypackage`` доступний на шляху імпорту Python)."

msgid ""
"In Python 3.2, a new means of configuring logging has been introduced, using "
"dictionaries to hold configuration information. This provides a superset of "
"the functionality of the config-file-based approach outlined above, and is "
"the recommended configuration method for new applications and deployments. "
"Because a Python dictionary is used to hold configuration information, and "
"since you can populate that dictionary using different means, you have more "
"options for configuration. For example, you can use a configuration file in "
"JSON format, or, if you have access to YAML processing functionality, a file "
"in YAML format, to populate the configuration dictionary. Or, of course, you "
"can construct the dictionary in Python code, receive it in pickled form over "
"a socket, or use whatever approach makes sense for your application."
msgstr ""
"У Python 3.2 було введено новий засіб конфігурації журналювання, "
"використовуючи словники для зберігання конфігураційної інформації. Це "
"забезпечує надмножину функціональних можливостей підходу на основі "
"конфігураційного файлу, описаного вище, і є рекомендованим методом "
"конфігурації для нових програм і розгортань. Оскільки словник Python "
"використовується для зберігання конфігураційної інформації, і оскільки ви "
"можете заповнювати цей словник різними засобами, у вас є більше можливостей "
"для конфігурації. Наприклад, ви можете використовувати файл конфігурації у "
"форматі JSON або, якщо у вас є доступ до функцій обробки YAML, файл у "
"форматі YAML, щоб заповнити словник конфігурації. Або, звісно, ви можете "
"побудувати словник у коді Python, отримати його в маринованому вигляді через "
"сокет або використати будь-який підхід, який має сенс для вашої програми."

msgid ""
"Here's an example of the same configuration as above, in YAML format for the "
"new dictionary-based approach:"
msgstr ""
"Ось приклад тієї ж конфігурації, що й вище, у форматі YAML для нового "
"підходу на основі словника:"

msgid ""
"For more information about logging using a dictionary, see :ref:`logging-"
"config-api`."
msgstr ""
"Для отримання додаткової інформації про журналювання за допомогою словника "
"див. :ref:`logging-config-api`."

msgid "What happens if no configuration is provided"
msgstr "Що станеться, якщо конфігурацію не надано"

msgid ""
"If no logging configuration is provided, it is possible to have a situation "
"where a logging event needs to be output, but no handlers can be found to "
"output the event. The behaviour of the logging package in these "
"circumstances is dependent on the Python version."
msgstr ""
"Якщо конфігурація журналювання не надається, можлива ситуація, коли потрібно "
"вивести подію журналювання, але не можна знайти обробників для виведення "
"події. Поведінка пакета журналювання в цих обставинах залежить від версії "
"Python."

msgid "For versions of Python prior to 3.2, the behaviour is as follows:"
msgstr "Для версій Python до 3.2 поведінка така:"

msgid ""
"If *logging.raiseExceptions* is ``False`` (production mode), the event is "
"silently dropped."
msgstr ""
"Якщо *logging.raiseExceptions* має значення ``False`` (виробничий режим), "
"подія мовчки видаляється."

msgid ""
"If *logging.raiseExceptions* is ``True`` (development mode), a message 'No "
"handlers could be found for logger X.Y.Z' is printed once."
msgstr ""
"Якщо *logging.raiseExceptions* має значення ``True`` (режим розробки), "
"повідомлення \"Не вдалося знайти обробників для реєстратора X.Y.Z\" "
"друкується один раз."

msgid "In Python 3.2 and later, the behaviour is as follows:"
msgstr "У Python 3.2 і пізніших версіях поведінка така:"

msgid ""
"The event is output using a 'handler of last resort', stored in ``logging."
"lastResort``. This internal handler is not associated with any logger, and "
"acts like a :class:`~logging.StreamHandler` which writes the event "
"description message to the current value of ``sys.stderr`` (therefore "
"respecting any redirections which may be in effect). No formatting is done "
"on the message - just the bare event description message is printed. The "
"handler's level is set to ``WARNING``, so all events at this and greater "
"severities will be output."
msgstr ""
"Подія виводиться за допомогою \"обробника останньої можливості\", який "
"зберігається в ``logging.lastResort``. Цей внутрішній обробник не пов’язаний "
"із жодним реєстратором і діє як :class:`~logging.StreamHandler`, який "
"записує повідомлення з описом події до поточного значення ``sys.stderr`` "
"(отже враховуючи будь-які перенаправлення, які можуть бути в ефект). "
"Повідомлення не форматується – друкується лише повідомлення з описом події. "
"Рівень обробника встановлено на ``ПОПЕРЕДЖЕННЯ``, тому всі події з цим і "
"вищими рівнями серйозності будуть виведені."

msgid ""
"To obtain the pre-3.2 behaviour, ``logging.lastResort`` can be set to "
"``None``."
msgstr ""
"Щоб отримати поведінку до 3.2, ``logging.lastResort`` можна встановити на "
"``None``."

msgid "Configuring Logging for a Library"
msgstr "Налаштування журналювання для бібліотеки"

msgid ""
"When developing a library which uses logging, you should take care to "
"document how the library uses logging - for example, the names of loggers "
"used. Some consideration also needs to be given to its logging "
"configuration. If the using application does not use logging, and library "
"code makes logging calls, then (as described in the previous section) events "
"of severity ``WARNING`` and greater will be printed to ``sys.stderr``. This "
"is regarded as the best default behaviour."
msgstr ""
"Розробляючи бібліотеку, яка використовує журналювання, ви повинні подбати "
"про документування того, як бібліотека використовує журналювання - "
"наприклад, імена використовуваних журналів. Певну увагу також слід приділити "
"його конфігурації журналювання. Якщо програма, що використовує, не "
"використовує журналювання, а код бібліотеки здійснює виклики журналювання, "
"тоді (як описано в попередньому розділі) події серйозності ``ПОПЕРЕДЖЕННЯ`` "
"і вище будуть надруковані в ``sys.stderr``. Це вважається найкращою "
"поведінкою за умовчанням."

msgid ""
"If for some reason you *don't* want these messages printed in the absence of "
"any logging configuration, you can attach a do-nothing handler to the top-"
"level logger for your library. This avoids the message being printed, since "
"a handler will always be found for the library's events: it just doesn't "
"produce any output. If the library user configures logging for application "
"use, presumably that configuration will add some handlers, and if levels are "
"suitably configured then logging calls made in library code will send output "
"to those handlers, as normal."
msgstr ""
"Якщо з якоїсь причини ви *не* хочете, щоб ці повідомлення друкувались за "
"відсутності будь-якої конфігурації журналювання, ви можете приєднати "
"обробник нічого не робити до реєстратора верхнього рівня для вашої "
"бібліотеки. Це дозволяє уникнути друку повідомлення, оскільки для подій "
"бібліотеки завжди буде знайдено обробник: він просто не створює жодних "
"виводів. Якщо користувач бібліотеки налаштовує журналювання для використання "
"програмою, імовірно, ця конфігурація додасть деякі обробники, і якщо рівні "
"налаштовано відповідним чином, виклики журналювання, зроблені в коді "
"бібліотеки, надсилатимуть вихідні дані цим обробникам, як зазвичай."

msgid ""
"A do-nothing handler is included in the logging package: :class:`~logging."
"NullHandler` (since Python 3.1). An instance of this handler could be added "
"to the top-level logger of the logging namespace used by the library (*if* "
"you want to prevent your library's logged events being output to ``sys."
"stderr`` in the absence of logging configuration). If all logging by a "
"library *foo* is done using loggers with names matching 'foo.x', 'foo.x.y', "
"etc. then the code::"
msgstr ""
"Обробник нічого не робиться включено в пакет журналювання: :class:`~logging."
"NullHandler` (починаючи з Python 3.1). Екземпляр цього обробника можна "
"додати до реєстратора верхнього рівня простору імен журналювання, який "
"використовується бібліотекою (*якщо* ви хочете запобігти виведенню "
"зареєстрованих у бібліотеці подій у ``sys.stderr`` за відсутності "
"конфігурації журналювання ). Якщо все журналювання бібліотекою *foo* "
"здійснюється за допомогою реєстраторів з іменами, що відповідають \"foo.x\", "
"\"foo.x.y\" тощо, тоді код::"

msgid ""
"should have the desired effect. If an organisation produces a number of "
"libraries, then the logger name specified can be 'orgname.foo' rather than "
"just 'foo'."
msgstr ""
"має мати бажаний ефект. Якщо організація виробляє декілька бібліотек, то "
"ім’я реєстратора може бути \"orgname.foo\", а не просто \"foo\"."

msgid ""
"It is strongly advised that you *do not add any handlers other than* :class:"
"`~logging.NullHandler` *to your library's loggers*. This is because the "
"configuration of handlers is the prerogative of the application developer "
"who uses your library. The application developer knows their target audience "
"and what handlers are most appropriate for their application: if you add "
"handlers 'under the hood', you might well interfere with their ability to "
"carry out unit tests and deliver logs which suit their requirements."
msgstr ""
"Настійно рекомендується *не додавати жодних обробників, окрім* :class:"
"`~logging.NullHandler` *до реєстраторів вашої бібліотеки*. Це пояснюється "
"тим, що конфігурація обробників є прерогативою розробника програми, який "
"використовує вашу бібліотеку. Розробник програми знає свою цільову аудиторію "
"та знає, які обробники найбільше підходять для їхньої програми: якщо ви "
"додасте обробники \"під капотом\", ви цілком можете втрутитися в їх "
"здатність виконувати модульні тести та доставляти журнали, які відповідають "
"їхнім вимогам."

msgid "Logging Levels"
msgstr "Рівні реєстрації"

msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"Числові значення рівнів журналювання наведені в наступній таблиці. Це "
"насамперед цікаво, якщо ви бажаєте визначити власні рівні та потребуєте, щоб "
"вони мали певні значення відносно попередньо визначених рівнів. Якщо ви "
"визначаєте рівень з тим самим числовим значенням, він перезаписує попередньо "
"визначене значення; попередньо визначене ім'я втрачено."

msgid "Numeric value"
msgstr "Числове значення"

msgid "50"
msgstr "50"

msgid "40"
msgstr "40"

msgid "30"
msgstr "30"

msgid "20"
msgstr "20"

msgid "10"
msgstr "10"

msgid "``NOTSET``"
msgstr "``NOTSET``"

msgid "0"
msgstr "0"

msgid ""
"Levels can also be associated with loggers, being set either by the "
"developer or through loading a saved logging configuration. When a logging "
"method is called on a logger, the logger compares its own level with the "
"level associated with the method call. If the logger's level is higher than "
"the method call's, no logging message is actually generated. This is the "
"basic mechanism controlling the verbosity of logging output."
msgstr ""
"Рівні також можуть бути пов’язані з реєстраторами, які встановлюються "
"розробником або через завантаження збереженої конфігурації журналювання. "
"Коли в реєстраторі викликається метод ведення журналу, реєстратор порівнює "
"свій власний рівень із рівнем, пов’язаним із викликом методу. Якщо рівень "
"реєстратора вищий, ніж виклик методу, повідомлення журналу фактично не "
"генерується. Це основний механізм, який контролює докладність вихідних даних "
"журналу."

msgid ""
"Logging messages are encoded as instances of the :class:`~logging.LogRecord` "
"class. When a logger decides to actually log an event, a :class:`~logging."
"LogRecord` instance is created from the logging message."
msgstr ""
"Повідомлення журналу кодуються як екземпляри класу :class:`~logging."
"LogRecord`. Коли реєстратор вирішує фактично зареєструвати подію, екземпляр :"
"class:`~logging.LogRecord` створюється з повідомлення журналу."

msgid ""
"Logging messages are subjected to a dispatch mechanism through the use of :"
"dfn:`handlers`, which are instances of subclasses of the :class:`Handler` "
"class. Handlers are responsible for ensuring that a logged message (in the "
"form of a :class:`LogRecord`) ends up in a particular location (or set of "
"locations) which is useful for the target audience for that message (such as "
"end users, support desk staff, system administrators, developers). Handlers "
"are passed :class:`LogRecord` instances intended for particular "
"destinations. Each logger can have zero, one or more handlers associated "
"with it (via the :meth:`~Logger.addHandler` method of :class:`Logger`). In "
"addition to any handlers directly associated with a logger, *all handlers "
"associated with all ancestors of the logger* are called to dispatch the "
"message (unless the *propagate* flag for a logger is set to a false value, "
"at which point the passing to ancestor handlers stops)."
msgstr ""
"Повідомлення журналювання підлягають механізму відправлення за допомогою :"
"dfn:`handlers`, які є екземплярами підкласів класу :class:`Handler`. "
"Обробники відповідають за те, щоб зареєстроване повідомлення (у формі :class:"
"`LogRecord`) потрапляло в певне місце (або набір місць), яке є корисним для "
"цільової аудиторії цього повідомлення (наприклад, кінцевих користувачів, "
"співробітники служби підтримки, системні адміністратори, розробники). "
"Обробники передають екземпляри :class:`LogRecord`, призначені для певних "
"місць призначення. Кожен реєстратор може мати нуль, один або більше "
"пов’язаних з ним обробників (через метод :meth:`~Logger.addHandler` :class:"
"`Logger`). На додаток до будь-яких обробників, безпосередньо пов’язаних із "
"реєстратором, *усі обробники, пов’язані з усіма предками реєстратора* "
"викликаються для надсилання повідомлення (якщо прапор *розповсюдження* для "
"реєстратора не має значення false, після чого передача до обробників предків "
"зупиняється)."

msgid ""
"Just as for loggers, handlers can have levels associated with them. A "
"handler's level acts as a filter in the same way as a logger's level does. "
"If a handler decides to actually dispatch an event, the :meth:`~Handler."
"emit` method is used to send the message to its destination. Most user-"
"defined subclasses of :class:`Handler` will need to override this :meth:"
"`~Handler.emit`."
msgstr ""
"Як і для реєстраторів, обробники можуть мати пов’язані з ними рівні. Рівень "
"обробника діє як фільтр так само, як і рівень реєстратора. Якщо обробник "
"вирішує фактично відправити подію, метод :meth:`~Handler.emit` "
"використовується для надсилання повідомлення до місця призначення. Більшість "
"визначених користувачем підкласів :class:`Handler` повинні замінити цей :"
"meth:`~Handler.emit`."

msgid "Custom Levels"
msgstr "Спеціальні рівні"

msgid ""
"Defining your own levels is possible, but should not be necessary, as the "
"existing levels have been chosen on the basis of practical experience. "
"However, if you are convinced that you need custom levels, great care should "
"be exercised when doing this, and it is possibly *a very bad idea to define "
"custom levels if you are developing a library*. That's because if multiple "
"library authors all define their own custom levels, there is a chance that "
"the logging output from such multiple libraries used together will be "
"difficult for the using developer to control and/or interpret, because a "
"given numeric value might mean different things for different libraries."
msgstr ""
"Визначення власних рівнів можливо, але це не обов’язково, оскільки існуючі "
"рівні було обрано на основі практичного досвіду. Однак, якщо ви впевнені, що "
"вам потрібні користувацькі рівні, слід бути дуже обережним, роблячи це, і "
"це, можливо, *дуже погана ідея визначати користувацькі рівні, якщо ви "
"розробляєте бібліотеку*. Це тому, що якщо кілька авторів бібліотек "
"визначають власні власні рівні, існує ймовірність того, що вихід журналу з "
"таких кількох бібліотек, які використовуються разом, розробнику буде важко "
"контролювати та/або інтерпретувати, оскільки дане числове значення може "
"означати різні речі для різних бібліотек."

msgid "Useful Handlers"
msgstr "Корисні обробники"

msgid ""
"In addition to the base :class:`Handler` class, many useful subclasses are "
"provided:"
msgstr ""
"Окрім базового класу :class:`Handler`, надається багато корисних підкласів:"

msgid ""
":class:`StreamHandler` instances send messages to streams (file-like "
"objects)."
msgstr ""
"Екземпляри :class:`StreamHandler` надсилають повідомлення до потоків "
"(файлоподібних об’єктів)."

msgid ":class:`FileHandler` instances send messages to disk files."
msgstr ""
"Екземпляри :class:`FileHandler` надсилають повідомлення до файлів на диску."

msgid ""
":class:`~handlers.BaseRotatingHandler` is the base class for handlers that "
"rotate log files at a certain point. It is not meant to be  instantiated "
"directly. Instead, use :class:`~handlers.RotatingFileHandler` or :class:"
"`~handlers.TimedRotatingFileHandler`."
msgstr ""
":class:`~handlers.BaseRotatingHandler` — це базовий клас для обробників, які "
"обертають файли журналів у певний момент. Він не призначений для "
"безпосереднього створення екземпляра. Замість цього використовуйте :class:"
"`~handlers.RotatingFileHandler` або :class:`~handlers."
"TimedRotatingFileHandler`."

msgid ""
":class:`~handlers.RotatingFileHandler` instances send messages to disk "
"files, with support for maximum log file sizes and log file rotation."
msgstr ""
"Екземпляри :class:`~handlers.RotatingFileHandler` надсилають повідомлення до "
"файлів на диску з підтримкою максимального розміру файлу журналу та ротації "
"файлів журналу."

msgid ""
":class:`~handlers.TimedRotatingFileHandler` instances send messages to disk "
"files, rotating the log file at certain timed intervals."
msgstr ""
":class:`~handlers.TimedRotatingFileHandler` екземпляри надсилають "
"повідомлення до дискових файлів, чергуючи файл журналу через певні проміжки "
"часу."

msgid ""
":class:`~handlers.SocketHandler` instances send messages to TCP/IP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
"Екземпляри :class:`~handlers.SocketHandler` надсилають повідомлення до "
"сокетів TCP/IP. Починаючи з версії 3.4, також підтримуються доменні сокети "
"Unix."

msgid ""
":class:`~handlers.DatagramHandler` instances send messages to UDP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
"Екземпляри :class:`~handlers.DatagramHandler` надсилають повідомлення до UDP-"
"сокетів. Починаючи з версії 3.4, також підтримуються доменні сокети Unix."

msgid ""
":class:`~handlers.SMTPHandler` instances send messages to a designated email "
"address."
msgstr ""
"Екземпляри :class:`~handlers.SMTPHandler` надсилають повідомлення на вказану "
"електронну адресу."

msgid ""
":class:`~handlers.SysLogHandler` instances send messages to a Unix syslog "
"daemon, possibly on a remote machine."
msgstr ""
"Екземпляри :class:`~handlers.SysLogHandler` надсилають повідомлення до "
"демона системного журналу Unix, можливо, на віддаленій машині."

msgid ""
":class:`~handlers.NTEventLogHandler` instances send messages to a Windows "
"NT/2000/XP event log."
msgstr ""
"Екземпляри :class:`~handlers.NTEventLogHandler` надсилають повідомлення до "
"журналу подій Windows NT/2000/XP."

msgid ""
":class:`~handlers.MemoryHandler` instances send messages to a buffer in "
"memory, which is flushed whenever specific criteria are met."
msgstr ""
"Екземпляри :class:`~handlers.MemoryHandler` надсилають повідомлення до "
"буфера в пам’яті, який очищається щоразу, коли виконуються певні критерії."

msgid ""
":class:`~handlers.HTTPHandler` instances send messages to an HTTP server "
"using either ``GET`` or ``POST`` semantics."
msgstr ""
"Екземпляри :class:`~handlers.HTTPHandler` надсилають повідомлення на сервер "
"HTTP, використовуючи семантику ``GET`` або ``POST``."

msgid ""
":class:`~handlers.WatchedFileHandler` instances watch the file they are "
"logging to. If the file changes, it is closed and reopened using the file "
"name. This handler is only useful on Unix-like systems; Windows does not "
"support the underlying mechanism used."
msgstr ""
"Екземпляри :class:`~handlers.WatchedFileHandler` спостерігають за файлом, до "
"якого вони входять. Якщо файл змінюється, він закривається та знову "
"відкривається з використанням імені файлу. Цей обробник корисний лише в Unix-"
"подібних системах; Windows не підтримує використовуваний основний механізм."

msgid ""
":class:`~handlers.QueueHandler` instances send messages to a queue, such as "
"those implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"Екземпляри :class:`~handlers.QueueHandler` надсилають повідомлення до черги, "
"як-от реалізовані в модулях :mod:`queue` або :mod:`multiprocessing`."

msgid ""
":class:`NullHandler` instances do nothing with error messages. They are used "
"by library developers who want to use logging, but want to avoid the 'No "
"handlers could be found for logger XXX' message which can be displayed if "
"the library user has not configured logging. See :ref:`library-config` for "
"more information."
msgstr ""
"Екземпляри :class:`NullHandler` нічого не роблять із повідомленнями про "
"помилки. Вони використовуються розробниками бібліотек, які хочуть "
"використовувати журналювання, але хочуть уникнути повідомлення \"Немає "
"обробників для журналу XXX\", яке може відображатися, якщо користувач "
"бібліотеки не налаштував журналювання. Перегляньте :ref:`library-config` для "
"отримання додаткової інформації."

msgid "The :class:`NullHandler` class."
msgstr "Клас :class:`NullHandler`."

msgid "The :class:`~handlers.QueueHandler` class."
msgstr "Клас :class:`~handlers.QueueHandler`."

msgid ""
"The :class:`NullHandler`, :class:`StreamHandler` and :class:`FileHandler` "
"classes are defined in the core logging package. The other handlers are "
"defined in a sub-module, :mod:`logging.handlers`. (There is also another sub-"
"module, :mod:`logging.config`, for configuration functionality.)"
msgstr ""
"Класи :class:`NullHandler`, :class:`StreamHandler` і :class:`FileHandler` "
"визначені в базовому пакеті журналювання. Інші обробники визначені в "
"підмодулі :mod:`logging.handlers`. (Існує також інший підмодуль, :mod:"
"`logging.config`, для функціональних можливостей налаштування.)"

msgid ""
"Logged messages are formatted for presentation through instances of the :"
"class:`Formatter` class. They are initialized with a format string suitable "
"for use with the % operator and a dictionary."
msgstr ""
"Зареєстровані повідомлення форматуються для представлення через екземпляри "
"класу :class:`Formatter`. Вони ініціалізуються рядком формату, придатним для "
"використання з оператором % і словником."

msgid ""
"For formatting multiple messages in a batch, instances of :class:`~handlers."
"BufferingFormatter` can be used. In addition to the format string (which is "
"applied to each message in the batch), there is provision for header and "
"trailer format strings."
msgstr ""
"Для форматування кількох повідомлень у пакеті можна використовувати "
"екземпляри :class:`~handlers.BufferingFormatter`. На додаток до рядка "
"формату (який застосовується до кожного повідомлення в пакеті), передбачено "
"рядки формату заголовка та кінця."

msgid ""
"When filtering based on logger level and/or handler level is not enough, "
"instances of :class:`Filter` can be added to both :class:`Logger` and :class:"
"`Handler` instances (through their :meth:`~Handler.addFilter` method). "
"Before deciding to process a message further, both loggers and handlers "
"consult all their filters for permission. If any filter returns a false "
"value, the message is not processed further."
msgstr ""
"Якщо фільтрації на основі рівня реєстратора та/або рівня обробника "
"недостатньо, екземпляри :class:`Filter` можна додати до екземплярів :class:"
"`Logger` і :class:`Handler` (через їх метод :meth:`~Handler.addFilter`). "
"Перш ніж вирішити продовжити обробку повідомлення, і реєстратори, і "
"обробники звертаються до всіх своїх фільтрів для отримання дозволу. Якщо "
"будь-який фільтр повертає хибне значення, повідомлення не обробляється далі."

msgid ""
"The basic :class:`Filter` functionality allows filtering by specific logger "
"name. If this feature is used, messages sent to the named logger and its "
"children are allowed through the filter, and all others dropped."
msgstr ""
"Основна функція :class:`Filter` дозволяє фільтрувати за певним іменем "
"реєстратора. Якщо використовується ця функція, повідомлення, надіслані до "
"названого реєстратора та його дочірніх елементів, пропускаються через "
"фільтр, а всі інші відкидаються."

msgid "Exceptions raised during logging"
msgstr "Винятки, які виникають під час реєстрації"

msgid ""
"The logging package is designed to swallow exceptions which occur while "
"logging in production. This is so that errors which occur while handling "
"logging events - such as logging misconfiguration, network or other similar "
"errors - do not cause the application using logging to terminate prematurely."
msgstr ""
"Пакет журналювання призначений для ковтання винятків, які виникають під час "
"входу в робочу систему. Це зроблено для того, щоб помилки, які виникають під "
"час обробки подій журналювання (наприклад, неправильна конфігурація журналу, "
"мережа чи інші подібні помилки), не призвели до передчасного завершення "
"програми, яка використовує журналювання."

msgid ""
":class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never "
"swallowed. Other exceptions which occur during the :meth:`~Handler.emit` "
"method of a :class:`Handler` subclass are passed to its :meth:`~Handler."
"handleError` method."
msgstr ""
"Винятки :class:`SystemExit` і :class:`KeyboardInterrupt` ніколи не "
"проковтуються. Інші винятки, які виникають під час методу :meth:`~Handler."
"emit` підкласу :class:`Handler`, передаються до його методу :meth:`~Handler."
"handleError`."

msgid ""
"The default implementation of :meth:`~Handler.handleError` in :class:"
"`Handler` checks to see if a module-level variable, :data:`raiseExceptions`, "
"is set. If set, a traceback is printed to :data:`sys.stderr`. If not set, "
"the exception is swallowed."
msgstr ""
"Стандартна реалізація :meth:`~Handler.handleError` в :class:`Handler` "
"перевіряє, чи встановлено змінну рівня модуля, :data:`raiseExceptions`. Якщо "
"встановлено, зворотне відстеження друкується в :data:`sys.stderr`. Якщо не "
"встановлено, виняток проковтується."

msgid ""
"The default value of :data:`raiseExceptions` is ``True``. This is because "
"during development, you typically want to be notified of any exceptions that "
"occur. It's advised that you set :data:`raiseExceptions` to ``False`` for "
"production usage."
msgstr ""
"Значенням за замовчуванням :data:`raiseExceptions` є ``True``. Це "
"пояснюється тим, що під час розробки ви зазвичай хочете отримувати "
"сповіщення про будь-які винятки, які трапляються. Радимо встановити :data:"
"`raiseExceptions` на ``False`` для використання у робочому режимі."

msgid "Using arbitrary objects as messages"
msgstr "Використання довільних об’єктів як повідомлень"

msgid ""
"In the preceding sections and examples, it has been assumed that the message "
"passed when logging the event is a string. However, this is not the only "
"possibility. You can pass an arbitrary object as a message, and its :meth:"
"`~object.__str__` method will be called when the logging system needs to "
"convert it to a string representation. In fact, if you want to, you can "
"avoid computing a string representation altogether - for example, the :class:"
"`~handlers.SocketHandler` emits an event by pickling it and sending it over "
"the wire."
msgstr ""
"У попередніх розділах і прикладах передбачалося, що повідомлення, передане "
"під час реєстрації події, є рядком. Однак це не єдина можливість. Ви можете "
"передати довільний об’єкт як повідомлення, і його метод :meth:`~object."
"__str__` буде викликано, коли системі журналювання потрібно перетворити його "
"на представлення рядка. Насправді, якщо ви хочете, ви можете взагалі "
"уникнути обчислення представлення рядка - наприклад, :class:`~handlers."
"SocketHandler` випромінює подію, вибираючи її та надсилаючи по дроту."

msgid "Optimization"
msgstr "Оптимізація"

msgid ""
"Formatting of message arguments is deferred until it cannot be avoided. "
"However, computing the arguments passed to the logging method can also be "
"expensive, and you may want to avoid doing it if the logger will just throw "
"away your event. To decide what to do, you can call the :meth:`~Logger."
"isEnabledFor` method which takes a level argument and returns true if the "
"event would be created by the Logger for that level of call. You can write "
"code like this::"
msgstr ""
"Форматування аргументів повідомлення відкладено, доки його не можна "
"уникнути. Однак обчислення аргументів, переданих до методу журналювання, "
"також може бути дорогим, і ви можете уникнути цього, якщо реєстратор просто "
"відкине вашу подію. Щоб вирішити, що робити, ви можете викликати метод :meth:"
"`~Logger.isEnabledFor`, який приймає аргумент рівня та повертає значення "
"true, якщо подію буде створено реєстратором для цього рівня виклику. Ви "
"можете написати такий код:"

msgid ""
"so that if the logger's threshold is set above ``DEBUG``, the calls to :func:"
"`expensive_func1` and :func:`expensive_func2` are never made."
msgstr ""
"тому, якщо порогове значення реєстратора встановлено вище ``DEBUG``, "
"виклики :func:`expensive_func1` і :func:`expensive_func2` ніколи не "
"здійснюються."

msgid ""
"In some cases, :meth:`~Logger.isEnabledFor` can itself be more expensive "
"than you'd like (e.g. for deeply nested loggers where an explicit level is "
"only set high up in the logger hierarchy). In such cases (or if you want to "
"avoid calling a method in tight loops), you can cache the result of a call "
"to :meth:`~Logger.isEnabledFor` in a local or instance variable, and use "
"that instead of calling the method each time. Such a cached value would only "
"need to be recomputed when the logging configuration changes dynamically "
"while the application is running (which is not all that common)."
msgstr ""
"У деяких випадках :meth:`~Logger.isEnabledFor` сам по собі може бути "
"дорожчим, ніж вам хотілося б (наприклад, для глибоко вкладених реєстраторів, "
"де явний рівень встановлюється лише високо в ієрархії реєстратора). У таких "
"випадках (або якщо ви хочете уникнути виклику методу в жорстких циклах), ви "
"можете кешувати результат виклику :meth:`~Logger.isEnabledFor` у локальній "
"змінній чи змінній екземпляра та використовувати це замість виклику метод "
"кожного разу. Таке кешоване значення потрібно було б повторно обчислити лише "
"тоді, коли конфігурація журналювання динамічно змінюється під час роботи "
"програми (що не так вже й часто)."

msgid ""
"There are other optimizations which can be made for specific applications "
"which need more precise control over what logging information is collected. "
"Here's a list of things you can do to avoid processing during logging which "
"you don't need:"
msgstr ""
"Існують інші оптимізації, які можна зробити для конкретних програм, які "
"потребують більш точного контролю над тим, яка інформація журналу "
"збирається. Ось список речей, які ви можете зробити, щоб уникнути обробки "
"під час журналювання, яка вам не потрібна:"

msgid "What you don't want to collect"
msgstr "Те, що ви не хочете збирати"

msgid "How to avoid collecting it"
msgstr "Як уникнути його збору"

msgid "Information about where calls were made from."
msgstr "Інформація про те, звідки дзвонили."

msgid ""
"Set ``logging._srcfile`` to ``None``. This avoids calling :func:`sys."
"_getframe`, which may help to speed up your code in environments like PyPy "
"(which can't speed up code that uses :func:`sys._getframe`)."
msgstr ""
"Встановіть для ``logging._srcfile`` значення ``None``. Це дозволяє уникнути "
"виклику :func:`sys._getframe`, що може допомогти пришвидшити ваш код у таких "
"середовищах, як PyPy (який не може прискорити код, який використовує :func:"
"`sys._getframe`)."

msgid "Threading information."
msgstr "Інформація про потоки."

msgid "Set ``logging.logThreads`` to ``False``."
msgstr "Встановіть для ``logging.logThreads`` значення ``False``."

msgid "Current process ID (:func:`os.getpid`)"
msgstr "Ідентифікатор поточного процесу (:func:`os.getpid`)"

msgid "Set ``logging.logProcesses`` to ``False``."
msgstr "Встановіть для ``logging.logProcesses`` значення ``False``."

msgid ""
"Current process name when using ``multiprocessing`` to manage multiple "
"processes."
msgstr ""
"Поточне ім’я процесу, якщо для керування кількома процесами використовується "
"``багатопроцесорна обробка``."

msgid "Set ``logging.logMultiprocessing`` to ``False``."
msgstr "Встановіть для ``logging.logMultiprocessing`` значення ``False``."

msgid ""
"Also note that the core logging module only includes the basic handlers. If "
"you don't import :mod:`logging.handlers` and :mod:`logging.config`, they "
"won't take up any memory."
msgstr ""
"Також зауважте, що основний модуль журналювання включає лише основні "
"обробники. Якщо ви не імпортуєте :mod:`logging.handlers` і :mod:`logging."
"config`, вони не займатимуть жодної пам’яті."

msgid "Module :mod:`logging`"
msgstr "Модуль :mod:`logging`"

msgid "API reference for the logging module."
msgstr "Довідник API для модуля журналювання."

msgid "Module :mod:`logging.config`"
msgstr "Модуль :mod:`logging.config`"

msgid "Configuration API for the logging module."
msgstr "API конфігурації для модуля журналювання."

msgid "Module :mod:`logging.handlers`"
msgstr "Модуль :mod:`logging.handlers`"

msgid "Useful handlers included with the logging module."
msgstr "Корисні обробники, включені в модуль журналювання."

msgid ":ref:`A logging cookbook <logging-cookbook>`"
msgstr ":ref:`Кулінарна книга журналювання <logging-cookbook>`"
