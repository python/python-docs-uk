# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Descriptor HowTo Guide"
msgstr "Дескриптор Інструкції"

msgid "Author"
msgstr "Автор"

msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

msgid "Contact"
msgstr "контакт"

msgid "<python at rcn dot com>"
msgstr " <python at rcn dot com>"

msgid "Contents"
msgstr "Зміст"

msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ""
":term:`Дескриптори <descriptor>` дозволяють об’єктам налаштовувати пошук "
"атрибутів, зберігання та видалення."

msgid "This guide has four major sections:"
msgstr "Цей посібник складається з чотирьох основних розділів:"

msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr ""
"\"Буквар\" дає базовий огляд, обережно переходячи від простих прикладів, "
"додаючи одну функцію за раз. Почніть тут, якщо ви новачок у дескрипторах."

msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr ""
"Другий розділ показує повний, практичний приклад дескриптора. Якщо ви вже "
"знаєте основи, почніть з цього."

msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""
"Третій розділ містить більш технічний підручник, який детально описує "
"механізм роботи дескрипторів. Більшості людей не потрібен такий рівень "
"деталізації."

msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into "
"bound methods or about the implementation of common tools like :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, and :term:`__slots__`."
msgstr ""
"Останній розділ містить чисті еквіваленти Python для вбудованих "
"дескрипторів, написаних мовою C. Прочитайте це, якщо вам цікаво, як функції "
"перетворюються на зв’язані методи, або про реалізацію звичайних "
"інструментів, таких як :func:`classmethod`, :func:`staticmethod`, :func:"
"`property` і :term:`__slots__`."

msgid "Primer"
msgstr "Буквар"

msgid ""
"In this primer, we start with the most basic possible example and then we'll "
"add new capabilities one by one."
msgstr ""
"У цьому посібнику ми починаємо з найпростішого можливого прикладу, а потім "
"будемо додавати нові можливості одну за одною."

msgid "Simple example: A descriptor that returns a constant"
msgstr "Простий приклад: дескриптор, який повертає константу"

msgid ""
"The :class:`Ten` class is a descriptor whose :meth:`__get__` method always "
"returns the constant ``10``:"
msgstr ""
"Клас :class:`Ten` — це дескриптор, чий метод :meth:`__get__` завжди повертає "
"константу ``10``:"

msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr ""
"Щоб використовувати дескриптор, його потрібно зберегти як змінну класу в "
"іншому класі:"

msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr ""
"Інтерактивний сеанс показує різницю між звичайним пошуком атрибута та "
"пошуком дескриптора:"

msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"Під час пошуку атрибутів ``a.x`` оператор крапки знаходить ``'x': 5`` у "
"словнику класу. Під час пошуку ``a.y`` оператор точки знаходить екземпляр "
"дескриптора, розпізнаний його методом ``__get__``. Виклик цього методу "
"повертає ``10``."

msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr ""
"Зверніть увагу, що значення ``10`` не зберігається ні в словнику класу, ні в "
"словнику екземпляра. Натомість значення ``10`` обчислюється на вимогу."

msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr ""
"Цей приклад показує, як працює простий дескриптор, але він не дуже корисний. "
"Для отримання констант кращим буде звичайний пошук атрибутів."

msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr "У наступному розділі ми створимо щось більш корисне, динамічний пошук."

msgid "Dynamic lookups"
msgstr "Динамічні пошуки"

msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr ""
"Цікаві дескриптори зазвичай запускають обчислення замість повернення "
"констант:"

msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr ""
"Інтерактивний сеанс показує, що пошук є динамічним — він щоразу обчислює "
"різні оновлені відповіді:"

msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter is "
"either *g* or *s*, an instance of *Directory*.  It is the *obj* parameter "
"that lets the :meth:`__get__` method learn the target directory.  The "
"*objtype* parameter is the class *Directory*."
msgstr ""
"Крім показу того, як дескриптори можуть запускати обчислення, цей приклад "
"також показує призначення параметрів для :meth:`__get__`. Параметр *self* — "
"це *size*, екземпляр *DirectorySize*. Параметр *obj* — це або *g*, або *s*, "
"екземпляр *Directory*. Саме параметр *obj* дозволяє методу :meth:`__get__` "
"вивчати цільовий каталог. Параметр *objtype* є класом *Directory*."

msgid "Managed attributes"
msgstr "Керовані атрибути"

msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods "
"are triggered when the public attribute is accessed."
msgstr ""
"Популярним використанням дескрипторів є керування доступом до даних "
"екземплярів. Дескриптор призначається публічному атрибуту в словнику класу, "
"а фактичні дані зберігаються як приватний атрибут у словнику екземпляра. "
"Методи дескриптора :meth:`__get__` і :meth:`__set__` запускаються під час "
"доступу до публічного атрибута."

msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr ""
"У наступному прикладі *age* є публічним атрибутом, а *_age* є приватним. "
"Коли здійснюється доступ до публічного атрибута, дескриптор реєструє пошук "
"або оновлення:"

msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr ""
"Інтерактивний сеанс показує, що весь доступ до керованого атрибута *age* "
"реєструється, але звичайний атрибут *name* не реєструється:"

msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can "
"only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"Однією з основних проблем у цьому прикладі є те, що приватне ім’я *_age* "
"закріплено в класі *LoggedAgeAccess*. Це означає, що кожен екземпляр може "
"мати лише один зареєстрований атрибут і що його ім’я не змінюється. У "
"наступному прикладі ми вирішимо цю проблему."

msgid "Customized names"
msgstr "Індивідуальні імена"

msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr ""
"Коли клас використовує дескриптори, він може інформувати кожен дескриптор "
"про те, яке ім'я змінної було використано."

msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field names "
"can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"У цьому прикладі клас :class:`Person` має два екземпляри дескриптора, *name* "
"і *age*. Коли визначено клас :class:`Person`, він здійснює зворотний виклик "
"до :meth:`__set_name__` у *LoggedAccess*, щоб можна було записати назви "
"полів, надаючи кожному дескриптору власні *public_name* і *private_name*:"

msgid ""
"An interactive session shows that the :class:`Person` class has called :meth:"
"`__set_name__` so that the field names would be recorded.  Here we call :"
"func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"Інтерактивний сеанс показує, що клас :class:`Person` викликав :meth:"
"`__set_name__`, щоб назви полів були записані. Тут ми викликаємо :func:"
"`vars` для пошуку дескриптора без його запуску:"

msgid "The new class now logs access to both *name* and *age*:"
msgstr "Новий клас тепер реєструє доступ як до *ім’я*, так і до *віку*:"

msgid "The two *Person* instances contain only the private names:"
msgstr "Два екземпляри *Person* містять лише приватні імена:"

msgid "Closing thoughts"
msgstr "Закриття думок"

msgid ""
"A :term:`descriptor` is what we call any object that defines :meth:"
"`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""
":term:`descriptor` — це те, що ми називаємо будь-яким об’єктом, який "
"визначає :meth:`__get__`, :meth:`__set__` або :meth:`__delete__`."

msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class where "
"it was created or the name of class variable it was assigned to.  (This "
"method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"Додатково дескриптори можуть мати метод :meth:`__set_name__`. Це "
"використовується лише у випадках, коли дескриптору потрібно знати або клас, "
"у якому він був створений, або назву змінної класу, якій він був "
"призначений. (Цей метод, якщо він присутній, викликається, навіть якщо клас "
"не є дескриптором.)"

msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with ``vars(some_class)"
"[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""
"Дескриптори викликаються оператором крапки під час пошуку атрибутів. Якщо до "
"дескриптора звертаються опосередковано за допомогою ``vars(some_class)"
"[descriptor_name]``, екземпляр дескриптора повертається без його виклику."

msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr ""
"Дескриптори працюють лише тоді, коли використовуються як змінні класу. Якщо "
"їх поставити в інстанції, вони не мають ефекту."

msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr ""
"Основна мотивація для дескрипторів полягає в тому, щоб надати гачок, який "
"дозволяє об’єктам, що зберігаються у змінних класу, контролювати те, що "
"відбувається під час пошуку атрибутів."

msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr ""
"Традиційно викликаючий клас контролює те, що відбувається під час пошуку. "
"Дескриптори інвертують цей зв’язок і дозволяють шуканим даним мати право "
"голосу в цьому питанні."

msgid ""
"Descriptors are used throughout the language.  It is how functions turn into "
"bound methods.  Common tools like :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, and :func:`functools.cached_property` are "
"all implemented as descriptors."
msgstr ""
"Дескриптори використовуються в усій мові. Саме так функції перетворюються на "
"зв’язані методи. Загальні інструменти, такі як :func:`classmethod`, :func:"
"`staticmethod`, :func:`property` і :func:`functools.cached_property`, усі "
"реалізовані як дескриптори."

msgid "Complete Practical Example"
msgstr "Повний практичний приклад"

msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr ""
"У цьому прикладі ми створюємо практичний і потужний інструмент для виявлення "
"помилок пошкодження даних, які, як відомо, важко знайти."

msgid "Validator class"
msgstr "Клас валідатора"

msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"Валідатор — це дескриптор керованого доступу до атрибутів. Перш ніж "
"зберігати будь-які дані, він перевіряє, чи нове значення відповідає різним "
"обмеженням типу та діапазону. Якщо ці обмеження не виконуються, створюється "
"виняток, щоб запобігти пошкодженню даних у їх джерелі."

msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr ""
"Цей клас :class:`Validator` є водночас :term:`abstract base class` і "
"дескриптором керованих атрибутів:"

msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply a :"
"meth:`validate` method to test various restrictions as needed."
msgstr ""
"Спеціальні валідатори повинні успадкувати :class:`Validator` і надати метод :"
"meth:`validate` для перевірки різноманітних обмежень за потреби."

msgid "Custom validators"
msgstr "Спеціальні валідатори"

msgid "Here are three practical data validation utilities:"
msgstr "Ось три практичні утиліти перевірки даних:"

msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of options."
msgstr ""
":class:`OneOf` перевіряє, чи значення є одним із обмеженого набору "
"параметрів."

msgid ""
":class:`Number` verifies that a value is either an :class:`int` or :class:"
"`float`.  Optionally, it verifies that a value is between a given minimum or "
"maximum."
msgstr ""
":class:`Number` перевіряє, чи значення є або :class:`int`, або :class:"
"`float`. За бажанням він перевіряє, чи значення знаходиться між заданим "
"мінімумом або максимумом."

msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ "
"as well."
msgstr ""
":class:`String` перевіряє, що значення є :class:`str`. За бажанням він "
"перевіряє задану мінімальну або максимальну довжину. Він також може "
"перевірити визначений користувачем `предикат <https://en.wikipedia.org/wiki/"
"Predicate_(mathematical_logic)>`_."

msgid "Practical application"
msgstr "Практичне застосування"

msgid "Here's how the data validators can be used in a real class:"
msgstr "Ось як валідатори даних можна використовувати в реальному класі:"

msgid "The descriptors prevent invalid instances from being created:"
msgstr "Дескриптори запобігають створенню недійсних екземплярів:"

msgid "Technical Tutorial"
msgstr "Технічний підручник"

msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr ""
"Далі є більш технічний підручник для механіки та деталей роботи дескрипторів."

msgid "Abstract"
msgstr "Анотація"

msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr ""
"Визначає дескриптори, підсумовує протокол і показує, як викликаються "
"дескриптори. Надає приклад, який показує, як працюють об’єктно-реляційні "
"відображення."

msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr ""
"Вивчення дескрипторів не тільки забезпечує доступ до більшого набору "
"інструментів, це створює глибше розуміння того, як працює Python."

msgid "Definition and introduction"
msgstr "Визначення та вступ"

msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`__get__`, :meth:"
"`__set__`, and :meth:`__delete__`.  If any of those methods are defined for "
"an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"Загалом, дескриптор — це значення атрибута, яке має один із методів у "
"протоколі дескриптора. Ці методи: :meth:`__get__`, :meth:`__set__` і :meth:"
"`__delete__`. Якщо будь-який із цих методів визначено для атрибута, він "
"називається :term:`descriptor`."

msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the method resolution order of ``type(a)``. If the looked-"
"up value is an object defining one of the descriptor methods, then Python "
"may override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"Поведінка за умовчанням для доступу до атрибутів полягає в отриманні, "
"установці або видаленні атрибута зі словника об’єкта. Наприклад, ``a.x`` має "
"ланцюжок пошуку, починаючи з ``a.__dict__['x']``, потім ``type(a)."
"__dict__['x']`` і продовжуючи через дозвіл методу порядок ``type(a)``. Якщо "
"шукане значення є об’єктом, що визначає один із методів дескриптора, тоді "
"Python може замінити поведінку за замовчуванням і замість цього викликати "
"метод дескриптора. Де це відбувається в ланцюжку пріоритетів, залежить від "
"того, які методи дескриптора були визначені."

msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""
"Дескриптори — це потужний протокол загального призначення. Вони є "
"механізмом, що стоїть за властивостями, методами, статичними методами, "
"методами класу та :func:`super()`. Вони використовуються в самому Python. "
"Дескриптори спрощують базовий код C і пропонують гнучкий набір нових "
"інструментів для щоденних програм Python."

msgid "Descriptor protocol"
msgstr "Дескрипторний протокол"

msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> значення``"

msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"Це все. Визначте будь-який із цих методів, і об’єкт вважатиметься "
"дескриптором і зможе замінити поведінку за замовчуванням, якщо його шукати "
"як атрибут."

msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered "
"a data descriptor.  Descriptors that only define :meth:`__get__` are called "
"non-data descriptors (they are often used for methods but other uses are "
"possible)."
msgstr ""
"Якщо об’єкт визначає :meth:`__set__` або :meth:`__delete__`, він вважається "
"дескриптором даних. Дескриптори, які визначають лише :meth:`__get__`, "
"називаються дескрипторами не даних (вони часто використовуються для методів, "
"але можливі й інші способи використання)."

msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"Дескриптори даних і не даних відрізняються тим, як обчислюються "
"перевизначення щодо записів у словнику екземпляра. Якщо в словнику "
"екземпляра є запис із таким самим іменем, як і дескриптор даних, дескриптор "
"даних має пріоритет. Якщо в словнику екземпляра є запис із таким же ім’ям, "
"що й дескриптор, що не є даними, пріоритет має словниковий запис."

msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and :meth:"
"`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when "
"called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"Щоб створити дескриптор даних лише для читання, визначте :meth:`__get__` і :"
"meth:`__set__` з :meth:`__set__`, що викликає :exc:`AttributeError` під час "
"виклику. Щоб зробити його дескриптором даних, достатньо визначити метод :"
"meth:`__set__` із заповнювачем, що викликає винятки."

msgid "Overview of descriptor invocation"
msgstr "Огляд виклику дескриптора"

msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or ``desc."
"__get__(None, cls)``."
msgstr ""
"Дескриптор можна викликати безпосередньо за допомогою ``desc.__get__(obj)`` "
"або ``desc.__get__(None, cls)``."

msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""
"Але частіше дескриптор викликається автоматично з доступу до атрибутів."

msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance ``__dict__``, its :meth:`__get__` method is invoked according to "
"the precedence rules listed below."
msgstr ""
"Вираз ``obj.x`` шукає атрибут ``x`` у ланцюжку просторів імен для ``obj``. "
"Якщо пошук знаходить дескриптор за межами екземпляра ``__dict__``, його "
"метод :meth:`__get__` викликається згідно з правилами пріоритету, наведеними "
"нижче."

msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr ""
"Деталі виклику залежать від того, чи є ``obj`` об'єктом, класом або "
"екземпляром super."

msgid "Invocation from an instance"
msgstr "Виклик із екземпляра"

msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`__getattr__` if it is "
"provided."
msgstr ""
"Пошук екземплярів сканує ланцюжок просторів імен, надаючи найвищий пріоритет "
"дескрипторам даних, потім змінним екземплярів, потім дескрипторам, що не є "
"даними, потім змінним класу, і нарешті :meth:`__getattr__`, якщо він "
"надається."

msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: ``desc."
"__get__(a, type(a))``."
msgstr ""
"Якщо для ``a.x`` знайдено дескриптор, він викликається за допомогою: ``desc."
"__get__(a, type(a))``."

msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr ""
"Логіка пошуку з пунктиром міститься в :meth:`object.__getattribute__`. Ось "
"чистий еквівалент Python:"

msgid ""
"Note, there is no :meth:`__getattr__` hook in the :meth:`__getattribute__` "
"code.  That is why calling :meth:`__getattribute__` directly or with "
"``super().__getattribute__`` will bypass :meth:`__getattr__` entirely."
msgstr ""
"Зауважте, що в коді :meth:`__getattribute__` немає хука :meth:`__getattr__`. "
"Ось чому виклик :meth:`__getattribute__` безпосередньо або за допомогою "
"``super().__getattribute__`` повністю обійде :meth:`__getattr__`."

msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`__getattr__` whenever :meth:"
"`__getattribute__` raises an :exc:`AttributeError`.  Their logic is "
"encapsulated in a helper function:"
msgstr ""
"Натомість це оператор крапки та функція :func:`getattr`, які відповідають за "
"виклик :meth:`__getattr__` щоразу, коли :meth:`__getattribute__` викликає :"
"exc:`AttributeError`. Їхня логіка інкапсульована в допоміжній функції:"

msgid "Invocation from a class"
msgstr "Виклик із класу"

msgid ""
"The logic for a dotted lookup such as ``A.x`` is in :meth:`type."
"__getattribute__`.  The steps are similar to those for :meth:`object."
"__getattribute__` but the instance dictionary lookup is replaced by a search "
"through the class's :term:`method resolution order`."
msgstr ""
"Логіка пошуку з пунктиром, наприклад ``A.x``, знаходиться в :meth:`type."
"__getattribute__`. Кроки подібні до кроків для :meth:`object."
"__getattribute__`, але пошук у словнику екземпляра замінюється пошуком у :"
"term:`method resolution order` класу."

msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr ""
"Якщо дескриптор знайдено, він викликається за допомогою ``desc.__get__(None, "
"A)``."

msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and :c:"
"func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""
"Повну реалізацію C можна знайти в :c:func:`type_getattro()` і :c:func:"
"`_PyType_Lookup()` у :source:`Objects/typeobject.c`."

msgid "Invocation from super"
msgstr "Заклик від супер"

msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr ""
"Логіка пошуку з пунктиром super полягає в методі :meth:`__getattribute__` "
"для об’єкта, який повертає :class:`super()`."

msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches ``obj.__class__."
"__mro__`` for the base class ``B`` immediately following ``A`` and then "
"returns ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is "
"returned unchanged."
msgstr ""
"Пошук із пунктиром, наприклад ``super(A, obj).m``, шукає ``obj.__class__."
"__mro__`` для базового класу ``B`` відразу після ``A``, а потім повертає "
"``B\". __dict__['m'].__get__(obj, A)``. Якщо не є дескриптором, ``m`` "
"повертається без змін."

msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in :"
"source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."
msgstr ""
"Повну реалізацію C можна знайти в :c:func:`super_getattro()` в :source:"
"`Objects/typeobject.c`. Чистий еквівалент Python можна знайти в `Посібнику "
"Guido <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."

msgid "Summary of invocation logic"
msgstr "Короткий опис логіки виклику"

msgid ""
"The mechanism for descriptors is embedded in the :meth:`__getattribute__()` "
"methods for :class:`object`, :class:`type`, and :func:`super`."
msgstr ""
"Механізм для дескрипторів вбудовано в методи :meth:`__getattribute__()` для :"
"class:`object`, :class:`type` і :func:`super`."

msgid "The important points to remember are:"
msgstr "Важливо пам’ятати:"

msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "Дескриптори викликаються методом :meth:`__getattribute__`."

msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or :func:"
"`super`."
msgstr ""
"Класи успадковують цей механізм від :class:`object`, :class:`type` або :func:"
"`super`."

msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr ""
"Перевизначення :meth:`__getattribute__` запобігає автоматичним викликам "
"дескриптора, оскільки вся логіка дескриптора міститься в цьому методі."

msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and may "
"include the class.  The second puts in ``None`` for the instance and always "
"includes the class."
msgstr ""
":meth:`object.__getattribute__` і :meth:`type.__getattribute__` здійснюють "
"різні виклики :meth:`__get__`. Перший включає екземпляр і може включати "
"клас. Другий ставить ``None`` для екземпляра та завжди включає клас."

msgid "Data descriptors always override instance dictionaries."
msgstr "Дескриптори даних завжди перевизначають словники примірників."

msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr ""
"Дескриптори, не пов’язані з даними, можуть бути перевизначені словниками "
"примірників."

msgid "Automatic name notification"
msgstr "Автоматичне сповіщення про ім'я"

msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`__set_name__`, that method is called "
"with two arguments.  The *owner* is the class where the descriptor is used, "
"and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"Іноді дескриптору бажано знати, яке ім'я змінної класу було призначено. Коли "
"створюється новий клас, метаклас :class:`type` сканує словник нового класу. "
"Якщо будь-який із записів є дескрипторами та якщо вони визначають :meth:"
"`__set_name__`, цей метод викликається з двома аргументами. *Власник* — це "
"клас, де використовується дескриптор, а *ім’я* — це змінна класу, якій "
"призначено дескриптор."

msgid ""
"The implementation details are in :c:func:`type_new()` and :c:func:"
"`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""
"Деталі реалізації знаходяться в :c:func:`type_new()` і :c:func:`set_names()` "
"в :source:`Objects/typeobject.c`."

msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`__set_name__` will need to be called manually."
msgstr ""
"Оскільки логіка оновлення знаходиться в :meth:`type.__new__`, сповіщення "
"надходять лише під час створення класу. Якщо дескриптори додаються до класу "
"пізніше, :meth:`__set_name__` потрібно буде викликати вручну."

msgid "ORM example"
msgstr "Приклад ORM"

msgid ""
"The following code is simplified skeleton showing how data descriptors could "
"be used to implement an `object relational mapping <https://en.wikipedia.org/"
"wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"Наступний код є спрощеним скелетом, який показує, як можна використовувати "
"дескриптори даних для реалізації `об’єктно-реляційного відображення <https://"
"en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."

msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr ""
"Основна ідея полягає в тому, що дані зберігаються у зовнішній базі даних. "
"Екземпляри Python містять лише ключі до таблиць бази даних. Дескриптори "
"піклуються про пошук або оновлення:"

msgid ""
"We can use the :class:`Field` class to define `models <https://en.wikipedia."
"org/wiki/Database_model>`_ that describe the schema for each table in a "
"database:"
msgstr ""
"Ми можемо використовувати клас :class:`Field`, щоб визначити `моделі "
"<https://en.wikipedia.org/wiki/Database_model>`_, які описують схему для "
"кожної таблиці в базі даних:"

msgid "To use the models, first connect to the database::"
msgstr "Щоб використовувати моделі, спочатку підключіться до бази даних:"

msgid ""
"An interactive session shows how data is retrieved from the database and how "
"it can be updated:"
msgstr ""
"Інтерактивний сеанс показує, як дані витягуються з бази даних і як їх можна "
"оновити:"

msgid "Pure Python Equivalents"
msgstr "Чисті еквіваленти Python"

msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"Протокол дескриптора простий і пропонує захоплюючі можливості. Кілька "
"варіантів використання настільки поширені, що вони були попередньо упаковані "
"у вбудовані інструменти. Властивості, прив’язані методи, статичні методи, "
"методи класу та \\_\\_слоти\\_\\_ базуються на протоколі дескриптора."

msgid "Properties"
msgstr "Властивості"

msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr ""
"Виклик :func:`property` — це короткий спосіб створення дескриптора даних, "
"який ініціює виклик функції після доступу до атрибута. Його підпис::"

msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr ""
"У документації показано типове використання для визначення керованого "
"атрибута ``x``:"

msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr ""
"Щоб побачити, як :func:`property` реалізовано в термінах протоколу "
"дескриптора, ось чистий еквівалент Python:"

msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"Вбудована функція :func:`property` допомагає щоразу, коли інтерфейс "
"користувача надає доступ до атрибутів, а подальші зміни вимагають втручання "
"методу."

msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"Наприклад, клас електронної таблиці може надати доступ до значення клітинки "
"через ``Cell('b10').value``. Подальші вдосконалення програми вимагають "
"перерахунку комірки при кожному доступі; однак програміст не хоче впливати "
"на існуючий клієнтський код, який безпосередньо звертається до атрибута. "
"Рішення полягає в тому, щоб загорнути доступ до атрибута значення в "
"дескриптор даних властивості:"

msgid ""
"Either the built-in :func:`property` or our :func:`Property` equivalent "
"would work in this example."
msgstr ""
"У цьому прикладі працюватиме або вбудований :func:`property`, або наш "
"еквівалент :func:`Property`."

msgid "Functions and methods"
msgstr "Функції та методи"

msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Об’єктно-орієнтовані функції Python побудовані на функціональному "
"середовищі. Використовуючи дескриптори, не пов’язані з даними, ці два "
"об’єднуються без проблем."

msgid ""
"Functions stored in class dictionaries get turned into methods when invoked. "
"Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"Функції, що зберігаються в словниках класів, під час виклику перетворюються "
"на методи. Методи відрізняються від звичайних функцій лише тим, що екземпляр "
"об’єкта додається до інших аргументів. За домовленістю екземпляр називається "
"*self*, але може мати назву *this* або будь-яке інше ім’я змінної."

msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr ""
"Методи можна створити вручну за допомогою :class:`types.MethodType`, що "
"приблизно еквівалентно:"

msgid ""
"To support automatic creation of methods, functions include the :meth:"
"`__get__` method for binding methods during attribute access.  This means "
"that functions are non-data descriptors that return bound methods during "
"dotted lookup from an instance.  Here's how it works:"
msgstr ""
"Щоб підтримувати автоматичне створення методів, функції включають метод :"
"meth:`__get__` для зв’язування методів під час доступу до атрибутів. Це "
"означає, що функції є дескрипторами, не пов’язаними з даними, які повертають "
"пов’язані методи під час пошуку з пунктиром з екземпляра. Ось як це працює:"

msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr ""
"Запуск наступного класу в інтерпретаторі показує, як дескриптор функції "
"працює на практиці:"

msgid ""
"The function has a :term:`qualified name` attribute to support introspection:"
msgstr "Функція має атрибут :term:`qualified name` для підтримки самоаналізу:"

msgid ""
"Accessing the function through the class dictionary does not invoke :meth:"
"`__get__`.  Instead, it just returns the underlying function object::"
msgstr ""
"Доступ до функції через словник класу не викликає :meth:`__get__`. Замість "
"цього він просто повертає базовий об’єкт функції::"

msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr ""
"Пунктирний доступ із класу викликає :meth:`__get__`, який просто повертає "
"базову функцію без змін::"

msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`__get__` which returns a bound method object::"
msgstr ""
"Цікава поведінка відбувається під час доступу з екземпляра з пунктиром. "
"Пошук із пунктиром викликає :meth:`__get__`, який повертає пов’язаний об’єкт "
"методу::"

msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr ""
"Внутрішньо зв’язаний метод зберігає базову функцію та зв’язаний екземпляр::"

msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""
"Якщо ви коли-небудь задавалися питанням, звідки береться *self* у звичайних "
"методах або звідки *cls* у методах класу, то це все!"

msgid "Kinds of methods"
msgstr "Види методів"

msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr ""
"Дескриптори, не пов’язані з даними, надають простий механізм для варіацій "
"звичайних шаблонів зв’язування функцій у методи."

msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``cls."
"f(*args)`` becomes ``f(*args)``."
msgstr ""
"Підсумовуючи, функції мають метод :meth:`__get__`, щоб їх можна було "
"перетворити на метод, коли вони доступні як атрибути. Дескриптор без даних "
"перетворює виклик ``obj.f(*args)`` на ``f(obj, *args)``. Виклик ``cls."
"f(*args)`` перетворюється на ``f(*args)``."

msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "Ця діаграма підсумовує прив’язку та два її найкорисніші варіанти:"

msgid "Transformation"
msgstr "Трансформація"

msgid "Called from an object"
msgstr "Викликано з об'єкта"

msgid "Called from a class"
msgstr "Подзвонили з класу"

msgid "function"
msgstr "функція"

msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

msgid "f(\\*args)"
msgstr "f(\\*args)"

msgid "staticmethod"
msgstr "статичний метод"

msgid "classmethod"
msgstr "метод класу"

msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

msgid "Static methods"
msgstr "Статичні методи"

msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"Статичні методи повертають базову функцію без змін. Виклик ``c.f`` або ``C."
"f`` є еквівалентом прямого пошуку ``object.__getattribute__(c, \"f\")`` або "
"``object.__getattribute__(C, \"f\")`` . У результаті функція стає однаково "
"доступною з об’єкта або класу."

msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr ""
"Хорошими кандидатами на статичні методи є методи, які не посилаються на "
"змінну ``self``."

msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"Наприклад, пакет статистики може містити клас контейнера для "
"експериментальних даних. Клас надає звичайні методи для обчислення "
"середнього, середнього, медіани та іншої описової статистики, яка залежить "
"від даних. Однак можуть існувати корисні функції, які концептуально "
"пов’язані, але не залежать від даних. Наприклад, ``erf(x)`` — це зручна "
"процедура перетворення, яка виникає в статистичній роботі, але безпосередньо "
"не залежить від конкретного набору даних. Його можна викликати або з "
"об’єкта, або з класу: ``s.erf(1.5) --> .9332`` або ``Sample.erf(1.5) --"
"> .9332``."

msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr ""
"Оскільки статичні методи повертають базову функцію без змін, приклади "
"викликів нецікаві:"

msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this:"
msgstr ""
"Використовуючи протокол дескриптора без даних, чиста версія :func:"
"`staticmethod` на Python виглядала б так:"

msgid "Class methods"
msgstr "Методи класу"

msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"На відміну від статичних методів, методи класу додають посилання на клас до "
"списку аргументів перед викликом функції. Цей формат є однаковим для того, "
"чи є викликаючий об’єкт чи клас:"

msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"Така поведінка корисна, коли метод потребує лише посилання на клас і не "
"покладається на дані, що зберігаються в конкретному екземплярі. Одним із "
"способів використання методів класу є створення альтернативних конструкторів "
"класу. Наприклад, метод класу :func:`dict.fromkeys` створює новий словник зі "
"списку ключів. Чистий еквівалент Python:"

msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "Тепер новий словник унікальних ключів можна сконструювати так:"

msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this:"
msgstr ""
"Використовуючи протокол дескриптора без даних, чиста версія :func:"
"`classmethod` на Python виглядала б так:"

msgid ""
"The code path for ``hasattr(type(self.f), '__get__')`` was added in Python "
"3.9 and makes it possible for :func:`classmethod` to support chained "
"decorators.  For example, a classmethod and property could be chained "
"together:"
msgstr ""

msgid "Member objects and __slots__"
msgstr "Об'єкти-члени та __slots__"

msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a "
"fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr ""
"Коли клас визначає ``__slots__``, він замінює словники примірників на масив "
"значень слотів фіксованої довжини. З точки зору користувача, це має кілька "
"ефектів:"

msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr ""
"1. Забезпечує негайне виявлення помилок через неправильно написані атрибути. "
"Дозволяються лише імена атрибутів, указані в ``__slots__``:"

msgid ""
"2. Helps create immutable objects where descriptors manage access to private "
"attributes stored in ``__slots__``:"
msgstr ""
"2. Допомагає створювати незмінні об’єкти, де дескриптори керують доступом до "
"приватних атрибутів, що зберігаються в ``__slots__``:"

msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. Економить пам'ять. У 64-розрядній збірці Linux екземпляр із двома "
"атрибутами займає 48 байтів із ``__slots__`` і 152 байти без. Цей `шаблон "
"проектування легкої ваги <https://en.wikipedia.org/wiki/"
"Flyweight_pattern>`_, ймовірно, має значення лише тоді, коли буде створено "
"велику кількість екземплярів."

msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. Покращує швидкість. Читання змінних екземплярів відбувається на 35% "
"швидше за допомогою ``__slots__`` (виміряно за допомогою Python 3.10 на "
"процесорі Apple M1)."

msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""
"5. Блокує такі інструменти, як :func:`functools.cached_property`, яким для "
"коректної роботи потрібен словник екземплярів:"

msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"Неможливо створити точну версію ``__slots__`` на Python, оскільки для цього "
"потрібен прямий доступ до структур C і контроль над розподілом пам’яті "
"об’єктів. Однак ми можемо побудувати здебільшого точну симуляцію, де "
"фактична структура C для слотів емулюється приватним списком "
"``_slotvalues``. Читанням і записом у цю приватну структуру керують "
"дескриптори членів:"

msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to class "
"variables:"
msgstr ""
"Метод :meth:`type.__new__` піклується про додавання об’єктів-членів до "
"змінних класу:"

msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have "
"slots instead of an instance dictionary.  Here is a rough simulation in pure "
"Python:"
msgstr ""
"Метод :meth:`object.__new__` піклується про створення екземплярів, які мають "
"слоти замість словника екземплярів. Ось приблизне моделювання на чистому "
"Python:"

msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` and "
"set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"Щоб використовувати симуляцію в реальному класі, просто успадкуйте від :"
"class:`Object` і встановіть :term:`metaclass` на :class:`Type`:"

msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr "На даний момент метаклас завантажив об’єкти-члени для *x* і *y*::"

msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr ""
"Коли екземпляри створюються, вони мають список ``slot_values``, де "
"зберігаються атрибути:"

msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "Помилково введені або непризначені атрибути викликають виняток:"
