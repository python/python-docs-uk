# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 01:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../whatsnew/2.0.rst:3
msgid "What's New in Python 2.0"
msgstr "Що нового в Python 2.0"

#: ../../whatsnew/2.0.rst:0
msgid "Author"
msgstr "Автор"

#: ../../whatsnew/2.0.rst:5
msgid "A.M. Kuchling and Moshe Zadka"
msgstr "A.M. Kuchling та Moshe Zadka"

#: ../../whatsnew/2.0.rst:13
msgid "Introduction"
msgstr "вступ"

#: ../../whatsnew/2.0.rst:15
msgid ""
"A new release of Python, version 2.0, was released on October 16, 2000. This"
" article covers the exciting new features in 2.0, highlights some other "
"useful changes, and points out a few incompatible changes that may require "
"rewriting code."
msgstr ""
"Новий випуск Python, версія 2.0, був випущений 16 жовтня 2000 року. У цій "
"статті розглядаються цікаві нові можливості версії 2.0, висвітлюються деякі "
"інші корисні зміни та вказується на кілька несумісних змін, які можуть "
"вимагати переписування коду."

#: ../../whatsnew/2.0.rst:20
msgid ""
"Python's development never completely stops between releases, and a steady "
"flow of bug fixes and improvements are always being submitted. A host of "
"minor fixes, a few optimizations, additional docstrings, and better error "
"messages went into 2.0; to list them all would be impossible, but they're "
"certainly significant. Consult the publicly available CVS logs if you want "
"to see the full list.  This progress is due to the five developers working "
"for  PythonLabs are now getting paid to spend their days fixing bugs, and "
"also due to the improved communication resulting  from moving to "
"SourceForge."
msgstr ""

#: ../../whatsnew/2.0.rst:33
msgid "What About Python 1.6?"
msgstr "Що щодо Python 1.6?"

#: ../../whatsnew/2.0.rst:35
msgid ""
"Python 1.6 can be thought of as the Contractual Obligations Python release. "
"After the core development team left CNRI in May 2000, CNRI requested that a"
" 1.6 release be created, containing all the work on Python that had been "
"performed at CNRI.  Python 1.6 therefore represents the state of the CVS "
"tree as of May 2000, with the most significant new feature being Unicode "
"support.  Development continued after May, of course, so the 1.6 tree "
"received a few fixes to ensure that it's forward-compatible with Python 2.0."
"  1.6 is therefore part of Python's evolution, and not a side branch."
msgstr ""
"Python 1.6 можна вважати випуском Python Contractual Obligations. Після "
"того, як основна команда розробників залишила CNRI у травні 2000 року, CNRI "
"попросив створити випуск 1.6, який містив би всю роботу над Python, яка була"
" виконана в CNRI. Таким чином, Python 1.6 представляє стан дерева CVS станом"
" на травень 2000 року, причому найважливішою новою функцією є підтримка "
"Unicode. Розробка продовжилася і після травня, тому дерево 1.6 отримало "
"кілька виправлень, щоб гарантувати його сумісність із Python 2.0. Таким "
"чином, 1.6 є частиною еволюції Python, а не побічною гілкою."

#: ../../whatsnew/2.0.rst:44
msgid ""
"So, should you take much interest in Python 1.6?  Probably not.  The "
"1.6final and 2.0beta1 releases were made on the same day (September 5, "
"2000), the plan being to finalize Python 2.0 within a month or so.  If you "
"have applications to maintain, there seems little point in breaking things "
"by moving to 1.6, fixing them, and then having another round of breakage "
"within a month by moving to 2.0; you're better off just going straight to "
"2.0.  Most of the really interesting features described in this document are"
" only in 2.0, because a lot of work was done between May and September."
msgstr ""
"Отже, чи варто сильно цікавитися Python 1.6? Напевно ні. Релізи 1.6final і "
"2.0beta1 були зроблені в один і той же день (5 вересня 2000 р.), планом було"
" завершити Python 2.0 протягом місяця або близько того. Якщо у вас є "
"додатки, які потрібно підтримувати, здається, немає сенсу ламати роботу, "
"переходячи до 1.6, виправляючи їх, а потім мати ще один цикл поломок "
"протягом місяця, переходячи до 2.0; вам краще просто перейти до 2.0. "
"Більшість справді цікавих функцій, описаних у цьому документі, є лише у "
"версії 2.0, оскільки з травня по вересень було виконано багато роботи."

#: ../../whatsnew/2.0.rst:57
msgid "New Development Process"
msgstr "Новий процес розвитку"

#: ../../whatsnew/2.0.rst:59
msgid ""
"The most important change in Python 2.0 may not be to the code at all, but "
"to how Python is developed: in May 2000 the Python developers began using "
"the tools made available by SourceForge for storing  source code, tracking "
"bug reports, and managing the queue of patch submissions.  To report bugs or"
" submit patches for Python 2.0, use the bug tracking and patch manager tools"
" available from Python's project page, located at "
"https://sourceforge.net/projects/python/."
msgstr ""
"Найважливіша зміна в Python 2.0 може стосуватися зовсім не коду, а способу "
"розробки Python: у травні 2000 року розробники Python почали використовувати"
" інструменти, надані SourceForge для зберігання вихідного коду, відстеження "
"звітів про помилки та керування чергою. подання патчів. Щоб повідомити про "
"помилки або надіслати виправлення для Python 2.0, використовуйте інструменти"
" відстеження помилок і керування виправленнями, доступні на сторінці проекту"
" Python, розташованій за адресою https://sourceforge.net/projects/python/."

#: ../../whatsnew/2.0.rst:66
msgid ""
"The most important of the services now hosted at SourceForge is the Python "
"CVS tree, the version-controlled repository containing the source code for "
"Python. Previously, there were roughly 7 or so people who had write access "
"to the CVS tree, and all patches had to be inspected and checked in by one "
"of the people on this short list. Obviously, this wasn't very scalable.  By "
"moving the CVS tree to SourceForge, it became possible to grant write access"
" to more people; as of September 2000 there were 27 people able to check in "
"changes, a fourfold increase.  This makes possible large-scale changes that "
"wouldn't be attempted if they'd have to be filtered through the small group "
"of core developers.  For example, one day Peter Schneider-Kamp took it into "
"his head to drop K&R C compatibility and convert the C source for Python to "
"ANSI C. After getting approval on the python-dev mailing list, he launched "
"into a flurry of checkins that lasted about a week, other developers joined "
"in to help, and the job was done.  If there were only 5 people with write "
"access, probably that task would have been viewed as \"nice, but not worth "
"the time and effort needed\" and it would never have gotten done."
msgstr ""
"Найважливішою з послуг, які зараз розміщені на SourceForge, є дерево Python "
"CVS, репозиторій з контрольованими версіями, що містить вихідний код для "
"Python. Раніше було приблизно 7 або близько того людей, які мали доступ для "
"запису до дерева CVS, і всі латки повинні були бути перевірені та "
"зареєстровані одним із людей у цьому короткому списку. Очевидно, що це було "
"не дуже масштабовано. Завдяки переміщенню дерева CVS до SourceForge стало "
"можливим надати доступ для запису більшій кількості людей; станом на "
"вересень 2000 року було 27 осіб, які могли перевірити зміни, тобто "
"чотириразове збільшення. Це робить можливими масштабні зміни, які б не були "
"зроблені, якби їх довелося фільтрувати через невелику групу основних "
"розробників. Наприклад, одного разу Пітер Шнайдер-Камп спав на думку "
"відмовитися від сумісності з K&R C і перетворити вихідний код C для Python "
"на ANSI C. Отримавши схвалення в списку розсилки python-dev, він розпочав "
"шквал перевірок, які тривали близько тижня інші розробники приєдналися, щоб "
"допомогти, і роботу було виконано. Якби було лише 5 осіб із доступом для "
"запису, ймовірно, це завдання було б сприйняте як \"гарне, але не варте "
"потрібного часу та зусиль\", і воно ніколи не було б виконане."

#: ../../whatsnew/2.0.rst:83
msgid ""
"The shift to using SourceForge's services has resulted in a remarkable "
"increase in the speed of development.  Patches now get submitted, commented "
"on, revised by people other than the original submitter, and bounced back "
"and forth between people until the patch is deemed worth checking in.  Bugs "
"are tracked in one central location and can be assigned to a specific person"
" for fixing, and we can count the number of open bugs to measure progress.  "
"This didn't come without a cost: developers now have more e-mail to deal "
"with, more mailing lists to follow, and special tools had to be written for "
"the new environment. For example, SourceForge sends default patch and bug "
"notification e-mail messages that are completely unhelpful, so Ka-Ping Yee "
"wrote an HTML screen-scraper that sends more useful messages."
msgstr ""
"Перехід до використання послуг SourceForge призвів до значного збільшення "
"швидкості розробки. Патчі тепер надсилаються, коментуються, переглядаються "
"людьми, які не були початковим відправником, і обмінюються між людьми, доки "
"виправлення не буде визнано вартим перевірки. Помилки відстежуються в одному"
" центральному місці та можуть бути призначені конкретній особі для "
"виправлення , і ми можемо підрахувати кількість відкритих помилок для "
"вимірювання прогресу. Це не обійшлося без витрат: розробники тепер мають "
"більше електронної пошти, щоб мати справу з більшою кількістю списків "
"розсилки, і для нового середовища потрібно було написати спеціальні "
"інструменти. Наприклад, SourceForge надсилає повідомлення електронною поштою"
" про стандартні виправлення та сповіщення про помилки, які абсолютно марні, "
"тому Ka-Ping Yee написав HTML-скрейпер, який надсилає більш корисні "
"повідомлення."

#: ../../whatsnew/2.0.rst:95
msgid ""
"The ease of adding code caused a few initial growing pains, such as code was"
" checked in before it was ready or without getting clear agreement from the "
"developer group.  The approval process that has emerged is somewhat similar "
"to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a"
" patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the "
"developer is mostly indifferent to the change, though with a slight positive"
" or negative slant.  The most significant change from the Apache model is "
"that the voting is essentially advisory, letting Guido van Rossum, who has "
"Benevolent Dictator For Life status, know what the general opinion is. He "
"can still ignore the result of a vote, and approve or reject a change even "
"if the community disagrees with him."
msgstr ""
"Легкість додавання коду спричинила кілька початкових труднощів, наприклад "
"код перевірявся до того, як він був готовий, або без отримання чіткої згоди "
"від групи розробників. Процес затвердження, який з’явився, дещо схожий на "
"той, який використовується групою Apache. Розробники можуть голосувати за "
"патч +1, +0, -0 або -1; +1 і -1 означають прийняття або відхилення, тоді як "
"+0 і -0 означають, що розробник здебільшого байдужий до змін, хоча з "
"невеликим позитивним або негативним ухилом. Найсуттєвішою зміною в "
"порівнянні з моделлю Apache є те, що голосування є, по суті, дорадчим, "
"дозволяючи Гвідо ван Россуму, який має статус доброзичливого довічного "
"диктатора, знати, якою є загальна думка. Він все ще може ігнорувати "
"результати голосування та схвалити або відхилити зміни, навіть якщо "
"спільнота з ним не погоджується."

#: ../../whatsnew/2.0.rst:106
msgid ""
"Producing an actual patch is the last step in adding a new feature, and is "
"usually easy compared to the earlier task of coming up with a good design. "
"Discussions of new features can often explode into lengthy mailing list "
"threads, making the discussion hard to follow, and no one can read every "
"posting to python-dev.  Therefore, a relatively formal process has been set "
"up to write Python Enhancement Proposals (PEPs), modelled on the internet "
"RFC process.  PEPs are draft documents that describe a proposed new feature,"
" and are continually revised until the community reaches a consensus, either"
" accepting or rejecting the proposal.  Quoting from the introduction to "
":pep:`1`, \"PEP Purpose and Guidelines\":"
msgstr ""
"Створення фактичного патча є останнім кроком у додаванні нової функції, і "
"зазвичай це легко порівняно з попереднім завданням створення гарного "
"дизайну. Обговорення нових функцій часто може вибухнути в довгі ланцюжки "
"списків розсилки, що ускладнює стеження за обговоренням, і ніхто не може "
"прочитати кожну публікацію на python-dev. Тому було створено відносно "
"формальний процес для написання пропозицій щодо покращення Python (PEP), "
"змодельований на основі процесу RFC в Інтернеті. PEPs — це проекти "
"документів, які описують запропоновану нову функцію, і постійно "
"переглядаються, доки спільнота не досягне консенсусу, прийняти або відхилити"
" пропозицію. Цитата зі вступу до :pep:`1`, \"Мета PEP і рекомендації\":"

#: ../../whatsnew/2.0.rst:120
msgid ""
"PEP stands for Python Enhancement Proposal.  A PEP is a design document "
"providing information to the Python community, or describing a new feature "
"for Python.  The PEP should provide a concise technical specification of the"
" feature and a rationale for the feature."
msgstr ""
"PEP розшифровується як Python Enhancement Proposal. PEP — це проектний "
"документ, який надає інформацію спільноті Python або описує нову функцію для"
" Python. PEP має надавати стислу технічну специфікацію функції та "
"обґрунтування цієї функції."

#: ../../whatsnew/2.0.rst:125
msgid ""
"We intend PEPs to be the primary mechanisms for proposing new features, for "
"collecting community input on an issue, and for documenting the design "
"decisions that have gone into Python.  The PEP author is responsible for "
"building consensus within the community and documenting dissenting opinions."
msgstr ""
"Ми плануємо, щоб PEP були основними механізмами для пропонування нових "
"функцій, для збору внесків спільноти щодо проблеми та для документування "
"дизайнерських рішень, які увійшли до Python. Автор PEP відповідає за "
"формування консенсусу в спільноті та документування особливих думок."

#: ../../whatsnew/2.0.rst:130
msgid ""
"Read the rest of :pep:`1` for the details of the PEP editorial process, "
"style, and format.  PEPs are kept in the Python CVS tree on SourceForge, "
"though they're not part of the Python 2.0 distribution, and are also "
"available in HTML form from https://peps.python.org/.  As of September 2000,"
" there are 25 PEPs, ranging from :pep:`201`, \"Lockstep Iteration\", to PEP "
"225, \"Elementwise/Objectwise Operators\"."
msgstr ""

#: ../../whatsnew/2.0.rst:141
msgid "Unicode"
msgstr "Unicode"

#: ../../whatsnew/2.0.rst:143
msgid ""
"The largest new feature in Python 2.0 is a new fundamental data type: "
"Unicode strings.  Unicode uses 16-bit numbers to represent characters "
"instead of the 8-bit number used by ASCII, meaning that 65,536 distinct "
"characters can be supported."
msgstr ""
"Найбільшою новою функцією Python 2.0 є новий фундаментальний тип даних: "
"рядки Unicode. Юнікод використовує 16-розрядні числа для представлення "
"символів замість 8-розрядних чисел, які використовуються в ASCII, тобто "
"підтримується 65 536 різних символів."

#: ../../whatsnew/2.0.rst:148
msgid ""
"The final interface for Unicode support was arrived at through countless "
"often-stormy discussions on the python-dev mailing list, and mostly "
"implemented by Marc-André Lemburg, based on a Unicode string type "
"implementation by Fredrik Lundh.  A detailed explanation of the interface "
"was written up as :pep:`100`, \"Python Unicode Integration\". This article "
"will simply cover the most significant points about the Unicode interfaces."
msgstr ""
"Остаточний інтерфейс для підтримки Unicode був досягнутий під час "
"незліченних, часто бурхливих дискусій у списку розсилки python-dev, і "
"здебільшого реалізований Марком-Андре Лембургом на основі реалізації "
"рядкового типу Unicode Фредріком Лундом. Детальне пояснення інтерфейсу було "
"написано як :pep:`100`, \"Інтеграція Python Unicode\". Ця стаття лише "
"охопить найважливіші моменти щодо інтерфейсів Unicode."

#: ../../whatsnew/2.0.rst:155
msgid ""
"In Python source code, Unicode strings are written as ``u\"string\"``.  "
"Arbitrary Unicode characters can be written using a new escape sequence, "
":samp:`\\\\u{HHHH}`, where *HHHH* is a 4-digit hexadecimal number from 0000 "
"to FFFF.  The existing :samp:`\\\\x{HH}` escape sequence can also be used, "
"and octal escapes can be used for characters up to U+01FF, which is "
"represented by ``\\777``."
msgstr ""

#: ../../whatsnew/2.0.rst:161
msgid ""
"Unicode strings, just like regular strings, are an immutable sequence type. "
"They can be indexed and sliced, but not modified in place. Unicode strings "
"have an ``encode( [encoding] )`` method that returns an 8-bit string in the "
"desired encoding.  Encodings are named by strings, such as ``'ascii'``, "
"``'utf-8'``, ``'iso-8859-1'``, or whatever.  A codec API is defined for "
"implementing and registering new encodings that are then available "
"throughout a Python program. If an encoding isn't specified, the default "
"encoding is usually 7-bit ASCII, though it can be changed for your Python "
"installation by calling the ``sys.setdefaultencoding(encoding)`` function in"
" a customized version of :file:`site.py`."
msgstr ""
"Рядки Unicode, як і звичайні рядки, є незмінним типом послідовності. Їх "
"можна індексувати та нарізати, але не змінювати на місці. Рядки Unicode "
"мають метод ``encode( [encoding] )``, який повертає 8-бітовий рядок у "
"потрібному кодуванні. Кодування називаються рядками, наприклад ``'ascii'``, "
"``'utf-8''``, ``'iso-8859-1''`` або будь-яким іншим. Кодек API визначено для"
" реалізації та реєстрації нових кодувань, які потім доступні в усій програмі"
" Python. Якщо кодування не вказано, кодуванням за замовчуванням зазвичай є "
"7-бітний ASCII, хоча його можна змінити для інсталяції Python, викликавши "
"функцію ``sys.setdefaultencoding(encoding)`` у налаштованій версії "
":file:`site.py`."

#: ../../whatsnew/2.0.rst:172
msgid ""
"Combining 8-bit and Unicode strings always coerces to Unicode, using the "
"default ASCII encoding; the result of ``'a' + u'bc'`` is ``u'abc'``."
msgstr ""
"Комбінування 8-бітових рядків і рядків Unicode завжди приводить до Unicode, "
"використовуючи стандартне кодування ASCII; результатом ``'a' + u'bc'`` є "
"``u'abc``."

#: ../../whatsnew/2.0.rst:175
msgid ""
"New built-in functions have been added, and existing built-ins modified to "
"support Unicode:"
msgstr ""
"Додано нові вбудовані функції, а наявні вбудовані модифіковано для підтримки"
" Unicode:"

#: ../../whatsnew/2.0.rst:178
msgid ""
"``unichr(ch)`` returns a Unicode string 1 character long, containing the "
"character *ch*."
msgstr ""
"``unichr(ch)`` повертає рядок Unicode довжиною 1 символ, що містить символ "
"*ch*."

#: ../../whatsnew/2.0.rst:181
msgid ""
"``ord(u)``, where *u* is a 1-character regular or Unicode string, returns "
"the number of the character as an integer."
msgstr ""
"``ord(u)``, де *u* — звичайний рядок із 1 символу або Unicode, повертає "
"номер символу як ціле число."

#: ../../whatsnew/2.0.rst:184
msgid ""
"``unicode(string [, encoding]  [, errors] )`` creates a Unicode string from "
"an 8-bit string.  ``encoding`` is a string naming the encoding to use. The "
"``errors`` parameter specifies the treatment of characters that are invalid "
"for the current encoding; passing ``'strict'`` as the value causes an "
"exception to be raised on any encoding error, while ``'ignore'`` causes "
"errors to be silently ignored and ``'replace'`` uses U+FFFD, the official "
"replacement character, in case of any problems."
msgstr ""
"``unicode(string [, encoding] [, errors] )`` створює рядок Unicode з "
"8-бітного рядка. ``encoding`` - це рядок із назвою кодування для "
"використання. Параметр ``errors`` визначає обробку символів, недійсних для "
"поточного кодування; передача ``'strict'`` як значення спричиняє виникнення "
"винятку при будь-якій помилці кодування, тоді ``'ignore'`` спричиняє "
"мовчазне ігнорування помилок, а ``'replace'`` використовує U+FFFD, офіційний"
" замінний характер, у разі будь-яких проблем."

#: ../../whatsnew/2.0.rst:192
msgid ""
"The ``exec`` statement, and various built-ins such as ``eval()``, "
"``getattr()``, and ``setattr()`` will also accept Unicode strings as well as"
" regular strings.  (It's possible that the process of fixing this missed "
"some built-ins; if you find a built-in function that accepts strings but "
"doesn't accept Unicode strings at all, please report it as a bug.)"
msgstr ""
"Оператор ``exec`` і різні вбудовані функції, такі як ``eval()``, "
"``getattr()`` і ``setattr()`` також прийматимуть рядки Unicode, а також "
"звичайні рядки. (Цілком можливо, що під час виправлення цього не вистачало "
"деяких вбудованих функцій; якщо ви знайдете вбудовану функцію, яка приймає "
"рядки, але взагалі не приймає рядки Unicode, повідомте про це як про "
"помилку.)"

#: ../../whatsnew/2.0.rst:198
msgid ""
"A new module, :mod:`unicodedata`, provides an interface to Unicode character"
" properties.  For example, ``unicodedata.category(u'A')`` returns the "
"2-character string 'Lu', the 'L' denoting it's a letter, and 'u' meaning "
"that it's uppercase. ``unicodedata.bidirectional(u'\\u0660')`` returns 'AN',"
" meaning that U+0660 is an Arabic number."
msgstr ""
"Новий модуль, :mod:`unicodedata`, надає інтерфейс для властивостей символів "
"Unicode. Наприклад, ``unicodedata.category(u'A')`` повертає 2-символьний "
"рядок 'Lu', 'L' означає, що це літера, і 'u' означає, що це великий регістр."
" ``unicodedata.bidirectional(u'\\u0660')`` повертає 'AN', що означає, що "
"U+0660 є арабським числом."

#: ../../whatsnew/2.0.rst:204
msgid ""
"The :mod:`codecs` module contains functions to look up existing encodings "
"and register new ones.  Unless you want to implement a new encoding, you'll "
"most often use the ``codecs.lookup(encoding)`` function, which returns a "
"4-element tuple: ``(encode_func, decode_func, stream_reader, "
"stream_writer)``."
msgstr ""
"Модуль :mod:`codecs` містить функції для пошуку існуючих кодувань і "
"реєстрації нових. Якщо ви не хочете застосувати нове кодування, ви "
"найчастіше використовуватимете функцію ``codecs.lookup(encoding)``, яка "
"повертає 4-елементний кортеж: ``(encode_func, decode_func, stream_reader, "
"stream_writer)``."

#: ../../whatsnew/2.0.rst:209
msgid ""
"*encode_func* is a function that takes a Unicode string, and returns a "
"2-tuple ``(string, length)``.  *string* is an 8-bit string containing a "
"portion (perhaps all) of the Unicode string converted into the given "
"encoding, and *length* tells you how much of the Unicode string was "
"converted."
msgstr ""
"*encode_func* — це функція, яка приймає рядок Unicode і повертає 2-кортеж "
"``(рядок, довжина)``. *рядок* — це 8-бітовий рядок, що містить частину "
"(можливо, весь) рядка Юнікод, перетвореного в дане кодування, а *довжина* "
"вказує вам, яку частину рядка Юнікод було перетворено."

#: ../../whatsnew/2.0.rst:214
msgid ""
"*decode_func* is the opposite of *encode_func*, taking an 8-bit string and "
"returning a 2-tuple ``(ustring, length)``, consisting of the resulting "
"Unicode string *ustring* and the integer *length* telling how much of the "
"8-bit string was consumed."
msgstr ""
"*decode_func* є протилежністю *encode_func*, беручи 8-бітний рядок і "
"повертаючи 2-кортеж ``(ustring, length)``, що складається з результуючого "
"рядка Unicode *ustring* і цілого числа *length*, що повідомляє, як велика "
"частина 8-бітного рядка була спожита."

#: ../../whatsnew/2.0.rst:219
msgid ""
"*stream_reader* is a class that supports decoding input from a stream. "
"*stream_reader(file_obj)* returns an object that supports the :meth:`!read`,"
" :meth:`!readline`, and :meth:`!readlines` methods.  These methods will all "
"translate from the given encoding and return Unicode strings."
msgstr ""

#: ../../whatsnew/2.0.rst:224
msgid ""
"*stream_writer*, similarly, is a class that supports encoding output to a "
"stream.  *stream_writer(file_obj)* returns an object that supports the "
":meth:`!write` and :meth:`!writelines` methods.  These methods expect "
"Unicode strings, translating them to the given encoding on output."
msgstr ""

#: ../../whatsnew/2.0.rst:229
msgid ""
"For example, the following code writes a Unicode string into a file,  "
"encoding it as UTF-8::"
msgstr ""
"Наприклад, наступний код записує рядок Unicode у файл, кодуючи його як "
"UTF-8::"

#: ../../whatsnew/2.0.rst:232
msgid ""
"import codecs\n"
"\n"
"unistr = u'\\u0660\\u2000ab ...'\n"
"\n"
"(UTF8_encode, UTF8_decode,\n"
" UTF8_streamreader, UTF8_streamwriter) = codecs.lookup('UTF-8')\n"
"\n"
"output = UTF8_streamwriter( open( '/tmp/output', 'wb') )\n"
"output.write( unistr )\n"
"output.close()"
msgstr ""

#: ../../whatsnew/2.0.rst:243
msgid "The following code would then read UTF-8 input from the file::"
msgstr "Наступний код буде читати вхідні дані UTF-8 з файлу:"

#: ../../whatsnew/2.0.rst:245
msgid ""
"input = UTF8_streamreader( open( '/tmp/output', 'rb') )\n"
"print repr(input.read())\n"
"input.close()"
msgstr ""

#: ../../whatsnew/2.0.rst:249
msgid ""
"Unicode-aware regular expressions are available through the :mod:`re` "
"module, which has a new underlying implementation called SRE written by "
"Fredrik Lundh of Secret Labs AB."
msgstr ""
"Регулярні вирази з підтримкою Unicode доступні через модуль :mod:`re`, який "
"має нову реалізацію під назвою SRE, написану Фредріком Лундом з Secret Labs "
"AB."

#: ../../whatsnew/2.0.rst:253
msgid ""
"A ``-U`` command line option was added which causes the Python compiler to "
"interpret all string literals as Unicode string literals. This is intended "
"to be used in testing and future-proofing your Python code, since some "
"future version of Python may drop support for 8-bit strings and provide only"
" Unicode strings."
msgstr ""
"Додано параметр командного рядка ``-U``, який змушує компілятор Python "
"інтерпретувати всі рядкові літерали як рядкові літерали Unicode. Це "
"призначено для тестування та перевірки вашого коду Python на майбутнє, "
"оскільки деякі майбутні версії Python можуть відмовитися від підтримки "
"8-бітних рядків і надавати лише рядки Unicode."

#: ../../whatsnew/2.0.rst:262
msgid "List Comprehensions"
msgstr "Розуміння списку"

#: ../../whatsnew/2.0.rst:264
msgid ""
"Lists are a workhorse data type in Python, and many programs manipulate a "
"list at some point.  Two common operations on lists are to loop over them, "
"and either pick out the elements that meet a certain criterion, or apply "
"some function to each element.  For example, given a list of strings, you "
"might want to pull out all the strings containing a given substring, or "
"strip off trailing whitespace from each line."
msgstr ""
"Списки є основним типом даних у Python, і багато програм маніпулюють списком"
" у певний момент. Дві поширені операції зі списками полягають у проходженні "
"по ним і або виборі елементів, які відповідають певному критерію, або "
"застосуванні певної функції до кожного елемента. Наприклад, маючи список "
"рядків, ви можете вилучити всі рядки, що містять даний підрядок, або "
"видалити кінцеві пробіли з кожного рядка."

#: ../../whatsnew/2.0.rst:271
msgid ""
"The existing :func:`map` and :func:`filter` functions can be used for this "
"purpose, but they require a function as one of their arguments.  This is "
"fine if there's an existing built-in function that can be passed directly, "
"but if there isn't, you have to create a little function to do the required "
"work, and Python's scoping rules make the result ugly if the little function"
" needs additional information.  Take the first example in the previous "
"paragraph, finding all the strings in the list containing a given substring."
"  You could write the following to do it::"
msgstr ""
"Існуючі функції :func:`map` і :func:`filter` можна використовувати для цієї "
"мети, але вони потребують функції як один із своїх аргументів. Це добре, "
"якщо існує вбудована функція, яку можна передати напряму, але якщо її немає,"
" вам доведеться створити невелику функцію для виконання необхідної роботи, а"
" правила визначення області Python роблять результат негарним, якщо маленька"
" функція потребує Додаткова інформація. Розглянемо перший приклад із "
"попереднього абзацу, знайшовши всі рядки у списку, що містить заданий "
"підрядок. Щоб це зробити, ви можете написати наступне:"

#: ../../whatsnew/2.0.rst:280
msgid ""
"# Given the list L, make a list of all strings\n"
"# containing the substring S.\n"
"sublist = filter( lambda s, substring=S:\n"
"                     string.find(s, substring) != -1,\n"
"                  L)"
msgstr ""

#: ../../whatsnew/2.0.rst:286
msgid ""
"Because of Python's scoping rules, a default argument is used so that the "
"anonymous function created by the :keyword:`lambda` expression knows what "
"substring is being searched for.  List comprehensions make this cleaner::"
msgstr ""
"Через правила визначення області Python використовується аргумент за "
"замовчуванням, щоб анонімна функція, створена виразом :keyword:`lambda`, "
"знала, який підрядок шукається. Розуміння списків робить це чистішим::"

#: ../../whatsnew/2.0.rst:290
msgid "sublist = [ s for s in L if string.find(s, S) != -1 ]"
msgstr ""

#: ../../whatsnew/2.0.rst:292
msgid "List comprehensions have the form::"
msgstr "Охоплення списків мають вигляд::"

#: ../../whatsnew/2.0.rst:294
msgid ""
"[ expression for expr in sequence1\n"
"             for expr2 in sequence2 ...\n"
"             for exprN in sequenceN\n"
"             if condition ]"
msgstr ""

#: ../../whatsnew/2.0.rst:299
msgid ""
"The :keyword:`!for`...\\ :keyword:`!in` clauses contain the sequences to be "
"iterated over.  The sequences do not have to be the same length, because "
"they are *not* iterated over in parallel, but from left to right; this is "
"explained more clearly in the following paragraphs.  The elements of the "
"generated list will be the successive values of *expression*.  The final "
":keyword:`!if` clause is optional; if present, *expression* is only "
"evaluated and added to the result if *condition* is true."
msgstr ""
"Речення :keyword:`!for`...\\ :keyword:`!in` містять послідовності, які "
"потрібно повторити. Послідовності не обов’язково мають бути однакової "
"довжини, тому що вони *не* повторюються паралельно, а зліва направо; це "
"більш чітко пояснюється в наступних параграфах. Елементи згенерованого "
"списку будуть послідовними значеннями *виразу*. Останній пункт "
":keyword:`!if` необов’язковий; якщо присутнє, *вираз* обчислюється та "
"додається до результату, лише якщо *умова* істинна."

#: ../../whatsnew/2.0.rst:307
msgid ""
"To make the semantics very clear, a list comprehension is equivalent to the "
"following Python code::"
msgstr ""
"Щоб зробити семантику дуже зрозумілою, розуміння списку еквівалентно "
"наступному коду Python:"

#: ../../whatsnew/2.0.rst:310
msgid ""
"for expr1 in sequence1:\n"
"    for expr2 in sequence2:\n"
"    ...\n"
"        for exprN in sequenceN:\n"
"             if (condition):\n"
"                  # Append the value of\n"
"                  # the expression to the\n"
"                  # resulting list."
msgstr ""

#: ../../whatsnew/2.0.rst:319
msgid ""
"This means that when there are multiple :keyword:`!for`...\\ :keyword:`!in` "
"clauses, the resulting list will be equal to the product of the lengths of "
"all the sequences.  If you have two lists of length 3, the output list is 9 "
"elements long::"
msgstr ""
"Це означає, що коли є кілька пропозицій :keyword:`!for`...\\ :keyword:`!in`,"
" результуючий список дорівнюватиме добутку довжин усіх послідовностей. Якщо "
"у вас є два списки довжиною 3, вихідний список складається з 9 елементів:"

#: ../../whatsnew/2.0.rst:324
msgid ""
"seq1 = 'abc'\n"
"seq2 = (1,2,3)\n"
">>> [ (x,y) for x in seq1 for y in seq2]\n"
"[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1),\n"
"('c', 2), ('c', 3)]"
msgstr ""

#: ../../whatsnew/2.0.rst:330
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if *expression* is "
"creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Щоб уникнути неоднозначності в граматиці Python, якщо *вираз* створює "
"кортеж, його потрібно взяти в дужки. Перше розуміння списку нижче є "
"синтаксичною помилкою, тоді як друге є правильним:"

#: ../../whatsnew/2.0.rst:334
msgid ""
"# Syntax error\n"
"[ x,y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[ (x,y) for x in seq1 for y in seq2]"
msgstr ""

#: ../../whatsnew/2.0.rst:339
msgid ""
"The idea of list comprehensions originally comes from the functional "
"programming language Haskell (https://www.haskell.org).  Greg Ewing argued "
"most effectively for adding them to Python and wrote the initial list "
"comprehension patch, which was then discussed for a seemingly endless time "
"on the python-dev mailing list and kept up-to-date by Skip Montanaro."
msgstr ""
"Ідея розуміння списків спочатку походить від функціональної мови "
"програмування Haskell (https://www.haskell.org). Ґреґ Юінг найбільш "
"ефективно доводив доцільність додавання їх до Python і написав початковий "
"патч для розуміння списку, який потім, здавалося, нескінченний час "
"обговорювався в списку розсилки python-dev і постійно оновлювався Скіпом "
"Монтанаро."

#: ../../whatsnew/2.0.rst:349
msgid "Augmented Assignment"
msgstr "Доповнене завдання"

#: ../../whatsnew/2.0.rst:351
msgid ""
"Augmented assignment operators, another long-requested feature, have been "
"added to Python 2.0.  Augmented assignment operators include ``+=``, ``-=``,"
" ``*=``, and so forth.  For example, the statement ``a += 2`` increments the"
" value of the variable  ``a`` by 2, equivalent to the slightly lengthier ``a"
" = a + 2``."
msgstr ""
"До Python 2.0 додано розширені оператори присвоєння, ще одну давно "
"запитувану функцію. Розширені оператори присвоєння включають ``+=``, ``-=``,"
" ``*=`` і так далі. Наприклад, оператор ``a += 2`` збільшує значення змінної"
" ``a`` на 2, еквівалентно трохи довшому ``a = a + 2``."

#: ../../whatsnew/2.0.rst:356
msgid ""
"The full list of supported assignment operators is ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=``, ``&=``, ``|=``, ``^=``, ``>>=``, and ``<<=``.  "
"Python classes can override the augmented assignment operators by defining "
"methods named :meth:`!__iadd__`, :meth:`!__isub__`, etc.  For example, the "
"following :class:`!Number` class stores a number and supports using += to "
"create a new instance with an incremented value."
msgstr ""

#: ../../whatsnew/2.0.rst:367
msgid ""
"class Number:\n"
"    def __init__(self, value):\n"
"        self.value = value\n"
"    def __iadd__(self, increment):\n"
"        return Number( self.value + increment)\n"
"\n"
"n = Number(5)\n"
"n += 3\n"
"print n.value"
msgstr ""

#: ../../whatsnew/2.0.rst:377
msgid ""
"The :meth:`!__iadd__` special method is called with the value of the "
"increment, and should return a new instance with an appropriately modified "
"value; this return value is bound as the new value of the variable on the "
"left-hand side."
msgstr ""

#: ../../whatsnew/2.0.rst:381
msgid ""
"Augmented assignment operators were first introduced in the C programming "
"language, and most C-derived languages, such as :program:`awk`, C++, Java, "
"Perl, and PHP also support them.  The augmented assignment patch was "
"implemented by Thomas Wouters."
msgstr ""
"Розширені оператори присвоєння вперше були представлені в мові програмування"
" C, і більшість похідних від C мов, таких як :program:`awk`, C++, Java, Perl"
" і PHP, також їх підтримують. Патч доповненого призначення реалізував Томас "
"Воутерс."

#: ../../whatsnew/2.0.rst:390
msgid "String Methods"
msgstr "Рядкові методи"

#: ../../whatsnew/2.0.rst:392
msgid ""
"Until now string-manipulation functionality was in the :mod:`string` module,"
" which was usually a front-end for the :mod:`!strop` module written in C.  "
"The addition of Unicode posed a difficulty for the :mod:`!strop` module, "
"because the functions would all need to be rewritten in order to accept "
"either 8-bit or Unicode strings.  For functions such as "
":func:`!string.replace`, which takes 3 string arguments, that means eight "
"possible permutations, and correspondingly complicated code."
msgstr ""

#: ../../whatsnew/2.0.rst:400
msgid ""
"Instead, Python 2.0 pushes the problem onto the string type, making string "
"manipulation functionality available through methods on both 8-bit strings "
"and Unicode strings.   ::"
msgstr ""
"Натомість Python 2.0 переносить проблему на рядковий тип, роблячи "
"функціональні можливості маніпулювання рядками доступними через методи як "
"для 8-бітних рядків, так і для рядків Unicode. ::"

#: ../../whatsnew/2.0.rst:404
msgid ""
">>> 'andrew'.capitalize()\n"
"'Andrew'\n"
">>> 'hostname'.replace('os', 'linux')\n"
"'hlinuxtname'\n"
">>> 'moshe'.find('sh')\n"
"2"
msgstr ""

#: ../../whatsnew/2.0.rst:411
msgid ""
"One thing that hasn't changed, a noteworthy April Fools' joke "
"notwithstanding, is that Python strings are immutable. Thus, the string "
"methods return new strings, and do not modify the string on which they "
"operate."
msgstr ""
"Одне, незважаючи на першоквітневий жарт, не змінилося, це те, що рядки "
"Python є незмінними. Таким чином, рядкові методи повертають нові рядки і не "
"змінюють рядок, з яким вони працюють."

#: ../../whatsnew/2.0.rst:415
msgid ""
"The old :mod:`string` module is still around for backwards compatibility, "
"but it mostly acts as a front-end to the new string methods."
msgstr ""
"Старий модуль :mod:`string` все ще доступний для зворотної сумісності, але "
"він здебільшого діє як інтерфейс для нових методів рядків."

#: ../../whatsnew/2.0.rst:418
msgid ""
"Two methods which have no parallel in pre-2.0 versions, although they did "
"exist in JPython for quite some time, are :meth:`!startswith` and "
":meth:`!endswith`. ``s.startswith(t)`` is equivalent to ``s[:len(t)] == t``,"
" while ``s.endswith(t)`` is equivalent to ``s[-len(t):] == t``."
msgstr ""

#: ../../whatsnew/2.0.rst:423
msgid ""
"One other method which deserves special mention is :meth:`!join`.  The "
":meth:`!join` method of a string receives one parameter, a sequence of "
"strings, and is equivalent to the :func:`!string.join` function from the old"
" :mod:`string` module, with the arguments reversed. In other words, "
"``s.join(seq)`` is equivalent to the old ``string.join(seq, s)``."
msgstr ""

#: ../../whatsnew/2.0.rst:433
msgid "Garbage Collection of Cycles"
msgstr "Збирання сміття циклів"

#: ../../whatsnew/2.0.rst:435
msgid ""
"The C implementation of Python uses reference counting to implement garbage "
"collection.  Every Python object maintains a count of the number of "
"references pointing to itself, and adjusts the count as references are "
"created or destroyed.  Once the reference count reaches zero, the object is "
"no longer accessible, since you need to have a reference to an object to "
"access it, and if the count is zero, no references exist any longer."
msgstr ""
"Реалізація Python на C використовує підрахунок посилань для реалізації "
"збирання сміття. Кожен об’єкт Python підтримує підрахунок кількості "
"посилань, що вказують на нього самого, і коригує кількість у міру створення "
"чи знищення посилань. Коли кількість посилань досягає нуля, об’єкт більше не"
" доступний, оскільки для доступу до нього потрібно мати посилання на об’єкт,"
" і якщо кількість посилань дорівнює нулю, посилань більше не існує."

#: ../../whatsnew/2.0.rst:442
msgid ""
"Reference counting has some pleasant properties: it's easy to understand and"
" implement, and the resulting implementation is portable, fairly fast, and "
"reacts well with other libraries that implement their own memory handling "
"schemes.  The major problem with reference counting is that it sometimes "
"doesn't realise that objects are no longer accessible, resulting in a memory"
" leak.  This happens when there are cycles of references."
msgstr ""
"Підрахунок посилань має деякі приємні властивості: його легко зрозуміти та "
"реалізувати, а результуюча реалізація є портативною, досить швидкою та добре"
" реагує на інші бібліотеки, які реалізують власні схеми обробки пам’яті. "
"Основна проблема з підрахунком посилань полягає в тому, що він іноді не "
"усвідомлює, що об’єкти більше не доступні, що призводить до витоку пам’яті. "
"Це відбувається, коли є цикли посилань."

#: ../../whatsnew/2.0.rst:449
msgid ""
"Consider the simplest possible cycle,  a class instance which has a "
"reference to itself::"
msgstr ""
"Розглянемо найпростіший можливий цикл, екземпляр класу, який має посилання "
"на самого себе::"

#: ../../whatsnew/2.0.rst:452
msgid ""
"instance = SomeClass()\n"
"instance.myself = instance"
msgstr ""

#: ../../whatsnew/2.0.rst:455
msgid ""
"After the above two lines of code have been executed, the reference count of"
" ``instance`` is 2; one reference is from the variable named ``'instance'``,"
" and the other is from the ``myself`` attribute of the instance."
msgstr ""
"Після виконання двох вищезазначених рядків коду кількість посилань "
"``примірника`` дорівнює 2; одне посилання походить від змінної з назвою "
"``'instance'``, а інше — від атрибута ``mysel`` екземпляра."

#: ../../whatsnew/2.0.rst:459
msgid ""
"If the next line of code is ``del instance``, what happens?  The reference "
"count of ``instance`` is decreased by 1, so it has a reference count of 1; "
"the reference in the ``myself`` attribute still exists.  Yet the instance is"
" no longer accessible through Python code, and it could be deleted.  Several"
" objects can participate in a cycle if they have references to each other, "
"causing all of the objects to be leaked."
msgstr ""
"Що станеться, якщо наступним рядком коду є ``del instance``? Кількість "
"посилань ``примірника`` зменшено на 1, тому він має кількість посилань 1; "
"посилання в атрибуті ``mysel`` все ще існує. Проте екземпляр більше не "
"доступний через код Python, і його можна видалити. Кілька об’єктів можуть "
"брати участь у циклі, якщо вони мають посилання один на одного, що спричиняє"
" витік усіх об’єктів."

#: ../../whatsnew/2.0.rst:466
msgid ""
"Python 2.0 fixes this problem by periodically executing a cycle detection "
"algorithm which looks for inaccessible cycles and deletes the objects "
"involved. A new :mod:`gc` module provides functions to perform a garbage "
"collection, obtain debugging statistics, and tuning the collector's "
"parameters."
msgstr ""
"Python 2.0 вирішує цю проблему, періодично виконуючи алгоритм виявлення "
"циклу, який шукає недоступні цикли та видаляє залучені об’єкти. Новий модуль"
" :mod:`gc` надає функції для збирання сміття, отримання статистики "
"налагодження та налаштування параметрів збирача."

#: ../../whatsnew/2.0.rst:471
msgid ""
"Running the cycle detection algorithm takes some time, and therefore will "
"result in some additional overhead.  It is hoped that after we've gotten "
"experience with the cycle collection from using 2.0, Python 2.1 will be able"
" to minimize the overhead with careful tuning.  It's not yet obvious how "
"much performance is lost, because benchmarking this is tricky and depends "
"crucially on how often the program creates and destroys objects.  The "
"detection of cycles can be disabled when Python is compiled, if you can't "
"afford even a tiny speed penalty or suspect that the cycle collection is "
"buggy, by specifying the :option:`!--without-cycle-gc` switch when running "
"the :program:`configure` script."
msgstr ""
"Виконання алгоритму виявлення циклу займає деякий час, а тому призведе до "
"додаткових витрат. Сподіваємося, що після того, як ми отримаємо досвід "
"роботи зі збором циклів від використання 2.0, Python 2.1 зможе мінімізувати "
"накладні витрати завдяки ретельному налаштуванню. Поки що неочевидно, "
"скільки продуктивності втрачається, тому що це порівняльний аналіз є "
"складним і дуже залежить від того, як часто програма створює та знищує "
"об’єкти. Виявлення циклів можна вимкнути під час компіляції Python, якщо ви "
"не можете дозволити собі навіть незначне зниження швидкості або підозрюєте, "
"що збирання циклів є помилковим, вказавши перемикач :option:`!--without-"
"cycle-gc`, коли виконання сценарію :program:`configure`."

#: ../../whatsnew/2.0.rst:482
msgid ""
"Several people tackled this problem and contributed to a solution.  An early"
" implementation of the cycle detection approach was written by Toby Kelsey."
"  The current algorithm was suggested by Eric Tiedemann during a visit to "
"CNRI, and Guido van Rossum and Neil Schemenauer wrote two different "
"implementations, which were later integrated by Neil.  Lots of other people "
"offered suggestions along the way; the March 2000 archives of the python-dev"
" mailing list contain most of the relevant discussion, especially in the "
"threads titled \"Reference cycle collection for Python\" and \"Finalization "
"again\"."
msgstr ""
"Кілька людей взялися за цю проблему та зробили свій внесок у її вирішення. "
"Рання реалізація підходу виявлення циклу була написана Тобі Келсі. Поточний "
"алгоритм був запропонований Еріком Тідеманном під час візиту до CNRI, а "
"Гвідо ван Россум і Ніл Шеменауер написали дві різні реалізації, які пізніше "
"були інтегровані Нілом. Багато інших людей пропонували пропозиції на цьому "
"шляху; архіви списку розсилки python-dev за березень 2000 року містять "
"більшість відповідних обговорень, особливо в темах під назвою \"Колекція "
"довідкового циклу для Python\" і \"Знову завершення\"."

#: ../../whatsnew/2.0.rst:495
msgid "Other Core Changes"
msgstr "Інші основні зміни"

#: ../../whatsnew/2.0.rst:497
msgid ""
"Various minor changes have been made to Python's syntax and built-in "
"functions. None of the changes are very far-reaching, but they're handy "
"conveniences."
msgstr ""
"У синтаксис і вбудовані функції Python внесено різні незначні зміни. Жодна "
"зі змін не є дуже далекосяжною, але це зручні зручності."

#: ../../whatsnew/2.0.rst:502
msgid "Minor Language Changes"
msgstr "Незначні зміни мови"

#: ../../whatsnew/2.0.rst:504
msgid ""
"A new syntax makes it more convenient to call a given function with a tuple "
"of arguments and/or a dictionary of keyword arguments. In Python 1.5 and "
"earlier, you'd use the :func:`!apply` built-in function: ``apply(f, args, "
"kw)`` calls the function :func:`!f` with the argument tuple *args* and the "
"keyword arguments in the dictionary *kw*.  :func:`!apply`  is the same in "
"2.0, but thanks to a patch from Greg Ewing, ``f(*args, **kw)`` is a shorter "
"and clearer way to achieve the same effect.  This syntax is symmetrical with"
" the syntax for defining functions::"
msgstr ""

#: ../../whatsnew/2.0.rst:513
msgid ""
"def f(*args, **kw):\n"
"    # args is a tuple of positional args,\n"
"    # kw is a dictionary of keyword args\n"
"    ..."
msgstr ""

#: ../../whatsnew/2.0.rst:518
msgid ""
"The ``print`` statement can now have its output directed to a file-like "
"object by following the ``print`` with  ``>> file``, similar to the "
"redirection operator in Unix shells. Previously you'd either have to use the"
" :meth:`!write` method of the file-like object, which lacks the convenience "
"and simplicity of ``print``, or you could assign a new value to "
"``sys.stdout`` and then restore the old value.  For sending output to "
"standard error, it's much easier to write this::"
msgstr ""

#: ../../whatsnew/2.0.rst:526
msgid "print >> sys.stderr, \"Warning: action field not supplied\""
msgstr ""

#: ../../whatsnew/2.0.rst:528
msgid ""
"Modules can now be renamed on importing them, using the syntax ``import "
"module as name`` or ``from module import name as othername``.  The patch was"
" submitted by Thomas Wouters."
msgstr ""
"Модулі тепер можна перейменовувати під час їх імпорту, використовуючи "
"синтаксис ``імпортувати модуль як ім’я`` або ``з імені імпорту модуля як "
"інше ім’я``. Патч надіслав Томас Воутерс."

#: ../../whatsnew/2.0.rst:532
msgid ""
"A new format style is available when using the ``%`` operator; '%r' will "
"insert the :func:`repr` of its argument.  This was also added from symmetry "
"considerations, this time for symmetry with the existing '%s' format style, "
"which inserts the :func:`str` of its argument.  For example, ``'%r %s' % "
"('abc', 'abc')`` returns a string containing ``'abc' abc``."
msgstr ""
"Новий стиль формату доступний при використанні оператора ``%``; '%r' "
"вставить :func:`repr` свого аргументу. Це також було додано з міркувань "
"симетрії, цього разу для симетрії з існуючим стилем формату '%s', який "
"вставляє :func:`str` свого аргументу. Наприклад, ``'%r %s' % ('abc', "
"'abc')`` повертає рядок, що містить ``'abc' abc``."

#: ../../whatsnew/2.0.rst:538
msgid ""
"Previously there was no way to implement a class that overrode Python's "
"built-in :keyword:`in` operator and implemented a custom version.  ``obj in "
"seq`` returns true if *obj* is present in the sequence *seq*; Python "
"computes this by simply trying every index of the sequence until either "
"*obj* is found or an :exc:`IndexError` is encountered.  Moshe Zadka "
"contributed a patch which adds a :meth:`!__contains__` magic method for "
"providing a custom implementation for :keyword:`!in`. Additionally, new "
"built-in objects written in C can define what :keyword:`!in` means for them "
"via a new slot in the sequence protocol."
msgstr ""

#: ../../whatsnew/2.0.rst:547
msgid ""
"Earlier versions of Python used a recursive algorithm for deleting objects. "
"Deeply nested data structures could cause the interpreter to fill up the C "
"stack and crash; Christian Tismer rewrote the deletion logic to fix this "
"problem.  On a related note, comparing recursive objects recursed infinitely"
" and crashed; Jeremy Hylton rewrote the code to no longer crash, producing a"
" useful result instead.  For example, after this code::"
msgstr ""
"Попередні версії Python використовували рекурсивний алгоритм для видалення "
"об’єктів. Глибоко вкладені структури даних можуть спричинити заповнення "
"стека C і збій інтерпретатора; Крістіан Тісмер переписав логіку видалення, "
"щоб вирішити цю проблему. У зв’язку з цим, порівняння рекурсивних об’єктів "
"нескінченно рекурсувало і вийшло з ладу; Джеремі Гілтон переписав код, щоб "
"він більше не виходив з ладу, натомість створюючи корисний результат. "
"Наприклад, після цього коду::"

#: ../../whatsnew/2.0.rst:554
msgid ""
"a = []\n"
"b = []\n"
"a.append(a)\n"
"b.append(b)"
msgstr ""

#: ../../whatsnew/2.0.rst:559
msgid ""
"The comparison ``a==b`` returns true, because the two recursive data "
"structures are isomorphic. See the thread \"trashcan and PR#7\" in the April"
" 2000 archives of the python-dev mailing list for the discussion leading up "
"to this implementation, and some useful relevant links.    Note that "
"comparisons can now also raise exceptions. In earlier versions of Python, a "
"comparison operation such as ``cmp(a,b)`` would always produce an answer, "
"even if a user-defined :meth:`!__cmp__` method encountered an error, since "
"the resulting exception would simply be silently swallowed."
msgstr ""

#: ../../whatsnew/2.0.rst:571
msgid ""
"Work has been done on porting Python to 64-bit Windows on the Itanium "
"processor, mostly by Trent Mick of ActiveState.  (Confusingly, "
"``sys.platform`` is still ``'win32'`` on Win64 because it seems that for "
"ease of porting, MS Visual C++ treats code as 32 bit on Itanium.) PythonWin "
"also supports Windows CE; see the Python CE page at "
"https://pythonce.sourceforge.net/ for more information."
msgstr ""

#: ../../whatsnew/2.0.rst:577
msgid ""
"Another new platform is Darwin/MacOS X; initial support for it is in Python "
"2.0. Dynamic loading works, if you specify \"configure --with-dyld --with-"
"suffix=.x\". Consult the README in the Python source distribution for more "
"instructions."
msgstr ""
"Ще одна нова платформа — Darwin/MacOS X; початкова підтримка для нього в "
"Python 2.0. Динамічне завантаження працює, якщо ви вкажете \"configure "
"--with-dyld --with-suffix=.x\". Щоб отримати додаткові вказівки, зверніться "
"до файлу README у вихідному коді Python."

#: ../../whatsnew/2.0.rst:581
msgid ""
"An attempt has been made to alleviate one of Python's warts, the often-"
"confusing :exc:`NameError` exception when code refers to a local variable "
"before the variable has been assigned a value.  For example, the following "
"code raises an exception on the ``print`` statement in both 1.5.2 and 2.0; "
"in 1.5.2 a :exc:`NameError` exception is raised, while 2.0 raises a new "
":exc:`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass "
"of :exc:`NameError`, so any existing code that expects :exc:`NameError` to "
"be raised should still work. ::"
msgstr ""
"Була зроблена спроба пом’якшити одну з недоліків Python, виняток "
":exc:`NameError`, який часто викликає плутанину, коли код посилається на "
"локальну змінну до того, як їй було присвоєно значення. Наприклад, наступний"
" код викликає виняток у операторі ``print`` як у 1.5.2, так і 2.0; у 1.5.2 "
"виникає виняток :exc:`NameError`, тоді як у 2.0 виникає новий виняток "
":exc:`UnboundLocalError`. :exc:`UnboundLocalError` є підкласом "
":exc:`NameError`, тому будь-який існуючий код, який очікує виклику "
":exc:`NameError`, має працювати. ::"

#: ../../whatsnew/2.0.rst:590
msgid ""
"def f():\n"
"    print \"i=\",i\n"
"    i = i + 1\n"
"f()"
msgstr ""

#: ../../whatsnew/2.0.rst:595
msgid ""
"Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been "
"introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised "
"when Python code is found to be improperly indented."
msgstr ""
"Додано два нові винятки, :exc:`TabError` і :exc:`IndentationError`. Обидва "
"вони є підкласами :exc:`SyntaxError` і викликаються, коли виявляється, що "
"код Python має неправильний відступ."

#: ../../whatsnew/2.0.rst:601
msgid "Changes to Built-in Functions"
msgstr "Зміни вбудованих функцій"

#: ../../whatsnew/2.0.rst:603
msgid ""
"A new built-in, ``zip(seq1, seq2, ...)``, has been added.  :func:`zip` "
"returns a list of tuples where each tuple contains the i-th element from "
"each of the argument sequences.  The difference between :func:`zip` and "
"``map(None, seq1, seq2)`` is that :func:`map` pads the sequences with "
"``None`` if the sequences aren't all of the same length, while :func:`zip` "
"truncates the returned list to the length of the shortest argument sequence."
msgstr ""
"Додано нову вбудовану функцію ``zip(seq1, seq2, ...)``. :func:`zip` повертає"
" список кортежів, де кожен кортеж містить i-й елемент із кожної "
"послідовності аргументів. Різниця між :func:`zip` і ``map(None, seq1, "
"seq2)`` полягає в тому, що :func:`map` доповнює послідовності ``None``, якщо"
" послідовності не мають однакову довжину , а :func:`zip` скорочує повернутий"
" список до довжини найкоротшої послідовності аргументів."

#: ../../whatsnew/2.0.rst:610
msgid ""
"The :func:`int` and :func:`!long` functions now accept an optional \"base\" "
"parameter when the first argument is a string. ``int('123', 10)`` returns "
"123, while ``int('123', 16)`` returns 291.  ``int(123, 16)`` raises a "
":exc:`TypeError` exception with the message \"can't convert non-string with "
"explicit base\"."
msgstr ""

#: ../../whatsnew/2.0.rst:616
msgid ""
"A new variable holding more detailed version information has been added to "
"the :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, "
"micro, level, serial)`` For example, in a hypothetical 2.0.1beta1, "
"``sys.version_info`` would be ``(2, 0, 1, 'beta', 1)``. *level* is a string "
"such as ``\"alpha\"``, ``\"beta\"``, or ``\"final\"`` for a final release."
msgstr ""
"До модуля :mod:`sys` додано нову змінну, що містить більш детальну "
"інформацію про версію. ``sys.version_info`` — це кортеж ``(major, minor, "
"micro, level, serial)``. Наприклад, у гіпотетичній версії 2.0.1beta1, "
"``sys.version_info`` буде ``(2, 0 , 1, 'бета', 1)``. *level* — це рядок, "
"наприклад ``\"alpha\"``, ``\"beta\"`` або ``\"final\"`` для остаточного "
"випуску."

#: ../../whatsnew/2.0.rst:622
msgid ""
"Dictionaries have an odd new method, ``setdefault(key, default)``, which "
"behaves similarly to the existing :meth:`!get` method.  However, if the key "
"is missing, :meth:`!setdefault` both returns the value of *default* as "
":meth:`!get` would do, and also inserts it into the dictionary as the value "
"for *key*.  Thus, the following lines of code::"
msgstr ""

#: ../../whatsnew/2.0.rst:628
msgid ""
"if dict.has_key( key ): return dict[key]\n"
"else:\n"
"    dict[key] = []\n"
"    return dict[key]"
msgstr ""

#: ../../whatsnew/2.0.rst:633
msgid ""
"can be reduced to a single ``return dict.setdefault(key, [])`` statement."
msgstr "можна звести до одного оператора ``return dict.setdefault(key, [])``."

#: ../../whatsnew/2.0.rst:635
msgid ""
"The interpreter sets a maximum recursion depth in order to catch runaway "
"recursion before filling the C stack and causing a core dump or GPF.. "
"Previously this limit was fixed when you compiled Python, but in 2.0 the "
"maximum recursion depth can be read and modified using "
":func:`sys.getrecursionlimit` and :func:`sys.setrecursionlimit`. The default"
" value is 1000, and a rough maximum value for a given platform can be found "
"by running a new script, :file:`Misc/find_recursionlimit.py`."
msgstr ""
"Інтерпретатор встановлює максимальну глибину рекурсії, щоб уловити "
"невимушену рекурсію перед заповненням стека C і створенням дампа ядра або "
"GPF. Раніше це обмеження було виправлено під час компіляції Python, але у "
"2.0 максимальну глибину рекурсії можна прочитати та змінити за допомогою "
":func:`sys.getrecursionlimit` і :func:`sys.setrecursionlimit`. Стандартним "
"значенням є 1000, а приблизне максимальне значення для даної платформи можна"
" знайти, запустивши новий сценарій :file:`Misc/find_recursionlimit.py`."

#: ../../whatsnew/2.0.rst:647
msgid "Porting to 2.0"
msgstr "Перенесення на 2.0"

#: ../../whatsnew/2.0.rst:649
msgid ""
"New Python releases try hard to be compatible with previous releases, and "
"the record has been pretty good.  However, some changes are considered "
"useful enough, usually because they fix initial design decisions that turned"
" out to be actively mistaken, that breaking backward compatibility can't "
"always be avoided. This section lists the changes in Python 2.0 that may "
"cause old Python code to break."
msgstr ""
"Нові випуски Python намагаються бути сумісними з попередніми випусками, і "
"результати були досить хорошими. Однак деякі зміни вважаються досить "
"корисними, зазвичай тому, що вони виправляють початкові дизайнерські "
"рішення, які виявилися активно помилковими, тому порушення зворотної "
"сумісності не завжди можна уникнути. У цьому розділі перераховано зміни в "
"Python 2.0, які можуть призвести до поломки старого коду Python."

#: ../../whatsnew/2.0.rst:656
msgid ""
"The change which will probably break the most code is tightening up the "
"arguments accepted by some methods.  Some methods would take multiple "
"arguments and treat them as a tuple, particularly various list methods such "
"as :meth:`!append` and :meth:`!insert`. In earlier versions of Python, if "
"``L`` is a list, ``L.append( 1,2 )`` appends the tuple ``(1,2)`` to the "
"list.  In Python 2.0 this causes a :exc:`TypeError` exception to be raised, "
"with the message: 'append requires exactly 1 argument; 2 given'.  The fix is"
" to simply add an extra set of parentheses to pass both values as a tuple:  "
"``L.append( (1,2) )``."
msgstr ""

#: ../../whatsnew/2.0.rst:665
msgid ""
"The earlier versions of these methods were more forgiving because they used "
"an old function in Python's C interface to parse their arguments; 2.0 "
"modernizes them to use :c:func:`PyArg_ParseTuple`, the current argument "
"parsing function, which provides more helpful error messages and treats "
"multi-argument calls as errors.  If you absolutely must use 2.0 but can't "
"fix your code, you can edit :file:`Objects/listobject.c` and define the "
"preprocessor symbol ``NO_STRICT_LIST_APPEND`` to preserve the old behaviour;"
" this isn't recommended."
msgstr ""

#: ../../whatsnew/2.0.rst:673
msgid ""
"Some of the functions in the :mod:`socket` module are still forgiving in "
"this way.  For example, ``socket.connect( ('hostname', 25) )`` is the "
"correct form, passing a tuple representing an IP address, but "
"``socket.connect('hostname', 25)`` also works. :meth:`socket.connect_ex "
"<socket.socket.connect_ex>` and :meth:`socket.bind <socket.socket.bind>` are"
" similarly easy-going.  2.0alpha1 tightened these functions up, but because "
"the documentation actually used the erroneous multiple argument form, many "
"people wrote code which would break with the stricter checking.  GvR backed "
"out the changes in the face of public reaction, so for the :mod:`socket` "
"module, the documentation was fixed and the multiple argument form is simply"
" marked as deprecated; it *will* be tightened up again in a future Python "
"version."
msgstr ""

#: ../../whatsnew/2.0.rst:684
msgid ""
"The ``\\x`` escape in string literals now takes exactly 2 hex digits.  "
"Previously it would consume all the hex digits following the 'x' and take "
"the lowest 8 bits of the result, so ``\\x123456`` was equivalent to "
"``\\x56``."
msgstr ""
"Екранування ``\\x`` у рядкових літералах тепер займає рівно 2 шістнадцяткові"
" цифри. Раніше він використовував усі шістнадцяткові цифри після 'x' і брав "
"молодші 8 бітів результату, тому ``\\x123456`` був еквівалентним ``\\x56``."

#: ../../whatsnew/2.0.rst:688
msgid ""
"The :exc:`AttributeError` and :exc:`NameError` exceptions have a more "
"friendly error message, whose text will be something like ``'Spam' instance "
"has no attribute 'eggs'`` or ``name 'eggs' is not defined``.  Previously the"
" error message was just the missing attribute name ``eggs``, and code "
"written to take advantage of this fact will break in 2.0."
msgstr ""
"Винятки :exc:`AttributeError` і :exc:`NameError` мають більш зрозуміле "
"повідомлення про помилку, текст якого буде приблизно таким, як \"Екземпляр "
"спаму\" не має атрибута \"яйця\" або \"назва \"яйця\" є не визначено``. "
"Раніше повідомленням про помилку було лише відсутнє ім’я атрибута ``яйця``, "
"і код, написаний для використання цього факту, зламається у 2.0."

#: ../../whatsnew/2.0.rst:694
msgid ""
"Some work has been done to make integers and long integers a bit more "
"interchangeable.  In 1.5.2, large-file support was added for Solaris, to "
"allow reading files larger than 2 GiB; this made the :meth:`!tell` method of"
" file objects return a long integer instead of a regular integer.  Some code"
" would subtract two file offsets and attempt to use the result to multiply a"
" sequence or slice a string, but this raised a :exc:`TypeError`.  In 2.0, "
"long integers can be used to multiply or slice a sequence, and it'll behave "
"as you'd intuitively expect it to; ``3L * 'abc'`` produces 'abcabcabc', and "
"``(0,1,2,3)[2L:4L]`` produces (2,3). Long integers can also be used in "
"various contexts where previously only integers were accepted, such as in "
"the :meth:`!seek` method of file objects, and in the formats supported by "
"the ``%`` operator (``%d``, ``%i``, ``%x``, etc.).  For example, ``\"%d\" % "
"2L**64`` will produce the string ``18446744073709551616``."
msgstr ""

#: ../../whatsnew/2.0.rst:708
msgid ""
"The subtlest long integer change of all is that the :func:`str` of a long "
"integer no longer has a trailing 'L' character, though :func:`repr` still "
"includes it.  The 'L' annoyed many people who wanted to print long integers "
"that looked just like regular integers, since they had to go out of their "
"way to chop off the character.  This is no longer a problem in 2.0, but code"
" which does ``str(longval)[:-1]`` and assumes the 'L' is there, will now "
"lose the final digit."
msgstr ""
"Найтонша зміна довгого цілого числа полягає в тому, що :func:`str` довгого "
"цілого більше не має кінцевого символу 'L', хоча :func:`repr` все ще містить"
" його. \"L\" дратувала багатьох людей, які хотіли надрукувати довгі цілі "
"числа, які виглядали так само, як звичайні цілі числа, оскільки їм "
"доводилося докладати всіх зусиль, щоб відрізати символ. Це більше не є "
"проблемою у 2.0, але код, який виконує ``str(longval)[:-1]`` і припускає, що"
" є 'L', тепер втратить останню цифру."

#: ../../whatsnew/2.0.rst:716
msgid ""
"Taking the :func:`repr` of a float now uses a different formatting precision"
" than :func:`str`.  :func:`repr` uses ``%.17g`` format string for C's "
":func:`!sprintf`, while :func:`str` uses ``%.12g`` as before.  The effect is"
" that :func:`repr` may occasionally show more decimal places than  "
":func:`str`, for certain numbers.  For example, the number 8.1 can't be "
"represented exactly in binary, so ``repr(8.1)`` is ``'8.0999999999999996'``,"
" while str(8.1) is ``'8.1'``."
msgstr ""

#: ../../whatsnew/2.0.rst:724
msgid ""
"The ``-X`` command-line option, which turned all standard exceptions into "
"strings instead of classes, has been removed; the standard exceptions will "
"now always be classes.  The :mod:`!exceptions` module containing the "
"standard exceptions was translated from Python to a built-in C module, "
"written by Barry Warsaw and Fredrik Lundh."
msgstr ""

#: ../../whatsnew/2.0.rst:740
msgid "Extending/Embedding Changes"
msgstr "Розширення/вбудовування змін"

#: ../../whatsnew/2.0.rst:742
msgid ""
"Some of the changes are under the covers, and will only be apparent to "
"people writing C extension modules or embedding a Python interpreter in a "
"larger application.  If you aren't dealing with Python's C API, you can "
"safely skip this section."
msgstr ""
"Деякі зміни знаходяться під обкладинками, і вони будуть очевидні лише для "
"людей, які пишуть модулі розширення C або вбудовують інтерпретатор Python у "
"більшу програму. Якщо ви не маєте справу з API C Python, можете сміливо "
"пропустити цей розділ."

#: ../../whatsnew/2.0.rst:747
msgid ""
"The version number of the Python C API was incremented, so C extensions "
"compiled for 1.5.2 must be recompiled in order to work with 2.0.  On "
"Windows, it's not possible for Python 2.0 to import a third party extension "
"built for Python 1.5.x due to how Windows DLLs work, so Python will raise an"
" exception and the import will fail."
msgstr ""
"Номер версії Python C API було збільшено, тому розширення C, скомпільовані "
"для 1.5.2, потрібно перекомпілювати, щоб працювати з 2.0. У Windows Python "
"2.0 не може імпортувати стороннє розширення, створене для Python 1.5.x, "
"через те, як працюють бібліотеки DLL Windows, тому Python викличе виняток, і"
" імпорт не вдасться."

#: ../../whatsnew/2.0.rst:753
msgid ""
"Users of Jim Fulton's ExtensionClass module will be pleased to find out that"
" hooks have been added so that ExtensionClasses are now supported by "
":func:`isinstance` and :func:`issubclass`. This means you no longer have to "
"remember to write code such as ``if type(obj) == myExtensionClass``, but can"
" use the more natural ``if isinstance(obj, myExtensionClass)``."
msgstr ""
"Користувачі модуля ExtensionClass Джима Фултона будуть раді дізнатися, що "
"були додані хуки, завдяки чому ExtensionClasses тепер підтримуються "
":func:`isinstance` і :func:`issubclass`. Це означає, що вам більше не "
"потрібно пам’ятати про написання такого коду, як ``if type(obj) == "
"myExtensionClass``, а можна використовувати більш природний ``if "
"isinstance(obj, myExtensionClass)``."

#: ../../whatsnew/2.0.rst:759
msgid ""
"The :file:`Python/importdl.c` file, which was a mass of #ifdefs to support "
"dynamic loading on many different platforms, was cleaned up and reorganised "
"by Greg Stein.  :file:`importdl.c` is now quite small, and platform-specific"
" code has been moved into a bunch of :file:`Python/dynload_\\*.c` files.  "
"Another cleanup: there were also a number of :file:`my\\*.h` files in the "
"Include/ directory that held various portability hacks; they've been merged "
"into a single file, :file:`Include/pyport.h`."
msgstr ""
"Файл :file:`Python/importdl.c`, який являв собою масу #ifdefs для підтримки "
"динамічного завантаження на багатьох різних платформах, був очищений і "
"реорганізований Грегом Стайном. :file:`importdl.c` тепер досить малий, і "
"специфічний для платформи код було переміщено до групи файлів "
":file:`Python/dynload_\\*.c`. Ще одне очищення: у каталозі Include/ також "
"було кілька файлів :file:`my\\*.h`, які містили різноманітні хаки для "
"перенесення; їх об’єднано в один файл :file:`Include/pyport.h`."

#: ../../whatsnew/2.0.rst:767
msgid ""
"Vladimir Marangozov's long-awaited malloc restructuring was completed, to "
"make it easy to have the Python interpreter use a custom allocator instead "
"of C's standard :c:func:`malloc`.  For documentation, read the comments in "
":file:`Include/pymem.h` and :file:`Include/objimpl.h`.  For the lengthy "
"discussions during which the interface was hammered out, see the web "
"archives of the 'patches' and 'python-dev' lists at python.org."
msgstr ""

#: ../../whatsnew/2.0.rst:774
msgid ""
"Recent versions of the GUSI development environment for MacOS support POSIX "
"threads.  Therefore, Python's POSIX threading support now works on the "
"Macintosh.  Threading support using the user-space GNU ``pth`` library was "
"also contributed."
msgstr ""
"Останні версії середовища розробки GUSI для MacOS підтримують потоки POSIX. "
"Таким чином, підтримка потоків Python POSIX тепер працює на Macintosh. Також"
" була надана підтримка потоків за допомогою бібліотеки GNU ``pth`` у "
"просторі користувача."

#: ../../whatsnew/2.0.rst:779
msgid ""
"Threading support on Windows was enhanced, too.  Windows supports thread "
"locks that use kernel objects only in case of contention; in the common case"
" when there's no contention, they use simpler functions which are an order "
"of magnitude faster.  A threaded version of Python 1.5.2 on NT is twice as "
"slow as an unthreaded version; with the 2.0 changes, the difference is only "
"10%.  These improvements were contributed by Yakov Markovitch."
msgstr ""
"Також покращено підтримку потоків у Windows. Windows підтримує блокування "
"потоків, які використовують об’єкти ядра лише у випадку конфлікту; у "
"звичайному випадку, коли немає суперечок, вони використовують простіші "
"функції, які на порядок швидші. Потокова версія Python 1.5.2 на NT вдвічі "
"повільніша за безпотокову версію; зі змінами 2.0 різниця становить лише 10%."
" Ці вдосконалення вніс Яків Маркович."

#: ../../whatsnew/2.0.rst:786
msgid ""
"Python 2.0's source now uses only ANSI C prototypes, so compiling Python now"
" requires an ANSI C compiler, and can no longer be done using a compiler "
"that only supports K&R C."
msgstr ""
"Вихідні коди Python 2.0 тепер використовують лише прототипи ANSI C, тому для"
" компіляції Python тепер потрібен компілятор ANSI C, і його більше неможливо"
" виконати за допомогою компілятора, який підтримує лише K&R C."

#: ../../whatsnew/2.0.rst:790
msgid ""
"Previously the Python virtual machine used 16-bit numbers in its bytecode, "
"limiting the size of source files.  In particular, this affected the maximum"
" size of literal lists and dictionaries in Python source; occasionally "
"people who are generating Python code would run into this limit.  A patch by"
" Charles G. Waldman raises the limit from ``2**16`` to ``2**32``."
msgstr ""
"Раніше віртуальна машина Python використовувала 16-бітні числа у своєму "
"байт-коді, обмежуючи розмір вихідних файлів. Зокрема, це вплинуло на "
"максимальний розмір списків літералів і словників у вихідних кодах Python; "
"час від часу люди, які генерують код Python, стикаються з цим обмеженням. "
"Патч від Charles G. Waldman підвищує ліміт з ``2**16`` до ``2**32``."

#: ../../whatsnew/2.0.rst:796
msgid ""
"Three new convenience functions intended for adding constants to a module's "
"dictionary at module initialization time were added: "
":c:func:`PyModule_AddObject`, :c:func:`PyModule_AddIntConstant`, and "
":c:func:`PyModule_AddStringConstant`.  Each of these functions takes a "
"module object, a null-terminated C string containing the name to be added, "
"and a third argument for the value to be assigned to the name.  This third "
"argument is, respectively, a Python object, a C long, or a C string."
msgstr ""

#: ../../whatsnew/2.0.rst:804
msgid ""
"A wrapper API was added for Unix-style signal handlers. "
":c:func:`PyOS_getsig` gets a signal handler and :c:func:`PyOS_setsig` will "
"set a new handler."
msgstr ""

#: ../../whatsnew/2.0.rst:811
msgid "Distutils: Making Modules Easy to Install"
msgstr "Distutils: полегшення встановлення модулів"

#: ../../whatsnew/2.0.rst:813
msgid ""
"Before Python 2.0, installing modules was a tedious affair -- there was no "
"way to figure out automatically where Python is installed, or what compiler "
"options to use for extension modules.  Software authors had to go through an"
" arduous ritual of editing Makefiles and configuration files, which only "
"really work on Unix and leave Windows and MacOS unsupported.  Python users "
"faced wildly differing installation instructions which varied between "
"different extension packages, which made administering a Python installation"
" something of  a chore."
msgstr ""
"До Python 2.0 встановлення модулів було нудною справою — не було можливості "
"автоматично визначити, де встановлено Python, або які параметри компілятора "
"використовувати для модулів розширення. Авторам програмного забезпечення "
"довелося пройти через важкий ритуал редагування файлів Makefile та "
"конфігураційних файлів, які справді працюють лише в Unix, а Windows і MacOS "
"не підтримуються. Користувачі Python зіткнулися з надзвичайно різними "
"інструкціями встановлення, які відрізнялися між різними пакетами розширень, "
"що робило адміністрування встановлення Python чимось на зразок клопітку."

#: ../../whatsnew/2.0.rst:821
msgid ""
"The SIG for distribution utilities, shepherded by Greg Ward, has created the"
" Distutils, a system to make package installation much easier.  They form "
"the ``distutils`` package, a new part of Python's standard library. In the "
"best case, installing a Python module from source will require the same "
"steps: first you simply mean unpack the tarball or zip archive, and the run "
"\"``python setup.py install``\".  The platform will be automatically "
"detected, the compiler will be recognized, C extension modules will be "
"compiled, and the distribution installed into the proper directory.  "
"Optional command-line arguments provide more control over the installation "
"process, the distutils package offers many places to override defaults -- "
"separating the build from the install, building or installing in non-default"
" directories, and more."
msgstr ""

#: ../../whatsnew/2.0.rst:833
msgid ""
"In order to use the Distutils, you need to write a :file:`setup.py` script."
"  For the simple case, when the software contains only .py files, a minimal "
":file:`setup.py` can be just a few lines long::"
msgstr ""
"Щоб використовувати Distutils, вам потрібно написати сценарій "
":file:`setup.py`. У простому випадку, коли програмне забезпечення містить "
"лише файли .py, мінімальний файл :file:`setup.py` може складатися лише з "
"кількох рядків::"

#: ../../whatsnew/2.0.rst:837
msgid ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       py_modules = [\"module1\", \"module2\"])"
msgstr ""

#: ../../whatsnew/2.0.rst:841
msgid ""
"The :file:`setup.py` file isn't much more complicated if the software "
"consists of a few packages::"
msgstr ""
"Файл :file:`setup.py` не є набагато складнішим, якщо програмне забезпечення "
"складається з кількох пакетів::"

#: ../../whatsnew/2.0.rst:844
msgid ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       packages = [\"package\", \"package.subpackage\"])"
msgstr ""

#: ../../whatsnew/2.0.rst:848
msgid ""
"A C extension can be the most complicated case; here's an example taken from"
" the PyXML package::"
msgstr ""
"Розширення C може бути найскладнішим випадком; ось приклад, взятий з пакета "
"PyXML::"

#: ../../whatsnew/2.0.rst:851
msgid ""
"from distutils.core import setup, Extension\n"
"\n"
"expat_extension = Extension('xml.parsers.pyexpat',\n"
"     define_macros = [('XML_NS', None)],\n"
"     include_dirs = [ 'extensions/expat/xmltok',\n"
"                      'extensions/expat/xmlparse' ],\n"
"     sources = [ 'extensions/pyexpat.c',\n"
"                 'extensions/expat/xmltok/xmltok.c',\n"
"                 'extensions/expat/xmltok/xmlrole.c', ]\n"
"       )\n"
"setup (name = \"PyXML\", version = \"0.5.4\",\n"
"       ext_modules =[ expat_extension ] )"
msgstr ""

#: ../../whatsnew/2.0.rst:864
msgid ""
"The Distutils can also take care of creating source and binary "
"distributions. The \"sdist\" command, run by \"``python setup.py sdist``', "
"builds a source distribution such as :file:`foo-1.0.tar.gz`. Adding new "
"commands isn't difficult, \"bdist_rpm\" and \"bdist_wininst\" commands have "
"already been contributed to create an RPM distribution and a Windows "
"installer for the software, respectively.  Commands to create other "
"distribution formats such as Debian packages and Solaris :file:`.pkg` files "
"are in various stages of development."
msgstr ""
"Distutils також може подбати про створення вихідних і двійкових "
"дистрибутивів. Команда \"sdist\", яку запускає \"`` python setup.py "
"sdist``\", створює вихідний дистрибутив, такий як :file:`foo-1.0.tar.gz`. "
"Додавати нові команди не складно, \"bdist_rpm\" Команди \"bdist_wininst\" і "
"\"bdist_wininst\" вже були використані для створення дистрибутива RPM і "
"інсталятора Windows для програмного забезпечення відповідно. ."

#: ../../whatsnew/2.0.rst:873
msgid ""
"All this is documented in a new manual, *Distributing Python Modules*, that "
"joins the basic set of Python documentation."
msgstr ""
"Усе це задокументовано в новому посібнику *Розповсюдження модулів Python*, "
"який доповнює базовий набір документації Python."

#: ../../whatsnew/2.0.rst:880
msgid "XML Modules"
msgstr "Модулі XML"

#: ../../whatsnew/2.0.rst:882
msgid ""
"Python 1.5.2 included a simple XML parser in the form of the :mod:`!xmllib` "
"module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two "
"different interfaces for processing XML have become common: SAX2 (version 2 "
"of the Simple API for XML) provides an event-driven interface with some "
"similarities to :mod:`!xmllib`, and the DOM (Document Object Model) provides"
" a tree-based interface, transforming an XML document into a tree of nodes "
"that can be traversed and modified.  Python 2.0 includes a SAX2 interface "
"and a stripped-down DOM interface as part of the :mod:`xml` package. Here we"
" will give a brief overview of these new interfaces; consult the Python "
"documentation or the source code for complete details. The Python XML SIG is"
" also working on improved documentation."
msgstr ""

#: ../../whatsnew/2.0.rst:896
msgid "SAX2 Support"
msgstr "Підтримка SAX2"

#: ../../whatsnew/2.0.rst:898
msgid ""
"SAX defines an event-driven interface for parsing XML.  To use SAX, you must"
" write a SAX handler class.  Handler classes inherit from various classes "
"provided by SAX, and override various methods that will then be called by "
"the XML parser.  For example, the "
":meth:`~xml.sax.handler.ContentHandler.startElement` and "
":meth:`~xml.sax.handler.ContentHandler.endElement` methods are called for "
"every starting and end tag encountered by the parser, the "
":meth:`~xml.sax.handler.ContentHandler.characters` method is called for "
"every chunk of character data, and so forth."
msgstr ""

#: ../../whatsnew/2.0.rst:906
msgid ""
"The advantage of the event-driven approach is that the whole document "
"doesn't have to be resident in memory at any one time, which matters if you "
"are processing really huge documents.  However, writing the SAX handler "
"class can get very complicated if you're trying to modify the document "
"structure in some elaborate way."
msgstr ""
"Перевага керованого подіями підходу полягає в тому, що весь документ не "
"повинен постійно зберігатися в пам’яті в будь-який момент часу, що має "
"значення, якщо ви обробляєте дійсно великі документи. Однак написання класу "
"обробника SAX може стати дуже складним, якщо ви намагаєтесь модифікувати "
"структуру документа якимось складним чином."

#: ../../whatsnew/2.0.rst:912
msgid ""
"For example, this little example program defines a handler that prints a "
"message for every starting and ending tag, and then parses the file "
":file:`hamlet.xml` using it::"
msgstr ""
"Наприклад, цей маленький приклад програми визначає обробник, який друкує "
"повідомлення для кожного початкового та кінцевого тегу, а потім аналізує "
"файл :file:`hamlet.xml`, використовуючи його:"

#: ../../whatsnew/2.0.rst:916
msgid ""
"from xml import sax\n"
"\n"
"class SimpleHandler(sax.ContentHandler):\n"
"    def startElement(self, name, attrs):\n"
"        print 'Start of element:', name, attrs.keys()\n"
"\n"
"    def endElement(self, name):\n"
"        print 'End of element:', name\n"
"\n"
"# Create a parser object\n"
"parser = sax.make_parser()\n"
"\n"
"# Tell it what handler to use\n"
"handler = SimpleHandler()\n"
"parser.setContentHandler( handler )\n"
"\n"
"# Parse a file!\n"
"parser.parse( 'hamlet.xml' )"
msgstr ""

#: ../../whatsnew/2.0.rst:935
msgid ""
"For more information, consult the Python documentation, or the XML HOWTO at "
"https://pyxml.sourceforge.net/topics/howto/xml-howto.html."
msgstr ""

#: ../../whatsnew/2.0.rst:940
msgid "DOM Support"
msgstr "Підтримка DOM"

#: ../../whatsnew/2.0.rst:942
msgid ""
"The Document Object Model is a tree-based representation for an XML "
"document.  A top-level :class:`!Document` instance is the root of the tree, "
"and has a single child which is the top-level :class:`!Element` instance. "
"This :class:`!Element` has children nodes representing character data and "
"any sub-elements, which may have further children of their own, and so "
"forth.  Using the DOM you can traverse the resulting tree any way you like, "
"access element and attribute values, insert and delete nodes, and convert "
"the tree back into XML."
msgstr ""

#: ../../whatsnew/2.0.rst:950
msgid ""
"The DOM is useful for modifying XML documents, because you can create a DOM "
"tree, modify it by adding new nodes or rearranging subtrees, and then "
"produce a new XML document as output.  You can also construct a DOM tree "
"manually and convert it to XML, which can be a more flexible way of "
"producing XML output than simply writing ``<tag1>``...\\ ``</tag1>`` to a "
"file."
msgstr ""
"DOM корисний для модифікації XML-документів, оскільки ви можете створити "
"дерево DOM, змінити його, додавши нові вузли або перевпорядкувавши "
"піддерева, а потім створити новий XML-документ як результат. Ви також можете"
" побудувати дерево DOM вручну та перетворити його на XML, що може бути більш"
" гнучким способом створення виводу XML, ніж просто запис ``<tag1>``...\\ "
"``</tag1>`` у файл."

#: ../../whatsnew/2.0.rst:956
msgid ""
"The DOM implementation included with Python lives in the "
":mod:`xml.dom.minidom` module.  It's a lightweight implementation of the "
"Level 1 DOM with support for XML namespaces.  The  :func:`!parse` and "
":func:`!parseString` convenience functions are provided for generating a DOM"
" tree::"
msgstr ""

#: ../../whatsnew/2.0.rst:961
msgid ""
"from xml.dom import minidom\n"
"doc = minidom.parse('hamlet.xml')"
msgstr ""

#: ../../whatsnew/2.0.rst:964
msgid ""
"``doc`` is a :class:`!Document` instance.  :class:`!Document`, like all the "
"other DOM classes such as :class:`!Element` and :class:`Text`, is a subclass"
" of the :class:`!Node` base class.  All the nodes in a DOM tree therefore "
"support certain common methods, such as :meth:`!toxml` which returns a "
"string containing the XML representation of the node and its children.  Each"
" class also has special methods of its own; for example, :class:`!Element` "
"and :class:`!Document` instances have a method to find all child elements "
"with a given tag name. Continuing from the previous 2-line example::"
msgstr ""

#: ../../whatsnew/2.0.rst:973
msgid ""
"perslist = doc.getElementsByTagName( 'PERSONA' )\n"
"print perslist[0].toxml()\n"
"print perslist[1].toxml()"
msgstr ""

#: ../../whatsnew/2.0.rst:977
msgid "For the *Hamlet* XML file, the above few lines output::"
msgstr "Для XML-файлу *Hamlet* наведені вище кілька рядків виводять::"

#: ../../whatsnew/2.0.rst:979
msgid ""
"<PERSONA>CLAUDIUS, king of Denmark. </PERSONA>\n"
"<PERSONA>HAMLET, son to the late, and nephew to the present king.</PERSONA>"
msgstr ""

#: ../../whatsnew/2.0.rst:982
msgid ""
"The root element of the document is available as ``doc.documentElement``, "
"and its children can be easily modified by deleting, adding, or removing "
"nodes::"
msgstr ""
"Кореневий елемент документа доступний як ``doc.documentElement``, і його "
"дочірні елементи можна легко змінити шляхом видалення, додавання або "
"вилучення вузлів:"

#: ../../whatsnew/2.0.rst:985
msgid ""
"root = doc.documentElement\n"
"\n"
"# Remove the first child\n"
"root.removeChild( root.childNodes[0] )\n"
"\n"
"# Move the new first child to the end\n"
"root.appendChild( root.childNodes[0] )\n"
"\n"
"# Insert the new first child (originally,\n"
"# the third child) before the 20th child.\n"
"root.insertBefore( root.childNodes[0], root.childNodes[20] )"
msgstr ""

#: ../../whatsnew/2.0.rst:997
msgid ""
"Again, I will refer you to the Python documentation for a complete listing "
"of the different :class:`!Node` classes and their various methods."
msgstr ""

#: ../../whatsnew/2.0.rst:1002
msgid "Relationship to PyXML"
msgstr "Відношення до PyXML"

#: ../../whatsnew/2.0.rst:1004
msgid ""
"The XML Special Interest Group has been working on XML-related Python code "
"for a while.  Its code distribution, called PyXML, is available from the "
"SIG's web pages at https://www.python.org/community/sigs/current/xml-sig. "
"The PyXML distribution also used the package name ``xml``.  If you've "
"written programs that used PyXML, you're probably wondering about its "
"compatibility with the 2.0 :mod:`xml` package."
msgstr ""
"Група спеціальних інтересів XML деякий час працювала над кодом Python, "
"пов’язаним із XML. Його розповсюдження коду під назвою PyXML доступне на "
"веб-сторінках SIG за адресою "
"https://www.python.org/community/sigs/current/xml-sig. Дистрибутив PyXML "
"також використовував назву пакета ``xml``. Якщо ви писали програми, які "
"використовували PyXML, ви, ймовірно, цікавитеся його сумісністю з пакетом "
"2.0 :mod:`xml`."

#: ../../whatsnew/2.0.rst:1010
msgid ""
"The answer is that Python 2.0's :mod:`xml` package isn't compatible with "
"PyXML, but can be made compatible by installing a recent version PyXML.  "
"Many applications can get by with the XML support that is included with "
"Python 2.0, but more complicated applications will require that the full "
"PyXML package will be installed.  When installed, PyXML versions 0.6.0 or "
"greater will replace the :mod:`xml` package shipped with Python, and will be"
" a strict superset of the standard package, adding a bunch of additional "
"features.  Some of the additional features in PyXML include:"
msgstr ""
"Відповідь полягає в тому, що пакет :mod:`xml` Python 2.0 несумісний з PyXML,"
" але його можна зробити сумісним, встановивши останню версію PyXML. Багато "
"програм можуть обійтися підтримкою XML, яка включена в Python 2.0, але "
"складніші програми вимагають інсталяції повного пакета PyXML. Після "
"встановлення PyXML версії 0.6.0 або новішої замінить пакет :mod:`xml`, який "
"постачається разом із Python, і стане строгим доповненням до стандартного "
"пакета, додаючи купу додаткових функцій. Деякі з додаткових функцій у PyXML "
"включають:"

#: ../../whatsnew/2.0.rst:1019
msgid "4DOM, a full DOM implementation from FourThought, Inc."
msgstr "4DOM, повна реалізація DOM від FourThought, Inc."

#: ../../whatsnew/2.0.rst:1021
msgid "The xmlproc validating parser, written by Lars Marius Garshol."
msgstr "Парсер перевірки xmlproc, написаний Ларсом Маріусом Гаршолом."

#: ../../whatsnew/2.0.rst:1023
msgid ""
"The :mod:`!sgmlop` parser accelerator module, written by Fredrik Lundh."
msgstr ""

#: ../../whatsnew/2.0.rst:1029
msgid "Module changes"
msgstr "Зміни модуля"

#: ../../whatsnew/2.0.rst:1031
msgid ""
"Lots of improvements and bugfixes were made to Python's extensive standard "
"library; some of the affected modules include :mod:`readline`, "
":mod:`ConfigParser <configparser>`, :mod:`!cgi`, :mod:`calendar`, "
":mod:`posix`, :mod:`readline`, :mod:`!xmllib`, :mod:`!aifc`, :mod:`!chunk`, "
":mod:`wave`, :mod:`random`, :mod:`shelve`, and :mod:`!nntplib`.  Consult the"
" CVS logs for the exact patch-by-patch details."
msgstr ""

#: ../../whatsnew/2.0.rst:1037
msgid ""
"Brian Gallew contributed OpenSSL support for the :mod:`socket` module.  "
"OpenSSL is an implementation of the Secure Socket Layer, which encrypts the "
"data being sent over a socket.  When compiling Python, you can edit "
":file:`Modules/Setup` to include SSL support, which adds an additional "
"function to the :mod:`socket` module: ``socket.ssl(socket, keyfile, "
"certfile)``, which takes a socket object and returns an SSL socket.  The "
":mod:`httplib <http>` and :mod:`urllib` modules were also changed to support"
" ``https://`` URLs, though no one has implemented FTP or SMTP over SSL."
msgstr ""

#: ../../whatsnew/2.0.rst:1046
msgid ""
"The :mod:`httplib <http>` module has been rewritten by Greg Stein to support"
" HTTP/1.1."
msgstr ""

#: ../../whatsnew/2.0.rst:1048
msgid ""
"Backward compatibility with the 1.5 version of :mod:`!httplib` is provided, "
"though using HTTP/1.1 features such as pipelining will require rewriting "
"code to use a different set of interfaces."
msgstr ""

#: ../../whatsnew/2.0.rst:1052
msgid ""
"The :mod:`!Tkinter` module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and"
" support for the older 7.x versions has been dropped.  The Tkinter module "
"now supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh "
"contributed an optimization which makes operations like ``create_line`` and "
"``create_polygon`` much faster, especially when using lots of coordinates."
msgstr ""

#: ../../whatsnew/2.0.rst:1058
msgid ""
"The :mod:`curses` module has been greatly extended, starting from Oliver "
"Andrich's enhanced version, to provide many additional functions from "
"ncurses and SYSV curses, such as colour, alternative character set support, "
"pads, and mouse support.  This means the module is no longer compatible with"
" operating systems that only have BSD curses, but there don't seem to be any"
" currently maintained OSes that fall into this category."
msgstr ""
"Модуль :mod:`curses` було значно розширено, починаючи з розширеної версії "
"Олівера Андріча, щоб забезпечити багато додаткових функцій від ncurses і "
"проклять SYSV, таких як колір, підтримка альтернативного набору символів, "
"підтримка панелей і миші. Це означає, що модуль більше не сумісний з "
"операційними системами, які мають лише прокляття BSD, але, здається, на "
"даний момент немає жодної ОС, яка підпадає під цю категорію."

#: ../../whatsnew/2.0.rst:1065
msgid ""
"As mentioned in the earlier discussion of 2.0's Unicode support, the "
"underlying implementation of the regular expressions provided by the "
":mod:`re` module has been changed.  SRE, a new regular expression engine "
"written by Fredrik Lundh and partially funded by Hewlett Packard, supports "
"matching against both 8-bit strings and Unicode strings."
msgstr ""
"Як згадувалося в попередньому обговоренні підтримки Unicode 2.0, базову "
"реалізацію регулярних виразів, які надає модуль :mod:`re`, було змінено. "
"SRE, нова система регулярних виразів, написана Фредріком Лундом і частково "
"фінансована Hewlett Packard, підтримує зіставлення як з 8-бітними рядками, "
"так і з рядками Unicode."

#: ../../whatsnew/2.0.rst:1075
msgid "New modules"
msgstr "Нові модулі"

#: ../../whatsnew/2.0.rst:1077
msgid ""
"A number of new modules were added.  We'll simply list them with brief "
"descriptions; consult the 2.0 documentation for the details of a particular "
"module."
msgstr ""
"Додано ряд нових модулів. Ми просто перерахуємо їх із короткими описами; "
"зверніться до документації 2.0, щоб дізнатися більше про конкретний модуль."

#: ../../whatsnew/2.0.rst:1081
msgid ""
":mod:`atexit`:  For registering functions to be called before the Python "
"interpreter exits. Code that currently sets ``sys.exitfunc`` directly should"
" be changed to  use the :mod:`atexit` module instead, importing "
":mod:`atexit` and calling :func:`atexit.register` with  the function to be "
"called on exit. (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`atexit`: для реєстрації функцій, які будуть викликані до завершення "
"роботи інтерпретатора Python. Код, який наразі безпосередньо встановлює "
"``sys.exitfunc``, слід змінити, щоб замість нього використовувати модуль "
":mod:`atexit`, імпортуючи :mod:`atexit` і викликаючи :func:`atexit.register`"
" із функцією, яку потрібно викликати на виході. (Надав Скіп Монтанаро.)"

#: ../../whatsnew/2.0.rst:1087
msgid ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`:  Added as part of the "
"new Unicode support."
msgstr ""

#: ../../whatsnew/2.0.rst:1090
msgid ""
":mod:`filecmp`: Supersedes the old :mod:`!cmp`, :mod:`!cmpcache` and "
":mod:`!dircmp` modules, which have now become deprecated. (Contributed by "
"Gordon MacMillan and Moshe Zadka.)"
msgstr ""

#: ../../whatsnew/2.0.rst:1094
msgid ""
":mod:`gettext`: This module provides internationalization (I18N) and "
"localization (L10N) support for Python programs by providing an interface to"
" the GNU gettext message catalog library. (Integrated by Barry Warsaw, from "
"separate contributions by Martin  von Löwis, Peter Funk, and James "
"Henstridge.)"
msgstr ""
":mod:`gettext`: Цей модуль забезпечує підтримку інтернаціоналізації (I18N) і"
" локалізації (L10N) для програм Python, надаючи інтерфейс до бібліотеки "
"каталогу повідомлень GNU gettext. (Інтегровано Баррі Варшау, з окремих "
"внесків Мартіна фон Льовіса, Пітера Функа та Джеймса Генстріджа.)"

#: ../../whatsnew/2.0.rst:1099
msgid ""
":mod:`!linuxaudiodev`: Support for the :file:`/dev/audio` device on Linux, a"
" twin to the existing :mod:`!sunaudiodev` module. (Contributed by Peter "
"Bosch, with fixes by Jeremy Hylton.)"
msgstr ""

#: ../../whatsnew/2.0.rst:1103
msgid ""
":mod:`mmap`: An interface to memory-mapped files on both Windows and Unix.  "
"A file's contents can be mapped directly into memory, at which point it "
"behaves like a mutable string, so its contents can be read and modified.  "
"They can even be passed to functions that expect ordinary strings, such as "
"the :mod:`re` module. (Contributed by Sam Rushing, with some extensions by "
"A.M. Kuchling.)"
msgstr ""
":mod:`mmap`: Інтерфейс для файлів із відображенням пам’яті як у Windows, так"
" і в Unix. Вміст файлу можна відобразити безпосередньо в пам’яті, після чого"
" він поводиться як змінний рядок, тому його вміст можна читати та змінювати."
" Їх можна навіть передати функціям, які очікують звичайних рядків, "
"наприклад, модулю :mod:`re`. (Надано Семом Рашингом, з деякими розширеннями "
"А. М. Кухлінгом.)"

#: ../../whatsnew/2.0.rst:1109
msgid ""
":mod:`!pyexpat`: An interface to the Expat XML parser. (Contributed by Paul "
"Prescod.)"
msgstr ""

#: ../../whatsnew/2.0.rst:1112
msgid ""
":mod:`robotparser <urllib.robotparser>`: Parse a :file:`robots.txt` file, "
"which is used for writing web spiders that politely avoid certain areas of a"
" web site.  The parser accepts the contents of a :file:`robots.txt` file, "
"builds a set of rules from it, and can then answer questions about the "
"fetchability of a given URL.  (Contributed by Skip Montanaro.)"
msgstr ""

#: ../../whatsnew/2.0.rst:1118
msgid ""
":mod:`tabnanny`: A module/script to  check Python source code for ambiguous "
"indentation. (Contributed by Tim Peters.)"
msgstr ""
":mod:`tabnanny`: Модуль/скрипт для перевірки вихідного коду Python на "
"неоднозначні відступи. (Надав Тім Пітерс.)"

#: ../../whatsnew/2.0.rst:1121
msgid ""
":mod:`!UserString`: A base class useful for deriving objects that behave "
"like strings."
msgstr ""

#: ../../whatsnew/2.0.rst:1124
msgid ""
":mod:`webbrowser`: A module that provides a platform independent way to "
"launch a web browser on a specific URL. For each platform, various browsers "
"are tried in a specific order. The user can alter which browser is launched "
"by setting the *BROWSER* environment variable.  (Originally inspired by Eric"
" S. Raymond's patch to :mod:`urllib` which added similar functionality, but "
"the final module comes from code originally  implemented by Fred Drake as "
":file:`Tools/idle/BrowserControl.py`, and adapted for the standard library "
"by Fred.)"
msgstr ""
":mod:`webbrowser`: модуль, який забезпечує незалежний від платформи спосіб "
"запуску веб-браузера за певною URL-адресою. Для кожної платформи різні "
"браузери пробуються в певному порядку. Користувач може змінити браузер, який"
" запускається, встановивши змінну середовища *BROWSER*. (Спочатку натхненний"
" патчем Еріка С. Реймонда до :mod:`urllib`, який додав подібну "
"функціональність, але остаточний модуль походить від коду, спочатку "
"реалізованого Фредом Дрейком як :file:`Tools/idle/BrowserControl.py`, і "
"адаптованого для стандартна бібліотека Фреда.)"

#: ../../whatsnew/2.0.rst:1133
msgid ""
":mod:`_winreg <winreg>`: An interface to the Windows registry.  "
":mod:`!_winreg` is an adaptation of functions that have been part of "
"PythonWin since 1995, but has now been added to the core  distribution, and "
"enhanced to support Unicode. :mod:`!_winreg` was written by Bill Tutt and "
"Mark Hammond."
msgstr ""

#: ../../whatsnew/2.0.rst:1138
msgid ""
":mod:`zipfile`: A module for reading and writing ZIP-format archives.  These"
" are archives produced by :program:`PKZIP` on DOS/Windows or :program:`zip` "
"on Unix, not to be confused with :program:`gzip`\\ -format files (which are "
"supported by the :mod:`gzip` module) (Contributed by James C. Ahlstrom.)"
msgstr ""
":mod:`zipfile`: Модуль для читання та запису архівів ZIP-формату. Це архіви,"
" створені :program:`PKZIP` у DOS/Windows або :program:`zip` в Unix, не "
"плутати з файлами у форматі :program:`gzip`\\ (які підтримуються модулем "
":mod:`gzip`) (надано Джеймсом К. Алстромом.)"

#: ../../whatsnew/2.0.rst:1143
msgid ""
":mod:`!imputil`: A module that provides a simpler way for writing customized"
" import hooks, in comparison to the existing :mod:`!ihooks` module.  "
"(Implemented by Greg Stein, with much discussion on python-dev along the "
"way.)"
msgstr ""

#: ../../whatsnew/2.0.rst:1151
msgid "IDLE Improvements"
msgstr "Покращення IDLE"

#: ../../whatsnew/2.0.rst:1153
msgid ""
"IDLE is the official Python cross-platform IDE, written using Tkinter. "
"Python 2.0 includes IDLE 0.6, which adds a number of new features and "
"improvements.  A partial list:"
msgstr ""
"IDLE — це офіційна кросплатформна IDE Python, написана за допомогою Tkinter."
" Python 2.0 містить IDLE 0.6, який додає низку нових функцій і покращень. "
"Неповний список:"

#: ../../whatsnew/2.0.rst:1157
msgid ""
"UI improvements and optimizations, especially in the area of syntax "
"highlighting and auto-indentation."
msgstr ""
"Покращення та оптимізація інтерфейсу користувача, особливо в області "
"підсвічування синтаксису та автоматичного відступу."

#: ../../whatsnew/2.0.rst:1160
msgid ""
"The class browser now shows more information, such as the top level "
"functions in a module."
msgstr ""
"Переглядач класів тепер показує більше інформації, наприклад функції "
"верхнього рівня в модулі."

#: ../../whatsnew/2.0.rst:1163
msgid ""
"Tab width is now a user settable option. When opening an existing Python "
"file, IDLE automatically detects the indentation conventions, and adapts."
msgstr ""
"Ширина вкладки тепер доступна користувачеві. Під час відкриття існуючого "
"файлу Python IDLE автоматично визначає правила відступів і адаптує їх."

#: ../../whatsnew/2.0.rst:1166
msgid ""
"There is now support for calling browsers on various platforms, used to open"
" the Python documentation in a browser."
msgstr ""
"Тепер існує підтримка виклику браузерів на різних платформах, які "
"використовуються для відкриття документації Python у браузері."

#: ../../whatsnew/2.0.rst:1169
msgid ""
"IDLE now has a command line, which is largely similar to  the vanilla Python"
" interpreter."
msgstr ""
"У IDLE тепер є командний рядок, який багато в чому схожий на ванільний "
"інтерпретатор Python."

#: ../../whatsnew/2.0.rst:1172
msgid "Call tips were added in many places."
msgstr "У багатьох місцях додано підказки щодо дзвінків."

#: ../../whatsnew/2.0.rst:1174
msgid "IDLE can now be installed as a package."
msgstr "IDLE тепер можна встановити як пакет."

#: ../../whatsnew/2.0.rst:1176
msgid "In the editor window, there is now a line/column bar at the bottom."
msgstr "Тепер у вікні редактора внизу є рядок/стовпець."

#: ../../whatsnew/2.0.rst:1178
msgid ""
"Three new keystroke commands: Check module (:kbd:`Alt-F5`), Import module "
"(:kbd:`F5`) and Run script (:kbd:`Ctrl-F5`)."
msgstr ""
"Три нові команди натискання клавіш: перевірити модуль (:kbd:`Alt-F5`), "
"імпортувати модуль (:kbd:`F5`) і запустити сценарій (:kbd:`Ctrl-F5`)."

#: ../../whatsnew/2.0.rst:1185
msgid "Deleted and Deprecated Modules"
msgstr "Видалені та застарілі модулі"

#: ../../whatsnew/2.0.rst:1187
msgid ""
"A few modules have been dropped because they're obsolete, or because there "
"are now better ways to do the same thing.  The :mod:`!stdwin` module is "
"gone; it was for a platform-independent windowing toolkit that's no longer "
"developed."
msgstr ""

#: ../../whatsnew/2.0.rst:1191
msgid ""
"A number of modules have been moved to the :file:`lib-old` subdirectory: "
":mod:`!cmp`, :mod:`!cmpcache`, :mod:`!dircmp`, :mod:`!dump`,  :mod:`!find`, "
":mod:`!grep`, :mod:`!packmail`,  :mod:`!poly`, :mod:`!util`, "
":mod:`!whatsound`, :mod:`!zmod`.  If you have code which relies on a module"
"  that's been moved to :file:`lib-old`, you can simply add that directory to"
" ``sys.path``   to get them back, but you're encouraged to update any code "
"that uses these modules."
msgstr ""

#: ../../whatsnew/2.0.rst:1200
msgid "Acknowledgements"
msgstr "Подяки"

#: ../../whatsnew/2.0.rst:1202
msgid ""
"The authors would like to thank the following people for offering "
"suggestions on various drafts of this article: David Bolen, Mark Hammond, "
"Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, "
"Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil "
"Schemenauer, and Russ Schmidt."
msgstr ""
"Автори хотіли б подякувати наступним людям за пропозиції щодо різних "
"чернеток цієї статті: Девід Болен, Марк Хаммонд, Грег Хаузер, Джеремі "
"Гілтон, Фредрік Лунд, Детлеф Ланнерт, Ааз Марух, Скіп Монтанаро, Володимир "
"Марангозов, Тобіас Ползін, Гвідо ван Россум, Ніл Шеменауер і Расс Шмідт."
