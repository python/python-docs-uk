# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "What's New in Python 2.2"
msgstr "Що нового в Python 2.2"

msgid "Author"
msgstr "Автор"

msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

msgid "Introduction"
msgstr "вступ"

msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"У цій статті пояснюється нові функції в Python 2.2.2, випущеному 14 жовтня "
"2002 року. Python 2.2.2 — це випуск Python 2.2 з виправленням помилок, "
"спочатку випущений 21 грудня 2001 року."

msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 можна розглядати як \"випуск для очищення\". Є деякі функції, "
"такі як генератори та ітератори, які є абсолютно новими, але більшість змін, "
"хоч і значних і далекосяжних вони можуть бути, спрямовані на очищення "
"нерівностей і темних кутів мовного дизайну."

msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"Ця стаття не намагається надати повну специфікацію нових функцій, натомість "
"надає зручний огляд. Щоб отримати повну інформацію, зверніться до "
"документації для Python 2.2, наприклад `Довідник бібліотеки Python <https://"
"docs.python.org/2.2/lib/lib.html>`_ і `Довідковий посібник Python <https://"
"docs.python.org/2.2/ref/ref.html>`_. Якщо ви хочете зрозуміти повну "
"реалізацію та обґрунтування дизайну для зміни, зверніться до PEP для "
"конкретної нової функції."

msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEP 252 і 253: Зміни типу та класу"

msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so "
"it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"Найбільші та наймасштабніші зміни в Python 2.2 стосуються моделі об’єктів і "
"класів Python. Зміни мають бути зворотно сумісними, тому ймовірно, що ваш "
"код працюватиме без змін, але зміни надають деякі дивовижні нові можливості. "
"Перш ніж почати цей, найдовший і найскладніший розділ цієї статті, я наведу "
"огляд змін і запропоную деякі коментарі."

msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of "
"the most significant flaws was that it's impossible to subclass Python types "
"implemented in C.  In particular, it's not possible to subclass built-in "
"types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but "
"there's lots of C code that expects a regular Python list and won't accept "
"a :class:`UserList` instance."
msgstr ""
"Давно я написав веб-сторінку з переліком недоліків у дизайні Python. Одним "
"із найбільш істотних недоліків було те, що неможливо створити підкласи типів "
"Python, реалізованих у C. Зокрема, неможливо створити підкласи вбудованих "
"типів, тому ви не можете просто підкласити, скажімо, списки, щоб додати один "
"корисний метод їм. Модуль :mod:`UserList` надає клас, який підтримує всі "
"методи списків і який можна додатково створювати на підкласи, але існує "
"багато коду C, який очікує звичайний список Python і не приймає :class:"
"`UserList` екземпляр."

msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr ""
"У Python 2.2 це виправлено, і в процесі додано кілька захоплюючих нових "
"можливостей. Короткий зміст:"

msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr ""
"Ви можете створювати підкласи вбудованих типів, таких як списки та навіть "
"цілі числа, і ваші підкласи повинні працювати в будь-якому місці, де "
"потрібен вихідний тип."

msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr ""
"Тепер можна визначати статичні методи та методи класу на додаток до методів "
"екземплярів, доступних у попередніх версіях Python."

msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`__getattr__` can be rewritten to use properties instead, "
"making the resulting code simpler and faster.  As a small side benefit, "
"attributes can now have docstrings, too."
msgstr ""
"Також можна автоматично викликати методи під час доступу або встановлення "
"атрибута екземпляра за допомогою нового механізму під назвою :dfn:"
"`properties`. Багато варіантів використання :meth:`__getattr__` можна "
"переписати, щоб замість нього використовувати властивості, що робить "
"кінцевий код простішим і швидшим. В якості невеликої додаткової переваги "
"атрибути тепер також можуть мати рядки документації."

msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr ""
"Список юридичних атрибутів для екземпляра можна обмежити певним набором за "
"допомогою :dfn:`slots`, що дає змогу захистити від помилок і, можливо, "
"зробити більше оптимізацій можливим у майбутніх версіях Python."

msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the "
"new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being "
"lost."
msgstr ""
"Деякі користувачі висловили стурбованість усіма цими змінами. Звісно, вони "
"кажуть, що нові функції гарні та піддаються різноманітним хитрощам, які були "
"недоступні в попередніх версіях Python, але вони також ускладнюють мову. "
"Деякі люди кажуть, що вони завжди рекомендували Python за його простоту, і "
"вважають, що його простота втрачається."

msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"Особисто я вважаю, що хвилюватися не варто. Багато нових функцій досить "
"езотеричні, і ви можете написати багато коду Python, навіть не знаючи про "
"них. Написати простий курс не складніше, ніж будь-коли, тому вам не потрібно "
"турбуватися про їх вивчення чи викладання, якщо вони дійсно не потрібні. "
"Деякі дуже складні завдання, які раніше були можливими лише на C, тепер "
"будуть можливими на чистому Python, і, на мій погляд, це все на краще."

msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will "
"paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"Я не збираюся намагатися охопити кожен кутовий випадок і невеликі зміни, які "
"були необхідні для того, щоб нові функції працювали. Натомість у цьому "
"розділі буде намальовано лише широкі штрихи. Перегляньте розділ :ref:`sect-"
"rellinks`, \"Пов’язані посилання\", щоб отримати додаткові джерела "
"інформації про нову об’єктну модель Python 2.2."

msgid "Old and New Classes"
msgstr "Старі та нові класи"

msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python.  "
"All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"По-перше, ви повинні знати, що Python 2.2 насправді має два типи класів: "
"класичні або старі класи та класи нового стилю. Модель класу старого стилю "
"точно така ж, як модель класу в попередніх версіях Python. Усі нові "
"можливості, описані в цьому розділі, застосовуються лише до класів нового "
"стилю. Ця розбіжність не має тривати вічно; зрештою класи старого стилю "
"будуть відкинуті, можливо, у Python 3.0."

msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A "
"new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"Отже, як визначити клас нового стилю? Ви робите це шляхом створення підкласу "
"існуючого класу нового стилю. Більшість вбудованих типів Python, таких як "
"цілі числа, списки, словники та навіть файли, тепер є класами нового стилю. "
"Також було додано новий клас під назвою :class:`object`, базовий клас для "
"всіх вбудованих типів, тож якщо жоден вбудований тип не підходить, ви можете "
"просто створити підклас :class:`object`::"

msgid ""
"This means that :keyword:`class` statements that don't have any base classes "
"are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`__metaclass__` --- see :"
"pep:`253` for the details --- but it's easier to just subclass :class:"
"`object`.)"
msgstr ""
"Це означає, що оператори :keyword:`class`, які не мають базових класів, "
"завжди є класичними класами в Python 2.2. (Насправді ви також можете змінити "
"це, встановивши змінну рівня модуля з назвою :attr:`__metaclass__` --- "
"подробиці див. :pep:`253` --- але простіше просто створити підклас :class:"
"`object`. )"

msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named :func:"
"`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions any "
"more, but type objects that behave as factories when called. ::"
msgstr ""
"Об’єкти типу для вбудованих типів доступні як вбудовані, названі за "
"допомогою хитрого прийому. У Python завжди були вбудовані функції з назвами :"
"func:`int`, :func:`float` і :func:`str`. У 2.2 вони більше не є функціями, а "
"об’єктами типу, які під час виклику поводяться як фабрики. ::"

msgid ""
"To make the set of types complete, new type objects such as :func:`dict` "
"and :func:`file` have been added.  Here's a more interesting example, adding "
"a :meth:`lock` method to file objects::"
msgstr ""
"Щоб завершити набір типів, додано нові об’єкти типу, такі як :func:`dict` і :"
"func:`file`. Ось більш цікавий приклад додавання методу :meth:`lock` до "
"файлових об’єктів::"

msgid ""
"The now-obsolete :mod:`posixfile` module contained a class that emulated all "
"of a file object's methods and also added a :meth:`lock` method, but this "
"class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`LockableFile`."
msgstr ""
"Застарілий модуль :mod:`posixfile` містив клас, який емулював усі методи "
"файлового об’єкта, а також додав метод :meth:`lock`, але цей клас не можна "
"було передати внутрішнім функціям, які очікували вбудованого у файлі, що "
"можливо за допомогою нашого нового :class:`LockableFile`."

msgid "Descriptors"
msgstr "Дескриптори"

msgid ""
"In previous versions of Python, there was no consistent way to discover what "
"attributes and methods were supported by an object. There were some informal "
"conventions, such as defining :attr:`__members__` and :attr:`__methods__` "
"attributes that were lists of names, but often the author of an extension "
"type or a class wouldn't bother to define them.  You could fall back on "
"inspecting the :attr:`~object.__dict__` of an object, but when class "
"inheritance or an arbitrary :meth:`__getattr__` hook were in use this could "
"still be inaccurate."
msgstr ""
"У попередніх версіях Python не було узгодженого способу дізнатися, які "
"атрибути та методи підтримувалися об’єктом. Були деякі неофіційні "
"домовленості, такі як визначення :attr:`__members__` і :attr:`__methods__` "
"атрибутів, які були списками імен, але часто автор типу розширення або класу "
"не турбувався про їх визначення. Ви можете повернутися до перевірки :attr:"
"`~object.__dict__` об’єкта, але коли використовується успадкування класу або "
"довільний хук :meth:`__getattr__`, це може бути неточним."

msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class "
"methods become possible, as well as more exotic constructs."
msgstr ""
"Одна велика ідея, яка лежить в основі нової моделі класу, полягає в тому, що "
"API для опису атрибутів об’єкта за допомогою :dfn:`descriptors` було "
"формалізовано. Дескриптори вказують значення атрибута, вказуючи, чи це "
"метод, чи поле. З API дескриптора статичні методи та методи класу стають "
"можливими, а також більш екзотичні конструкції."

msgid ""
"Attribute descriptors are objects that live inside class objects, and have a "
"few attributes of their own:"
msgstr ""
"Дескриптори атрибутів — це об’єкти, які знаходяться всередині об’єктів класу "
"та мають кілька власних атрибутів:"

msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` це ім'я атрибута."

msgid ":attr:`__doc__` is the attribute's docstring."
msgstr ":attr:`__doc__` — рядок документації атрибута."

msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr ""
"``__get__(object)`` — це метод, який отримує значення атрибута з *object*."

msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr "``__set__(object, value)`` встановлює атрибут *object* на *value*."

msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr "``__delete__(object, value)`` видаляє атрибут *value* *object*."

msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr ""
"Наприклад, коли ви пишете ``obj.x``, кроки, які фактично виконує Python:"

msgid ""
"For methods, :meth:`descriptor.__get__` returns a temporary object that's "
"callable, and wraps up the instance and the method to be called on it. This "
"is also why static methods and class methods are now possible; they have "
"descriptors that wrap up just the method, or the method and the class.  As a "
"brief explanation of these new kinds of methods, static methods aren't "
"passed the instance, and therefore resemble regular functions.  Class "
"methods are passed the class of the object, but not the object itself.  "
"Static and class methods are defined like this::"
msgstr ""
"Для методів :meth:`descriptor.__get__` повертає тимчасовий об’єкт, який "
"можна викликати, і завершує екземпляр і метод, який потрібно викликати на "
"ньому. Ось чому тепер можливі статичні методи та методи класу; вони мають "
"дескриптори, які завершують лише метод або метод і клас. Як коротке "
"пояснення цих нових типів методів, статичні методи не передаються "
"екземпляру, і тому нагадують звичайні функції. Методам класу передається "
"клас об’єкта, але не сам об’єкт. Статичні методи та методи класу "
"визначаються так:"

msgid ""
"The :func:`staticmethod` function takes the function :func:`f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
"Функція :func:`staticmethod` приймає функцію :func:`f` і повертає її, "
"загорнуту в дескриптор, щоб її можна було зберегти в об’єкті класу. Можна "
"очікувати, що для створення таких методів буде спеціальний синтаксис (``def "
"static f``, ``defstatic f()`` або щось подібне), але такий синтаксис ще не "
"визначено; це було залишено для майбутніх версій Python."

msgid ""
"More new features, such as slots and properties, are also implemented as new "
"kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"Більше нових функцій, таких як слоти та властивості, також реалізовано як "
"нові типи дескрипторів, і не важко написати клас дескриптора, який робить "
"щось нове. Наприклад, можна було б написати клас дескрипторів, який би "
"дозволив написати передумови та постумови методу в стилі Ейфеля. Клас, який "
"використовує цю функцію, можна визначити так:"

msgid ""
"Note that a person using the new :func:`eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features "
"don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"Зауважте, що особа, яка використовує новий :func:`eiffelmethod`, не повинна "
"нічого розуміти про дескриптори. Ось чому я думаю, що нові функції не "
"збільшують основну складність мови. Буде кілька майстрів, які повинні знати "
"про це, щоб написати :func:`eiffelmethod` або ZODB або щось інше, але "
"більшість користувачів просто напишуть код поверх отриманих бібліотек і "
"проігнорують деталі реалізації."

msgid "Multiple Inheritance: The Diamond Rule"
msgstr "Множинне успадкування: ромбовидне правило"

msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram "
"taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"Множинне успадкування також стало більш корисним завдяки зміні правил, за "
"якими розпізнаються імена. Розглянемо цей набір класів (діаграма взята з :"
"pep:`253` Гвідо ван Россума):"

msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to :"
"meth:`D.save` will search the classes :class:`D`, :class:`B`, and then :"
"class:`A`, where :meth:`save` would be found and returned.  :meth:`C.save` "
"would never be found at all.  This is bad, because if :class:`C`'s :meth:"
"`save` method is saving some internal state specific to :class:`C`, not "
"calling it will result in that state never getting saved."
msgstr ""
"Правило пошуку для класичних класів просте, але не дуже розумне; базові "
"класи шукаються в глибину зліва направо. Посилання на :meth:`D.save` "
"шукатиме класи :class:`D`, :class:`B`, а потім :class:`A`, де буде знайдено "
"та повернено :meth:`save` . :meth:`C.save` взагалі ніколи не буде знайдено. "
"Це погано, тому що якщо метод :meth:`save` :class:`C` зберігає певний "
"внутрішній стан, специфічний для :class:`C`, його невиклик призведе до того, "
"що цей стан ніколи не буде збережено."

msgid ""
"New-style classes follow a different algorithm that's a bit more complicated "
"to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"Класи нового стилю дотримуються іншого алгоритму, який трохи складніший для "
"пояснення, але в цій ситуації діє правильно. (Зверніть увагу, що Python 2.3 "
"змінює цей алгоритм на такий, який дає ті самі результати в більшості "
"випадків, але дає більш корисні результати для дійсно складних графів "
"успадкування.)"

msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`D`, :class:`B`, :class:`A`, :class:`C`, :"
"class:`A`]."
msgstr ""
"Перерахуйте всі базові класи, дотримуючись класичного правила пошуку, і "
"додайте клас кілька разів, якщо його відвідують неодноразово. У наведеному "
"вище прикладі список відвіданих класів [:class:`D`, :class:`B`, :class:`A`, :"
"class:`C`, :class:`A`]."

msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`D`, :class:`B`, :class:`C`, :class:`A`] after dropping "
"duplicates."
msgstr ""
"Проскануйте список на наявність дубльованих класів. Якщо такі знайдено, "
"видаліть усі, крім одного, залишивши *останнє* у списку. У наведеному вище "
"прикладі список стає [:class:`D`, :class:`B`, :class:`C`, :class:`A`] після "
"видалення дублікатів."

msgid ""
"Following this rule, referring to :meth:`D.save` will return :meth:`C.save`, "
"which is the behaviour we're after.  This lookup rule is the same as the one "
"followed by Common Lisp.  A new built-in function, :func:`super`, provides a "
"way to get at a class's superclasses without having to reimplement Python's "
"algorithm. The most commonly used form will be  ``super(class, obj)``, which "
"returns  a bound superclass object (not the actual class object).  This form "
"will be used in methods to call a method in the superclass; for example, :"
"class:`D`'s :meth:`save` method would look like this::"
msgstr ""
"Дотримуючись цього правила, звернення до :meth:`D.save` поверне :meth:`C."
"save`, що є поведінкою, яку ми прагнемо. Це правило пошуку таке ж, як "
"правило Common Lisp. Нова вбудована функція, :func:`super`, надає спосіб "
"отримати доступ до суперкласів класу без необхідності повторного "
"впровадження алгоритму Python. Найпоширенішою формою буде ``super(class, "
"obj)``, яка повертає пов’язаний об’єкт суперкласу (а не фактичний об’єкт "
"класу). Ця форма буде використовуватися в методах для виклику методу в "
"суперкласі; наприклад, метод :class:`D` :meth:`save` виглядатиме так:"

msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often "
"be useful."
msgstr ""
":func:`super` також може повертати незв’язані об’єкти суперкласу під час "
"виклику ``super(class)`` або ``super(class1, class2)``, але це, мабуть, не "
"часто буде корисним."

msgid "Attribute Access"
msgstr "Доступ до атрибутів"

msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as ``obj."
"get_parent``.  Python 2.2 adds some new ways of controlling attribute access."
msgstr ""
"Велика кількість складних класів Python визначають хуки для доступу до "
"атрибутів за допомогою :meth:`__getattr__`; найчастіше це робиться для "
"зручності, щоб зробити код більш читабельним шляхом автоматичного "
"відображення доступу до атрибута, такого як ``obj.parent``, у виклик методу, "
"такого як ``obj.get_parent``. Python 2.2 додає кілька нових способів "
"контролю доступу до атрибутів."

msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"По-перше, ``__getattr__(attr_name)`` все ще підтримується класами нового "
"стилю, і нічого в ньому не змінилося. Як і раніше, він буде викликаний, коли "
"буде зроблена спроба отримати доступ до ``obj.foo``, а атрибут з назвою "
"``foo`` не знайдено в словнику примірника."

msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`__getattribute__` is *always* called whenever any attribute is "
"accessed, while the old :meth:`__getattr__` is only called if ``foo`` isn't "
"found in the instance's dictionary."
msgstr ""
"Класи нового стилю також підтримують новий метод, "
"``__getattribute__(attr_name)``. Різниця між цими двома методами полягає в "
"тому, що :meth:`__getattribute__` *завжди* викликається щоразу, коли "
"здійснюється доступ до будь-якого атрибута, тоді як старий :meth:"
"`__getattr__` викликається, лише якщо ``foo`` не знайдено в екземплярі "
"словник."

msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of :"
"attr:`~object.__dict__`. :meth:`__getattr__` methods also end up being "
"called by Python when it checks for other methods such as :meth:`__repr__` "
"or :meth:`__coerce__`, and so have to be written with this in mind. Finally, "
"calling a function on every attribute access results in a sizable "
"performance loss."
msgstr ""
"Однак підтримка Python 2.2 :dfn:`properties` часто буде простішим способом "
"перехоплення посилань на атрибути. Написання методу :meth:`__getattr__` є "
"складним, тому що, щоб уникнути рекурсії, ви не можете використовувати "
"звичайний доступ до атрибутів усередині них, а натомість вам доведеться "
"возитися з вмістом :attr:`~object.__dict__`. Методи :meth:`__getattr__` "
"також викликаються Python під час перевірки інших методів, таких як :meth:"
"`__repr__` або :meth:`__coerce__`, тому їх потрібно писати з урахуванням "
"цього. Нарешті, виклик функції для кожного доступу до атрибута призводить до "
"значної втрати продуктивності."

msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you "
"want to define a :attr:`size` attribute that's computed, but also settable, "
"you could write::"
msgstr ""
":class:`property` — це новий вбудований тип, який містить три функції, які "
"отримують, встановлюють або видаляють атрибут і рядок документації. "
"Наприклад, якщо ви хочете визначити атрибут :attr:`size`, який обчислюється, "
"але також може бути встановлений, ви можете написати::"

msgid ""
"That is certainly clearer and easier to write than a pair of :meth:"
"`__getattr__`/:meth:`__setattr__` methods that check for the :attr:`size` "
"attribute and handle it specially while retrieving all other attributes from "
"the instance's :attr:`~object.__dict__`.  Accesses to :attr:`size` are also "
"the only ones which have to perform the work of calling a function, so "
"references to other attributes run at their usual speed."
msgstr ""
"Це, звичайно, зрозуміліше та простіше для написання, ніж пара методів :meth:"
"`__getattr__`/:meth:`__setattr__`, які перевіряють наявність атрибута :attr:"
"`size` і обробляють його спеціально, одночасно одержуючи всі інші атрибути з "
"екземпляра :attr:`~об’єкт.__dict__`. Доступи до :attr:`size` також є "
"єдиними, які повинні виконувати роботу виклику функції, тому посилання на "
"інші атрибути виконуються зі звичайною швидкістю."

msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing ``obj."
"new_attr=1``.   A new-style class can define a class attribute named :attr:"
"`~object.__slots__` to limit the legal attributes  to a particular set of "
"names.  An example will make this clear::"
msgstr ""
"Нарешті, можна обмежити список атрибутів, на які можна посилатися в об’єкті, "
"використовуючи новий атрибут класу :attr:`~object.__slots__`. Об'єкти Python "
"зазвичай дуже динамічні; у будь-який час можна визначити новий атрибут "
"екземпляра, просто виконавши ``obj.new_attr=1``. Клас нового стилю може "
"визначати атрибут класу під назвою :attr:`~object.__slots__`, щоб обмежити "
"допустимі атрибути певним набором імен. Приклад прояснить це:"

msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"Зверніть увагу, як ви отримуєте :exc:`AttributeError` під час спроби "
"призначити атрибут, не вказаний у :attr:`~object.__slots__`."

msgid "Related Links"
msgstr "Пов'язані посилання"

msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr ""
"Цей розділ був лише коротким оглядом нових можливостей, що дає достатньо "
"пояснень, щоб почати програмування, але багато деталей було спрощено або "
"проігноровано. Куди звернутися, щоб отримати більш повну картину?"

msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much "
"more detail about the new features while still remaining quite easy to read."
msgstr ""

msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is "
"titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  :"
"pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"Далі є два відповідних PEP, :pep:`252` і :pep:`253`. :pep:`252` має назву "
"\"Зробіть типи схожими на класи\" та охоплює API дескриптора. :pep:`253` має "
"назву \"Підтипування вбудованих типів\" і описує зміни в об’єктах типів, які "
"роблять можливим підтипування вбудованих об’єктів. :pep:`253` є більш "
"складним PEP з двох, і в деяких моментах необхідні пояснення типів і мета-"
"типів можуть змусити вашу голову вибухнути. Обидва PEP були написані та "
"реалізовані Гвідо ван Россумом за значної допомоги решти команди Zope Corp."

msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"Нарешті, є найвищий авторитет: вихідний код. Більшість механізмів для "
"обробки типів знаходиться в :file:`Objects/typeobject.c`, але ви повинні "
"вдаватися до нього лише після того, як вичерпано всі інші способи, включно з "
"розміщенням запитання в python-list або python-dev."

msgid "PEP 234: Iterators"
msgstr "PEP 234: Ітератори"

msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr ""
"Іншим значним доповненням до 2.2 є ітераційний інтерфейс як на рівнях C, так "
"і на Python. Об’єкти можуть визначати, як вони можуть бути зациклені "
"абонентами."

msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work "
"is to define a :meth:`__getitem__` method that looks something like this::"
msgstr ""
"У версіях Python до 2.1 звичайний спосіб змусити ``for item in obj`` "
"працювати — це визначити метод :meth:`__getitem__`, який виглядає приблизно "
"так::"

msgid ""
":meth:`__getitem__` is more properly used to define an indexing operation on "
"an object so that you can write ``obj[5]`` to retrieve the sixth element.  "
"It's a bit misleading when you're using this only to support :keyword:`for` "
"loops. Consider some file-like object that wants to be looped over; the "
"*index* parameter is essentially meaningless, as the class probably assumes "
"that a series of :meth:`__getitem__` calls will be made with *index* "
"incrementing by one each time.  In other words, the presence of the :meth:"
"`__getitem__` method doesn't mean that using ``file[5]``  to randomly access "
"the sixth element will work, though it really should."
msgstr ""
":meth:`__getitem__` правильніше використовувати для визначення операції "
"індексування об’єкта, щоб ви могли написати ``obj[5]`` для отримання шостого "
"елемента. Це трохи оманливо, коли ви використовуєте це лише для підтримки "
"циклів :keyword:`for`. Розглянемо якийсь файлоподібний об’єкт, який хоче "
"бути зациклений; параметр *index* по суті не має сенсу, оскільки клас, "
"ймовірно, припускає, що серія викликів :meth:`__getitem__` буде здійснена зі "
"збільшенням *index* на одиницю кожного разу. Іншими словами, наявність "
"методу :meth:`__getitem__` не означає, що використання ``file[5]`` для "
"довільного доступу до шостого елемента буде працювати, хоча це справді має "
"працювати."

msgid ""
"In Python 2.2, iteration can be implemented separately, and :meth:"
"`__getitem__` methods can be limited to classes that really do support "
"random access.  The basic idea of iterators is  simple.  A new built-in "
"function, ``iter(obj)`` or ``iter(C, sentinel)``, is used to get an "
"iterator. ``iter(obj)`` returns an iterator for the object *obj*, while "
"``iter(C, sentinel)`` returns an iterator that will invoke the callable "
"object *C* until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"У Python 2.2 ітерація може бути реалізована окремо, а методи :meth:"
"`__getitem__` можуть бути обмежені класами, які дійсно підтримують довільний "
"доступ. Основна ідея ітераторів проста. Для отримання ітератора "
"використовується нова вбудована функція, ``iter(obj)`` або ``iter(C, "
"sentinel)``. ``iter(obj)`` повертає ітератор для об’єкта *obj*, тоді як "
"``iter(C, sentinel)`` повертає ітератор, який викличе об’єкт *C*, що "
"викликається, доки він не поверне *sentinel*, щоб повідомити, що ітератор "
"готовий."

msgid ""
"Python classes can define an :meth:`__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator, "
"this method can just return ``self``.  In particular, iterators will usually "
"be their own iterators.  Extension types implemented in C can implement a :c:"
"member:`~PyTypeObject.tp_iter` function in order to return an iterator, and "
"extension types that want to behave as iterators can define a :c:member:"
"`~PyTypeObject.tp_iternext` function."
msgstr ""
"Класи Python можуть визначати метод :meth:`__iter__`, який має створити та "
"повернути новий ітератор для об’єкта; якщо об’єкт є власним ітератором, цей "
"метод може просто повернути ``self``. Зокрема, ітератори зазвичай є своїми "
"власними ітераторами. Типи розширень, реалізовані в C, можуть реалізовувати "
"функцію :c:member:`~PyTypeObject.tp_iter` для повернення ітератора, а типи "
"розширень, які хочуть поводитися як ітератори, можуть визначати :c:member:"
"`~PyTypeObject.tp_iternext` функція."

msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"Отже, після всього цього, що насправді роблять ітератори? Вони мають один "
"обов’язковий метод, :meth:`next`, який не приймає аргументів і повертає "
"наступне значення. Якщо більше немає значень, які потрібно повернути, "
"виклик :meth:`next` має викликати виняток :exc:`StopIteration`. ::"

msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`__iter__` or a :c:"
"member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"У 2.2 оператор Python :keyword:`for` більше не очікує послідовності; він "
"очікує щось, для чого :func:`iter` поверне ітератор. Для зворотної "
"сумісності та зручності ітератор автоматично створюється для послідовностей, "
"які не реалізують :meth:`__iter__` або слот :c:member:`~PyTypeObject."
"tp_iter`, тому ``for i в [1,2, 3]`` все одно працюватиме. Усюди, де "
"інтерпретатор Python циклічно перебирає послідовність, його було змінено на "
"використання протоколу ітератора. Це означає, що ви можете робити такі речі:"

msgid ""
"Iterator support has been added to some of Python's basic types.   Calling :"
"func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr ""
"До деяких базових типів Python додано підтримку ітераторів. Виклик :func:"
"`iter` у словнику поверне ітератор, який перебирає його ключі:"

msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`iterkeys`, :"
"meth:`itervalues`, or :meth:`iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on "
"dictionaries, so ``key in dict`` is now equivalent to ``dict.has_key(key)``."
msgstr ""
"Це лише поведінка за умовчанням. Якщо ви хочете перебирати ключі, значення "
"або пари ключ/значення, ви можете явно викликати методи :meth:`iterkeys`, :"
"meth:`itervalues` або :meth:`iteritems`, щоб отримати відповідний ітератор. "
"У незначній відповідній зміні оператор :keyword:`in` тепер працює зі "
"словниками, тому ``key in dict`` тепер еквівалентний ``dict.has_key(key)``."

msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each "
"line of a file using code like this::"
msgstr ""
"Файли також містять ітератор, який викликає метод :meth:`readline`, доки у "
"файлі не залишиться рядків. Це означає, що тепер ви можете читати кожен "
"рядок файлу за допомогою такого коду:"

msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol "
"only requires a :meth:`next` method."
msgstr ""
"Зауважте, що в ітераторі можна рухатися лише вперед; немає способу отримати "
"попередній елемент, скинути ітератор або зробити його копію. Об’єкт-ітератор "
"може надати такі додаткові можливості, але протокол ітератора потребує лише "
"методу :meth:`next`."

msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - Ітератори"

msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly "
"by GvR and Tim Peters."
msgstr ""
"Написаний Ка-Пінг Йі та GvR; реалізований командою Python Labs, переважно "
"GvR і Тімом Пітерсом."

msgid "PEP 255: Simple Generators"
msgstr "PEP 255: Прості генератори"

msgid ""
"Generators are another new feature, one that interacts with the introduction "
"of iterators."
msgstr "Генератори — ще одна нова функція, яка взаємодіє з появою ітераторів."

msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"Ви, безсумнівно, знайомі з тим, як працюють виклики функцій у Python або C. "
"Коли ви викликаєте функцію, вона отримує приватний простір імен, де "
"створюються її локальні змінні. Коли функція досягає оператора :keyword:"
"`return`, локальні змінні знищуються, а отримане значення повертається до "
"викликаючого. Пізніший виклик тієї ж функції отримає новий набір локальних "
"змінних. Але що, якби локальні змінні не були викинуті під час виходу з "
"функції? Що, якби ви могли пізніше відновити функцію, де вона була зупинена? "
"Це те, що забезпечують генератори; їх можна розглядати як відновлювані "
"функції."

msgid "Here's the simplest example of a generator function::"
msgstr "Ось найпростіший приклад функції генератора:"

msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"Для генераторів було введено нове ключове слово :keyword:`yield`. Будь-яка "
"функція, що містить оператор :keyword:`!yield`, є функцією-генератором; це "
"виявляється компілятором байт-коду Python, який спеціально компілює функцію "
"в результаті. Оскільки було введено нове ключове слово, генератори мають "
"бути явно ввімкнені в модулі, включивши оператор ``from __future__ import "
"generators`` у верхній частині вихідного коду модуля. У Python 2.3 цей "
"оператор стане непотрібним."

msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`!try` block of a :keyword:"
"`try`...\\ :keyword:`finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"Коли ви викликаєте функцію генератора, вона не повертає жодного значення; "
"замість цього він повертає об'єкт генератора, який підтримує протокол "
"ітератора. Під час виконання оператора :keyword:`yield` генератор виводить "
"значення ``i``, подібне до оператора :keyword:`return`. Велика різниця між :"
"keyword:`!yield` і оператором :keyword:`!return` полягає в тому, що при "
"досягненні :keyword:`!yield` стан виконання генератора призупиняється, а "
"локальні змінні зберігаються. Під час наступного виклику методу ``next()`` "
"генератора функція відновить виконання відразу після оператора :keyword:`!"
"yield`. (Зі складних причин оператор :keyword:`!yield` не дозволяється "
"всередині блоку :keyword:`!try` оператора :keyword:`try`...\\ :keyword:"
"`finally`; читайте :pep:`255` для повного пояснення взаємодії між :keyword:`!"
"yield` і винятками.)"

msgid "Here's a sample usage of the :func:`generate_ints` generator::"
msgstr "Ось приклад використання генератора :func:`generate_ints`::"

msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"Так само можна написати ``for i in generate_ints(5)`` або ``a,b,c = "
"generate_ints(3)``."

msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"Усередині функції генератора оператор :keyword:`return` може "
"використовуватися лише без значення та сигналізує про завершення процесії "
"значень; після цього генератор не може повертати жодних додаткових значень. :"
"keyword:`!return` зі значенням, таким як ``return 5``, є синтаксичною "
"помилкою у функції генератора. Кінець результатів генератора також можна "
"вказати, піднявши :exc:`StopIteration` вручну, або просто дозволивши потоку "
"виконання впасти з нижньої частини функції."

msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"Ви можете досягти ефекту генераторів вручну, написавши власний клас і "
"зберігши всі локальні змінні генератора як змінні екземпляра. Наприклад, щоб "
"повернути список цілих чисел, можна встановити ``self.count`` на 0, а метод :"
"meth:`next` збільшити ``self.count`` і повернути його. Однак для помірно "
"складного генератора написання відповідного класу було б набагато "
"складнішим. :file:`Lib/test/test_generators.py` містить ще кілька цікавих "
"прикладів. Найпростіший реалізує рекурсивний обхід дерева за допомогою "
"генераторів. ::"

msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"Два інших приклади в :file:`Lib/test/test_generators.py` створюють рішення "
"для проблеми N-Queens (розміщення $N$ ферзів на $NxN$ шахівниці так, щоб "
"жодна королева не загрожувала іншій) і Knight's Tour (a маршрут, який веде "
"лицаря до кожного поля $NxN$ шахівниці, не відвідуючи жодного поля двічі)."

msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""
"Ідея генераторів походить від інших мов програмування, особливо Icon "
"(https://www.cs.arizona.edu/icon/), де ідея генераторів є центральною. У "
"Icon кожен вираз і виклик функції поводяться як генератор. Один приклад із "
"\"Огляду мови програмування значків\" на https://www.cs.arizona.edu/icon/"
"docs/ipd266.htm дає уявлення про те, як це виглядає:"

msgid ""
"In Icon the :func:`find` function returns the indexes at which the substring "
"\"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` is first "
"assigned a value of 3, but 3 is less than 5, so the comparison fails, and "
"Icon retries it with the second value of 23.  23 is greater than 5, so the "
"comparison now succeeds, and the code prints the value 23 to the screen."
msgstr ""
"У Icon функція :func:`find` повертає індекси, за якими знайдено підрядок "
"\"or\": 3, 23, 33. У операторі :keyword:`if` ``i`` спочатку присвоюється "
"значення 3, але 3 менше за 5, тому порівняння не вдається, і Icon повторює "
"спробу з другим значенням 23. 23 більше за 5, тому порівняння завершується "
"успішно, і код друкує значення 23 на екрані."

msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to "
"other functions or stored in a data structure."
msgstr ""
"Python не заходить так далеко, як Icon, у прийнятті генераторів як "
"центральної концепції. Генератори вважаються новою частиною ядра мови "
"Python, але їх вивчення або використання не є обов’язковим; якщо вони не "
"вирішують жодних ваших проблем, не соромтеся їх ігнорувати. Однією з нових "
"особливостей інтерфейсу Python порівняно з інтерфейсом Icon є те, що стан "
"генератора представлено як конкретний об’єкт (ітератор), який можна передати "
"іншим функціям або зберегти в структурі даних."

msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Прості генератори"

msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"Автори: Ніл Шеменауер, Тім Пітерс, Магнус Лі Хетленд. Реалізовано переважно "
"Нілом Шеменауером і Тімом Пітерсом, інші виправлення внесені командою Python "
"Labs."

msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: Об’єднання довгих і цілих чисел"

msgid ""
"In recent versions, the distinction between regular integers, which are 32-"
"bit values on most machines, and long integers, which can be of arbitrary "
"size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"В останніх версіях різниця між звичайними цілими числами, які є 32-"
"розрядними значеннями на більшості машин, і довгими цілими числами, які "
"можуть мати довільний розмір, стала неприємною. Наприклад, на платформах, "
"які підтримують файли розміром понад ``2**32`` байти, метод :meth:`tell` "
"файлових об’єктів має повертати довге ціле число. Однак існували різні "
"частини Python, які очікували простих цілих чисел і викликали помилку, якщо "
"натомість було надано довге ціле число. Наприклад, у Python 1.5 лише "
"звичайні цілі числа можна було використовувати як індекс фрагмента, а "
"``'abc'[1L:]`` викликав би виняток :exc:`TypeError` із повідомленням "
"\"індекс фрагмента повинен бути int\" ."

msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 за потреби змінюватиме значення від коротких до довгих цілих. "
"Суфікс 'L' більше не потрібен для позначення довгого цілого літералу, "
"оскільки тепер компілятор вибере відповідний тип. (Використання суфікса "
"\"L\" не буде рекомендовано в майбутніх версіях Python 2.x, ініціюючи "
"попередження в Python 2.4, і, ймовірно, буде відмінено в Python 3.0.) Багато "
"операцій, які раніше викликали помилку :exc:`OverflowError`, тепер "
"повертатимуть довге ціле число як їхній результат. Наприклад::"

msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr ""
"У більшості випадків цілі та довгі цілі тепер оброблятимуться однаково. Ви "
"все ще можете розрізнити їх за допомогою вбудованої функції :func:`type`, "
"але це рідко потрібно."

msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - Об'єднання довгих і цілих чисел"

msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr ""
"Автори Моше Цадка та Гвідо ван Россум. Реалізовано переважно Гвідо ван "
"Россумом."

msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238: Зміна оператора поділу"

msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Найбільш суперечлива зміна в Python 2.2 віщує початок спроб виправити старий "
"недолік дизайну, який був у Python з самого початку. Наразі оператор ділення "
"Python, ``/``, поводиться як оператор ділення C, коли йому представлено два "
"цілочисельні аргументи: він повертає цілочисельний результат, який "
"скорочується, коли має бути дробова частина. Наприклад, \"3/2\" — це 1, а не "
"1,5, а \"(-1)/2\" — це -1, а не -0,5. Це означає, що результати ділення "
"можуть неочікувано відрізнятися залежно від типу двох операндів, а оскільки "
"Python типізується динамічно, може бути важко визначити можливі типи "
"операндів."

msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether "
"it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"(Суперечка точиться про те, чи це *справді* недолік дизайну, і чи варто "
"ламати існуючий код, щоб виправити це. Це викликало нескінченні дискусії на "
"python-dev, а в липні 2001 року вибухнуло бурею їдко-саркастичних публікацій "
"на :newsgroup:`comp.lang.python`. Я не буду сперечатися на жодну зі сторін "
"тут і зупинюся на описі того, що реалізовано у 2.2. Прочитайте :pep:`238`, "
"щоб отримати підсумок аргументів і контраргументів.)"

msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"Оскільки ця зміна може порушити код, вона вводиться дуже поступово. Python "
"2.2 починає перехід, але перехід не буде завершено до Python 3.0."

msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is "
"0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"По-перше, я запозичу деяку термінологію з :pep:`238`. \"Справжнє ділення\" — "
"це ділення, яке знайоме більшості непрограмістів: 3/2 — це 1,5, 1/4 — це "
"0,25 і так далі. \"Поділ на поверх\" - це те, що наразі робить оператор ``/"
"`` Python, коли йому надаються цілі операнди; результатом є мінімальне "
"значення, яке повертається істинним діленням. \"Класичний розподіл\" - це "
"поточна змішана поведінка ``/``; він повертає результат ділення на поверх, "
"якщо операнди є цілими числами, і повертає результат справжнього ділення, "
"коли один із операндів є числом з плаваючою комою."

msgid "Here are the changes 2.2 introduces:"
msgstr "Ось зміни, внесені 2.2:"

msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and "
"``1.0 // 2.0`` is also 0.0."
msgstr ""
"Новий оператор, ``//``, є оператором поділу поверху. (Так, ми знаємо, що це "
"виглядає як символ коментаря C++.) ``//`` *завжди* виконує поділ на поверх "
"незалежно від типів його операндів, тому ``1 // 2`` дорівнює 0 і ``1.0 // "
"2.0`` також 0.0."

msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr ""
"``//`` завжди доступний у Python 2.2; вам не потрібно вмикати його за "
"допомогою оператора ``__future__``."

msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"Якщо додати в модуль ``from __future__ import division``, оператор ``/`` "
"буде змінено, щоб повернути результат справжнього поділу, тому ``1/2`` "
"дорівнює 0,5. Без оператора ``__future__`` ``/`` усе ще означає класичний "
"розподіл. Стандартне значення ``/`` не зміниться до Python 3.0."

msgid ""
"Classes can define methods called :meth:`__truediv__` and :meth:"
"`__floordiv__` to overload the two division operators.  At the C level, "
"there are also slots in the :c:type:`PyNumberMethods` structure so extension "
"types can define the two operators."
msgstr ""
"Класи можуть визначати методи під назвою :meth:`__truediv__` і :meth:"
"`__floordiv__` для перевантаження двох операторів ділення. На рівні C також "
"є слоти в структурі :c:type:`PyNumberMethods`, тому типи розширення можуть "
"визначати два оператори."

msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with :option:"
"`!-Q warn` will cause a warning to be issued whenever division is applied to "
"two integers.  You can use this to find code that's affected by the change "
"and fix it.  By default, Python 2.2 will simply perform classic division "
"without a warning; the warning will be turned on by default in Python 2.3."
msgstr ""
"Python 2.2 підтримує деякі аргументи командного рядка для перевірки того, чи "
"працюватиме код зі зміненою семантикою поділу. Запуск python із :option:`!-Q "
"warn` призведе до появи попередження щоразу, коли ділення буде застосовано "
"до двох цілих чисел. Ви можете використовувати це, щоб знайти код, на який "
"вплинули зміни, і виправити його. За замовчуванням Python 2.2 просто "
"виконуватиме класичне ділення без попередження; попередження буде ввімкнено "
"за замовчуванням у Python 2.3."

msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238` - Зміна оператора ділення"

msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr ""
"Автори Моше Цадка та Гвідо ван Россум. Реалізовано Гвідо ван Россумом.."

msgid "Unicode Changes"
msgstr "Зміни Unicode"

msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Підтримку Python Unicode було дещо вдосконалено у версії 2.2. Рядки Unicode "
"зазвичай зберігаються як UCS-2, як 16-розрядні цілі числа без знаку. Python "
"2.2 також можна скомпілювати для використання UCS-4, 32-розрядних цілих "
"чисел без знаку, як внутрішнього кодування, надаючи :option:`!--enable-"
"unicode=ucs4` до сценарію конфігурації. (Також можна вказати :option:`!--"
"disable-unicode`, щоб повністю вимкнути підтримку Unicode.)"

msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than "
"65535 will still cause :func:`unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode "
"characters\"; consult it for further details."
msgstr ""
"Якщо створено для використання UCS-4 (\"широкого Python\"), інтерпретатор "
"може нативно обробляти символи Unicode від U+000000 до U+110000, тому "
"діапазон допустимих значень для функції :func:`unichr` відповідно "
"розширюється. Використовуючи інтерпретатор, скомпільований для використання "
"UCS-2 (\"вузького Python\"), значення, що перевищують 65535, все одно "
"призведуть до того, що :func:`unichr` викличе виняток :exc:`ValueError`. Усе "
"це описано в :pep:`261`, \"Підтримка \"широких\" символів Unicode\"; "
"зверніться до нього для отримання додаткової інформації."

msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`decode` assumes that the string is in the "
"specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""
"Іншу зміну пояснити простіше. З моменту появи рядки Unicode підтримували "
"метод :meth:`encode` для перетворення рядка у вибране кодування, наприклад "
"UTF-8 або Latin-1. Симетричний метод ``decode([*encoding*])`` було додано до "
"8-бітових рядків (хоча не до рядків Unicode) у 2.2. :meth:`decode` "
"припускає, що рядок знаходиться у вказаному кодуванні, і декодує його, "
"повертаючи те, що повертає кодек."

msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"За допомогою цієї нової функції було додано кодеки для завдань, які "
"безпосередньо не пов’язані з Unicode. Наприклад, додано кодеки для uu-"
"кодування, кодування MIME base64 і стиснення за допомогою модуля :mod:"
"`zlib`::"

msgid ""
"To convert a class instance to Unicode, a :meth:`__unicode__` method can be "
"defined by a class, analogous to :meth:`__str__`."
msgstr ""
"Щоб перетворити екземпляр класу в Unicode, метод :meth:`__unicode__` може "
"бути визначений класом, аналогічно :meth:`__str__`."

msgid ""
":meth:`encode`, :meth:`decode`, and :meth:`__unicode__` were implemented by "
"Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`encode`, :meth:`decode` і :meth:`__unicode__` були реалізовані Марком-"
"Андре Лембургом. Зміни для внутрішньої підтримки використання UCS-4 "
"впровадили Фредрік Лунд і Мартін фон Льовіс."

msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - Підтримка \"широких\" символів Unicode"

msgid "Written by Paul Prescod."
msgstr "Написав Пол Прескод."

msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: Вкладені області"

msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always "
"present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"У Python 2.1 статичні вкладені області було додано як необов’язкову функцію, "
"яку можна ввімкнути за допомогою директиви ``from __future__ import "
"nested_scopes``. У версії 2.2 вкладені області більше не потрібно спеціально "
"вмикати, і тепер вони завжди присутні. Решта цього розділу є копією опису "
"вкладених областей з мого документа \"Що нового в Python 2.1\"; якщо ви "
"прочитали його, коли вийшла версія 2.1, ви можете пропустити решту цього "
"розділу."

msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to "
"Python's scoping rules.  In Python 2.0, at any given time there are at most "
"three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match "
"their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Найбільша зміна, внесена в Python 2.1 і завершена в 2.2, стосується правил "
"визначення області видимості Python. У Python 2.0 у будь-який момент часу "
"існує щонайбільше три простори імен, які використовуються для пошуку імен "
"змінних: локальний, на рівні модуля та вбудований простір імен. Це часто "
"дивувало людей, оскільки не відповідало їхнім інтуїтивним очікуванням. "
"Наприклад, визначення вкладеної рекурсивної функції не працює:"

msgid ""
"The function :func:`g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"Функція :func:`g` завжди викличе виняток :exc:`NameError`, оскільки "
"прив’язка імені ``g`` не знаходиться ні в його локальному просторі імен, ні "
"в просторі імен на рівні модуля. Це не є великою проблемою на практиці (як "
"часто ви рекурсивно визначаєте такі внутрішні функції?), але це також робило "
"використання виразу :keyword:`lambda` більш незграбним, і це було проблемою "
"на практиці. У коді, який використовує :keyword:`!lambda`, ви часто можете "
"знайти локальні змінні, які копіюються, передаючи їх як стандартні значення "
"аргументів. ::"

msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr ""
"У результаті цього значно погіршується читабельність коду Python, написаного "
"у сильно функціональному стилі."

msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"Найсуттєвішою зміною в Python 2.2 є те, що для вирішення цієї проблеми до "
"мови додано статичне визначення області видимості. Як перший ефект, аргумент "
"за замовчуванням ``name=name`` тепер непотрібний у наведеному вище прикладі. "
"Простіше кажучи, коли заданому імені змінної не присвоєно значення у функції "
"(за допомогою призначення або операторів :keyword:`def`, :keyword:`class` "
"або :keyword:`import`), посилання на змінна буде шукатися в локальному "
"просторі імен охоплюючої області. Більш детальне пояснення правил і опис "
"реалізації можна знайти в PEP."

msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"Ця зміна може спричинити деякі проблеми сумісності для коду, де те саме ім’я "
"змінної використовується як на рівні модуля, так і як локальна змінна у "
"функції, яка містить додаткові визначення функцій. Це здається "
"малоймовірним, оскільки такий код було б досить заплутаним для читання."

msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"Одним із побічних ефектів змін є те, що оператори ``from module import *`` і "
"``exec`` були зроблені незаконними в межах функції за певних умов. У "
"довідковому посібнику Python весь час говорилося, що ``from module import "
"*`` допустимо лише на верхньому рівні модуля, але інтерпретатор CPython "
"ніколи раніше не виконував цього. Як частина реалізації вкладених областей, "
"компілятор, який перетворює джерело Python на байт-коди, має згенерувати "
"інший код для доступу до змінних у місткій області. ``from module import *`` "
"і ``exec`` не дозволяють компілятору це зрозуміти, оскільки вони додають "
"імена до локального простору імен, які невідомі під час компіляції. Таким "
"чином, якщо функція містить визначення функції або :keyword:`lambda` вирази "
"з вільними змінними, компілятор позначить це, викликавши виняток :exc:"
"`SyntaxError`."

msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "Щоб зробити попереднє пояснення трохи зрозумілішим, ось приклад::"

msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`g`."
msgstr ""
"Рядок 4, що містить інструкцію ``exec``, є синтаксичною помилкою, оскільки "
"``exec`` визначатиме нову локальну змінну з назвою ``x``, до значення якої "
"має отримати доступ :func:`g`."

msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"Це не повинно бути великим обмеженням, оскільки ``exec`` рідко "
"використовується в більшості коду Python (і коли він використовується, це "
"часто свідчить про поганий дизайн)."

msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - Статично вкладені області"

msgid "Written and implemented by Jeremy Hylton."
msgstr "Написаний і реалізований Джеремі Гілтоном."

msgid "New and Improved Modules"
msgstr "Нові та вдосконалені модулі"

msgid ""
"The :mod:`xmlrpclib` module was contributed to the standard library by "
"Fredrik Lundh, providing support for writing XML-RPC clients.  XML-RPC is a "
"simple remote procedure call protocol built on top of HTTP and XML. For "
"example, the following snippet retrieves a list of RSS channels from the "
"O'Reilly Network, and then  lists the recent headlines for one channel::"
msgstr ""
"Модуль :mod:`xmlrpclib` був доданий до стандартної бібліотеки Фредріком "
"Лундом, надаючи підтримку для написання клієнтів XML-RPC. XML-RPC — це "
"простий протокол віддаленого виклику процедури, створений на основі HTTP і "
"XML. Наприклад, наведений нижче фрагмент отримує список каналів RSS із "
"мережі O'Reilly, а потім перераховує останні заголовки для одного каналу:"

msgid ""
"The :mod:`SimpleXMLRPCServer` module makes it easy to create straightforward "
"XML-RPC servers.  See http://xmlrpc.scripting.com/ for more information "
"about XML-RPC."
msgstr ""
"Модуль :mod:`SimpleXMLRPCServer` дозволяє легко створювати прості сервери "
"XML-RPC. Перегляньте http://xmlrpc.scripting.com/ для отримання додаткової "
"інформації про XML-RPC."

msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by :rfc:"
"`2104`. (Contributed by Gerhard Häring.)"
msgstr ""
"Новий модуль :mod:`hmac` реалізує алгоритм HMAC, описаний :rfc:`2104`. "
"(Надав Герхард Херінг.)"

msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as memberst_mtime or :attr:`tm_year`. The enhanced functions include :"
"func:`stat`, :func:`fstat`, :func:`statvfs`, and :func:`fstatvfs` in the :"
"mod:`os` module, and :func:`localtime`, :func:`gmtime`, and :func:`strptime` "
"in the :mod:`time` module."
msgstr ""
"Кілька функцій, які спочатку повертали довгі кортежі, тепер повертають "
"псевдопослідовності, які все ще поводяться як кортежі, але також мають "
"мнемонічні атрибути, такі як memberst_mtime або :attr:`tm_year`. До "
"розширених функцій належать :func:`stat`, :func:`fstat`, :func:`statvfs` і :"
"func:`fstatvfs` у модулі :mod:`os`, а також :func:`localtime`, :func:"
"`gmtime` і :func:`strptime` у модулі :mod:`time`."

msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = os.stat(filename)."
"st_size``."
msgstr ""
"Наприклад, щоб отримати розмір файлу за допомогою старих кортежів, вам "
"доведеться написати щось на зразок ``file_size = os.stat(filename)[stat."
"ST_SIZE]``, але тепер це можна записати більш чітко як ``file_size = os."
"stat(назва_файлу).st_size``."

msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr "Оригінальний патч для цієї функції надав Нік Метьюсон."

msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Профайлер Python було значно перероблено та виправлено різні помилки в його "
"виводі. (Надано Фредом Л. Дрейком молодшим і Тімом Пітерсом.)"

msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the :"
"option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
"Модуль :mod:`socket` можна скомпільувати для підтримки IPv6; вкажіть "
"параметр :option:`!--enable-ipv6` для сценарію налаштування Python. (Надав "
"Дзюн-ічіро \"ітоджун\" Хагіно.)"

msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is "
"for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value is "
"returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""

msgid ""
"In the interpreter's interactive mode, there's a new built-in function :func:"
"`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to provide "
"interactive help. ``help(object)`` displays any available help text about "
"*object*.  :func:`help` with no argument puts you in an online help utility, "
"where you can enter the names of functions, classes, or modules to read "
"their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's :mod:"
"`pydoc` module.)"
msgstr ""
"В інтерактивному режимі інтерпретатора є нова вбудована функція :func:"
"`help`, яка використовує модуль :mod:`pydoc`, представлений у Python 2.1, "
"для надання інтерактивної довідки. ``help(object)`` відображає будь-який "
"доступний текст довідки про *object*. :func:`help` без аргументу передає вас "
"до утиліти онлайн-довідки, де ви можете вводити назви функцій, класів або "
"модулів, щоб прочитати їхній текст довідки. (Надано Гвідо ван Россумом, "
"використовуючи модуль Ka-Ping Yee :mod:`pydoc`.)"

msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` "
"and :func:`re.split` functions have been rewritten in C.  Another "
"contributed patch speeds up certain Unicode character ranges by a factor of "
"two, and a new :meth:`finditer`  method that returns an iterator over all "
"the non-overlapping matches in  a given string.  (SRE is maintained by "
"Fredrik Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
"У механізмі SRE, що лежить в основі модуля :mod:`re`, було зроблено різні "
"виправлення помилок і покращено продуктивність. Наприклад, функції :func:`re."
"sub` і :func:`re.split` було переписано мовою C. Інший патч пришвидшує певні "
"діапазони символів Юнікоду в два рази, а також новий :meth:`метод finditer`, "
"який повертає ітератор для всіх неперекриваючих збігів у заданому рядку. "
"(SRE підтримує Фредрік Лунд. Патч BIGCHARSET надав Мартін фон Льовіс.)"

msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib` "
"also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
"Модуль :mod:`smtplib` тепер підтримує :rfc:`2487`, \"Безпечний SMTP через "
"TLS\", тому тепер можна шифрувати SMTP-трафік між програмою Python і агентом "
"транспортування пошти, якому передається повідомлення. :mod:`smtplib` також "
"підтримує аутентифікацію SMTP. (Надав Герхард Херінг.)"

msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
"Модуль :mod:`imaplib`, який підтримує Пірс Лаудер, підтримує кілька нових "
"розширень: розширення NAMESPACE, визначене в :rfc:`2342`, SORT, GETACL і "
"SETACL. (Надано Ентоні Бакстером і Мішелем Пеллетьє.)"

msgid ""
"The :mod:`rfc822` module's parsing of email addresses is now compliant with :"
"rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* going to "
"be changed to ``rfc2822``.)  A new package, :mod:`email`, has also been "
"added for parsing and generating e-mail messages.  (Contributed by Barry "
"Warsaw, and arising out of his work on Mailman.)"
msgstr ""
"Аналіз адрес електронної пошти модулем :mod:`rfc822` тепер сумісний з :rfc:"
"`2822`, оновленням до :rfc:`822`. (Ім’я модуля *не* буде змінено на "
"``rfc2822``.) Новий пакет, :mod:`email`, також було додано для аналізу та "
"генерування повідомлень електронної пошти. (Надано Баррі Варшау, що є "
"результатом його роботи над Mailman.)"

msgid ""
"The :mod:`difflib` module now contains a new :class:`Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, :func:"
"`ndiff` and :func:`restore`, which respectively return a delta from two "
"sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
"Модуль :mod:`difflib` тепер містить новий клас :class:`Differ` для створення "
"зрозумілих людині списків змін (\"дельта\") між двома послідовностями рядків "
"тексту. Є також дві функції-генератори, :func:`ndiff` і :func:`restore`, які "
"відповідно повертають дельту з двох послідовностей або одну з оригінальних "
"послідовностей з дельти. (Роботу Grunt вніс Девід Гуджер, з коду ndiff.py "
"Тім Пітерс, який потім виконав генерацію.)"

msgid ""
"New constants :const:`ascii_letters`, :const:`ascii_lowercase`, and :const:"
"`ascii_uppercase` were added to the :mod:`string` module.  There were "
"several modules in the standard library that used :const:`string.letters` to "
"mean the ranges A-Za-z, but that assumption is incorrect when locales are in "
"use, because :const:`string.letters` varies depending on the set of legal "
"characters defined by the current locale.  The buggy modules have all been "
"fixed to use :const:`ascii_letters` instead. (Reported by an unknown person; "
"fixed by Fred L. Drake, Jr.)"
msgstr ""
"Нові константи :const:`ascii_letters`, :const:`ascii_lowercase` і :const:"
"`ascii_uppercase` додано до модуля :mod:`string`. У стандартній бібліотеці "
"було кілька модулів, які використовували :const:`string.letters` для "
"позначення діапазонів A-Za-z, але це припущення є неправильним, коли "
"використовуються локалі, оскільки :const:`string.letters` змінюється залежно "
"від на наборі юридичних символів, визначених поточною локалізацією. У всіх "
"модулях із помилками було виправлено використання :const:`ascii_letters`. "
"(Повідомлено невідомою особою; виправлено Фредом Л. Дрейком-молодшим)"

msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type "
"databases by the addition of a :class:`MimeTypes` class, which takes a list "
"of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Модуль :mod:`mimetypes` тепер полегшує використання альтернативних баз даних "
"типу MIME завдяки доданню класу :class:`MimeTypes`, який приймає список імен "
"файлів для аналізу. (Надав Фред Л. Дрейк-молодший)"

msgid ""
"A :class:`Timer` class was added to the :mod:`threading` module that allows "
"scheduling an activity to happen at some future time.  (Contributed by "
"Itamar Shtull-Trauring.)"
msgstr ""
"До модуля :mod:`threading` було додано клас :class:`Timer`, який дозволяє "
"планувати виконання активності в майбутньому. (Надав Ітамар Штул-Траурінг.)"

msgid "Interpreter Changes and Fixes"
msgstr "Зміни та виправлення перекладача"

msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"Деякі зміни стосуються лише тих, хто має справу з інтерпретатором Python на "
"рівні C, оскільки вони пишуть модулі розширення Python, вбудовують "
"інтерпретатор або просто зламують сам інтерпретатор. Якщо ви пишете лише код "
"на Python, жодна з описаних тут змін не вплине на вас."

msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors "
"of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The "
"existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Функції профілювання та трасування тепер можна реалізувати в C, який може "
"працювати на набагато вищій швидкості, ніж функції на основі Python, і має "
"зменшити накладні витрати на профілювання та трасування. Це буде цікаво "
"авторам середовищ розробки для Python. До API Python додано дві нові функції "
"C: :c:func:`PyEval_SetProfile` і :c:func:`PyEval_SetTrace`. Існуючі функції :"
"func:`sys.setprofile` і :func:`sys.settrace` все ще існують, і їх просто "
"змінено для використання нового інтерфейсу рівня C. (Надав Фред Л. Дрейк-"
"молодший)"

msgid ""
"Another low-level API, primarily of interest to implementors of Python "
"debuggers and development tools, was added. :c:func:"
"`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let a caller "
"walk through all the existing interpreter objects; :c:func:"
"`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` allow "
"looping over all the thread states for a given interpreter.  (Contributed by "
"David Beazley.)"
msgstr ""
"Було додано ще один низькорівневий API, який в першу чергу цікавить "
"розробників налагоджувачів Python та інструментів розробки. :c:func:"
"`PyInterpreterState_Head` і :c:func:`PyInterpreterState_Next` дозволяють "
"абоненту пройти через усі існуючі об’єкти інтерпретатора; :c:func:"
"`PyInterpreterState_ThreadHead` і :c:func:`PyThreadState_Next` дозволяють "
"циклічно переглядати всі стани потоку для певного інтерпретатора. (Надав "
"Девід Бізлі.)"

msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug "
"misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"Інтерфейс рівня C для збирача сміття було змінено, щоб полегшити написання "
"типів розширень, які підтримують збирання сміття, і налагодити неправильне "
"використання функцій. Різні функції мають дещо різну семантику, тому купу "
"функцій довелося перейменувати. Розширення, які використовують старий API, "
"все одно будуть компілюватися, але *не* братимуть участь у збиранні сміття, "
"тому їхнє оновлення до 2.2 має вважатися досить пріоритетним."

msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr "Щоб оновити модуль розширення до нового API, виконайте такі дії:"

msgid "Rename :c:func:`Py_TPFLAGS_GC` to :c:func:`PyTPFLAGS_HAVE_GC`."
msgstr "Перейменуйте :c:func:`Py_TPFLAGS_GC` на :c:func:`PyTPFLAGS_HAVE_GC`."

msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr ""
"Використовуйте :c:func:`PyObject_GC_New` або :c:func:`PyObject_GC_NewVar` "
"для виділення"

msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "об’єктів і :c:func:`PyObject_GC_Del`, щоб звільнити їх."

msgid "Rename :c:func:`PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and"
msgstr ""
"Перейменуйте :c:func:`PyObject_GC_Init` на :c:func:`PyObject_GC_Track` і"

msgid ":c:func:`PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ":c:func:`PyObject_GC_Fini` до :c:func:`PyObject_GC_UnTrack`."

msgid "Remove :c:func:`PyGC_HEAD_SIZE` from object size calculations."
msgstr "Видалити :c:func:`PyGC_HEAD_SIZE` з обчислень розміру об’єкта."

msgid ""
"Remove calls to :c:func:`PyObject_AS_GC` and :c:func:`PyObject_FROM_GC`."
msgstr ""
"Видаліть виклики :c:func:`PyObject_AS_GC` і :c:func:`PyObject_FROM_GC`."

msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et`` "
"takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following section.)"
msgstr ""
"Нову послідовність формату ``et`` додано до :c:func:`PyArg_ParseTuple`; "
"``et`` приймає як параметр, так і ім’я кодування та перетворює параметр у "
"вказане кодування, якщо параметр виявляється рядком Юнікоду, або залишає "
"його в спокої, якщо це 8-бітовий рядок, припускаючи, що він уже є у "
"потрібному кодуванні. Це відрізняється від символу формату ``es``, який "
"припускає, що 8-бітні рядки мають типове кодування ASCII Python, і "
"перетворює їх у вказане нове кодування. (Надано M.-A. Lemburg і "
"використовується для підтримки MBCS у Windows, описаної в наступному "
"розділі.)"

msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been "
"added that's simpler and presumably faster.  Instead of specifying a format "
"string, the caller simply gives the minimum and maximum number of arguments "
"expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""

msgid ""
"Two new flags :const:`METH_NOARGS` and :const:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses :const:"
"`METH_VARARGS`.  Also, the old :const:`METH_OLDARGS` style of writing C "
"methods is  now officially deprecated."
msgstr ""
"Два нові прапорці :const:`METH_NOARGS` і :const:`METH_O` доступні в таблицях "
"визначення методів, щоб спростити реалізацію методів без аргументів або з "
"одним нетиповим аргументом. Виклик таких методів ефективніший, ніж виклик "
"відповідного методу, який використовує :const:`METH_VARARGS`. Крім того, "
"старий :const:`METH_OLDARGS` стиль написання методів C тепер офіційно "
"застарів."

msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and :c:func:"
"`PyOS_vsnprintf` were added to provide  cross-platform implementations for "
"the relatively new :c:func:`snprintf` and :c:func:`vsnprintf` C lib APIs. In "
"contrast to the standard :c:func:`sprintf` and :c:func:`vsprintf` functions, "
"the Python versions check the bounds of the buffer used to protect against "
"buffer overruns. (Contributed by M.-A. Lemburg.)"
msgstr ""
"Дві нові функції оболонки, :c:func:`PyOS_snprintf` і :c:func:"
"`PyOS_vsnprintf`, були додані, щоб забезпечити кросплатформену реалізацію "
"відносно нових :c:func:`snprintf` і :c:func:`vsnprintf` API C lib. На "
"відміну від стандартних функцій :c:func:`sprintf` і :c:func:`vsprintf`, "
"версії Python перевіряють межі буфера, який використовується для захисту від "
"переповнення буфера. (Уклав М.-А. Лембург.)"

msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
"Функція :c:func:`_PyTuple_Resize` втратила невикористаний параметр, тому "
"тепер вона приймає 2 параметри замість 3. Третій аргумент ніколи не "
"використовувався, і його можна просто відкинути під час перенесення коду з "
"попередніх версій на Python 2.2."

msgid "Other Changes and Fixes"
msgstr "Інші зміни та виправлення"

msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches "
"and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"Як завжди, було багато інших покращень і виправлень помилок, розкиданих по "
"дереву вихідних кодів. Пошук у журналах змін CVS виявив, що було застосовано "
"527 патчів і 683 виправлені помилки між Python 2.1 і 2.2; 2.2.1 застосовано "
"139 патчів і виправлено 143 помилки; 2.2.2 застосовано 106 патчів і "
"виправлено 82 помилки. Ймовірно, ці цифри занижені."

msgid "Some of the more notable changes are:"
msgstr "Деякі з найбільш помітних змін:"

msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support "
"MacOS X."
msgstr ""
"Код порту MacOS для Python, який підтримує Джек Янсен, тепер зберігається в "
"основному дереві Python CVS, і внесено багато змін для підтримки MacOS X."

msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this "
"(actually, there is the disadvantage that you have to change your PATH to be "
"able to find Python), but it is the basis for creating a full-blown Python "
"application, porting the MacPython IDE, possibly using Python as a standard "
"OSA scripting language and much more.\""
msgstr ""
"Найсуттєвішою зміною є можливість створювати Python як фреймворк, увімкнений "
"шляхом надання опції :option:`!--enable-framework` до сценарію конфігурації "
"під час компіляції Python. За словами Джека Янсена, \"це встановлює "
"самодостатню інсталяцію Python, а також фреймворк OS X \"клей\" у :file:`/"
"Library/Frameworks/Python.framework` (або в інше розташування). це додаткова "
"перевага (насправді, є недолік, що вам потрібно змінити свій ШЛЯХ, щоб мати "
"змогу знайти Python), але це основа для створення повномасштабної програми "
"Python, портування MacPython IDE, можливо, використання Python як стандартна "
"мова сценаріїв OSA та багато іншого\"."

msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as "
"windowing, QuickTime, scripting, etc. have been ported to OS X, but they've "
"been left commented out in :file:`setup.py`.  People who want to experiment "
"with these modules can uncomment them manually."
msgstr ""
"Більшість модулів панелі інструментів MacPython, які взаємодіють з API "
"MacOS, такими як вікна, QuickTime, сценарії тощо, було перенесено в OS X, "
"але вони залишилися прокоментованими в :file:`setup.py`. Люди, які хочуть "
"поекспериментувати з цими модулями, можуть розкоментувати їх вручну."

msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"Аргументи ключових слів, передані вбудованим функціям, які зараз їх не "
"приймають, викликають виняток :exc:`TypeError` із повідомленням \"*функція* "
"не приймає аргументів ключового слова\"."

msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of "
"the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the :mod:"
"`weakref` module to become a built-in exception."
msgstr ""
"Слабкі посилання, додані в Python 2.1 як модуль розширення, тепер є частиною "
"ядра, оскільки вони використовуються в реалізації класів нового стилю. Тому "
"виняток :exc:`ReferenceError` переміщено з модуля :mod:`weakref` і став "
"вбудованим винятком."

msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"Новий скрипт, :file:`Tools/scripts/cleanfuture.py` Тіма Пітерса, автоматично "
"видаляє застарілі оператори ``__future__`` з вихідного коду Python."

msgid ""
"An additional *flags* argument has been added to the built-in function :func:"
"`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"Додатковий аргумент *flags* було додано до вбудованої функції :func:"
"`compile`, тому поведінку операторів ``__future__`` тепер можна правильно "
"спостерігати в змодельованих оболонках, таких як представлені IDLE та інші "
"розробки середовищ. Це описано в :pep:`264`. (Надав Майкл Хадсон.)"

msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to "
"embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Нова ліцензія, представлена разом із Python 1.6, не була сумісною з GPL. Це "
"виправлено деякими незначними текстовими змінами в ліцензії 2.2, тому тепер "
"можна знову вставляти Python у програму GPL. Зауважте, що сам Python не "
"підпадає під ліцензію GPL, а натомість діє під ліцензією, яка, по суті, "
"еквівалентна ліцензії BSD, як і було завжди. Зміни ліцензії також було "
"застосовано до випусків Python 2.0.1 і 2.1.1."

msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default "
"encoding turns out to be an annoyance.  On Unix, the locale's character set "
"is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"Коли в Windows надається ім’я файлу Unicode, Python тепер перетворює його на "
"рядок у кодуванні MBCS, який використовується файловими API Microsoft. "
"Оскільки MBCS явно використовується файловими API, вибір Python ASCII як "
"кодування за замовчуванням виявляється неприємним. В Unix набір символів "
"локалі використовується, якщо доступний ``locale.nl_langinfo(CODESET)``. "
"(Підтримку Windows надав Марк Хаммонд за підтримки Марка-Андре Лембурга. "
"Підтримку Unix додав Мартін фон Льовіс.)"

msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr ""
"Підтримка великих файлів тепер увімкнена в Windows. (Надав Тім Пітерс.)"

msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
"Сценарій :file:`Tools/scripts/ftpmirror.py` тепер аналізує файл :file:`."
"netrc`, якщо він у вас є. (Надав Майк Ромберг.)"

msgid ""
"Some features of the object returned by the :func:`xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in "
"Python 2.3. :class:`xrange` objects tried to pretend they were full sequence "
"types by supporting slicing, sequence multiplication, and the :keyword:`in` "
"operator, but these features were rarely used and therefore buggy.  The :"
"meth:`tolist` method and the :attr:`start`, :attr:`stop`, and :attr:`step` "
"attributes are also being deprecated.  At the C level, the fourth argument "
"to the :c:func:`PyRange_New` function, ``repeat``, has also been deprecated."
msgstr ""
"Деякі функції об’єкта, що повертаються функцією :func:`xrange`, тепер "
"застаріли та викликають попередження під час доступу до них; вони зникнуть у "
"Python 2.3. Об’єкти :class:`xrange` намагалися вдавати, що вони є типами "
"повної послідовності, підтримуючи нарізку, множення послідовності та "
"оператор :keyword:`in`, але ці функції рідко використовувалися і, отже, мали "
"помилки. Метод :meth:`tolist` і атрибути :attr:`start`, :attr:`stop` і :attr:"
"`step` також застаріли. На рівні C четвертий аргумент функції :c:func:"
"`PyRange_New`, ``repeat``, також застарів."

msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a "
"case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"Була купа патчів до реалізації словника, здебільшого для виправлення "
"потенційних дампів ядра, якщо словник містить об’єкти, які потайки змінили "
"своє хеш-значення або видозмінили словник, у якому вони містилися. На деякий "
"час python-dev впав у м’який ритм Майкл Хадсон знайшов випадок, який викидав "
"ядро, Тім Пітерс виправив помилку, Майкл знайшов інший випадок, і все пішло "
"кругом."

msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"У Windows Python тепер можна скомпілювати за допомогою Borland C завдяки "
"ряду патчів, внесених Стівеном Хансеном, хоча результат ще не повністю "
"функціональний. (Але це *це* прогрес...)"

msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"Ще одне вдосконалення Windows: компанія Wise Solutions щедро запропонувала "
"PythonLabs використовувати їхню систему InstallerMaster 8.1. Раніше "
"інсталятори PythonLabs для Windows використовували Wise 5.0a, який почав "
"показувати свій вік. (Упакував Тім Пітерс.)"

msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David "
"Bolen.)"
msgstr ""
"Файли із закінченням ``.pyw`` тепер можна імпортувати в Windows. ``.pyw`` — "
"це лише річ для Windows, яка використовується для вказівки на те, що "
"сценарій потрібно запустити за допомогою PYTHONW.EXE замість PYTHON.EXE, щоб "
"запобігти появі консолі DOS для відображення результату. Цей патч дає змогу "
"імпортувати такі сценарії, якщо їх також можна використовувати як модулі. "
"(Реалізовано Девідом Боленом.)"

msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by :c:func:"
"`dlopen` using the :func:`sys.getdlopenflags` and :func:`sys.setdlopenflags` "
"functions. (Contributed by Bram Stolk.)"
msgstr ""
"На платформах, де Python використовує функцію C :c:func:`dlopen` для "
"завантаження модулів розширення, тепер можна встановити прапорці, які "
"використовує :c:func:`dlopen` за допомогою :func:`sys.getdlopenflags` і :"
"func:`sys.setdlopenflags` функції. (Надано Бремом Столком.)"

msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
"Вбудована функція :func:`pow` більше не підтримує 3 аргументи, коли "
"надаються числа з плаваючою комою. ``pow(x, y, z)`` повертає ``(x**y) % z``, "
"але це ніколи не корисно для чисел з плаваючою комою, і кінцевий результат "
"непередбачувано змінюється залежно від платформи. Такий виклик, як "
"``pow(2.0, 8.0, 7.0)``, тепер викличе виняток :exc:`TypeError`."

msgid "Acknowledgements"
msgstr "Подяки"

msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack "
"Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, "
"Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van "
"Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"Автор хотів би подякувати наступним особам за пропозиції, виправлення та "
"допомогу з різними чернетками цієї статті: Фред Бреммер, Кіт Бріггс, Ендрю "
"Далк, Фред Л. Дрейк молодший, Карел Феллінгер, Девід Гуджер, Марк Хаммонд, "
"Стівен Хансен, Майкл Хадсон, Джек Янсен, Марк-Андре Лембург, Мартін фон "
"Левіс, Фредрік Лунд, Майкл МакЛей, Нік Метьюсон, Пол Мур, Густаво Німейєр, "
"Дон О'Доннелл, Йоонас Пааласма, Тім Пітерс, Йенс Куейд, Том Рейнхардт, Ніл "
"Шеменауер, Гвідо ван Россум, Грег Уорд, Едвард Велборн."
