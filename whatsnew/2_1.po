# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-22 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../whatsnew/2.1.rst:3
msgid "What's New in Python 2.1"
msgstr "Що нового в Python 2.1"

#: ../../whatsnew/2.1.rst:0
msgid "Author"
msgstr "Автор"

#: ../../whatsnew/2.1.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.1.rst:13
msgid "Introduction"
msgstr "вступ"

#: ../../whatsnew/2.1.rst:15
msgid ""
"This article explains the new features in Python 2.1.  While there aren't as"
" many changes in 2.1 as there were in Python 2.0, there are still some "
"pleasant surprises in store.  2.1 is the first release to be steered through"
" the use of Python Enhancement Proposals, or PEPs, so most of the sizable "
"changes have accompanying PEPs that provide more complete documentation and "
"a design rationale for the change.  This article doesn't attempt to document"
" the new features completely, but simply provides an overview of the new "
"features for Python programmers. Refer to the Python 2.1 documentation, or "
"to the specific PEP, for more details about any new feature that "
"particularly interests you."
msgstr ""
"У цій статті пояснюються нові функції Python 2.1. Хоча у версії 2.1 не так "
"багато змін, як у Python 2.0, все ж є деякі приємні сюрпризи. 2.1 є першим "
"випуском, який керується використанням Python Enhancement Proposals або PEP,"
" тому більшість значних змін супроводжуються PEP, які надають більш повну "
"документацію та обґрунтування зміни. Ця стаття не намагається повністю "
"задокументувати нові функції, а просто надає огляд нових функцій для "
"програмістів Python. Зверніться до документації Python 2.1 або до "
"конкретного PEP, щоб дізнатися більше про будь-яку нову функцію, яка вас "
"особливо цікавить."

#: ../../whatsnew/2.1.rst:25
msgid ""
"One recent goal of the Python development team has been to accelerate the "
"pace of new releases, with a new release coming every 6 to 9 months. 2.1 is "
"the first release to come out at this faster pace, with the first alpha "
"appearing in January, 3 months after the final version of 2.0 was released."
msgstr ""
"Одна з нещодавніх цілей команди розробників Python полягала в тому, щоб "
"пришвидшити темп випуску нових випусків, причому новий випуск виходить кожні"
" 6-9 місяців. 2.1 є першим випуском, який вийшов таким швидким темпом, з "
"першою альфа-версією, яка з’явилася в січні, через 3 місяці після виходу "
"остаточної версії 2.0."

#: ../../whatsnew/2.1.rst:30
msgid "The final release of Python 2.1 was made on April 17, 2001."
msgstr "Остаточний випуск Python 2.1 був зроблений 17 квітня 2001 року."

#: ../../whatsnew/2.1.rst:36
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: Вкладені області"

#: ../../whatsnew/2.1.rst:38
msgid ""
"The largest change in Python 2.1 is to Python's scoping rules.  In Python "
"2.0, at any given time there are at most three namespaces used to look up "
"variable names: local, module-level, and the built-in namespace.  This often"
" surprised people because it didn't match their intuitive expectations.  For"
" example, a nested recursive function definition doesn't work::"
msgstr ""
"Найбільша зміна в Python 2.1 стосується правил визначення області видимості "
"Python. У Python 2.0 у будь-який момент часу існує щонайбільше три простори "
"імен, які використовуються для пошуку імен змінних: локальний, на рівні "
"модуля та вбудований простір імен. Це часто дивувало людей, оскільки не "
"відповідало їхнім інтуїтивним очікуванням. Наприклад, визначення вкладеної "
"рекурсивної функції не працює:"

#: ../../whatsnew/2.1.rst:44
msgid ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."
msgstr ""

#: ../../whatsnew/2.1.rst:51
msgid ""
"The function :func:`!g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or"
" in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was"
" a problem in practice. In code which uses :keyword:`lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""

#: ../../whatsnew/2.1.rst:59
msgid ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"
msgstr ""

#: ../../whatsnew/2.1.rst:65
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr ""
"У результаті цього значно погіршується читабельність коду Python, написаного"
" у сильно функціональному стилі."

#: ../../whatsnew/2.1.rst:68
msgid ""
"The most significant change to Python 2.1 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put"
" simply, when a given variable name is not assigned a value within a "
"function (by an assignment, or the :keyword:`def`, :keyword:`class`, or "
":keyword:`import` statements), references to the variable will be looked up "
"in the local namespace of the enclosing scope.  A more detailed explanation "
"of the rules, and a dissection of the implementation, can be found in the "
"PEP."
msgstr ""
"Найсуттєвіша зміна Python 2.1 полягає в тому, що для вирішення цієї проблеми"
" до мови додано статичне визначення області видимості. Як перший ефект, "
"аргумент за замовчуванням ``name=name`` тепер непотрібний у наведеному вище "
"прикладі. Простіше кажучи, коли заданому імені змінної не присвоєно значення"
" у функції (за допомогою призначення або операторів :keyword:`def`, "
":keyword:`class` або :keyword:`import`), посилання на змінна буде шукатися в"
" локальному просторі імен охоплюючої області. Більш детальне пояснення "
"правил і опис реалізації можна знайти в PEP."

#: ../../whatsnew/2.1.rst:77
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"Ця зміна може спричинити деякі проблеми сумісності для коду, де те саме ім’я"
" змінної використовується як на рівні модуля, так і як локальна змінна у "
"функції, яка містить додаткові визначення функцій. Це здається "
"малоймовірним, оскільки такий код було б досить заплутаним для читання."

#: ../../whatsnew/2.1.rst:83
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the"
" CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into"
" bytecodes has to generate different code to access variables in a "
"containing scope.  ``from module import *`` and ``exec`` make it impossible "
"for the compiler to figure this out, because they add names to the local "
"namespace that are unknowable at compile time. Therefore, if a function "
"contains function definitions or :keyword:`lambda` expressions with free "
"variables, the compiler will flag this by raising a :exc:`SyntaxError` "
"exception."
msgstr ""
"Одним із побічних ефектів змін є те, що оператори ``from module import *`` і"
" ``exec`` були зроблені незаконними в межах функції за певних умов. У "
"довідковому посібнику Python весь час говорилося, що ``from module import "
"*`` допустимо лише на верхньому рівні модуля, але інтерпретатор CPython "
"ніколи раніше не виконував цього. Як частина реалізації вкладених областей, "
"компілятор, який перетворює джерело Python на байт-коди, має згенерувати "
"інший код для доступу до змінних у місткій області. ``from module import *``"
" і ``exec`` не дозволяють компілятору це зрозуміти, оскільки вони додають "
"імена до локального простору імен, які невідомі під час компіляції. Таким "
"чином, якщо функція містить визначення функції або :keyword:`lambda` вирази "
"з вільними змінними, компілятор позначить це, викликавши виняток "
":exc:`SyntaxError`."

#: ../../whatsnew/2.1.rst:96
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "Щоб зробити попереднє пояснення трохи зрозумілішим, ось приклад::"

#: ../../whatsnew/2.1.rst:98
msgid ""
"x = 1\n"
"def f():\n"
"    # The next line is a syntax error\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"
msgstr ""

#: ../../whatsnew/2.1.rst:105
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed"
" by :func:`!g`."
msgstr ""

#: ../../whatsnew/2.1.rst:109
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"Це не повинно бути великим обмеженням, оскільки ``exec`` рідко "
"використовується в більшості коду Python (і коли він використовується, це "
"часто свідчить про поганий дизайн)."

#: ../../whatsnew/2.1.rst:113
msgid ""
"Compatibility concerns have led to nested scopes being introduced gradually;"
" in Python 2.1, they aren't enabled by default, but can be turned on within "
"a module by using a future statement as described in :pep:`236`.  (See the "
"following section for further discussion of :pep:`236`.)  In Python 2.2, "
"nested scopes will become the default and there will be no way to turn them "
"off, but users will have had all of 2.1's lifetime to fix any breakage "
"resulting from their introduction."
msgstr ""
"Занепокоєння щодо сумісності призвело до поступового впровадження вкладених "
"областей; у Python 2.1 вони не ввімкнені за замовчуванням, але їх можна "
"ввімкнути в модулі за допомогою оператора future, як описано в :pep:`236`. "
"(Див. наступний розділ для подальшого обговорення :pep:`236`.) У Python 2.2 "
"вкладені області стануть типовими, і не буде можливості їх вимкнути, але "
"користувачі матимуть весь час життя 2.1, щоб усунути будь-яку поломку "
"внаслідок їх введення."

#: ../../whatsnew/2.1.rst:123
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - Статично вкладені області"

#: ../../whatsnew/2.1.rst:124
msgid "Written and implemented by Jeremy Hylton."
msgstr "Написаний і реалізований Джеремі Гілтоном."

#: ../../whatsnew/2.1.rst:130
msgid "PEP 236: __future__ Directives"
msgstr "PEP 236: директиви __future__"

#: ../../whatsnew/2.1.rst:132
msgid ""
"The reaction to nested scopes was widespread concern about the dangers of "
"breaking code with the 2.1 release, and it was strong enough to make the "
"Pythoneers take a more conservative approach.  This approach consists of "
"introducing a convention for enabling optional functionality in release N "
"that will become compulsory in release N+1."
msgstr ""
"Реакцією на вкладені області було широко поширене занепокоєння щодо "
"небезпеки злому коду з випуском 2.1, і воно було досить сильним, щоб змусити"
" Pythoneers застосувати більш консервативний підхід. Цей підхід полягає у "
"введенні угоди про ввімкнення додаткової функціональності у випуску N, який "
"стане обов’язковим у випуску N+1."

#: ../../whatsnew/2.1.rst:138
msgid ""
"The syntax uses a ``from...import`` statement using the reserved module name"
" :mod:`__future__`.  Nested scopes can be enabled by the following "
"statement::"
msgstr ""
"Синтаксис використовує оператор ``from...import`` із використанням "
"зарезервованої назви модуля :mod:`__future__`. Вкладені області можна "
"активувати наступним оператором::"

#: ../../whatsnew/2.1.rst:141
msgid "from __future__ import nested_scopes"
msgstr ""

#: ../../whatsnew/2.1.rst:143
msgid ""
"While it looks like a normal :keyword:`import` statement, it's not; there "
"are strict rules on where such a future statement can be put. They can only "
"be at the top of a module, and must precede any Python code or regular "
":keyword:`!import` statements.  This is because such statements can affect "
"how the Python bytecode compiler parses code and generates bytecode, so they"
" must precede any statement that will result in bytecodes being produced."
msgstr ""
"Хоча це виглядає як звичайний оператор :keyword:`import`, це не так; існують"
" суворі правила щодо того, де можна розмістити таку майбутню заяву. Вони "
"можуть бути лише у верхній частині модуля та повинні передувати будь-якому "
"коду Python або звичайним операторам :keyword:`!import`. Це тому, що такі "
"оператори можуть впливати на те, як компілятор байт-коду Python аналізує код"
" і генерує байт-код, тому вони повинні передувати будь-якому оператору, який"
" призведе до створення байт-кодів."

#: ../../whatsnew/2.1.rst:153
msgid ":pep:`236` - Back to the :mod:`__future__`"
msgstr ":pep:`236` - Назад у :mod:`__future__`"

#: ../../whatsnew/2.1.rst:154
msgid "Written by Tim Peters, and primarily implemented by Jeremy Hylton."
msgstr ""
"Написаний Тімом Пітерсом, а в основному реалізований Джеремі Гілтоном."

#: ../../whatsnew/2.1.rst:160
msgid "PEP 207: Rich Comparisons"
msgstr "PEP 207: багаті порівняння"

#: ../../whatsnew/2.1.rst:162
msgid ""
"In earlier versions, Python's support for implementing comparisons on user-"
"defined classes and extension types was quite simple. Classes could "
"implement a :meth:`!__cmp__` method that was given two instances of a class,"
" and could only return 0 if they were equal or +1 or -1 if they weren't; the"
" method couldn't raise an exception or return anything other than a Boolean "
"value.  Users of Numeric Python often found this model too weak and "
"restrictive, because in the number-crunching programs that numeric Python is"
" used for, it would be more useful to be able to perform elementwise "
"comparisons of two matrices, returning a matrix containing the results of a "
"given comparison for each element.  If the two matrices are of different "
"sizes, then the compare has to be able to raise an exception to signal the "
"error."
msgstr ""

#: ../../whatsnew/2.1.rst:174
msgid ""
"In Python 2.1, rich comparisons were added in order to support this need. "
"Python classes can now individually overload each of the ``<``, ``<=``, "
"``>``, ``>=``, ``==``, and ``!=`` operations.  The new magic method names "
"are:"
msgstr ""
"У Python 2.1 для підтримки цієї потреби було додано розширені порівняння. "
"Класи Python тепер можуть окремо перевантажувати кожну з операцій ``<``, "
"``<=``, ``>``, ``>=``, ``==`` і ``!=``. Назви нових магічних методів:"

#: ../../whatsnew/2.1.rst:179
msgid "Operation"
msgstr "Операція"

#: ../../whatsnew/2.1.rst:179
msgid "Method name"
msgstr "Назва методу"

#: ../../whatsnew/2.1.rst:181
msgid "``<``"
msgstr "``<``"

#: ../../whatsnew/2.1.rst:181
msgid ":meth:`~object.__lt__`"
msgstr ""

#: ../../whatsnew/2.1.rst:183
msgid "``<=``"
msgstr "``<=``"

#: ../../whatsnew/2.1.rst:183
msgid ":meth:`~object.__le__`"
msgstr ""

#: ../../whatsnew/2.1.rst:185
msgid "``>``"
msgstr "``>``"

#: ../../whatsnew/2.1.rst:185
msgid ":meth:`~object.__gt__`"
msgstr ""

#: ../../whatsnew/2.1.rst:187
msgid "``>=``"
msgstr "``>=``"

#: ../../whatsnew/2.1.rst:187
msgid ":meth:`~object.__ge__`"
msgstr ""

#: ../../whatsnew/2.1.rst:189
msgid "``==``"
msgstr "``==``"

#: ../../whatsnew/2.1.rst:189
msgid ":meth:`~object.__eq__`"
msgstr ""

#: ../../whatsnew/2.1.rst:191
msgid "``!=``"
msgstr "``!=``"

#: ../../whatsnew/2.1.rst:191
msgid ":meth:`~object.__ne__`"
msgstr ""

#: ../../whatsnew/2.1.rst:194
msgid ""
"(The magic methods are named after the corresponding Fortran operators "
"``.LT.``. ``.LE.``, &c.  Numeric programmers are almost certainly quite "
"familiar with these names and will find them easy to remember.)"
msgstr ""
"(Чарівні методи названо на честь відповідних операторів Fortran ``.LT.``. "
"``.LE.`` тощо. Цифрові програмісти майже напевно добре знайомі з цими "
"назвами та легко їх запам’ятають.)"

#: ../../whatsnew/2.1.rst:198
msgid ""
"Each of these magic methods is of the form ``method(self, other)``, where "
"``self`` will be the object on the left-hand side of the operator, while "
"``other`` will be the object on the right-hand side.  For example, the "
"expression ``A < B`` will cause ``A.__lt__(B)`` to be called."
msgstr ""
"Кожен із цих чарівних методів має форму ``method(self, other)``, де ``self``"
" буде об’єктом ліворуч від оператора, а ``other`` буде об’єктом з правого "
"боку. Наприклад, вираз ``A < B`` призведе до виклику ``A.__lt__(B)``."

#: ../../whatsnew/2.1.rst:203
msgid ""
"Each of these magic methods can return anything at all: a Boolean, a matrix,"
" a list, or any other Python object.  Alternatively they can raise an "
"exception if the comparison is impossible, inconsistent, or otherwise "
"meaningless."
msgstr ""
"Кожен із цих магічних методів може повернути будь-що: логічне значення, "
"матрицю, список або будь-який інший об’єкт Python. Крім того, вони можуть "
"викликати виняток, якщо порівняння є неможливим, непослідовним або іншим "
"чином безглуздим."

#: ../../whatsnew/2.1.rst:207
msgid ""
"The built-in ``cmp(A,B)`` function can use the rich comparison machinery, "
"and now accepts an optional argument specifying which comparison operation "
"to use; this is given as one of the strings ``\"<\"``, ``\"<=\"``, "
"``\">\"``, ``\">=\"``, ``\"==\"``, or ``\"!=\"``.  If called without the "
"optional third argument, :func:`!cmp` will only return -1, 0, or +1 as in "
"previous versions of Python; otherwise it will call the appropriate method "
"and can return any Python object."
msgstr ""

#: ../../whatsnew/2.1.rst:214
msgid ""
"There are also corresponding changes of interest to C programmers; there's a"
" new slot ``tp_richcmp`` in type objects and an API for performing a given "
"rich comparison.  I won't cover the C API here, but will refer you to "
":pep:`207`, or to 2.1's C API documentation, for the full list of related "
"functions."
msgstr ""
"Є також відповідні зміни, які цікавлять програмістів на C; є новий слот "
"``tp_richcmp`` в об’єктах типу та API для виконання певного розширеного "
"порівняння. Я не буду тут розповідати про C API, але відсилаю вас до "
":pep:`207` або до документації C API 2.1, щоб отримати повний список "
"пов’язаних функцій."

#: ../../whatsnew/2.1.rst:222
msgid ":pep:`207` - Rich Comparisons"
msgstr ":pep:`207` - багаті порівняння"

#: ../../whatsnew/2.1.rst:223
msgid ""
"Written by Guido van Rossum, heavily based on earlier work by David Ascher, "
"and implemented by Guido van Rossum."
msgstr ""
"Написаний Гвідо ван Россумом, значною мірою заснований на попередніх роботах"
" Девіда Ашера та реалізований Гвідо ван Россумом."

#: ../../whatsnew/2.1.rst:230
msgid "PEP 230: Warning Framework"
msgstr "PEP 230: Попередження"

#: ../../whatsnew/2.1.rst:232
msgid ""
"Over its 10 years of existence, Python has accumulated a certain number of "
"obsolete modules and features along the way.  It's difficult to know when a "
"feature is safe to remove, since there's no way of knowing how much code "
"uses it --- perhaps no programs depend on the feature, or perhaps many do.  "
"To enable removing old features in a more structured way, a warning "
"framework was added. When the Python developers want to get rid of a "
"feature, it will first trigger a warning in the next version of Python.  The"
" following Python version can then drop the feature, and users will have had"
" a full release cycle to remove uses of the old feature."
msgstr ""
"За 10 років існування Python накопичив певну кількість застарілих модулів і "
"функцій. Важко визначити, коли функцію безпечно видалити, оскільки неможливо"
" дізнатися, скільки коду її використовує --- можливо, жодна програма не "
"залежить від функції, або, можливо, багато хто залежить від цієї функції. "
"Щоб уможливити видалення старих функцій у більш структурований спосіб, було "
"додано рамку попереджень. Коли розробники Python хочуть позбутися функції, "
"це спочатку викличе попередження в наступній версії Python. Наступна версія "
"Python може відмовитися від цієї функції, і користувачі матимуть повний цикл"
" випуску, щоб усунути використання старої функції."

#: ../../whatsnew/2.1.rst:242
msgid ""
"Python 2.1 adds the warning framework to be used in this scheme.  It adds a "
":mod:`warnings` module that provide functions to issue warnings, and to "
"filter out warnings that you don't want to be displayed. Third-party modules"
" can also use this framework to deprecate old features that they no longer "
"wish to support."
msgstr ""
"Python 2.1 додає структуру попереджень для використання в цій схемі. Він "
"додає модуль :mod:`warnings`, який надає функції для видачі попереджень і "
"для фільтрації попереджень, які ви не бажаєте відображати. Сторонні модулі "
"також можуть використовувати цю структуру, щоб відмовитися від старих "
"функцій, які вони більше не хочуть підтримувати."

#: ../../whatsnew/2.1.rst:248
msgid ""
"For example, in Python 2.1 the :mod:`!regex` module is deprecated, so "
"importing it causes a warning to be printed::"
msgstr ""

#: ../../whatsnew/2.1.rst:251
msgid ""
">>> import regex\n"
"__main__:1: DeprecationWarning: the regex module\n"
"         is deprecated; please use the re module\n"
">>>"
msgstr ""

#: ../../whatsnew/2.1.rst:256
msgid "Warnings can be issued by calling the :func:`warnings.warn` function::"
msgstr "Попередження можна видати, викликавши функцію :func:`warnings.warn`::"

#: ../../whatsnew/2.1.rst:258
msgid "warnings.warn(\"feature X no longer supported\")"
msgstr ""

#: ../../whatsnew/2.1.rst:260
msgid ""
"The first parameter is the warning message; an additional optional "
"parameters can be used to specify a particular warning category."
msgstr ""
"Перший параметр – це попереджувальне повідомлення; додаткові необов'язкові "
"параметри можуть використовуватися для визначення певної категорії "
"попередження."

#: ../../whatsnew/2.1.rst:263
msgid ""
"Filters can be added to disable certain warnings; a regular expression "
"pattern can be applied to the message or to the module name in order to "
"suppress a warning.  For example, you may have a program that uses the "
":mod:`!regex` module and not want to spare the time to convert it to use the"
" :mod:`re` module right now.  The warning can be suppressed by calling ::"
msgstr ""

#: ../../whatsnew/2.1.rst:269
msgid ""
"import warnings\n"
"warnings.filterwarnings(action = 'ignore',\n"
"                        message='.*regex module is deprecated',\n"
"                        category=DeprecationWarning,\n"
"                        module = '__main__')"
msgstr ""

#: ../../whatsnew/2.1.rst:275
msgid ""
"This adds a filter that will apply only to warnings of the class "
":class:`DeprecationWarning` triggered in the :mod:`__main__` module, and "
"applies a regular expression to only match the message about the "
":mod:`!regex` module being deprecated, and will cause such warnings to be "
"ignored.  Warnings can also be printed only once, printed every time the "
"offending code is executed, or turned into exceptions that will cause the "
"program to stop (unless the exceptions are caught in the usual way, of "
"course)."
msgstr ""

#: ../../whatsnew/2.1.rst:283
msgid ""
"Functions were also added to Python's C API for issuing warnings; refer to "
"PEP 230 or to Python's API documentation for the details."
msgstr ""
"До API C Python також додано функції для видачі попереджень; подробиці "
"зверніться до PEP 230 або до документації Python API."

#: ../../whatsnew/2.1.rst:289
msgid ":pep:`5` - Guidelines for Language Evolution"
msgstr ":pep:`5` - Рекомендації щодо розвитку мови"

#: ../../whatsnew/2.1.rst:290
msgid ""
"Written by Paul Prescod, to specify procedures to be followed when removing "
"old features from Python.  The policy described in this PEP hasn't been "
"officially adopted, but the eventual policy probably won't be too different "
"from Prescod's proposal."
msgstr ""
"Написав Пол Прескод, щоб визначити процедури, яких слід дотримуватися під "
"час видалення старих функцій з Python. Політика, описана в цьому PEP, не "
"була офіційно прийнята, але остаточна політика, ймовірно, не надто "
"відрізнятиметься від пропозиції Prescod."

#: ../../whatsnew/2.1.rst:295
msgid ":pep:`230` - Warning Framework"
msgstr ":pep:`230` - Рамка попереджень"

#: ../../whatsnew/2.1.rst:296
msgid "Written and implemented by Guido van Rossum."
msgstr "Написаний і реалізований Гвідо ван Россумом."

#: ../../whatsnew/2.1.rst:302
msgid "PEP 229: New Build System"
msgstr "PEP 229: Нова система побудови"

#: ../../whatsnew/2.1.rst:304
msgid ""
"When compiling Python, the user had to go in and edit the "
":file:`Modules/Setup` file in order to enable various additional modules; "
"the default set is relatively small and limited to modules that compile on "
"most Unix platforms. This means that on Unix platforms with many more "
"features, most notably Linux, Python installations often don't contain all "
"useful modules they could."
msgstr ""
"Під час компіляції Python користувач мав зайти та відредагувати файл "
":file:`Modules/Setup`, щоб увімкнути різні додаткові модулі; стандартний "
"набір відносно малий і обмежений модулями, які компілюються на більшості "
"платформ Unix. Це означає, що на платформах Unix із набагато більшою "
"кількістю можливостей, особливо Linux, встановлення Python часто не містять "
"усіх корисних модулів, які могли б."

#: ../../whatsnew/2.1.rst:310
msgid ""
"Python 2.0 added the Distutils, a set of modules for distributing and "
"installing extensions.  In Python 2.1, the Distutils are used to compile "
"much of the standard library of extension modules, autodetecting which ones "
"are supported on the current machine.  It's hoped that this will make Python"
" installations easier and more featureful."
msgstr ""
"Python 2.0 додав Distutils, набір модулів для розповсюдження та встановлення"
" розширень. У Python 2.1 Distutils використовуються для компіляції більшої "
"частини стандартної бібліотеки модулів розширення, автоматично визначаючи, "
"які з них підтримуються на поточній машині. Є надія, що це зробить "
"інсталяцію Python простішою та функціональнішою."

#: ../../whatsnew/2.1.rst:316
msgid ""
"Instead of having to edit the :file:`Modules/Setup` file in order to enable "
"modules, a :file:`setup.py` script in the top directory of the Python source"
" distribution is run at build time, and attempts to discover which modules "
"can be enabled by examining the modules and header files on the system.  If "
"a module is configured in :file:`Modules/Setup`, the :file:`setup.py` script"
" won't attempt to compile that module and will defer to the "
":file:`Modules/Setup` file's contents.  This provides a way to specific any "
"strange command-line flags or libraries that are required for a specific "
"platform."
msgstr ""
"Замість того, щоб редагувати файл :file:`Modules/Setup`, щоб увімкнути "
"модулі, сценарій :file:`setup.py` у верхньому каталозі дистрибутива "
"вихідного коду Python запускається під час збирання та намагається виявити "
"які модулі можна ввімкнути, перевіривши модулі та файли заголовків у "
"системі. Якщо модуль налаштовано в :file:`Modules/Setup`, сценарій "
":file:`setup.py` не намагатиметься скомпілювати цей модуль і звернеться до "
"вмісту файлу :file:`Modules/Setup`. Це надає спосіб визначити будь-які дивні"
" прапори командного рядка або бібліотеки, які потрібні для певної платформи."

#: ../../whatsnew/2.1.rst:325
msgid ""
"In another far-reaching change to the build mechanism, Neil Schemenauer "
"restructured things so Python now uses a single makefile that isn't "
"recursive, instead of makefiles in the top directory and in each of the "
":file:`Python/`, :file:`Parser/`, :file:`Objects/`, and :file:`Modules/` "
"subdirectories.  This makes building Python faster and also makes hacking "
"the Makefiles clearer and simpler."
msgstr ""
"В іншій далекосяжній зміні механізму збірки Ніл Шеменауер змінив структуру "
"так, що Python тепер використовує єдиний make-файл, який не є рекурсивним, "
"замість make-файлів у верхньому каталозі та в кожному Підкаталоги з "
":file:`Python/`, :file:`Parser/`, :file:`Objects/` і :file:`Modules/`. Це "
"робить створення Python швидшим, а також робить злам Makefiles зрозумілішим "
"і простішим."

#: ../../whatsnew/2.1.rst:335
msgid ":pep:`229` - Using Distutils to Build Python"
msgstr ":pep:`229` - Використання Distutils для створення Python"

#: ../../whatsnew/2.1.rst:336 ../../whatsnew/2.1.rst:575
msgid "Written and implemented by A.M. Kuchling."
msgstr "Написана та реалізована А.М. Кухлінг."

#: ../../whatsnew/2.1.rst:342
msgid "PEP 205: Weak References"
msgstr "PEP 205: Слабкі посилання"

#: ../../whatsnew/2.1.rst:344
msgid ""
"Weak references, available through the :mod:`weakref` module, are a minor "
"but useful new data type in the Python programmer's toolbox."
msgstr ""
"Слабкі посилання, доступні через модуль :mod:`weakref`, є другорядним, але "
"корисним новим типом даних у наборі інструментів програміста Python."

#: ../../whatsnew/2.1.rst:347
msgid ""
"Storing a reference to an object (say, in a dictionary or a list) has the "
"side effect of keeping that object alive forever.  There are a few specific "
"cases where this behaviour is undesirable, object caches being the most "
"common one, and another being circular references in data structures such as"
" trees."
msgstr ""
"Зберігання посилання на об’єкт (скажімо, у словнику чи списку) має побічним "
"ефектом збереження цього об’єкта назавжди. Є кілька конкретних випадків, "
"коли така поведінка є небажаною, найпоширенішим є кешування об’єктів, а "
"іншим є циклічні посилання в структурах даних, таких як дерева."

#: ../../whatsnew/2.1.rst:352
msgid ""
"For example, consider a memoizing function that caches the results of "
"another function ``f(x)`` by storing the function's argument and its result "
"in a dictionary::"
msgstr ""
"Наприклад, розглянемо функцію запам’ятовування, яка кешує результати іншої "
"функції ``f(x)``, зберігаючи аргумент функції та її результат у словнику:"

#: ../../whatsnew/2.1.rst:356
msgid ""
"_cache = {}\n"
"def memoize(x):\n"
"    if _cache.has_key(x):\n"
"        return _cache[x]\n"
"\n"
"    retval = f(x)\n"
"\n"
"    # Cache the returned object\n"
"    _cache[x] = retval\n"
"\n"
"    return retval"
msgstr ""

#: ../../whatsnew/2.1.rst:368
msgid ""
"This version works for simple things such as integers, but it has a side "
"effect; the ``_cache`` dictionary holds a reference to the return values, so"
" they'll never be deallocated until the Python process exits and cleans up. "
"This isn't very noticeable for integers, but if :func:`!f` returns an "
"object, or a data structure that takes up a lot of memory, this can be a "
"problem."
msgstr ""

#: ../../whatsnew/2.1.rst:374
msgid ""
"Weak references provide a way to implement a cache that won't keep objects "
"alive beyond their time.  If an object is only accessible through weak "
"references, the object will be deallocated and the weak references will now "
"indicate that the object it referred to no longer exists.  A weak reference "
"to an object *obj* is created by calling ``wr = weakref.ref(obj)``.  The "
"object being referred to is returned by calling the weak reference as if it "
"were a function: ``wr()``.  It will return the referenced object, or "
"``None`` if the object no longer exists."
msgstr ""
"Слабкі посилання забезпечують спосіб реалізації кешу, який не зберігатиме "
"об’єкти живими понад час. Якщо об’єкт доступний лише через слабкі посилання,"
" об’єкт буде звільнено, а слабкі посилання тепер вказуватимуть, що об’єкт, "
"на який він посилався, більше не існує. Слабке посилання на об’єкт *obj* "
"створюється шляхом виклику ``wr = weakref.ref(obj)``. Об’єкт, на який "
"посилається, повертається шляхом виклику слабкого посилання, як якщо б це "
"була функція: ``wr()``. Він поверне об’єкт, на який посилається, або "
"\"Немає\", якщо об’єкт більше не існує."

#: ../../whatsnew/2.1.rst:382
msgid ""
"This makes it possible to write a :func:`!memoize` function whose cache "
"doesn't keep objects alive, by storing weak references in the cache. ::"
msgstr ""

#: ../../whatsnew/2.1.rst:385
msgid ""
"_cache = {}\n"
"def memoize(x):\n"
"    if _cache.has_key(x):\n"
"        obj = _cache[x]()\n"
"        # If weak reference object still exists,\n"
"        # return it\n"
"        if obj is not None: return obj\n"
"\n"
"    retval = f(x)\n"
"\n"
"    # Cache a weak reference\n"
"    _cache[x] = weakref.ref(retval)\n"
"\n"
"    return retval"
msgstr ""

#: ../../whatsnew/2.1.rst:400
msgid ""
"The :mod:`weakref` module also allows creating proxy objects which behave "
"like weak references --- an object referenced only by proxy objects is "
"deallocated -- but instead of requiring an explicit call to retrieve the "
"object, the proxy transparently forwards all operations to the object as "
"long as the object still exists.  If the object is deallocated, attempting "
"to use a proxy will cause a :exc:`!weakref.ReferenceError` exception to be "
"raised. ::"
msgstr ""

#: ../../whatsnew/2.1.rst:407
msgid ""
"proxy = weakref.proxy(obj)\n"
"proxy.attr   # Equivalent to obj.attr\n"
"proxy.meth() # Equivalent to obj.meth()\n"
"del obj\n"
"proxy.attr   # raises weakref.ReferenceError"
msgstr ""

#: ../../whatsnew/2.1.rst:416
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - Слабкі посилання"

#: ../../whatsnew/2.1.rst:417
msgid "Written and implemented by Fred L. Drake, Jr."
msgstr "Написаний і реалізований Фредом Л. Дрейком-молодшим."

#: ../../whatsnew/2.1.rst:423
msgid "PEP 232: Function Attributes"
msgstr "PEP 232: Атрибути функцій"

#: ../../whatsnew/2.1.rst:425
msgid ""
"In Python 2.1, functions can now have arbitrary information attached to "
"them. People were often using docstrings to hold information about functions"
" and methods, because the :attr:`~function.__doc__` attribute was the only "
"way of attaching any information to a function.  For example, in the Zope "
"web application server, functions are marked as safe for public access by "
"having a docstring, and in John Aycock's SPARK parsing framework, docstrings"
" hold parts of the BNF grammar to be parsed.  This overloading is "
"unfortunate, since docstrings are really intended to hold a function's "
"documentation; for example, it means you can't properly document functions "
"intended for private use in Zope."
msgstr ""

#: ../../whatsnew/2.1.rst:436
msgid ""
"Arbitrary attributes can now be set and retrieved on functions using the "
"regular Python syntax::"
msgstr ""
"Довільні атрибути тепер можна встановлювати та отримувати для функцій за "
"допомогою звичайного синтаксису Python:"

#: ../../whatsnew/2.1.rst:439
msgid ""
"def f(): pass\n"
"\n"
"f.publish = 1\n"
"f.secure = 1\n"
"f.grammar = \"A ::= B (C D)*\""
msgstr ""

#: ../../whatsnew/2.1.rst:445
msgid ""
"The dictionary containing attributes can be accessed as the function's "
":attr:`~function.__dict__`. Unlike the :attr:`~type.__dict__` attribute of "
"class instances, in functions you can actually assign a new dictionary to "
":attr:`~function.__dict__`, though the new value is restricted to a regular "
"Python dictionary; you *can't* be tricky and set it to a :class:`!UserDict` "
"instance, or any other random object that behaves like a mapping."
msgstr ""

#: ../../whatsnew/2.1.rst:455
msgid ":pep:`232` - Function Attributes"
msgstr ":pep:`232` - Атрибути функції"

#: ../../whatsnew/2.1.rst:456
msgid "Written and implemented by Barry Warsaw."
msgstr "Написав і реалізував Баррі Варшау."

#: ../../whatsnew/2.1.rst:462
msgid "PEP 235: Importing Modules on Case-Insensitive Platforms"
msgstr "PEP 235: Імпорт модулів на платформах без урахування регістру"

#: ../../whatsnew/2.1.rst:464
msgid ""
"Some operating systems have filesystems that are case-insensitive, MacOS and"
" Windows being the primary examples; on these systems, it's impossible to "
"distinguish the filenames ``FILE.PY`` and ``file.py``, even though they do "
"store the file's name  in its original case (they're case-preserving, too)."
msgstr ""
"Деякі операційні системи мають файлові системи, які не чутливі до регістру, "
"MacOS і Windows є основними прикладами; у цих системах неможливо розрізнити "
"назви файлів ``FILE.PY`` і ``file.py``, навіть якщо вони зберігають назву "
"файлу в оригінальному регістрі (вони також зберігають регістр)."

#: ../../whatsnew/2.1.rst:469
msgid ""
"In Python 2.1, the :keyword:`import` statement will work to simulate case-"
"sensitivity on case-insensitive platforms.  Python will now search for the "
"first case-sensitive match by default, raising an :exc:`ImportError` if no "
"such file is found, so ``import file`` will not import a module named "
"``FILE.PY``. Case-insensitive matching can be requested by setting the "
":envvar:`PYTHONCASEOK` environment variable before starting the Python "
"interpreter."
msgstr ""
"У Python 2.1 оператор :keyword:`import` працюватиме для імітації чутливості "
"до регістру на платформах, які не чутливі до регістру. Тепер Python буде "
"шукати перший збіг з урахуванням регістру за замовчуванням, викликаючи "
":exc:`ImportError`, якщо такий файл не знайдено, тому ``import file`` не "
"імпортуватиме модуль з назвою ``FILE.PY``. Зіставлення без урахування "
"регістру можна запитати, встановивши змінну середовища "
":envvar:`PYTHONCASEOK` перед запуском інтерпретатора Python."

#: ../../whatsnew/2.1.rst:480
msgid "PEP 217: Interactive Display Hook"
msgstr "PEP 217: інтерактивний дисплей"

#: ../../whatsnew/2.1.rst:482
msgid ""
"When using the Python interpreter interactively, the output of commands is "
"displayed using the built-in :func:`repr` function. In Python 2.1, the "
"variable :func:`sys.displayhook` can be set to a callable object which will "
"be called instead of :func:`repr`. For example, you can set it to a special "
"pretty-printing function::"
msgstr ""
"Під час використання інтерпретатора Python в інтерактивному режимі вихід "
"команд відображається за допомогою вбудованої функції :func:`repr`. У Python"
" 2.1 змінна :func:`sys.displayhook` може бути встановлена на викликаний "
"об’єкт, який буде викликатися замість :func:`repr`. Наприклад, ви можете "
"встановити для нього спеціальну функцію красивого друку:"

#: ../../whatsnew/2.1.rst:488
msgid ""
">>> # Create a recursive data structure\n"
"... L = [1,2,3]\n"
">>> L.append(L)\n"
">>> L # Show Python's default output\n"
"[1, 2, 3, [...]]\n"
">>> # Use pprint.pprint() as the display function\n"
"... import sys, pprint\n"
">>> sys.displayhook = pprint.pprint\n"
">>> L\n"
"[1, 2, 3,  <Recursion on list with id=135143996>]\n"
">>>"
msgstr ""

#: ../../whatsnew/2.1.rst:503
msgid ":pep:`217` - Display Hook for Interactive Use"
msgstr ":pep:`217` - Дисплей Хук для інтерактивного використання"

#: ../../whatsnew/2.1.rst:504
msgid "Written and implemented by Moshe Zadka."
msgstr "Написав і реалізував Моше Задка."

#: ../../whatsnew/2.1.rst:510
msgid "PEP 208: New Coercion Model"
msgstr "PEP 208: Нова модель примусу"

#: ../../whatsnew/2.1.rst:512
msgid ""
"How numeric coercion is done at the C level was significantly modified.  "
"This will only affect the authors of C extensions to Python, allowing them "
"more flexibility in writing extension types that support numeric operations."
msgstr ""
"Спосіб виконання числового приведення на рівні C було значно змінено. Це "
"вплине лише на авторів розширень C для Python, надаючи їм більше гнучкості в"
" написанні типів розширень, які підтримують числові операції."

#: ../../whatsnew/2.1.rst:516
msgid ""
"Extension types can now set the type flag ``Py_TPFLAGS_CHECKTYPES`` in their"
" ``PyTypeObject`` structure to indicate that they support the new coercion "
"model. In such extension types, the numeric slot functions can no longer "
"assume that they'll be passed two arguments of the same type; instead they "
"may be passed two arguments of differing types, and can then perform their "
"own internal coercion. If the slot function is passed a type it can't "
"handle, it can indicate the failure by returning a reference to the "
"``Py_NotImplemented`` singleton value. The numeric functions of the other "
"type will then be tried, and perhaps they can handle the operation; if the "
"other type also returns ``Py_NotImplemented``, then a :exc:`TypeError` will "
"be raised.  Numeric methods written in Python can also return "
"``Py_NotImplemented``, causing the interpreter to act as if the method did "
"not exist (perhaps raising a :exc:`TypeError`, perhaps trying another "
"object's numeric methods)."
msgstr ""
"Типи розширень тепер можуть установлювати прапор типу "
"``Py_TPFLAGS_CHECKTYPES`` у своїй структурі ``PyTypeObject``, щоб вказати, "
"що вони підтримують нову модель примусу. У таких типах розширень функції "
"числового слота більше не можуть припускати, що їм будуть передані два "
"аргументи одного типу; натомість їм можуть бути передані два аргументи "
"різних типів, і потім вони можуть виконувати власний внутрішній примус. Якщо"
" функції слота передано тип, який вона не може обробити, вона може вказувати"
" на помилку, повертаючи посилання на одноэлементне значення "
"``Py_NotImplemented``. Потім буде випробувано числові функції іншого типу, "
"і, можливо, вони зможуть впоратися з операцією; якщо інший тип також "
"повертає ``Py_NotImplemented``, тоді буде викликано :exc:`TypeError`. "
"Числові методи, написані на Python, також можуть повертати "
"``Py_NotImplemented``, змушуючи інтерпретатор діяти так, ніби метод не існує"
" (можливо, викликаючи :exc:`TypeError`, можливо, намагаючись використовувати"
" числові методи іншого об’єкта)."

#: ../../whatsnew/2.1.rst:533
msgid ":pep:`208` - Reworking the Coercion Model"
msgstr ":pep:`208` - Переробка моделі примусу"

#: ../../whatsnew/2.1.rst:534
msgid ""
"Written and implemented by Neil Schemenauer, heavily based upon earlier work"
" by Marc-André Lemburg.  Read this to understand the fine points of how "
"numeric operations will now be processed at the C level."
msgstr ""
"Написаний і реалізований Нілом Шеменауером, значною мірою заснований на "
"попередніх роботах Марка-Андре Лембурга. Прочитайте це, щоб зрозуміти "
"тонкощі того, як числові операції тепер оброблятимуться на рівні C."

#: ../../whatsnew/2.1.rst:542
msgid "PEP 241: Metadata in Python Packages"
msgstr "PEP 241: Метадані в пакетах Python"

#: ../../whatsnew/2.1.rst:544
msgid ""
"A common complaint from Python users is that there's no single catalog of "
"all the Python modules in existence.  T. Middleton's Vaults of Parnassus at "
"``www.vex.net/parnassus/`` (retired in February 2009, `available in the "
"Internet Archive Wayback Machine "
"<https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/>`_)"
" was the largest catalog of Python modules, but registering software at the "
"Vaults is optional, and many people did not bother."
msgstr ""

#: ../../whatsnew/2.1.rst:552
msgid ""
"As a first small step toward fixing the problem, Python software packaged "
"using the Distutils :command:`sdist` command will include a file named "
":file:`PKG-INFO` containing information about the package such as its name, "
"version, and author (metadata, in cataloguing terminology).  :pep:`241` "
"contains the full list of fields that can be present in the :file:`PKG-INFO`"
" file.  As people began to package their software using Python 2.1, more and"
" more packages will include metadata, making it possible to build automated "
"cataloguing systems and experiment with them.  With the result experience, "
"perhaps it'll be possible to design a really good catalog and then build "
"support for it into Python 2.2. For example, the Distutils :command:`sdist` "
"and :command:`bdist_\\*` commands could support an ``upload`` option that "
"would automatically upload your package to a catalog server."
msgstr ""
"Як перший невеликий крок до вирішення проблеми, програмне забезпечення "
"Python, упаковане за допомогою команди Distutils :command:`sdist`, міститиме"
" файл під назвою :file:`PKG-INFO`, що містить інформацію про пакунок, як-от "
"його назву, версію та автора. (метадані, в термінології каталогізації). "
":pep:`241` містить повний список полів, які можуть міститися у файлі "
":file:`PKG-INFO`. Оскільки люди почали пакувати своє програмне забезпечення "
"за допомогою Python 2.1, все більше і більше пакетів включатимуть метадані, "
"що дає змогу створювати автоматизовані системи каталогізації та "
"експериментувати з ними. З отриманим досвідом, можливо, стане можливим "
"створити справді хороший каталог, а потім створити його підтримку в Python "
"2.2. Наприклад, команди Distutils :command:`sdist` і :command:`bdist_\\*` "
"можуть підтримувати опцію ``upload``, яка автоматично завантажуватиме ваш "
"пакет на сервер каталогу."

#: ../../whatsnew/2.1.rst:565
msgid ""
"You can start creating packages containing :file:`PKG-INFO` even if you're "
"not using Python 2.1, since a new release of the Distutils will be made for "
"users of earlier Python versions.  Version 1.0.2 of the Distutils includes "
"the changes described in :pep:`241`, as well as various bugfixes and "
"enhancements.  It will be available from the Distutils SIG at "
"https://www.python.org/community/sigs/current/distutils-sig/."
msgstr ""
"Ви можете почати створювати пакунки, що містять :file:`PKG-INFO`, навіть "
"якщо ви не використовуєте Python 2.1, оскільки для користувачів попередніх "
"версій Python буде створено новий випуск Distutils. Версія 1.0.2 Distutils "
"містить зміни, описані в :pep:`241`, а також різні виправлення помилок і "
"вдосконалення. Він буде доступний у Distutils SIG за адресою "
"https://www.python.org/community/sigs/current/distutils-sig/."

#: ../../whatsnew/2.1.rst:574
msgid ":pep:`241` - Metadata for Python Software Packages"
msgstr ":pep:`241` - метадані для програмних пакетів Python"

#: ../../whatsnew/2.1.rst:577
msgid ":pep:`243` - Module Repository Upload Mechanism"
msgstr ":pep:`243` - Механізм завантаження сховища модулів"

#: ../../whatsnew/2.1.rst:578
msgid ""
"Written by Sean Reifschneider, this draft PEP describes a proposed mechanism"
" for uploading  Python packages to a central server."
msgstr ""
"Цей проект PEP, написаний Шоном Райфшнайдером, описує запропонований "
"механізм для завантаження пакетів Python на центральний сервер."

#: ../../whatsnew/2.1.rst:585
msgid "New and Improved Modules"
msgstr "Нові та вдосконалені модулі"

#: ../../whatsnew/2.1.rst:587
msgid ""
"Ka-Ping Yee contributed two new modules: :mod:`!inspect.py`, a module for "
"getting information about live Python code, and :mod:`!pydoc.py`, a module "
"for interactively converting docstrings to HTML or text.  As a bonus, "
":file:`Tools/scripts/pydoc`, which is now automatically installed, uses "
":mod:`!pydoc.py` to display documentation given a Python module, package, or"
" class name.  For example, ``pydoc xml.dom`` displays the following::"
msgstr ""

#: ../../whatsnew/2.1.rst:594
msgid ""
"Python Library Documentation: package xml.dom in xml\n"
"\n"
"NAME\n"
"    xml.dom - W3C Document Object Model implementation for Python.\n"
"\n"
"FILE\n"
"    /usr/local/lib/python2.1/xml/dom/__init__.pyc\n"
"\n"
"DESCRIPTION\n"
"    The Python mapping of the Document Object Model is documented in the\n"
"    Python Library Reference in the section on the xml.dom package.\n"
"\n"
"    This package contains the following modules:\n"
"      ..."
msgstr ""

#: ../../whatsnew/2.1.rst:609
msgid ""
":file:`pydoc` also includes a Tk-based interactive help browser.   "
":file:`pydoc` quickly becomes addictive; try it out!"
msgstr ""
":file:`pydoc` також містить інтерактивний довідковий браузер на основі Tk. "
":file:`pydoc` швидко викликає звикання; Спробуй!"

#: ../../whatsnew/2.1.rst:612
msgid ""
"Two different modules for unit testing were added to the standard library. "
"The :mod:`doctest` module, contributed by Tim Peters, provides a testing "
"framework based on running embedded examples in docstrings and comparing the"
" results against the expected output.  PyUnit, contributed by Steve Purcell,"
" is a unit testing framework inspired by JUnit, which was in turn an "
"adaptation of Kent Beck's Smalltalk testing framework.  See "
"https://pyunit.sourceforge.net/ for more information about PyUnit."
msgstr ""

#: ../../whatsnew/2.1.rst:620
msgid ""
"The :mod:`difflib` module contains a class, "
":class:`~difflib.SequenceMatcher`, which compares two sequences and computes"
" the changes required to transform one sequence into the other.  For "
"example, this module can be used to write a tool similar to the Unix "
":program:`diff` program, and in fact the sample program "
":file:`Tools/scripts/ndiff.py` demonstrates how to write such a script."
msgstr ""

#: ../../whatsnew/2.1.rst:626
msgid ""
":mod:`curses.panel`, a wrapper for the panel library, part of ncurses and of"
" SYSV curses, was contributed by Thomas Gellekum.  The panel library "
"provides windows with the additional feature of depth. Windows can be moved "
"higher or lower in the depth ordering, and the panel library figures out "
"where panels overlap and which sections are visible."
msgstr ""
":mod:`curses.panel`, оболонку для бібліотеки панелей, частину ncurses і "
"проклять SYSV, надав Томас Геллекум. Бібліотека панелей надає вікна з "
"додатковою функцією глибини. Вікна можна переміщувати вище або нижче в "
"порядку глибини, а бібліотека панелей визначає, де панелі перекриваються та "
"які розділи видно."

#: ../../whatsnew/2.1.rst:632
msgid ""
"The PyXML package has gone through a few releases since Python 2.0, and "
"Python 2.1 includes an updated version of the :mod:`xml` package.  Some of "
"the noteworthy changes include support for Expat 1.2 and later versions, the"
" ability for Expat parsers to handle files in any encoding supported by "
"Python, and various bugfixes for SAX, DOM, and the :mod:`!minidom` module."
msgstr ""

#: ../../whatsnew/2.1.rst:638
msgid ""
"Ping also contributed another hook for handling uncaught exceptions. "
":func:`sys.excepthook` can be set to a callable object.  When an exception "
"isn't caught by any :keyword:`try`...\\ :keyword:`except` blocks, the "
"exception will be passed to :func:`sys.excepthook`, which can then do "
"whatever it likes.  At the Ninth Python Conference, Ping demonstrated an "
"application for this hook: printing an extended traceback that not only "
"lists the stack frames, but also lists the function arguments and the local "
"variables for each frame."
msgstr ""
"Ping також вніс ще один хук для обробки неперехоплених винятків. "
":func:`sys.excepthook` можна встановити на об’єкт, що викликається. Якщо "
"виняток не перехоплюється жодним блоком :keyword:`try`...\\ "
":keyword:`except`, виняток буде передано до :func:`sys.excepthook`, який "
"потім може робити все, що забажає. На Дев’ятій конференції Python Ping "
"продемонстрував застосування для цього хука: друк розширеного трасування, "
"яке не лише містить перелік фреймів стека, але також перераховує аргументи "
"функції та локальні змінні для кожного фрейму."

#: ../../whatsnew/2.1.rst:646
msgid ""
"Various functions in the :mod:`time` module, such as :func:`~time.asctime` "
"and :func:`~time.localtime`, require a floating-point argument containing "
"the time in seconds since the epoch.  The most common use of these functions"
" is to work with the current time, so the floating-point argument has been "
"made optional; when a value isn't provided, the current time will be used.  "
"For example, log file entries usually need a string containing the current "
"time; in Python 2.1, ``time.asctime()`` can be used, instead of the "
"lengthier ``time.asctime(time.localtime(time.time()))`` that was previously "
"required."
msgstr ""

#: ../../whatsnew/2.1.rst:655
msgid "This change was proposed and implemented by Thomas Wouters."
msgstr "Цю зміну запропонував і впровадив Томас Воутерс."

#: ../../whatsnew/2.1.rst:657
msgid ""
"The :mod:`ftplib` module now defaults to retrieving files in passive mode, "
"because passive mode is more likely to work from behind a firewall.  This "
"request came from the Debian bug tracking system, since other Debian "
"packages use :mod:`ftplib` to retrieve files and then don't work from behind"
" a firewall. It's deemed unlikely that this will cause problems for anyone, "
"because Netscape defaults to passive mode and few people complain, but if "
"passive mode is unsuitable for your application or network setup, call "
"``set_pasv(0)`` on FTP objects to disable passive mode."
msgstr ""
"Модуль :mod:`ftplib` тепер за замовчуванням отримує файли в пасивному "
"режимі, оскільки пасивний режим, швидше за все, працюватиме за брандмауером."
" Цей запит надійшов від системи відстеження помилок Debian, оскільки інші "
"пакунки Debian використовують :mod:`ftplib` для отримання файлів, а потім не"
" працюють через брандмауер. Вважається малоймовірним, що це спричинить "
"комусь проблеми, оскільки Netscape за замовчуванням використовує пасивний "
"режим, і мало хто скаржиться, але якщо пасивний режим не підходить для вашої"
" програми чи налаштувань мережі, викличте ``set_pasv(0)`` для об’єктів FTP, "
"щоб вимкнути пасивний режим."

#: ../../whatsnew/2.1.rst:666
msgid ""
"Support for raw socket access has been added to the :mod:`socket` module, "
"contributed by Grant Edwards."
msgstr ""
"До модуля :mod:`socket`, наданого Грантом Едвардсом, додано підтримку "
"необробленого доступу до сокетів."

#: ../../whatsnew/2.1.rst:669
msgid ""
"The :mod:`pstats` module now contains a simple interactive statistics "
"browser for displaying timing profiles for Python programs, invoked when the"
" module is run as a script.  Contributed by  Eric S. Raymond."
msgstr ""
"Модуль :mod:`pstats` тепер містить простий інтерактивний браузер статистики "
"для відображення профілів часу для програм Python, викликаних, коли модуль "
"запускається як сценарій. Надав Ерік С. Реймонд."

#: ../../whatsnew/2.1.rst:673
msgid ""
"A new implementation-dependent function, ``sys._getframe([depth])``, has "
"been added to return a given frame object from the current call stack. "
":func:`sys._getframe` returns the frame at the top of the call stack;  if "
"the optional integer argument *depth* is supplied, the function returns the "
"frame that is *depth* calls below the top of the stack.  For example, "
"``sys._getframe(1)`` returns the caller's frame object."
msgstr ""
"Додано нову залежну від реалізації функцію sys._getframe([depth]) для "
"повернення заданого об’єкта кадру з поточного стеку викликів. "
":func:`sys._getframe` повертає кадр у верхній частині стека викликів; якщо "
"вказано додатковий цілочисельний аргумент *depth*, функція повертає кадр, "
"який *depth* викликає нижче верхньої частини стека. Наприклад, "
"``sys._getframe(1)`` повертає об’єкт кадру викликаючого."

#: ../../whatsnew/2.1.rst:680
msgid ""
"This function is only present in CPython, not in Jython or the .NET "
"implementation.  Use it for debugging, and resist the temptation to put it "
"into production code."
msgstr ""
"Ця функція присутня лише в CPython, а не в Jython або реалізації .NET. "
"Використовуйте його для налагодження та втримайтеся від спокуси вставити "
"його у робочий код."

#: ../../whatsnew/2.1.rst:688
msgid "Other Changes and Fixes"
msgstr "Інші зміни та виправлення"

#: ../../whatsnew/2.1.rst:690
msgid ""
"There were relatively few smaller changes made in Python 2.1 due to the "
"shorter release cycle.  A search through the CVS change logs turns up 117 "
"patches applied, and 136 bugs fixed; both figures are likely to be "
"underestimates.  Some of the more notable changes are:"
msgstr ""
"У Python 2.1 було внесено відносно небагато менших змін через коротший цикл "
"випуску. Пошук у журналах змін CVS виявив 117 застосованих виправлень і 136 "
"виправлених помилок; обидві цифри, ймовірно, занижені. Деякі з найбільш "
"помітних змін:"

#: ../../whatsnew/2.1.rst:695
msgid ""
"A specialized object allocator is now optionally available, that should be "
"faster than the system :c:func:`malloc` and have less memory overhead.  The "
"allocator uses C's :c:func:`!malloc` function to get large pools of memory, "
"and then fulfills smaller memory requests from these pools.  It can be "
"enabled by providing the :option:`!--with-pymalloc` option to the "
":program:`configure` script; see :file:`Objects/obmalloc.c` for the "
"implementation details."
msgstr ""

#: ../../whatsnew/2.1.rst:702
msgid ""
"Authors of C extension modules should test their code with the object "
"allocator enabled, because some incorrect code may break, causing core dumps"
" at runtime. There are a bunch of memory allocation functions in Python's C "
"API that have previously been just aliases for the C library's "
":c:func:`malloc` and :c:func:`free`, meaning that if you accidentally called"
" mismatched functions, the error wouldn't be noticeable.  When the object "
"allocator is enabled, these functions aren't aliases of :c:func:`!malloc` "
"and :c:func:`!free` any more, and calling the wrong function to free memory "
"will get you a core dump.  For example, if memory was allocated using "
":c:macro:`PyMem_New`, it has to be freed using :c:func:`PyMem_Del`, not "
":c:func:`!free`.  A few modules included with Python fell afoul of this and "
"had to be fixed; doubtless there are more third-party modules that will have"
" the same problem."
msgstr ""

#: ../../whatsnew/2.1.rst:715
msgid "The object allocator was contributed by Vladimir Marangozov."
msgstr "Розподільник об’єктів надав Володимир Марангозов."

#: ../../whatsnew/2.1.rst:717
msgid ""
"The speed of line-oriented file I/O has been improved because people often "
"complain about its lack of speed, and because it's often been used as a "
"naïve benchmark.  The :meth:`readline` method of file objects has therefore "
"been rewritten to be much faster.  The exact amount of the speedup will vary"
" from platform to platform depending on how slow the C library's "
":c:func:`!getc` was, but is around 66%, and potentially much faster on some "
"particular operating systems. Tim Peters did much of the benchmarking and "
"coding for this change, motivated by a discussion in comp.lang.python."
msgstr ""

#: ../../whatsnew/2.1.rst:726
msgid ""
"A new module and method for file objects was also added, contributed by Jeff"
" Epler. The new method, :meth:`!xreadlines`, is similar to the existing "
":func:`!xrange` built-in.  :func:`!xreadlines` returns an opaque sequence "
"object that only supports being iterated over, reading a line on every "
"iteration but not reading the entire file into memory as the existing "
":meth:`!readlines` method does. You'd use it like this::"
msgstr ""

#: ../../whatsnew/2.1.rst:733
msgid ""
"for line in sys.stdin.xreadlines():\n"
"    # ... do something for each line ...\n"
"    ..."
msgstr ""

#: ../../whatsnew/2.1.rst:737
msgid ""
"For a fuller discussion of the line I/O changes, see the python-dev summary "
"for January 1--15, 2001 at https://mail.python.org/pipermail/python-"
"dev/2001-January/."
msgstr ""
"Для детальнішого обговорення змін лінії вводу-виводу дивіться резюме python-"
"dev за 1--15 січня 2001 року на https://mail.python.org/pipermail/python-"
"dev/2001-January/."

#: ../../whatsnew/2.1.rst:740
msgid ""
"A new method, :meth:`~dict.popitem`, was added to dictionaries to enable "
"destructively iterating through the contents of a dictionary; this can be "
"faster for large dictionaries because there's no need to construct a list "
"containing all the keys or values. ``D.popitem()`` removes a random ``(key, "
"value)`` pair from the dictionary ``D`` and returns it as a 2-tuple.  This "
"was implemented mostly by Tim Peters and Guido van Rossum, after a "
"suggestion and preliminary patch by Moshe Zadka."
msgstr ""

#: ../../whatsnew/2.1.rst:748
msgid ""
"Modules can now control which names are imported when ``from module import "
"*`` is used, by defining an ``__all__`` attribute containing a list of names"
" that will be imported.  One common complaint is that if the module imports "
"other modules such as :mod:`sys` or :mod:`string`, ``from module import *`` "
"will add them to the importing module's namespace.  To fix this, simply list"
" the public names in ``__all__``::"
msgstr ""
"Модулі тепер можуть контролювати, які імена імпортуються, коли "
"використовується ``from module import *``, визначаючи атрибут ``__all__``, "
"що містить список імен, які будуть імпортовані. Однією з поширених скарг є "
"те, що якщо модуль імпортує інші модулі, такі як :mod:`sys` або "
":mod:`string`, ``from module import *`` додасть їх до простору імен модуля "
"імпорту. Щоб виправити це, просто перелічіть загальнодоступні імена в "
"``__all__``::"

#: ../../whatsnew/2.1.rst:755
msgid ""
"# List public names\n"
"__all__ = ['Database', 'open']"
msgstr ""

#: ../../whatsnew/2.1.rst:758
msgid ""
"A stricter version of this patch was first suggested and implemented by Ben "
"Wolfson, but after some python-dev discussion, a weaker final version was "
"checked in."
msgstr ""
"Більш сувору версію цього патча вперше запропонував і реалізував Бен "
"Вольфсон, але після деякого обговорення розробників python була перевірена "
"слабша остаточна версія."

#: ../../whatsnew/2.1.rst:762
msgid ""
"Applying :func:`repr` to strings previously used octal escapes for non-"
"printable characters; for example, a newline was ``'\\012'``.  This was a "
"vestigial trace of Python's C ancestry, but today octal is of very little "
"practical use.  Ka-Ping Yee suggested using hex escapes instead of octal "
"ones, and using the ``\\n``, ``\\t``, ``\\r`` escapes for the appropriate "
"characters, and implemented this new formatting."
msgstr ""
"Застосування :func:`repr` до рядків, які раніше використовували вісімкові "
"символи для недрукованих символів; наприклад, новий рядок був ``''\\012'``. "
"Це був рудиментарний слід походження Python C, але сьогодні вісімкова "
"система має дуже мало практичного використання. Ka-Ping Yee запропонував "
"використовувати шістнадцяткові символи замість вісімкових, а також "
"використовувати символи ``\\n``, ``\\t``, ``\\r`` для відповідних символів, "
"і реалізував це нове форматування."

#: ../../whatsnew/2.1.rst:769
msgid ""
"Syntax errors detected at compile-time can now raise exceptions containing "
"the filename and line number of the error, a pleasant side effect of the "
"compiler reorganization done by Jeremy Hylton."
msgstr ""
"Синтаксичні помилки, виявлені під час компіляції, тепер можуть викликати "
"винятки, що містять назву файлу та номер рядка помилки, приємний побічний "
"ефект реорганізації компілятора, виконаної Джеремі Гілтоном."

#: ../../whatsnew/2.1.rst:773
msgid ""
"C extensions which import other modules have been changed to use "
":c:func:`PyImport_ImportModule`, which means that they will use any import "
"hooks that have been installed.  This is also encouraged for third-party "
"extensions that need to import some other module from C code."
msgstr ""

#: ../../whatsnew/2.1.rst:778
msgid ""
"The size of the Unicode character database was shrunk by another 340K thanks"
" to Fredrik Lundh."
msgstr ""
"Завдяки Фредріку Лунду розмір бази даних символів Unicode було зменшено ще "
"на 340 КБ."

#: ../../whatsnew/2.1.rst:781
msgid ""
"Some new ports were contributed: MacOS X (by Steven Majewski), Cygwin (by "
"Jason Tishler); RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. "
"Allie)."
msgstr ""
"Додано кілька нових портів: MacOS X (від Стівена Маєвського), Cygwin (від "
"Джейсона Тішлера); RISCOS (автор Дітмар Швертбергер); Unixware 7 (автор "
"Billy G. Allie)."

#: ../../whatsnew/2.1.rst:785
msgid ""
"And there's the usual list of minor bugfixes, minor memory leaks, docstring "
"edits, and other tweaks, too lengthy to be worth itemizing; see the CVS logs"
" for the full details if you want them."
msgstr ""
"І є звичайний список незначних виправлень помилок, незначних витоків "
"пам’яті, редагування рядків документів та інших налаштувань, надто довгий, "
"щоб його варто було б перерахувати; перегляньте журнали CVS, щоб отримати "
"повну інформацію, якщо ви її бажаєте."

#: ../../whatsnew/2.1.rst:793
msgid "Acknowledgements"
msgstr "Подяки"

#: ../../whatsnew/2.1.rst:795
msgid ""
"The author would like to thank the following people for offering suggestions"
" on various drafts of this article: Graeme Cross, David Goodger, Jay Graves,"
" Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas"
" Wouters."
msgstr ""
"Автор хотів би подякувати наступним людям за пропозиції щодо різних чернеток"
" цієї статті: Грем Кросс, Девід Гуджер, Джей Грейвс, Майкл Хадсон, Марк-"
"Андре Лембург, Фредрік Лунд, Ніл Шеменауер, Томас Воутерс."
