# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "What's New in Python 2.0"
msgstr "Що нового в Python 2.0"

msgid "Author"
msgstr "Автор"

msgid "A.M. Kuchling and Moshe Zadka"
msgstr "A.M. Kuchling та Moshe Zadka"

msgid "Introduction"
msgstr "вступ"

msgid ""
"A new release of Python, version 2.0, was released on October 16, 2000. This "
"article covers the exciting new features in 2.0, highlights some other "
"useful changes, and points out a few incompatible changes that may require "
"rewriting code."
msgstr ""
"Новий випуск Python, версія 2.0, був випущений 16 жовтня 2000 року. У цій "
"статті розглядаються цікаві нові можливості версії 2.0, висвітлюються деякі "
"інші корисні зміни та вказується на кілька несумісних змін, які можуть "
"вимагати переписування коду."

msgid ""
"Python's development never completely stops between releases, and a steady "
"flow of bug fixes and improvements are always being submitted. A host of "
"minor fixes, a few optimizations, additional docstrings, and better error "
"messages went into 2.0; to list them all would be impossible, but they're "
"certainly significant. Consult the publicly-available CVS logs if you want "
"to see the full list.  This progress is due to the five developers working "
"for  PythonLabs are now getting paid to spend their days fixing bugs, and "
"also due to the improved communication resulting  from moving to SourceForge."
msgstr ""
"Розробка Python ніколи повністю не зупиняється між випусками, і постійно "
"надсилається потік виправлень помилок і вдосконалень. Багато незначних "
"виправлень, кілька оптимізацій, додаткові рядки документації та кращі "
"повідомлення про помилки увійшли до 2.0; перерахувати їх усіх було б "
"неможливо, але вони, безумовно, важливі. Зверніться до загальнодоступних "
"журналів CVS, якщо бажаєте переглянути повний список. Цей прогрес відбувся "
"завдяки тому, що п’ять розробників, які працюють на PythonLabs, тепер "
"отримують гроші за те, щоб витрачати свої дні на виправлення помилок, а "
"також завдяки покращеній комунікації в результаті переходу на SourceForge."

msgid "What About Python 1.6?"
msgstr "Що щодо Python 1.6?"

msgid ""
"Python 1.6 can be thought of as the Contractual Obligations Python release. "
"After the core development team left CNRI in May 2000, CNRI requested that a "
"1.6 release be created, containing all the work on Python that had been "
"performed at CNRI.  Python 1.6 therefore represents the state of the CVS "
"tree as of May 2000, with the most significant new feature being Unicode "
"support.  Development continued after May, of course, so the 1.6 tree "
"received a few fixes to ensure that it's forward-compatible with Python "
"2.0.  1.6 is therefore part of Python's evolution, and not a side branch."
msgstr ""
"Python 1.6 можна вважати випуском Python Contractual Obligations. Після "
"того, як основна команда розробників залишила CNRI у травні 2000 року, CNRI "
"попросив створити випуск 1.6, який містив би всю роботу над Python, яка була "
"виконана в CNRI. Таким чином, Python 1.6 представляє стан дерева CVS станом "
"на травень 2000 року, причому найважливішою новою функцією є підтримка "
"Unicode. Розробка продовжилася і після травня, тому дерево 1.6 отримало "
"кілька виправлень, щоб гарантувати його сумісність із Python 2.0. Таким "
"чином, 1.6 є частиною еволюції Python, а не побічною гілкою."

msgid ""
"So, should you take much interest in Python 1.6?  Probably not.  The "
"1.6final and 2.0beta1 releases were made on the same day (September 5, "
"2000), the plan being to finalize Python 2.0 within a month or so.  If you "
"have applications to maintain, there seems little point in breaking things "
"by moving to 1.6, fixing them, and then having another round of breakage "
"within a month by moving to 2.0; you're better off just going straight to "
"2.0.  Most of the really interesting features described in this document are "
"only in 2.0, because a lot of work was done between May and September."
msgstr ""
"Отже, чи варто сильно цікавитися Python 1.6? Напевно ні. Релізи 1.6final і "
"2.0beta1 були зроблені в один і той же день (5 вересня 2000 р.), планом було "
"завершити Python 2.0 протягом місяця або близько того. Якщо у вас є додатки, "
"які потрібно підтримувати, здається, немає сенсу ламати роботу, переходячи "
"до 1.6, виправляючи їх, а потім мати ще один цикл поломок протягом місяця, "
"переходячи до 2.0; вам краще просто перейти до 2.0. Більшість справді "
"цікавих функцій, описаних у цьому документі, є лише у версії 2.0, оскільки з "
"травня по вересень було виконано багато роботи."

msgid "New Development Process"
msgstr "Новий процес розвитку"

msgid ""
"The most important change in Python 2.0 may not be to the code at all, but "
"to how Python is developed: in May 2000 the Python developers began using "
"the tools made available by SourceForge for storing  source code, tracking "
"bug reports, and managing the queue of patch submissions.  To report bugs or "
"submit patches for Python 2.0, use the bug tracking and patch manager tools "
"available from Python's project page, located at https://sourceforge.net/"
"projects/python/."
msgstr ""
"Найважливіша зміна в Python 2.0 може стосуватися зовсім не коду, а способу "
"розробки Python: у травні 2000 року розробники Python почали використовувати "
"інструменти, надані SourceForge для зберігання вихідного коду, відстеження "
"звітів про помилки та керування чергою. подання патчів. Щоб повідомити про "
"помилки або надіслати виправлення для Python 2.0, використовуйте інструменти "
"відстеження помилок і керування виправленнями, доступні на сторінці проекту "
"Python, розташованій за адресою https://sourceforge.net/projects/python/."

msgid ""
"The most important of the services now hosted at SourceForge is the Python "
"CVS tree, the version-controlled repository containing the source code for "
"Python. Previously, there were roughly 7 or so people who had write access "
"to the CVS tree, and all patches had to be inspected and checked in by one "
"of the people on this short list. Obviously, this wasn't very scalable.  By "
"moving the CVS tree to SourceForge, it became possible to grant write access "
"to more people; as of September 2000 there were 27 people able to check in "
"changes, a fourfold increase.  This makes possible large-scale changes that "
"wouldn't be attempted if they'd have to be filtered through the small group "
"of core developers.  For example, one day Peter Schneider-Kamp took it into "
"his head to drop K&R C compatibility and convert the C source for Python to "
"ANSI C. After getting approval on the python-dev mailing list, he launched "
"into a flurry of checkins that lasted about a week, other developers joined "
"in to help, and the job was done.  If there were only 5 people with write "
"access, probably that task would have been viewed as \"nice, but not worth "
"the time and effort needed\" and it would never have gotten done."
msgstr ""
"Найважливішою з послуг, які зараз розміщені на SourceForge, є дерево Python "
"CVS, репозиторій з контрольованими версіями, що містить вихідний код для "
"Python. Раніше було приблизно 7 або близько того людей, які мали доступ для "
"запису до дерева CVS, і всі латки повинні були бути перевірені та "
"зареєстровані одним із людей у цьому короткому списку. Очевидно, що це було "
"не дуже масштабовано. Завдяки переміщенню дерева CVS до SourceForge стало "
"можливим надати доступ для запису більшій кількості людей; станом на "
"вересень 2000 року було 27 осіб, які могли перевірити зміни, тобто "
"чотириразове збільшення. Це робить можливими масштабні зміни, які б не були "
"зроблені, якби їх довелося фільтрувати через невелику групу основних "
"розробників. Наприклад, одного разу Пітер Шнайдер-Камп спав на думку "
"відмовитися від сумісності з K&R C і перетворити вихідний код C для Python "
"на ANSI C. Отримавши схвалення в списку розсилки python-dev, він розпочав "
"шквал перевірок, які тривали близько тижня інші розробники приєдналися, щоб "
"допомогти, і роботу було виконано. Якби було лише 5 осіб із доступом для "
"запису, ймовірно, це завдання було б сприйняте як \"гарне, але не варте "
"потрібного часу та зусиль\", і воно ніколи не було б виконане."

msgid ""
"The shift to using SourceForge's services has resulted in a remarkable "
"increase in the speed of development.  Patches now get submitted, commented "
"on, revised by people other than the original submitter, and bounced back "
"and forth between people until the patch is deemed worth checking in.  Bugs "
"are tracked in one central location and can be assigned to a specific person "
"for fixing, and we can count the number of open bugs to measure progress.  "
"This didn't come without a cost: developers now have more e-mail to deal "
"with, more mailing lists to follow, and special tools had to be written for "
"the new environment. For example, SourceForge sends default patch and bug "
"notification e-mail messages that are completely unhelpful, so Ka-Ping Yee "
"wrote an HTML screen-scraper that sends more useful messages."
msgstr ""
"Перехід до використання послуг SourceForge призвів до значного збільшення "
"швидкості розробки. Патчі тепер надсилаються, коментуються, переглядаються "
"людьми, які не були початковим відправником, і обмінюються між людьми, доки "
"виправлення не буде визнано вартим перевірки. Помилки відстежуються в одному "
"центральному місці та можуть бути призначені конкретній особі для "
"виправлення , і ми можемо підрахувати кількість відкритих помилок для "
"вимірювання прогресу. Це не обійшлося без витрат: розробники тепер мають "
"більше електронної пошти, щоб мати справу з більшою кількістю списків "
"розсилки, і для нового середовища потрібно було написати спеціальні "
"інструменти. Наприклад, SourceForge надсилає повідомлення електронною поштою "
"про стандартні виправлення та сповіщення про помилки, які абсолютно марні, "
"тому Ka-Ping Yee написав HTML-скрейпер, який надсилає більш корисні "
"повідомлення."

msgid ""
"The ease of adding code caused a few initial growing pains, such as code was "
"checked in before it was ready or without getting clear agreement from the "
"developer group.  The approval process that has emerged is somewhat similar "
"to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a "
"patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the "
"developer is mostly indifferent to the change, though with a slight positive "
"or negative slant.  The most significant change from the Apache model is "
"that the voting is essentially advisory, letting Guido van Rossum, who has "
"Benevolent Dictator For Life status, know what the general opinion is. He "
"can still ignore the result of a vote, and approve or reject a change even "
"if the community disagrees with him."
msgstr ""
"Легкість додавання коду спричинила кілька початкових труднощів, наприклад "
"код перевірявся до того, як він був готовий, або без отримання чіткої згоди "
"від групи розробників. Процес затвердження, який з’явився, дещо схожий на "
"той, який використовується групою Apache. Розробники можуть голосувати за "
"патч +1, +0, -0 або -1; +1 і -1 означають прийняття або відхилення, тоді як "
"+0 і -0 означають, що розробник здебільшого байдужий до змін, хоча з "
"невеликим позитивним або негативним ухилом. Найсуттєвішою зміною в "
"порівнянні з моделлю Apache є те, що голосування є, по суті, дорадчим, "
"дозволяючи Гвідо ван Россуму, який має статус доброзичливого довічного "
"диктатора, знати, якою є загальна думка. Він все ще може ігнорувати "
"результати голосування та схвалити або відхилити зміни, навіть якщо "
"спільнота з ним не погоджується."

msgid ""
"Producing an actual patch is the last step in adding a new feature, and is "
"usually easy compared to the earlier task of coming up with a good design. "
"Discussions of new features can often explode into lengthy mailing list "
"threads, making the discussion hard to follow, and no one can read every "
"posting to python-dev.  Therefore, a relatively formal process has been set "
"up to write Python Enhancement Proposals (PEPs), modelled on the internet "
"RFC process.  PEPs are draft documents that describe a proposed new feature, "
"and are continually revised until the community reaches a consensus, either "
"accepting or rejecting the proposal.  Quoting from the introduction to :pep:"
"`1`, \"PEP Purpose and Guidelines\":"
msgstr ""
"Створення фактичного патча є останнім кроком у додаванні нової функції, і "
"зазвичай це легко порівняно з попереднім завданням створення гарного "
"дизайну. Обговорення нових функцій часто може вибухнути в довгі ланцюжки "
"списків розсилки, що ускладнює стеження за обговоренням, і ніхто не може "
"прочитати кожну публікацію на python-dev. Тому було створено відносно "
"формальний процес для написання пропозицій щодо покращення Python (PEP), "
"змодельований на основі процесу RFC в Інтернеті. PEPs — це проекти "
"документів, які описують запропоновану нову функцію, і постійно "
"переглядаються, доки спільнота не досягне консенсусу, прийняти або відхилити "
"пропозицію. Цитата зі вступу до :pep:`1`, \"Мета PEP і рекомендації\":"

msgid ""
"PEP stands for Python Enhancement Proposal.  A PEP is a design document "
"providing information to the Python community, or describing a new feature "
"for Python.  The PEP should provide a concise technical specification of the "
"feature and a rationale for the feature."
msgstr ""
"PEP розшифровується як Python Enhancement Proposal. PEP — це проектний "
"документ, який надає інформацію спільноті Python або описує нову функцію для "
"Python. PEP має надавати стислу технічну специфікацію функції та "
"обґрунтування цієї функції."

msgid ""
"We intend PEPs to be the primary mechanisms for proposing new features, for "
"collecting community input on an issue, and for documenting the design "
"decisions that have gone into Python.  The PEP author is responsible for "
"building consensus within the community and documenting dissenting opinions."
msgstr ""
"Ми плануємо, щоб PEP були основними механізмами для пропонування нових "
"функцій, для збору внесків спільноти щодо проблеми та для документування "
"дизайнерських рішень, які увійшли до Python. Автор PEP відповідає за "
"формування консенсусу в спільноті та документування особливих думок."

msgid ""
"Read the rest of :pep:`1` for the details of the PEP editorial process, "
"style, and format.  PEPs are kept in the Python CVS tree on SourceForge, "
"though they're not part of the Python 2.0 distribution, and are also "
"available in HTML form from https://www.python.org/dev/peps/.  As of "
"September 2000, there are 25 PEPS, ranging from :pep:`201`, \"Lockstep "
"Iteration\", to PEP 225, \"Elementwise/Objectwise Operators\"."
msgstr ""
"Прочитайте решту :pep:`1`, щоб дізнатися більше про редакційний процес PEP, "
"стиль і формат. PEP зберігаються в дереві Python CVS на SourceForge, хоча "
"вони не є частиною дистрибутива Python 2.0, і також доступні у формі HTML на "
"https://www.python.org/dev/peps/. Станом на вересень 2000 року існує 25 "
"PEPS, починаючи від :pep:`201`, \"Lockstep Iteration\", до PEP 225, "
"\"Elementwise/Objectwise Operators\"."

msgid "Unicode"
msgstr "Unicode"

msgid ""
"The largest new feature in Python 2.0 is a new fundamental data type: "
"Unicode strings.  Unicode uses 16-bit numbers to represent characters "
"instead of the 8-bit number used by ASCII, meaning that 65,536 distinct "
"characters can be supported."
msgstr ""
"Найбільшою новою функцією Python 2.0 є новий фундаментальний тип даних: "
"рядки Unicode. Юнікод використовує 16-розрядні числа для представлення "
"символів замість 8-розрядних чисел, які використовуються в ASCII, тобто "
"підтримується 65 536 різних символів."

msgid ""
"The final interface for Unicode support was arrived at through countless "
"often-stormy discussions on the python-dev mailing list, and mostly "
"implemented by Marc-André Lemburg, based on a Unicode string type "
"implementation by Fredrik Lundh.  A detailed explanation of the interface "
"was written up as :pep:`100`, \"Python Unicode Integration\". This article "
"will simply cover the most significant points about the Unicode interfaces."
msgstr ""
"Остаточний інтерфейс для підтримки Unicode був досягнутий під час "
"незліченних, часто бурхливих дискусій у списку розсилки python-dev, і "
"здебільшого реалізований Марком-Андре Лембургом на основі реалізації "
"рядкового типу Unicode Фредріком Лундом. Детальне пояснення інтерфейсу було "
"написано як :pep:`100`, \"Інтеграція Python Unicode\". Ця стаття лише "
"охопить найважливіші моменти щодо інтерфейсів Unicode."

msgid ""
"In Python source code, Unicode strings are written as ``u\"string\"``.  "
"Arbitrary Unicode characters can be written using a new escape sequence, "
"``\\uHHHH``, where *HHHH* is a 4-digit hexadecimal number from 0000 to "
"FFFF.  The existing ``\\xHHHH`` escape sequence can also be used, and octal "
"escapes can be used for characters up to U+01FF, which is represented by "
"``\\777``."
msgstr ""
"У вихідному коді Python рядки Unicode записуються як ``u\"рядок``. Довільні "
"символи Юнікоду можна записувати за допомогою нової керуючої послідовності "
"``\\uHHHH``, де *HHHH* — це 4-значне шістнадцяткове число від 0000 до FFFF. "
"Існуючу керуючу послідовність ``\\xHHHH`` також можна використовувати, а "
"вісімкове екранування можна використовувати для символів до U+01FF, що "
"представлено ``\\777``."

msgid ""
"Unicode strings, just like regular strings, are an immutable sequence type. "
"They can be indexed and sliced, but not modified in place. Unicode strings "
"have an ``encode( [encoding] )`` method that returns an 8-bit string in the "
"desired encoding.  Encodings are named by strings, such as ``'ascii'``, "
"``'utf-8'``, ``'iso-8859-1'``, or whatever.  A codec API is defined for "
"implementing and registering new encodings that are then available "
"throughout a Python program. If an encoding isn't specified, the default "
"encoding is usually 7-bit ASCII, though it can be changed for your Python "
"installation by calling the ``sys.setdefaultencoding(encoding)`` function in "
"a customized version of :file:`site.py`."
msgstr ""
"Рядки Unicode, як і звичайні рядки, є незмінним типом послідовності. Їх "
"можна індексувати та нарізати, але не змінювати на місці. Рядки Unicode "
"мають метод ``encode( [encoding] )``, який повертає 8-бітовий рядок у "
"потрібному кодуванні. Кодування називаються рядками, наприклад ``'ascii'``, "
"``'utf-8''``, ``'iso-8859-1''`` або будь-яким іншим. Кодек API визначено для "
"реалізації та реєстрації нових кодувань, які потім доступні в усій програмі "
"Python. Якщо кодування не вказано, кодуванням за замовчуванням зазвичай є 7-"
"бітний ASCII, хоча його можна змінити для інсталяції Python, викликавши "
"функцію ``sys.setdefaultencoding(encoding)`` у налаштованій версії :file:"
"`site.py`."

msgid ""
"Combining 8-bit and Unicode strings always coerces to Unicode, using the "
"default ASCII encoding; the result of ``'a' + u'bc'`` is ``u'abc'``."
msgstr ""
"Комбінування 8-бітових рядків і рядків Unicode завжди приводить до Unicode, "
"використовуючи стандартне кодування ASCII; результатом ``'a' + u'bc'`` є "
"``u'abc``."

msgid ""
"New built-in functions have been added, and existing built-ins modified to "
"support Unicode:"
msgstr ""
"Додано нові вбудовані функції, а наявні вбудовані модифіковано для підтримки "
"Unicode:"

msgid ""
"``unichr(ch)`` returns a Unicode string 1 character long, containing the "
"character *ch*."
msgstr ""
"``unichr(ch)`` повертає рядок Unicode довжиною 1 символ, що містить символ "
"*ch*."

msgid ""
"``ord(u)``, where *u* is a 1-character regular or Unicode string, returns "
"the number of the character as an integer."
msgstr ""
"``ord(u)``, де *u* — звичайний рядок із 1 символу або Unicode, повертає "
"номер символу як ціле число."

msgid ""
"``unicode(string [, encoding]  [, errors] )`` creates a Unicode string from "
"an 8-bit string.  ``encoding`` is a string naming the encoding to use. The "
"``errors`` parameter specifies the treatment of characters that are invalid "
"for the current encoding; passing ``'strict'`` as the value causes an "
"exception to be raised on any encoding error, while ``'ignore'`` causes "
"errors to be silently ignored and ``'replace'`` uses U+FFFD, the official "
"replacement character, in case of any problems."
msgstr ""
"``unicode(string [, encoding] [, errors] )`` створює рядок Unicode з 8-"
"бітного рядка. ``encoding`` - це рядок із назвою кодування для використання. "
"Параметр ``errors`` визначає обробку символів, недійсних для поточного "
"кодування; передача ``'strict'`` як значення спричиняє виникнення винятку "
"при будь-якій помилці кодування, тоді ``'ignore'`` спричиняє мовчазне "
"ігнорування помилок, а ``'replace'`` використовує U+FFFD, офіційний замінний "
"характер, у разі будь-яких проблем."

msgid ""
"The ``exec`` statement, and various built-ins such as ``eval()``, "
"``getattr()``, and ``setattr()`` will also accept Unicode strings as well as "
"regular strings.  (It's possible that the process of fixing this missed some "
"built-ins; if you find a built-in function that accepts strings but doesn't "
"accept Unicode strings at all, please report it as a bug.)"
msgstr ""
"Оператор ``exec`` і різні вбудовані функції, такі як ``eval()``, "
"``getattr()`` і ``setattr()`` також прийматимуть рядки Unicode, а також "
"звичайні рядки. (Цілком можливо, що під час виправлення цього не вистачало "
"деяких вбудованих функцій; якщо ви знайдете вбудовану функцію, яка приймає "
"рядки, але взагалі не приймає рядки Unicode, повідомте про це як про "
"помилку.)"

msgid ""
"A new module, :mod:`unicodedata`, provides an interface to Unicode character "
"properties.  For example, ``unicodedata.category(u'A')`` returns the 2-"
"character string 'Lu', the 'L' denoting it's a letter, and 'u' meaning that "
"it's uppercase. ``unicodedata.bidirectional(u'\\u0660')`` returns 'AN', "
"meaning that U+0660 is an Arabic number."
msgstr ""
"Новий модуль, :mod:`unicodedata`, надає інтерфейс для властивостей символів "
"Unicode. Наприклад, ``unicodedata.category(u'A')`` повертає 2-символьний "
"рядок 'Lu', 'L' означає, що це літера, і 'u' означає, що це великий регістр. "
"``unicodedata.bidirectional(u'\\u0660')`` повертає 'AN', що означає, що "
"U+0660 є арабським числом."

msgid ""
"The :mod:`codecs` module contains functions to look up existing encodings "
"and register new ones.  Unless you want to implement a new encoding, you'll "
"most often use the ``codecs.lookup(encoding)`` function, which returns a 4-"
"element tuple: ``(encode_func, decode_func, stream_reader, stream_writer)``."
msgstr ""
"Модуль :mod:`codecs` містить функції для пошуку існуючих кодувань і "
"реєстрації нових. Якщо ви не хочете застосувати нове кодування, ви "
"найчастіше використовуватимете функцію ``codecs.lookup(encoding)``, яка "
"повертає 4-елементний кортеж: ``(encode_func, decode_func, stream_reader, "
"stream_writer)``."

msgid ""
"*encode_func* is a function that takes a Unicode string, and returns a 2-"
"tuple ``(string, length)``.  *string* is an 8-bit string containing a "
"portion (perhaps all) of the Unicode string converted into the given "
"encoding, and *length* tells you how much of the Unicode string was "
"converted."
msgstr ""
"*encode_func* — це функція, яка приймає рядок Unicode і повертає 2-кортеж "
"``(рядок, довжина)``. *рядок* — це 8-бітовий рядок, що містить частину "
"(можливо, весь) рядка Юнікод, перетвореного в дане кодування, а *довжина* "
"вказує вам, яку частину рядка Юнікод було перетворено."

msgid ""
"*decode_func* is the opposite of *encode_func*, taking an 8-bit string and "
"returning a 2-tuple ``(ustring, length)``, consisting of the resulting "
"Unicode string *ustring* and the integer *length* telling how much of the 8-"
"bit string was consumed."
msgstr ""
"*decode_func* є протилежністю *encode_func*, беручи 8-бітний рядок і "
"повертаючи 2-кортеж ``(ustring, length)``, що складається з результуючого "
"рядка Unicode *ustring* і цілого числа *length*, що повідомляє, як велика "
"частина 8-бітного рядка була спожита."

msgid ""
"*stream_reader* is a class that supports decoding input from a stream. "
"*stream_reader(file_obj)* returns an object that supports the :meth:`read`, :"
"meth:`readline`, and :meth:`readlines` methods.  These methods will all "
"translate from the given encoding and return Unicode strings."
msgstr ""
"*stream_reader* — це клас, який підтримує декодування вхідних даних із "
"потоку. *stream_reader(file_obj)* повертає об’єкт, який підтримує методи :"
"meth:`read`, :meth:`readline` і :meth:`readlines`. Усі ці методи "
"перекладатимуть із заданого кодування та повертатимуть рядки Unicode."

msgid ""
"*stream_writer*, similarly, is a class that supports encoding output to a "
"stream.  *stream_writer(file_obj)* returns an object that supports the :meth:"
"`write` and :meth:`writelines` methods.  These methods expect Unicode "
"strings, translating them to the given encoding on output."
msgstr ""
"*stream_writer*, аналогічно, є класом, який підтримує кодування виводу в "
"потік. *stream_writer(file_obj)* повертає об’єкт, який підтримує методи :"
"meth:`write` і :meth:`writelines`. Ці методи очікують рядків Unicode, "
"переводячи їх у задане кодування на виході."

msgid ""
"For example, the following code writes a Unicode string into a file,  "
"encoding it as UTF-8::"
msgstr ""
"Наприклад, наступний код записує рядок Unicode у файл, кодуючи його як "
"UTF-8::"

msgid "The following code would then read UTF-8 input from the file::"
msgstr "Наступний код буде читати вхідні дані UTF-8 з файлу:"

msgid ""
"Unicode-aware regular expressions are available through the :mod:`re` "
"module, which has a new underlying implementation called SRE written by "
"Fredrik Lundh of Secret Labs AB."
msgstr ""
"Регулярні вирази з підтримкою Unicode доступні через модуль :mod:`re`, який "
"має нову реалізацію під назвою SRE, написану Фредріком Лундом з Secret Labs "
"AB."

msgid ""
"A ``-U`` command line option was added which causes the Python compiler to "
"interpret all string literals as Unicode string literals. This is intended "
"to be used in testing and future-proofing your Python code, since some "
"future version of Python may drop support for 8-bit strings and provide only "
"Unicode strings."
msgstr ""
"Додано параметр командного рядка ``-U``, який змушує компілятор Python "
"інтерпретувати всі рядкові літерали як рядкові літерали Unicode. Це "
"призначено для тестування та перевірки вашого коду Python на майбутнє, "
"оскільки деякі майбутні версії Python можуть відмовитися від підтримки 8-"
"бітних рядків і надавати лише рядки Unicode."

msgid "List Comprehensions"
msgstr "Розуміння списку"

msgid ""
"Lists are a workhorse data type in Python, and many programs manipulate a "
"list at some point.  Two common operations on lists are to loop over them, "
"and either pick out the elements that meet a certain criterion, or apply "
"some function to each element.  For example, given a list of strings, you "
"might want to pull out all the strings containing a given substring, or "
"strip off trailing whitespace from each line."
msgstr ""
"Списки є основним типом даних у Python, і багато програм маніпулюють списком "
"у певний момент. Дві поширені операції зі списками полягають у проходженні "
"по ним і або виборі елементів, які відповідають певному критерію, або "
"застосуванні певної функції до кожного елемента. Наприклад, маючи список "
"рядків, ви можете вилучити всі рядки, що містять даний підрядок, або "
"видалити кінцеві пробіли з кожного рядка."

msgid ""
"The existing :func:`map` and :func:`filter` functions can be used for this "
"purpose, but they require a function as one of their arguments.  This is "
"fine if there's an existing built-in function that can be passed directly, "
"but if there isn't, you have to create a little function to do the required "
"work, and Python's scoping rules make the result ugly if the little function "
"needs additional information.  Take the first example in the previous "
"paragraph, finding all the strings in the list containing a given "
"substring.  You could write the following to do it::"
msgstr ""
"Існуючі функції :func:`map` і :func:`filter` можна використовувати для цієї "
"мети, але вони потребують функції як один із своїх аргументів. Це добре, "
"якщо існує вбудована функція, яку можна передати напряму, але якщо її немає, "
"вам доведеться створити невелику функцію для виконання необхідної роботи, а "
"правила визначення області Python роблять результат негарним, якщо маленька "
"функція потребує Додаткова інформація. Розглянемо перший приклад із "
"попереднього абзацу, знайшовши всі рядки у списку, що містить заданий "
"підрядок. Щоб це зробити, ви можете написати наступне:"

msgid ""
"Because of Python's scoping rules, a default argument is used so that the "
"anonymous function created by the :keyword:`lambda` expression knows what "
"substring is being searched for.  List comprehensions make this cleaner::"
msgstr ""
"Через правила визначення області Python використовується аргумент за "
"замовчуванням, щоб анонімна функція, створена виразом :keyword:`lambda`, "
"знала, який підрядок шукається. Розуміння списків робить це чистішим::"

msgid "List comprehensions have the form::"
msgstr "Охоплення списків мають вигляд::"

msgid ""
"The :keyword:`!for`...\\ :keyword:`!in` clauses contain the sequences to be "
"iterated over.  The sequences do not have to be the same length, because "
"they are *not* iterated over in parallel, but from left to right; this is "
"explained more clearly in the following paragraphs.  The elements of the "
"generated list will be the successive values of *expression*.  The final :"
"keyword:`!if` clause is optional; if present, *expression* is only evaluated "
"and added to the result if *condition* is true."
msgstr ""
"Речення :keyword:`!for`...\\ :keyword:`!in` містять послідовності, які "
"потрібно повторити. Послідовності не обов’язково мають бути однакової "
"довжини, тому що вони *не* повторюються паралельно, а зліва направо; це "
"більш чітко пояснюється в наступних параграфах. Елементи згенерованого "
"списку будуть послідовними значеннями *виразу*. Останній пункт :keyword:`!"
"if` необов’язковий; якщо присутнє, *вираз* обчислюється та додається до "
"результату, лише якщо *умова* істинна."

msgid ""
"To make the semantics very clear, a list comprehension is equivalent to the "
"following Python code::"
msgstr ""
"Щоб зробити семантику дуже зрозумілою, розуміння списку еквівалентно "
"наступному коду Python:"

msgid ""
"This means that when there are multiple :keyword:`!for`...\\ :keyword:`!in` "
"clauses, the resulting list will be equal to the product of the lengths of "
"all the sequences.  If you have two lists of length 3, the output list is 9 "
"elements long::"
msgstr ""
"Це означає, що коли є кілька пропозицій :keyword:`!for`...\\ :keyword:`!in`, "
"результуючий список дорівнюватиме добутку довжин усіх послідовностей. Якщо у "
"вас є два списки довжиною 3, вихідний список складається з 9 елементів:"

msgid ""
"To avoid introducing an ambiguity into Python's grammar, if *expression* is "
"creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Щоб уникнути неоднозначності в граматиці Python, якщо *вираз* створює "
"кортеж, його потрібно взяти в дужки. Перше розуміння списку нижче є "
"синтаксичною помилкою, тоді як друге є правильним:"

msgid ""
"The idea of list comprehensions originally comes from the functional "
"programming language Haskell (https://www.haskell.org).  Greg Ewing argued "
"most effectively for adding them to Python and wrote the initial list "
"comprehension patch, which was then discussed for a seemingly endless time "
"on the python-dev mailing list and kept up-to-date by Skip Montanaro."
msgstr ""
"Ідея розуміння списків спочатку походить від функціональної мови "
"програмування Haskell (https://www.haskell.org). Ґреґ Юінг найбільш "
"ефективно доводив доцільність додавання їх до Python і написав початковий "
"патч для розуміння списку, який потім, здавалося, нескінченний час "
"обговорювався в списку розсилки python-dev і постійно оновлювався Скіпом "
"Монтанаро."

msgid "Augmented Assignment"
msgstr "Доповнене завдання"

msgid ""
"Augmented assignment operators, another long-requested feature, have been "
"added to Python 2.0.  Augmented assignment operators include ``+=``, ``-=``, "
"``*=``, and so forth.  For example, the statement ``a += 2`` increments the "
"value of the variable  ``a`` by 2, equivalent to the slightly lengthier ``a "
"= a + 2``."
msgstr ""
"До Python 2.0 додано розширені оператори присвоєння, ще одну давно "
"запитувану функцію. Розширені оператори присвоєння включають ``+=``, ``-=``, "
"``*=`` і так далі. Наприклад, оператор ``a += 2`` збільшує значення змінної "
"``a`` на 2, еквівалентно трохи довшому ``a = a + 2``."

msgid ""
"The full list of supported assignment operators is ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=``, ``&=``, ``|=``, ``^=``, ``>>=``, and ``<<=``.  "
"Python classes can override the augmented assignment operators by defining "
"methods named :meth:`__iadd__`, :meth:`__isub__`, etc.  For example, the "
"following :class:`Number` class stores a number and supports using += to "
"create a new instance with an incremented value."
msgstr ""
"Повний список підтримуваних операторів призначення: ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=`` , ``&=``, ``|=``, ``^=``, ``>>=`` і ``<<=``. Класи "
"Python можуть перевизначати розширені оператори присвоювання, визначаючи "
"методи з іменами :meth:`__iadd__`, :meth:`__isub__` тощо. Наприклад, "
"наступний клас :class:`Number` зберігає число та підтримує використання += "
"для створення новий екземпляр із збільшеним значенням."

msgid ""
"The :meth:`__iadd__` special method is called with the value of the "
"increment, and should return a new instance with an appropriately modified "
"value; this return value is bound as the new value of the variable on the "
"left-hand side."
msgstr ""
"Спеціальний метод :meth:`__iadd__` викликається зі значенням приросту та має "
"повертати новий екземпляр із відповідним чином зміненим значенням; це "
"повернуте значення прив’язується як нове значення змінної зліва."

msgid ""
"Augmented assignment operators were first introduced in the C programming "
"language, and most C-derived languages, such as :program:`awk`, C++, Java, "
"Perl, and PHP also support them.  The augmented assignment patch was "
"implemented by Thomas Wouters."
msgstr ""
"Розширені оператори присвоєння вперше були представлені в мові програмування "
"C, і більшість похідних від C мов, таких як :program:`awk`, C++, Java, Perl "
"і PHP, також їх підтримують. Патч доповненого призначення реалізував Томас "
"Воутерс."

msgid "String Methods"
msgstr "Рядкові методи"

msgid ""
"Until now string-manipulation functionality was in the :mod:`string` module, "
"which was usually a front-end for the :mod:`strop` module written in C.  The "
"addition of Unicode posed a difficulty for the :mod:`strop` module, because "
"the functions would all need to be rewritten in order to accept either 8-bit "
"or Unicode strings.  For functions such as :func:`string.replace`, which "
"takes 3 string arguments, that means eight possible permutations, and "
"correspondingly complicated code."
msgstr ""
"До цього часу функціональні можливості обробки рядків були в модулі :mod:"
"`string`, який зазвичай був інтерфейсом для модуля :mod:`strop`, написаного "
"мовою C. Додавання Unicode створювало труднощі для :mod:`strop`, тому що всі "
"функції потрібно було б переписати, щоб приймати 8-бітні рядки або рядки "
"Unicode. Для таких функцій, як :func:`string.replace`, яка приймає 3 рядкові "
"аргументи, це означає вісім можливих перестановок і, відповідно, складний "
"код."

msgid ""
"Instead, Python 2.0 pushes the problem onto the string type, making string "
"manipulation functionality available through methods on both 8-bit strings "
"and Unicode strings.   ::"
msgstr ""
"Натомість Python 2.0 переносить проблему на рядковий тип, роблячи "
"функціональні можливості маніпулювання рядками доступними через методи як "
"для 8-бітних рядків, так і для рядків Unicode. ::"

msgid ""
"One thing that hasn't changed, a noteworthy April Fools' joke "
"notwithstanding, is that Python strings are immutable. Thus, the string "
"methods return new strings, and do not modify the string on which they "
"operate."
msgstr ""
"Одне, незважаючи на першоквітневий жарт, не змінилося, це те, що рядки "
"Python є незмінними. Таким чином, рядкові методи повертають нові рядки і не "
"змінюють рядок, з яким вони працюють."

msgid ""
"The old :mod:`string` module is still around for backwards compatibility, "
"but it mostly acts as a front-end to the new string methods."
msgstr ""
"Старий модуль :mod:`string` все ще доступний для зворотної сумісності, але "
"він здебільшого діє як інтерфейс для нових методів рядків."

msgid ""
"Two methods which have no parallel in pre-2.0 versions, although they did "
"exist in JPython for quite some time, are :meth:`startswith` and :meth:"
"`endswith`. ``s.startswith(t)`` is equivalent to ``s[:len(t)] == t``, while "
"``s.endswith(t)`` is equivalent to ``s[-len(t):] == t``."
msgstr ""
"Два методи, які не мають аналогів у версіях до 2.0, хоча вони існували в "
"JPython досить довго, це :meth:`startswith` і :meth:`endswith`. ``s."
"startswith(t)`` еквівалентно ``s[:len(t)] == t``, тоді як ``s.endswith(t)`` "
"еквівалентно ``s[-len( t):] == t``."

msgid ""
"One other method which deserves special mention is :meth:`join`.  The :meth:"
"`join` method of a string receives one parameter, a sequence of strings, and "
"is equivalent to the :func:`string.join` function from the old :mod:`string` "
"module, with the arguments reversed. In other words, ``s.join(seq)`` is "
"equivalent to the old ``string.join(seq, s)``."
msgstr ""
"Ще одним методом, який заслуговує окремої згадки, є :meth:`join`. Метод :"
"meth:`join` рядка отримує один параметр, послідовність рядків, і є "
"еквівалентом функції :func:`string.join` зі старого модуля :mod:`string`, зі "
"зміненими аргументами. Іншими словами, ``s.join(seq)`` еквівалентний старому "
"``string.join(seq, s)``."

msgid "Garbage Collection of Cycles"
msgstr "Збирання сміття циклів"

msgid ""
"The C implementation of Python uses reference counting to implement garbage "
"collection.  Every Python object maintains a count of the number of "
"references pointing to itself, and adjusts the count as references are "
"created or destroyed.  Once the reference count reaches zero, the object is "
"no longer accessible, since you need to have a reference to an object to "
"access it, and if the count is zero, no references exist any longer."
msgstr ""
"Реалізація Python на C використовує підрахунок посилань для реалізації "
"збирання сміття. Кожен об’єкт Python підтримує підрахунок кількості "
"посилань, що вказують на нього самого, і коригує кількість у міру створення "
"чи знищення посилань. Коли кількість посилань досягає нуля, об’єкт більше не "
"доступний, оскільки для доступу до нього потрібно мати посилання на об’єкт, "
"і якщо кількість посилань дорівнює нулю, посилань більше не існує."

msgid ""
"Reference counting has some pleasant properties: it's easy to understand and "
"implement, and the resulting implementation is portable, fairly fast, and "
"reacts well with other libraries that implement their own memory handling "
"schemes.  The major problem with reference counting is that it sometimes "
"doesn't realise that objects are no longer accessible, resulting in a memory "
"leak.  This happens when there are cycles of references."
msgstr ""
"Підрахунок посилань має деякі приємні властивості: його легко зрозуміти та "
"реалізувати, а результуюча реалізація є портативною, досить швидкою та добре "
"реагує на інші бібліотеки, які реалізують власні схеми обробки пам’яті. "
"Основна проблема з підрахунком посилань полягає в тому, що він іноді не "
"усвідомлює, що об’єкти більше не доступні, що призводить до витоку пам’яті. "
"Це відбувається, коли є цикли посилань."

msgid ""
"Consider the simplest possible cycle,  a class instance which has a "
"reference to itself::"
msgstr ""
"Розглянемо найпростіший можливий цикл, екземпляр класу, який має посилання "
"на самого себе::"

msgid ""
"After the above two lines of code have been executed, the reference count of "
"``instance`` is 2; one reference is from the variable named ``'instance'``, "
"and the other is from the ``myself`` attribute of the instance."
msgstr ""
"Після виконання двох вищезазначених рядків коду кількість посилань "
"``примірника`` дорівнює 2; одне посилання походить від змінної з назвою "
"``'instance'``, а інше — від атрибута ``mysel`` екземпляра."

msgid ""
"If the next line of code is ``del instance``, what happens?  The reference "
"count of ``instance`` is decreased by 1, so it has a reference count of 1; "
"the reference in the ``myself`` attribute still exists.  Yet the instance is "
"no longer accessible through Python code, and it could be deleted.  Several "
"objects can participate in a cycle if they have references to each other, "
"causing all of the objects to be leaked."
msgstr ""
"Що станеться, якщо наступним рядком коду є ``del instance``? Кількість "
"посилань ``примірника`` зменшено на 1, тому він має кількість посилань 1; "
"посилання в атрибуті ``mysel`` все ще існує. Проте екземпляр більше не "
"доступний через код Python, і його можна видалити. Кілька об’єктів можуть "
"брати участь у циклі, якщо вони мають посилання один на одного, що спричиняє "
"витік усіх об’єктів."

msgid ""
"Python 2.0 fixes this problem by periodically executing a cycle detection "
"algorithm which looks for inaccessible cycles and deletes the objects "
"involved. A new :mod:`gc` module provides functions to perform a garbage "
"collection, obtain debugging statistics, and tuning the collector's "
"parameters."
msgstr ""
"Python 2.0 вирішує цю проблему, періодично виконуючи алгоритм виявлення "
"циклу, який шукає недоступні цикли та видаляє залучені об’єкти. Новий "
"модуль :mod:`gc` надає функції для збирання сміття, отримання статистики "
"налагодження та налаштування параметрів збирача."

msgid ""
"Running the cycle detection algorithm takes some time, and therefore will "
"result in some additional overhead.  It is hoped that after we've gotten "
"experience with the cycle collection from using 2.0, Python 2.1 will be able "
"to minimize the overhead with careful tuning.  It's not yet obvious how much "
"performance is lost, because benchmarking this is tricky and depends "
"crucially on how often the program creates and destroys objects.  The "
"detection of cycles can be disabled when Python is compiled, if you can't "
"afford even a tiny speed penalty or suspect that the cycle collection is "
"buggy, by specifying the :option:`!--without-cycle-gc` switch when running "
"the :program:`configure` script."
msgstr ""
"Виконання алгоритму виявлення циклу займає деякий час, а тому призведе до "
"додаткових витрат. Сподіваємося, що після того, як ми отримаємо досвід "
"роботи зі збором циклів від використання 2.0, Python 2.1 зможе мінімізувати "
"накладні витрати завдяки ретельному налаштуванню. Поки що неочевидно, "
"скільки продуктивності втрачається, тому що це порівняльний аналіз є "
"складним і дуже залежить від того, як часто програма створює та знищує "
"об’єкти. Виявлення циклів можна вимкнути під час компіляції Python, якщо ви "
"не можете дозволити собі навіть незначне зниження швидкості або підозрюєте, "
"що збирання циклів є помилковим, вказавши перемикач :option:`!--without-"
"cycle-gc`, коли виконання сценарію :program:`configure`."

msgid ""
"Several people tackled this problem and contributed to a solution.  An early "
"implementation of the cycle detection approach was written by Toby Kelsey.  "
"The current algorithm was suggested by Eric Tiedemann during a visit to "
"CNRI, and Guido van Rossum and Neil Schemenauer wrote two different "
"implementations, which were later integrated by Neil.  Lots of other people "
"offered suggestions along the way; the March 2000 archives of the python-dev "
"mailing list contain most of the relevant discussion, especially in the "
"threads titled \"Reference cycle collection for Python\" and \"Finalization "
"again\"."
msgstr ""
"Кілька людей взялися за цю проблему та зробили свій внесок у її вирішення. "
"Рання реалізація підходу виявлення циклу була написана Тобі Келсі. Поточний "
"алгоритм був запропонований Еріком Тідеманном під час візиту до CNRI, а "
"Гвідо ван Россум і Ніл Шеменауер написали дві різні реалізації, які пізніше "
"були інтегровані Нілом. Багато інших людей пропонували пропозиції на цьому "
"шляху; архіви списку розсилки python-dev за березень 2000 року містять "
"більшість відповідних обговорень, особливо в темах під назвою \"Колекція "
"довідкового циклу для Python\" і \"Знову завершення\"."

msgid "Other Core Changes"
msgstr "Інші основні зміни"

msgid ""
"Various minor changes have been made to Python's syntax and built-in "
"functions. None of the changes are very far-reaching, but they're handy "
"conveniences."
msgstr ""
"У синтаксис і вбудовані функції Python внесено різні незначні зміни. Жодна "
"зі змін не є дуже далекосяжною, але це зручні зручності."

msgid "Minor Language Changes"
msgstr "Незначні зміни мови"

msgid ""
"A new syntax makes it more convenient to call a given function with a tuple "
"of arguments and/or a dictionary of keyword arguments. In Python 1.5 and "
"earlier, you'd use the :func:`apply` built-in function: ``apply(f, args, "
"kw)`` calls the function :func:`f` with the argument tuple *args* and the "
"keyword arguments in the dictionary *kw*.  :func:`apply`  is the same in "
"2.0, but thanks to a patch from Greg Ewing, ``f(*args, **kw)`` is a shorter "
"and clearer way to achieve the same effect.  This syntax is symmetrical with "
"the syntax for defining functions::"
msgstr ""
"Новий синтаксис робить більш зручним виклик певної функції за допомогою "
"кортежу аргументів та/або словника ключових аргументів. У Python 1.5 і "
"раніших версіях ви використовували вбудовану функцію :func:`apply`: "
"``apply(f, args, kw)`` викликає функцію :func:`f` з кортежем аргументів "
"*args* і ключові аргументи в словнику *kw*. :func:`apply` те саме у версії "
"2.0, але завдяки патчу від Грега Юінга, ``f(*args, **kw)`` є коротшим і "
"зрозумілішим способом досягнення того самого ефекту. Цей синтаксис "
"симетричний до синтаксису для визначення функцій:"

msgid ""
"The ``print`` statement can now have its output directed to a file-like "
"object by following the ``print`` with  ``>> file``, similar to the "
"redirection operator in Unix shells. Previously you'd either have to use "
"the :meth:`write` method of the file-like object, which lacks the "
"convenience and simplicity of ``print``, or you could assign a new value to "
"``sys.stdout`` and then restore the old value.  For sending output to "
"standard error, it's much easier to write this::"
msgstr ""
"Оператор ``print`` тепер може мати вихід, спрямований на файлоподібний "
"об’єкт, слідуючи за ``print`` ``>> file``, подібно до оператора "
"перенаправлення в оболонках Unix. Раніше вам потрібно було використовувати "
"метод :meth:`write` файлоподібного об’єкта, якому бракує зручності та "
"простоти ``print``, або ви могли призначити нове значення ``sys.stdout``, а "
"потім відновіть старе значення. Для надсилання виводу до стандартної помилки "
"набагато простіше написати це::"

msgid ""
"Modules can now be renamed on importing them, using the syntax ``import "
"module as name`` or ``from module import name as othername``.  The patch was "
"submitted by Thomas Wouters."
msgstr ""
"Модулі тепер можна перейменовувати під час їх імпорту, використовуючи "
"синтаксис ``імпортувати модуль як ім’я`` або ``з імені імпорту модуля як "
"інше ім’я``. Патч надіслав Томас Воутерс."

msgid ""
"A new format style is available when using the ``%`` operator; '%r' will "
"insert the :func:`repr` of its argument.  This was also added from symmetry "
"considerations, this time for symmetry with the existing '%s' format style, "
"which inserts the :func:`str` of its argument.  For example, ``'%r %s' % "
"('abc', 'abc')`` returns a string containing ``'abc' abc``."
msgstr ""
"Новий стиль формату доступний при використанні оператора ``%``; '%r' "
"вставить :func:`repr` свого аргументу. Це також було додано з міркувань "
"симетрії, цього разу для симетрії з існуючим стилем формату '%s', який "
"вставляє :func:`str` свого аргументу. Наприклад, ``'%r %s' % ('abc', "
"'abc')`` повертає рядок, що містить ``'abc' abc``."

msgid ""
"Previously there was no way to implement a class that overrode Python's "
"built-in :keyword:`in` operator and implemented a custom version.  ``obj in "
"seq`` returns true if *obj* is present in the sequence *seq*; Python "
"computes this by simply trying every index of the sequence until either "
"*obj* is found or an :exc:`IndexError` is encountered.  Moshe Zadka "
"contributed a patch which adds a :meth:`__contains__` magic method for "
"providing a custom implementation for :keyword:`!in`. Additionally, new "
"built-in objects written in C can define what :keyword:`!in` means for them "
"via a new slot in the sequence protocol."
msgstr ""
"Раніше не було можливості реалізувати клас, який замінює вбудований оператор "
"Python :keyword:`in` і реалізовує спеціальну версію. ``obj in seq`` повертає "
"істину, якщо *obj* присутній у послідовності *seq*; Python обчислює це, "
"просто пробуючи кожен індекс послідовності, поки не буде знайдено *obj* або "
"не буде виявлено :exc:`IndexError`. Moshe Zadka вніс патч, який додає "
"магічний метод :meth:`__contains__` для надання спеціальної реалізації для :"
"keyword:`!in`. Крім того, нові вбудовані об’єкти, написані мовою C, можуть "
"визначати, що для них означає :keyword:`!in` через новий слот у протоколі "
"послідовності."

msgid ""
"Earlier versions of Python used a recursive algorithm for deleting objects. "
"Deeply nested data structures could cause the interpreter to fill up the C "
"stack and crash; Christian Tismer rewrote the deletion logic to fix this "
"problem.  On a related note, comparing recursive objects recursed infinitely "
"and crashed; Jeremy Hylton rewrote the code to no longer crash, producing a "
"useful result instead.  For example, after this code::"
msgstr ""
"Попередні версії Python використовували рекурсивний алгоритм для видалення "
"об’єктів. Глибоко вкладені структури даних можуть спричинити заповнення "
"стека C і збій інтерпретатора; Крістіан Тісмер переписав логіку видалення, "
"щоб вирішити цю проблему. У зв’язку з цим, порівняння рекурсивних об’єктів "
"нескінченно рекурсувало і вийшло з ладу; Джеремі Гілтон переписав код, щоб "
"він більше не виходив з ладу, натомість створюючи корисний результат. "
"Наприклад, після цього коду::"

msgid ""
"The comparison ``a==b`` returns true, because the two recursive data "
"structures are isomorphic. See the thread \"trashcan and PR#7\" in the April "
"2000 archives of the python-dev mailing list for the discussion leading up "
"to this implementation, and some useful relevant links.    Note that "
"comparisons can now also raise exceptions. In earlier versions of Python, a "
"comparison operation such as ``cmp(a,b)`` would always produce an answer, "
"even if a user-defined :meth:`__cmp__` method encountered an error, since "
"the resulting exception would simply be silently swallowed."
msgstr ""
"Порівняння ``a==b`` повертає true, оскільки дві рекурсивні структури даних є "
"ізоморфними. Дивіться тему \"trashcan and PR#7\" в архівах списку розсилки "
"python-dev за квітень 2000 року для обговорення, що призвело до цієї "
"реалізації, а також деякі корисні відповідні посилання. Зауважте, що "
"порівняння тепер також можуть створювати винятки. У попередніх версіях "
"Python операція порівняння, наприклад ``cmp(a,b)``, завжди давала відповідь, "
"навіть якщо визначений користувачем метод :meth:`__cmp__` виявив помилку, "
"оскільки результуючий виняток просто мовчки проковтнути."

msgid ""
"Work has been done on porting Python to 64-bit Windows on the Itanium "
"processor, mostly by Trent Mick of ActiveState.  (Confusingly, ``sys."
"platform`` is still ``'win32'`` on Win64 because it seems that for ease of "
"porting, MS Visual C++ treats code as 32 bit on Itanium.) PythonWin also "
"supports Windows CE; see the Python CE page at http://pythonce.sourceforge."
"net/ for more information."
msgstr ""
"Робота над перенесенням Python на 64-розрядну Windows на процесорі Itanium "
"була виконана в основному Трентом Міком з ActiveState. (Для плутанини ``sys."
"platform`` все ще є ``'win32'`` на Win64, тому що здається, що для зручності "
"перенесення MS Visual C++ розглядає код як 32-розрядний на Itanium.) "
"PythonWin також підтримує Windows CE; дивіться сторінку Python CE за адресою "
"http://pythonce.sourceforge.net/ для отримання додаткової інформації."

msgid ""
"Another new platform is Darwin/MacOS X; initial support for it is in Python "
"2.0. Dynamic loading works, if you specify \"configure --with-dyld --with-"
"suffix=.x\". Consult the README in the Python source distribution for more "
"instructions."
msgstr ""
"Ще одна нова платформа — Darwin/MacOS X; початкова підтримка для нього в "
"Python 2.0. Динамічне завантаження працює, якщо ви вкажете \"configure --"
"with-dyld --with-suffix=.x\". Щоб отримати додаткові вказівки, зверніться до "
"файлу README у вихідному коді Python."

msgid ""
"An attempt has been made to alleviate one of Python's warts, the often-"
"confusing :exc:`NameError` exception when code refers to a local variable "
"before the variable has been assigned a value.  For example, the following "
"code raises an exception on the ``print`` statement in both 1.5.2 and 2.0; "
"in 1.5.2 a :exc:`NameError` exception is raised, while 2.0 raises a new :exc:"
"`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass of :"
"exc:`NameError`, so any existing code that expects :exc:`NameError` to be "
"raised should still work. ::"
msgstr ""
"Була зроблена спроба пом’якшити одну з недоліків Python, виняток :exc:"
"`NameError`, який часто викликає плутанину, коли код посилається на локальну "
"змінну до того, як їй було присвоєно значення. Наприклад, наступний код "
"викликає виняток у операторі ``print`` як у 1.5.2, так і 2.0; у 1.5.2 "
"виникає виняток :exc:`NameError`, тоді як у 2.0 виникає новий виняток :exc:"
"`UnboundLocalError`. :exc:`UnboundLocalError` є підкласом :exc:`NameError`, "
"тому будь-який існуючий код, який очікує виклику :exc:`NameError`, має "
"працювати. ::"

msgid ""
"Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been "
"introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised "
"when Python code is found to be improperly indented."
msgstr ""
"Додано два нові винятки, :exc:`TabError` і :exc:`IndentationError`. Обидва "
"вони є підкласами :exc:`SyntaxError` і викликаються, коли виявляється, що "
"код Python має неправильний відступ."

msgid "Changes to Built-in Functions"
msgstr "Зміни вбудованих функцій"

msgid ""
"A new built-in, ``zip(seq1, seq2, ...)``, has been added.  :func:`zip` "
"returns a list of tuples where each tuple contains the i-th element from "
"each of the argument sequences.  The difference between :func:`zip` and "
"``map(None, seq1, seq2)`` is that :func:`map` pads the sequences with "
"``None`` if the sequences aren't all of the same length, while :func:`zip` "
"truncates the returned list to the length of the shortest argument sequence."
msgstr ""
"Додано нову вбудовану функцію ``zip(seq1, seq2, ...)``. :func:`zip` повертає "
"список кортежів, де кожен кортеж містить i-й елемент із кожної послідовності "
"аргументів. Різниця між :func:`zip` і ``map(None, seq1, seq2)`` полягає в "
"тому, що :func:`map` доповнює послідовності ``None``, якщо послідовності не "
"мають однакову довжину , а :func:`zip` скорочує повернутий список до довжини "
"найкоротшої послідовності аргументів."

msgid ""
"The :func:`int` and :func:`long` functions now accept an optional \"base\" "
"parameter when the first argument is a string. ``int('123', 10)`` returns "
"123, while ``int('123', 16)`` returns 291.  ``int(123, 16)`` raises a :exc:"
"`TypeError` exception with the message \"can't convert non-string with "
"explicit base\"."
msgstr ""
"Функції :func:`int` і :func:`long` тепер приймають додатковий параметр "
"\"base\", коли перший аргумент є рядком. ``int('123', 10)`` повертає 123, "
"тоді як ``int('123', 16)`` повертає 291. ``int(123, 16)`` викликає виняток :"
"exc:`TypeError` з повідомленням \"неможливо перетворити не рядок із явною "
"базою\"."

msgid ""
"A new variable holding more detailed version information has been added to "
"the :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, "
"micro, level, serial)`` For example, in a hypothetical 2.0.1beta1, ``sys."
"version_info`` would be ``(2, 0, 1, 'beta', 1)``. *level* is a string such "
"as ``\"alpha\"``, ``\"beta\"``, or ``\"final\"`` for a final release."
msgstr ""
"До модуля :mod:`sys` додано нову змінну, що містить більш детальну "
"інформацію про версію. ``sys.version_info`` — це кортеж ``(major, minor, "
"micro, level, serial)``. Наприклад, у гіпотетичній версії 2.0.1beta1, ``sys."
"version_info`` буде ``(2, 0 , 1, 'бета', 1)``. *level* — це рядок, наприклад "
"``\"alpha\"``, ``\"beta\"`` або ``\"final\"`` для остаточного випуску."

msgid ""
"Dictionaries have an odd new method, ``setdefault(key, default)``, which "
"behaves similarly to the existing :meth:`get` method.  However, if the key "
"is missing, :meth:`setdefault` both returns the value of *default* as :meth:"
"`get` would do, and also inserts it into the dictionary as the value for "
"*key*.  Thus, the following lines of code::"
msgstr ""
"У словниках є дивний новий метод, ``setdefault(key, default)``, який "
"поводиться подібно до існуючого методу :meth:`get`. Однак, якщо ключ "
"відсутній, :meth:`setdefault` повертає значення *default*, як це зробив би :"
"meth:`get`, а також вставляє його до словника як значення для *key*. Таким "
"чином, наступні рядки коду::"

msgid ""
"can be reduced to a single ``return dict.setdefault(key, [])`` statement."
msgstr "можна звести до одного оператора ``return dict.setdefault(key, [])``."

msgid ""
"The interpreter sets a maximum recursion depth in order to catch runaway "
"recursion before filling the C stack and causing a core dump or GPF.. "
"Previously this limit was fixed when you compiled Python, but in 2.0 the "
"maximum recursion depth can be read and modified using :func:`sys."
"getrecursionlimit` and :func:`sys.setrecursionlimit`. The default value is "
"1000, and a rough maximum value for a given platform can be found by running "
"a new script, :file:`Misc/find_recursionlimit.py`."
msgstr ""
"Інтерпретатор встановлює максимальну глибину рекурсії, щоб уловити "
"невимушену рекурсію перед заповненням стека C і створенням дампа ядра або "
"GPF. Раніше це обмеження було виправлено під час компіляції Python, але у "
"2.0 максимальну глибину рекурсії можна прочитати та змінити за допомогою :"
"func:`sys.getrecursionlimit` і :func:`sys.setrecursionlimit`. Стандартним "
"значенням є 1000, а приблизне максимальне значення для даної платформи можна "
"знайти, запустивши новий сценарій :file:`Misc/find_recursionlimit.py`."

msgid "Porting to 2.0"
msgstr "Перенесення на 2.0"

msgid ""
"New Python releases try hard to be compatible with previous releases, and "
"the record has been pretty good.  However, some changes are considered "
"useful enough, usually because they fix initial design decisions that turned "
"out to be actively mistaken, that breaking backward compatibility can't "
"always be avoided. This section lists the changes in Python 2.0 that may "
"cause old Python code to break."
msgstr ""
"Нові випуски Python намагаються бути сумісними з попередніми випусками, і "
"результати були досить хорошими. Однак деякі зміни вважаються досить "
"корисними, зазвичай тому, що вони виправляють початкові дизайнерські "
"рішення, які виявилися активно помилковими, тому порушення зворотної "
"сумісності не завжди можна уникнути. У цьому розділі перераховано зміни в "
"Python 2.0, які можуть призвести до поломки старого коду Python."

msgid ""
"The change which will probably break the most code is tightening up the "
"arguments accepted by some methods.  Some methods would take multiple "
"arguments and treat them as a tuple, particularly various list methods such "
"as :meth:`append` and :meth:`insert`. In earlier versions of Python, if "
"``L`` is a list, ``L.append( 1,2 )`` appends the tuple ``(1,2)`` to the "
"list.  In Python 2.0 this causes a :exc:`TypeError` exception to be raised, "
"with the message: 'append requires exactly 1 argument; 2 given'.  The fix is "
"to simply add an extra set of parentheses to pass both values as a tuple:  "
"``L.append( (1,2) )``."
msgstr ""
"Зміна, яка, ймовірно, найбільше порушить код, полягає в посиленні "
"аргументів, прийнятих деякими методами. Деякі методи приймають кілька "
"аргументів і розглядають їх як кортеж, зокрема різні методи списку, такі як :"
"meth:`append` і :meth:`insert`. У попередніх версіях Python, якщо ``L`` є "
"списком, ``L.append( 1,2 )`` додає кортеж ``(1,2)`` до списку. У Python 2.0 "
"це викликає виняток :exc:`TypeError` із повідомленням: \"додавання вимагає "
"рівно 1 аргументу; 2 дано'. Виправлення полягає в тому, щоб просто додати "
"додатковий набір дужок, щоб передати обидва значення як кортеж: ``L."
"append( (1,2) )``."

msgid ""
"The earlier versions of these methods were more forgiving because they used "
"an old function in Python's C interface to parse their arguments; 2.0 "
"modernizes them to use :func:`PyArg_ParseTuple`, the current argument "
"parsing function, which provides more helpful error messages and treats "
"multi-argument calls as errors.  If you absolutely must use 2.0 but can't "
"fix your code, you can edit :file:`Objects/listobject.c` and define the "
"preprocessor symbol ``NO_STRICT_LIST_APPEND`` to preserve the old behaviour; "
"this isn't recommended."
msgstr ""
"Попередні версії цих методів були більш поблажливими, оскільки вони "
"використовували стару функцію в інтерфейсі C Python для аналізу своїх "
"аргументів; 2.0 модернізує їх для використання :func:`PyArg_ParseTuple`, "
"поточної функції аналізу аргументів, яка надає більш корисні повідомлення "
"про помилки та розглядає багатоаргументні виклики як помилки. Якщо вам "
"абсолютно необхідно використовувати 2.0, але ви не можете виправити свій "
"код, ви можете відредагувати :file:`Objects/listobject.c` і визначити символ "
"препроцесора ``NO_STRICT_LIST_APPEND``, щоб зберегти стару поведінку; це не "
"рекомендується."

msgid ""
"Some of the functions in the :mod:`socket` module are still forgiving in "
"this way.  For example, :func:`socket.connect( ('hostname', 25) )` is the "
"correct form, passing a tuple representing an IP address, but :func:`socket."
"connect( 'hostname', 25 )` also works. :func:`socket.connect_ex` and :func:"
"`socket.bind` are similarly easy-going.  2.0alpha1 tightened these functions "
"up, but because the documentation actually used the erroneous multiple "
"argument form, many people wrote code which would break with the stricter "
"checking.  GvR backed out the changes in the face of public reaction, so for "
"the :mod:`socket` module, the documentation was fixed and the multiple "
"argument form is simply marked as deprecated; it *will* be tightened up "
"again in a future Python version."
msgstr ""
"Деякі функції в модулі :mod:`socket` все ще прощають таким чином. "
"Наприклад, :func:`socket.connect( ('hostname', 25) )` є правильною формою, "
"яка передає кортеж, що представляє IP-адресу, але :func:`socket."
"connect( 'hostname', 25 )` також працює. :func:`socket.connect_ex` і :func:"
"`socket.bind` так само прості. 2.0alpha1 посилив ці функції, але оскільки "
"документація фактично використовувала помилкову форму з декількома "
"аргументами, багато людей писали код, який порушує суворішу перевірку. GvR "
"скасував зміни, незважаючи на реакцію громадськості, тому для модуля :mod:"
"`socket` документацію було виправлено, а форму з кількома аргументами просто "
"позначено як застарілу; його *буде* знову посилено в майбутній версії Python."

msgid ""
"The ``\\x`` escape in string literals now takes exactly 2 hex digits.  "
"Previously it would consume all the hex digits following the 'x' and take "
"the lowest 8 bits of the result, so ``\\x123456`` was equivalent to "
"``\\x56``."
msgstr ""
"Екранування ``\\x`` у рядкових літералах тепер займає рівно 2 шістнадцяткові "
"цифри. Раніше він використовував усі шістнадцяткові цифри після 'x' і брав "
"молодші 8 бітів результату, тому ``\\x123456`` був еквівалентним ``\\x56``."

msgid ""
"The :exc:`AttributeError` and :exc:`NameError` exceptions have a more "
"friendly error message, whose text will be something like ``'Spam' instance "
"has no attribute 'eggs'`` or ``name 'eggs' is not defined``.  Previously the "
"error message was just the missing attribute name ``eggs``, and code written "
"to take advantage of this fact will break in 2.0."
msgstr ""
"Винятки :exc:`AttributeError` і :exc:`NameError` мають більш зрозуміле "
"повідомлення про помилку, текст якого буде приблизно таким, як \"Екземпляр "
"спаму\" не має атрибута \"яйця\" або \"назва \"яйця\" є не визначено``. "
"Раніше повідомленням про помилку було лише відсутнє ім’я атрибута ``яйця``, "
"і код, написаний для використання цього факту, зламається у 2.0."

msgid ""
"Some work has been done to make integers and long integers a bit more "
"interchangeable.  In 1.5.2, large-file support was added for Solaris, to "
"allow reading files larger than 2 GiB; this made the :meth:`tell` method of "
"file objects return a long integer instead of a regular integer.  Some code "
"would subtract two file offsets and attempt to use the result to multiply a "
"sequence or slice a string, but this raised a :exc:`TypeError`.  In 2.0, "
"long integers can be used to multiply or slice a sequence, and it'll behave "
"as you'd intuitively expect it to; ``3L * 'abc'`` produces 'abcabcabc', and "
"``(0,1,2,3)[2L:4L]`` produces (2,3). Long integers can also be used in "
"various contexts where previously only integers were accepted, such as in "
"the :meth:`seek` method of file objects, and in the formats supported by the "
"``%`` operator (``%d``, ``%i``, ``%x``, etc.).  For example, ``\"%d\" % "
"2L**64`` will produce the string ``18446744073709551616``."
msgstr ""
"Було зроблено певну роботу, щоб зробити цілі та довгі цілі трохи більш "
"взаємозамінними. У 1.5.2 була додана підтримка великих файлів для Solaris, "
"щоб дозволити читати файли розміром понад 2 ГіБ; це змусило метод :meth:"
"`tell` файлових об’єктів повертати довге ціле число замість звичайного "
"цілого. Деякий код віднімав би два зміщення файлів і намагався використати "
"результат для множення послідовності або фрагменту рядка, але це викликало :"
"exc:`TypeError`. У версії 2.0 довгі цілі числа можна використовувати для "
"множення або розділення послідовності, і вона працюватиме так, як ви "
"інтуїтивно очікуєте; 3L * 'abc' створює 'abcabcabc', а ``(0,1,2,3)[2L:4L]`` "
"створює (2,3). Довгі цілі також можна використовувати в різних контекстах, "
"де раніше приймалися лише цілі числа, наприклад у методі :meth:`seek` "
"файлових об’єктів, а також у форматах, які підтримуються оператором ``%`` "
"(``%d`` , ``%i``, ``%x`` тощо). Наприклад, ``\"%d\" % 2L**64`` створить "
"рядок ``18446744073709551616``."

msgid ""
"The subtlest long integer change of all is that the :func:`str` of a long "
"integer no longer has a trailing 'L' character, though :func:`repr` still "
"includes it.  The 'L' annoyed many people who wanted to print long integers "
"that looked just like regular integers, since they had to go out of their "
"way to chop off the character.  This is no longer a problem in 2.0, but code "
"which does ``str(longval)[:-1]`` and assumes the 'L' is there, will now lose "
"the final digit."
msgstr ""
"Найтонша зміна довгого цілого числа полягає в тому, що :func:`str` довгого "
"цілого більше не має кінцевого символу 'L', хоча :func:`repr` все ще містить "
"його. \"L\" дратувала багатьох людей, які хотіли надрукувати довгі цілі "
"числа, які виглядали так само, як звичайні цілі числа, оскільки їм "
"доводилося докладати всіх зусиль, щоб відрізати символ. Це більше не є "
"проблемою у 2.0, але код, який виконує ``str(longval)[:-1]`` і припускає, що "
"є 'L', тепер втратить останню цифру."

msgid ""
"Taking the :func:`repr` of a float now uses a different formatting precision "
"than :func:`str`.  :func:`repr` uses ``%.17g`` format string for C's :func:"
"`sprintf`, while :func:`str` uses ``%.12g`` as before.  The effect is that :"
"func:`repr` may occasionally show more decimal places than  :func:`str`, for "
"certain numbers.  For example, the number 8.1 can't be represented exactly "
"in binary, so ``repr(8.1)`` is ``'8.0999999999999996'``, while str(8.1) is "
"``'8.1'``."
msgstr ""
"Прийняття :func:`repr` числа з плаваючою точкою тепер використовує іншу "
"точність форматування, ніж :func:`str`. :func:`repr` використовує рядок "
"формату ``%.17g`` для C :func:`sprintf`, а :func:`str` використовує "
"``%.12g``, як і раніше. Внаслідок цього :func:`repr` іноді може показувати "
"більше десяткових знаків, ніж :func:`str`, для певних чисел. Наприклад, "
"число 8.1 не може бути точно представлене у двійковій формі, тому "
"``repr(8.1)`` має значення ``'8.0999999999999996'``, а str(8.1) — ``'8.1'``."

msgid ""
"The ``-X`` command-line option, which turned all standard exceptions into "
"strings instead of classes, has been removed; the standard exceptions will "
"now always be classes.  The :mod:`exceptions` module containing the standard "
"exceptions was translated from Python to a built-in C module, written by "
"Barry Warsaw and Fredrik Lundh."
msgstr ""
"Параметр командного рядка ``-X``, який перетворював усі стандартні винятки "
"на рядки замість класів, було видалено; стандартними винятками тепер завжди "
"будуть класи. Модуль :mod:`exceptions`, що містить стандартні винятки, було "
"перекладено з Python на вбудований модуль C, написаний Баррі Варшау та "
"Фредріком Лундом."

msgid "Extending/Embedding Changes"
msgstr "Розширення/вбудовування змін"

msgid ""
"Some of the changes are under the covers, and will only be apparent to "
"people writing C extension modules or embedding a Python interpreter in a "
"larger application.  If you aren't dealing with Python's C API, you can "
"safely skip this section."
msgstr ""
"Деякі зміни знаходяться під обкладинками, і вони будуть очевидні лише для "
"людей, які пишуть модулі розширення C або вбудовують інтерпретатор Python у "
"більшу програму. Якщо ви не маєте справу з API C Python, можете сміливо "
"пропустити цей розділ."

msgid ""
"The version number of the Python C API was incremented, so C extensions "
"compiled for 1.5.2 must be recompiled in order to work with 2.0.  On "
"Windows, it's not possible for Python 2.0 to import a third party extension "
"built for Python 1.5.x due to how Windows DLLs work, so Python will raise an "
"exception and the import will fail."
msgstr ""
"Номер версії Python C API було збільшено, тому розширення C, скомпільовані "
"для 1.5.2, потрібно перекомпілювати, щоб працювати з 2.0. У Windows Python "
"2.0 не може імпортувати стороннє розширення, створене для Python 1.5.x, "
"через те, як працюють бібліотеки DLL Windows, тому Python викличе виняток, і "
"імпорт не вдасться."

msgid ""
"Users of Jim Fulton's ExtensionClass module will be pleased to find out that "
"hooks have been added so that ExtensionClasses are now supported by :func:"
"`isinstance` and :func:`issubclass`. This means you no longer have to "
"remember to write code such as ``if type(obj) == myExtensionClass``, but can "
"use the more natural ``if isinstance(obj, myExtensionClass)``."
msgstr ""
"Користувачі модуля ExtensionClass Джима Фултона будуть раді дізнатися, що "
"були додані хуки, завдяки чому ExtensionClasses тепер підтримуються :func:"
"`isinstance` і :func:`issubclass`. Це означає, що вам більше не потрібно "
"пам’ятати про написання такого коду, як ``if type(obj) == "
"myExtensionClass``, а можна використовувати більш природний ``if "
"isinstance(obj, myExtensionClass)``."

msgid ""
"The :file:`Python/importdl.c` file, which was a mass of #ifdefs to support "
"dynamic loading on many different platforms, was cleaned up and reorganised "
"by Greg Stein.  :file:`importdl.c` is now quite small, and platform-specific "
"code has been moved into a bunch of :file:`Python/dynload_\\*.c` files.  "
"Another cleanup: there were also a number of :file:`my\\*.h` files in the "
"Include/ directory that held various portability hacks; they've been merged "
"into a single file, :file:`Include/pyport.h`."
msgstr ""
"Файл :file:`Python/importdl.c`, який являв собою масу #ifdefs для підтримки "
"динамічного завантаження на багатьох різних платформах, був очищений і "
"реорганізований Грегом Стайном. :file:`importdl.c` тепер досить малий, і "
"специфічний для платформи код було переміщено до групи файлів :file:`Python/"
"dynload_\\*.c`. Ще одне очищення: у каталозі Include/ також було кілька "
"файлів :file:`my\\*.h`, які містили різноманітні хаки для перенесення; їх "
"об’єднано в один файл :file:`Include/pyport.h`."

msgid ""
"Vladimir Marangozov's long-awaited malloc restructuring was completed, to "
"make it easy to have the Python interpreter use a custom allocator instead "
"of C's standard :func:`malloc`.  For documentation, read the comments in :"
"file:`Include/pymem.h` and :file:`Include/objimpl.h`.  For the lengthy "
"discussions during which the interface was hammered out, see the web "
"archives of the 'patches' and 'python-dev' lists at python.org."
msgstr ""
"Довгоочікувана реструктуризація malloc Володимира Марангозова була "
"завершена, щоб полегшити використання інтерпретатором Python спеціального "
"розподілювача замість стандартного C :func:`malloc`. Для документації "
"прочитайте коментарі в :file:`Include/pymem.h` і :file:`Include/objimpl.h`. "
"Щоб дізнатися про довгі дискусії, під час яких вироблявся інтерфейс, "
"перегляньте веб-архіви списків \"патчів\" і \"python-dev\" на python.org."

msgid ""
"Recent versions of the GUSI development environment for MacOS support POSIX "
"threads.  Therefore, Python's POSIX threading support now works on the "
"Macintosh.  Threading support using the user-space GNU ``pth`` library was "
"also contributed."
msgstr ""
"Останні версії середовища розробки GUSI для MacOS підтримують потоки POSIX. "
"Таким чином, підтримка потоків Python POSIX тепер працює на Macintosh. Також "
"була надана підтримка потоків за допомогою бібліотеки GNU ``pth`` у просторі "
"користувача."

msgid ""
"Threading support on Windows was enhanced, too.  Windows supports thread "
"locks that use kernel objects only in case of contention; in the common case "
"when there's no contention, they use simpler functions which are an order of "
"magnitude faster.  A threaded version of Python 1.5.2 on NT is twice as slow "
"as an unthreaded version; with the 2.0 changes, the difference is only 10%.  "
"These improvements were contributed by Yakov Markovitch."
msgstr ""
"Також покращено підтримку потоків у Windows. Windows підтримує блокування "
"потоків, які використовують об’єкти ядра лише у випадку конфлікту; у "
"звичайному випадку, коли немає суперечок, вони використовують простіші "
"функції, які на порядок швидші. Потокова версія Python 1.5.2 на NT вдвічі "
"повільніша за безпотокову версію; зі змінами 2.0 різниця становить лише 10%. "
"Ці вдосконалення вніс Яків Маркович."

msgid ""
"Python 2.0's source now uses only ANSI C prototypes, so compiling Python now "
"requires an ANSI C compiler, and can no longer be done using a compiler that "
"only supports K&R C."
msgstr ""
"Вихідні коди Python 2.0 тепер використовують лише прототипи ANSI C, тому для "
"компіляції Python тепер потрібен компілятор ANSI C, і його більше неможливо "
"виконати за допомогою компілятора, який підтримує лише K&R C."

msgid ""
"Previously the Python virtual machine used 16-bit numbers in its bytecode, "
"limiting the size of source files.  In particular, this affected the maximum "
"size of literal lists and dictionaries in Python source; occasionally people "
"who are generating Python code would run into this limit.  A patch by "
"Charles G. Waldman raises the limit from ``2**16`` to ``2**32``."
msgstr ""
"Раніше віртуальна машина Python використовувала 16-бітні числа у своєму байт-"
"коді, обмежуючи розмір вихідних файлів. Зокрема, це вплинуло на максимальний "
"розмір списків літералів і словників у вихідних кодах Python; час від часу "
"люди, які генерують код Python, стикаються з цим обмеженням. Патч від "
"Charles G. Waldman підвищує ліміт з ``2**16`` до ``2**32``."

msgid ""
"Three new convenience functions intended for adding constants to a module's "
"dictionary at module initialization time were added: :func:"
"`PyModule_AddObject`, :func:`PyModule_AddIntConstant`, and :func:"
"`PyModule_AddStringConstant`.  Each of these functions takes a module "
"object, a null-terminated C string containing the name to be added, and a "
"third argument for the value to be assigned to the name.  This third "
"argument is, respectively, a Python object, a C long, or a C string."
msgstr ""
"Додано три нові зручні функції, призначені для додавання констант до "
"словника модуля під час ініціалізації модуля: :func:`PyModule_AddObject`, :"
"func:`PyModule_AddIntConstant` і :func:`PyModule_AddStringConstant`. Кожна з "
"цих функцій приймає об’єкт модуля, рядок C із нульовим символом, що містить "
"ім’я, яке потрібно додати, і третій аргумент для значення, яке буде "
"присвоєно імені. Цей третій аргумент є, відповідно, об’єктом Python, довгим "
"C або рядком C."

msgid ""
"A wrapper API was added for Unix-style signal handlers. :func:`PyOS_getsig` "
"gets a signal handler and :func:`PyOS_setsig` will set a new handler."
msgstr ""
"Було додано API оболонки для обробників сигналів у стилі Unix. :func:"
"`PyOS_getsig` отримує обробник сигналу, а :func:`PyOS_setsig` встановить "
"новий обробник."

msgid "Distutils: Making Modules Easy to Install"
msgstr "Distutils: полегшення встановлення модулів"

msgid ""
"Before Python 2.0, installing modules was a tedious affair -- there was no "
"way to figure out automatically where Python is installed, or what compiler "
"options to use for extension modules.  Software authors had to go through an "
"arduous ritual of editing Makefiles and configuration files, which only "
"really work on Unix and leave Windows and MacOS unsupported.  Python users "
"faced wildly differing installation instructions which varied between "
"different extension packages, which made administering a Python installation "
"something of  a chore."
msgstr ""
"До Python 2.0 встановлення модулів було нудною справою — не було можливості "
"автоматично визначити, де встановлено Python, або які параметри компілятора "
"використовувати для модулів розширення. Авторам програмного забезпечення "
"довелося пройти через важкий ритуал редагування файлів Makefile та "
"конфігураційних файлів, які справді працюють лише в Unix, а Windows і MacOS "
"не підтримуються. Користувачі Python зіткнулися з надзвичайно різними "
"інструкціями встановлення, які відрізнялися між різними пакетами розширень, "
"що робило адміністрування встановлення Python чимось на зразок клопітку."

msgid ""
"The SIG for distribution utilities, shepherded by Greg Ward, has created the "
"Distutils, a system to make package installation much easier.  They form "
"the :mod:`distutils` package, a new part of Python's standard library. In "
"the best case, installing a Python module from source will require the same "
"steps: first you simply mean unpack the tarball or zip archive, and the run "
"\"``python setup.py install``\".  The platform will be automatically "
"detected, the compiler will be recognized, C extension modules will be "
"compiled, and the distribution installed into the proper directory.  "
"Optional command-line arguments provide more control over the installation "
"process, the distutils package offers many places to override defaults -- "
"separating the build from the install, building or installing in non-default "
"directories, and more."
msgstr ""
"SIG для розповсюджувальних утиліт, очолюваний Грегом Уордом, створив "
"Distutils, систему, яка значно полегшує встановлення пакетів. Вони утворюють "
"пакет :mod:`distutils`, нову частину стандартної бібліотеки Python. У "
"найкращому випадку інсталяція модуля Python із вихідного коду вимагатиме тих "
"самих кроків: спочатку ви просто маєте на увазі розпакування архіву tarball "
"або zip і запустіть \"``python setup.py install``\". Платформа буде "
"автоматично визначена, компілятор буде розпізнано, модулі розширення C "
"будуть скомпільовані, а дистрибутив встановлено у відповідний каталог. "
"Необов’язкові аргументи командного рядка забезпечують більше контролю над "
"процесом інсталяції, пакет distutils пропонує багато місць для заміни "
"значень за замовчуванням – відокремлення збірки від інсталяції, збірка або "
"встановлення в каталогах, що не є типовими, тощо."

msgid ""
"In order to use the Distutils, you need to write a :file:`setup.py` script.  "
"For the simple case, when the software contains only .py files, a minimal :"
"file:`setup.py` can be just a few lines long::"
msgstr ""
"Щоб використовувати Distutils, вам потрібно написати сценарій :file:`setup."
"py`. У простому випадку, коли програмне забезпечення містить лише файли .py, "
"мінімальний файл :file:`setup.py` може складатися лише з кількох рядків::"

msgid ""
"The :file:`setup.py` file isn't much more complicated if the software "
"consists of a few packages::"
msgstr ""
"Файл :file:`setup.py` не є набагато складнішим, якщо програмне забезпечення "
"складається з кількох пакетів::"

msgid ""
"A C extension can be the most complicated case; here's an example taken from "
"the PyXML package::"
msgstr ""
"Розширення C може бути найскладнішим випадком; ось приклад, взятий з пакета "
"PyXML::"

msgid ""
"The Distutils can also take care of creating source and binary "
"distributions. The \"sdist\" command, run by \"``python setup.py sdist``', "
"builds a source distribution such as :file:`foo-1.0.tar.gz`. Adding new "
"commands isn't difficult, \"bdist_rpm\" and \"bdist_wininst\" commands have "
"already been contributed to create an RPM distribution and a Windows "
"installer for the software, respectively.  Commands to create other "
"distribution formats such as Debian packages and Solaris :file:`.pkg` files "
"are in various stages of development."
msgstr ""
"Distutils також може подбати про створення вихідних і двійкових "
"дистрибутивів. Команда \"sdist\", яку запускає \"`` python setup.py "
"sdist``\", створює вихідний дистрибутив, такий як :file:`foo-1.0.tar.gz`. "
"Додавати нові команди не складно, \"bdist_rpm\" Команди \"bdist_wininst\" і "
"\"bdist_wininst\" вже були використані для створення дистрибутива RPM і "
"інсталятора Windows для програмного забезпечення відповідно. ."

msgid ""
"All this is documented in a new manual, *Distributing Python Modules*, that "
"joins the basic set of Python documentation."
msgstr ""
"Усе це задокументовано в новому посібнику *Розповсюдження модулів Python*, "
"який доповнює базовий набір документації Python."

msgid "XML Modules"
msgstr "Модулі XML"

msgid ""
"Python 1.5.2 included a simple XML parser in the form of the :mod:`xmllib` "
"module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two "
"different interfaces for processing XML have become common: SAX2 (version 2 "
"of the Simple API for XML) provides an event-driven interface with some "
"similarities to :mod:`xmllib`, and the DOM (Document Object Model) provides "
"a tree-based interface, transforming an XML document into a tree of nodes "
"that can be traversed and modified.  Python 2.0 includes a SAX2 interface "
"and a stripped-down DOM interface as part of the :mod:`xml` package. Here we "
"will give a brief overview of these new interfaces; consult the Python "
"documentation or the source code for complete details. The Python XML SIG is "
"also working on improved documentation."
msgstr ""
"Python 1.5.2 містив простий аналізатор XML у формі модуля :mod:`xmllib`, "
"наданого Sjoerd Mullender. Починаючи з випуску 1.5.2, два різні інтерфейси "
"для обробки XML стали поширеними: SAX2 (версія 2 Simple API для XML) надає "
"інтерфейс, керований подіями, дещо подібний до :mod:`xmllib`, і DOM (об’єкт "
"документа). Model) надає інтерфейс на основі дерева, перетворюючи XML-"
"документ на дерево вузлів, які можна переглядати та змінювати. Python 2.0 "
"містить інтерфейс SAX2 і скорочений інтерфейс DOM як частину пакета :mod:"
"`xml`. Тут ми дамо короткий огляд цих нових інтерфейсів; зверніться до "
"документації Python або вихідного коду для отримання повної інформації. "
"Python XML SIG також працює над покращенням документації."

msgid "SAX2 Support"
msgstr "Підтримка SAX2"

msgid ""
"SAX defines an event-driven interface for parsing XML.  To use SAX, you must "
"write a SAX handler class.  Handler classes inherit from various classes "
"provided by SAX, and override various methods that will then be called by "
"the XML parser.  For example, the :meth:`startElement` and :meth:"
"`endElement` methods are called for every starting and end tag encountered "
"by the parser, the :meth:`characters` method is called for every chunk of "
"character data, and so forth."
msgstr ""
"SAX визначає керований подіями інтерфейс для аналізу XML. Щоб "
"використовувати SAX, ви повинні написати клас обробника SAX. Класи "
"обробників успадковуються від різних класів, наданих SAX, і перевизначають "
"різні методи, які потім будуть викликані аналізатором XML. Наприклад, "
"методи :meth:`startElement` і :meth:`endElement` викликаються для кожного "
"початкового та кінцевого тегів, які зустрічає аналізатор, метод :meth:"
"`characters` викликається для кожної частини символьних даних, і тому вперед."

msgid ""
"The advantage of the event-driven approach is that the whole document "
"doesn't have to be resident in memory at any one time, which matters if you "
"are processing really huge documents.  However, writing the SAX handler "
"class can get very complicated if you're trying to modify the document "
"structure in some elaborate way."
msgstr ""
"Перевага керованого подіями підходу полягає в тому, що весь документ не "
"повинен постійно зберігатися в пам’яті в будь-який момент часу, що має "
"значення, якщо ви обробляєте дійсно великі документи. Однак написання класу "
"обробника SAX може стати дуже складним, якщо ви намагаєтесь модифікувати "
"структуру документа якимось складним чином."

msgid ""
"For example, this little example program defines a handler that prints a "
"message for every starting and ending tag, and then parses the file :file:"
"`hamlet.xml` using it::"
msgstr ""
"Наприклад, цей маленький приклад програми визначає обробник, який друкує "
"повідомлення для кожного початкового та кінцевого тегу, а потім аналізує "
"файл :file:`hamlet.xml`, використовуючи його:"

msgid ""
"For more information, consult the Python documentation, or the XML HOWTO at "
"http://pyxml.sourceforge.net/topics/howto/xml-howto.html."
msgstr ""
"Для отримання додаткової інформації зверніться до документації Python або "
"XML HOWTO на http://pyxml.sourceforge.net/topics/howto/xml-howto.html."

msgid "DOM Support"
msgstr "Підтримка DOM"

msgid ""
"The Document Object Model is a tree-based representation for an XML "
"document.  A top-level :class:`Document` instance is the root of the tree, "
"and has a single child which is the top-level :class:`Element` instance. "
"This :class:`Element` has children nodes representing character data and any "
"sub-elements, which may have further children of their own, and so forth.  "
"Using the DOM you can traverse the resulting tree any way you like, access "
"element and attribute values, insert and delete nodes, and convert the tree "
"back into XML."
msgstr ""
"Об’єктна модель документа – це деревовидне представлення документа XML. "
"Екземпляр :class:`Document` верхнього рівня є коренем дерева та має єдину "
"дочірню примірник :class:`Element` верхнього рівня. Цей :class:`Element` має "
"дочірні вузли, що представляють символьні дані та будь-які піделементи, які "
"можуть мати інших власних дочірніх елементів тощо. Використовуючи DOM, ви "
"можете переглядати отримане дерево будь-яким способом, отримувати доступ до "
"значень елементів і атрибутів, вставляти та видаляти вузли та перетворювати "
"дерево назад у XML."

msgid ""
"The DOM is useful for modifying XML documents, because you can create a DOM "
"tree, modify it by adding new nodes or rearranging subtrees, and then "
"produce a new XML document as output.  You can also construct a DOM tree "
"manually and convert it to XML, which can be a more flexible way of "
"producing XML output than simply writing ``<tag1>``...\\ ``</tag1>`` to a "
"file."
msgstr ""
"DOM корисний для модифікації XML-документів, оскільки ви можете створити "
"дерево DOM, змінити його, додавши нові вузли або перевпорядкувавши "
"піддерева, а потім створити новий XML-документ як результат. Ви також можете "
"побудувати дерево DOM вручну та перетворити його на XML, що може бути більш "
"гнучким способом створення виводу XML, ніж просто запис ``<tag1>``...\\ ``</"
"tag1>`` у файл."

msgid ""
"The DOM implementation included with Python lives in the :mod:`xml.dom."
"minidom` module.  It's a lightweight implementation of the Level 1 DOM with "
"support for XML namespaces.  The  :func:`parse` and :func:`parseString` "
"convenience functions are provided for generating a DOM tree::"
msgstr ""
"Реалізація DOM, включена в Python, знаходиться в модулі :mod:`xml.dom."
"minidom`. Це спрощена реалізація DOM рівня 1 із підтримкою просторів імен "
"XML. Зручні функції :func:`parse` і :func:`parseString` надаються для "
"створення дерева DOM::"

msgid ""
"``doc`` is a :class:`Document` instance.  :class:`Document`, like all the "
"other DOM classes such as :class:`Element` and :class:`Text`, is a subclass "
"of the :class:`Node` base class.  All the nodes in a DOM tree therefore "
"support certain common methods, such as :meth:`toxml` which returns a string "
"containing the XML representation of the node and its children.  Each class "
"also has special methods of its own; for example, :class:`Element` and :"
"class:`Document` instances have a method to find all child elements with a "
"given tag name. Continuing from the previous 2-line example::"
msgstr ""
"``doc`` є екземпляром :class:`Document`. :class:`Document`, як і всі інші "
"класи DOM, такі як :class:`Element` і :class:`Text`, є підкласом базового "
"класу :class:`Node`. Тому всі вузли в дереві DOM підтримують певні загальні "
"методи, такі як :meth:`toxml`, який повертає рядок, що містить XML-"
"представлення вузла та його дочірніх елементів. Кожен клас також має власні "
"спеціальні методи; наприклад, екземпляри :class:`Element` і :class:"
"`Document` мають метод пошуку всіх дочірніх елементів із вказаною назвою "
"тегу. Продовжуючи попередній 2-рядковий приклад::"

msgid "For the *Hamlet* XML file, the above few lines output::"
msgstr "Для XML-файлу *Hamlet* наведені вище кілька рядків виводять::"

msgid ""
"The root element of the document is available as ``doc.documentElement``, "
"and its children can be easily modified by deleting, adding, or removing "
"nodes::"
msgstr ""
"Кореневий елемент документа доступний як ``doc.documentElement``, і його "
"дочірні елементи можна легко змінити шляхом видалення, додавання або "
"вилучення вузлів:"

msgid ""
"Again, I will refer you to the Python documentation for a complete listing "
"of the different :class:`Node` classes and their various methods."
msgstr ""
"Знову ж таки, я відсилаю вас до документації Python, щоб отримати повний "
"перелік різних класів :class:`Node` та їхніх різних методів."

msgid "Relationship to PyXML"
msgstr "Відношення до PyXML"

msgid ""
"The XML Special Interest Group has been working on XML-related Python code "
"for a while.  Its code distribution, called PyXML, is available from the "
"SIG's web pages at https://www.python.org/community/sigs/current/xml-sig. "
"The PyXML distribution also used the package name ``xml``.  If you've "
"written programs that used PyXML, you're probably wondering about its "
"compatibility with the 2.0 :mod:`xml` package."
msgstr ""
"Група спеціальних інтересів XML деякий час працювала над кодом Python, "
"пов’язаним із XML. Його розповсюдження коду під назвою PyXML доступне на веб-"
"сторінках SIG за адресою https://www.python.org/community/sigs/current/xml-"
"sig. Дистрибутив PyXML також використовував назву пакета ``xml``. Якщо ви "
"писали програми, які використовували PyXML, ви, ймовірно, цікавитеся його "
"сумісністю з пакетом 2.0 :mod:`xml`."

msgid ""
"The answer is that Python 2.0's :mod:`xml` package isn't compatible with "
"PyXML, but can be made compatible by installing a recent version PyXML.  "
"Many applications can get by with the XML support that is included with "
"Python 2.0, but more complicated applications will require that the full "
"PyXML package will be installed.  When installed, PyXML versions 0.6.0 or "
"greater will replace the :mod:`xml` package shipped with Python, and will be "
"a strict superset of the standard package, adding a bunch of additional "
"features.  Some of the additional features in PyXML include:"
msgstr ""
"Відповідь полягає в тому, що пакет :mod:`xml` Python 2.0 несумісний з PyXML, "
"але його можна зробити сумісним, встановивши останню версію PyXML. Багато "
"програм можуть обійтися підтримкою XML, яка включена в Python 2.0, але "
"складніші програми вимагають інсталяції повного пакета PyXML. Після "
"встановлення PyXML версії 0.6.0 або новішої замінить пакет :mod:`xml`, який "
"постачається разом із Python, і стане строгим доповненням до стандартного "
"пакета, додаючи купу додаткових функцій. Деякі з додаткових функцій у PyXML "
"включають:"

msgid "4DOM, a full DOM implementation from FourThought, Inc."
msgstr "4DOM, повна реалізація DOM від FourThought, Inc."

msgid "The xmlproc validating parser, written by Lars Marius Garshol."
msgstr "Парсер перевірки xmlproc, написаний Ларсом Маріусом Гаршолом."

msgid "The :mod:`sgmlop` parser accelerator module, written by Fredrik Lundh."
msgstr "Модуль прискорювача парсера :mod:`sgmlop`, написаний Фредріком Лундом."

msgid "Module changes"
msgstr "Зміни модуля"

msgid ""
"Lots of improvements and bugfixes were made to Python's extensive standard "
"library; some of the affected modules include :mod:`readline`, :mod:"
"`ConfigParser`, :mod:`cgi`, :mod:`calendar`, :mod:`posix`, :mod:`readline`, :"
"mod:`xmllib`, :mod:`aifc`, :mod:`chunk, wave`, :mod:`random`, :mod:`shelve`, "
"and :mod:`nntplib`.  Consult the CVS logs for the exact patch-by-patch "
"details."
msgstr ""
"Було зроблено багато покращень і виправлень помилок у великій стандартній "
"бібліотеці Python; деякі з постраждалих модулів включають :mod:`readline`, :"
"mod:`ConfigParser`, :mod:`cgi`, :mod:`calendar`, :mod:`posix`, :mod:"
"`readline`, :mod:`xmllib`, :mod:`aifc`, :mod:`chunk, wave`, :mod:`random`, :"
"mod:`shelve` і :mod:`nntplib`. Зверніться до журналів CVS для отримання "
"точних деталей кожного патча."

msgid ""
"Brian Gallew contributed OpenSSL support for the :mod:`socket` module.  "
"OpenSSL is an implementation of the Secure Socket Layer, which encrypts the "
"data being sent over a socket.  When compiling Python, you can edit :file:"
"`Modules/Setup` to include SSL support, which adds an additional function to "
"the :mod:`socket` module: ``socket.ssl(socket, keyfile, certfile)``, which "
"takes a socket object and returns an SSL socket.  The :mod:`httplib` and :"
"mod:`urllib` modules were also changed to support ``https://`` URLs, though "
"no one has implemented FTP or SMTP over SSL."
msgstr ""
"Брайан Галлью надав підтримку OpenSSL для модуля :mod:`socket`. OpenSSL — це "
"реалізація рівня захищених сокетів, який шифрує дані, що надсилаються через "
"сокет. Під час компіляції Python ви можете редагувати :file:`Modules/Setup`, "
"щоб включити підтримку SSL, яка додає додаткову функцію до модуля :mod:"
"`socket`: ``socket.ssl(socket, keyfile, certfile)``, який приймає об’єкт "
"сокета та повертає сокет SSL. Модулі :mod:`httplib` і :mod:`urllib` також "
"були змінені для підтримки URL-адрес ``https://``, хоча ніхто не реалізував "
"FTP або SMTP через SSL."

msgid ""
"The :mod:`httplib` module has been rewritten by Greg Stein to support "
"HTTP/1.1. Backward compatibility with the 1.5 version of :mod:`httplib` is "
"provided, though using HTTP/1.1 features such as pipelining will require "
"rewriting code to use a different set of interfaces."
msgstr ""
"Модуль :mod:`httplib` був переписаний Грегом Стайном для підтримки HTTP/1.1. "
"Забезпечується зворотна сумісність із версією 1.5 :mod:`httplib`, хоча "
"використання функцій HTTP/1.1, таких як конвеєр, потребуватиме переписування "
"коду для використання іншого набору інтерфейсів."

msgid ""
"The :mod:`Tkinter` module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and "
"support for the older 7.x versions has been dropped.  The Tkinter module now "
"supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh "
"contributed an optimization which makes operations like ``create_line`` and "
"``create_polygon`` much faster, especially when using lots of coordinates."
msgstr ""
"Модуль :mod:`Tkinter` тепер підтримує Tcl/Tk версії 8.1, 8.2 або 8.3, а "
"підтримку старіших версій 7.x припинено. Модуль Tkinter тепер підтримує "
"відображення рядків Unicode у віджетах Tk. Крім того, Фредрік Лунд вніс "
"оптимізацію, яка робить такі операції, як ``create_line`` і "
"``create_polygon``, набагато швидшими, особливо при використанні великої "
"кількості координат."

msgid ""
"The :mod:`curses` module has been greatly extended, starting from Oliver "
"Andrich's enhanced version, to provide many additional functions from "
"ncurses and SYSV curses, such as colour, alternative character set support, "
"pads, and mouse support.  This means the module is no longer compatible with "
"operating systems that only have BSD curses, but there don't seem to be any "
"currently maintained OSes that fall into this category."
msgstr ""
"Модуль :mod:`curses` було значно розширено, починаючи з розширеної версії "
"Олівера Андріча, щоб забезпечити багато додаткових функцій від ncurses і "
"проклять SYSV, таких як колір, підтримка альтернативного набору символів, "
"підтримка панелей і миші. Це означає, що модуль більше не сумісний з "
"операційними системами, які мають лише прокляття BSD, але, здається, на "
"даний момент немає жодної ОС, яка підпадає під цю категорію."

msgid ""
"As mentioned in the earlier discussion of 2.0's Unicode support, the "
"underlying implementation of the regular expressions provided by the :mod:"
"`re` module has been changed.  SRE, a new regular expression engine written "
"by Fredrik Lundh and partially funded by Hewlett Packard, supports matching "
"against both 8-bit strings and Unicode strings."
msgstr ""
"Як згадувалося в попередньому обговоренні підтримки Unicode 2.0, базову "
"реалізацію регулярних виразів, які надає модуль :mod:`re`, було змінено. "
"SRE, нова система регулярних виразів, написана Фредріком Лундом і частково "
"фінансована Hewlett Packard, підтримує зіставлення як з 8-бітними рядками, "
"так і з рядками Unicode."

msgid "New modules"
msgstr "Нові модулі"

msgid ""
"A number of new modules were added.  We'll simply list them with brief "
"descriptions; consult the 2.0 documentation for the details of a particular "
"module."
msgstr ""
"Додано ряд нових модулів. Ми просто перерахуємо їх із короткими описами; "
"зверніться до документації 2.0, щоб дізнатися більше про конкретний модуль."

msgid ""
":mod:`atexit`:  For registering functions to be called before the Python "
"interpreter exits. Code that currently sets ``sys.exitfunc`` directly should "
"be changed to  use the :mod:`atexit` module instead, importing :mod:`atexit` "
"and calling :func:`atexit.register` with  the function to be called on exit. "
"(Contributed by Skip Montanaro.)"
msgstr ""
":mod:`atexit`: для реєстрації функцій, які будуть викликані до завершення "
"роботи інтерпретатора Python. Код, який наразі безпосередньо встановлює "
"``sys.exitfunc``, слід змінити, щоб замість нього використовувати модуль :"
"mod:`atexit`, імпортуючи :mod:`atexit` і викликаючи :func:`atexit.register` "
"із функцією, яку потрібно викликати на виході. (Надав Скіп Монтанаро.)"

msgid ""
":mod:`codecs`, :mod:`encodings`, :mod:`unicodedata`:  Added as part of the "
"new Unicode support."
msgstr ""
":mod:`codecs`, :mod:`encodings`, :mod:`unicodedata`: додано як частину нової "
"підтримки Unicode."

msgid ""
":mod:`filecmp`: Supersedes the old :mod:`cmp`, :mod:`cmpcache` and :mod:"
"`dircmp` modules, which have now become deprecated. (Contributed by Gordon "
"MacMillan and Moshe Zadka.)"
msgstr ""
":mod:`filecmp`: Замінює старі модулі :mod:`cmp`, :mod:`cmpcache` і :mod:"
"`dircmp`, які вже стали застарілими. (Надано Гордоном Макмілланом і Моше "
"Цадка.)"

msgid ""
":mod:`gettext`: This module provides internationalization (I18N) and "
"localization (L10N) support for Python programs by providing an interface to "
"the GNU gettext message catalog library. (Integrated by Barry Warsaw, from "
"separate contributions by Martin  von Löwis, Peter Funk, and James "
"Henstridge.)"
msgstr ""
":mod:`gettext`: Цей модуль забезпечує підтримку інтернаціоналізації (I18N) і "
"локалізації (L10N) для програм Python, надаючи інтерфейс до бібліотеки "
"каталогу повідомлень GNU gettext. (Інтегровано Баррі Варшау, з окремих "
"внесків Мартіна фон Льовіса, Пітера Функа та Джеймса Генстріджа.)"

msgid ""
":mod:`linuxaudiodev`: Support for the :file:`/dev/audio` device on Linux, a "
"twin to the existing :mod:`sunaudiodev` module. (Contributed by Peter Bosch, "
"with fixes by Jeremy Hylton.)"
msgstr ""
":mod:`linuxaudiodev`: Підтримка пристрою :file:`/dev/audio` в Linux, "
"аналогічно існуючому модулю :mod:`sunaudiodev`. (Надано Пітером Бошем, з "
"виправленнями Джеремі Гілтоном.)"

msgid ""
":mod:`mmap`: An interface to memory-mapped files on both Windows and Unix.  "
"A file's contents can be mapped directly into memory, at which point it "
"behaves like a mutable string, so its contents can be read and modified.  "
"They can even be passed to functions that expect ordinary strings, such as "
"the :mod:`re` module. (Contributed by Sam Rushing, with some extensions by A."
"M. Kuchling.)"
msgstr ""
":mod:`mmap`: Інтерфейс для файлів із відображенням пам’яті як у Windows, так "
"і в Unix. Вміст файлу можна відобразити безпосередньо в пам’яті, після чого "
"він поводиться як змінний рядок, тому його вміст можна читати та змінювати. "
"Їх можна навіть передати функціям, які очікують звичайних рядків, наприклад, "
"модулю :mod:`re`. (Надано Семом Рашингом, з деякими розширеннями А. М. "
"Кухлінгом.)"

msgid ""
":mod:`pyexpat`: An interface to the Expat XML parser. (Contributed by Paul "
"Prescod.)"
msgstr ""
":mod:`pyexpat`: інтерфейс для аналізатора Expat XML. (Надав Пол Прескод.)"

msgid ""
":mod:`robotparser`: Parse a :file:`robots.txt` file, which is used for "
"writing web spiders that politely avoid certain areas of a web site.  The "
"parser accepts the contents of a :file:`robots.txt` file, builds a set of "
"rules from it, and can then answer questions about the fetchability of a "
"given URL.  (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`robotparser`: Проаналізуйте файл :file:`robots.txt`, який "
"використовується для написання веб-павуків, які ввічливо уникають певних "
"частин веб-сайту. Синтаксичний аналізатор приймає вміст файлу :file:`robots."
"txt`, створює з нього набір правил, а потім може відповісти на запитання "
"щодо доступності певної URL-адреси. (Надав Скіп Монтанаро.)"

msgid ""
":mod:`tabnanny`: A module/script to  check Python source code for ambiguous "
"indentation. (Contributed by Tim Peters.)"
msgstr ""
":mod:`tabnanny`: Модуль/скрипт для перевірки вихідного коду Python на "
"неоднозначні відступи. (Надав Тім Пітерс.)"

msgid ""
":mod:`UserString`: A base class useful for deriving objects that behave like "
"strings."
msgstr ""
":mod:`UserString`: базовий клас, корисний для отримання об’єктів, які "
"поводяться як рядки."

msgid ""
":mod:`webbrowser`: A module that provides a platform independent way to "
"launch a web browser on a specific URL. For each platform, various browsers "
"are tried in a specific order. The user can alter which browser is launched "
"by setting the *BROWSER* environment variable.  (Originally inspired by Eric "
"S. Raymond's patch to :mod:`urllib` which added similar functionality, but "
"the final module comes from code originally  implemented by Fred Drake as :"
"file:`Tools/idle/BrowserControl.py`, and adapted for the standard library by "
"Fred.)"
msgstr ""
":mod:`webbrowser`: модуль, який забезпечує незалежний від платформи спосіб "
"запуску веб-браузера за певною URL-адресою. Для кожної платформи різні "
"браузери пробуються в певному порядку. Користувач може змінити браузер, який "
"запускається, встановивши змінну середовища *BROWSER*. (Спочатку натхненний "
"патчем Еріка С. Реймонда до :mod:`urllib`, який додав подібну "
"функціональність, але остаточний модуль походить від коду, спочатку "
"реалізованого Фредом Дрейком як :file:`Tools/idle/BrowserControl.py`, і "
"адаптованого для стандартна бібліотека Фреда.)"

msgid ""
":mod:`_winreg`: An interface to the Windows registry.  :mod:`_winreg` is an "
"adaptation of functions that have been part of PythonWin since 1995, but has "
"now been added to the core  distribution, and enhanced to support Unicode. :"
"mod:`_winreg` was written by Bill Tutt and Mark Hammond."
msgstr ""
":mod:`_winreg`: Інтерфейс до реєстру Windows. :mod:`_winreg` — це адаптація "
"функцій, які були частиною PythonWin з 1995 року, але тепер їх додано до "
"основного дистрибутива та покращено для підтримки Unicode. :mod:`_winreg` "
"був написаний Біллом Таттом і Марком Хаммондом."

msgid ""
":mod:`zipfile`: A module for reading and writing ZIP-format archives.  These "
"are archives produced by :program:`PKZIP` on DOS/Windows or :program:`zip` "
"on Unix, not to be confused with :program:`gzip`\\ -format files (which are "
"supported by the :mod:`gzip` module) (Contributed by James C. Ahlstrom.)"
msgstr ""
":mod:`zipfile`: Модуль для читання та запису архівів ZIP-формату. Це архіви, "
"створені :program:`PKZIP` у DOS/Windows або :program:`zip` в Unix, не "
"плутати з файлами у форматі :program:`gzip`\\ (які підтримуються модулем :"
"mod:`gzip`) (надано Джеймсом К. Алстромом.)"

msgid ""
":mod:`imputil`: A module that provides a simpler way for writing customized "
"import hooks, in comparison to the existing :mod:`ihooks` module.  "
"(Implemented by Greg Stein, with much discussion on python-dev along the "
"way.)"
msgstr ""
":mod:`imputil`: модуль, який забезпечує простіший спосіб написання "
"налаштованих хуків імпорту порівняно з існуючим модулем :mod:`ihooks`. "
"(Реалізовано Грегом Стайном, з великим обговоренням python-dev на цьому "
"шляху.)"

msgid "IDLE Improvements"
msgstr "Покращення IDLE"

msgid ""
"IDLE is the official Python cross-platform IDE, written using Tkinter. "
"Python 2.0 includes IDLE 0.6, which adds a number of new features and "
"improvements.  A partial list:"
msgstr ""
"IDLE — це офіційна кросплатформна IDE Python, написана за допомогою Tkinter. "
"Python 2.0 містить IDLE 0.6, який додає низку нових функцій і покращень. "
"Неповний список:"

msgid ""
"UI improvements and optimizations, especially in the area of syntax "
"highlighting and auto-indentation."
msgstr ""
"Покращення та оптимізація інтерфейсу користувача, особливо в області "
"підсвічування синтаксису та автоматичного відступу."

msgid ""
"The class browser now shows more information, such as the top level "
"functions in a module."
msgstr ""
"Переглядач класів тепер показує більше інформації, наприклад функції "
"верхнього рівня в модулі."

msgid ""
"Tab width is now a user settable option. When opening an existing Python "
"file, IDLE automatically detects the indentation conventions, and adapts."
msgstr ""
"Ширина вкладки тепер доступна користувачеві. Під час відкриття існуючого "
"файлу Python IDLE автоматично визначає правила відступів і адаптує їх."

msgid ""
"There is now support for calling browsers on various platforms, used to open "
"the Python documentation in a browser."
msgstr ""
"Тепер існує підтримка виклику браузерів на різних платформах, які "
"використовуються для відкриття документації Python у браузері."

msgid ""
"IDLE now has a command line, which is largely similar to  the vanilla Python "
"interpreter."
msgstr ""
"У IDLE тепер є командний рядок, який багато в чому схожий на ванільний "
"інтерпретатор Python."

msgid "Call tips were added in many places."
msgstr "У багатьох місцях додано підказки щодо дзвінків."

msgid "IDLE can now be installed as a package."
msgstr "IDLE тепер можна встановити як пакет."

msgid "In the editor window, there is now a line/column bar at the bottom."
msgstr "Тепер у вікні редактора внизу є рядок/стовпець."

msgid ""
"Three new keystroke commands: Check module (:kbd:`Alt-F5`), Import module (:"
"kbd:`F5`) and Run script (:kbd:`Ctrl-F5`)."
msgstr ""
"Три нові команди натискання клавіш: перевірити модуль (:kbd:`Alt-F5`), "
"імпортувати модуль (:kbd:`F5`) і запустити сценарій (:kbd:`Ctrl-F5`)."

msgid "Deleted and Deprecated Modules"
msgstr "Видалені та застарілі модулі"

msgid ""
"A few modules have been dropped because they're obsolete, or because there "
"are now better ways to do the same thing.  The :mod:`stdwin` module is gone; "
"it was for a platform-independent windowing toolkit that's no longer "
"developed."
msgstr ""
"Кілька модулів було вилучено, оскільки вони застаріли, або тому, що тепер є "
"кращі способи зробити те саме. Модуль :mod:`stdwin` зник; це було для "
"незалежного від платформи інструментарію вікон, який більше не розробляється."

msgid ""
"A number of modules have been moved to the :file:`lib-old` subdirectory: :"
"mod:`cmp`, :mod:`cmpcache`, :mod:`dircmp`, :mod:`dump`,  :mod:`find`, :mod:"
"`grep`, :mod:`packmail`,  :mod:`poly`, :mod:`util`, :mod:`whatsound`, :mod:"
"`zmod`.  If you have code which relies on a module  that's been moved to :"
"file:`lib-old`, you can simply add that directory to ``sys.path``   to get "
"them back, but you're encouraged to update any code that uses these modules."
msgstr ""
"Кілька модулів переміщено до підкаталогу :file:`lib-old`: :mod:`cmp`, :mod:"
"`cmpcache`, :mod:`dircmp`, :mod:`dump`, :mod:`find`, :mod:`grep`, :mod:"
"`packmail`, :mod:`poly`, :mod:`util`, :mod:`whatsound`, :mod:`zmod`. Якщо у "
"вас є код, який покладається на модуль, який було переміщено до :file:`lib-"
"old`, ви можете просто додати цей каталог до ``sys.path``, щоб отримати їх "
"назад, але вам рекомендується оновити будь-який код який використовує ці "
"модулі."

msgid "Acknowledgements"
msgstr "Подяки"

msgid ""
"The authors would like to thank the following people for offering "
"suggestions on various drafts of this article: David Bolen, Mark Hammond, "
"Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, "
"Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil "
"Schemenauer, and Russ Schmidt."
msgstr ""
"Автори хотіли б подякувати наступним людям за пропозиції щодо різних "
"чернеток цієї статті: Девід Болен, Марк Хаммонд, Грег Хаузер, Джеремі "
"Гілтон, Фредрік Лунд, Детлеф Ланнерт, Ааз Марух, Скіп Монтанаро, Володимир "
"Марангозов, Тобіас Ползін, Гвідо ван Россум, Ніл Шеменауер і Расс Шмідт."
