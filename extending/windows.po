# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Building C and C++ Extensions on Windows"
msgstr "Створення розширень C і C++ у Windows"

msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"У цій главі коротко пояснюється, як створити модуль розширення Windows для "
"Python за допомогою Microsoft Visual C++, а далі надається більш детальна "
"довідкова інформація про те, як це працює. Пояснювальний матеріал корисний "
"як для Windows-програміста, який навчається створювати розширення Python, "
"так і для Unix-програміста, зацікавленого у створенні програмного "
"забезпечення, яке можна успішно створювати як на Unix, так і на Windows."

msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"Авторам модулів рекомендується використовувати підхід distutils для "
"створення модулів розширення замість описаного в цьому розділі. Вам все одно "
"знадобиться компілятор C, який використовувався для створення Python; "
"зазвичай Microsoft Visual C++."

msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"У цьому розділі згадується кілька імен файлів, які включають закодований "
"номер версії Python. Ці назви файлів представлені номером версії, показаним "
"як ``XY``; на практиці ``'X'`` буде номером основної версії, а ``'Y''`` буде "
"номером другорядної версії випуску Python, з яким ви працюєте. Наприклад, "
"якщо ви використовуєте Python 2.2.1, ``XY`` насправді буде ``22``."

msgid "A Cookbook Approach"
msgstr "Підхід з кулінарної книги"

msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the :mod:`distutils` package to control the build "
"process, or do things manually.  The distutils approach works well for most "
"extensions; documentation on using :mod:`distutils` to build and package "
"extension modules is available in :ref:`distutils-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Існує два підходи до створення модулів розширення у Windows, як і в Unix: "
"використовувати пакет :mod:`distutils`, щоб контролювати процес збирання, "
"або виконувати дії вручну. Підхід distutils добре працює для більшості "
"розширень; документація щодо використання :mod:`distutils` для створення та "
"пакування модулів розширення доступна в :ref:`distutils-index`. Якщо ви "
"виявите, що вам справді потрібно щось робити вручну, можливо, буде корисно "
"вивчити файл проекту для модуля стандартної бібліотеки :source:`winsound "
"<PCbuild/winsound.vcxproj>`."

msgid "Differences Between Unix and Windows"
msgstr "Відмінності між Unix і Windows"

msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"Unix і Windows використовують абсолютно різні парадигми для завантаження "
"коду під час виконання. Перш ніж спробувати створити модуль, який можна "
"динамічно завантажувати, ознайомтеся з тим, як працює ваша система."

msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"В Unix файл спільного об’єкта (:file:`.so`) містить код, який буде "
"використовуватися програмою, а також назви функцій і даних, які вона очікує "
"знайти в програмі. Коли файл приєднується до програми, усі посилання на ці "
"функції та дані в коді файлу змінюються, щоб вказувати на фактичні місця в "
"програмі, де функції та дані розміщені в пам’яті. По суті, це операція "
"посилання."

msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"У Windows файл бібліотеки динамічного компонування (:file:`.dll`) не має "
"висячих посилань. Натомість доступ до функцій або даних відбувається через "
"таблицю пошуку. Тому код DLL не потрібно виправляти під час виконання, щоб "
"посилатися на пам’ять програми; замість цього код уже використовує таблицю "
"пошуку DLL, і таблиця пошуку змінюється під час виконання, щоб вказувати на "
"функції та дані."

msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"В Unix існує лише один тип файлу бібліотеки (:file:`.a`), який містить код "
"із кількох об’єктних файлів (:file:`.o`). Під час етапу зв’язування для "
"створення файлу спільного об’єкта (:file:`.so`) компонувальник може виявити, "
"що він не знає, де визначено ідентифікатор. Компонувальник шукатиме його в "
"об’єктних файлах у бібліотеках; якщо він знайде його, він включить увесь код "
"із цього об’єктного файлу."

msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"У Windows існує два типи бібліотек: статична та імпортована (обидві "
"називаються :file:`.lib`). Статична бібліотека схожа на файл Unix :file:`."
"a`; він містить код, який слід включити за необхідності. Бібліотека імпорту "
"в основному використовується лише для того, щоб переконати компонувальник у "
"тому, що певний ідентифікатор є законним і буде присутній у програмі, коли "
"DLL завантажується. Таким чином, компонувальник використовує інформацію з "
"бібліотеки імпорту для створення таблиці пошуку для використання "
"ідентифікаторів, які не включені в DLL. Коли програму або DLL пов’язано, "
"може бути створена бібліотека імпорту, яку потрібно буде використовувати для "
"всіх майбутніх DLL, які залежать від символів у програмі чи DLL."

msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"Припустімо, ви створюєте два модулі динамічного завантаження, B і C, які "
"мають спільно використовувати ще один блок коду A. В Unix ви *не* передаєте :"
"file:`A.a` компонувальнику для :file:`B.so` і :file:`C.so`; це призвело б до "
"того, що його було б включено двічі, так що B і C мали б кожен свою копію. У "
"Windows збірка :file:`A.dll` також створить :file:`A.lib`. Ви *передаєте* :"
"file:`A.lib` компонувальнику для B і C. :file:`A.lib` не містить коду; він "
"просто містить інформацію, яка буде використана під час виконання для "
"доступу до коду A."

msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"У Windows використання бібліотеки імпорту схоже на використання ``import "
"spam``; він надає вам доступ до імен спаму, але не створює окремої копії. В "
"Unix зв’язування з бібліотекою більше схоже на ``імпорт спаму *``; він "
"створює окрему копію."

msgid "Using DLLs in Practice"
msgstr "Використання DLL на практиці"

msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"Windows Python побудовано на Microsoft Visual C++; використання інших "
"компіляторів може працювати, а може і не працювати. Решта цього розділу "
"стосується MSVC++."

msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"Під час створення DLL у Windows ви повинні передати :file:`pythonXY.lib` до "
"компонувальника. Щоб створити дві бібліотеки DLL, spam і ni (яка "
"використовує функції C, знайдені в спамі), ви можете використати такі "
"команди:"

msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"Перша команда створила три файли: :file:`spam.obj`, :file:`spam.dll` і :file:"
"`spam.lib`. :file:`Spam.dll` не містить жодних функцій Python (таких як :c:"
"func:`PyArg_ParseTuple`), але він знає, як знайти код Python завдяки :file:"
"`pythonXY.lib`."

msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"Друга команда створила :file:`ni.dll` (і :file:`.obj` і :file:`.lib`), який "
"вміє знаходити потрібні функції в спамі, а також у виконуваному файлі Python."

msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"Не кожен ідентифікатор експортується до таблиці пошуку. Якщо ви хочете, щоб "
"будь-які інші модулі (включно з Python) могли бачити ваші ідентифікатори, "
"вам потрібно сказати ``_declspec(dllexport)``, як у ``void "
"_declspec(dllexport) initspam(void)`` або ``PyObject _declspec(dllexport) "
"*NiGetSpamData(void)``."

msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries."
msgstr ""
"Developer Studio додасть багато бібліотек для імпорту, які вам насправді не "
"потрібні, додавши близько 100K до вашого виконуваного файлу. Щоб позбутися "
"їх, скористайтеся діалоговим вікном \"Параметри проекту\", вкладкою "
"\"Посилання\", щоб указати *ігнорувати стандартні бібліотеки*. Додайте "
"правильний :file:`msvcrtxx.lib` до списку бібліотек."
