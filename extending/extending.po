# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "Розширення Python за допомогою C або C++"

#: ../../extending/extending.rst:10
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be"
" done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr ""
"Доволі легко додати нові вбудовані модулі до Python, якщо ви знаєте, як "
"програмувати на C. Такі :dfn:`extension modules` можуть робити дві речі, які"
" не можна зробити безпосередньо в Python: вони можуть реалізувати нові "
"вбудовані модулі. -in типи об'єктів, і вони можуть викликати функції "
"бібліотеки C і системні виклики."

#: ../../extending/extending.rst:15
msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most"
" aspects of the Python run-time system.  The Python API is incorporated in a"
" C source file by including the header ``\"Python.h\"``."
msgstr ""
"Для підтримки розширень API Python (інтерфейс прикладного програмування) "
"визначає набір функцій, макросів і змінних, які надають доступ до більшості "
"аспектів системи виконання Python. API Python включено у вихідний файл C "
"шляхом включення заголовка ``\"Python.h\"``."

#: ../../extending/extending.rst:20
msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr ""
"Компіляція модуля розширення залежить від його цільового використання, а "
"також від налаштування вашої системи; подробиці наведено в наступних "
"розділах."

#: ../../extending/extending.rst:25
msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""
"Інтерфейс розширення C є специфічним для CPython, а модулі розширення не "
"працюють в інших реалізаціях Python. У багатьох випадках можна уникнути "
"написання розширень C і зберегти переносимість на інші реалізації. "
"Наприклад, якщо ви використовуєте виклик функцій бібліотеки C або системних "
"викликів, вам слід розглянути можливість використання модуля :mod:`ctypes` "
"або бібліотеки `cffi <https://cffi.readthedocs.io/>`_ замість написання "
"спеціального коду C. Ці модулі дозволяють писати код Python для взаємодії з "
"кодом C і є більш переносимими між реалізаціями Python, ніж написання та "
"компіляція модуля розширення C."

#: ../../extending/extending.rst:40
msgid "A Simple Example"
msgstr "Простий приклад"

#: ../../extending/extending.rst:42
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty"
" Python fans...) and let's say we want to create a Python interface to the C"
" library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""
"Давайте створимо модуль розширення під назвою ``spam`` (улюблена їжа "
"шанувальників Monty Python...) і, скажімо, ми хочемо створити інтерфейс "
"Python для функції бібліотеки C :c:func:`system` [#]_ . Ця функція приймає "
"рядок символів із нулем у кінці як аргумент і повертає ціле число. Ми "
"хочемо, щоб цю функцію можна було викликати з Python наступним чином:"

#: ../../extending/extending.rst:48
msgid ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"
msgstr ""

#: ../../extending/extending.rst:53
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called "
":file:`spammodule.c`; if the module name is very long, like ``spammify``, "
"the module name can be just :file:`spammify.c`.)"
msgstr ""
"Почніть із створення файлу :file:`spammodule.c`. (Історично склалося так, що"
" якщо модуль називається ``спам``, файл C, що містить його реалізацію, "
"називається :file:`spammodule.c`; якщо назва модуля дуже довга, наприклад "
"``spammify``, назва модуля може бути просто :file:`spammify.c`.)"

#: ../../extending/extending.rst:58
msgid "The first two lines of our file can be::"
msgstr "Перші два рядки нашого файлу можуть бути:"

#: ../../extending/extending.rst:60 ../../extending/extending.rst:663
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""

#: ../../extending/extending.rst:63
msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr ""
"який залучає API Python (ви можете додати коментар із описом призначення "
"модуля та повідомлення про авторські права, якщо хочете)."

#: ../../extending/extending.rst:68
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before"
" any standard headers are included."
msgstr ""
"Оскільки Python може визначати деякі визначення попереднього процесора, які "
"впливають на стандартні заголовки в деяких системах, ви *мусите* включити "
":file:`Python.h` перед тим, як включити будь-які стандартні заголовки."

#: ../../extending/extending.rst:72
msgid ""
"``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` should"
" be used in some APIs instead of ``int``. It is not necessary since Python "
"3.13, but we keep it here for backward compatibility. See :ref:`arg-parsing-"
"string-and-buffers` for a description of this macro."
msgstr ""

#: ../../extending/extending.rst:77
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py``"
" or ``PY``, except those defined in standard header files. For convenience, "
"and since they are used extensively by the Python interpreter, "
"``\"Python.h\"`` includes a few standard header files: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, and ``<stdlib.h>``.  If the latter header "
"file does not exist on your system, it declares the functions "
":c:func:`malloc`, :c:func:`free` and :c:func:`realloc` directly."
msgstr ""
"Усі видимі користувачем символи, визначені :file:`Python.h`, мають префікс "
"``Py`` або ``PY``, за винятком тих, що визначені у стандартних файлах "
"заголовків. Для зручності та оскільки вони широко використовуються "
"інтерпретатором Python, ``\"Python.h\"`` містить кілька стандартних файлів "
"заголовків: ``<stdio.h>``, ``<string.h>``, ``<errno.h>``, і ``<stdlib.h>``. "
"Якщо останнього файлу заголовка не існує у вашій системі, він безпосередньо "
"оголошує функції :c:func:`malloc`, :c:func:`free` і :c:func:`realloc`."

#: ../../extending/extending.rst:85
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"Наступне, що ми додаємо до нашого файлу модуля, це функція C, яка буде "
"викликана, коли буде обчислено вираз Python ``spam.system(string)`` "
"(незабаром ми побачимо, як вона буде викликана):"

#: ../../extending/extending.rst:89
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:101
msgid ""
"There is a straightforward translation from the argument list in Python (for"
" example, the single expression ``\"ls -l\"``) to the arguments passed to "
"the C function.  The C function always has two arguments, conventionally "
"named *self* and *args*."
msgstr ""
"Існує прямий переклад зі списку аргументів у Python (наприклад, один вираз "
"``\"ls -l\"``) в аргументи, передані функції C. Функція C завжди має два "
"аргументи, умовно названі *self* і *args*."

#: ../../extending/extending.rst:106
msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr ""
"Аргумент *self* вказує на об’єкт модуля для функцій рівня модуля; для методу"
" він вказував би на екземпляр об’єкта."

#: ../../extending/extending.rst:109
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"Аргумент *args* буде вказівником на об’єкт кортежу Python, що містить "
"аргументи. Кожен елемент кортежу відповідає аргументу в списку аргументів "
"виклику. Аргументи є об’єктами Python --- щоб щось робити з ними в нашій "
"функції C, ми повинні перетворити їх на значення C. Функція "
":c:func:`PyArg_ParseTuple` в API Python перевіряє типи аргументів і "
"перетворює їх на значення C. Він використовує рядок шаблону для визначення "
"необхідних типів аргументів, а також типів змінних C, у яких зберігатимуться"
" перетворені значення. Про це пізніше."

#: ../../extending/extending.rst:118
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return ``NULL`` immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` повертає істину (не нуль), якщо всі аргументи "
"мають правильний тип і його компоненти зберігаються в змінних, адреси яких "
"передано. Він повертає false (нуль), якщо було передано недійсний список "
"аргументів. В останньому випадку він також викликає відповідний виняток, щоб"
" функція, що викликає, могла негайно повернути ``NULL`` (як ми бачили в "
"прикладі)."

#: ../../extending/extending.rst:128
msgid "Intermezzo: Errors and Exceptions"
msgstr "Intermezzo: помилки та винятки"

#: ../../extending/extending.rst:130
msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually ``-1`` or a ``NULL`` pointer).  Exception information "
"is stored in three members of the interpreter's thread state.  These are "
"``NULL`` if there is no exception.  Otherwise they are the C equivalents of "
"the members of the Python tuple returned by :meth:`sys.exc_info`.  These are"
" the exception type, exception instance, and a traceback object.  It is "
"important to know about them to understand how errors are passed around."
msgstr ""
"Важлива конвенція в інтерпретаторі Python полягає в наступному: коли функція"
" виходить з ладу, вона повинна встановити умову винятку та повернути "
"значення помилки (зазвичай ``-1`` або ``NULL`` покажчик). Інформація про "
"винятки зберігається в трьох членах стану потоку інтерпретатора. Це "
"``NULL``, якщо немає винятку. В іншому випадку вони є еквівалентами C членів"
" кортежу Python, які повертає :meth:`sys.exc_info`. Це тип винятку, "
"екземпляр винятку та об’єкт трасування. Важливо знати про них, щоб "
"зрозуміти, як передаються помилки."

#: ../../extending/extending.rst:139
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr ""
"API Python визначає низку функцій для встановлення різних типів винятків."

#: ../../extending/extending.rst:141
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"Найпоширенішим є :c:func:`PyErr_SetString`. Його аргументами є об’єкт "
"винятку та рядок C. Об’єкт винятку зазвичай є попередньо визначеним "
"об’єктом, наприклад :c:data:`PyExc_ZeroDivisionError`. Рядок C вказує на "
"причину помилки, перетворюється на об’єкт рядка Python і зберігається як "
"\"пов’язане значення\" винятку."

#: ../../extending/extending.rst:147
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an"
" exception argument and constructs the associated value by inspection of the"
" global variable :c:data:`errno`.  The most general function is "
":c:func:`PyErr_SetObject`, which takes two object arguments, the exception "
"and its associated value.  You don't need to :c:func:`Py_INCREF` the objects"
" passed to any of these functions."
msgstr ""
"Іншою корисною функцією є :c:func:`PyErr_SetFromErrno`, яка приймає лише "
"аргумент винятку та створює пов’язане значення шляхом перевірки глобальної "
"змінної :c:data:`errno`. Найбільш загальною функцією є "
":c:func:`PyErr_SetObject`, яка приймає два аргументи об’єкта, виняток і "
"пов’язане з ним значення. Вам не потрібно :c:func:`Py_INCREF` об’єкти, "
"передані в будь-яку з цих функцій."

#: ../../extending/extending.rst:154
msgid ""
"You can test non-destructively whether an exception has been set with "
":c:func:`PyErr_Occurred`.  This returns the current exception object, or "
"``NULL`` if no exception has occurred.  You normally don't need to call "
":c:func:`PyErr_Occurred` to see whether an error occurred in a function "
"call, since you should be able to tell from the return value."
msgstr ""
"За допомогою :c:func:`PyErr_Occurred` можна неруйнівним чином перевірити, чи"
" встановлено виняток. Це повертає поточний об’єкт винятку або ``NULL``, якщо"
" винятку не сталося. Зазвичай вам не потрібно викликати "
":c:func:`PyErr_Occurred`, щоб перевірити, чи сталася помилка під час виклику"
" функції, оскільки ви зможете визначити це за значенням, що повертається."

#: ../../extending/extending.rst:160
msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually ``NULL`` or ``-1``)."
"  It should *not* call one of the ``PyErr_*`` functions --- one has already "
"been called by *g*. *f*'s caller is then supposed to also return an error "
"indication to *its* caller, again *without* calling ``PyErr_*``, and so on "
"--- the most detailed cause of the error was already reported by the "
"function that first detected it.  Once the error reaches the Python "
"interpreter's main loop, this aborts the currently executing Python code and"
" tries to find an exception handler specified by the Python programmer."
msgstr ""

#: ../../extending/extending.rst:170
msgid ""
"(There are situations where a module can actually give a more detailed error"
" message by calling another ``PyErr_*`` function, and in such cases it is "
"fine to do so.  As a general rule, however, this is not necessary, and can "
"cause information about the cause of the error to be lost: most operations "
"can fail for a variety of reasons.)"
msgstr ""

#: ../../extending/extending.rst:176
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went "
"wrong)."
msgstr ""
"Щоб проігнорувати виняток, встановлений невдалим викликом функції, умову "
"виключення потрібно явно очистити, викликавши :c:func:`PyErr_Clear`. Єдиний "
"раз, коли C-код повинен викликати :c:func:`PyErr_Clear`, це якщо він не хоче"
" передавати помилку інтерпретатору, а хоче обробити її повністю сам "
"(можливо, спробувавши щось інше або вдаючи, що нічого не пішло не так). )."

#: ../../extending/extending.rst:182
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the"
" direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call "
":c:func:`PyErr_NoMemory` and return a failure indicator itself.  All the "
"object-creating functions (for example, :c:func:`PyLong_FromLong`) already "
"do this, so this note is only relevant to those who call :c:func:`malloc` "
"directly."
msgstr ""
"Кожен невдалий виклик :c:func:`malloc` має бути перетворений на виняток --- "
"прямий виклик :c:func:`malloc` (або :c:func:`realloc`) повинен викликати "
":c:func:`PyErr_NoMemory` і повертає сам індикатор помилки. Усі функції "
"створення об’єктів (наприклад, :c:func:`PyLong_FromLong`) уже це роблять, "
"тому ця примітка актуальна лише для тих, хто викликає :c:func:`malloc` "
"безпосередньо."

#: ../../extending/extending.rst:188
msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"Також зауважте, що, за винятком :c:func:`PyArg_ParseTuple` та друзів, "
"функції, які повертають цілочисельний статус, зазвичай повертають додатне "
"значення або нуль у разі успіху та ``-1`` у разі невдачі, як системні "
"виклики Unix."

#: ../../extending/extending.rst:192
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or "
":c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"Нарешті, будьте обережні, щоб очистити сміття (за допомогою викликів "
":c:func:`Py_XDECREF` або :c:func:`Py_DECREF` для об’єктів, які ви вже "
"створили), коли ви повертаєте індикатор помилки!"

#: ../../extending/extending.rst:196
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course,"
" you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError`"
" to mean that a file couldn't be opened (that should probably be "
":c:data:`PyExc_OSError`). If something's wrong with the argument list, the "
":c:func:`PyArg_ParseTuple` function usually raises "
":c:data:`PyExc_TypeError`.  If you have an argument whose value must be in a"
" particular range or must satisfy other conditions, "
":c:data:`PyExc_ValueError` is appropriate."
msgstr ""

#: ../../extending/extending.rst:206
msgid ""
"You can also define a new exception that is unique to your module. For this,"
" you usually declare a static object variable at the beginning of your "
"file::"
msgstr ""
"Ви також можете визначити новий виняток, унікальний для вашого модуля. Для "
"цього ви зазвичай оголошуєте змінну статичного об’єкта на початку вашого "
"файлу::"

#: ../../extending/extending.rst:209
msgid "static PyObject *SpamError;"
msgstr ""

#: ../../extending/extending.rst:211
msgid ""
"and initialize it in your module's initialization function "
"(:c:func:`!PyInit_spam`) with an exception object::"
msgstr ""

#: ../../extending/extending.rst:214
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    if (PyModule_AddObjectRef(m, \"error\", SpamError) < 0) {\n"
"        Py_CLEAR(SpamError);\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:233
msgid ""
"Note that the Python name for the exception object is :exc:`!spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"``NULL``), described in :ref:`bltin-exceptions`."
msgstr ""

#: ../../extending/extending.rst:238
msgid ""
"Note also that the :c:data:`!SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the"
" class is needed to ensure that it will not be discarded, causing "
":c:data:`!SpamError` to become a dangling pointer. Should it become a "
"dangling pointer, C code which raises the exception could cause a core dump "
"or other unintended side effects."
msgstr ""

#: ../../extending/extending.rst:245
msgid ""
"We discuss the use of :c:macro:`PyMODINIT_FUNC` as a function return type "
"later in this sample."
msgstr ""

#: ../../extending/extending.rst:248
msgid ""
"The :exc:`!spam.error` exception can be raised in your extension module "
"using a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ""

#: ../../extending/extending.rst:251
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"System command failed\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:271
msgid "Back to the Example"
msgstr "Повернемося до прикладу"

#: ../../extending/extending.rst:273
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr ""
"Повертаючись до нашого прикладу функції, тепер ви зможете зрозуміти цей "
"оператор:"

#: ../../extending/extending.rst:276
msgid ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"
msgstr ""

#: ../../extending/extending.rst:279
msgid ""
"It returns ``NULL`` (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`!command`.  This"
" is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`!command` should "
"properly be declared as ``const char *command``)."
msgstr ""

#: ../../extending/extending.rst:287
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"Наступний оператор — це виклик функції Unix :c:func:`system`, передаючи їй "
"рядок, який ми щойно отримали з :c:func:`PyArg_ParseTuple`::"

#: ../../extending/extending.rst:290
msgid "sts = system(command);"
msgstr ""

#: ../../extending/extending.rst:292
msgid ""
"Our :func:`!spam.system` function must return the value of :c:data:`!sts` as"
" a Python object.  This is done using the function "
":c:func:`PyLong_FromLong`. ::"
msgstr ""

#: ../../extending/extending.rst:295
msgid "return PyLong_FromLong(sts);"
msgstr ""

#: ../../extending/extending.rst:297
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr ""
"У цьому випадку він поверне цілочисельний об’єкт. (Так, навіть цілі числа є "
"об’єктами в купі в Python!)"

#: ../../extending/extending.rst:300
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:expr:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the "
":c:macro:`Py_RETURN_NONE` macro)::"
msgstr ""

#: ../../extending/extending.rst:305
msgid ""
"Py_INCREF(Py_None);\n"
"return Py_None;"
msgstr ""

#: ../../extending/extending.rst:308
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a ``NULL`` pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` — це ім’я C для спеціального об’єкта Python ``None``. Це "
"справжній об’єкт Python, а не покажчик ``NULL``, що означає \"помилку\" в "
"більшості контекстів, як ми бачили."

#: ../../extending/extending.rst:316
msgid "The Module's Method Table and Initialization Function"
msgstr "Таблиця методів модуля та функція ініціалізації"

#: ../../extending/extending.rst:318
msgid ""
"I promised to show how :c:func:`!spam_system` is called from Python "
"programs. First, we need to list its name and address in a \"method "
"table\"::"
msgstr ""

#: ../../extending/extending.rst:321
msgid ""
"static PyMethodDef SpamMethods[] = {\n"
"    ...\n"
"    {\"system\",  spam_system, METH_VARARGS,\n"
"     \"Execute a shell command.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"
msgstr ""

#: ../../extending/extending.rst:329
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should"
" normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"Зверніть увагу на третій запис (``METH_VARARGS``). Це прапорець, який "
"повідомляє інтерпретатору умову виклику, яка буде використовуватися для "
"функції C. Зазвичай це завжди має бути ``METH_VARARGS`` або ``METH_VARARGS |"
" METH_KEYWORDS``; значення ``0`` означає, що використовується застарілий "
"варіант :c:func:`PyArg_ParseTuple`."

#: ../../extending/extending.rst:334
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via "
":c:func:`PyArg_ParseTuple`; more information on this function is provided "
"below."
msgstr ""
"Якщо використовується лише ``METH_VARARGS``, функція повинна очікувати, що "
"параметри рівня Python будуть передані як кортеж, прийнятний для аналізу "
"через :c:func:`PyArg_ParseTuple`; більше інформації про цю функцію наведено "
"нижче."

#: ../../extending/extending.rst:338
msgid ""
"The :c:macro:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of"
" keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""

#: ../../extending/extending.rst:344
msgid ""
"The method table must be referenced in the module definition structure::"
msgstr "На таблицю методів має бути посилання в структурі визначення модуля:"

#: ../../extending/extending.rst:346
msgid ""
"static struct PyModuleDef spammodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"spam\",   /* name of module */\n"
"    spam_doc, /* module documentation, may be NULL */\n"
"    -1,       /* size of per-interpreter state of the module,\n"
"                 or -1 if the module keeps state in global variables. */\n"
"    SpamMethods\n"
"};"
msgstr ""

#: ../../extending/extending.rst:355
msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named "
":c:func:`!PyInit_name`, where *name* is the name of the module, and should "
"be the only non-\\ ``static`` item defined in the module file::"
msgstr ""

#: ../../extending/extending.rst:360
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModule_Create(&spammodule);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:366
msgid ""
"Note that :c:macro:`PyMODINIT_FUNC` declares the function as ``PyObject *`` "
"return type, declares any special linkage declarations required by the "
"platform, and for C++ declares the function as ``extern \"C\"``."
msgstr ""

#: ../../extending/extending.rst:370
msgid ""
"When the Python program imports module :mod:`!spam` for the first time, "
":c:func:`!PyInit_spam` is called. (See below for comments about embedding "
"Python.) It calls :c:func:`PyModule_Create`, which returns a module object, "
"and inserts built-in function objects into the newly created module based "
"upon the table (an array of :c:type:`PyMethodDef` structures) found in the "
"module definition. :c:func:`PyModule_Create` returns a pointer to the module"
" object that it creates.  It may abort with a fatal error for certain "
"errors, or return ``NULL`` if the module could not be initialized "
"satisfactorily. The init function must return the module object to its "
"caller, so that it then gets inserted into ``sys.modules``."
msgstr ""

#: ../../extending/extending.rst:381
msgid ""
"When embedding Python, the :c:func:`!PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use "
":c:func:`PyImport_AppendInittab`, optionally followed by an import of the "
"module::"
msgstr ""

#: ../../extending/extending.rst:386
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* Add a built-in module, before Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pass argv[0] to the Python interpreter */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    /* Initialize the Python interpreter.  Required.\n"
"       If this step fails, it will be a fatal error. */\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    /* Optionally import the module; alternatively,\n"
"       import can be deferred until the embedded script\n"
"       imports it. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    // ... use Python C API here ...\n"
"\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:436
msgid ""
"Removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`) can create problems for some "
"extension modules. Extension module authors should exercise caution when "
"initializing internal data structures."
msgstr ""
"Видалення записів із ``sys.modules`` або імпортування скомпільованих модулів"
" у кілька інтерпретаторів у межах процесу (або виконання :c:func:`fork` без "
"втручання :c:func:`exec`) може створити проблеми для деяких розширень "
"модулі. Авторам модулів розширення слід бути обережними під час "
"ініціалізації внутрішніх структур даних."

#: ../../extending/extending.rst:442
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  "
"template or simply read as an example."
msgstr ""
"Більш суттєвий приклад модуля включено в вихідний код Python як "
":file:`Modules/xxmodule.c`. Цей файл можна використовувати як шаблон або "
"просто прочитати як приклад."

#: ../../extending/extending.rst:448
msgid ""
"Unlike our ``spam`` example, ``xxmodule`` uses *multi-phase initialization* "
"(new in Python 3.5), where a PyModuleDef structure is returned from "
"``PyInit_spam``, and creation of the module is left to the import machinery."
" For details on multi-phase initialization, see :PEP:`489`."
msgstr ""
"На відміну від нашого прикладу ``спаму``, ``xxmodule`` використовує "
"*багатофазову ініціалізацію* (нове в Python 3.5), де структура PyModuleDef "
"повертається з ``PyInit_spam``, а створення модуля залишається за імпортне "
"обладнання. Докладніше про багатофазову ініціалізацію див. :PEP:`489`."

#: ../../extending/extending.rst:457
msgid "Compilation and Linkage"
msgstr "Компіляція та зв'язування"

#: ../../extending/extending.rst:459
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter "
":ref:`building`) and additional information that pertains only to building "
"on Windows (chapter :ref:`building-on-windows`) for more information about "
"this."
msgstr ""
"Перш ніж використовувати нове розширення, потрібно зробити ще дві речі: "
"скомпілювати та зв’язати його з системою Python. Якщо ви використовуєте "
"динамічне завантаження, деталі можуть залежати від стилю динамічного "
"завантаження, який використовує ваша система; дивіться розділи про створення"
" модулів розширення (глава :ref:`building`) та додаткову інформацію, яка "
"стосується лише збірки на Windows (глава :ref:`building-on-windows`), щоб "
"отримати додаткові відомості про це."

#: ../../extending/extending.rst:466
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""
"Якщо ви не можете використовувати динамічне завантаження або якщо ви хочете "
"зробити свій модуль постійною частиною інтерпретатора Python, вам доведеться"
" змінити налаштування конфігурації та перебудувати інтерпретатор. На щастя, "
"в Unix це дуже просто: просто розмістіть свій файл (наприклад, "
":file:`spammodule.c`) у каталозі :file:`Modules/` розпакованого вихідного "
"дистрибутива, додайте рядок до файлу :file:`Modules/Setup.local`, що описує "
"ваш файл:"

#: ../../extending/extending.rst:473
msgid "spam spammodule.o"
msgstr ""

#: ../../extending/extending.rst:477
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change"
" the :file:`Setup` file.)"
msgstr ""
"і перебудуйте інтерпретатор, запустивши :program:`make` у каталозі верхнього"
" рівня. Ви також можете запустити :program:`make` у підкаталозі "
":file:`Modules/`, але тоді ви повинні спочатку перебудувати :file:`Makefile`"
" там, запустивши ':program:`make` Makefile'. (Це необхідно щоразу, коли ви "
"змінюєте файл :file:`Setup`.)"

#: ../../extending/extending.rst:483
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr ""
"Якщо вашому модулю потрібні додаткові бібліотеки для зв’язування, їх також "
"можна вказати в рядку у файлі конфігурації, наприклад:"

#: ../../extending/extending.rst:486
msgid "spam spammodule.o -lX11"
msgstr ""

#: ../../extending/extending.rst:494
msgid "Calling Python Functions from C"
msgstr "Виклик функцій Python із C"

#: ../../extending/extending.rst:496
msgid ""
"So far we have concentrated on making C functions callable from Python.  The"
" reverse is also useful: calling Python functions from C. This is especially"
" the case for libraries that support so-called \"callback\" functions.  If a"
" C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other"
" uses are also imaginable."
msgstr ""
"Поки що ми зосереджувалися на тому, щоб зробити функції C викликаними з "
"Python. Корисним є і зворотний шлях: виклик функцій Python із C. Особливо це"
" стосується бібліотек, які підтримують так звані функції \"зворотного "
"виклику\". Якщо інтерфейс C використовує зворотні виклики, еквівалентний "
"Python часто потребує надання механізму зворотного виклику для програміста "
"Python; реалізація вимагатиме виклику функцій зворотного виклику Python із "
"зворотного виклику C. Можна уявити й інші способи використання."

#: ../../extending/extending.rst:504
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to"
" call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"На щастя, інтерпретатор Python легко викликати рекурсивно, і існує "
"стандартний інтерфейс для виклику функції Python. (Я не буду зупинятися на "
"тому, як викликати синтаксичний аналізатор Python за допомогою певного рядка"
" як вхідних даних --- якщо вам цікаво, подивіться на реалізацію параметра "
"командного рядка :option:`-c` у :file:`Modules/main.c` з вихідного коду "
"Python.)"

#: ../../extending/extending.rst:510
msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some"
" other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"Викликати функцію Python легко. По-перше, програма Python повинна якимось "
"чином передати вам об’єкт функції Python. Ви повинні надати функцію (або "
"інший інтерфейс), щоб це зробити. Під час виклику цієї функції збережіть "
"вказівник на об’єкт функції Python (будьте обережні, щоб :c:func:`Py_INCREF`"
" це!) у глобальній змінній --- або будь-де, де ви вважаєте за потрібне. "
"Наприклад, наступна функція може бути частиною визначення модуля:"

#: ../../extending/extending.rst:517
msgid ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parameter must be callable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp);         /* Add a reference to new callback */\n"
"        Py_XDECREF(my_callback);  /* Dispose of previous callback */\n"
"        my_callback = temp;       /* Remember new callback */\n"
"        /* Boilerplate to return \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:540
msgid ""
"This function must be registered with the interpreter using the "
":c:macro:`METH_VARARGS` flag; this is described in section "
":ref:`methodtable`.  The :c:func:`PyArg_ParseTuple` function and its "
"arguments are documented in section :ref:`parsetuple`."
msgstr ""

#: ../../extending/extending.rst:545
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement"
" the reference count of an object and are safe in the presence of ``NULL`` "
"pointers (but note that *temp* will not be  ``NULL`` in this context).  More"
" info on them in section :ref:`refcounts`."
msgstr ""
"Макроси :c:func:`Py_XINCREF` і :c:func:`Py_XDECREF` збільшують/зменшують "
"кількість посилань на об’єкт і безпечні за наявності покажчиків ``NULL`` "
"(але зауважте, що *temp* не буде бути ``NULL`` у цьому контексті). "
"Детальніше про них у розділі :ref:`refcounts`."

#: ../../extending/extending.rst:552
msgid ""
"Later, when it is time to call the function, you call the C function "
":c:func:`PyObject_CallObject`.  This function has two arguments, both "
"pointers to arbitrary Python objects: the Python function, and the argument "
"list.  The argument list must always be a tuple object, whose length is the "
"number of arguments.  To call the Python function with no arguments, pass in"
" ``NULL``, or an empty tuple; to call it with one argument, pass a singleton"
" tuple. :c:func:`Py_BuildValue` returns a tuple when its format string "
"consists of zero or more format codes between parentheses.  For example::"
msgstr ""
"Пізніше, коли прийде час викликати функцію, ви викликаєте функцію C "
":c:func:`PyObject_CallObject`. Ця функція має два аргументи, обидва вказують"
" на довільні об’єкти Python: функція Python і список аргументів. Список "
"аргументів завжди має бути об’єктом кортежу, довжина якого дорівнює "
"кількості аргументів. Щоб викликати функцію Python без аргументів, передайте"
" ``NULL`` або пустий кортеж; щоб викликати його з одним аргументом, "
"передайте одиночний кортеж. :c:func:`Py_BuildValue` повертає кортеж, якщо "
"його рядок формату складається з нуля або більше кодів формату в дужках. "
"Наприклад::"

#: ../../extending/extending.rst:561
msgid ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Time to call the callback */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"
msgstr ""

#: ../../extending/extending.rst:572
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a"
" new tuple was created to serve as the argument list, which is "
":c:func:`Py_DECREF`\\ -ed immediately after the "
":c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` повертає покажчик на об’єкт Python: це "
"значення, яке повертає функція Python. :c:func:`PyObject_CallObject` є "
"\"нейтральним щодо кількості посилань\" щодо своїх аргументів. У прикладі "
"було створено новий кортеж, який слугуватиме списком аргументів, який "
":c:func:`Py_DECREF`\\ -редагується відразу після виклику "
":c:func:`PyObject_CallObject`."

#: ../../extending/extending.rst:579
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a"
" brand new object, or it is an existing object whose reference count has "
"been incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are"
" not interested in its value."
msgstr ""
"Значення, що повертається :c:func:`PyObject_CallObject`, є \"новим\": або це"
" абсолютно новий об’єкт, або це вже існуючий об’єкт, кількість посилань на "
"який було збільшено. Отже, якщо ви не хочете зберегти його в глобальній "
"змінній, ви повинні якимось чином :c:func:`Py_DECREF` результат, навіть "
"(особливо!), якщо вас не цікавить його значення."

#: ../../extending/extending.rst:585
msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't ``NULL``.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called"
" from Python, it should now return an error indication to its Python caller,"
" so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"Однак перед тим, як це зробити, важливо переконатися, що значення, що "
"повертається, не ``NULL``. Якщо так, функція Python припиняється, викликаючи"
" виняток. Якщо код C, який викликав :c:func:`PyObject_CallObject`, "
"викликається з Python, тепер він має повернути вказівку про помилку своєму "
"виклику Python, щоб інтерпретатор міг надрукувати трасування стека, або "
"викликаючий код Python міг обробити виняткову ситуацію. Якщо це неможливо чи"
" бажано, виняток слід очистити, викликавши :c:func:`PyErr_Clear`. "
"Наприклад::"

#: ../../extending/extending.rst:593
msgid ""
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"...use result...\n"
"Py_DECREF(result);"
msgstr ""

#: ../../extending/extending.rst:598
msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through"
" the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if"
" you want to pass an integral event code, you might use the following code::"
msgstr ""
"Залежно від бажаного інтерфейсу для функції зворотного виклику Python, вам "
"також може знадобитися надати список аргументів для "
":c:func:`PyObject_CallObject`. У деяких випадках список аргументів також "
"надається програмою Python через той самий інтерфейс, який вказав функцію "
"зворотного виклику. Потім його можна зберегти та використовувати так само, "
"як і об’єкт функції. В інших випадках вам, можливо, доведеться створити "
"новий кортеж для передачі як списку аргументів. Найпростіший спосіб зробити "
"це — викликати :c:func:`Py_BuildValue`. Наприклад, якщо ви хочете передати "
"інтегральний код події, ви можете використати такий код:"

#: ../../extending/extending.rst:607
msgid ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""

#: ../../extending/extending.rst:617
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""
"Зверніть увагу на розміщення ``Py_DECREF(arglist)`` одразу після виклику, "
"перед перевіркою помилок! Також зауважте, що строго кажучи, цей код "
"неповний: :c:func:`Py_BuildValue` може не вистачати пам’яті, і це слід "
"перевірити."

#: ../../extending/extending.rst:621
msgid ""
"You may also call a function with keyword arguments by using "
":c:func:`PyObject_Call`, which supports arguments and keyword arguments.  As"
" in the above example, we use :c:func:`Py_BuildValue` to construct the "
"dictionary. ::"
msgstr ""
"Ви також можете викликати функцію з ключовими аргументами за допомогою "
":c:func:`PyObject_Call`, який підтримує аргументи та ключові аргументи. Як і"
" в наведеному вище прикладі, ми використовуємо :c:func:`Py_BuildValue` для "
"створення словника. ::"

#: ../../extending/extending.rst:625
msgid ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"name\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""

#: ../../extending/extending.rst:639
msgid "Extracting Parameters in Extension Functions"
msgstr "Вилучення параметрів у функціях розширення"

#: ../../extending/extending.rst:643
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr "Функція :c:func:`PyArg_ParseTuple` оголошується таким чином:"

#: ../../extending/extending.rst:645
msgid "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"
msgstr ""

#: ../../extending/extending.rst:647
msgid ""
"The *arg* argument must be a tuple object containing an argument list passed"
" from Python to a C function.  The *format* argument must be a format "
"string, whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""
"Аргумент *arg* має бути об’єктом кортежу, що містить список аргументів, "
"переданий з Python до функції C. Аргумент *format* має бути рядком формату, "
"синтаксис якого пояснюється в :ref:`arg-parsing` у довідковому посібнику "
"Python/C API. Решта аргументів мають бути адресами змінних, тип яких "
"визначається рядком формату."

#: ../../extending/extending.rst:653
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
"Зауважте, що хоча :c:func:`PyArg_ParseTuple` перевіряє, чи аргументи Python "
"мають необхідні типи, він не може перевірити дійсність адрес змінних C, "
"переданих до виклику: якщо ви припуститеся там помилки, ваш код, ймовірно, "
"аварійно завершить роботу. найменше перезаписувати випадкові біти в пам'яті."
" Тому будьте обережні!"

#: ../../extending/extending.rst:658
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"Зауважте, що будь-які посилання на об’єкти Python, які надаються абоненту, є"
" *позиченими* посиланнями; не зменшуйте кількість посилань!"

#: ../../extending/extending.rst:661
msgid "Some example calls::"
msgstr "Деякі приклади викликів::"

#: ../../extending/extending.rst:668
msgid ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* No arguments */\n"
"    /* Python call: f() */"
msgstr ""

#: ../../extending/extending.rst:679
msgid ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* A string */\n"
"    /* Possible Python call: f('whoops!') */"
msgstr ""

#: ../../extending/extending.rst:684
msgid ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Two longs and a string */\n"
"    /* Possible Python call: f(1, 2, 'three') */"
msgstr ""

#: ../../extending/extending.rst:689
msgid ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* A pair of ints and a string, whose size is also returned */\n"
"    /* Possible Python call: f((1, 2), 'three') */"
msgstr ""

#: ../../extending/extending.rst:695
msgid ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* A string, and optionally another string and an integer */\n"
"    /* Possible Python calls:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:709
msgid ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* A rectangle and a point */\n"
"    /* Possible Python call:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:720
msgid ""
"{\n"
"    Py_complex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* a complex, also providing a function name for errors */\n"
"    /* Possible Python call: myfunction(1+2j) */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:731
msgid "Keyword Parameters for Extension Functions"
msgstr "Параметри ключових слів для функцій розширення"

#: ../../extending/extending.rst:735
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ""
"Функція :c:func:`PyArg_ParseTupleAndKeywords` оголошується таким чином:"

#: ../../extending/extending.rst:737
msgid ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char * const *kwlist, ...);"
msgstr ""

#: ../../extending/extending.rst:740
msgid ""
"The *arg* and *format* parameters are identical to those of the "
":c:func:`PyArg_ParseTuple` function.  The *kwdict* parameter is the "
"dictionary of keywords received as the third parameter from the Python "
"runtime.  The *kwlist* parameter is a ``NULL``-terminated list of strings "
"which identify the parameters; the names are matched with the type "
"information from *format* from left to right.  On success, "
":c:func:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns "
"false and raises an appropriate exception."
msgstr ""
"Параметри *arg* і *format* ідентичні параметрам функції "
":c:func:`PyArg_ParseTuple`. Параметр *kwdict* — це словник ключових слів, "
"отриманий як третій параметр із середовища виконання Python. Параметр "
"*kwlist* — це список рядків, що завершуються ``NULL`` і ідентифікують "
"параметри; імена зіставляються з інформацією про тип із *format* зліва "
"направо. У разі успіху :c:func:`PyArg_ParseTupleAndKeywords` повертає true, "
"інакше повертає false і викликає відповідний виняток."

#: ../../extending/extending.rst:750
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause "
":exc:`TypeError` to be raised."
msgstr ""
"Вкладені кортежі неможливо проаналізувати за допомогою аргументів ключових "
"слів! Передані параметри ключового слова, яких немає в *kwlist*, призведуть "
"до появи :exc:`TypeError`."

#: ../../extending/extending.rst:756
msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr ""
"Ось приклад модуля, який використовує ключові слова, на основі прикладу "
"Джеффа Філбріка (philbrick@hks.com):"

#: ../../extending/extending.rst:759
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int voltage;\n"
"    const char *state = \"a stiff\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"Norwegian Blue\";\n"
"\n"
"    static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        return NULL;\n"
"\n"
"    printf(\"-- This parrot wouldn't %s if you put %i Volts through it.\\n\",\n"
"           action, voltage);\n"
"    printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* The cast of the function is necessary since PyCFunction values\n"
"     * only take two PyObject* parameters, and keywdarg_parrot() takes\n"
"     * three.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,\n"
"     \"Print a lovely skit to standard output.\"},\n"
"    {NULL, NULL, 0, NULL}   /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdargmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"keywdarg\",\n"
"    NULL,\n"
"    -1,\n"
"    keywdarg_methods\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModule_Create(&keywdargmodule);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:811
msgid "Building Arbitrary Values"
msgstr "Побудова довільних значень"

#: ../../extending/extending.rst:813
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr ""
"Ця функція є аналогом :c:func:`PyArg_ParseTuple`. Це оголошено наступним "
"чином:"

#: ../../extending/extending.rst:816
msgid "PyObject *Py_BuildValue(const char *format, ...);"
msgstr ""

#: ../../extending/extending.rst:818
msgid ""
"It recognizes a set of format units similar to the ones recognized by "
":c:func:`PyArg_ParseTuple`, but the arguments (which are input to the "
"function, not output) must not be pointers, just values.  It returns a new "
"Python object, suitable for returning from a C function called from Python."
msgstr ""
"Він розпізнає набір одиниць формату, подібних до тих, які розпізнає "
":c:func:`PyArg_ParseTuple`, але аргументи (які є вхідними для функції, а не "
"виведеними) не повинні бути вказівниками, а просто значеннями. Він повертає "
"новий об’єкт Python, придатний для повернення з функції C, викликаної з "
"Python."

#: ../../extending/extending.rst:823
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it"
" contains exactly one format unit, it returns whatever object is described "
"by that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""
"Одна відмінність із :c:func:`PyArg_ParseTuple`: у той час як останній "
"вимагає, щоб його перший аргумент був кортежем (оскільки списки аргументів "
"Python завжди представлені у вигляді кортежів), :c:func:`Py_BuildValue` не "
"завжди створює кортеж . Він створює кортеж, лише якщо його рядок формату "
"містить дві або більше одиниць формату. Якщо рядок формату порожній, "
"повертається ``None``; якщо він містить рівно одну одиницю формату, він "
"повертає будь-який об’єкт, описаний цією одиницею формату. Щоб змусити його "
"повертати кортеж розміром 0 або одиницю, візьміть рядок формату в дужки."

#: ../../extending/extending.rst:831
msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr "Приклади (ліворуч виклик, праворуч результуюче значення Python):"

#: ../../extending/extending.rst:833
msgid ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"
msgstr ""

#: ../../extending/extending.rst:857
msgid "Reference Counts"
msgstr "Довідкова кількість"

#: ../../extending/extending.rst:859
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using"
" the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""
"У таких мовах, як C або C++, програміст відповідає за динамічний розподіл і "
"звільнення пам’яті в купі. У C це робиться за допомогою функцій "
":c:func:`malloc` і :c:func:`free`. У C++ оператори ``new`` і ``delete`` "
"використовуються, по суті, з однаковим значенням, і ми обмежимо наступне "
"обговорення випадком C."

#: ../../extending/extending.rst:865
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to "
":c:func:`free`. It is important to call :c:func:`free` at the right time.  "
"If a block's address is forgotten but :c:func:`free` is not called for it, "
"the memory it occupies cannot be reused until the program terminates.  This "
"is called a :dfn:`memory leak`.  On the other hand, if a program calls "
":c:func:`free` for a block and then continues to use the block, it creates a"
" conflict with reuse of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""

#: ../../extending/extending.rst:876
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction"
" of all calls, and most modern machines have plenty of virtual memory, so "
"the leak only becomes apparent in a long-running process that uses the "
"leaking function frequently.  Therefore, it's important to prevent leaks "
"from happening by having a coding convention or strategy that minimizes this"
" kind of errors."
msgstr ""
"Поширеними причинами витоку пам'яті є незвичайні шляхи через код. Наприклад,"
" функція може виділити блок пам'яті, виконати деякі обчислення, а потім "
"знову звільнити блок. Тепер зміна вимог до функції може додати перевірку до "
"обчислення, яка виявляє помилку та може передчасно повернутися з функції. "
"Легко забути звільнити виділений блок пам’яті під час цього передчасного "
"виходу, особливо коли він додається пізніше до коду. Такі витоки, щойно "
"виникли, часто залишаються непоміченими протягом тривалого часу: вихід із "
"помилкою відбувається лише в невеликій частині всіх викликів, а більшість "
"сучасних машин мають багато віртуальної пам’яті, тому витік стає очевидним "
"лише під час тривалого процесу який часто використовує функцію витоку. Тому "
"важливо запобігти витокам, маючи угоду або стратегію кодування, яка "
"мінімізує цей тип помилок."

#: ../../extending/extending.rst:889
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a"
" reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""
"Оскільки Python активно використовує :c:func:`malloc` і :c:func:`free`, йому"
" потрібна стратегія, щоб уникнути витоку пам’яті, а також використання "
"звільненої пам’яті. Обраний метод називається :dfn:`reference counting`. "
"Принцип простий: кожен об’єкт містить лічильник, який збільшується, коли "
"десь зберігається посилання на об’єкт, і зменшується, коли посилання на "
"нього видаляється. Коли лічильник досягає нуля, останнє посилання на об’єкт "
"було видалено, а об’єкт звільнено."

#: ../../extending/extending.rst:897
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The"
" disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic"
" garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""
"Альтернативна стратегія називається :dfn:`автоматична збірка сміття "
"<automatic garbage collection>`. (Іноді підрахунок посилань також називають "
"стратегією збирання сміття, тому я використовую \"автоматичний\", щоб "
"відрізнити ці два.) Великою перевагою автоматичного збирання сміття є те, що"
" користувачеві не потрібно викликати :c:func:`free` явно. (Іншою заявленою "
"перевагою є покращення швидкості або використання пам’яті --- однак це "
"непереконливий факт.) Недоліком є те, що для C немає справді портативного "
"автоматичного збирача сміття, тоді як підрахунок посилань можна реалізувати "
"портативно (за умови, що функції :c:func:`malloc` і :c:func:`free` доступні "
"--- що гарантує стандарт C). Можливо, колись достатньо портативний "
"автоматичний збирач сміття буде доступний для C. До того часу нам доведеться"
" жити з кількістю посилань."

#: ../../extending/extending.rst:909
msgid ""
"While Python uses the traditional reference counting implementation, it also"
" offers a cycle detector that works to detect reference cycles.  This allows"
" applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""
"Хоча Python використовує традиційну реалізацію підрахунку посилань, він "
"також пропонує детектор циклів, який працює для виявлення опорних циклів. Це"
" дозволяє програмам не турбуватися про створення прямих чи непрямих "
"циклічних посилань; це слабкі місця збирання сміття, реалізованого лише за "
"допомогою підрахунку посилань. Посилальні цикли складаються з об’єктів, які "
"містять (можливо, непрямі) посилання на себе, так що кожен об’єкт у циклі "
"має кількість посилань, відмінну від нуля. Типові реалізації підрахунку "
"посилань не можуть відновити пам’ять, що належить до будь-яких об’єктів у "
"циклі посилань, або на яку посилаються об’єкти в циклі, навіть якщо немає "
"подальших посилань на сам цикл."

#: ../../extending/extending.rst:920
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the "
":func:`~gc.collect` function), as well as configuration interfaces and the "
"ability to disable the detector at runtime."
msgstr ""
"Детектор циклів здатний виявляти цикли сміття та повертати їх. Модуль "
":mod:`gc` надає спосіб запуску детектора (функція :func:`~gc.collect`), а "
"також інтерфейси налаштування та можливість вимкнути детектор під час "
"виконання."

#: ../../extending/extending.rst:929
msgid "Reference Counting in Python"
msgstr "Підрахунок посилань у Python"

#: ../../extending/extending.rst:931
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. "
":c:func:`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""
"Є два макроси, ``Py_INCREF(x)`` і ``Py_DECREF(x)``, які обробляють "
"збільшення та зменшення лічильника посилань. :c:func:`Py_DECREF` також "
"звільняє об’єкт, коли кількість досягає нуля. З міркувань гнучкості він не "
"викликає :c:func:`free` напряму --- він робить виклик через вказівник на "
"функцію в об’єкті :dfn:`type object`. Для цієї мети (та інших) кожен об’єкт "
"також містить покажчик на об’єкт свого типу."

#: ../../extending/extending.rst:938
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The"
" owner of a reference is responsible for calling :c:func:`Py_DECREF` when "
"the reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it"
" on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an "
"owned reference creates a memory leak."
msgstr ""
"Тепер залишається велике питання: коли використовувати ``Py_INCREF(x)`` і "
"``Py_DECREF(x)``? Давайте спочатку введемо деякі терміни. Ніхто не "
"\"володіє\" об'єктом; проте ви можете :dfn:`володіти посиланням <own a "
"reference>` на об'єкт. Кількість посилань на об’єкт тепер визначається як "
"кількість належних посилань на нього. Власник посилання відповідає за виклик"
" :c:func:`Py_DECREF`, коли посилання більше не потрібне. Право власності на "
"посилання можна передати. Є три способи позбутися посилання, яке належить: "
"передати, зберегти або викликати :c:func:`Py_DECREF`. Якщо забути позбутися "
"посилання, що належить, це призводить до витоку пам’яті."

#: ../../extending/extending.rst:947
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""
"Також можна :dfn:`borrow` [#]_ посилання на об’єкт. Позичальник посилання не"
" повинен викликати :c:func:`Py_DECREF`. Позичальник не повинен утримувати "
"річ довше, ніж власник, у якого вона була позичена. Використання "
"запозиченого посилання після того, як власник позбувся його, ризикує "
"використати звільнену пам’ять, і його слід повністю уникати [#]_."

#: ../../extending/extending.rst:953
msgid ""
"The advantage of borrowing over owning a reference is that you don't need to"
" take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of"
" leaking when a premature exit is taken.  The disadvantage of borrowing over"
" owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""
"Перевага запозичення перед володінням посиланням полягає в тому, що вам не "
"потрібно піклуватися про утилізацію посилання на всіх можливих шляхах через "
"код --- іншими словами, з запозиченим посиланням ви не ризикуєте витоком "
"коли зроблено передчасний вихід. Недоліком запозичення перед володінням є "
"те, що існують деякі тонкі ситуації, коли в, здавалося б, правильному коді "
"запозичене посилання може бути використано після того, як власник, у якого "
"воно було запозичено, фактично позбувся його."

#: ../../extending/extending.rst:961
msgid ""
"A borrowed reference can be changed into an owned reference by calling "
":c:func:`Py_INCREF`.  This does not affect the status of the owner from "
"which the reference was borrowed --- it creates a new owned reference, and "
"gives full owner responsibilities (the new owner must dispose of the "
"reference properly, as well as the previous owner)."
msgstr ""
"Позичене посилання можна змінити на власне, викликавши :c:func:`Py_INCREF`. "
"Це не впливає на статус власника, у якого було запозичено посилання --- "
"створюється нове посилання, яке належить, і надається повна відповідальність"
" власника (новий власник повинен правильно розпоряджатися посиланням, як і "
"попередній власник)."

#: ../../extending/extending.rst:971
msgid "Ownership Rules"
msgstr "Правила власності"

#: ../../extending/extending.rst:973
msgid ""
"Whenever an object reference is passed into or out of a function, it is part"
" of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr ""
"Кожного разу, коли посилання на об’єкт передається у функцію або з неї, воно"
" є частиною специфікації інтерфейсу функції незалежно від того, передається "
"право власності з посиланням чи ні."

#: ../../extending/extending.rst:977
msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`,"
" pass ownership to the receiver.  Even if the object is not actually new, "
"you still receive ownership of a new reference to that object.  For "
"instance, :c:func:`PyLong_FromLong` maintains a cache of popular values and "
"can return a reference to a cached item."
msgstr ""
"Більшість функцій, які повертають посилання на об’єкт, передають право "
"власності разом із посиланням. Зокрема, усі функції, функцією яких є "
"створення нового об’єкта, такі як :c:func:`PyLong_FromLong` і "
":c:func:`Py_BuildValue`, передають право власності одержувачу. Навіть якщо "
"об’єкт насправді не новий, ви все одно отримуєте право власності на нове "
"посилання на цей об’єкт. Наприклад, :c:func:`PyLong_FromLong` підтримує кеш "
"популярних значень і може повертати посилання на кешований елемент."

#: ../../extending/extending.rst:985
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:`PyObject_GetAttrString`."
"  The picture is less clear, here, however, since a few common routines are "
"exceptions: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, "
":c:func:`PyDict_GetItem`, and :c:func:`PyDict_GetItemString` all return "
"references that you borrow from the tuple, list or dictionary."
msgstr ""
"Багато функцій, які витягують об’єкти з інших об’єктів, також передають "
"право власності разом із посиланням, наприклад "
":c:func:`PyObject_GetAttrString`. Однак тут картина менш зрозуміла, оскільки"
" кілька типових процедур є винятками: :c:func:`PyTuple_GetItem`, "
":c:func:`PyList_GetItem`, :c:func:`PyDict_GetItem` і "
":c:func:`PyDict_GetItemString` повертає всі посилання, які ви запозичили з "
"кортежу, списку або словника."

#: ../../extending/extending.rst:992
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference,"
" even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
"Функція :c:func:`PyImport_AddModule` також повертає запозичене посилання, "
"навіть якщо вона може фактично створити об’єкт, який повертає: це можливо, "
"оскільки власне посилання на об’єкт зберігається в ``sys.modules``."

#: ../../extending/extending.rst:996
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will"
" use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and "
":c:func:`PyList_SetItem`.  These functions take over ownership of the item "
"passed to them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` "
"and friends don't take over ownership --- they are \"normal.\")"
msgstr ""
"Коли ви передаєте посилання на об’єкт в іншу функцію, функція, як правило, "
"запозичує посилання у вас --- якщо їй потрібно її зберегти, вона "
"використовуватиме :c:func:`Py_INCREF`, щоб стати незалежним власником. З "
"цього правила є два важливих винятки: :c:func:`PyTuple_SetItem` і "
":c:func:`PyList_SetItem`. Ці функції беруть на себе право власності на "
"переданий їм елемент --- навіть якщо вони виходять з ладу! (Зауважте, що "
":c:func:`PyDict_SetItem` і друзі не беруть на себе право власності --- вони "
"\"нормальні\".)"

#: ../../extending/extending.rst:1004
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns."
"  Only when such a borrowed reference must be stored or passed on, it must "
"be turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""
"Коли функція C викликається з Python, вона запозичує посилання на свої "
"аргументи від викликаючого. Виклик володіє посиланням на об’єкт, тому час "
"життя позиченого посилання гарантується до повернення функції. Лише тоді, "
"коли таке запозичене посилання потрібно зберегти або передати, його потрібно"
" перетворити на власне посилання шляхом виклику :c:func:`Py_INCREF`."

#: ../../extending/extending.rst:1010
msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to"
" its caller."
msgstr ""
"Посилання на об’єкт, що повертається функцією C, яка викликається з Python, "
"має бути посиланням у власності --- право власності передається від функції "
"до її викликаючого."

#: ../../extending/extending.rst:1018
msgid "Thin Ice"
msgstr "Тонкий лід"

#: ../../extending/extending.rst:1020
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr ""
"Є кілька ситуацій, коли, здавалося б, нешкідливе використання запозиченого "
"посилання може призвести до проблем. Усе це пов’язано з неявними викликами "
"інтерпретатора, які можуть змусити власника посилання позбутися його."

#: ../../extending/extending.rst:1024
msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF`"
" on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr ""
"Перший і найважливіший випадок, про який варто знати, це використання "
":c:func:`Py_DECREF` для непов’язаного об’єкта під час запозичення посилання "
"на елемент списку. Наприклад::"

#: ../../extending/extending.rst:1027
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1036
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference."
" Looks harmless, right?  But it's not!"
msgstr ""
"Ця функція спочатку запозичує посилання на ``list[0]``, потім замінює "
"``list[1]`` на значення ``0`` і, нарешті, друкує запозичене посилання. "
"Виглядає нешкідливо, правда? Але це не так!"

#: ../../extending/extending.rst:1040
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`!__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`!__del__` method."
msgstr ""

#: ../../extending/extending.rst:1047
msgid ""
"Since it is written in Python, the :meth:`!__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`!bug`?  You bet!  Assuming that the list "
"passed into :c:func:`!bug` is accessible to the :meth:`!__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""

#: ../../extending/extending.rst:1055
msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr ""
"Якщо ви дізнаєтеся про джерело проблеми, вирішити її легко: тимчасово "
"збільште кількість посилань. Правильна версія функції виглядає так:"

#: ../../extending/extending.rst:1058
msgid ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1069
msgid ""
"This is a true story.  An older version of Python contained variants of this"
" bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`!__del__` methods would fail..."
msgstr ""

#: ../../extending/extending.rst:1073
msgid ""
"The second case of problems with a borrowed reference is a variant involving"
" threads.  Normally, multiple threads in the Python interpreter can't get in"
" each other's way, because there is a global lock protecting Python's entire"
" object space.  However, it is possible to temporarily release this lock "
"using the macro :c:macro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it "
"using :c:macro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O "
"calls, to let other threads use the processor while waiting for the I/O to "
"complete. Obviously, the following function has the same problem as the "
"previous one::"
msgstr ""
"Другий випадок проблем із запозиченим посиланням – це варіант із залученням "
"потоків. Зазвичай кілька потоків в інтерпретаторі Python не можуть "
"перешкоджати один одному, оскільки існує глобальне блокування, яке захищає "
"весь простір об’єктів Python. Однак можна тимчасово зняти це блокування за "
"допомогою макросу :c:macro:`Py_BEGIN_ALLOW_THREADS` і повторно отримати його"
" за допомогою :c:macro:`Py_END_ALLOW_THREADS`. Це часто зустрічається під "
"час блокування викликів введення-виведення, щоб дозволити іншим потокам "
"використовувати процесор під час очікування завершення введення-виведення. "
"Очевидно, що наступна функція має ту саму проблему, що й попередня:"

#: ../../extending/extending.rst:1082
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...some blocking I/O call...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1096
msgid "NULL Pointers"
msgstr "NULL покажчики"

#: ../../extending/extending.rst:1098
msgid ""
"In general, functions that take object references as arguments do not expect"
" you to pass them ``NULL`` pointers, and will dump core (or cause later core"
" dumps) if you do so.  Functions that return object references generally "
"return ``NULL`` only to indicate that an exception occurred.  The reason for"
" not testing for ``NULL`` arguments is that functions often pass the objects"
" they receive on to other function --- if each function were to test for "
"``NULL``, there would be a lot of redundant tests and the code would run "
"more slowly."
msgstr ""
"Загалом, функції, які приймають посилання на об’єкти як аргументи, не "
"очікують, що ви передасте їм покажчики ``NULL``, і, якщо ви це зробите, "
"створять дамп ядра (або викликатимуть дамп ядра пізніше). Функції, які "
"повертають посилання на об’єкт, зазвичай повертають ``NULL`` лише для того, "
"щоб вказати, що стався виняток. Причина не перевіряти аргументи ``NULL`` "
"полягає в тому, що функції часто передають отримані об’єкти іншій функції "
"--- якби кожна функція перевіряла ``NULL``, було б багато зайвих перевірок і"
" код працюватиме повільніше."

#: ../../extending/extending.rst:1106
msgid ""
"It is better to test for ``NULL`` only at the \"source:\" when a pointer "
"that may be ``NULL`` is received, for example, from :c:func:`malloc` or from"
" a function that may raise an exception."
msgstr ""
"Краще перевіряти ``NULL`` лише на \"джерело:\", коли вказівник, який може "
"бути ``NULL`` отримано, наприклад, від :c:func:`malloc` або від функції, яка"
" може створити виняток."

#: ../../extending/extending.rst:1110
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"``NULL`` pointers --- however, their variants :c:func:`Py_XINCREF` and "
":c:func:`Py_XDECREF` do."
msgstr ""
"Макроси :c:func:`Py_INCREF` і :c:func:`Py_DECREF` не перевіряють покажчики "
"``NULL`` --- однак їх варіанти :c:func:`Py_XINCREF` і :c:func:`Py_XDECREF` "
"робити."

#: ../../extending/extending.rst:1114
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for ``NULL`` pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with ``NULL`` checking."
msgstr ""
"Макроси для перевірки певного типу об’єкта (``Pytype_Check()``) не "
"перевіряють покажчики ``NULL`` --- знову ж таки, є багато коду, який "
"викликає кілька з них поспіль для перевірки об’єкта проти різних очікуваних "
"типів, і це створить надлишкові тести. Варіантів із перевіркою ``NULL`` "
"немає."

#: ../../extending/extending.rst:1120
msgid ""
"The C function calling mechanism guarantees that the argument list passed to"
" C functions (``args`` in the examples) is never ``NULL`` --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr ""
"Механізм виклику функції C гарантує, що список аргументів, переданий "
"функціям C (``args`` у прикладах), ніколи не буде ``NULL`` --- фактично він "
"гарантує, що це завжди кортеж [#]_."

#: ../../extending/extending.rst:1124
msgid ""
"It is a severe error to ever let a ``NULL`` pointer \"escape\" to the Python"
" user."
msgstr ""
"Дозволити вказівнику ``NULL`` \"вийти\" користувачеві Python є серйозною "
"помилкою."

#: ../../extending/extending.rst:1135
msgid "Writing Extensions in C++"
msgstr "Написання розширень на C++"

#: ../../extending/extending.rst:1137
msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply."
"  If the main program (the Python interpreter) is compiled and linked by the"
" C compiler, global or static objects with constructors cannot be used.  "
"This is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``."
" It is unnecessary to enclose the Python header files in ``extern \"C\" "
"{...}`` --- they use this form already if the symbol ``__cplusplus`` is "
"defined (all recent C++ compilers define this symbol)."
msgstr ""
"На C++ можна писати модулі розширення. Застосовуються деякі обмеження. Якщо "
"основна програма (інтерпретатор Python) скомпільована та зв’язана "
"компілятором C, глобальні чи статичні об’єкти з конструкторами "
"використовувати не можна. Це не проблема, якщо основна програма зв’язана "
"компілятором C++. Функції, які буде викликатися інтерпретатором Python "
"(зокрема, функції ініціалізації модуля), мають бути оголошені за допомогою "
"``extern \"C\"``. Немає необхідності вкладати файли заголовків Python у "
"``extern \"C\" {...}`` --- вони вже використовують цю форму, якщо визначено "
"символ ``__cplusplus`` (усі останні компілятори C++ визначають цей символ) ."

#: ../../extending/extending.rst:1151
msgid "Providing a C API for an Extension Module"
msgstr "Надання C API для модуля розширення"

#: ../../extending/extending.rst:1156
msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C"
" functions for direct manipulation from other extension modules."
msgstr ""
"Багато модулів розширення просто надають нові функції та типи для "
"використання з Python, але іноді код у модулі розширення може бути корисним "
"для інших модулів розширення. Наприклад, модуль розширення може реалізувати "
"тип \"колекція\", який працює як списки без порядку. Подібно до того, як "
"стандартний тип списку Python має C API, який дозволяє модулям розширення "
"створювати списки та маніпулювати ними, цей новий тип колекції повинен мати "
"набір функцій C для прямого маніпулювання з інших модулів розширення."

#: ../../extending/extending.rst:1164
msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not"
" be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others"
" require an explicit list of imported symbols at module link time (AIX is "
"one example), or offer a choice of different strategies (most Unices). And "
"even if symbols are globally visible, the module whose functions one wishes "
"to call might not have been loaded yet!"
msgstr ""
"На перший погляд це здається легким: просто напишіть функції (звичайно, не "
"оголошуючи їх \"статичними\"), надайте відповідний файл заголовка та "
"задокументуйте C API. І насправді це працювало б, якби всі модулі розширення"
" завжди були статично пов’язані з інтерпретатором Python. Проте коли модулі "
"використовуються як спільні бібліотеки, символи, визначені в одному модулі, "
"можуть бути невидимими для іншого модуля. Деталі видимості залежать від "
"операційної системи; деякі системи використовують один глобальний простір "
"імен для інтерпретатора Python і всіх модулів розширення (наприклад, "
"Windows), тоді як інші вимагають явного списку імпортованих символів під час"
" зв’язування модуля (прикладом є AIX) або пропонують вибір різних стратегій "
"(більшість Unices). І навіть якщо символи видимі глобально, модуль, функції "
"якого потрібно викликати, можливо, ще не завантажено!"

#: ../../extending/extending.rst:1176
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""
"Тому портативність вимагає не робити жодних припущень щодо видимості "
"символу. Це означає, що всі символи в модулях розширення мають бути "
"оголошені ``статичними``, за винятком функції ініціалізації модуля, щоб "
"уникнути зіткнення імен з іншими модулями розширення (як описано в розділі "
":ref:`methodtable`). І це означає, що символи, які *мають* бути доступні з "
"інших модулів розширення, повинні бути експортовані в інший спосіб."

#: ../../extending/extending.rst:1183
msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:expr:`void \\*`).  Capsules can only be"
" created and accessed via their C API, but they can be passed around like "
"any other Python object. In particular,  they can be assigned to a name in "
"an extension module's namespace. Other extension modules can then import "
"this module, retrieve the value of this name, and then retrieve the pointer "
"from the Capsule."
msgstr ""

#: ../../extending/extending.rst:1191
msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be"
" distributed in different ways between the module providing the code and the"
" client modules."
msgstr ""
"Є багато способів використання Capsules для експорту C API модуля "
"розширення. Кожна функція може отримати власну капсулу, або всі покажчики C "
"API можуть зберігатися в масиві, адреса якого опублікована в капсулі. Різні "
"завдання зі зберігання та отримання покажчиків можуть бути розподілені "
"різними способами між модулем, що надає код, і клієнтськими модулями."

#: ../../extending/extending.rst:1197
msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:expr:`const "
"char \\*`); you're permitted to pass in a ``NULL`` name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule"
" from another."
msgstr ""

#: ../../extending/extending.rst:1204
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr ""
"Зокрема, капсулам, які використовуються для розкриття C API, слід присвоїти "
"назву відповідно до цієї угоди:"

#: ../../extending/extending.rst:1207
msgid "modulename.attributename"
msgstr ""

#: ../../extending/extending.rst:1209
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that"
" the Capsule they load contains the correct C API."
msgstr ""
"Зручна функція :c:func:`PyCapsule_Import` спрощує завантаження C API, що "
"надається через Capsule, але лише якщо назва Capsule відповідає цій умові. "
"Така поведінка дає користувачам C API високий ступінь впевненості, що "
"капсула, яку вони завантажують, містить правильний C API."

#: ../../extending/extending.rst:1214
msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:expr:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that"
" takes care of importing the module and retrieving its C API pointers; "
"client modules only have to call this macro before accessing the C API."
msgstr ""

#: ../../extending/extending.rst:1222
msgid ""
"The exporting module is a modification of the :mod:`!spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`!spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`!PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`!PySpam_System` is also exported to other extension "
"modules."
msgstr ""

#: ../../extending/extending.rst:1229
msgid ""
"The function :c:func:`!PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ""

#: ../../extending/extending.rst:1232
msgid ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1238
msgid "The function :c:func:`!spam_system` is modified in a trivial way::"
msgstr ""

#: ../../extending/extending.rst:1240
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1252
msgid "In the beginning of the module, right after the line ::"
msgstr "На початку модуля, відразу після рядка ::"

#: ../../extending/extending.rst:1254
msgid "#include <Python.h>"
msgstr ""

#: ../../extending/extending.rst:1256
msgid "two more lines must be added::"
msgstr "потрібно додати ще два рядки::"

#: ../../extending/extending.rst:1258
msgid ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""
msgstr ""

#: ../../extending/extending.rst:1261
msgid ""
"The ``#define`` is used to tell the header file that it is being included in"
" the exporting module, not a client module. Finally, the module's "
"initialization function must take care of initializing the C API pointer "
"array::"
msgstr ""
"``#define`` використовується, щоб повідомити файлу заголовка, що його "
"включено до модуля експорту, а не клієнтського модуля. Нарешті, функція "
"ініціалізації модуля повинна подбати про ініціалізацію масиву покажчиків C "
"API::"

#: ../../extending/extending.rst:1265
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    /* Initialize the C API pointer array */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Create a Capsule containing the API pointer array's address */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", NULL);\n"
"\n"
"    if (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1290
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array"
" would disappear when :c:func:`!PyInit_spam` terminates!"
msgstr ""

#: ../../extending/extending.rst:1293
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks"
" like this::"
msgstr ""
"Основна частина роботи знаходиться у файлі заголовка :file:`spammodule.h`, "
"який виглядає так:"

#: ../../extending/extending.rst:1296
msgid ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Header file for spammodule */\n"
"\n"
"/* C API functions */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* Total number of C API pointers */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* This section is used when compiling spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* This section is used in modules that use spammodule's API */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Return -1 on error, 0 on success.\n"
" * PyCapsule_Import will set an exception if there's an error.\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"
msgstr ""

#: ../../extending/extending.rst:1344
msgid ""
"All that a client module must do in order to have access to the function "
":c:func:`!PySpam_System` is to call the function (or rather macro) "
":c:func:`!import_spam` in its initialization function::"
msgstr ""

#: ../../extending/extending.rst:1348
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_client(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&clientmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"    if (import_spam() < 0)\n"
"        return NULL;\n"
"    /* additional initialization can happen here */\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1362
msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h`"
" is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr ""
"Основним недоліком цього підходу є те, що файл :file:`spammodule.h` досить "
"складний. Однак базова структура однакова для кожної функції, яка "
"експортується, тому її потрібно вивчати лише один раз."

#: ../../extending/extending.rst:1366
msgid ""
"Finally it should be mentioned that Capsules offer additional functionality,"
" which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of"
" Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c`"
" in the Python source code distribution)."
msgstr ""
"Насамкінець слід зазначити, що капсули пропонують додаткову "
"функціональність, яка особливо корисна для виділення пам’яті та зняття "
"вказівника, що зберігається в капсулі. Подробиці описано в довідковому "
"посібнику Python/C API у розділі :ref:`capsules` і в реалізації капсул "
"(файли :file:`Include/pycapsule.h` і :file:`Objects/pycapsule.c` у "
"дистрибутиві вихідного коду Python)."

#: ../../extending/extending.rst:1374
msgid "Footnotes"
msgstr "Виноски"

#: ../../extending/extending.rst:1375
msgid ""
"An interface for this function already exists in the standard module "
":mod:`os` --- it was chosen as a simple and straightforward example."
msgstr ""
"Інтерфейс для цієї функції вже існує в стандартному модулі :mod:`os` --- він"
" був обраний як простий і зрозумілий приклад."

#: ../../extending/extending.rst:1378
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr ""
"Метафора \"позичити\" довідку не зовсім коректна: власник досі має копію "
"довідки."

#: ../../extending/extending.rst:1381
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr ""
"Перевірка того, що кількість посилань дорівнює принаймні 1, **не працює** "
"--- сама кількість посилань може бути у звільненій пам’яті та, таким чином, "
"може бути повторно використана для іншого об’єкта!"

#: ../../extending/extending.rst:1385
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr ""
"Ці гарантії не діють, якщо ви використовуєте \"старий\" стиль викликів --- "
"він все ще міститься в більшості існуючих кодів."

#: ../../extending/extending.rst:550
msgid "PyObject_CallObject (C function)"
msgstr ""

#: ../../extending/extending.rst:641
msgid "PyArg_ParseTuple (C function)"
msgstr ""

#: ../../extending/extending.rst:733
msgid "PyArg_ParseTupleAndKeywords (C function)"
msgstr ""

#: ../../extending/extending.rst:754
msgid "Philbrick, Geoff"
msgstr ""
