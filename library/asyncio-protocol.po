# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Transports and Protocols"
msgstr "Транспорт і протоколи"

msgid "Preface"
msgstr "Передмова"

msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Транспорти та протоколи використовуються API циклу подій **низького рівня**, "
"наприклад :meth:`loop.create_connection`. Вони використовують стиль "
"програмування на основі зворотного виклику та дозволяють високопродуктивні "
"реалізації мережевих або IPC-протоколів (наприклад, HTTP)."

msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"По суті, транспорти та протоколи слід використовувати лише в бібліотеках і "
"фреймворках, а не в асинхронних програмах високого рівня."

msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "Ця сторінка документації охоплює як `Transports`_, так і `Protocols`_."

msgid "Introduction"
msgstr "Вступ"

msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"На найвищому рівні транспорт стосується того, *як* передаються байти, тоді "
"як протокол визначає, *які* байти передавати (і певною мірою коли)."

msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Інший спосіб сказати те саме: транспорт є абстракцією для сокета (або "
"подібної кінцевої точки вводу/виводу), тоді як протокол є абстракцією для "
"програми з точки зору транспорту."

msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Ще один погляд полягає в тому, що транспортний і протокольний інтерфейси "
"разом визначають абстрактний інтерфейс для використання мережевого вводу-"
"виводу та міжпроцесного введення-виведення."

msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Між транспортними об’єктами та об’єктами протоколу завжди існує зв’язок 1:1: "
"протокол викликає транспортні методи для надсилання даних, тоді як транспорт "
"викликає протокольні методи для передачі йому отриманих даних."

msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"Більшість методів циклу подій, орієнтованих на підключення (таких як :meth:"
"`loop.create_connection`), зазвичай приймають аргумент *protocol_factory*, "
"який використовується для створення об’єкта *Protocol* для прийнятного "
"з’єднання, представленого об’єктом *Transport*. Такі методи зазвичай "
"повертають кортеж ``(транспорт, протокол)``."

msgid "Contents"
msgstr "Зміст"

msgid "This documentation page contains the following sections:"
msgstr "Ця сторінка документації містить такі розділи:"

msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"Розділ `Transports`_ документує asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport` і :class:`SubprocessTransport` класи."

msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"Розділ `Protocols`_ документує асинхронні класи :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol` і :"
"class:`SubprocessProtocol`."

msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"Розділ `Examples`_ демонструє, як працювати з транспортами, протоколами та "
"API низькорівневого циклу подій."

msgid "Transports"
msgstr "Транспорти"

msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Вихідний код:** :source:`Lib/asyncio/transports.py`"

msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Транспорти — це класи, надані :mod:`asyncio` для абстрагування різних видів "
"каналів зв’язку."

msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Транспортні об’єкти завжди створюються :ref:`асинхронним циклом подій "
"<asyncio-event-loop>`."

msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio реалізує транспорти для каналів TCP, UDP, SSL і підпроцесів. Методи, "
"доступні на транспорті, залежать від типу транспорту."

msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Транспортні класи :ref:`не потоково безпечні <asyncio-multithreading>`."

msgid "Transports Hierarchy"
msgstr "Ієрархія транспортів"

msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Базовий клас для всіх видів транспорту. Містить методи, спільні для всіх "
"асинхронних транспортів."

msgid "A base transport for write-only connections."
msgstr "Базовий транспорт для підключень лише для запису."

msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Екземпляри класу *WriteTransport* повертаються з методу циклу подій :meth:"
"`loop.connect_write_pipe`, а також використовуються пов’язаними з "
"підпроцесами методами, наприклад :meth:`loop.subprocess_exec`."

msgid "A base transport for read-only connections."
msgstr "Базовий транспорт для підключень лише для читання."

msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Екземпляри класу *ReadTransport* повертаються з методу циклу подій :meth:"
"`loop.connect_read_pipe`, а також використовуються пов’язаними з "
"підпроцесами методами, наприклад :meth:`loop.subprocess_exec`."

msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Інтерфейс, що представляє двонаправлений транспорт, наприклад TCP-з'єднання."

msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"Користувач не створює екземпляр транспорту безпосередньо; вони викликають "
"службову функцію, передаючи їй фабрику протоколів та іншу інформацію, "
"необхідну для створення транспорту та протоколу."

msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Екземпляри класу *Transport* повертаються або використовуються такими "
"методами циклу подій, як :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop. sendfile` "
"тощо."

msgid "A transport for datagram (UDP) connections."
msgstr "Транспорт для з’єднань дейтаграм (UDP)."

msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Екземпляри класу *DatagramTransport* повертаються з методу циклу подій :meth:"
"`loop.create_datagram_endpoint`."

msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Абстракція для представлення зв’язку між батьківським і дочірнім процесами "
"ОС."

msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Екземпляри класу *SubprocessTransport* повертаються з методів циклу подій :"
"meth:`loop.subprocess_shell` і :meth:`loop.subprocess_exec`."

msgid "Base Transport"
msgstr "Базовий транспорт"

msgid "Close the transport."
msgstr "Закрити транспорт."

msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument."
msgstr ""
"Якщо транспорт має буфер для вихідних даних, буферизовані дані будуть "
"скидані асинхронно. Дані більше не надходитимуть. Після того, як усі "
"буферизовані дані скинуто, буде викликано метод протоколу :meth:`protocol."
"connection_lost() <BaseProtocol.connection_lost>` з аргументом :const:`None`."

msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Повертає ``True``, якщо транспорт закривається або закритий."

msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Повертає інформацію про транспорт або основні ресурси, які він використовує."

msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*ім’я* — це рядок, що представляє частину транспортної інформації, яку "
"потрібно отримати."

msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* — це значення, яке повертається, якщо інформація недоступна або "
"якщо транспорт не підтримує її запит за допомогою сторонньої реалізації "
"циклу подій або на поточній платформі."

msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Наприклад, наступний код намагається отримати базовий об’єкт сокета "
"транспорту::"

msgid "Categories of information that can be queried on some transports:"
msgstr "Категорії інформації, які можна запитувати на деяких транспортах:"

msgid "socket:"
msgstr "розетка:"

msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: віддалена адреса, до якої підключено сокет, результат :meth:"
"`socket.socket.getpeername` (``None`` у разі помилки)"

msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` екземпляр"

msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: власна адреса сокета, результат :meth:`socket.socket."
"getsockname`"

msgid "SSL socket:"
msgstr "SSL-сокет:"

msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'стиснення'``: алгоритм стиснення, що використовується як рядок, або "
"``None``, якщо з'єднання не стиснуте; результат :meth:`ssl.SSLSocket."
"compression`"

msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: кортеж з трьох значень, що містить назву використовуваного "
"шифру, версію протоколу SSL, яка визначає його використання, і кількість "
"секретних бітів, що використовуються; результат :meth:`ssl.SSLSocket.cipher`"

msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: одноранговий сертифікат; результат :meth:`ssl.SSLSocket."
"getpeercert`"

msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: екземпляр :class:`ssl.SSLContext`"

msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` або :class:`ssl.SSLSocket` екземпляр"

msgid "pipe:"
msgstr "труба:"

msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: об'єкт труби"

msgid "subprocess:"
msgstr "підпроцес:"

msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "екземпляр ``'subprocess'``: :class:`subprocess.Popen`"

msgid "Set a new protocol."
msgstr "Встановіть новий протокол."

msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"Протокол перемикання слід виконувати лише тоді, коли обидва протоколи "
"задокументовано для підтримки перемикання."

msgid "Return the current protocol."
msgstr "Повернути поточний протокол."

msgid "Read-only Transports"
msgstr "Транспорти лише для читання"

msgid "Return ``True`` if the transport is receiving new data."
msgstr "Повертає ``True``, якщо транспорт отримує нові дані."

msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Призупинити приймальний кінець транспорту. Жодні дані не будуть передані в "
"метод протоколу :meth:`protocol.data_received() <Protocol.data_received>`, "
"доки не буде викликано :meth:`resume_reading`."

msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"Метод є ідемпотентним, тобто його можна викликати, коли транспорт вже "
"призупинено або закрито."

msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Відновіть приймальний кінець. Метод :meth:`protocol.data_received() "
"<Protocol.data_received>` протоколу буде викликано ще раз, якщо деякі дані "
"доступні для читання."

msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"Метод є ідемпотентним, тобто його можна викликати, коли транспорт вже читає."

msgid "Write-only Transports"
msgstr "Транспорти лише для запису"

msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Закрийте транспорт негайно, не чекаючи завершення незавершених операцій. "
"Буферизовані дані буде втрачено. Дані більше не надходитимуть. Метод :meth:"
"`protocol.connection_lost() <BaseProtocol.connection_lost>` протоколу "
"зрештою буде викликано з :const:`None` як аргумент."

msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Повертає :const:`True`, якщо транспорт підтримує :meth:`~WriteTransport."
"write_eof`, :const:`False`, якщо ні."

msgid "Return the current size of the output buffer used by the transport."
msgstr ""
"Повертає поточний розмір вихідного буфера, який використовується транспортом."

msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Отримайте *високий* і *низький* водяні знаки для керування потоком запису. "
"Повертає кортеж ``(low, high)``, де *low* і *high* є додатною кількістю "
"байтів."

msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr ""
"Використовуйте :meth:`set_write_buffer_limits`, щоб встановити обмеження."

msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Встановіть *високий* і *низький* водяні знаки для керування потоком запису."

msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Ці два значення (вимірюються в кількості байтів) контролюють, коли "
"викликаються методи протоколу :meth:`protocol.pause_writing() <BaseProtocol."
"pause_writing>` і :meth:`protocol.resume_writing() <BaseProtocol."
"resume_writing>`. Якщо вказано, нижній водяний знак має бути меншим або "
"дорівнювати високому водяному знаку. Ні *високий*, ні *низький* не можуть "
"бути негативними."

msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` викликається, коли розмір буфера стає "
"більшим або рівним значенню *high*. Якщо запис призупинено, :meth:"
"`~BaseProtocol.resume_writing` викликається, коли розмір буфера стає меншим "
"або рівним *низькому* значенню."

msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Значення за замовчуванням залежать від реалізації. Якщо вказано лише високий "
"водяний знак, низький водяний знак за замовчуванням має значення, що "
"залежить від реалізації, менше або дорівнює верхньому водяному знаку. Якщо "
"встановити *high* на нуль, *low* також буде встановлено на нуль і спричинить "
"виклик :meth:`~BaseProtocol.pause_writing` щоразу, коли буфер стає "
"непорожнім. Якщо встановити *low* на нуль, :meth:`~BaseProtocol."
"resume_writing` буде викликатися лише після того, як буфер буде порожнім. "
"Використання нуля для будь-якого обмеження, як правило, є неоптимальним, "
"оскільки воно зменшує можливості одночасного виконання вводу-виводу та "
"обчислень."

msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Використовуйте :meth:`~WriteTransport.get_write_buffer_limits`, щоб отримати "
"обмеження."

msgid "Write some *data* bytes to the transport."
msgstr "Запишіть кілька байтів *data* в транспорт."

msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Цей спосіб не блокує; він буферизує дані та організовує їх асинхронне "
"надсилання."

msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Запишіть список (або будь-яку ітерацію) байтів даних у транспорт. Це "
"функціонально еквівалентно виклику :meth:`write` для кожного елемента, "
"отриманого iterable, але може бути реалізовано більш ефективно."

msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Закрийте кінець запису транспорту після очищення всіх буферизованих даних. "
"Дані ще можуть бути отримані."

msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Цей метод може викликати :exc:`NotImplementedError`, якщо транспорт "
"(наприклад, SSL) не підтримує напівзакриті з’єднання."

msgid "Datagram Transports"
msgstr "Транспортування дейтаграм"

msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Надішліть байти *data* до віддаленого однорангового вузла, заданого *addr* "
"(цільова адреса, що залежить від транспорту). Якщо *addr* має значення :"
"const:`None`, дані надсилаються на цільову адресу, указану під час створення "
"транспорту."

msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Закрийте транспорт негайно, не чекаючи завершення незавершених операцій. "
"Буферизовані дані буде втрачено. Дані більше не надходитимуть. Метод :meth:"
"`protocol.connection_lost() <BaseProtocol.connection_lost>` протоколу "
"зрештою буде викликано з :const:`None` як аргумент."

msgid "Subprocess Transports"
msgstr "Транспортування підпроцесів"

msgid "Return the subprocess process id as an integer."
msgstr "Повертає ідентифікатор процесу підпроцесу як ціле число."

msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Повертає транспорт для комунікаційного каналу, що відповідає цілочисельному "
"файловому дескриптору *fd*:"

msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: доступний для читання потоковий транспорт стандартного введення "
"(*stdin*) або :const:`None`, якщо підпроцес не було створено за допомогою "
"``stdin=PIPE``"

msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: доступний для запису потоковий транспорт стандартного виводу "
"(*stdout*) або :const:`None`, якщо підпроцес не було створено за допомогою "
"``stdout=PIPE``"

msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: доступний для запису потоковий транспорт стандартної помилки "
"(*stderr*) або :const:`None`, якщо підпроцес не було створено за допомогою "
"``stderr=PIPE``"

msgid "other *fd*: :const:`None`"
msgstr "інший *fd*: :const:`None`"

msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Повертає код повернення підпроцесу як ціле число або :const:`None`, якщо він "
"не повернувся, що подібно до атрибута :attr:`subprocess.Popen.returncode`."

msgid "Kill the subprocess."
msgstr "Закрийте підпроцес."

msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"У системах POSIX функція надсилає SIGKILL підпроцесу. У Windows цей метод є "
"псевдонімом для :meth:`terminate`."

msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Дивіться також :meth:`subprocess.Popen.kill`."

msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Надішліть номер *сигналу* підпроцесу, як у :meth:`subprocess.Popen."
"send_signal`."

msgid "Stop the subprocess."
msgstr "Зупиніть підпроцес."

msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""
"У системах POSIX цей метод надсилає SIGTERM підпроцесу. У Windows для "
"зупинки підпроцесу викликається функція Windows API TerminateProcess()."

msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Дивіться також :meth:`subprocess.Popen.terminate`."

msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Закрийте підпроцес, викликавши метод :meth:`kill`."

msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Якщо підпроцес ще не повернувся, закрийте транспорти каналів *stdin*, "
"*stdout* і *stderr*."

msgid "Protocols"
msgstr "Протоколи"

msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Вихідний код:** :source:`Lib/asyncio/protocols.py`"

msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio надає набір абстрактних базових класів, які слід використовувати для "
"реалізації мережевих протоколів. Ці класи призначені для використання разом "
"із :ref:`transports <asyncio-transport>`."

msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Підкласи абстрактних базових класів протоколу можуть реалізовувати деякі або "
"всі методи. Усі ці методи є зворотними викликами: вони викликаються "
"транспортами під час певних подій, наприклад, коли надходять якісь дані. "
"Метод базового протоколу має викликатися відповідним транспортом."

msgid "Base Protocols"
msgstr "Базові протоколи"

msgid "Base protocol with methods that all protocols share."
msgstr "Базовий протокол із методами, які використовують усі протоколи."

msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"Базовий клас для реалізації потокових протоколів (TCP, Unix-сокети тощо)."

msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Базовий клас для реалізації потокових протоколів із ручним керуванням "
"приймальним буфером."

msgid "The base class for implementing datagram (UDP) protocols."
msgstr "Базовий клас для реалізації протоколів дейтаграм (UDP)."

msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"Базовий клас для реалізації протоколів, що спілкуються з дочірніми процесами "
"(односпрямовані канали)."

msgid "Base Protocol"
msgstr "Базовий протокол"

msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Усі асинхронні протоколи можуть реалізовувати зворотні виклики базового "
"протоколу."

msgid "Connection Callbacks"
msgstr "Зворотні виклики підключення"

msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Зворотні виклики підключення викликаються для всіх протоколів рівно один раз "
"за успішне підключення. Усі інші зворотні виклики протоколу можна викликати "
"лише між цими двома методами."

msgid "Called when a connection is made."
msgstr "Викликається, коли встановлено з'єднання."

msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"Аргумент *transport* — це транспорт, що представляє з’єднання. Протокол "
"відповідає за збереження посилання на свій транспорт."

msgid "Called when the connection is lost or closed."
msgstr "Викликається, коли з'єднання втрачено або закрито."

msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"Аргументом є або об’єкт винятку, або :const:`None`. Останнє означає, що "
"отримано звичайний EOF, або з’єднання було перервано чи закрито цією "
"стороною з’єднання."

msgid "Flow Control Callbacks"
msgstr "Зворотні виклики керування потоком"

msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Зворотні виклики керування потоком можуть бути викликані транспортами, щоб "
"призупинити або відновити запис, який виконується протоколом."

msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Додаткову інформацію дивіться в документації методу :meth:`~WriteTransport."
"set_write_buffer_limits`."

msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Викликається, коли транспортний буфер переходить верхній водяний знак."

msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Викликається, коли транспортний буфер закінчується нижче низького водяного "
"знака."

msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Якщо розмір буфера дорівнює верхньому водяному знаку, :meth:`~BaseProtocol."
"pause_writing` не викликається: розмір буфера має суворо перевищувати."

msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"І навпаки, :meth:`~BaseProtocol.resume_writing` викликається, коли розмір "
"буфера дорівнює або менше ніж нижній водяний знак. Ці кінцеві умови важливі "
"для забезпечення того, щоб усе відбувалося так, як очікувалося, коли будь-"
"яка позначка дорівнює нулю."

msgid "Streaming Protocols"
msgstr "Протоколи потокової передачі"

msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Методи подій, такі як :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe` і :meth:`loop.connect_write_pipe` приймають фабрики, які "
"повертають потокові протоколи."

msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Викликається при отриманні деяких даних. *data* — це об’єкт із непорожніми "
"байтами, що містить вхідні дані."

msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Від транспортування залежить, чи будуть дані буферизовані, фрагментовані чи "
"повторно зібрані. Загалом, вам не слід покладатися на конкретну семантику, а "
"натомість робити аналіз загальним і гнучким. Однак дані завжди надходять у "
"правильному порядку."

msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"Метод можна викликати довільну кількість разів, поки з’єднання відкрито."

msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once `eof_received()` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Однак :meth:`protocol.eof_received() <Protocol.eof_received>` викликається "
"щонайбільше один раз. Після виклику `eof_received()` ``data_received()`` "
"більше не викликається."

msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Викликається, коли інший кінець сигналізує, що більше не надсилатиме даних "
"(наприклад, викликом :meth:`transport.write_eof() <WriteTransport."
"write_eof>`, якщо інший кінець також використовує asyncio)."

msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Цей метод може повернути хибне значення (включаючи ``None``), у цьому "
"випадку транспорт закриється сам. І навпаки, якщо цей метод повертає істинне "
"значення, протокол, який використовується, визначає, чи закривати транспорт. "
"Оскільки реалізація за замовчуванням повертає ``None``, вона неявно закриває "
"з’єднання."

msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Деякі транспортні засоби, включно з SSL, не підтримують напівзакриті "
"з’єднання, і в цьому випадку повернення true з цього методу призведе до "
"закриття з’єднання."

msgid "State machine:"
msgstr "Державна машина:"

msgid "Buffered Streaming Protocols"
msgstr "Буферизовані потокові протоколи"

msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Буферизовані протоколи можна використовувати з будь-яким методом циклу "
"подій, який підтримує `Streaming Protocols`_."

msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"Реалізації ``BufferedProtocol`` дозволяють явно вручну розподіляти та "
"контролювати буфер отримання. Потім цикли подій можуть використовувати "
"буфер, наданий протоколом, щоб уникнути непотрібних копій даних. Це може "
"призвести до помітного підвищення продуктивності для протоколів, які "
"отримують великі обсяги даних. Складні реалізації протоколів можуть значно "
"зменшити кількість розподілів буферів."

msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Наступні зворотні виклики викликаються в екземплярах :class:"
"`BufferedProtocol`:"

msgid "Called to allocate a new receive buffer."
msgstr "Викликається для виділення нового буфера отримання."

msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* — рекомендований мінімальний розмір для поверненого буфера. "
"Дозволено повертати менші або більші буфери, ніж пропонує *sizehint*. Якщо "
"встановлено значення -1, розмір буфера може бути довільним. Помилкою є "
"повернення буфера з нульовим розміром."

msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` має повертати об’єкт, що реалізує :ref:`протокол буфера "
"<bufferobjects>`."

msgid "Called when the buffer was updated with the received data."
msgstr "Викликається, коли буфер оновлюється отриманими даними."

msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* — це загальна кількість байтів, які були записані в буфер."

msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Перегляньте документацію методу :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` можна викликати довільну кількість "
"разів під час з’єднання. Однак :meth:`protocol.eof_received() <Protocol."
"eof_received>` викликається щонайбільше один раз, і, якщо буде викликано, :"
"meth:`~BufferedProtocol.get_buffer` і :meth:`~BufferedProtocol."
"buffer_updated` не будуть викликатися після нього."

msgid "Datagram Protocols"
msgstr "Протоколи дейтаграм"

msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Екземпляри протоколу дейтаграм мають бути створені фабриками протоколів, "
"переданими в метод :meth:`loop.create_datagram_endpoint`."

msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Викликається, коли отримано дейтаграму. *data* — це об’єкт bytes, що містить "
"вхідні дані. *addr* — це адреса вузла, який надсилає дані; точний формат "
"залежить від транспорту."

msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Викликається, коли попередня операція надсилання чи отримання викликає :"
"class:`OSError`. *exc* — це екземпляр :class:`OSError`."

msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Цей метод викликається в рідкісних випадках, коли транспорт (наприклад, UDP) "
"виявляє, що дейтаграму не вдалося доставити одержувачу. Однак у багатьох "
"випадках дейтаграми, які неможливо доставити, будуть мовчки видалені."

msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"У системах BSD (macOS, FreeBSD тощо) керування потоком не підтримується для "
"протоколів дейтаграм, оскільки немає надійного способу виявити помилки "
"надсилання, спричинені записом занадто великої кількості пакетів."

msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"Сокет завжди виглядає \"готовим\", а зайві пакети відкидаються. Помилка :"
"class:`OSEror` з ``errno`` встановленим на :const:`errno.ENOBUFS` може "
"виникати або не виникати; якщо воно піднято, про це буде повідомлено :meth:"
"`DatagramProtocol.error_received`, але в інших випадках воно буде "
"проігноровано."

msgid "Subprocess Protocols"
msgstr "Протоколи підпроцесів"

msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Екземпляри протоколу підпроцесу мають бути створені фабриками протоколів, "
"переданими методам :meth:`loop.subprocess_exec` і :meth:`loop."
"subprocess_shell`."

msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Викликається, коли дочірній процес записує дані в канал stdout або stderr."

msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* — цілочисельний файловий дескриптор каналу."

msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* — об’єкт із непорожніми байтами, що містить отримані дані."

msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Викликається, коли одна з труб, що спілкуються з дочірнім процесом, закрита."

msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* — цілочисельний файловий дескриптор, який було закрито."

msgid "Called when the child process has exited."
msgstr "Викликається, коли дочірній процес завершився."

msgid "Examples"
msgstr "Приклади"

msgid "TCP Echo Server"
msgstr "TCP Echo Server"

msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Створіть TCP-сервер ехо за допомогою методу :meth:`loop.create_server`, "
"надішліть назад отримані дані та закрийте з’єднання::"

msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"У прикладі :ref:`TCP echo server using streams <asyncio-tcp-echo-server-"
"streams>` використовується функція :func:`asyncio.start_server` високого "
"рівня."

msgid "TCP Echo Client"
msgstr "TCP Echo Client"

msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"TCP-клієнт відлуння, використовуючи метод :meth:`loop.create_connection`, "
"надсилає дані та чекає, доки з’єднання не буде закрито::"

msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"У прикладі :ref:`TCP echo client using streams <asyncio-tcp-echo-client-"
"streams>` використовується функція :func:`asyncio.open_connection` високого "
"рівня."

msgid "UDP Echo Server"
msgstr "Сервер UDP Echo"

msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Ехо-сервер UDP за допомогою методу :meth:`loop.create_datagram_endpoint` "
"повертає отримані дані:"

msgid "UDP Echo Client"
msgstr "UDP Echo Client"

msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Ехо-клієнт UDP, використовуючи метод :meth:`loop.create_datagram_endpoint`, "
"надсилає дані та закриває транспорт, коли отримує відповідь:"

msgid "Connecting Existing Sockets"
msgstr "Підключення наявних розеток"

msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Зачекайте, поки сокет отримає дані за допомогою методу :meth:`loop."
"create_connection` з протоколом::"

msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"У прикладі :ref:`спостерігати за файловим дескриптором для подій читання "
"<asyncio_example_watch_fd>` використовується метод низького рівня :meth:"
"`loop.add_reader` для реєстрації FD."

msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"У прикладі :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` використовуються потоки "
"високого рівня, створені функцією :func:`open_connection` у співпрограмі."

msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() і SubprocessProtocol"

msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Приклад протоколу підпроцесу, який використовується для отримання "
"результатів підпроцесу та очікування виходу підпроцесу."

msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "Підпроцес створюється методом :meth:`loop.subprocess_exec`::"

msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Дивіться також :ref:`той самий приклад "
"<asyncio_example_create_subprocess_exec>`, написаний з використанням API "
"високого рівня."
