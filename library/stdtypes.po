# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Built-in Types"
msgstr "Вбудовані типи"

msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"У наступних розділах описуються стандартні типи, вбудовані в інтерпретатор."

msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Основними вбудованими типами є числа, послідовності, відображення, класи, "
"екземпляри та винятки."

msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Деякі класи колекцій є змінними. Методи, які додають, віднімають або "
"переставляють свої члени на місці, і не повертають конкретний елемент, "
"ніколи не повертають сам екземпляр колекції, але ``Жодного``."

msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Деякі операції підтримуються кількома типами об'єктів; зокрема, практично "
"всі об’єкти можна порівняти на рівність, перевірити на значення істинності "
"та перетворити на рядок (за допомогою функції :func:`repr` або трохи іншої "
"функції :func:`str`). Остання функція неявно використовується, коли об’єкт "
"записується функцією :func:`print`."

msgid "Truth Value Testing"
msgstr "Перевірка правдивості"

msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Будь-який об’єкт можна перевірити на значення істинності, для використання в "
"умовах :keyword:`if` або :keyword:`while` або як операнд логічних операцій, "
"наведених нижче."

msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"За замовчуванням об’єкт вважається істинним, якщо його клас не визначає або "
"метод :meth:`__bool__`, який повертає ``False``, або метод :meth:`__len__`, "
"який повертає нуль під час виклику з об’єктом. [1]_ Ось більшість вбудованих "
"об’єктів, які вважаються помилковими:"

msgid "constants defined to be false: ``None`` and ``False``."
msgstr "константи, визначені як false: ``None`` і ``False``."

msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"нуль будь-якого числового типу: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"порожні послідовності та колекції: ``''``, ``()``, ``[]``, ``{}``, "
"``set()``, ``range(0)``"

msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Операції та вбудовані функції, які мають логічний результат, завжди "
"повертають ``0`` або ``False`` для false і ``1`` або ``True`` для true, якщо "
"не вказано інше. (Важливий виняток: логічні операції \"або\" та \"і\" завжди "
"повертають один із своїх операндів.)"

msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "Логічні операції --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Це логічні операції, упорядковані за зростанням пріоритету:"

msgid "Operation"
msgstr "Операція"

msgid "Result"
msgstr "Результат"

msgid "Notes"
msgstr "Примітки"

msgid "``x or y``"
msgstr "``x або y``"

msgid "if *x* is false, then *y*, else *x*"
msgstr "якщо *x* false, то *y*, інакше *x*"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``x and y``"
msgstr "``x і y``"

msgid "if *x* is false, then *x*, else *y*"
msgstr "якщо *x* false, тоді *x*, інакше *y*"

msgid "\\(2)"
msgstr "\\(2)"

msgid "``not x``"
msgstr "``не x``"

msgid "if *x* is false, then ``True``, else ``False``"
msgstr "якщо *x* false, тоді ``True``, інакше ``False``"

msgid "\\(3)"
msgstr "\\(3)"

msgid "Notes:"
msgstr "Примітки:"

msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Це оператор короткого замикання, тому він обчислює лише другий аргумент, "
"якщо перший невірний."

msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Це оператор короткого замикання, тому він обчислює лише другий аргумент, "
"якщо перший істинний."

msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` має нижчий пріоритет, ніж не-булеві оператори, тому ``not a == b`` "
"інтерпретується як ``not (a == b)``, а ``a == not b`` є синтаксичною "
"помилкою."

msgid "Comparisons"
msgstr "Порівняння"

msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"У Python є вісім операцій порівняння. Усі вони мають однаковий пріоритет "
"(вищий, ніж у логічних операцій). Порівняння можна зв'язувати довільно; "
"наприклад, ``x < y <= z`` еквівалентно ``x < y і y <= z``, за винятком того, "
"що *y* обчислюється лише один раз (але в обох випадках *z* не обчислюється в "
"все, коли ``x < y`` виявляється хибним)."

msgid "This table summarizes the comparison operations:"
msgstr "Ця таблиця підсумовує операції порівняння:"

msgid "Meaning"
msgstr "Значення"

msgid "``<``"
msgstr "``<``"

msgid "strictly less than"
msgstr "строго менше ніж"

msgid "``<=``"
msgstr "``<=``"

msgid "less than or equal"
msgstr "менше або дорівнює"

msgid "``>``"
msgstr "``>``"

msgid "strictly greater than"
msgstr "строго більше ніж"

msgid "``>=``"
msgstr "``>=``"

msgid "greater than or equal"
msgstr "більше або дорівнює"

msgid "``==``"
msgstr "``==``"

msgid "equal"
msgstr "рівні"

msgid "``!=``"
msgstr "``!=``"

msgid "not equal"
msgstr "не рівні"

msgid "``is``"
msgstr "``є``"

msgid "object identity"
msgstr "ідентичність об'єкта"

msgid "``is not``"
msgstr "``не``"

msgid "negated object identity"
msgstr "заперечена ідентичність об'єкта"

msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Об’єкти різних типів, за винятком різних числових типів, ніколи не "
"порівнюються. Оператор ``==`` завжди визначений, але для деяких типів "
"об’єктів (наприклад, об’єктів класу) еквівалентний :keyword:`is`. Оператори "
"``<``, ``<=``, ``>`` і ``>=`` визначені лише там, де вони мають сенс; "
"наприклад, вони викликають виняток :exc:`TypeError`, коли один із аргументів "
"є комплексним числом."

msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Неідентичні екземпляри класу зазвичай порівнюються як нерівні, якщо клас не "
"визначає метод :meth:`~object.__eq__`."

msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Екземпляри класу не можуть бути впорядковані відносно інших екземплярів того "
"самого класу або інших типів об’єктів, якщо клас не визначає достатньо "
"методів :meth:`~object.__lt__`, :meth:`~object.__le__` , :meth:`~object."
"__gt__` і :meth:`~object.__ge__` (загалом, :meth:`~object.__lt__` і :meth:"
"`~object.__eq__` достатньо, якщо ви хочете звичайні значення операторів "
"порівняння)."

msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Поведінку операторів :keyword:`is` і :keyword:`is not` не можна налаштувати; "
"також вони можуть бути застосовані до будь-яких двох об’єктів і ніколи не "
"викликають винятків."

msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"Ще дві операції з таким же синтаксичним пріоритетом, :keyword:`in` і :"
"keyword:`not in`, підтримуються типами, які є :term:`iterable` або "
"реалізують метод :meth:`__contains__`."

msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Числові типи --- :class:`int`, :class:`float`, :class:`complex`"

msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Є три різні типи чисел: :dfn:`integers`, :dfn:`floating point numbers` та :"
"dfn:`complex numbers`. Крім того, логічні значення є підтипом цілих чисел. "
"Цілі числа мають необмежену точність. Числа з плаваючою комою зазвичай "
"реалізуються за допомогою :c:type:`double` в C; інформація про точність і "
"внутрішнє представлення чисел з плаваючою комою для машини, на якій "
"виконується ваша програма, доступна в :data:`sys.float_info`. Комплексні "
"числа мають дійсну та уявну частини, кожна з яких є числом з плаваючою "
"комою. Щоб отримати ці частини з комплексного числа *z*, використовуйте ``z."
"real`` і ``z.imag``. (Стандартна бібліотека включає додаткові числові типи :"
"mod:`fractions.Fraction`, для раціональних чисел, і :mod:`decimal.Decimal`, "
"для чисел з плаваючою комою з визначеною користувачем точністю.)"

msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Числа створюються за допомогою числових літералів або як результат "
"вбудованих функцій і операторів. Неприкрашені цілі літерали (включаючи "
"шістнадцяткові, вісімкові та двійкові числа) дають цілі числа. Числові "
"літерали, що містять десяткову кому або знак експоненти, дають числа з "
"плаваючою комою. Додавання ``'j'`` або ``'J''`` до числового літералу дає "
"уявне число (комплексне число з нульовою дійсною частиною), яке ви можете "
"додати до цілого числа або числа з плаваючою точкою, щоб отримати комплексне "
"число з дійсним і уявні частини."

msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python повністю підтримує змішану арифметику: коли двійковий арифметичний "
"оператор має операнди різних числових типів, операнд із \"вужчим\" типом "
"розширюється до операнда іншого типу, де ціле число вужче за число з "
"плаваючою крапкою, яке є вужчим за комплексний. Порівняння між числами "
"різних типів поводиться так, ніби порівнюються точні значення цих чисел. [2]_"

msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Конструктори :func:`int`, :func:`float` і :func:`complex` можна "
"використовувати для отримання чисел певного типу."

msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Усі числові типи (крім комплексних) підтримують наступні операції "
"(пріоритети операцій див. :ref:`operator-summary`):"

msgid "Full documentation"
msgstr "Повна документація"

msgid "``x + y``"
msgstr "``x + y``"

msgid "sum of *x* and *y*"
msgstr "сума *x* і *y*"

msgid "``x - y``"
msgstr "``x - y``"

msgid "difference of *x* and *y*"
msgstr "різниця *x* і *y*"

msgid "``x * y``"
msgstr "``x * y``"

msgid "product of *x* and *y*"
msgstr "добуток *x* і *y*"

msgid "``x / y``"
msgstr "``x / y``"

msgid "quotient of *x* and *y*"
msgstr "частка *x* і *y*"

msgid "``x // y``"
msgstr "``x // y``"

msgid "floored quotient of *x* and *y*"
msgstr "частка *x* і *y*"

msgid "``x % y``"
msgstr "``x % y``"

msgid "remainder of ``x / y``"
msgstr "залишок ``x / y``"

msgid "``-x``"
msgstr "``-x``"

msgid "*x* negated"
msgstr "*x* заперечено"

msgid "``+x``"
msgstr "``+x``"

msgid "*x* unchanged"
msgstr "*x* без змін"

msgid "``abs(x)``"
msgstr "``abs(x)``"

msgid "absolute value or magnitude of *x*"
msgstr "абсолютне значення або величина *x*"

msgid ":func:`abs`"
msgstr ":func:`abs`"

msgid "``int(x)``"
msgstr "``int(x)``"

msgid "*x* converted to integer"
msgstr "*x* перетворено на ціле число"

msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

msgid ":func:`int`"
msgstr ":func:`int`"

msgid "``float(x)``"
msgstr "``float(x)``"

msgid "*x* converted to floating point"
msgstr "*x* перетворено на число з плаваючою комою"

msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

msgid ":func:`float`"
msgstr ":func:`float`"

msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"комплексне число з дійсною частиною *re*, уявною частиною *im*. *im* за "
"замовчуванням дорівнює нулю."

msgid "\\(6)"
msgstr "\\(6)"

msgid ":func:`complex`"
msgstr ":func:`complex`"

msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

msgid "conjugate of the complex number *c*"
msgstr "спряжене комплексне число *c*"

msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

msgid "the pair ``(x // y, x % y)``"
msgstr "пара ``(x // y, x % y)``"

msgid ":func:`divmod`"
msgstr ":func:`divmod`"

msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

msgid "*x* to the power *y*"
msgstr "*x* у степені *y*"

msgid "\\(5)"
msgstr "\\(5)"

msgid ":func:`pow`"
msgstr ":func:`pow`"

msgid "``x ** y``"
msgstr "``x ** y``"

msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Також називається цілим діленням. Результуюче значення є цілим числом, хоча "
"тип результату не обов’язково є int. Результат завжди округлюється до мінус "
"нескінченності: ``1//2`` це ``0``, ``(-1)//2`` ``-1``, ``1//(- 2) \"`` — це "
"\"-1\", а \"(-1)//(-2)\" — це \"0\"."

msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Не для комплексних чисел. Натомість конвертуйте у числа з плаваючою точкою "
"за допомогою :func:`abs`, якщо це доречно."

msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"Перетворення з плаваючої крапки на ціле число може округлятися або "
"скорочуватися, як у C; див. функції :func:`math.floor` і :func:`math.ceil` "
"для чітко визначених перетворень."

msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float також приймає рядки \"nan\" і \"inf\" з необов'язковим префіксом \"+\" "
"або \"-\" для Not a Number (NaN) і додатною або від'ємною нескінченністю."

msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python визначає ``pow(0, 0)`` і ``0 ** 0`` як ``1``, як це прийнято для мов "
"програмування."

msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Прийнятні числові літерали включають цифри від ``0`` до ``9`` або будь-який "
"еквівалент Unicode (кодові точки з властивістю ``Nd``)."

msgid ""
"See https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""
"Повний список кодових точок із властивістю ``Nd`` див. https://www.unicode."
"org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt"

msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Усі типи :class:`numbers.Real` (:class:`int` і :class:`float`) також містять "
"такі операції:"

msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* скорочено до :class:`~numbers.Integral`"

msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* округлено до *n* цифр, округлення половини до парного числа. Якщо *n* "
"опущено, за умовчанням дорівнює 0."

msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "найбільший :class:`~numbers.Integral` <= *x*"

msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "найменший :class:`~numbers.Integral` >= *x*"

msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Для отримання додаткових числових операцій перегляньте модулі :mod:`math` і :"
"mod:`cmath`."

msgid "Bitwise Operations on Integer Types"
msgstr "Побітові операції над цілими типами"

msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Побітові операції мають сенс лише для цілих чисел. Результат порозрядних "
"операцій обчислюється так, ніби виконується в доповненні до двох із "
"нескінченною кількістю знакових бітів."

msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Пріоритети двійкових порозрядних операцій нижчі, ніж числових операцій, і "
"вищі, ніж порівняння; унарна операція ``~`` має той самий пріоритет, що й "
"інші унарні числові операції (``+`` і ``-``)."

msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"У цій таблиці наведено порозрядні операції, відсортовані за зростанням "
"пріоритету:"

msgid "``x | y``"
msgstr "``x | y``"

msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "порозрядно :dfn:`or` *x* і *y*"

msgid "\\(4)"
msgstr "\\(4)"

msgid "``x ^ y``"
msgstr "``x ^ y``"

msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "порозрядно :dfn:`exclusive or` *x* та *y*"

msgid "``x & y``"
msgstr "``x & y``"

msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "порозрядно :dfn:`and` *x* і *y*"

msgid "``x << n``"
msgstr "``x << n``"

msgid "*x* shifted left by *n* bits"
msgstr "*x* зміщено вліво на *n* бітів"

msgid "(1)(2)"
msgstr "(1)(2)"

msgid "``x >> n``"
msgstr "``x >> n``"

msgid "*x* shifted right by *n* bits"
msgstr "*x* зміщено праворуч на *n* бітів"

msgid "(1)(3)"
msgstr "(1)(3)"

msgid "``~x``"
msgstr "``~x``"

msgid "the bits of *x* inverted"
msgstr "біти *x* інвертовані"

msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "Підрахунок від’ємного зсуву є незаконним і викликає :exc:`ValueError`."

msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "Зсув вліво на *n* бітів еквівалентний множенню на ``pow(2, n)``."

msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Зсув праворуч на *n* бітів еквівалентний діленню підлоги за допомогою "
"``pow(2, n)``."

msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Виконання цих обчислень із принаймні одним додатковим бітом розширення знака "
"в поданні скінченних двох доповнень (робоча бітова ширина ``1 + max(x."
"bit_length(), y.bit_length())`` або більше) є достатньою для отримати той "
"самий результат, ніби існує нескінченна кількість знакових бітів."

msgid "Additional Methods on Integer Types"
msgstr "Додаткові методи для цілих типів"

msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Тип int реалізує :class:`numbers.Integral` :term:`abstract base class`. Крім "
"того, він надає ще кілька методів:"

msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Повертає кількість бітів, необхідних для представлення цілого числа в "
"двійковій системі, за винятком знака та нулів на початку::"

msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Точніше, якщо ``x`` відмінне від нуля, то ``x.bit_length()`` є унікальним "
"натуральним числом ``k`` таким, що ``2**(k-1) <= abs(x) < 2**k``. "
"Аналогічно, коли ``abs(x)`` достатньо малий, щоб мати правильно округлений "
"логарифм, тоді ``k = 1 + int(log(abs(x), 2))``. Якщо ``x`` дорівнює нулю, то "
"``x.bit_length()`` повертає ``0``."

msgid "Equivalent to::"
msgstr "Дорівнює::"

msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Повертає кількість одиниць у двійковому представленні абсолютного значення "
"цілого числа. Це також відомо як підрахунок населення. Приклад::"

msgid "Return an array of bytes representing an integer."
msgstr "Повертає масив байтів, що представляє ціле число."

msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""
"Ціле число представлено за допомогою *довжини* байтів. Помилка :exc:"
"`OverflowError` виникає, якщо ціле число не можна представити заданою "
"кількістю байтів."

msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"Аргумент *byteorder* визначає порядок байтів, який використовується для "
"представлення цілого числа. Якщо *byteorder* має значення ``\"big\"``, "
"старший байт знаходиться на початку масиву байтів. Якщо *byteorder* має "
"значення ``\"little\"``, старший байт знаходиться в кінці масиву байтів. Щоб "
"запитати власний порядок байтів хост-системи, використовуйте :data:`sys."
"byteorder` як значення порядку байтів."

msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"Аргумент *signed* визначає, чи використовується доповнення до двох для "
"представлення цілого числа. Якщо *signed* має значення ``False`` і вказано "
"від’ємне ціле число, виникає :exc:`OverflowError`. Значенням за "
"замовчуванням для *signed* є ``False``."

msgid "Return the integer represented by the given array of bytes."
msgstr "Повертає ціле число, представлене заданим масивом байтів."

msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"Аргумент *bytes* має бути або :term:`bytes-like object`, або ітерованим, що "
"створює байти."

msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"Аргумент *signed* вказує, чи використовується доповнення до двох для "
"представлення цілого числа."

msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr ""
"Повертає пару цілих чисел, відношення яких точно дорівнює вихідному числу та "
"має додатний знаменник. Цілочисельне відношення цілих чисел (цілих чисел) "
"завжди є цілим числом як чисельник і \"1\" як знаменник."

msgid "Additional Methods on Float"
msgstr "Додаткові методи для Float"

msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Тип float реалізує :class:`numbers.Real` :term:`abstract base class`. float "
"також має такі додаткові методи."

msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"Повертає пару цілих чисел, співвідношення яких точно дорівнює початковому "
"float і з додатним знаменником. Викликає :exc:`OverflowError` на "
"нескінченності та :exc:`ValueError` на NaN."

msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Повертає ``True``, якщо екземпляр float є кінцевим із цілим значенням, і "
"``False`` інакше::"

msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Два методи підтримують перетворення до та з шістнадцяткових рядків. Оскільки "
"числа з плаваючою точкою Python зберігаються усередині як двійкові числа, "
"перетворення числа з плаваючою точкою в *десятковий* рядок або з нього "
"зазвичай включає невелику помилку округлення. Навпаки, шістнадцяткові рядки "
"дозволяють точне представлення та специфікацію чисел з плаваючою комою. Це "
"може бути корисним під час налагодження та чисельної роботи."

msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Повертає представлення числа з плаваючою комою як шістнадцятковий рядок. Для "
"скінченних чисел з плаваючою комою це представлення завжди включатиме ``0x`` "
"на початку та ``p`` у кінці та експоненту."

msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Метод класу для повернення числа з плаваючою точкою, представленого "
"шістнадцятковим рядком *s*. Рядок *s* може мати пробіли на початку та в "
"кінці."

msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Зауважте, що :meth:`float.hex` є методом екземпляра, тоді як :meth:`float."
"fromhex` є методом класу."

msgid "A hexadecimal string takes the form::"
msgstr "Шістнадцятковий рядок має вигляд::"

msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"де необов’язковий ``знак`` може мати ``+`` або ``-``, ``ціле число`` і "
"``дріб`` є рядками шістнадцяткових цифр, а ``експонента`` є десятковим цілим "
"числом з необов’язковим переднім знаком. Регістр не є значущим, і в цілому "
"чи дробі має бути принаймні одна шістнадцяткова цифра. Цей синтаксис "
"подібний до синтаксису, зазначеного в розділі 6.4.4.2 стандарту C99, а також "
"до синтаксису, який використовується в Java 1.5 і далі. Зокрема, вихід :meth:"
"`float.hex` можна використовувати як шістнадцятковий літерал із плаваючою "
"комою в коді C або Java, а також шістнадцяткові рядки, створені символом "
"формату C ``%a`` або ``Double.toHexString`` Java приймаються :meth:`float."
"fromhex`."

msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Зауважте, що експонента записується в десятковій, а не в шістнадцятковій "
"формі, і що вона дає ступінь 2, на який потрібно помножити коефіцієнт. "
"Наприклад, шістнадцятковий рядок ``0x3.a7p10`` представляє число з плаваючою "
"комою ``(3 + 10./16 + 7./16**2) * 2.0**10`` або ``3740.0``::"

msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Застосування зворотного перетворення до ``3740.0`` дає інший шістнадцятковий "
"рядок, що представляє те саме число::"

msgid "Hashing of numeric types"
msgstr "Хешування числових типів"

msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`modulus` attribute "
"of :data:`sys.hash_info`."
msgstr ""
"Для чисел ``x`` і ``y``, можливо, різних типів, є вимога, щоб ``hash(x) == "
"hash(y)`` щоразу, коли ``x == y`` (див. : документація методу :meth:`~object."
"__hash__` для отримання додаткової інформації). Для простоти впровадження та "
"ефективності для різноманітних числових типів (зокрема :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` і :class:`fractions.Fraction`) хеш Python "
"для числових типи базується на одній математичній функції, яка визначена для "
"будь-якого раціонального числа, і, отже, застосовується до всіх екземплярів :"
"class:`int` і :class:`fractions.Fraction`, а також усіх кінцевих "
"екземплярів :class:`float` і :class:`decimal.Decimal`. По суті, ця функція "
"задана скороченням за модулем ``P`` для фіксованого простого ``P``. Значення "
"``P`` стає доступним для Python як атрибут :attr:`modulus` :data:`sys."
"hash_info`."

msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"В даний час простим числом, яке використовується, є ``P = 2**31 - 1`` на "
"машинах з 32-розрядним C long і ``P = 2**61 - 1`` на машинах з 64-бітним C "
"long."

msgid "Here are the rules in detail:"
msgstr "Ось правила в деталях:"

msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Якщо ``x = m / n`` є невід’ємним раціональним числом, а ``n`` не ділиться на "
"``P``, визначте ``hash(x)`` як ``m * invmod(n, P`` ) % P``, де ``invmod(n, "
"P)`` дає обернене ``n`` за модулем ``P``."

msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Якщо ``x = m / n`` є невід’ємним раціональним числом, а ``n`` ділиться на "
"``P`` (але ``m`` не ділиться на ``m``), тоді ``n`` не має оберненого "
"модуля``P`` і правило вище не застосовується; у цьому випадку визначте "
"``hash(x)`` як постійне значення ``sys.hash_info.inf``."

msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Якщо ``x = m / n`` є від’ємним раціональним числом, визначте ``hash(x)`` як "
"``-hash(-x)``. Якщо отриманий хеш дорівнює ``-1``, замініть його ``-2``."

msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"Конкретні значення ``sys.hash_info.inf`` і ``-sys.hash_info.inf`` "
"використовуються як хеш-значення для позитивної нескінченності або "
"негативної нескінченності (відповідно)."

msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Для :class:`complex` числа ``z`` хеш-значення дійсної та уявної частин "
"поєднуються шляхом обчислення ``hash(z.real) + sys.hash_info.imag * hash(z."
"imag)``, зменшено за модулем ``2**sys.hash_info.width`` так, щоб він "
"знаходився в ``діапазоні (-2**(sys.hash_info.width - 1), 2**(sys.hash_info."
"width - 1) ))``. Знову ж таки, якщо результат ``-1``, він замінюється на "
"``-2``."

msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Щоб прояснити наведені вище правила, ось приклад коду Python, еквівалентного "
"вбудованому хешу, для обчислення хешу раціонального числа, :class:`float` "
"або :class:`complex`::"

msgid "Iterator Types"
msgstr "Типи ітераторів"

msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python підтримує концепцію ітерації над контейнерами. Це реалізується за "
"допомогою двох різних методів; вони використовуються, щоб дозволити "
"визначеним користувачем класам підтримувати ітерацію. Послідовності, описані "
"нижче більш детально, завжди підтримують ітераційні методи."

msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Потрібно визначити один метод для об’єктів-контейнерів, щоб забезпечити "
"підтримку :term:`iterable`:"

msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Повертає об’єкт :term:`iterator`. Об’єкт повинен підтримувати описаний нижче "
"протокол ітератора. Якщо контейнер підтримує різні типи ітерацій, можна "
"надати додаткові методи для спеціального запиту ітераторів для цих типів "
"ітерацій. (Прикладом об’єкта, що підтримує кілька форм ітерації, може бути "
"деревоподібна структура, яка підтримує обхід як у ширину, так і в глибину.) "
"Цей метод відповідає слоту :c:member:`~PyTypeObject.tp_iter` структури типу "
"для об’єктів Python в API Python/C."

msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Самі об’єкти ітератора повинні підтримувати наступні два методи, які разом "
"утворюють :dfn:`iterator protocol`:"

msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Повертає сам об’єкт :term:`iterator`. Це потрібно, щоб дозволити "
"використовувати як контейнери, так і ітератори з операторами :keyword:`for` "
"і :keyword:`in`. Цей метод відповідає слоту :c:member:`~PyTypeObject."
"tp_iter` структури типу для об’єктів Python в API Python/C."

msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Повертає наступний елемент із :term:`iterator`. Якщо більше елементів немає, "
"підніміть виняток :exc:`StopIteration`. Цей метод відповідає слоту :c:member:"
"`~PyTypeObject.tp_iternext` структури типу для об’єктів Python в API Python/"
"C."

msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python визначає декілька об’єктів-ітераторів для підтримки ітерації "
"загальних і конкретних типів послідовностей, словників та інших більш "
"спеціалізованих форм. Конкретні типи не важливі за межами їхньої реалізації "
"протоколу ітератора."

msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Коли метод :meth:`~iterator.__next__` ітератора викликає :exc:"
"`StopIteration`, він повинен продовжувати робити це під час наступних "
"викликів. Реалізації, які не підкоряються цій властивості, вважаються "
"зламаними."

msgid "Generator Types"
msgstr "Типи генераторів"

msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
":term:`generator`\\s Python надають зручний спосіб реалізації протоколу "
"ітератора. Якщо метод :meth:`__iter__` об’єкта-контейнера реалізовано як "
"генератор, він автоматично повертатиме об’єкт-ітератор (технічно, об’єкт-"
"генератор), що надає методи :meth:`__iter__` і :meth:`~generator.__next__` . "
"Більше інформації про генератори можна знайти в :ref:`документації для "
"виразу yield <yieldexpr>`."

msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Типи послідовностей --- :class:`list`, :class:`tuple`, :class:`range`"

msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Існує три основні типи послідовностей: списки, кортежі та об’єкти діапазону. "
"Додаткові типи послідовностей, призначені для обробки :ref:`бінарних даних "
"<binaryseq>` і :ref:`текстових рядків <textseq>`, описані у спеціальних "
"розділах."

msgid "Common Sequence Operations"
msgstr "Загальні операції послідовності"

msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Операції в наведеній нижче таблиці підтримують більшість типів "
"послідовностей, як змінних, так і незмінних. :class:`collections.abc."
"Sequence` ABC надається, щоб спростити правильну реалізацію цих операцій у "
"настроюваних типах послідовностей."

msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"У цій таблиці наведено послідовність операцій, відсортованих за зростанням "
"пріоритету. У таблиці *s* і *t* — послідовності одного типу, *n*, *i*, *j* і "
"*k* — цілі числа, а *x* — довільний об’єкт, який відповідає будь-яким "
"обмеженням щодо типу та значення накладений *s*."

msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Операції ``in`` і ``not in`` мають ті самі пріоритети, що й операції "
"порівняння. Операції ``+`` (конкатенація) і ``*`` (повторення) мають той "
"самий пріоритет, що й відповідні числові операції. [3]_"

msgid "``x in s``"
msgstr "``x в s``"

msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True``, якщо елемент *s* дорівнює *x*, інакше ``False``"

msgid "``x not in s``"
msgstr "``x не в s``"

msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False``, якщо елемент *s* дорівнює *x*, інакше ``True``"

msgid "``s + t``"
msgstr "``s + t``"

msgid "the concatenation of *s* and *t*"
msgstr "конкатенація *s* і *t*"

msgid "(6)(7)"
msgstr "(6)(7)"

msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` або ``n * s``"

msgid "equivalent to adding *s* to itself *n* times"
msgstr "еквівалентно додаванню *s* до самого себе *n* разів"

msgid "(2)(7)"
msgstr "(2)(7)"

msgid "``s[i]``"
msgstr "``s[i]``"

msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ ий елемент з *s*, джерело 0"

msgid "``s[i:j]``"
msgstr "``s[i:j]``"

msgid "slice of *s* from *i* to *j*"
msgstr "фрагмент *s* від *i* до *j*"

msgid "(3)(4)"
msgstr "(3)(4)"

msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "фрагмент *s* від *i* до *j* з кроком *k*"

msgid "(3)(5)"
msgstr "(3)(5)"

msgid "``len(s)``"
msgstr "``len(s)``"

msgid "length of *s*"
msgstr "довжина *s*"

msgid "``min(s)``"
msgstr "``хв(и)``"

msgid "smallest item of *s*"
msgstr "найменший елемент *s*"

msgid "``max(s)``"
msgstr "``max(s)``"

msgid "largest item of *s*"
msgstr "найбільший предмет *s*"

msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"індекс першого входження *x* у *s* (за або після індексу *i* та перед "
"індексом *j*)"

msgid "\\(8)"
msgstr "\\(8)"

msgid "``s.count(x)``"
msgstr "``s.count(x)``"

msgid "total number of occurrences of *x* in *s*"
msgstr "загальна кількість входжень *x* у *s*"

msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Послідовності одного типу також підтримують порівняння. Зокрема, кортежі та "
"списки порівнюються лексикографічно шляхом порівняння відповідних елементів. "
"Це означає, що для порівняння однаково кожен елемент повинен порівнюватись "
"рівно, а дві послідовності мають бути одного типу та мати однакову довжину. "
"(Для отримання повної інформації див. :ref:`comparisons` у мовній довідці.)"

msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Прямі та зворотні ітератори над змінними послідовностями отримують доступ до "
"значень за допомогою індексу. Цей індекс буде продовжувати рух вперед (або "
"назад), навіть якщо базова послідовність змінена. Ітератор завершується лише "
"тоді, коли зустрічається :exc:`IndexError` або :exc:`StopIteration` (або "
"коли індекс падає нижче нуля)."

msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"У той час як операції ``in`` і ``not in`` використовуються лише для простого "
"тестування локалізації в загальному випадку, деякі спеціалізовані "
"послідовності (такі як :class:`str`, :class:`bytes` і :class:`bytearray`) "
"також використовуйте їх для тестування підпослідовності::"

msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Значення *n*, менші за ``0``, розглядаються як ``0`` (що дає порожню "
"послідовність того самого типу, що й *s*). Зверніть увагу, що елементи в "
"послідовності *s* не копіюються; на них посилаються кілька разів. Це часто "
"переслідує нових програмістів Python; розглянути::"

msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Сталося те, що ``[[]]`` є одноелементним списком, який містить порожній "
"список, тому всі три елементи ``[[]] * 3`` є посиланнями на цей єдиний "
"порожній список. Зміна будь-якого з елементів ``списків`` змінює цей єдиний "
"список. Ви можете створити список різних списків таким чином:"

msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Подальші пояснення доступні в розділі поширених запитань :ref:`faq-"
"multidimensional-list`."

msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Якщо *i* або *j* є від’ємними, індекс відноситься до кінця послідовності "
"*s*: замінюється ``len(s) + i`` або ``len(s) + j``. Але зауважте, що ``-0`` "
"все одно ``0``."

msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"Зріз *s* від *i* до *j* визначається як послідовність елементів з індексом "
"*k*, така що ``i <= k < j``. Якщо *i* або *j* більше ніж ``len(s)``, "
"використовуйте ``len(s)``. Якщо *i* пропущено або ``None``, використовуйте "
"``0``. Якщо *j* пропущено або ``None``, використовуйте ``len(s)``. Якщо *i* "
"більше або дорівнює *j*, фрагмент порожній."

msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"Зріз *s* від *i* до *j* з кроком *k* визначається як послідовність елементів "
"з індексом ``x = i + n*k`` так, що ``0 <= n < (j-i )/k``. Іншими словами, "
"індекси ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` і так далі, зупиняючись, коли "
"*j* є досягнуто (але ніколи не включаючи *j*). Коли *k* додатне, *i* і *j* "
"скорочуються до ``len(s)``, якщо вони більші. Коли *k* від’ємне, *i* та *j* "
"скорочуються до ``len(s) - 1``, якщо вони більші. Якщо *i* або *j* пропущені "
"або ``None``, вони стають \"кінцевими\" значеннями (кінець залежить від "
"знака *k*). Зауважте, *k* не може дорівнювати нулю. Якщо *k* має значення "
"``None``, воно розглядається як ``1``."

msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Конкатенація незмінних послідовностей завжди призводить до нового об’єкта. "
"Це означає, що створення послідовності шляхом повторної конкатенації матиме "
"квадратичну вартість виконання в загальній довжині послідовності. Щоб "
"отримати лінійну вартість роботи, ви повинні перейти до однієї з наведених "
"нижче альтернатив:"

msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"якщо конкатенувати об’єкти :class:`str`, ви можете створити список і "
"використовувати :meth:`str.join` наприкінці або записати в екземпляр :class:"
"`io.StringIO` і отримати його значення після завершення"

msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"якщо конкатенація об’єктів :class:`bytes`, ви можете так само "
"використовувати :meth:`bytes.join` або :class:`io.BytesIO`, або ви можете "
"виконати конкатенацію на місці з об’єктом :class:`bytearray`. Об’єкти :class:"
"`bytearray` є змінними та мають ефективний механізм загального розподілу"

msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"якщо конкатенація об’єктів :class:`tuple`, замість цього розширте :class:"
"`list`"

msgid "for other types, investigate the relevant class documentation"
msgstr "для інших типів дослідіть відповідну документацію класу"

msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Деякі типи послідовностей (наприклад, :class:`range`) підтримують лише "
"послідовності елементів, які відповідають певним шаблонам, і, отже, не "
"підтримують конкатенацію або повторення послідовності."

msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` викликає :exc:`ValueError`, коли *x* не знайдено в *s*. Не всі "
"реалізації підтримують передачу додаткових аргументів *i* і *j*. Ці "
"аргументи дозволяють здійснювати ефективний пошук підрозділів послідовності. "
"Передача додаткових аргументів приблизно еквівалентна використанню ``s[i:j]."
"index(x)``, тільки без копіювання будь-яких даних і з повернутим індексом "
"відносно початку послідовності, а не початку фрагмента. ."

msgid "Immutable Sequence Types"
msgstr "Незмінні типи послідовностей"

msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"Єдина операція, яку зазвичай реалізують незмінні типи послідовностей, яка "
"також не реалізована змінними типами послідовностей, це підтримка "
"вбудованого :func:`hash`."

msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Ця підтримка дозволяє використовувати незмінні послідовності, такі як "
"екземпляри :class:`tuple`, як ключі :class:`dict` і зберігати їх у "
"екземплярах :class:`set` і :class:`frozenset`."

msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Спроба хешувати незмінну послідовність, яка містить нехешовані значення, "
"призведе до :exc:`TypeError`."

msgid "Mutable Sequence Types"
msgstr "Змінні типи послідовностей"

msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Операції в наведеній нижче таблиці визначено для змінних типів "
"послідовностей. :class:`collections.abc.MutableSequence` ABC надається, щоб "
"спростити правильну реалізацію цих операцій у настроюваних типах "
"послідовностей."

msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"У таблиці *s* є екземпляром змінного типу послідовності, *t* є будь-яким "
"ітерованим об’єктом, а *x* є довільним об’єктом, який відповідає будь-яким "
"обмеженням типу та значення, накладеним *s* (наприклад, :class:`bytearray` "
"приймає лише цілі числа, які відповідають обмеженню значення ``0 <= x <= "
"255``)."

msgid "``s[i] = x``"
msgstr "``s[i] = x``"

msgid "item *i* of *s* is replaced by *x*"
msgstr "пункт *i* з *s* замінено на *x*"

msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "фрагмент *s* від *i* до *j* замінюється вмістом ітерованого *t*"

msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

msgid "same as ``s[i:j] = []``"
msgstr "те саме, що ``s[i:j] = []``"

msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "елементи ``s[i:j:k]`` замінюються на елементи *t*"

msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "видаляє елементи ``s[i:j:k]`` зі списку"

msgid "``s.append(x)``"
msgstr "``s.append(x)``"

msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"додає *x* до кінця послідовності (те саме, що ``s[len(s):len(s)] = [x]``)"

msgid "``s.clear()``"
msgstr "``s.clear()``"

msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "видаляє всі елементи з *s* (те саме, що ``del s[:]``)"

msgid "``s.copy()``"
msgstr "``s.copy()``"

msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "створює поверхневу копію *s* (те саме, що ``s[:]``)"

msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` або ``s += t``"

msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"розширює *s* вмістом *t* (здебільшого те саме, що ``s[len(s):len(s)] = t``)"

msgid "``s *= n``"
msgstr "``s *= n``"

msgid "updates *s* with its contents repeated *n* times"
msgstr "оновлює *s* з повторенням його вмісту *n* разів"

msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"вставляє *x* в *s* за індексом, заданим *i* (те саме, що ``s[i:i] = [x]``)"

msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` або ``s.pop(i)``"

msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "отримує елемент у *i*, а також видаляє його з *s*"

msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "видалити перший елемент із *s*, де ``s[i]`` дорівнює *x*"

msgid "``s.reverse()``"
msgstr "``s.reverse()``"

msgid "reverses the items of *s* in place"
msgstr "перевертає елементи *s* на місце"

msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* має мати таку саму довжину, що й фрагмент, який він замінює."

msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"Необов’язковий аргумент *i* за умовчанням має значення ``-1``, тому за "
"замовчуванням останній елемент видаляється та повертається."

msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ":meth:`remove` викликає :exc:`ValueError`, коли *x* не знайдено в *s*."

msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"Метод :meth:`reverse` змінює поточну послідовність для економії простору під "
"час реверсування великої послідовності. Щоб нагадати користувачам, що він "
"працює за побічним ефектом, він не повертає зворотну послідовність."

msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` і :meth:`!copy` включено для узгодженості з інтерфейсами "
"змінних контейнерів, які не підтримують операції зрізання (таких як :class:"
"`dict` і :class:`set`). :meth:`!copy` не є частиною :class:`collections.abc."
"MutableSequence` ABC, але більшість конкретних змінних класів послідовності "
"надають його."

msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "Методи :meth:`clear` і :meth:`!copy`."

msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Значення *n* є цілим числом або об’єктом, що реалізує :meth:`~object."
"__index__`. Нульові та негативні значення *n* очищають послідовність. "
"Елементи послідовності не копіюються; на них посилаються кілька разів, як "
"пояснюється для ``s * n`` у :ref:`typesseq-common`."

msgid "Lists"
msgstr "списки"

msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Списки — це змінювані послідовності, які зазвичай використовуються для "
"зберігання колекцій однорідних елементів (де точний ступінь подібності "
"залежить від програми)."

msgid "Lists may be constructed in several ways:"
msgstr "Списки можна створювати кількома способами:"

msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"Використання пари квадратних дужок для позначення порожнього списку: ``[]``"

msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Використовуючи квадратні дужки, розділяючи елементи комами: ``[a]``, ``[a, "
"b, c]``"

msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Використання розуміння списку: ``[x for x in iterable]``"

msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Використання конструктора типу: ``list()`` або ``list(iterable)``"

msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Конструктор створює список, елементи якого є такими ж і в тому ж порядку, що "
"й елементи *iterable*. *iterable* може бути або послідовністю, контейнером, "
"який підтримує ітерацію, або об’єктом ітератора. Якщо *iterable* вже є "
"списком, копія створюється та повертається, подібно до ``iterable[:]``. "
"Наприклад, ``list('abc')`` повертає ``['a', 'b', 'c']``, а ``list( (1, 2, "
"3) )`` повертає ``[ 1, 2, 3]``. Якщо аргумент не задано, конструктор створює "
"новий порожній список, ``[]``."

msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Багато інших операцій також створюють списки, включаючи вбудовану :func:"
"`sorted`."

msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Списки реалізують усі :ref:`common <typesseq-common>` і :ref:`mutable "
"<typesseq-mutable>` операції послідовності. Списки також надають наступний "
"додатковий метод:"

msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Цей метод сортує список на місці, використовуючи лише ``<`` порівняння між "
"елементами. Винятки не пригнічуються — якщо будь-яка операція порівняння "
"завершиться невдало, вся операція сортування буде невдалою (і список, "
"ймовірно, залишиться в частково зміненому стані)."

msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` приймає два аргументи, які можуть бути передані лише ключовим "
"словом (:ref:`аргументи лише для ключових слів <keyword-only_parameter>`):"

msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* визначає функцію одного аргументу, яка використовується для отримання "
"ключа порівняння з кожного елемента списку (наприклад, ``key=str.lower``). "
"Ключ, що відповідає кожному елементу в списку, обчислюється один раз, а "
"потім використовується для всього процесу сортування. Значення за "
"замовчуванням \"Немає\" означає, що елементи списку сортуються безпосередньо "
"без обчислення окремого значення ключа."

msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"Утиліта :func:`functools.cmp_to_key` доступна для перетворення функції *cmp* "
"у стилі 2.x на функцію *key*."

msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* — це логічне значення. Якщо встановлено значення ``True``, "
"елементи списку сортуються так, ніби кожне порівняння було зворотним."

msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Цей метод змінює наявну послідовність для економії простору під час "
"сортування великої послідовності. Щоб нагадати користувачам, що він працює "
"за побічним ефектом, він не повертає відсортовану послідовність "
"(використовуйте :func:`sorted`, щоб явно запитати новий екземпляр "
"відсортованого списку)."

msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"Метод :meth:`sort` гарантовано буде стабільним. Сортування є стабільним, "
"якщо воно гарантує відсутність зміни відносного порядку порівнюваних рівних "
"елементів --- це корисно для сортування за кілька проходів (наприклад, "
"сортування за відділом, а потім за ступенем зарплати)."

msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Приклади сортування та короткий посібник із сортування див. :ref:"
"`sortinghowto`."

msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Поки список сортується, ефект від спроби змінити або навіть перевірити "
"список не визначено. Реалізація Python на C робить список порожнім протягом "
"певного часу та викликає :exc:`ValueError`, якщо він може виявити, що список "
"було змінено під час сортування."

msgid "Tuples"
msgstr "Кортежі"

msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Кортежі — це незмінні послідовності, які зазвичай використовуються для "
"зберігання колекцій різнорідних даних (таких як 2-кортежі, створені за "
"допомогою вбудованої функції :func:`enumerate`). Кортежі також "
"використовуються у випадках, коли потрібна незмінна послідовність однорідних "
"даних (наприклад, дозволити зберігання в екземплярі :class:`set` або :class:"
"`dict`)."

msgid "Tuples may be constructed in a number of ways:"
msgstr "Кортежі можна побудувати кількома способами:"

msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"Використання пари круглих дужок для позначення порожнього кортежу: ``()``"

msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Використання кінцевої коми для одноэлементного кортежу: ``a,`` або ``(a,)``"

msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Розділення елементів комами: ``a, b, c`` або ``(a, b, c)``"

msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Використання вбудованого :func:`tuple`: ``tuple()`` або ``tuple(iterable)``"

msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Конструктор будує кортеж, елементи якого є такими ж і в тому ж порядку, що й "
"елементи *iterable*. *iterable* може бути або послідовністю, контейнером, "
"який підтримує ітерацію, або об’єктом ітератора. Якщо *iterable* вже є "
"кортежем, він повертається без змін. Наприклад, ``tuple('abc')`` повертає "
"``('a', 'b', 'c')``, ``tuple( [1, 2, 3] )`` повертає ``( 1, 2, 3)``. Якщо "
"аргумент не задано, конструктор створює новий порожній кортеж ``()``."

msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Зауважте, що насправді кома створює кортеж, а не круглі дужки. Дужки "
"необов’язкові, за винятком порожнього кортежу або коли вони потрібні для "
"уникнення синтаксичної неоднозначності. Наприклад, \"f(a, b, c)\" — це "
"виклик функції з трьома аргументами, тоді як \"f((a, b, c))\" — це виклик "
"функції з 3-кортежем як єдиним аргумент."

msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Кортежі реалізують усі :ref:`загальні <typesseq-common>` операції "
"послідовності."

msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Для різнорідних колекцій даних, де доступ за іменем є зрозумілішим, ніж "
"доступ за індексом, :func:`collections.namedtuple` може бути більш "
"відповідним вибором, ніж простий об’єкт кортежу."

msgid "Ranges"
msgstr "діапазони"

msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Тип :class:`range` представляє незмінну послідовність чисел і зазвичай "
"використовується для повторення певної кількості разів у циклах :keyword:"
"`for`."

msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Аргументи конструктора діапазону мають бути цілими числами (або вбудованим :"
"class:`int`, або будь-яким об’єктом, який реалізує спеціальний метод :meth:"
"`~object.__index__`). Якщо аргумент *step* опущено, за умовчанням він "
"дорівнює ``1``. Якщо аргумент *початок* опущено, за умовчанням він дорівнює "
"``0``. Якщо *крок* дорівнює нулю, виникає :exc:`ValueError`."

msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Для позитивного *кроку* вміст діапазону ``r`` визначається за формулою "
"``r[i] = start + step*i``, де ``i >= 0`` і ``r[ i] < stop``."

msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Для від’ємного *кроку* вміст діапазону все ще визначається формулою ``r[i] = "
"start + step*i``, але обмеження ``i >= 0`` і ``r[ i] > stop``."

msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Об’єкт діапазону буде порожнім, якщо ``r[0]`` не відповідає обмеженню "
"значення. Діапазони підтримують негативні індекси, але вони інтерпретуються "
"як індексування з кінця послідовності, визначеної позитивними індексами."

msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Діапазони, що містять абсолютні значення, більші за :data:`sys.maxsize`, "
"дозволені, але деякі функції (такі як :func:`len`) можуть викликати :exc:"
"`OverflowError`."

msgid "Range examples::"
msgstr "Приклади асортименту::"

msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Діапазони реалізують усі :ref:`загальні <typesseq-common>` операції "
"послідовності, окрім конкатенації та повторення (через те, що об’єкти "
"діапазону можуть представляти лише послідовності, які дотримуються строгого "
"шаблону, а повторення та конкатенація зазвичай порушують цей шаблон)."

msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "Значення параметра *start* (або ``0``, якщо параметр не було надано)"

msgid "The value of the *stop* parameter"
msgstr "Значення параметра *stop*"

msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "Значення параметра *step* (або ``1``, якщо параметр не було надано)"

msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Перевага типу :class:`range` перед звичайним :class:`list` або :class:"
"`tuple` полягає в тому, що об’єкт :class:`range` завжди займатиме однаковий "
"(невеликий) обсяг пам’яті, ні не має значення розмір діапазону, який він "
"представляє (оскільки він зберігає лише значення ``start``, ``stop`` і "
"``step``, обчислюючи окремі елементи та піддіапазони за потреби)."

msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Об’єкти діапазону реалізують :class:`collections.abc.Sequence` ABC і надають "
"такі функції, як тести на обмеження, пошук індексу елемента, нарізка та "
"підтримка негативних індексів (див. :ref:`typesseq`):"

msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Перевірка об’єктів діапазону на рівність за допомогою ``==`` і ``!=`` "
"порівнює їх як послідовності. Тобто два об’єкти діапазону вважаються "
"рівними, якщо вони представляють однакову послідовність значень. (Зверніть "
"увагу, що два об’єкти діапазону, які порівнюються, можуть мати різні "
"атрибути :attr:`~range.start`, :attr:`~range.stop` і :attr:`~range.step`, "
"наприклад ``range(0 ) == діапазон(2, 1, 3)`` або ``діапазон(0, 3, 2) == "
"діапазон(0, 4, 2)``.)"

msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Реалізуйте послідовність ABC. Підтримка нарізки та негативних індексів. "
"Перевіряйте об’єкти :class:`int` на приналежність у постійному часі замість "
"повторення всіх елементів."

msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Визначте \"==\" і \"!=\", щоб порівнювати об’єкти діапазону на основі "
"послідовності значень, які вони визначають (замість порівняння на основі "
"ідентичності об’єкта)."

msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Атрибути :attr:`~range.start`, :attr:`~range.stop` і :attr:`~range.step`."

msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"Рецепт `linspace <http://code.activestate.com/recipes/579000/>`_ показує, як "
"реалізувати відкладену версію діапазону, придатну для програм із плаваючою "
"комою."

msgid "Text Sequence Type --- :class:`str`"
msgstr "Тип текстової послідовності --- :class:`str`"

msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Текстові дані в Python обробляються за допомогою об’єктів :class:`str` або :"
"dfn:`strings`. Рядки є незмінними :ref:`послідовностями <typesseq>` кодових "
"точок Unicode. Рядкові літерали записуються різними способами:"

msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Одинарні лапки: ``'дозволяє вбудовані \"подвійні\" лапки'``"

msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Подвійні лапки: ``\"дозволяє вбудовані 'одинарні' лапки\"``"

msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Потрійні лапки: ``''Три одинарні лапки''''``, ``\"\"\"Три подвійні "
"лапки\"\"\"``"

msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Рядки з потрійними лапками можуть охоплювати кілька рядків - усі пов’язані "
"пробіли будуть включені в рядковий літерал."

msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Рядкові літерали, які є частиною одного виразу і мають лише пробіли між "
"собою, будуть неявно перетворені в один рядковий літерал. Тобто ``(\"спам \" "
"\"яйця\") == \"спам яйця\"``."

msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Перегляньте :ref:`strings`, щоб дізнатися більше про різні форми рядкових "
"літералів, включаючи підтримувані керуючі послідовності та префікс ``r`` "
"(\"необроблений\"), який вимикає більшість обробки керуючих послідовностей."

msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Рядки також можна створювати з інших об’єктів за допомогою конструктора :"
"class:`str`."

msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Оскільки окремого типу \"символів\" немає, індексування рядка створює рядки "
"довжиною 1. Тобто для непорожнього рядка *s* ``s[0] == s[0:1]``."

msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Також немає змінного типу рядка, але :meth:`str.join` або :class:`io."
"StringIO` можна використовувати для ефективного створення рядків із кількох "
"фрагментів."

msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Для зворотної сумісності з серією Python 2 префікс ``u`` знову дозволений у "
"рядкових літералах. Він не впливає на значення рядкових літералів і не може "
"поєднуватися з префіксом ``r``."

msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Повертає :ref:`string <textseq>` версію *об’єкта*. Якщо *object* не надано, "
"повертає порожній рядок. В іншому випадку поведінка ``str()`` залежить від "
"того, чи вказано *кодування* чи *помилки*, як показано нижче."

msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :meth:"
"`repr(object) <repr>`."
msgstr ""
"Якщо ні *кодування*, ні *помилки* не вказано, ``str(object)`` повертає :meth:"
"`type(object).__str__(object) <object.__str__>`, що є \"неформальним\" або "
"зручним для друку рядковим представленням *об'єкт*. Для рядкових об’єктів це "
"сам рядок. Якщо *object* не має методу :meth:`~object.__str__`, тоді :func:"
"`str` повертається до повернення :meth:`repr(object) <repr>`."

msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Якщо вказано принаймні одну з *кодування* або *помилок*, *об’єкт* має бути :"
"term:`bytes-like object` (наприклад, :class:`bytes` або :class:`bytearray`). "
"У цьому випадку, якщо *object* є об’єктом :class:`bytes` (або :class:"
"`bytearray`), тоді ``str(bytes, encoding, errors)`` еквівалентно :meth:"
"`bytes.decode (кодування, помилки) <bytes.decode>`. В іншому випадку об’єкт "
"bytes, що лежить в основі об’єкта буфера, отримується перед викликом :meth:"
"`bytes.decode`. Перегляньте :ref:`binaryseq` і :ref:`bufferobjects` для "
"отримання інформації про буферні об’єкти."

msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Передача об’єкта :class:`bytes` до :func:`str` без аргументів *encoding* або "
"*errors* підпадає під перший випадок повернення неформального представлення "
"рядка (див. також команду :option:`-b`- рядок для Python). Наприклад::"

msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Додаткову інформацію про клас ``str`` і його методи див. у розділі :ref:"
"`textseq` і :ref:`string-methods` нижче. Щоб вивести форматовані рядки, "
"перегляньте розділи :ref:`f-strings` і :ref:`formatstrings`. Крім того, "
"перегляньте розділ :ref:`stringservices`."

msgid "String Methods"
msgstr "Рядкові методи"

msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Рядки реалізують усі :ref:`загальні <typesseq-common>` операції "
"послідовності разом із додатковими методами, описаними нижче."

msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Рядки також підтримують два стилі форматування рядків: один забезпечує "
"велику гнучкість і налаштування (див. :meth:`str.format`, :ref:"
"`formatstrings` і :ref:`string-formatting`), а інший базується на "
"Форматування стилю C ``printf``, яке обробляє вужчий діапазон типів і трохи "
"важче правильно використовувати, але часто швидше для випадків, які воно "
"може обробляти (:ref:`old-string-formatting`)."

msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"Розділ :ref:`textservices` стандартної бібліотеки охоплює низку інших "
"модулів, які надають різноманітні утиліти, пов’язані з текстом (зокрема "
"підтримку регулярних виразів у модулі :mod:`re`)."

msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "Повертає копію рядка з великим першим символом, а решта малими."

msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Перший символ тепер вводиться в заголовок, а не у верхній регістр. Це "
"означає, що такі символи, як диграфи, матимуть велику першу літеру, а не "
"повний символ."

msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Повертає згорнуту копію рядка. Для зіставлення без регістру можна "
"використовувати рядки з регістром."

msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Згортання регістру подібне до нижнього регістру, але більш агресивне, "
"оскільки воно призначене для видалення всіх відмінностей регістру в рядку. "
"Наприклад, німецька мала літера ``'ß'`` еквівалентна ``\"ss\"``. Оскільки це "
"вже малий регістр, :meth:`lower` нічого не зробить для ``'ß'``; :meth:"
"`casefold` перетворює його на ``\"ss\"``."

msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr "Алгоритм casefolding описано в розділі 3.13 стандарту Unicode."

msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Повернення з центром у рядку довжиною *width*. Заповнення виконується за "
"допомогою вказаного *fillchar* (за замовчуванням це пробіл ASCII). "
"Оригінальний рядок повертається, якщо *width* менше або дорівнює ``len(s)``."

msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Повертає кількість неперекриваючих входжень підрядка *sub* у діапазоні "
"[*початок*, *кінець*]. Необов’язкові аргументи *початок* і *кінець* "
"інтерпретуються як у нотації фрагментів."

msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""
"Повертає закодовану версію рядка як об’єкт bytes. Кодування за замовчуванням "
"``'utf-8'``. *помилки* можуть бути надані для встановлення іншої схеми "
"обробки помилок. Типовим значенням для *помилок* є ``'строгий'``, що "
"означає, що помилки кодування викликають :exc:`UnicodeError`. Інші можливі "
"значення: ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` та будь-яке інше ім’я, зареєстроване через :func:"
"`codecs.register_error`, див. розділ :ref:`error-handlers`. Список можливих "
"кодувань див. у розділі :ref:`standard-encodings`."

msgid ""
"By default, the *errors* argument is not checked for best performances, but "
"only used at the first encoding error. Enable the :ref:`Python Development "
"Mode <devmode>`, or use a :ref:`debug build <debug-build>` to check *errors*."
msgstr ""
"За замовчуванням аргумент *errors* не перевіряється на найкращу "
"продуктивність, а використовується лише при першій помилці кодування. "
"Увімкніть :ref:`Режим розробки Python <devmode>` або скористайтеся :ref:"
"`debug build <debug-build>`, щоб перевірити *помилки*."

msgid "Support for keyword arguments added."
msgstr "Додано підтримку аргументів ключових слів."

msgid ""
"The *errors* is now checked in development mode and in :ref:`debug mode "
"<debug-build>`."
msgstr ""
"*Помилки* тепер перевіряються в режимі розробки та в :ref:`режимі "
"налагодження <debug-build>`."

msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Повертає ``True``, якщо рядок закінчується вказаним *суфіксом*, інакше "
"повертає ``False``. *suffix* також може бути кортежем суфіксів для пошуку. З "
"необов'язковим *початком* тестування починається з цієї позиції. З "
"необов’язковим *end*, припинити порівняння на цій позиції."

msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Повертає копію рядка, де всі символи табуляції замінені одним або кількома "
"пробілами, залежно від поточного стовпця та заданого розміру табуляції. "
"Позиції табуляції відбуваються з кожним символом *tabsize* (за замовчуванням "
"— 8, надаючи позиції табуляції в стовпцях 0, 8, 16 тощо). Щоб розгорнути "
"рядок, поточний стовпець встановлюється на нуль, а рядок перевіряється "
"символ за символом. Якщо символ є табуляцією (``\\t``), один або кілька "
"символів пробілу вставляються в результат, доки поточний стовпець не "
"зрівняється з позицією наступної табуляції. (Сам символ табуляції не "
"копіюється.) Якщо символ є символом нового рядка (``\\n``) або повернення "
"(``\\r``), він копіюється, а поточний стовпець скидається до нуля. Будь-який "
"інший символ копіюється без змін, а поточний стовпець збільшується на "
"одиницю незалежно від того, як символ представлено під час друку."

msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Повертає найнижчий індекс у рядку, де підрядок *sub* знайдено в фрагменті "
"``s[start:end]``. Необов’язкові аргументи *початок* і *кінець* "
"інтерпретуються як у нотації фрагментів. Повертає ``-1``, якщо *sub* не "
"знайдено."

msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Метод :meth:`~str.find` слід використовувати, лише якщо вам потрібно знати "
"позицію *sub*. Щоб перевірити, чи є *sub* підрядком, скористайтеся "
"оператором :keyword:`in`::"

msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Виконайте операцію форматування рядка. Рядок, у якому викликається цей "
"метод, може містити літеральний текст або поля заміни, розділені дужками ``{}"
"``. Кожне поле заміни містить або числовий індекс позиційного аргументу, або "
"назву ключового аргументу. Повертає копію рядка, де кожне поле заміни "
"замінено рядковим значенням відповідного аргументу."

msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Перегляньте :ref:`formatstrings` для опису різних параметрів форматування, "
"які можна вказати в рядках формату."

msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Під час форматування числа (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` і підкласів) із типом ``n`` (наприклад: ``'{:n}'."
"format(1234)``, функція тимчасово встановлює локаль ``LC_CTYPE`` на мову "
"``LC_NUMERIC`` для декодування полів ``decimal_point`` і ``thousands_sep`` :"
"c:func:`localeconv`, якщо вони не є ASCII або довші за 1 байт, а локаль "
"``LC_NUMERIC`` відрізняється від локалі ``LC_CTYPE``. Ця тимчасова зміна "
"впливає на інші потоки."

msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Під час форматування числа за допомогою типу ``n``, у деяких випадках "
"функція тимчасово встановлює ``LC_CTYPE`` локаль ``LC_NUMERIC``."

msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Подібно до ``str.format(**mapping)``, за винятком того, що ``mapping`` "
"використовується безпосередньо, а не копіюється в :class:`dict`. Це корисно, "
"якщо, наприклад, ``mapping`` є підкласом dict:"

msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Як :meth:`~str.find`, але викликає :exc:`ValueError`, коли підрядок не "
"знайдено."

msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є буквено-цифровими і є "
"принаймні один символ, ``False`` інакше. Символ ``c`` є буквено-цифровим, "
"якщо одне з наступного повертає ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()`` або ``c.isnumeric()``."

msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the "
"\"Alphabetic\" property defined in the Unicode Standard."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку алфавітні та є принаймні один "
"символ, ``False`` інакше. Алфавітні символи — це символи, визначені в базі "
"даних символів Юнікоду як \"букви\", тобто такі, що мають загальну категорію "
"як \"Lm\", \"Lt\", \"Lu\", \"Ll\" або \"Lo\". Зауважте, що це відрізняється "
"від властивості \"Alphabetic\", визначеної в стандарті Unicode."

msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Повертає ``True``, якщо рядок порожній або всі символи в рядку є ASCII, "
"``False`` інакше. Символи ASCII мають кодові точки в діапазоні U+0000-U+007F."

msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є десятковими символами і є "
"принаймні один символ, ``False`` інакше. Десяткові символи – це ті, які "
"можна використовувати для утворення чисел за основою 10, напр. U+0660, "
"АРАБСЬКО-ІНДІЙСЬКА ЦИФРА НУЛЬ. Формально десятковий символ — це символ у "
"загальній категорії Unicode \"Nd\"."

msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є цифрами і є принаймні один "
"символ, ``False`` інакше. Цифри включають десяткові символи та цифри, які "
"потребують спеціальної обробки, наприклад цифри сумісності над індексом. Це "
"охоплює цифри, які не можна використовувати для формування чисел з основою "
"10, як-от числа Харості. Формально цифра — це символ, який має значення "
"властивості Numeric_Type=Digit або Numeric_Type=Decimal."

msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Повертає ``True``, якщо рядок є дійсним ідентифікатором відповідно до "
"визначення мови, розділ :ref:`identifiers`."

msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"Викличте :func:`keyword.iskeyword`, щоб перевірити, чи рядок ``s`` є "
"зарезервованим ідентифікатором, таким як :keyword:`def` і :keyword:`class`."

msgid "Example: ::"
msgstr "Приклад: ::"

msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо всі символи регістру [4]_ в рядку є малими і є "
"принаймні один символ регістру, ``False`` інакше."

msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є цифровими символами, і є "
"принаймні один символ, ``False`` інакше. Цифрові символи включають цифрові "
"символи та всі символи, які мають властивість числового значення Unicode, "
"напр. U+2155, ВУЛЬГАРНА ФРАКЦІЯ ОДНА П’ЯТА. Формально цифровими символами є "
"символи зі значенням властивості Numeric_Type=Digit, Numeric_Type=Decimal "
"або Numeric_Type=Numeric."

msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Повертає ``True``, якщо всі символи в рядку можна надрукувати або рядок "
"порожній, ``False`` інакше. Символи, що не друкуються, — це символи, "
"визначені в базі даних символів Unicode як \"Інші\" або \"Розділювачі\", за "
"винятком пробілу ASCII (0x20), який вважається придатним для друку. "
"(Зауважте, що друковані символи в цьому контексті – це ті символи, які не "
"слід екранувати, коли :func:`repr` викликається в рядку. Це не впливає на "
"обробку рядків, записаних у :data:`sys.stdout` або :data:`sys.stderr`.)"

msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо в рядку є лише пробіли та є принаймні один символ, "
"``False`` інакше."

msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Символ є *пробілом*, якщо в базі даних символів Unicode (див. :mod:"
"`unicodedata`) або його загальна категорія ``Zs`` (\"Роздільник, пробіл\"), "
"або його двонаправлений клас є одним із ``WS``, ``B`` або ``S``."

msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Повертає ``True``, якщо рядок є рядком із заголовком і містить принаймні "
"один символ, наприклад, символи верхнього регістру можуть слідувати лише за "
"символами без регістру, а символи нижнього регістру – лише за символами в "
"регістрі. В іншому випадку поверніть ``False``."

msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо всі символи регістру [4]_ в рядку є верхніми і є "
"принаймні один символ регістру, ``False`` інакше."

msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Повертає рядок, який є конкатенацією рядків у *iterable*. Помилка :exc:"
"`TypeError` буде викликана, якщо в *iterable* є будь-які нерядкові значення, "
"включаючи об’єкти :class:`bytes`. Роздільником між елементами є рядок, що "
"забезпечує цей метод."

msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Повертає рядок, вирівняний за лівим краєм, у рядку довжини *width*. "
"Заповнення виконується за допомогою вказаного *fillchar* (за замовчуванням "
"це пробіл ASCII). Оригінальний рядок повертається, якщо *width* менше або "
"дорівнює ``len(s)``."

msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Повертає копію рядка з усіма регістровими символами [4]_, перетвореними на "
"нижній регістр."

msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"Алгоритм використання нижнього регістру описано в розділі 3.13 стандарту "
"Unicode."

msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Повертає копію рядка з видаленими початковими символами. Аргумент *chars* — "
"це рядок, який визначає набір символів, які потрібно видалити. Якщо "
"пропущено або ``None``, аргумент *chars* за умовчанням видаляє пробіли. "
"Аргумент *chars* не є префіксом; навпаки, усі комбінації його значень "
"видаляються:"

msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Перегляньте :meth:`str.removeprefix` для методу, який видаляє один рядок "
"префікса, а не весь набір символів. Наприклад::"

msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Цей статичний метод повертає таблицю перекладу, яку можна використовувати "
"для :meth:`str.translate`."

msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Якщо є лише один аргумент, це має бути словник, який відображає порядкові "
"номери Unicode (цілі числа) або символи (рядки довжиною 1) на порядкові "
"номери Unicode, рядки (довільної довжини) або ``None``. Потім символьні "
"ключі будуть перетворені на порядкові."

msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Якщо є два аргументи, вони мають бути рядками однакової довжини, і в "
"отриманому словнику кожен символ у x буде зіставлено зі символом у тій же "
"позиції в y. Якщо є третій аргумент, це має бути рядок, символи якого будуть "
"зіставлені на ``None`` у результаті."

msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Розділіть рядок при першому входженні *sep* і поверніть 3-кортеж, що містить "
"частину перед роздільником, сам роздільник і частину після роздільника. Якщо "
"роздільник не знайдено, поверніть 3-кортеж, що містить сам рядок, а потім "
"два порожні рядки."

msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Якщо рядок починається з рядка *prefix*, поверніть ``string[len(prefix):]``. "
"В іншому випадку поверніть копію оригінального рядка::"

msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Якщо рядок закінчується рядком *suffix* і цей *suffix* не є порожнім, "
"поверніть ``string[:-len(suffix)]``. В іншому випадку поверніть копію "
"оригінального рядка::"

msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Повертає копію рядка з усіма входженнями підрядка *old*, заміненими на "
"*new*. Якщо вказано необов’язковий аргумент *count*, заміняються лише перші "
"випадки *count*."

msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Повертає найвищий індекс у рядку, де знайдено підрядок *sub*, так що *sub* "
"міститься в ``s[start:end]``. Необов’язкові аргументи *початок* і *кінець* "
"інтерпретуються як у нотації фрагментів. Повернути ``-1`` у разі помилки."

msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Подібно до :meth:`rfind`, але викликає :exc:`ValueError`, коли підрядок "
"*sub* не знайдено."

msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Повертає рядок, вирівняний по правому краю, у рядку довжини *width*. "
"Заповнення виконується за допомогою вказаного *fillchar* (за замовчуванням "
"це пробіл ASCII). Оригінальний рядок повертається, якщо *width* менше або "
"дорівнює ``len(s)``."

msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Розділіть рядок на останнє входження *sep* і поверніть 3-кортеж, що містить "
"частину перед роздільником, сам роздільник і частину після роздільника. Якщо "
"роздільник не знайдено, поверніть 3-кортеж, що містить два порожні рядки, а "
"потім сам рядок."

msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Повертає список слів у рядку, використовуючи *sep* як роздільник. Якщо "
"задано *maxsplit*, виконується щонайбільше *maxsplit* розбиття, "
"*найправіші*. Якщо *sep* не вказано або ``None``, будь-який пробільний рядок "
"є роздільником. За винятком розділення справа, :meth:`rsplit` поводиться як :"
"meth:`split`, що детально описано нижче."

msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Повертає копію рядка з видаленими кінцевими символами. Аргумент *chars* — це "
"рядок, який визначає набір символів, які потрібно видалити. Якщо пропущено "
"або ``None``, аргумент *chars* за умовчанням видаляє пробіли. Аргумент "
"*chars* не є суфіксом; навпаки, усі комбінації його значень видаляються:"

msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Перегляньте :meth:`str.removesuffix` для методу, який видаляє один рядок "
"суфікса, а не весь набір символів. Наприклад::"

msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Повертає список слів у рядку, використовуючи *sep* як роздільник. Якщо "
"вказано *maxsplit*, виконується щонайбільше *maxsplit* розбиття (отже, "
"список міститиме щонайбільше елементів ``maxsplit+1``). Якщо *maxsplit* не "
"вказано або ``-1``, тоді немає обмеження на кількість розділень (виконуються "
"всі можливі розділення)."

msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Якщо задано *sep*, послідовні розділювачі не групуються разом і вважаються "
"роздільниками порожніх рядків (наприклад, ``'1,,2'.split(',')`` повертає "
"``['1', ' ', '2']``). Аргумент *sep* може складатися з кількох символів "
"(наприклад, ``'1 <> 2 <> 3'.split(' <> ')`` повертає ``['1', '2', '3']`` ). "
"Розділення порожнього рядка з указаним роздільником повертає ``['']``."

msgid "For example::"
msgstr "Наприклад::"

msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Якщо *sep* не вказано або має значення ``None``, застосовується інший "
"алгоритм поділу: цикли послідовних пробілів розглядаються як один "
"роздільник, і результат не міститиме порожніх рядків на початку або в кінці, "
"якщо рядок має пробіли на початку або в кінці. Отже, розділення порожнього "
"рядка або рядка, що складається лише з пробілів, за допомогою розділювача "
"``None`` повертає ``[]``."

msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Повертає список рядків у рядку, розриваючи межі рядків. Розриви рядків не "
"включаються в результуючий список, якщо *keepends* не задано і не відповідає "
"дійсності."

msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Цей метод розбивається на наступні межі рядків. Зокрема, межі є надмножиною :"
"term:`universal newlines`."

msgid "Representation"
msgstr "Представництво"

msgid "Description"
msgstr "опис"

msgid "``\\n``"
msgstr "``\\n``"

msgid "Line Feed"
msgstr "Переведення рядка"

msgid "``\\r``"
msgstr "``\\r``"

msgid "Carriage Return"
msgstr "Повернення каретки"

msgid "``\\r\\n``"
msgstr "``\\r\\n``"

msgid "Carriage Return + Line Feed"
msgstr "Повернення каретки + Переведення рядка"

msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` або ``\\x0b``"

msgid "Line Tabulation"
msgstr "Лінія табуляції"

msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` або ``\\x0c``"

msgid "Form Feed"
msgstr "Подача форми"

msgid "``\\x1c``"
msgstr "``\\x1c``"

msgid "File Separator"
msgstr "Роздільник файлів"

msgid "``\\x1d``"
msgstr "``\\x1d``"

msgid "Group Separator"
msgstr "Роздільник груп"

msgid "``\\x1e``"
msgstr "``\\x1e``"

msgid "Record Separator"
msgstr "Розділювач записів"

msgid "``\\x85``"
msgstr "``\\x85``"

msgid "Next Line (C1 Control Code)"
msgstr "Наступний рядок (контрольний код C1)"

msgid "``\\u2028``"
msgstr "``\\u2028``"

msgid "Line Separator"
msgstr "Розділювач рядків"

msgid "``\\u2029``"
msgstr "``\\u2029``"

msgid "Paragraph Separator"
msgstr "Роздільник абзаців"

msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` і ``\\f`` додано до списку меж ліній."

msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"На відміну від :meth:`~str.split`, коли задано рядок роздільника *sep*, цей "
"метод повертає порожній список для порожнього рядка, а розрив кінцевого "
"рядка не призводить до додаткового рядка::"

msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Для порівняння ``split('\\n')`` дає:"

msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Повертає ``True``, якщо рядок починається з *префікса*, інакше повертає "
"``False``. *префікс* також може бути кортежем префіксів для пошуку. З "
"необов’язковим *початком*, тестовий рядок починається з цієї позиції. З "
"необов’язковим *end* припиняє порівнювати рядок у цій позиції."

msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Повертає копію рядка з видаленими початковими та кінцевими символами. "
"Аргумент *chars* — це рядок, який визначає набір символів, які потрібно "
"видалити. Якщо пропущено або ``None``, аргумент *chars* за умовчанням "
"видаляє пробіли. Аргумент *chars* не є префіксом або суфіксом; навпаки, усі "
"комбінації його значень видаляються:"

msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Зовнішні початкові та кінцеві значення аргументів *chars* видаляються з "
"рядка. Символи видаляються з початку, доки не досягнеться символ рядка, який "
"не міститься в наборі символів у *chars*. Подібна дія відбувається на кінці. "
"Наприклад::"

msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Повертає копію рядка з символами верхнього регістру, перетвореними на малі, "
"і навпаки. Зауважте, що ``s.swapcase().swapcase() == s`` не обов’язково "
"правда."

msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Повертає версію рядка в заголовку, де слова починаються з великої літери, а "
"решта символів – нижніми."

msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Алгоритм використовує просте незалежне від мови визначення слова як групи "
"послідовних букв. Визначення працює в багатьох контекстах, але це означає, "
"що апостроф у скороченнях і присвійних формах формує межі слів, що може бути "
"не бажаним результатом:"

msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"Функція :func:`string.capwords` не має цієї проблеми, оскільки вона розділяє "
"слова лише на пробіли."

msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Крім того, обхідний шлях для апострофів можна створити за допомогою "
"регулярних виразів::"

msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Повертає копію рядка, у якому кожен символ було зіставлено через задану "
"таблицю перекладу. Таблиця має бути об’єктом, який реалізує індексування "
"через :meth:`__getitem__`, як правило, :term:`mapping` або :term:`sequence`. "
"Коли індексується порядковим номером Unicode (цілим числом), об’єкт таблиці "
"може виконувати будь-яку з наступних дій: повертати порядковий номер Unicode "
"або рядок, щоб зіставити символ з одним або декількома іншими символами; "
"return ``None``, щоб видалити символ із рядка повернення; або викликати "
"виняток :exc:`LookupError`, щоб зіставити символ із собою."

msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Ви можете використовувати :meth:`str.maketrans`, щоб створити карту "
"перекладу з відображень символів у різні формати."

msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Перегляньте також модуль :mod:`codecs` для більш гнучкого підходу до "
"нестандартних відображень символів."

msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Повертає копію рядка з усіма символами [4]_, перетвореними на верхній "
"регістр. Зауважте, що ``s.upper().isupper()`` може мати значення ``False``, "
"якщо ``s`` містить символи без регістру або якщо категорія Юнікоду "
"результуючих символів не є \"Lu\" (літера , верхній регістр), але напр. "
"\"Lt\" (літера, регістр)."

msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"Використовуваний алгоритм верхнього регістру описано в розділі 3.13 "
"стандарту Unicode."

msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Поверніть копію рядка зліва, заповненого цифрами ASCII ``'0''``, щоб "
"отримати рядок довжини *width*. Початковий префікс знака (``'+'``/``'-'``) "
"обробляється шляхом вставки заповнення *після* символу знака, а не перед "
"ним. Оригінальний рядок повертається, якщо *width* менше або дорівнює "
"``len(s)``."

msgid "``printf``-style String Formatting"
msgstr "Форматування рядків у стилі ``printf``"

msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Операції форматування, описані тут, демонструють різноманітні особливості, "
"які призводять до низки поширених помилок (наприклад, неправильне "
"відображення кортежів і словників). Використання нових :ref:`відформатованих "
"рядкових літералів <f-strings>`, інтерфейсу :meth:`str.format` або :ref:"
"`шаблонних рядків <template-strings>` може допомогти уникнути цих помилок. "
"Кожна з цих альтернатив забезпечує власні компроміси та переваги простоти, "
"гнучкості та/або розширюваності."

msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Рядкові об’єкти мають одну унікальну вбудовану операцію: оператор ``%`` (по "
"модулю). Це також відоме як оператор *форматування* рядка або "
"*інтерполяції*. З огляду на ``формат % значень`` (де *format* є рядком), "
"``%`` специфікації перетворення у *format* замінюються нулем або більше "
"елементами *значень*. Ефект подібний до використання :c:func:`sprintf` у "
"мові C."

msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Якщо для *format* потрібен один аргумент, *values* може бути одним "
"некортежним об’єктом. [5]_ В іншому випадку *values* має бути кортежем із "
"точною кількістю елементів, визначених рядком формату, або одним об’єктом "
"відображення (наприклад, словником)."

msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Специфікатор перетворення містить два або більше символів і має наступні "
"компоненти, які мають відображатися в такому порядку:"

msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Символ ``'%'``, який позначає початок специфікатора."

msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Ключ відображення (необов’язковий), що складається з послідовності символів "
"у дужках (наприклад, ``(якесь ім’я)``)."

msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Прапорці перетворення (опціонально), які впливають на результат деяких типів "
"перетворення."

msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Мінімальна ширина поля (опціонально). Якщо вказано як ``'*'`` (зірочка), "
"фактична ширина зчитується з наступного елемента кортежу в *значеннях*, а "
"об’єкт для перетворення йде після мінімальної ширини поля та необов’язкової "
"точності."

msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Точність (необов’язкова), подається як ``'.'`` (крапка), за якою йде "
"точність. Якщо вказано як ``'*'`` (зірочка), фактична точність зчитується з "
"наступного елемента кортежу в *значеннях*, а значення для перетворення йде "
"після точності."

msgid "Length modifier (optional)."
msgstr "Модифікатор довжини (необов'язково)."

msgid "Conversion type."
msgstr "Тип перетворення."

msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Якщо правильний аргумент є словником (або іншим типом відображення), то "
"формати в рядку *мають* містити ключ відображення в дужках у цьому словнику, "
"вставлений одразу після символу ``'%'``. Ключ відображення вибирає значення, "
"яке потрібно відформатувати, із відображення. Наприклад:"

msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"У цьому випадку у форматі не може бути специфікаторів ``*`` (оскільки вони "
"вимагають послідовного списку параметрів)."

msgid "The conversion flag characters are:"
msgstr "Символи прапора перетворення:"

msgid "Flag"
msgstr "Прапор"

msgid "``'#'``"
msgstr "``'#''``"

msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"Перетворення значень використовуватиме \"альтернативну форму\" (де визначено "
"нижче)."

msgid "``'0'``"
msgstr "``'0'``"

msgid "The conversion will be zero padded for numeric values."
msgstr "Перетворення буде доповнено нулем для числових значень."

msgid "``'-'``"
msgstr "``'-'``"

msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Перетворене значення коригується зліва (перевизначає перетворення ``'0'``, "
"якщо подано обидва значення)."

msgid "``' '``"
msgstr "``' '``"

msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(пробіл) Пробіл слід залишити перед додатним числом (або порожнім рядком), "
"утвореним перетворенням зі знаком."

msgid "``'+'``"
msgstr "``'+'``"

msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Символ знака (``'+'`` або ``'-'``) передуватиме перетворенню (перевизначає "
"позначку \"пробіл\")."

msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Модифікатор довжини (``h``, ``l`` або ``L``) може бути присутнім, але він "
"ігнорується, оскільки він не є необхідним для Python - так, напр. ``%ld`` "
"ідентичний ``%d``."

msgid "The conversion types are:"
msgstr "Типи перетворення:"

msgid "Conversion"
msgstr "Перетворення"

msgid "``'d'``"
msgstr "``'d''``"

msgid "Signed integer decimal."
msgstr "Ціле десяткове число зі знаком."

msgid "``'i'``"
msgstr "``'я''``"

msgid "``'o'``"
msgstr "``'o'``"

msgid "Signed octal value."
msgstr "Вісімкове значення зі знаком."

msgid "``'u'``"
msgstr "``'u''``"

msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Застарілий тип -- він ідентичний ``'d'``."

msgid "``'x'``"
msgstr "``'x''``"

msgid "Signed hexadecimal (lowercase)."
msgstr "Шістнадцяткове число зі знаком (нижній регістр)."

msgid "``'X'``"
msgstr "``'X''``"

msgid "Signed hexadecimal (uppercase)."
msgstr "Шістнадцяткове число зі знаком (верхній регістр)."

msgid "``'e'``"
msgstr "``'e''``"

msgid "Floating point exponential format (lowercase)."
msgstr "Експоненціальний формат із плаваючою комою (нижній регістр)."

msgid "``'E'``"
msgstr "``'E'``"

msgid "Floating point exponential format (uppercase)."
msgstr "Експоненціальний формат із плаваючою комою (верхній регістр)."

msgid "``'f'``"
msgstr "``'f''``"

msgid "Floating point decimal format."
msgstr "Десятковий формат із плаваючою комою."

msgid "``'F'``"
msgstr "``'F''``"

msgid "``'g'``"
msgstr "``'g''``"

msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Формат з плаваючою комою. Використовує нижній регістр експоненціального "
"формату, якщо показник степеня менший за -4 або не менший за точність, "
"десятковий формат інакше."

msgid "``'G'``"
msgstr "``'G''``"

msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Формат з плаваючою комою. Використовує експоненціальний формат у верхньому "
"регістрі, якщо показник степеня менший за -4 або не менший за точність, "
"інакше – десятковий формат."

msgid "``'c'``"
msgstr "``'c''``"

msgid "Single character (accepts integer or single character string)."
msgstr "Один символ (приймає рядок цілих чи односимвольних символів)."

msgid "``'r'``"
msgstr "``'r''``"

msgid "String (converts any Python object using :func:`repr`)."
msgstr "Рядок (перетворює будь-який об’єкт Python за допомогою :func:`repr`)."

msgid "``'s'``"
msgstr "``'s''``"

msgid "String (converts any Python object using :func:`str`)."
msgstr "Рядок (перетворює будь-який об’єкт Python за допомогою :func:`str`)."

msgid "``'a'``"
msgstr "``'a'``"

msgid "String (converts any Python object using :func:`ascii`)."
msgstr "Рядок (перетворює будь-який об’єкт Python за допомогою :func:`ascii`)."

msgid "``'%'``"
msgstr "``'%'``"

msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Жоден аргумент не перетворюється, результатом є символ ``'%'`` в результаті."

msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"Альтернативна форма призводить до того, що початковий вісімковий "
"специфікатор (``'0o'``) буде вставлено перед першою цифрою."

msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"Альтернативна форма призводить до того, що початковий ``'0x'`` або ``'0X'`` "
"(залежно від того, використовувався формат ``'x'`` або ``'X'``) буде "
"вставлено перед перша цифра."

msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"Альтернативна форма призводить до того, що результат завжди містить "
"десяткову крапку, навіть якщо за нею не йде цифра."

msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"Точність визначає кількість цифр після коми та за замовчуванням дорівнює 6."

msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"Альтернативна форма призводить до того, що результат завжди містить "
"десяткову кому, а кінцеві нулі не видаляються, як це було б інакше."

msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"Точність визначає кількість значущих цифр до та після десяткової коми та за "
"умовчанням дорівнює 6."

msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Якщо точність ``N``, вивід скорочується до ``N`` символів."

msgid "See :pep:`237`."
msgstr "Дивіться :pep:`237`."

msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Оскільки рядки Python мають явну довжину, перетворення ``%s`` не "
"припускають, що ``'\\0`` є кінцем рядка."

msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Перетворення ``%f`` для чисел, абсолютне значення яких перевищує 1e50, "
"більше не замінюються перетвореннями ``%g``."

msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Типи бінарних послідовностей --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Основними вбудованими типами для обробки двійкових даних є :class:`bytes` і :"
"class:`bytearray`. Вони підтримуються :class:`memoryview`, який "
"використовує :ref:`протокол буфера <bufferobjects>` для доступу до пам’яті "
"інших бінарних об’єктів без необхідності створення копії."

msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Модуль :mod:`array` підтримує ефективне зберігання основних типів даних, "
"таких як 32-розрядні цілі числа та плаваючі значення подвійної точності "
"IEEE754."

msgid "Bytes Objects"
msgstr "Об'єкти Bytes"

msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Об’єкти Bytes — це незмінні послідовності окремих байтів. Оскільки багато "
"основних двійкових протоколів базуються на текстовому кодуванні ASCII, "
"об’єкти bytes пропонують кілька методів, які дійсні лише під час роботи з "
"даними, сумісними з ASCII, і тісно пов’язані з рядковими об’єктами різними "
"способами."

msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"По-перше, синтаксис байтових літералів здебільшого такий самий, як і для "
"рядкових літералів, за винятком того, що додано префікс ``b``:"

msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Одинарні лапки: ``b'все ще дозволяє вбудовані \"подвійні\" лапки``"

msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "Подвійні лапки: ``b\"все ще дозволяє вбудовані 'одинарні' лапки``"

msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Потрійні лапки: ``b''''3 одинарні лапки''''``, ``b\"\"\"3 подвійні "
"лапки\"\"\"``"

msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"У байтових літералах дозволені лише символи ASCII (незалежно від оголошеного "
"кодування вихідного коду). Будь-які двійкові значення понад 127 потрібно "
"вводити в байтові літерали за допомогою відповідної керуючої послідовності."

msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Як і рядкові літерали, літерали bytes також можуть використовувати префікс "
"``r``, щоб вимкнути обробку керуючих послідовностей. Перегляньте :ref:"
"`strings`, щоб дізнатися більше про різні форми літералів байтів, включаючи "
"підтримувані керуючі послідовності."

msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"У той час як байтові літерали та представлення базуються на тексті ASCII, "
"об’єкти байтів фактично поводяться як незмінні послідовності цілих чисел, де "
"кожне значення в послідовності обмежено таким чином, що ``0 <= x < 256`` "
"(спроби порушити це обмеження викличуть :exc:`ValueError`). Це зроблено "
"навмисно, щоб підкреслити, що хоча багато двійкових форматів включають "
"елементи на основі ASCII і ними можна корисно маніпулювати за допомогою "
"деяких текстово-орієнтованих алгоритмів, це зазвичай не стосується довільних "
"двійкових даних (сліпе застосування алгоритмів обробки тексту до двійкових "
"форматів даних, які не Сумісність із ASCII зазвичай призводить до "
"пошкодження даних)."

msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Окрім літеральних форм, об’єкти bytes можна створювати кількома іншими "
"способами:"

msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "Об’єкт із заповненими нулем байтами вказаної довжини: ``bytes(10)``"

msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "З ітерації цілих чисел: ``bytes(range(20))``"

msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Копіювання існуючих двійкових даних через протокол буфера: ``bytes(obj)``"

msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Також перегляньте вбудований :ref:`bytes <func-bytes>`."

msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Оскільки 2 шістнадцяткові цифри точно відповідають одному байту, "
"шістнадцяткові числа є широко використовуваним форматом для опису двійкових "
"даних. Відповідно, тип bytes має додатковий метод класу для читання даних у "
"цьому форматі:"

msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Цей метод класу :class:`bytes` повертає об’єкт bytes, декодуючи даний "
"рядковий об’єкт. Рядок має містити дві шістнадцяткові цифри на байт, при "
"цьому пробіли ASCII ігноруються."

msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` тепер пропускає всі пробіли ASCII у рядку, а не лише "
"пробіли."

msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Існує функція зворотного перетворення для перетворення об’єкта байтів у його "
"шістнадцяткове представлення."

msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Повертає рядковий об’єкт, що містить дві шістнадцяткові цифри для кожного "
"байта екземпляра."

msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default "
"between each byte.  A second optional *bytes_per_sep* parameter controls the "
"spacing.  Positive values calculate the separator position from the right, "
"negative values from the left."
msgstr ""
"Якщо ви хочете зробити шістнадцятковий рядок легшим для читання, ви можете "
"вказати параметр розділювача з одним символом *sep*, який буде включено у "
"вивід. За замовчуванням між кожним байтом. Другий необов’язковий параметр "
"*bytes_per_sep* керує інтервалом. Додатні значення обчислюють положення "
"роздільника справа, від’ємні значення – ліворуч."

msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` тепер підтримує додаткові параметри *sep* і "
"*bytes_per_sep* для вставки роздільників між байтами в шістнадцятковому "
"виведенні."

msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Оскільки об’єкти bytes — це послідовності цілих чисел (подібно до кортежу), "
"для об’єкта bytes *b* \"b[0]\" буде цілим числом, тоді як \"b[0:1]\" буде "
"байтом об’єкт довжини 1. (Це контрастує з текстовими рядками, де як "
"індексування, так і нарізка створять рядок довжиною 1)"

msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"Для представлення об’єктів bytes використовується літеральний формат "
"(``b'...''``), оскільки він часто корисніший, ніж, наприклад, ``bytes([46, "
"46, 46])``. Ви завжди можете перетворити об’єкт bytes на список цілих чисел "
"за допомогою ``list(b)``."

msgid "Bytearray Objects"
msgstr "Об’єкти байтового масиву"

msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Об’єкти :class:`bytearray` є змінними аналогами об’єктів :class:`bytes`."

msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Для об’єктів bytearray немає виділеного синтаксису літералів, натомість вони "
"завжди створюються шляхом виклику конструктора:"

msgid "Creating an empty instance: ``bytearray()``"
msgstr "Створення порожнього екземпляра: ``bytearray()``"

msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Створення екземпляра із заповненням нуля із заданою довжиною: "
"``bytearray(10)``"

msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "З ітерації цілих чисел: ``bytearray(range(20))``"

msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Копіювання наявних двійкових даних за допомогою буферного протоколу: "
"``bytearray(b'Hi!')``"

msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Оскільки об’єкти bytearray є змінними, вони підтримують операції "
"послідовності :ref:`mutable <typesseq-mutable>` на додаток до звичайних "
"операцій з байтами та байтовими масивами, описаних у :ref:`bytes-methods`."

msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Також перегляньте вбудований :ref:`bytearray <func-bytearray>`."

msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Оскільки 2 шістнадцяткові цифри точно відповідають одному байту, "
"шістнадцяткові числа є широко використовуваним форматом для опису двійкових "
"даних. Відповідно, тип bytearray має додатковий метод класу для читання "
"даних у цьому форматі:"

msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Цей метод класу :class:`bytearray` повертає об’єкт bytearray, декодуючи "
"заданий рядковий об’єкт. Рядок має містити дві шістнадцяткові цифри на байт, "
"при цьому пробіли ASCII ігноруються."

msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` тепер пропускає всі пробіли ASCII у рядку, а не "
"лише пробіли."

msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Існує функція зворотного перетворення для перетворення об’єкта байтового "
"масиву в його шістнадцяткове представлення."

msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Подібно до :meth:`bytes.hex`, :meth:`bytearray.hex` тепер підтримує "
"додаткові параметри *sep* і *bytes_per_sep* для вставки роздільників між "
"байтами в шістнадцятковому виведенні."

msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Оскільки об’єкти bytearray — це послідовності цілих чисел (схожі на список), "
"для об’єкта bytearray *b* \"b[0]\" буде цілим числом, а \"b[0:1]\" буде "
"масивом bytearray об’єкт довжини 1. (Це контрастує з текстовими рядками, де "
"як індексування, так і нарізка створять рядок довжиною 1)"

msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"У представленні об’єктів bytearray використовується формат літералу bytes "
"(``bytearray(b'...')``), оскільки він часто корисніший, ніж, наприклад, "
"``bytearray([46, 46, 46])``. Ви завжди можете перетворити об’єкт bytearray "
"на список цілих чисел за допомогою ``list(b)``."

msgid "Bytes and Bytearray Operations"
msgstr "Операції з байтами та масивом байтів"

msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Як об’єкти bytes, так і bytearray підтримують операції послідовності :ref:"
"`common <typesseq-common>`. Вони взаємодіють не тільки з операндами того "
"самого типу, але й з будь-яким :term:`bytes-like object`. Завдяки цій "
"гнучкості їх можна вільно змішувати під час операцій, не викликаючи помилок. "
"Однак тип результату може залежати від порядку операндів."

msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Методи для об’єктів bytes і bytearray не приймають рядки як аргументи, так "
"само як методи для рядків не приймають байти як аргументи. Наприклад, ви "
"повинні написати::"

msgid "and::"
msgstr "і::"

msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Деякі операції з байтами та масивами байтів передбачають використання "
"двійкових форматів, сумісних із ASCII, і тому їх слід уникати під час роботи "
"з довільними двійковими даними. Ці обмеження описані нижче."

msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Використання цих операцій на основі ASCII для обробки двійкових даних, які "
"не зберігаються у форматі на основі ASCII, може призвести до пошкодження "
"даних."

msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Наступні методи для об’єктів bytes і bytearray можна використовувати з "
"довільними двійковими даними."

msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Повертає кількість неперекриваючих входжень підпослідовності *sub* у "
"діапазоні [*початок*, *кінець*]. Необов’язкові аргументи *початок* і "
"*кінець* інтерпретуються як у нотації фрагментів."

msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"Підпослідовністю для пошуку може бути будь-який :term:`bytes-like object` "
"або ціле число в діапазоні від 0 до 255."

msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Також прийняти ціле число в діапазоні від 0 до 255 як підпослідовність."

msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Якщо двійкові дані починаються з рядка *prefix*, поверніть "
"``bytes[len(prefix):]``. В іншому випадку поверніть копію вихідних двійкових "
"даних::"

msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*Префікс* може бути будь-яким :term:`bytes-like object`."

msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"Версія bytearray цього методу *не* працює на місці – вона завжди створює "
"новий об’єкт, навіть якщо не було зроблено жодних змін."

msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Якщо двійкові дані закінчуються рядком *суфікса* і цей *суфікс* не порожній, "
"поверніть ``bytes[:-len(suffix)]``. В іншому випадку поверніть копію "
"вихідних двійкових даних::"

msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*Суфіксом* може бути будь-який :term:`bytes-like object`."

msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`error-handlers`. For a list of possible "
"encodings, see section :ref:`standard-encodings`."
msgstr ""
"Повертає рядок, декодований із заданих байтів. Кодування за замовчуванням "
"``'utf-8'``. *помилки* можуть бути надані для встановлення іншої схеми "
"обробки помилок. Типовим значенням для *помилок* є ``'строгий'``, що "
"означає, що помилки кодування викликають :exc:`UnicodeError`. Іншими "
"можливими значеннями є ``'ignore'``, ``'replace'`` та будь-яке інше ім'я, "
"зареєстроване через :func:`codecs.register_error`, див. розділ :ref:`error-"
"handlers`. Список можливих кодувань див. у розділі :ref:`standard-encodings`."

msgid ""
"By default, the *errors* argument is not checked for best performances, but "
"only used at the first decoding error. Enable the :ref:`Python Development "
"Mode <devmode>`, or use a :ref:`debug build <debug-build>` to check *errors*."
msgstr ""
"За замовчуванням аргумент *errors* не перевіряється на найкращу "
"продуктивність, а використовується лише при першій помилці декодування. "
"Увімкніть :ref:`Режим розробки Python <devmode>` або скористайтеся :ref:"
"`debug build <debug-build>`, щоб перевірити *помилки*."

msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""
"Передача аргументу *encoding* до :class:`str` дозволяє декодувати будь-який :"
"term:`bytes-like object` безпосередньо, без необхідності створювати "
"тимчасові об’єкти bytes або bytearray."

msgid "Added support for keyword arguments."
msgstr "Додано підтримку аргументів ключових слів."

msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Повертає ``True``, якщо двійкові дані закінчуються вказаним *суфіксом*, "
"інакше повертає ``False``. *suffix* також може бути кортежем суфіксів для "
"пошуку. З необов'язковим *початком* тестування починається з цієї позиції. З "
"необов’язковим *end*, припинити порівняння на цій позиції."

msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "Суфікс(и) для пошуку може бути будь-яким :term:`bytes-like object`."

msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Повертає найнижчий індекс у даних, де знайдено підпослідовність *sub*, так "
"що *sub* міститься в сегменті ``s[start:end]``. Необов’язкові аргументи "
"*початок* і *кінець* інтерпретуються як у нотації фрагментів. Повертає "
"``-1``, якщо *sub* не знайдено."

msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Метод :meth:`~bytes.find` слід використовувати, лише якщо вам потрібно знати "
"позицію *sub*. Щоб перевірити, чи є *sub* підрядком, скористайтеся "
"оператором :keyword:`in`::"

msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Як :meth:`~bytes.find`, але викликає :exc:`ValueError`, коли "
"підпослідовність не знайдено."

msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Повертає об’єкт bytes або bytearray, який є конкатенацією двійкових "
"послідовностей даних у *iterable*. Помилка :exc:`TypeError` буде викликана, "
"якщо в *iterable* є будь-які значення, які не є :term:`bytes-подібними "
"об’єктами <bytes-like object>`, включаючи об’єкти :class:`str`. Роздільником "
"між елементами є вміст об’єкта bytes або bytearray, що забезпечує цей метод."

msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Цей статичний метод повертає таблицю перекладу, придатну для :meth:`bytes."
"translate`, яка відобразить кожен символ у *from* на символ у тій же позиції "
"в *to*; *from* і *to* мають бути :term:`байтоподібними об’єктами <bytes-like "
"object>` і мати однакову довжину."

msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Розділіть послідовність при першому входженні *sep* і поверніть 3-кортеж, що "
"містить частину перед роздільником, сам роздільник або його копію байтового "
"масиву та частину після роздільника. Якщо роздільник не знайдено, поверніть "
"3-кортеж, що містить копію вихідної послідовності, за якою слідують два "
"порожні байти або об’єкти bytearray."

msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "Роздільником для пошуку може бути будь-який :term:`bytes-like object`."

msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Повертає копію послідовності з заміною всіх входжень підпослідовності *old* "
"на *new*. Якщо вказано необов’язковий аргумент *count*, заміняються лише "
"перші випадки *count*."

msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"Підпослідовністю для пошуку та її заміною може бути будь-який :term:`bytes-"
"like object`."

msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Повертає найвищий індекс у послідовності, де знайдено підпослідовність "
"*sub*, так що *sub* міститься в ``s[start:end]``. Необов’язкові аргументи "
"*початок* і *кінець* інтерпретуються як у нотації фрагментів. Повернути "
"``-1`` у разі помилки."

msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Подібно до :meth:`~bytes.rfind`, але викликає :exc:`ValueError`, коли "
"підпослідовність *sub* не знайдено."

msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Розділіть послідовність при останньому входженні *sep* і поверніть 3-кортеж, "
"що містить частину перед роздільником, сам роздільник або його копію "
"байтового масиву та частину після роздільника. Якщо роздільник не знайдено, "
"поверніть 3-кортеж, що містить два порожні об’єкти байтів або масиву байтів, "
"а потім копію вихідної послідовності."

msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Повертає ``True``, якщо двійкові дані починаються з указаного *префікса*, "
"інакше повертає ``False``. *префікс* також може бути кортежем префіксів для "
"пошуку. З необов’язковим *початком* тестування починається з цієї позиції. З "
"необов’язковим *end*, припинити порівняння на цій позиції."

msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "Префікс(и) для пошуку може бути будь-яким :term:`bytes-like object`."

msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Повертає копію об’єкта bytes або bytearray, де всі байти, що зустрічаються в "
"необов’язковому аргументі *delete*, видаляються, а решта байтів відображено "
"через задану таблицю перекладу, яка має бути об’єктом bytes довжиною 256."

msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Ви можете використовувати метод :func:`bytes.maketrans` для створення "
"таблиці перекладу."

msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Встановіть для аргументу *table* значення ``None`` для перекладів, які "
"видаляють лише символи::"

msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* тепер підтримується як аргумент ключового слова."

msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Наведені нижче методи для об’єктів bytes і bytearray мають поведінку за "
"замовчуванням, яка передбачає використання ASCII-сумісних двійкових "
"форматів, але все одно їх можна використовувати з довільними двійковими "
"даними шляхом передачі відповідних аргументів. Зауважте, що всі методи "
"bytearray у цьому розділі *не* працюють на місці, а створюють нові об’єкти."

msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Повертає копію об’єкта з центром у послідовності довжиною *шириною*. "
"Доповнення виконується за допомогою вказаного *fillbyte* (за замовчуванням "
"це пробіл ASCII). Для об’єктів :class:`bytes` оригінальна послідовність "
"повертається, якщо *width* менше або дорівнює ``len(s)``."

msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Повертає копію об’єкта, вирівняну за лівим краєм у послідовності довжини "
"*ширина*. Доповнення виконується за допомогою вказаного *fillbyte* (за "
"замовчуванням це пробіл ASCII). Для об’єктів :class:`bytes` вихідна "
"послідовність повертається, якщо *width* менше або дорівнює ``len(s)``."

msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Повертає копію послідовності з видаленими вказаними початковими байтами. "
"Аргумент *chars* є двійковою послідовністю, яка визначає набір значень "
"байтів, які потрібно видалити. Назва вказує на те, що цей метод зазвичай "
"використовується з символами ASCII. Якщо пропущено або ``None``, аргумент "
"*chars* за умовчанням видаляє пробіли ASCII. Аргумент *chars* не є "
"префіксом; навпаки, усі комбінації його значень видаляються:"

msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"Двійкова послідовність байтових значень для видалення може бути будь-яким :"
"term:`bytes-like object`. Перегляньте :meth:`~bytes.removeprefix` для "
"методу, який видаляє один рядок префікса, а не весь набір символів. "
"Наприклад::"

msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Повертає копію об’єкта, вирівняну по правому краю в послідовності довжина "
"*ширина*. Доповнення виконується за допомогою вказаного *fillbyte* (за "
"замовчуванням це пробіл ASCII). Для об’єктів :class:`bytes` оригінальна "
"послідовність повертається, якщо *width* менше або дорівнює ``len(s)``."

msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Розділіть бінарну послідовність на підпослідовності одного типу, "
"використовуючи *sep* як рядок-роздільник. Якщо задано *maxsplit*, "
"виконується щонайбільше *maxsplit* розбиття, *найправіші*. Якщо *sep* не "
"вказано або ``None``, будь-яка підпослідовність, що складається виключно з "
"пробілів ASCII, є роздільником. За винятком розділення справа, :meth:"
"`rsplit` поводиться як :meth:`split`, що детально описано нижче."

msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Повертає копію послідовності з видаленими вказаними кінцевими байтами. "
"Аргумент *chars* є двійковою послідовністю, яка визначає набір значень "
"байтів, які потрібно видалити. Назва вказує на те, що цей метод зазвичай "
"використовується з символами ASCII. Якщо пропущено або ``None``, аргумент "
"*chars* за замовчуванням видаляє пробіли ASCII. Аргумент *chars* не є "
"суфіксом; навпаки, усі комбінації його значень видаляються:"

msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"Двійкова послідовність байтових значень для видалення може бути будь-яким :"
"term:`bytes-like object`. Перегляньте :meth:`~bytes.removesuffix`, щоб "
"дізнатися про метод, який видалить один рядок суфікса, а не весь набір "
"символів. Наприклад::"

msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Розділіть бінарну послідовність на підпослідовності одного типу, "
"використовуючи *sep* як рядок-роздільник. Якщо задано *maxsplit* і воно є "
"невід’ємним, виконується щонайбільше розділень *maxsplit* (отже, список "
"матиме щонайбільше елементів ``maxsplit+1``). Якщо *maxsplit* не вказано або "
"дорівнює ``-1``, тоді немає обмежень на кількість розбивок (виконуються всі "
"можливі розбиття)."

msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Якщо задано *sep*, послідовні розділювачі не групуються разом і вважаються "
"розмежовуючими порожні підпослідовності (наприклад, ``b'1,,2'.split(b',')`` "
"повертає ``[b'1 ', b'', b'2']``). Аргумент *sep* може складатися з "
"багатобайтової послідовності (наприклад, ``b'1 <> 2 <> 3'.split(b' <> ')`` "
"повертає ``[b'1', b'2', b '3']``). Розділення порожньої послідовності з "
"указаним роздільником повертає ``[b'']`` або ``[bytearray(b'')]`` залежно "
"від типу об’єкта, який розділяється. Аргументом *sep* може бути будь-який :"
"term:`bytes-like object`."

msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Якщо *sep* не вказано або має значення ``None``, застосовується інший "
"алгоритм поділу: цикли послідовних пробілів ASCII розглядаються як один "
"роздільник, і результат не міститиме порожніх рядків на початку або в кінці, "
"якщо послідовність має пробіли на початку або в кінці. Отже, розділення "
"порожньої послідовності або послідовності, що складається виключно з "
"пробілів ASCII без указаного роздільника, повертає ``[]``."

msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Повертає копію послідовності з вилученими вказаними початковим і кінцевим "
"байтами. Аргумент *chars* є двійковою послідовністю, яка визначає набір "
"значень байтів, які потрібно видалити. Назва вказує на те, що цей метод "
"зазвичай використовується з символами ASCII. Якщо пропущено або ``None``, "
"аргумент *chars* за замовчуванням видаляє пробіли ASCII. Аргумент *chars* не "
"є префіксом або суфіксом; навпаки, усі комбінації його значень видаляються:"

msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"Двійкова послідовність байтових значень для видалення може бути будь-яким :"
"term:`bytes-like object`."

msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Наступні методи для об’єктів bytes і bytearray передбачають використання "
"двійкових форматів, сумісних із ASCII, і їх не слід застосовувати до "
"довільних двійкових даних. Зауважте, що всі методи bytearray у цьому розділі "
"*не* працюють на місці, а створюють нові об’єкти."

msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Повертає копію послідовності з кожним байтом, інтерпретованим як символ "
"ASCII, і перший байт у великому регістрі, а решта – у нижньому. Байтові "
"значення, відмінні від ASCII, передаються без змін."

msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Повертає копію послідовності, де всі символи табуляції ASCII замінено одним "
"або декількома пробілами ASCII, залежно від поточного стовпця та заданого "
"розміру табуляції. Позиції табуляції відбуваються кожні байти *табуляції* "
"(за замовчуванням — 8, надаючи позиції табуляції в стовпцях 0, 8, 16 і так "
"далі). Щоб розширити послідовність, поточний стовпець встановлюється на нуль "
"і послідовність перевіряється побайтно. Якщо байт є символом табуляції ASCII "
"(``b'\\t'``), один або більше символів пробілу вставляються в результат, "
"доки поточний стовпець не буде відповідати наступній позиції табуляції. (Сам "
"символ табуляції не копіюється.) Якщо поточний байт є ASCII символом нового "
"рядка (``b'\\n'``) або поверненням каретки (``b'\\r'``), він копіюється і "
"поточний стовпець скидається на нуль. Будь-яке інше значення байта "
"копіюється без змін, а поточний стовпець збільшується на одиницю незалежно "
"від того, як значення байта представлено під час друку::"

msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є алфавітними символами "
"ASCII або десятковими цифрами ASCII і послідовність не є порожньою, "
"``False`` інакше. Алфавітні символи ASCII – це значення байтів у "
"послідовності ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``. "
"Десяткові цифри ASCII – це значення байтів у послідовності ``b'0123456789``."

msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є алфавітними символами "
"ASCII і послідовність не є пустою, ``False`` інакше. Алфавітні символи ASCII "
"– це значення байтів у послідовності "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``."

msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Повертає ``True``, якщо послідовність порожня або всі байти в послідовності "
"ASCII, ``False`` інакше. Байти ASCII знаходяться в діапазоні 0-0x7F."

msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є десятковими цифрами "
"ASCII і послідовність не порожня, ``False`` інакше. Десяткові цифри ASCII – "
"це значення байтів у послідовності ``b'0123456789``."

msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо в послідовності є принаймні один символ нижнього "
"регістру ASCII і немає символів ASCII у верхньому регістрі, інакше ``False``."

msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Символи ASCII у нижньому регістрі – це значення байтів у послідовності "
"``b'abcdefghijklmnopqrstuvwxyz``. Символи ASCII у верхньому регістрі – це "
"значення байтів у послідовності ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ``."

msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є пробілами ASCII і "
"послідовність не порожня, ``False`` інакше. Пробільні символи ASCII – це "
"значення байтів у послідовності ``b' \\t\\n\\r\\x0b\\f''`` (пробіл, "
"табуляція, новий рядок, повернення каретки, вертикальна табуляція, передача "
"форми)."

msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Повертає ``True``, якщо послідовність має регістр заголовків ASCII і "
"послідовність не є порожньою, ``False`` інакше. Дивіться :meth:`bytes."
"title`, щоб дізнатися більше про визначення \"заголовка\"."

msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Повертає ``True``, якщо в послідовності є принаймні один символ ASCII у "
"верхньому регістрі та відсутні символи ASCII у нижньому регістрі, інакше "
"``False``."

msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Повертає копію послідовності з усіма символами ASCII у верхньому регістрі, "
"перетвореними на їхні відповідні відповідники у нижньому регістрі."

msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Повертає список рядків у двійковій послідовності, розриваючи межі рядків "
"ASCII. Цей метод використовує підхід :term:`universal newlines` до "
"розділення рядків. Розриви рядків не включаються до результуючого списку, "
"якщо не задано *keepends* і воно є істинним."

msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"На відміну від :meth:`~bytes.split`, коли задано рядок розділювача *sep*, "
"цей метод повертає порожній список для порожнього рядка, а розрив кінцевого "
"рядка не призводить до додаткового рядка::"

msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Повертає копію послідовності з усіма символами нижнього регістру ASCII, "
"перетвореними на їхні відповідні відповідники у верхньому регістрі та "
"навпаки."

msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"На відміну від :func:`str.swapcase()`, це завжди так, що ``bin.swapcase()."
"swapcase() == bin`` для бінарних версій. Перетворення регістру є симетричним "
"у ASCII, навіть якщо це зазвичай не вірно для довільних кодових точок "
"Unicode."

msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Повертає версію двійкової послідовності в заголовку, де слова починаються з "
"символу ASCII у верхньому регістрі, а решта символів – у нижньому регістрі. "
"Значення байтів без регістру залишаються незмінними."

msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Символи ASCII у нижньому регістрі – це значення байтів у послідовності "
"``b'abcdefghijklmnopqrstuvwxyz``. Символи ASCII у верхньому регістрі – це "
"значення байтів у послідовності ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ``. Усі інші "
"значення байтів без регістру."

msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Обхідний шлях для апострофів можна створити за допомогою регулярних виразів:"

msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Повертає копію послідовності з усіма символами нижнього регістру ASCII, "
"перетвореними на їхні відповідні відповідники у верхньому регістрі."

msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Поверніть копію послідовності зліва, заповнену цифрами ASCII ``b'0``, щоб "
"створити послідовність довжиною *ширина*. Початковий префікс знака "
"(``b'+'``/ ``b'-'``) обробляється шляхом вставки заповнення *після* символу "
"знака, а не перед ним. Для об’єктів :class:`bytes` оригінальна послідовність "
"повертається, якщо *width* менше або дорівнює ``len(seq)``."

msgid "``printf``-style Bytes Formatting"
msgstr "Форматування байтів у стилі ``printf``"

msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Операції форматування, описані тут, демонструють різноманітні особливості, "
"які призводять до низки поширених помилок (наприклад, неправильне "
"відображення кортежів і словників). Якщо значення, яке друкується, може бути "
"кортежем або словником, оберніть його в кортеж."

msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Об’єкти Bytes (``bytes``/``bytearray``) мають одну унікальну вбудовану "
"операцію: оператор ``%`` (за модулем). Це також відоме як оператор "
"*форматування* або *інтерполяції* байтів. Враховуючи ``формат % значень`` "
"(де *format* є об’єктом байтів), ``%`` специфікації перетворення у *format* "
"замінюються нулем або більше елементами *значень*. Ефект подібний до "
"використання :c:func:`sprintf` у мові C."

msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Якщо для *format* потрібен один аргумент, *values* може бути одним "
"некортежним об’єктом. [5]_ В іншому випадку *values* має бути кортежем із "
"точною кількістю елементів, указаною об’єктом format bytes, або одним "
"об’єктом відображення (наприклад, словником)."

msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Коли правильний аргумент є словником (або іншим типом відображення), тоді "
"формати в об’єкті bytes *мають* містити ключ відображення в дужках у цьому "
"словнику, вставлений відразу після символу ``'%'``. Ключ відображення "
"вибирає значення, яке потрібно відформатувати, із відображення. Наприклад:"

msgid "Single byte (accepts integer or single byte objects)."
msgstr "Однобайтовий (приймає цілі чи однобайтові об’єкти)."

msgid "``'b'``"
msgstr "``'b''``"

msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"Байти (будь-який об’єкт, який відповідає :ref:`протоколу буфера "
"<bufferobjects>` або має :meth:`__bytes__`)."

msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s''`` є псевдонімом для ``'b''`` і має використовуватися лише для "
"базового коду Python2/3."

msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Байти (перетворює будь-який об’єкт Python за допомогою ``repr(obj)."
"encode('ascii', 'backslashreplace')``)."

msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` є псевдонімом для ``'a'`` і має використовуватися лише для базових "
"кодів Python2/3."

msgid "\\(7)"
msgstr "\\(7)"

msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s`` є застарілим, але не буде видалено протягом серії 3.x."

msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r''`` є застарілим, але не буде видалено протягом серії 3.x."

msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Додано форматування % до байтів і масиву байтів"

msgid "Memory Views"
msgstr "Перегляди пам'яті"

msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Об’єкти :class:`memoryview` дозволяють коду Python отримувати доступ до "
"внутрішніх даних об’єкта, який підтримує :ref:`протокол буфера "
"<bufferobjects>` без копіювання."

msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Створіть :class:`memoryview`, який посилається на *об’єкт*. *об’єкт* має "
"підтримувати протокол буфера. Вбудовані об’єкти, які підтримують протокол "
"буфера, включають :class:`bytes` і :class:`bytearray`."

msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
":class:`memoryview` має поняття *елемента*, який є атомарною одиницею "
"пам’яті, яка обробляється вихідним *об’єктом*. Для багатьох простих типів, "
"таких як :class:`bytes` і :class:`bytearray`, елемент є одним байтом, але "
"інші типи, такі як :class:`array.array`, можуть мати більші елементи."

msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"``len(view)`` дорівнює довжині :class:`~memoryview.tolist`. Якщо ``view.ndim "
"= 0``, довжина дорівнює 1. Якщо ``view.ndim = 1``, довжина дорівнює "
"кількості елементів у поданні. Для вищих розмірів довжина дорівнює довжині "
"представлення представлення представлення вкладеного списку. Атрибут :class:"
"`~memoryview.itemsize` дасть вам кількість байтів в одному елементі."

msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
":class:`memoryview` підтримує нарізку та індексування для показу своїх "
"даних. Одновимірне нарізання призведе до підвиду::"

msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Якщо :class:`~memoryview.format` є одним із власних специфікаторів формату з "
"модуля :mod:`struct`, індексація за допомогою цілого числа або кортежу цілих "
"чисел також підтримується та повертає один *елемент* із правильним типом . "
"Одновимірні представлення пам'яті можна індексувати за допомогою цілого або "
"одноцілого кортежу. Багатовимірні представлення пам’яті можна індексувати за "
"допомогою кортежів з точно *ndim* цілих чисел, де *ndim* є кількістю "
"вимірів. Нульвимірні представлення пам'яті можна індексувати за допомогою "
"порожнього кортежу."

msgid "Here is an example with a non-byte format::"
msgstr "Ось приклад небайтового формату::"

msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Якщо основний об’єкт доступний для запису, memoryview підтримує одновимірне "
"призначення фрагментів. Зміна розміру заборонена::"

msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""
"Одновимірні представлення пам’яті типів, які можна хешувати (тільки для "
"читання), з форматами \"B\", \"b\" або \"c\" також хешуються. Хеш "
"визначається як ``hash(m) == hash(m.tobytes())``::"

msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""
"Одновимірні зображення пам’яті тепер можна нарізати. Одновимірні перегляди "
"пам’яті з форматами \"B\", \"b\" або \"c\" тепер можна хешувати."

msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview тепер автоматично реєструється в :class:`collections.abc.Sequence`"

msgid "memoryviews can now be indexed with tuple of integers."
msgstr "memoryviews тепер можна індексувати кортежем цілих чисел."

msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` має кілька методів:"

msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Memoriview і експортер :pep:`3118` є рівними, якщо їхні форми еквівалентні "
"та якщо всі відповідні значення рівні, коли відповідні коди формату "
"операндів інтерпретуються за допомогою синтаксису :mod:`struct`."

msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Для підмножини рядків формату :mod:`struct`, які зараз підтримуються :meth:"
"`tolist`, ``v`` і ``w`` рівні, якщо ``v.tolist() == w.tolist()``::"

msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Якщо будь-який рядок формату не підтримується модулем :mod:`struct`, тоді "
"об’єкти завжди порівнюватимуться як нерівні (навіть якщо рядки формату та "
"вміст буфера ідентичні)::"

msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Зауважте, що, як і у випадку з числами з плаваючою комою, ``v є w`` *не* "
"означає ``v == w`` для об'єктів memoryview."

msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Попередні версії порівнювали необроблену пам’ять без урахування формату "
"елемента та логічної структури масиву."

msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Повертає дані в буфері як байтовий рядок. Це еквівалентно виклику "
"конструктора :class:`bytes` у memoryview. ::"

msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Для несуміжних масивів результат дорівнює представленню зведеного списку з "
"усіма елементами, перетвореними на байти. :meth:`tobytes` підтримує всі "
"рядки формату, включно з тими, яких немає в синтаксисі модуля :mod:`struct`."

msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*порядок* може бути {'C', 'F', 'A'}. Якщо *порядок* має значення \"C\" або "
"\"F\", дані вихідного масиву перетворюються на порядок C або Fortran. Для "
"суміжних переглядів \"A\" повертає точну копію фізичної пам’яті. Зокрема, "
"зберігається порядок Fortran у пам'яті. Для несуміжних переглядів дані "
"спочатку перетворюються на C. *order=None* те саме, що *order='C'*."

msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Повертає рядковий об’єкт, що містить дві шістнадцяткові цифри для кожного "
"байта в буфері. ::"

msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Подібно до :meth:`bytes.hex`, :meth:`memoryview.hex` тепер підтримує "
"додаткові параметри *sep* і *bytes_per_sep* для вставки роздільників між "
"байтами в шістнадцятковому виведенні."

msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Повертає дані в буфері як список елементів. ::"

msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` тепер підтримує всі односимвольні рідні формати в синтаксисі "
"модуля :mod:`struct`, а також багатовимірні представлення."

msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Повертає версію об’єкта memoryview лише для читання. Оригінальний об’єкт "
"memoryview не змінено. ::"

msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Вивільніть базовий буфер, відкритий об’єктом memoryview. Багато об’єктів "
"виконують спеціальні дії, коли їх переглядають (наприклад, :class:"
"`bytearray` тимчасово забороняє зміну розміру); отже, виклик release() є "
"зручним, щоб усунути ці обмеження (і звільнити будь-які завислі ресурси) "
"якомога швидше."

msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Після виклику цього методу будь-яка подальша операція з представленням "
"викликає помилку :class:`ValueError` (крім самого :meth:`release()`, який "
"можна викликати кілька разів)::"

msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Протокол керування контекстом може бути використаний для подібного ефекту, "
"використовуючи оператор ``with``::"

msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Транслюйте пам’ять у новий формат або форму. *shape* за умовчанням має "
"значення ``[byte_length//new_itemsize]``, що означає, що перегляд результату "
"буде одновимірним. Поверненим значенням є новий перегляд пам’яті, але сам "
"буфер не копіюється. Підтримувані приведення: 1D -> C-:term:`contiguous` і C-"
"contiguous -> 1D."

msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"Цільовий формат обмежується рідним форматом одного елемента в синтаксисі :"
"mod:`struct`. Один із форматів має бути байтовим (\"B\", \"b\" або \"c\"). "
"Довжина результату в байтах має збігатися з вихідною."

msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Перетворення 1D/long на 1D/беззнакові байти::"

msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Перетворення 1D/беззнакових байтів у 1D/char::"

msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Перетворити 1D/байти на 3D/ints на 1D/signed char::"

msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Перетворення 1D/unsigned long на 2D/unsigned long ::"

msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Вихідний формат більше не обмежений під час трансляції до байтового "
"перегляду."

msgid "There are also several readonly attributes available:"
msgstr "Також є кілька доступних атрибутів лише для читання:"

msgid "The underlying object of the memoryview::"
msgstr "Основний об’єкт memoryview::"

msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Це обсяг "
"простору в байтах, який буде використовуватися масивом у безперервному "
"представленні. Воно не обов’язково дорівнює ``len(m)``::"

msgid "Multi-dimensional arrays::"
msgstr "Багатовимірні масиви::"

msgid "A bool indicating whether the memory is read only."
msgstr "Bool, що вказує, чи є пам’ять лише для читання."

msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Рядок, що містить формат (у стилі модуля :mod:`struct`) для кожного елемента "
"в поданні. Огляд пам’яті можна створити з експортерів із довільними рядками "
"формату, але деякі методи (наприклад, :meth:`tolist`) обмежені рідними "
"одноелементними форматами."

msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"формат ``'B'`` тепер обробляється відповідно до синтаксису модуля struct. Це "
"означає, що ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

msgid "The size in bytes of each element of the memoryview::"
msgstr "Розмір у байтах кожного елемента memoryview::"

msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Ціле число, що вказує, скільки вимірів багатовимірного масиву представляє "
"пам’ять."

msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Кортеж цілих чисел довжиною :attr:`ndim`, що надає форму пам’яті як N-"
"вимірного масиву."

msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Порожній кортеж замість ``None``, коли ndim = 0."

msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Кортеж цілих чисел довжиною :attr:`ndim`, що вказує розмір у байтах для "
"доступу до кожного елемента для кожного виміру масиву."

msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Використовується внутрішньо для масивів у стилі PIL. Значення лише "
"інформаційне."

msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Логічне значення, яке вказує, чи є пам’ять C-:term:`contiguous`."

msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Логічне значення, що вказує, чи є пам’ять Fortran :term:`contiguous`."

msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Bool, що вказує, чи є пам’ять :term:`contiguous`."

msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Типи наборів --- :class:`set`, :class:`frozenset`"

msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Об’єкт :dfn:`set` — це невпорядкована колекція окремих об’єктів :term:"
"`hashable`. Загальне використання включає тестування членства, видалення "
"дублікатів із послідовності та обчислення математичних операцій, таких як "
"перетин, об’єднання, різниця та симетрична різниця. (Для інших контейнерів "
"перегляньте вбудовані класи :class:`dict`, :class:`list` і :class:`tuple`, а "
"також модуль :mod:`collections`.)"

msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Як і інші колекції, набори підтримують ``x in set``, ``len(set)`` і ``for x "
"in set``. Будучи невпорядкованою колекцією, набори не записують положення "
"елемента або порядок вставки. Відповідно, набори не підтримують "
"індексування, нарізку чи іншу поведінку, подібну до послідовності."

msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Наразі існує два вбудовані типи наборів: :class:`set` і :class:`frozenset`. "
"Тип :class:`set` є змінним --- вміст можна змінити за допомогою таких "
"методів, як :meth:`~set.add` і :meth:`~set.remove`. Оскільки він є змінним, "
"він не має хеш-значення і не може використовуватися ні як ключ словника, ні "
"як елемент іншого набору. Тип :class:`frozenset` є незмінним і :term:"
"`hashable` --- його вміст не можна змінити після створення; тому його можна "
"використовувати як ключ до словника або як елемент іншого набору."

msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Непорожні набори (не заморожені набори) можна створити шляхом розміщення "
"списку елементів, розділених комами, у фігурних дужках, наприклад: "
"``{'jack', 'sjoerd'}``, на додаток до :class:`set` конструктор."

msgid "The constructors for both classes work the same:"
msgstr "Конструктори для обох класів працюють однаково:"

msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Повертає новий набір або заморожений об’єкт, елементи якого взяті з "
"*iterable*. Елементи набору мають бути :term:`hashable`. Щоб представити "
"набори наборів, внутрішні набори мають бути об’єктами :class:`frozenset`. "
"Якщо *iterable* не вказано, повертається новий порожній набір."

msgid "Sets can be created by several means:"
msgstr "Набори можна створювати кількома способами:"

msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Використовуйте список елементів, розділених комами, у фігурних дужках: "
"``{'jack', 'sjoerd'}``"

msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Використовуйте розуміння набору: ``{c для c в 'abracadabra' якщо c не в "
"'abc'}``"

msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Використовуйте конструктор типу: ``set()``, ``set('foobar')``, ``set(['a', "
"'b', 'foo'])``"

msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Екземпляри :class:`set` і :class:`frozenset` забезпечують такі операції:"

msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Повертає кількість елементів у наборі *s* (мощність *s*)."

msgid "Test *x* for membership in *s*."
msgstr "Перевірте *x* на членство в *s*."

msgid "Test *x* for non-membership in *s*."
msgstr "Перевірте *x* на неналежність до *s*."

msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Повертає ``True``, якщо набір не має спільних елементів з *other*. Множини "
"непересічні тоді і тільки тоді, коли їх перетин є порожньою множиною."

msgid "Test whether every element in the set is in *other*."
msgstr "Перевірте, чи кожен елемент у наборі знаходиться в *other*."

msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Перевірте, чи набір є правильною підмножиною *other*, тобто ``set <= other і "
"set != other``."

msgid "Test whether every element in *other* is in the set."
msgstr "Перевірте, чи всі елементи в *other* є в наборі."

msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Перевірте, чи є набір правильною надмножиною *other*, тобто ``set >= other і "
"set != other``."

msgid "Return a new set with elements from the set and all others."
msgstr "Повернути новий набір з елементами з набору та всі інші."

msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Повертає новий набір із елементами, спільними для набору та всіх інших."

msgid "Return a new set with elements in the set that are not in the others."
msgstr "Повертає новий набір з елементами в наборі, яких немає в інших."

msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Повертає новий набір з елементами або в наборі, або в *іншому*, але не в "
"обох."

msgid "Return a shallow copy of the set."
msgstr "Поверніть мілку копію набору."

msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Зауважте, версії без операторів :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, :meth:`symmetric_difference`, :meth:`issubset` і :meth:"
"`issuperset` методи приймуть будь-яку ітерацію як аргумент. На відміну від "
"цього, їхні аналоги на основі операторів вимагають, щоб їхні аргументи були "
"наборами. Це виключає такі схильні до помилок конструкції, як ``set('abc') & "
"'cbs'`` на користь більш читабельного ``set('abc').intersection('cbs')``."

msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"І :class:`set`, і :class:`frozenset` підтримують набір для встановлення "
"порівнянь. Дві множини рівні тоді і тільки тоді, коли кожен елемент кожної "
"множини міститься в іншій (кожен є підмножиною іншого). Набір менший за "
"інший набір тоді і тільки тоді, коли перший набір є належним підмножиною "
"другого набору (є підмножиною, але не дорівнює). Набір більший за інший "
"набір тоді і тільки тоді, коли перший набір є належним надмножиною другого "
"набору (є надмножиною, але не є рівним)."

msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Примірники :class:`set` порівнюються з примірниками :class:`frozenset` на "
"основі їхніх членів. Наприклад, ``set('abc') == frozenset('abc')`` повертає "
"``True``, а також ``set('abc')`` у ``set([frozenset('abc')])``."

msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Порівняння підмножини та рівності не узагальнюють до загальної функції "
"впорядкування. Наприклад, будь-які дві непорожні непересічні множини не "
"рівні і не є підмножинами одна одної, тому *всі* з наступного повертають "
"``False``: ``a <b``, ``a==b``, or ``a> b``."

msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Оскільки набори визначають лише часткове впорядкування (відносини "
"підмножин), вихід методу :meth:`list.sort` не визначений для списків наборів."

msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "Елементи набору, як і ключі словника, мають бути :term:`hashable`."

msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Бінарні операції, які поєднують екземпляри :class:`set` із :class:"
"`frozenset`, повертають тип першого операнда. Наприклад: ``frozenset('ab') | "
"set('bc')`` повертає екземпляр :class:`frozenset`."

msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"У наступній таблиці наведено операції, доступні для :class:`set`, які не "
"застосовуються до незмінних екземплярів :class:`frozenset`:"

msgid "Update the set, adding elements from all others."
msgstr "Оновіть набір, додавши елементи з усіх інших."

msgid "Update the set, keeping only elements found in it and all others."
msgstr "Оновіть набір, зберігаючи лише елементи, знайдені в ньому, і всі інші."

msgid "Update the set, removing elements found in others."
msgstr "Оновіть набір, видаляючи елементи, знайдені в інших."

msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Оновіть набір, зберігаючи лише елементи, знайдені в будь-якому наборі, але "
"не в обох."

msgid "Add element *elem* to the set."
msgstr "Додайте елемент *elem* до набору."

msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Видалити елемент *elem* із набору. Викликає :exc:`KeyError`, якщо *elem* не "
"міститься в наборі."

msgid "Remove element *elem* from the set if it is present."
msgstr "Видалити елемент *elem* із набору, якщо він присутній."

msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Вилучити та повернути довільний елемент із набору. Викликає :exc:`KeyError`, "
"якщо набір порожній."

msgid "Remove all elements from the set."
msgstr "Видаліть усі елементи з набору."

msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Зауважте, що безоператорні версії методів :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update` і :meth:"
"`symmetric_difference_update` прийматимуть будь-яку ітерацію як аргумент."

msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Зауважте, що аргумент *elem* для методів :meth:`__contains__`, :meth:"
"`remove` і :meth:`discard` може бути набором. Щоб підтримувати пошук "
"еквівалентного замороженого набору, тимчасовий набір створюється з *elem*."

msgid "Mapping Types --- :class:`dict`"
msgstr "Типи зіставлення --- :class:`dict`"

msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Об’єкт :term:`mapping` відображає значення :term:`hashable` на довільні "
"об’єкти. Відображення є змінними об'єктами. Зараз існує лише один "
"стандартний тип відображення, :dfn:`dictionary`. (Для інших контейнерів "
"перегляньте вбудовані класи :class:`list`, :class:`set` і :class:`tuple`, а "
"також модуль :mod:`collections`.)"

msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"Ключі словника - це *майже* довільні значення. Значення, які не :term:"
"`hashable`, тобто значення, що містять списки, словники чи інші змінювані "
"типи (які порівнюються за значенням, а не за ідентичністю об’єкта), не можна "
"використовувати як ключі. Числові типи, які використовуються для ключів, "
"підкоряються звичайним правилам для числового порівняння: якщо два числа "
"порівнюються (наприклад, ``1`` і ``1.0``), тоді їх можна використовувати як "
"взаємозамінні для індексування тієї самої статті словника. (Однак зауважте, "
"що оскільки комп’ютери зберігають числа з плаваючою комою як наближення, "
"зазвичай нерозумно використовувати їх як ключі словника.)"

msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Повертає новий словник, ініціалізований необов’язковим позиційним аргументом "
"і, можливо, порожнім набором ключових аргументів."

msgid "Dictionaries can be created by several means:"
msgstr "Словники можна створювати кількома способами:"

msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Використовуйте розділений комами список пар ``ключ: значення`` у дужках: "
"``{'jack': 4098, 'sjoerd': 4127}`` або ``{4098: 'jack', 4127: 'sjoerd' }``"

msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Використовуйте розуміння диктового слова: ``{}``, ``{x: x ** 2 для x в "
"діапазоні (10)}``"

msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Використовуйте конструктор типу: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"

msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Якщо позиційний аргумент не задано, створюється порожній словник. Якщо "
"вказано позиційний аргумент і він є об’єктом відображення, словник "
"створюється з тими самими парами ключ-значення, що й об’єкт відображення. В "
"іншому випадку позиційний аргумент має бути об’єктом :term:`iterable`. Кожен "
"елемент у ітераторі повинен сам бути ітератором із рівно двома об’єктами. "
"Перший об’єкт кожного елемента стає ключем у новому словнику, а другий "
"об’єкт – відповідним значенням. Якщо ключ зустрічається більше одного разу, "
"останнє значення цього ключа стає відповідним значенням у новому словнику."

msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Якщо надано аргументи ключового слова, аргументи ключового слова та їхні "
"значення додаються до словника, створеного з позиційного аргументу. Якщо "
"ключ, який додається, уже присутній, значення з аргументу ключового слова "
"замінює значення з позиційного аргументу."

msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Для ілюстрації, усі наступні приклади повертають словник, що дорівнює "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Надання аргументів ключових слів, як у першому прикладі, працює лише для "
"ключів, які є дійсними ідентифікаторами Python. В іншому випадку можна "
"використовувати будь-які дійсні ключі."

msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Це операції, які підтримують словники (і, отже, також повинні підтримуватися "
"спеціальні типи зіставлення):"

msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Повернути список усіх ключів, які використовуються у словнику *d*."

msgid "Return the number of items in the dictionary *d*."
msgstr "Повернути кількість елементів у словнику *d*."

msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Поверніть елемент *d* за допомогою ключа *key*. Викликає :exc:`KeyError`, "
"якщо *key* немає на карті."

msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Якщо підклас dict визначає метод :meth:`__missing__` і *key* відсутній, "
"операція ``d[key]`` викликає цей метод із ключем *key* як аргументом. Потім "
"операція ``d[key]`` повертає або викликає все, що повертається або "
"викликається викликом ``__missing__(key)``. Жодні інші операції чи методи не "
"викликають :meth:`__missing__`. Якщо :meth:`__missing__` не визначено, "
"виникає :exc:`KeyError`. :meth:`__missing__` має бути методом; це не може "
"бути змінна екземпляра::"

msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"Наведений вище приклад показує частину реалізації :class:`collections."
"Counter`. Інший метод ``__missing__`` використовується :class:`collections."
"defaultdict`."

msgid "Set ``d[key]`` to *value*."
msgstr "Установіть для ``d[key]`` значення *value*."

msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Видаліть ``d[key]`` з *d*. Викликає :exc:`KeyError`, якщо *key* немає на "
"карті."

msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Повертає ``True``, якщо *d* має ключ *key*, інакше ``False``."

msgid "Equivalent to ``not key in d``."
msgstr "Еквівалент ``не вводити d``."

msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Повертає ітератор над ключами словника. Це ярлик для ``iter(d.keys())``."

msgid "Remove all items from the dictionary."
msgstr "Видаліть усі елементи зі словника."

msgid "Return a shallow copy of the dictionary."
msgstr "Поверніть мілку копію словника."

msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Створіть новий словник із ключами з *iterable* і значеннями, встановленими "
"на *value*."

msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` — це метод класу, який повертає новий словник. *value* за "
"замовчуванням ``None``. Усі значення стосуються лише одного екземпляра, тому "
"загалом не має сенсу, щоб *value* було змінним об’єктом, таким як порожній "
"список. Щоб отримати різні значення, замість цього використовуйте :ref:`dict "
"comprehension <dict>`."

msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Повертає значення для *key*, якщо *key* є в словнику, інакше *за "
"замовчуванням*. Якщо *default* не вказано, за замовчуванням буде ``None``, "
"тому цей метод ніколи не викликає :exc:`KeyError`."

msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Повертає нове подання елементів словника (пари \"(ключ, значення)\"). "
"Перегляньте :ref:`документацію об’єктів перегляду <dict-views>`."

msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Повернути новий вигляд ключів словника. Перегляньте :ref:`документацію "
"об’єктів перегляду <dict-views>`."

msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Якщо *key* є у словнику, видаліть його та поверніть його значення, інакше "
"поверніть *default*. Якщо *default* не вказано, а *key* немає в словнику, "
"виникає :exc:`KeyError`."

msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Видалити та повернути пару ``(ключ, значення)`` зі словника. Пари "
"повертаються в порядку :abbr:`LIFO (останній прийшов, перший вийшов)`."

msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` корисний для деструктивного повторення словника, як це часто "
"використовується в набір алгоритмів. Якщо словник порожній, виклик :meth:"
"`popitem` викликає :exc:`KeyError`."

msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"Замовлення LIFO тепер гарантовано. У попередніх версіях :meth:`popitem` "
"повертав довільну пару ключ/значення."

msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Повертає зворотний ітератор над ключами словника. Це ярлик для ``reversed(d."
"keys())``."

msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Якщо *key* є в словнику, поверніть його значення. Якщо ні, вставте *ключ* зі "
"значенням *default* і поверніть *default*. *default* за замовчуванням "
"``None``."

msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Оновіть словник парами ключ/значення з *other*, перезаписавши існуючі ключі. "
"Повернути ``Жодного``."

msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` приймає або інший об’єкт словника, або ітерацію пар ключ/"
"значення (як кортежі чи інші ітерації довжиною два). Якщо вказано аргументи "
"ключового слова, словник оновлюється такими парами ключ/значення: ``d."
"update(red=1, blue=2)``."

msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Повернути нове подання значень словника. Перегляньте :ref:`документацію "
"об’єктів перегляду <dict-views>`."

msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Порівняння рівності між одним переглядом ``dict.values()`` та іншим завжди "
"повертатиме ``False``. Це також стосується порівняння ``dict.values()`` із "
"собою::"

msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Створіть новий словник із об’єднаними ключами та значеннями *d* та *other*, "
"які мають бути словниками. Значення *other* мають пріоритет, коли *d* та "
"*other* мають спільні ключі."

msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Оновіть словник *d* ключами та значеннями з *other*, які можуть бути :term:"
"`mapping` або :term:`iterable` пар ключ/значення. Значення *other* мають "
"пріоритет, коли *d* та *other* мають спільні ключі."

msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"Словники порівнюються рівними тоді і тільки тоді, коли вони мають однакові "
"пари ``(ключ, значення)`` (незалежно від порядку). Порівняння порядку (' <', "
"'<=', '> =', '>') викликає :exc:`TypeError`."

msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Словники зберігають порядок вставки. Зауважте, що оновлення ключа не впливає "
"на порядок. Ключі, додані після видалення, вставляються в кінці. ::"

msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Порядок словника гарантовано буде порядком вставки. Така поведінка була "
"деталлю реалізації CPython від 3.6."

msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Словники та перегляди словників є оборотними. ::"

msgid "Dictionaries are now reversible."
msgstr "Словники тепер оборотні."

msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` можна використовувати для створення "
"перегляду :class:`dict` лише для читання."

msgid "Dictionary view objects"
msgstr "Об’єкти перегляду словника"

msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Об’єкти, які повертаються :meth:`dict.keys`, :meth:`dict.values` і :meth:"
"`dict.items`, є *об’єктами перегляду*. Вони забезпечують динамічний перегляд "
"статей словника, що означає, що коли словник змінюється, перегляд відображає "
"ці зміни."

msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Перегляди словників можна повторювати, щоб отримати відповідні дані та "
"підтримувати тести членства:"

msgid "Return the number of entries in the dictionary."
msgstr "Повернути кількість статей у словнику."

msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Повертає ітератор над ключами, значеннями або елементами (представленими у "
"вигляді кортежів ``(ключ, значення)``) у словнику."

msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Ключі та значення повторюються в порядку вставки. Це дозволяє створювати "
"пари ``(значення, ключ)`` за допомогою :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``. Інший спосіб створити той самий список: ``pairs = "
"[(v, k) for (k, v) in d.items()]``."

msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Ітерація подання під час додавання чи видалення записів у словнику може "
"викликати :exc:`RuntimeError` або не вдається виконати ітерацію по всіх "
"записах."

msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Порядок словника гарантовано буде порядком вставки."

msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Повертає ``True``, якщо *x* міститься в ключах, значеннях або елементах "
"основного словника (в останньому випадку *x* має бути кортежем ``(ключ, "
"значення)``)."

msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Повертає зворотний ітератор над ключами, значеннями або елементами словника. "
"Подання буде повторено в порядку, зворотному до вставки."

msgid "Dictionary views are now reversible."
msgstr "Перегляди словника тепер оборотні."

msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Повертає :class:`types.MappingProxyType`, який обгортає вихідний словник, на "
"який посилається перегляд."

msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""
"Перегляди ключів подібні до набору, оскільки їхні записи унікальні та "
"хешуються. Якщо всі значення можна хешувати, так що пари ``(ключ, "
"значення)`` є унікальними та хешованими, то перегляд елементів також "
"подібний до набору. (Подання значень не розглядаються як схожі на множину, "
"оскільки записи, як правило, не є унікальними.) Для подібних на множину "
"подання доступні всі операції, визначені для абстрактного базового класу :"
"class:`collections.abc.Set` (наприклад, , ``==``, ``<`` або ``^``)."

msgid "An example of dictionary view usage::"
msgstr "Приклад використання перегляду словника::"

msgid "Context Manager Types"
msgstr "Типи менеджера контексту"

msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Оператор Python :keyword:`with` підтримує концепцію контексту виконання, "
"визначеного менеджером контексту. Це реалізовано за допомогою пари методів, "
"які дозволяють визначеним користувачем класам визначати контекст виконання, "
"який вводиться перед виконанням тіла оператора та виходить, коли оператор "
"закінчується:"

msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Введіть контекст середовища виконання та поверніть або цей об’єкт, або інший "
"об’єкт, пов’язаний із контекстом середовища виконання. Значення, яке "
"повертає цей метод, прив’язується до ідентифікатора в пункті :keyword:`!as` "
"операторів :keyword:`with` за допомогою цього менеджера контексту."

msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Прикладом контекстного менеджера, який повертає сам себе, є :term:`file "
"object`. Файлові об’єкти повертаються з __enter__(), щоб дозволити "
"використовувати :func:`open` як вираз контексту в операторі :keyword:`with`."

msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Прикладом менеджера контексту, який повертає пов’язаний об’єкт, є той, який "
"повертає :func:`decimal.localcontext`. Ці менеджери встановлюють активний "
"десятковий контекст на копію вихідного десяткового контексту, а потім "
"повертають копію. Це дозволяє вносити зміни до поточного десяткового "
"контексту в тілі оператора :keyword:`with`, не впливаючи на код поза "
"оператором :keyword:`!with`."

msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Вийдіть із контексту виконання та поверніть логічний прапор, який вказує, чи "
"має бути придушено будь-який виняток, який стався. Якщо виняток стався під "
"час виконання тіла оператора :keyword:`with`, аргументи містять тип винятку, "
"значення та інформацію про відстеження. В іншому випадку всі три аргументи є "
"``Жодним``."

msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Повернення цього методу справжнього значення призведе до того, що оператор :"
"keyword:`with` придушить виняток і продовжить виконання з оператором, який "
"слідує безпосередньо за оператором :keyword:`!with`. В іншому випадку "
"виняткова ситуація продовжує поширюватися після завершення виконання цього "
"методу. Винятки, які виникають під час виконання цього методу, замінять будь-"
"які винятки, які виникли в тілі оператора :keyword:`!with`."

msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"Переданий виняток ніколи не слід повторно викликати явно — натомість цей "
"метод має повертати значення false, щоб вказати, що метод завершився успішно "
"та не хоче придушувати викликаний виняток. Це дозволяє коду керування "
"контекстом легко визначати, чи метод :meth:`__exit__` фактично не вдався."

msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python визначає декілька контекстних менеджерів для підтримки легкої "
"синхронізації потоків, швидкого закриття файлів чи інших об’єктів і "
"простішого маніпулювання активним десятковим арифметичним контекстом. "
"Конкретні типи не розглядаються спеціально за межами їх реалізації в "
"протоколі керування контекстом. Перегляньте модуль :mod:`contextlib` для "
"деяких прикладів."

msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
":term:`generator`\\s Python і декоратор :class:`contextlib.contextmanager` "
"забезпечують зручний спосіб реалізації цих протоколів. Якщо функція-"
"генератор прикрашена декоратором :class:`contextlib.contextmanager`, вона "
"повертатиме менеджер контексту, який реалізує необхідні методи :meth:"
"`~contextmanager.__enter__` і :meth:`~contextmanager.__exit__`, а не "
"ітератор, створений недекорованою функцією генератора."

msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Зауважте, що немає спеціального слота для жодного з цих методів у структурі "
"типу для об’єктів Python в API Python/C. Типи розширень, які хочуть "
"визначити ці методи, повинні надати їх як звичайний доступний метод Python. "
"Порівняно з накладними витратами на налаштування контексту виконання, "
"накладні витрати на пошук словника одного класу є незначними."

msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Типи анотацій типу --- :ref:`Загальний псевдонім <types-genericalias>`, :ref:"
"`Об’єднання <types-union>`"

msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"Основними вбудованими типами для :term:`анотацій типу <annotation>` є :ref:"
"`Generic Alias <types-genericalias>` і :ref:`Union <types-union>`."

msgid "Generic Alias Type"
msgstr "Загальний тип псевдоніма"

msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"Об’єкти ``GenericAlias`` зазвичай створюються :ref:`індексом "
"<subscriptions>` класу. Найчастіше вони використовуються з :ref:"
"`контейнерними класами <sequence-types>`, такими як :class:`list` або :class:"
"`dict`. Наприклад, ``list[int]`` є об’єктом ``GenericAlias``, створеним "
"шляхом підписання класу ``list`` з аргументом :class:`int`. Об’єкти "
"``GenericAlias`` призначені насамперед для використання з :term:`анотаціями "
"типу <annotation>`."

msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"Як правило, індекс класу можливий, лише якщо клас реалізує спеціальний "
"метод :meth:`~object.__class_getitem__`."

msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Об’єкт ``GenericAlias`` діє як проксі для :term:`generic type`, реалізуючи "
"*параметризовані генерики*."

msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"Для класу-контейнера аргумент(и), що надаються :ref:`підписці "
"<subscriptions>` класу, може вказувати тип(и) елементів, які містить об’єкт. "
"Наприклад, ``set[bytes]`` можна використовувати в анотаціях типу для "
"позначення :class:`set`, у якому всі елементи мають тип :class:`bytes`."

msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"Для класу, який визначає :meth:`~object.__class_getitem__`, але не є "
"контейнером, аргумент(и), що надаються до підписки класу, часто вказуватиме "
"тип(и) повернення одного або кількох методів, визначених для об’єкта . "
"Наприклад, :mod:`регулярні вирази <re>` можна використовувати як для типу "
"даних :class:`str`, так і для типу даних :class:`bytes`:"

msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Якщо ``x = re.search('foo', 'foo')``, ``x`` буде об’єктом :ref:`re.Match "
"<match-objects>`, де повертаються значення ``x.group(0 )`` і ``x[0]`` будуть "
"мати тип :class:`str`. Ми можемо представити цей тип об’єктів в анотаціях "
"типу за допомогою ``GenericAlias`` ``re.Match[str]``."

msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Якщо ``y = re.search(b'bar', b'bar')`` (зверніть увагу на ``b`` для :class:"
"`bytes`), ``y`` також буде екземпляром ``re.Match``, але повертані значення "
"``y.group(0)`` і ``y[0]`` будуть мати тип :class:`bytes`. В анотаціях типів "
"ми б представили цю різноманітність об’єктів :ref:`re.Match <match-objects>` "
"за допомогою ``re.Match[bytes]``."

msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"Об’єкти ``GenericAlias`` є екземплярами класу :class:`types.GenericAlias`, "
"який також можна використовувати для безпосереднього створення об’єктів "
"``GenericAlias``."

msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Створює ``Generic Alias``, що представляє тип ``T``, параметризований типами "
"*X*, *Y* тощо залежно від ``T``, що використовується. Наприклад, функція, "
"яка очікує :class:`list`, що містить елементи :class:`float`::"

msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Інший приклад для об’єктів :term:`mapping` з використанням :class:`dict`, "
"який є загальним типом, який очікує двох параметрів типу, що представляють "
"тип ключа та тип значення. У цьому прикладі функція очікує ``dict`` з "
"ключами типу :class:`str` і значеннями типу :class:`int`::"

msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"Вбудовані функції :func:`isinstance` і :func:`issubclass` не приймають типи "
"``GenericAlias`` для свого другого аргументу::"

msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Середовище виконання Python не вимагає :term:`анотацій типу <annotation>`. "
"Це поширюється на загальні типи та їхні параметри типу. Під час створення "
"об’єкта-контейнера з ``GenericAlias`` елементи в контейнері не перевіряються "
"на їх тип. Наприклад, наступний код не рекомендується, але працюватиме без "
"помилок:"

msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Крім того, параметризовані генерики стирають параметри типу під час "
"створення об’єкта:"

msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Виклик :func:`repr` або :func:`str` у загальному показує параметризований "
"тип::"

msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Метод :meth:`~object.__getitem__` загальних контейнерів викличе виняток, щоб "
"заборонити такі помилки, як ``dict[str][str]``::"

msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Однак такі вирази дійсні, коли використовуються :ref:`змінні типу "
"<generics>`. Індекс має містити стільки елементів, скільки елементів змінних "
"типу в об’єкті ``GenericAlias`` :attr:`~genericalias.__args__`. ::"

msgid "Standard Generic Classes"
msgstr "Стандартні загальні класи"

msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Наступні стандартні бібліотечні класи підтримують параметризовані генерики. "
"Цей список не є вичерпним."

msgid ":class:`tuple`"
msgstr ":class:`tuple`"

msgid ":class:`list`"
msgstr ":class:`list`"

msgid ":class:`dict`"
msgstr ":class:`dict`"

msgid ":class:`set`"
msgstr ":class:`set`"

msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

msgid ":class:`type`"
msgstr ":class:`type`"

msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Патерн <re-objects>`"

msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`полиця.BsdDbShelf`"

msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`полиця.DbfilenameShelf`"

msgid ":class:`shelve.Shelf`"
msgstr ":class:`полиця.Полиця`"

msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Спеціальні атрибути об’єктів ``GenericAlias``"

msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Усі параметризовані генерики реалізують спеціальні атрибути лише для читання."

msgid "This attribute points at the non-parameterized generic class::"
msgstr "Цей атрибут вказує на непараметризований загальний клас::"

msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Цей атрибут є :class:`tuple` (можливо, довжиною 1) загальних типів, "
"переданих до оригінального :meth:`~object.__class_getitem__` загального "
"класу::"

msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Цей атрибут є ліниво обчисленим кортежем (можливо, порожнім) унікальних "
"змінних типу, знайдених у ``__args__``::"

msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Об’єкт ``GenericAlias`` з параметрами :class:`typing.ParamSpec` може не мати "
"правильних ``__parameters__`` після заміни, тому що :class:`typing."
"ParamSpec` призначений насамперед для статичної перевірки типу."

msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - підказки типу"

msgid "Introducing Python's framework for type annotations."
msgstr "Представляємо структуру Python для анотацій типів."

msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Універсальні підказки типів у стандартних колекціях"

msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Представляємо можливість нативної параметризації класів стандартної "
"бібліотеки, якщо вони реалізують спеціальний метод класу :meth:`~object."
"__class_getitem__`."

msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`визначені користувачем узагальнення <user-defined-"
"generics>` і :class:`typing.Generic`"

msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Документація про те, як реалізувати загальні класи, які можна "
"параметризувати під час виконання та розуміти статичними засобами перевірки "
"типів."

msgid "Union Type"
msgstr "Тип союзу"

msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"Об’єкт об’єднання містить значення операції ``|`` (порозрядної або) на "
"кількох :ref:`об’єктах типу <bltin-type-objects>`. Ці типи призначені "
"насамперед для :term:`анотацій типу <annotation>`. Вираз типу об’єднання "
"забезпечує чіткіший синтаксис підказки типу порівняно з :data:`typing.Union`."

msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Визначає об’єкт об’єднання, який містить типи *X*, *Y* і так далі. ``X | Y`` "
"означає X або Y. Це еквівалентно ``typing.Union[X, Y]``. Наприклад, наступна "
"функція очікує аргумент типу :class:`int` або :class:`float`::"

msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Об’єкти об’єднання можна перевірити на рівність з іншими об’єктами "
"об’єднання. Подробиці:"

msgid "Unions of unions are flattened::"
msgstr "Союзи союзів сплощені::"

msgid "Redundant types are removed::"
msgstr "Зайві типи видаляються:"

msgid "When comparing unions, the order is ignored::"
msgstr "Під час порівняння об'єднань порядок ігнорується:"

msgid "It is compatible with :data:`typing.Union`::"
msgstr "Він сумісний з :data:`typing.Union`::"

msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Необов'язкові типи можуть бути написані як об'єднання з ``None``::"

msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Виклики :func:`isinstance` і :func:`issubclass` також підтримуються з "
"об’єктом об’єднання::"

msgid ""
"However, union objects containing :ref:`parameterized generics <types-"
"genericalias>` cannot be used::"
msgstr ""
"Однак об’єкти об’єднання, що містять :ref:`параметризовані генерики <types-"
"genericalias>`, не можна використовувати:"

msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"Доступ до відкритого користувачем типу для об’єкта union можна отримати з :"
"data:`types.UnionType` і використовувати для перевірки :func:`isinstance`. "
"Об’єкт не може бути створений із типу::"

msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`__or__`, the Union may override "
"it::"
msgstr ""
"Метод :meth:`__or__` було додано для підтримки синтаксису ``X | Y``. Якщо "
"метаклас реалізує :meth:`__or__`, об’єднання може замінити його::"

msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP пропонує ``X | Синтаксис Y`` і тип Union."

msgid "Other Built-in Types"
msgstr "Інші вбудовані типи"

msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"Інтерпретатор підтримує кілька інших видів об'єктів. Більшість із них "
"підтримує лише одну або дві операції."

msgid "Modules"
msgstr "Модулі"

msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"Єдиною спеціальною операцією над модулем є доступ до атрибутів: ``m.name``, "
"де *m* — це модуль, а *name* отримує доступ до імені, визначеного в таблиці "
"символів *m*. Модулю можна призначити атрибути. (Зауважте, що оператор :"
"keyword:`import` не є, строго кажучи, операцією над об’єктом модуля; "
"``import foo`` не вимагає існування об’єкта модуля з назвою *foo*, скоріше "
"для цього потрібен (зовнішній) *визначення* для модуля з назвою *foo* десь.)"

msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Спеціальним атрибутом кожного модуля є :attr:`~object.__dict__`. Це словник, "
"що містить таблицю символів модуля. Зміна цього словника фактично змінить "
"таблицю символів модуля, але пряме призначення атрибуту :attr:`~object."
"__dict__` неможливо (ви можете написати ``m.__dict__['a'] = 1``, що визначає "
"``m.a`` буде ``1``, але ви не можете написати ``m.__dict__ = {}``). Не "
"рекомендується безпосередньо змінювати :attr:`~object.__dict__`."

msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Модулі, вбудовані в інтерпретатор, записуються так: ``<module 'sys' (built-"
"in)>``. Якщо завантажуються з файлу, вони записуються як ``<module 'os' from "
"'/usr/local/lib/pythonX.Y/os.pyc'>``."

msgid "Classes and Class Instances"
msgstr "Класи та екземпляри класів"

msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Перегляньте :ref:`objects` і :ref:`class` для них."

msgid "Functions"
msgstr "Функції"

msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Функціональні об’єкти створюються визначеннями функцій. Єдина операція над "
"об’єктом-функцією – це викликати його: ``func(список-аргументів)``."

msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Насправді існує два види функціональних об’єктів: вбудовані функції та "
"функції, визначені користувачем. Обидва підтримують однакову операцію "
"(виклик функції), але реалізація різна, отже, різні типи об’єктів."

msgid "See :ref:`function` for more information."
msgstr "Перегляньте :ref:`function` для отримання додаткової інформації."

msgid "Methods"
msgstr "методи"

msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Методи — це функції, які викликаються за допомогою нотації атрибутів. Є два "
"варіанти: вбудовані методи (такі як :meth:`append` у списках) і методи "
"екземплярів класу. Вбудовані методи описані з типами, які їх підтримують."

msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Якщо ви отримуєте доступ до методу (функції, визначеної в просторі імен "
"класу) через екземпляр, ви отримуєте спеціальний об’єкт: об’єкт :dfn:"
"`зв’язаний метод` (також званий :dfn:`instance method`). Під час виклику він "
"додасть аргумент ``self`` до списку аргументів. Зв’язані методи мають два "
"спеціальні атрибути лише для читання: ``m.__self__`` - це об'єкт, з яким "
"працює метод, і ``m.__func__`` - це функція, що реалізує метод. Виклик "
"``m(arg-1, arg-2, ..., arg-n)`` повністю еквівалентний виклику ``m."
"__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."

msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Як і функціональні об’єкти, зв’язані об’єкти методів підтримують отримання "
"довільних атрибутів. Однак, оскільки атрибути методу фактично зберігаються в "
"базовому об’єкті функції (``meth.__func__``), встановлення атрибутів методу "
"для зв’язаних методів заборонено. Спроба встановити атрибут для методу "
"призводить до появи :exc:`AttributeError`. Щоб установити атрибут методу, "
"вам потрібно явно встановити його на базовому об’єкті функції::"

msgid "See :ref:`types` for more information."
msgstr "Перегляньте :ref:`types` для отримання додаткової інформації."

msgid "Code Objects"
msgstr "Об'єкти коду"

msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Об’єкти коду використовуються реалізацією для представлення "
"\"псевдокомпільованого\" виконуваного коду Python, такого як тіло функції. "
"Вони відрізняються від функціональних об’єктів, оскільки не містять "
"посилання на своє глобальне середовище виконання. Об’єкти коду повертаються "
"вбудованою функцією :func:`compile` і можуть бути витягнуті з об’єктів "
"функції через їх атрибут :attr:`__code__`. Дивіться також модуль :mod:`code`."

msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"Доступ до ``__code__`` викликає :ref:`подію аудиту <auditing>` ``object."
"__getattr__`` з аргументами ``obj`` і ``\"__code__\"``."

msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Об’єкт коду можна виконати або оцінити, передавши його (замість вихідного "
"рядка) у вбудовані функції :func:`exec` або :func:`eval`."

msgid "Type Objects"
msgstr "Об'єкти типу"

msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Об’єкти типу представляють різні типи об’єктів. Доступ до типу об’єкта "
"здійснюється за допомогою вбудованої функції :func:`type`. Над типами немає "
"спеціальних операцій. Стандартний модуль :mod:`types` визначає імена для "
"всіх стандартних вбудованих типів."

msgid "Types are written like this: ``<class 'int'>``."
msgstr "Типи записуються так: ``<class 'int'>``."

msgid "The Null Object"
msgstr "Нульовий об’єкт"

msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Цей об’єкт повертають функції, які явно не повертають значення. Він не "
"підтримує ніяких спеціальних операцій. Існує рівно один нульовий об’єкт із "
"назвою ``None`` (вбудована назва). ``type(None)()`` створює той самий "
"синглтон."

msgid "It is written as ``None``."
msgstr "Він записується як ``None``."

msgid "The Ellipsis Object"
msgstr "Об’єкт \"Еліпсис\"."

msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Цей об’єкт зазвичай використовується для нарізки (див. :ref:`slicings`). Він "
"не підтримує ніяких спеціальних операцій. Існує рівно один об’єкт з крапкою, "
"який називається :const:`Ellipsis` (вбудована назва). ``type(Ellipsis)()`` "
"виробляє :const:`Ellipsis` синглтон."

msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "Він записується як ``Еліпсис`` або ``...``."

msgid "The NotImplemented Object"
msgstr "Об’єкт NotImplemented"

msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Цей об’єкт повертається з порівнянь і двійкових операцій, коли їх запитують "
"оперувати типами, які вони не підтримують. Перегляньте :ref:`comparisons` "
"для отримання додаткової інформації. Існує рівно один об’єкт "
"``NotImplemented``. ``type(NotImplemented)()`` створює одиночний екземпляр."

msgid "It is written as ``NotImplemented``."
msgstr "Це написано як ``NotImplemented``."

msgid "Boolean Values"
msgstr "Логічні значення"

msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"Логічні значення – це два постійні об’єкти ``False`` і ``True``. Вони "
"використовуються для представлення істинних значень (хоча інші значення "
"також можна вважати хибними або істинними). У числовому контексті "
"(наприклад, коли використовуються як аргумент для арифметичного оператора) "
"вони поводяться як цілі числа 0 і 1 відповідно. Вбудовану функцію :func:"
"`bool` можна використати для перетворення будь-якого значення на логічний, "
"якщо це значення можна інтерпретувати як значення істинності (див. розділ :"
"ref:`truth` вище)."

msgid "They are written as ``False`` and ``True``, respectively."
msgstr "Вони записуються як ``False`` і ``True`` відповідно."

msgid "Internal Objects"
msgstr "Внутрішні об'єкти"

msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Перегляньте :ref:`types` цю інформацію. Він описує об’єкти фрейму стека, "
"об’єкти трасування та об’єкти фрагментів."

msgid "Special Attributes"
msgstr "Спеціальні атрибути"

msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Реалізація додає кілька спеціальних атрибутів лише для читання до кількох "
"типів об’єктів, де вони актуальні. Деякі з них не повідомляються вбудованою "
"функцією :func:`dir`."

msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Словник або інший об’єкт відображення, який використовується для зберігання "
"атрибутів об’єкта (для запису)."

msgid "The class to which a class instance belongs."
msgstr "Клас, до якого належить екземпляр класу."

msgid "The tuple of base classes of a class object."
msgstr "Кортеж базових класів об’єкта класу."

msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "Ім'я класу, функції, методу, дескриптора або екземпляра генератора."

msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
":term:`qualified name` класу, функції, методу, дескриптора або екземпляра "
"генератора."

msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Цей атрибут є кортежем класів, які враховуються під час пошуку базових "
"класів під час вирішення методу."

msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Цей метод може бути перевизначений метакласом, щоб налаштувати порядок "
"вирішення методів для його екземплярів. Він викликається під час створення "
"екземпляра класу, а його результат зберігається в :attr:`~class.__mro__`."

msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""
"Кожен клас зберігає список слабких посилань на його безпосередні підкласи. "
"Цей метод повертає список усіх посилань, які ще живі. Список у порядку "
"визначення. Приклад::"

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Додаткову інформацію про ці спеціальні методи можна знайти в довідковому "
"посібнику Python (:ref:`customization`)."

msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Як наслідок, список ``[1, 2]`` вважається рівним ``[1.0, 2.0]``, і "
"аналогічно для кортежів."

msgid "They must have since the parser can't tell the type of the operands."
msgstr "Мабуть, оскільки аналізатор не може визначити тип операндів."

msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Регістр символів — це символи загальної категорії, які мають одну з таких "
"властивостей: \"Lu\" (літера, верхній регістр), \"Ll\" (літера, нижній "
"регістр) або \"Lt\" (літера, регістр заголовка)."

msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Щоб відформатувати лише кортеж, ви повинні надати одиночний кортеж, єдиним "
"елементом якого є кортеж, який потрібно відформатувати."
