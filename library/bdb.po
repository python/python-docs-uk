# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`bdb` --- Debugger framework"
msgstr ":mod:`bdb` --- Фреймворк налагоджувача"

msgid "**Source code:** :source:`Lib/bdb.py`"
msgstr "**Вихідний код:** :source:`Lib/bdb.py`"

msgid ""
"The :mod:`bdb` module handles basic debugger functions, like setting "
"breakpoints or managing execution via the debugger."
msgstr ""
"Модуль :mod:`bdb` обробляє основні функції налагоджувача, як-от встановлення "
"точок зупину або керування виконанням через налагоджувач."

msgid "The following exception is defined:"
msgstr "Визначено такий виняток:"

msgid "Exception raised by the :class:`Bdb` class for quitting the debugger."
msgstr "Виняток, створений класом :class:`Bdb` для виходу з налагоджувача."

msgid "The :mod:`bdb` module also defines two classes:"
msgstr "Модуль :mod:`bdb` також визначає два класи:"

msgid ""
"This class implements temporary breakpoints, ignore counts, disabling and "
"(re-)enabling, and conditionals."
msgstr ""
"Цей клас реалізує тимчасові точки зупинки, ігнорування підрахунків, "
"відключення та (повторне) увімкнення, а також умови."

msgid ""
"Breakpoints are indexed by number through a list called :attr:`bpbynumber` "
"and by ``(file, line)`` pairs through :attr:`bplist`.  The former points to "
"a single instance of class :class:`Breakpoint`.  The latter points to a list "
"of such instances since there may be more than one breakpoint per line."
msgstr ""
"Точки зупину індексуються за номером у списку під назвою :attr:`bpbynumber` "
"та парами ``(файл, рядок)`` через :attr:`bplist`. Перший вказує на єдиний "
"екземпляр класу :class:`Breakpoint`. Останній вказує на список таких "
"випадків, оскільки на рядок може бути більше однієї точки зупину."

msgid ""
"When creating a breakpoint, its associated filename should be in canonical "
"form.  If a *funcname* is defined, a breakpoint hit will be counted when the "
"first line of that function is executed.  A conditional breakpoint always "
"counts a hit."
msgstr ""
"Під час створення точки зупину пов’язане ім’я файлу має бути в канонічній "
"формі. Якщо *funcname* визначено, то точка зупину буде зарахована під час "
"виконання першого рядка цієї функції. Умовна точка зупину завжди зараховує "
"попадання."

msgid ":class:`Breakpoint` instances have the following methods:"
msgstr "Екземпляри :class:`Breakpoint` мають такі методи:"

msgid ""
"Delete the breakpoint from the list associated to a file/line.  If it is the "
"last breakpoint in that position, it also deletes the entry for the file/"
"line."
msgstr ""
"Видалити точку зупину зі списку, пов’язаного з файлом/рядком. Якщо це "
"остання точка зупину в цій позиції, вона також видаляє запис для файлу/рядка."

msgid "Mark the breakpoint as enabled."
msgstr "Позначте точку зупину як увімкнену."

msgid "Mark the breakpoint as disabled."
msgstr "Позначте точку зупину як вимкнену."

msgid ""
"Return a string with all the information about the breakpoint, nicely "
"formatted:"
msgstr ""
"Повертає рядок з усією інформацією про точку зупину, красиво відформатований:"

msgid "The breakpoint number."
msgstr "Номер точки зупину."

msgid "If it is temporary or not."
msgstr "Якщо це тимчасово чи ні."

msgid "Its file,line position."
msgstr "Його файл, позиція рядка."

msgid "The condition that causes a break."
msgstr "Стан, що викликає розрив."

msgid "If it must be ignored the next N times."
msgstr "Якщо його потрібно проігнорувати наступні N разів."

msgid "The breakpoint hit count."
msgstr "Підрахунок ударів точки зупину."

msgid ""
"Print the output of :meth:`bpformat` to the file *out*, or if it is "
"``None``, to standard output."
msgstr ""
"Надрукувати вихідні дані :meth:`bpformat` у файл *out*, або, якщо він "
"``None``, у стандартний вихід."

msgid "The :class:`Bdb` class acts as a generic Python debugger base class."
msgstr "Клас :class:`Bdb` діє як загальний базовий клас налагоджувача Python."

msgid ""
"This class takes care of the details of the trace facility; a derived class "
"should implement user interaction.  The standard debugger class (:class:`pdb."
"Pdb`) is an example."
msgstr ""
"Цей клас піклується про деталі засобу трасування; похідний клас повинен "
"реалізовувати взаємодію з користувачем. Прикладом є стандартний клас "
"відладчика (:class:`pdb.Pdb`)."

msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. Whether a frame is considered to "
"originate in a certain module is determined by the ``__name__`` in the frame "
"globals."
msgstr ""
"Аргумент *skip*, якщо він наданий, має бути повторюваним шаблоном імен "
"модулів у стилі glob. Налагоджувач не ввійде в кадри, які походять із "
"модуля, який відповідає одному з цих шаблонів. Чи вважається, що фрейм "
"походить із певного модуля, визначається ``__name__`` у глобальних "
"параметрах фрейму."

msgid "The *skip* argument."
msgstr "Аргумент *пропустити*."

msgid ""
"The following methods of :class:`Bdb` normally don't need to be overridden."
msgstr "Наступні методи :class:`Bdb` зазвичай не потребують перевизначення."

msgid ""
"Auxiliary method for getting a filename in a canonical form, that is, as a "
"case-normalized (on case-insensitive filesystems) absolute path, stripped of "
"surrounding angle brackets."
msgstr ""
"Допоміжний метод отримання назви файлу в канонічній формі, тобто як "
"нормований за регістром (у файлових системах без урахування регістру) "
"абсолютний шлях, позбавлений оточуючих кутових дужок."

msgid ""
"Set the :attr:`botframe`, :attr:`stopframe`, :attr:`returnframe` and :attr:"
"`quitting` attributes with values ready to start debugging."
msgstr ""
"Установіть атрибути :attr:`botframe`, :attr:`stopframe`, :attr:`returnframe` "
"і :attr:`quitting` зі значеннями, готовими до початку налагодження."

msgid ""
"This function is installed as the trace function of debugged frames.  Its "
"return value is the new trace function (in most cases, that is, itself)."
msgstr ""
"Ця функція встановлена як функція трасування налагоджених кадрів. Його "
"значенням, що повертається, є нова функція трасування (у більшості випадків, "
"тобто сама)."

msgid ""
"The default implementation decides how to dispatch a frame, depending on the "
"type of event (passed as a string) that is about to be executed. *event* can "
"be one of the following:"
msgstr ""
"Реалізація за замовчуванням вирішує, як відправляти кадр, залежно від типу "
"події (переданої у вигляді рядка), яка має бути виконана. *подією* може бути "
"одне з наступного:"

msgid "``\"line\"``: A new line of code is going to be executed."
msgstr "``\"рядок\"``: буде виконано новий рядок коду."

msgid ""
"``\"call\"``: A function is about to be called, or another code block "
"entered."
msgstr "``\"виклик\"``: функція буде викликана або введено інший блок коду."

msgid "``\"return\"``: A function or other code block is about to return."
msgstr "``\"return\"``: функція або інший блок коду збирається повернутися."

msgid "``\"exception\"``: An exception has occurred."
msgstr "``\"exception\"``: сталася виняток."

msgid "``\"c_call\"``: A C function is about to be called."
msgstr "``\"c_call\"``: функція C збирається викликатися."

msgid "``\"c_return\"``: A C function has returned."
msgstr "``\"c_return\"``: функція C повернулася."

msgid "``\"c_exception\"``: A C function has raised an exception."
msgstr "``\"c_exception\"``: функція C викликала виняток."

msgid ""
"For the Python events, specialized functions (see below) are called.  For "
"the C events, no action is taken."
msgstr ""
"Для подій Python викликаються спеціалізовані функції (див. нижче). Для подій "
"C не виконується жодних дій."

msgid "The *arg* parameter depends on the previous event."
msgstr "Параметр *arg* залежить від попередньої події."

msgid ""
"See the documentation for :func:`sys.settrace` for more information on the "
"trace function.  For more information on code and frame objects, refer to :"
"ref:`types`."
msgstr ""
"Перегляньте документацію для :func:`sys.settrace`, щоб дізнатися більше про "
"функцію трасування. Для отримання додаткової інформації про код і об’єкти "
"фрейму зверніться до :ref:`types`."

msgid ""
"If the debugger should stop on the current line, invoke the :meth:"
"`user_line` method (which should be overridden in subclasses). Raise a :exc:"
"`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can be "
"set from :meth:`user_line`).  Return a reference to the :meth:"
"`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Якщо налагоджувач повинен зупинитися на поточному рядку, викличте метод :"
"meth:`user_line` (який має бути перевизначений у підкласах). Викликайте "
"виняток :exc:`BdbQuit`, якщо встановлено прапорець :attr:`Bdb.quitting` "
"(який можна встановити з :meth:`user_line`). Повернути посилання на метод :"
"meth:`trace_dispatch` для подальшого відстеження в цій області."

msgid ""
"If the debugger should stop on this function call, invoke the :meth:"
"`user_call` method (which should be overridden in subclasses). Raise a :exc:"
"`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can be "
"set from :meth:`user_call`).  Return a reference to the :meth:"
"`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Якщо налагоджувач зупиниться на цьому виклику функції, викличте метод :meth:"
"`user_call` (який має бути перевизначений у підкласах). Викликайте виняток :"
"exc:`BdbQuit`, якщо встановлено прапорець :attr:`Bdb.quitting` (який можна "
"встановити з :meth:`user_call`). Повернути посилання на метод :meth:"
"`trace_dispatch` для подальшого відстеження в цій області."

msgid ""
"If the debugger should stop on this function return, invoke the :meth:"
"`user_return` method (which should be overridden in subclasses). Raise a :"
"exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can "
"be set from :meth:`user_return`).  Return a reference to the :meth:"
"`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Якщо налагоджувач повинен зупинитися на цьому поверненні функції, викличте "
"метод :meth:`user_return` (який має бути перевизначений у підкласах). "
"Викликайте виняток :exc:`BdbQuit`, якщо встановлено прапорець :attr:`Bdb."
"quitting` (який можна встановити з :meth:`user_return`). Повернути посилання "
"на метод :meth:`trace_dispatch` для подальшого відстеження в цій області."

msgid ""
"If the debugger should stop at this exception, invokes the :meth:"
"`user_exception` method (which should be overridden in subclasses). Raise a :"
"exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can "
"be set from :meth:`user_exception`).  Return a reference to the :meth:"
"`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Якщо налагоджувач повинен зупинитися на цій винятковій ситуації, викликає "
"метод :meth:`user_exception` (який має бути перевизначений у підкласах). "
"Викликайте виняток :exc:`BdbQuit`, якщо встановлено прапорець :attr:`Bdb."
"quitting` (який можна встановити з :meth:`user_exception`). Повернути "
"посилання на метод :meth:`trace_dispatch` для подальшого відстеження в цій "
"області."

msgid ""
"Normally derived classes don't override the following methods, but they may "
"if they want to redefine the definition of stopping and breakpoints."
msgstr ""
"Зазвичай похідні класи не замінюють наступні методи, але вони можуть, якщо "
"хочуть перевизначити визначення зупинки та точок зупинки."

msgid ""
"This method checks if the *frame* is somewhere below :attr:`botframe` in the "
"call stack.  :attr:`botframe` is the frame in which debugging started."
msgstr ""
"Цей метод перевіряє, чи *фрейм* знаходиться десь нижче :attr:`botframe` у "
"стеку викликів. :attr:`botframe` — це фрейм, у якому почалося налагодження."

msgid ""
"This method checks if there is a breakpoint in the filename and line "
"belonging to *frame* or, at least, in the current function.  If the "
"breakpoint is a temporary one, this method deletes it."
msgstr ""
"Цей метод перевіряє, чи є точка зупину в імені файлу та рядку, що належить "
"*frame* або, принаймні, у поточній функції. Якщо точка зупину є тимчасовою, "
"цей метод видаляє її."

msgid ""
"This method checks if there is a breakpoint in the filename of the current "
"frame."
msgstr "Цей метод перевіряє, чи є точка зупину в імені файлу поточного кадру."

msgid ""
"Derived classes should override these methods to gain control over debugger "
"operation."
msgstr ""
"Похідні класи повинні перевизначати ці методи, щоб отримати контроль над "
"роботою відладчика."

msgid ""
"This method is called from :meth:`dispatch_call` when there is the "
"possibility that a break might be necessary anywhere inside the called "
"function."
msgstr ""
"Цей метод викликається з :meth:`dispatch_call`, коли існує ймовірність того, "
"що перерва може знадобитися будь-де всередині викликаної функції."

msgid ""
"This method is called from :meth:`dispatch_line` when either :meth:"
"`stop_here` or :meth:`break_here` yields ``True``."
msgstr ""
"Цей метод викликається з :meth:`dispatch_line`, коли :meth:`stop_here` або :"
"meth:`break_here` видає ``True``."

msgid ""
"This method is called from :meth:`dispatch_return` when :meth:`stop_here` "
"yields ``True``."
msgstr ""
"Цей метод викликається з :meth:`dispatch_return`, коли :meth:`stop_here` дає "
"``True``."

msgid ""
"This method is called from :meth:`dispatch_exception` when :meth:`stop_here` "
"yields ``True``."
msgstr ""
"Цей метод викликається з :meth:`dispatch_exception`, коли :meth:`stop_here` "
"дає ``True``."

msgid "Handle how a breakpoint must be removed when it is a temporary one."
msgstr "Визначте, як потрібно видалити точку зупину, якщо вона є тимчасовою."

msgid "This method must be implemented by derived classes."
msgstr "Цей метод має бути реалізований похідними класами."

msgid ""
"Derived classes and clients can call the following methods to affect the "
"stepping state."
msgstr ""
"Похідні класи та клієнти можуть викликати наступні методи, щоб впливати на "
"кроковий стан."

msgid "Stop after one line of code."
msgstr "Зупинка після одного рядка коду."

msgid "Stop on the next line in or below the given frame."
msgstr "Зупиніться на наступному рядку в заданому кадрі або під ним."

msgid "Stop when returning from the given frame."
msgstr "Зупинка при поверненні із заданого кадру."

msgid ""
"Stop when the line with the line no greater than the current one is reached "
"or when returning from current frame."
msgstr ""
"Зупинка, коли буде досягнуто рядок, рядок не більший за поточний, або при "
"поверненні з поточного кадру."

msgid ""
"Start debugging from *frame*.  If *frame* is not specified, debugging starts "
"from caller's frame."
msgstr ""
"Почніть налагодження з *фрейму*. Якщо *frame* не вказано, налагодження "
"починається з кадру абонента."

msgid ""
"Stop only at breakpoints or when finished.  If there are no breakpoints, set "
"the system trace function to ``None``."
msgstr ""
"Зупиняйтеся лише в точках зупинки або після завершення. Якщо немає "
"контрольних точок, встановіть для функції трасування системи значення "
"``None``."

msgid ""
"Set the :attr:`quitting` attribute to ``True``.  This raises :exc:`BdbQuit` "
"in the next call to one of the :meth:`dispatch_\\*` methods."
msgstr ""
"Встановіть для атрибута :attr:`quitting` значення ``True``. Це викликає :exc:"
"`BdbQuit` під час наступного виклику одного з методів :meth:`dispatch_\\*`."

msgid ""
"Derived classes and clients can call the following methods to manipulate "
"breakpoints.  These methods return a string containing an error message if "
"something went wrong, or ``None`` if all is well."
msgstr ""
"Похідні класи та клієнти можуть викликати наведені нижче методи для "
"керування точками зупинки. Ці методи повертають рядок, що містить "
"повідомлення про помилку, якщо щось пішло не так, або ``None``, якщо все "
"добре."

msgid ""
"Set a new breakpoint.  If the *lineno* line doesn't exist for the *filename* "
"passed as argument, return an error message.  The *filename* should be in "
"canonical form, as described in the :meth:`canonic` method."
msgstr ""
"Встановіть нову точку зупинки. Якщо рядок *lineno* не існує для *ім’я "
"файлу*, переданого як аргумент, поверніть повідомлення про помилку. *Ім’я* "
"файлу має бути в канонічній формі, як описано в методі :meth:`canonic`."

msgid ""
"Delete the breakpoints in *filename* and *lineno*.  If none were set, an "
"error message is returned."
msgstr ""
"Видаліть точки зупину в *filename* і *lineno*. Якщо жодного не встановлено, "
"повертається повідомлення про помилку."

msgid ""
"Delete the breakpoint which has the index *arg* in the :attr:`Breakpoint."
"bpbynumber`.  If *arg* is not numeric or out of range, return an error "
"message."
msgstr ""
"Видаліть точку зупину, яка має індекс *arg* у :attr:`Breakpoint.bpbynumber`. "
"Якщо *arg* не є числом або виходить за межі діапазону, повертає повідомлення "
"про помилку."

msgid ""
"Delete all breakpoints in *filename*.  If none were set, an error message is "
"returned."
msgstr ""
"Видаліть усі контрольні точки в *назві файлу*. Якщо жодного не встановлено, "
"повертається повідомлення про помилку."

msgid "Delete all existing breakpoints."
msgstr "Видаліть усі існуючі точки зупину."

msgid ""
"Return a breakpoint specified by the given number.  If *arg* is a string, it "
"will be converted to a number.  If *arg* is a non-numeric string, if the "
"given breakpoint never existed or has been deleted, a :exc:`ValueError` is "
"raised."
msgstr ""
"Повертає точку зупину, визначену заданим числом. Якщо *arg* є рядком, його "
"буде перетворено на число. Якщо *arg* є нечисловим рядком, якщо задана точка "
"зупину ніколи не існувала або була видалена, виникає :exc:`ValueError`."

msgid "Check if there is a breakpoint for *lineno* of *filename*."
msgstr "Перевірте, чи є точка зупину для *lineno* *filename*."

msgid ""
"Return all breakpoints for *lineno* in *filename*, or an empty list if none "
"are set."
msgstr ""
"Повертає всі контрольні точки для *lineno* в *імені файлу* або порожній "
"список, якщо жодна з них не встановлена."

msgid "Return all breakpoints in *filename*, or an empty list if none are set."
msgstr ""
"Повертає всі контрольні точки в *назві файлу* або порожній список, якщо "
"жодна з них не встановлена."

msgid "Return all breakpoints that are set."
msgstr "Повернути всі встановлені точки зупину."

msgid ""
"Derived classes and clients can call the following methods to get a data "
"structure representing a stack trace."
msgstr ""
"Похідні класи та клієнти можуть викликати наведені нижче методи, щоб "
"отримати структуру даних, що представляє трасування стека."

msgid ""
"Get a list of records for a frame and all higher (calling) and lower frames, "
"and the size of the higher part."
msgstr ""
"Отримайте список записів для фрейму та всіх вищих (викликаючих) і нижчих "
"фреймів, а також розмір верхньої частини."

msgid ""
"Return a string with information about a stack entry, identified by a "
"``(frame, lineno)`` tuple:"
msgstr ""
"Повертає рядок з інформацією про запис стека, ідентифікований кортежем "
"``(frame, lineno)``:"

msgid "The canonical form of the filename which contains the frame."
msgstr "Канонічна форма імені файлу, який містить кадр."

msgid "The function name, or ``\"<lambda>\"``."
msgstr "Ім’я функції або ``\"<lambda>\"``."

msgid "The input arguments."
msgstr "Вхідні аргументи."

msgid "The return value."
msgstr "Повернене значення."

msgid "The line of code (if it exists)."
msgstr "Рядок коду (якщо він існує)."

msgid ""
"The following two methods can be called by clients to use a debugger to "
"debug a :term:`statement`, given as a string."
msgstr ""
"Наступні два методи можуть бути викликані клієнтами для використання "
"налагоджувача для налагодження :term:`statement`, поданого як рядок."

msgid ""
"Debug a statement executed via the :func:`exec` function.  *globals* "
"defaults to :attr:`__main__.__dict__`, *locals* defaults to *globals*."
msgstr ""
"Налагодити оператор, який виконується за допомогою функції :func:`exec`. "
"*globals* за замовчуванням :attr:`__main__.__dict__`, *locals* за "
"замовчуванням *globals*."

msgid ""
"Debug an expression executed via the :func:`eval` function.  *globals* and "
"*locals* have the same meaning as in :meth:`run`."
msgstr ""
"Налагодити вираз, що виконується за допомогою функції :func:`eval`. "
"*globals* і *locals* мають те саме значення, що й у :meth:`run`."

msgid "For backwards compatibility.  Calls the :meth:`run` method."
msgstr "Для зворотної сумісності. Викликає метод :meth:`run`."

msgid "Debug a single function call, and return its result."
msgstr "Налагодити один виклик функції та повернути його результат."

msgid "Finally, the module defines the following functions:"
msgstr "Нарешті, модуль визначає такі функції:"

msgid ""
"Check whether we should break here, depending on the way the breakpoint *b* "
"was set."
msgstr ""
"Перевірте, чи маємо ми розірвати тут, залежно від того, як була встановлена "
"точка зупину *b*."

msgid ""
"If it was set via line number, it checks if ``b.line`` is the same as the "
"one in the frame also passed as argument.  If the breakpoint was set via "
"function name, we have to check we are in the right frame (the right "
"function) and if we are in its first executable line."
msgstr ""
"Якщо його було встановлено через номер рядка, він перевіряє, чи ``b.line`` "
"збігається з тим, що у фреймі також передається як аргумент. Якщо точка "
"зупину була встановлена через назву функції, ми повинні перевірити, чи "
"знаходимося ми у правильному фреймі (правильній функції) і чи знаходимося ми "
"в її першому виконуваному рядку."

msgid ""
"Determine if there is an effective (active) breakpoint at this line of code. "
"Return a tuple of the breakpoint and a boolean that indicates if it is ok to "
"delete a temporary breakpoint.  Return ``(None, None)`` if there is no "
"matching breakpoint."
msgstr ""
"Визначте, чи є ефективна (активна) точка зупину в цьому рядку коду. Повертає "
"кортеж точки зупину та логічне значення, яке вказує, чи можна видалити "
"тимчасову точку зупину. Повертає ``(None, None)``, якщо немає відповідної "
"точки зупину."

msgid "Start debugging with a :class:`Bdb` instance from caller's frame."
msgstr "Почніть налагодження з екземпляра :class:`Bdb` із фрейму абонента."
