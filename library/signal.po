# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`signal` --- Set handlers for asynchronous events"
msgstr ":mod:`signal` --- Встановити обробники для асинхронних подій"

msgid "This module provides mechanisms to use signal handlers in Python."
msgstr ""
"Цей модуль надає механізми для використання обробників сигналів у Python."

msgid "General rules"
msgstr "Загальні правила"

msgid ""
"The :func:`signal.signal` function allows defining custom handlers to be "
"executed when a signal is received.  A small number of default handlers are "
"installed: :const:`SIGPIPE` is ignored (so write errors on pipes and sockets "
"can be reported as ordinary Python exceptions) and :const:`SIGINT` is "
"translated into a :exc:`KeyboardInterrupt` exception if the parent process "
"has not changed it."
msgstr ""
"Функція :func:`signal.signal` дозволяє визначати спеціальні обробники, які "
"будуть виконуватися під час отримання сигналу. Встановлено невелику "
"кількість обробників за замовчуванням: :const:`SIGPIPE` ігнорується (тому "
"про помилки запису в каналах і сокетах можна повідомляти як про звичайні "
"винятки Python), а :const:`SIGINT` перетворюється на :exc:"
"`KeyboardInterrupt` виняток, якщо батьківський процес не змінив його."

msgid ""
"A handler for a particular signal, once set, remains installed until it is "
"explicitly reset (Python emulates the BSD style interface regardless of the "
"underlying implementation), with the exception of the handler for :const:"
"`SIGCHLD`, which follows the underlying implementation."
msgstr ""
"Обробник для певного сигналу після встановлення залишається встановленим, "
"доки його явно не буде скинуто (Python емулює інтерфейс у стилі BSD "
"незалежно від базової реалізації), за винятком обробника для :const:"
"`SIGCHLD`, який слідує за базовою реалізацією. ."

msgid "Execution of Python signal handlers"
msgstr "Виконання обробників сигналів Python"

msgid ""
"A Python signal handler does not get executed inside the low-level (C) "
"signal handler.  Instead, the low-level signal handler sets a flag which "
"tells the :term:`virtual machine` to execute the corresponding Python signal "
"handler at a later point(for example at the next :term:`bytecode` "
"instruction). This has consequences:"
msgstr ""
"Обробник сигналу Python не виконується всередині обробника сигналу низького "
"рівня (C). Натомість обробник сигналу низького рівня встановлює прапорець, "
"який повідомляє :term:`virtual machine` виконати відповідний обробник "
"сигналу Python пізніше (наприклад, у наступній інструкції :term:`bytecode`). "
"Це має наслідки:"

msgid ""
"It makes little sense to catch synchronous errors like :const:`SIGFPE` or :"
"const:`SIGSEGV` that are caused by an invalid operation in C code.  Python "
"will return from the signal handler to the C code, which is likely to raise "
"the same signal again, causing Python to apparently hang.  From Python 3.3 "
"onwards, you can use the :mod:`faulthandler` module to report on synchronous "
"errors."
msgstr ""
"Немає сенсу виловлювати синхронні помилки, такі як :const:`SIGFPE` або :"
"const:`SIGSEGV`, які викликані недійсною операцією в коді C. Python "
"повернеться від обробника сигналів до коду C, який, імовірно, знову викличе "
"той самий сигнал, що, очевидно, призведе до зависання Python. Починаючи з "
"Python 3.3, ви можете використовувати модуль :mod:`faulthandler` для "
"звітування про синхронні помилки."

msgid ""
"A long-running calculation implemented purely in C (such as regular "
"expression matching on a large body of text) may run uninterrupted for an "
"arbitrary amount of time, regardless of any signals received.  The Python "
"signal handlers will be called when the calculation finishes."
msgstr ""
"Тривале обчислення, реалізоване виключно на C (наприклад, зіставлення "
"регулярного виразу з великою частиною тексту), може виконуватися безперервно "
"протягом довільного проміжку часу, незалежно від будь-яких отриманих "
"сигналів. Обробники сигналів Python будуть викликані, коли обчислення "
"завершиться."

msgid ""
"If the handler raises an exception, it will be raised \"out of thin air\" in "
"the main thread. See the :ref:`note below <handlers-and-exceptions>` for a "
"discussion."
msgstr ""
"Якщо обробник викликає виняткову ситуацію, вона буде викликана \"з повітря\" "
"в основному потоці. Перегляньте :ref:`примітку нижче <handlers-and-"
"exceptions>` для обговорення."

msgid "Signals and threads"
msgstr "Сигнали та нитки"

msgid ""
"Python signal handlers are always executed in the main Python thread of the "
"main interpreter, even if the signal was received in another thread.  This "
"means that signals can't be used as a means of inter-thread communication.  "
"You can use the synchronization primitives from the :mod:`threading` module "
"instead."
msgstr ""
"Обробники сигналів Python завжди виконуються в основному потоці Python "
"головного інтерпретатора, навіть якщо сигнал було отримано в іншому потоці. "
"Це означає, що сигнали не можна використовувати як засіб міжпотокового "
"зв'язку. Натомість ви можете використовувати примітиви синхронізації з "
"модуля :mod:`threading`."

msgid ""
"Besides, only the main thread of the main interpreter is allowed to set a "
"new signal handler."
msgstr ""
"Крім того, лише головному потоку головного інтерпретатора дозволено "
"встановлювати новий обробник сигналу."

msgid "Module contents"
msgstr "Зміст модуля"

msgid ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) and sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) related "
"constants listed below were turned into :class:`enums <enum.IntEnum>`. :func:"
"`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` and :func:`sigwait` "
"functions return human-readable :class:`enums <enum.IntEnum>`."
msgstr ""

msgid "The variables defined in the :mod:`signal` module are:"
msgstr "Змінні, визначені в модулі :mod:`signal`:"

msgid ""
"This is one of two standard signal handling options; it will simply perform "
"the default function for the signal.  For example, on most systems the "
"default action for :const:`SIGQUIT` is to dump core and exit, while the "
"default action for :const:`SIGCHLD` is to simply ignore it."
msgstr ""
"Це один із двох стандартних варіантів обробки сигналу; він просто "
"виконуватиме стандартну функцію для сигналу. Наприклад, у більшості систем "
"дія за замовчуванням для :const:`SIGQUIT` — це дамп ядра та вихід, а дія за "
"замовчуванням для :const:`SIGCHLD` — просто ігнорувати його."

msgid ""
"This is another standard signal handler, which will simply ignore the given "
"signal."
msgstr ""
"Це ще один стандартний обробник сигналу, який просто ігнорує поданий сигнал."

msgid "Abort signal from :manpage:`abort(3)`."
msgstr "Сигнал скасування з :manpage:`abort(3)`."

msgid "Timer signal from :manpage:`alarm(2)`."
msgstr "Сигнал таймера з :manpage:`alarm(2)`."

msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Наявність <availability>`: Unix."

msgid "Interrupt from keyboard (CTRL + BREAK)."
msgstr "Переривання з клавіатури (CTRL + BREAK)."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid "Bus error (bad memory access)."
msgstr "Помилка шини (поганий доступ до пам'яті)."

msgid "Child process stopped or terminated."
msgstr "Дочірній процес зупинено або припинено."

msgid "Alias to :data:`SIGCHLD`."
msgstr "Псевдонім :data:`SIGCHLD`."

msgid "Continue the process if it is currently stopped"
msgstr "Продовжуйте процес, якщо він зараз зупинений"

msgid "Floating-point exception. For example, division by zero."
msgstr "Виняток із плаваючою комою. Наприклад, ділення на нуль."

msgid ""
":exc:`ZeroDivisionError` is raised when the second argument of a division or "
"modulo operation is zero."
msgstr ""
":exc:`ZeroDivisionError` виникає, коли другий аргумент операції ділення або "
"модуля дорівнює нулю."

msgid ""
"Hangup detected on controlling terminal or death of controlling process."
msgstr ""
"Виявлено зависання на керуючому терміналі або смерть керуючого процесу."

msgid "Illegal instruction."
msgstr "Незаконна інструкція."

msgid "Interrupt from keyboard (CTRL + C)."
msgstr "Переривання з клавіатури (CTRL + C)."

msgid "Default action is to raise :exc:`KeyboardInterrupt`."
msgstr "Дія за замовчуванням — підняти :exc:`KeyboardInterrupt`."

msgid "Kill signal."
msgstr "Сигнал вбивства."

msgid "It cannot be caught, blocked, or ignored."
msgstr "Його неможливо зловити, заблокувати чи проігнорувати."

msgid "Broken pipe: write to pipe with no readers."
msgstr "Зламаний канал: записувати в канал без читачів."

msgid "Default action is to ignore the signal."
msgstr "Стандартна дія – ігнорувати сигнал."

msgid "Segmentation fault: invalid memory reference."
msgstr "Помилка сегментації: недійсне посилання на пам'ять."

msgid "Termination signal."
msgstr "Сигнал завершення."

msgid "User-defined signal 1."
msgstr "Визначений користувачем сигнал 1."

msgid "User-defined signal 2."
msgstr "Визначений користувачем сигнал 2."

msgid "Window resize signal."
msgstr "Сигнал зміни розміру вікна."

msgid ""
"All the signal numbers are defined symbolically.  For example, the hangup "
"signal is defined as :const:`signal.SIGHUP`; the variable names are "
"identical to the names used in C programs, as found in ``<signal.h>``.  The "
"Unix man page for ':c:func:`signal`' lists the existing signals (on some "
"systems this is :manpage:`signal(2)`, on others the list is in :manpage:"
"`signal(7)`). Note that not all systems define the same set of signal names; "
"only those names defined by the system are defined by this module."
msgstr ""
"Усі сигнальні числа визначені символічно. Наприклад, сигнал зависання "
"визначається як :const:`signal.SIGHUP`; імена змінних ідентичні іменам, які "
"використовуються в програмах на C, як це знайдено в ``<signal.h>``. Сторінка "
"довідки Unix для ':c:func:`signal`' містить список існуючих сигналів (у "
"деяких системах це :manpage:`signal(2)`, в інших список знаходиться в :"
"manpage:`signal(7)` ). Зауважте, що не всі системи визначають однаковий "
"набір назв сигналів; тільки ті імена, які визначені системою, визначаються "
"цим модулем."

msgid ""
"The signal corresponding to the :kbd:`Ctrl+C` keystroke event. This signal "
"can only be used with :func:`os.kill`."
msgstr ""
"Сигнал, що відповідає події натискання клавіші :kbd:`Ctrl+C`. Цей сигнал "
"можна використовувати лише з :func:`os.kill`."

msgid ""
"The signal corresponding to the :kbd:`Ctrl+Break` keystroke event. This "
"signal can only be used with :func:`os.kill`."
msgstr ""
"Сигнал, що відповідає події натискання клавіші :kbd:`Ctrl+Break`. Цей сигнал "
"можна використовувати лише з :func:`os.kill`."

msgid "One more than the number of the highest signal number."
msgstr ""

msgid ""
"Decrements interval timer in real time, and delivers :const:`SIGALRM` upon "
"expiration."
msgstr ""
"Зменшує інтервальний таймер у реальному часі та доставляє :const:`SIGALRM` "
"після закінчення терміну дії."

msgid ""
"Decrements interval timer only when the process is executing, and delivers "
"SIGVTALRM upon expiration."
msgstr ""
"Зменшує інтервальний таймер, лише коли процес виконується, і доставляє "
"SIGVTALRM після закінчення терміну дії."

msgid ""
"Decrements interval timer both when the process executes and when the system "
"is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this "
"timer is usually used to profile the time spent by the application in user "
"and kernel space. SIGPROF is delivered upon expiration."
msgstr ""
"Зменшує інтервальний таймер як під час виконання процесу, так і коли система "
"виконується від імені процесу. У поєднанні з ITIMER_VIRTUAL цей таймер "
"зазвичай використовується для профілювання часу, проведеного програмою в "
"просторі користувача та ядра. SIGPROF доставляється після закінчення терміну "
"дії."

msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be blocked."
msgstr ""
"Можливе значення для параметра *how* для :func:`pthread_sigmask`, яке "
"вказує, що сигнали мають бути заблоковані."

msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be unblocked."
msgstr ""
"Можливе значення для параметра *how* для :func:`pthread_sigmask`, яке "
"вказує, що сигнали мають бути розблоковані."

msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that the signal mask is to be replaced."
msgstr ""
"Можливе значення для параметра *how* для :func:`pthread_sigmask`, яке "
"вказує, що маску сигналу потрібно замінити."

msgid "The :mod:`signal` module defines one exception:"
msgstr "Модуль :mod:`signal` визначає один виняток:"

msgid ""
"Raised to signal an error from the underlying :func:`setitimer` or :func:"
"`getitimer` implementation. Expect this error if an invalid interval timer "
"or a negative time is passed to :func:`setitimer`. This error is a subtype "
"of :exc:`OSError`."
msgstr ""
"Викликається, щоб повідомити про помилку базової реалізації :func:"
"`setitimer` або :func:`getitimer`. Очікуйте цю помилку, якщо в :func:"
"`setitimer` передано недійсний таймер інтервалу або від’ємний час. Ця "
"помилка є підтипом :exc:`OSError`."

msgid ""
"This error used to be a subtype of :exc:`IOError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Раніше ця помилка була підтипом :exc:`IOError`, який тепер є псевдонімом :"
"exc:`OSError`."

msgid "The :mod:`signal` module defines the following functions:"
msgstr "Модуль :mod:`signal` визначає такі функції:"

msgid ""
"If *time* is non-zero, this function requests that a :const:`SIGALRM` signal "
"be sent to the process in *time* seconds. Any previously scheduled alarm is "
"canceled (only one alarm can be scheduled at any time).  The returned value "
"is then the number of seconds before any previously set alarm was to have "
"been delivered. If *time* is zero, no alarm is scheduled, and any scheduled "
"alarm is canceled.  If the return value is zero, no alarm is currently "
"scheduled."
msgstr ""
"Якщо *time* не нуль, ця функція запитує, щоб сигнал :const:`SIGALRM` був "
"надісланий процесу через *time* секунди. Будь-який раніше запланований "
"будильник скасовується (одночасно можна запланувати лише один будильник). "
"Повернене значення – це кількість секунд до того, як будь-який попередньо "
"встановлений сигнал буде доставлено. Якщо *time* дорівнює нулю, будильник не "
"заплановано, а будь-який запланований будильник скасовується. Якщо повернене "
"значення дорівнює нулю, нагадування наразі не заплановано."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`alarm(2)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`alarm(2)` для отримання додаткової інформації."

msgid ""
"Return the current signal handler for the signal *signalnum*. The returned "
"value may be a callable Python object, or one of the special values :const:"
"`signal.SIG_IGN`, :const:`signal.SIG_DFL` or :const:`None`.  Here, :const:"
"`signal.SIG_IGN` means that the signal was previously ignored, :const:"
"`signal.SIG_DFL` means that the default way of handling the signal was "
"previously in use, and ``None`` means that the previous signal handler was "
"not installed from Python."
msgstr ""
"Повертає поточний обробник сигналу для сигналу *signalnum*. Поверненим "
"значенням може бути об’єкт Python, який можна викликати, або одне зі "
"спеціальних значень :const:`signal.SIG_IGN`, :const:`signal.SIG_DFL` або :"
"const:`None`. Тут :const:`signal.SIG_IGN` означає, що сигнал раніше "
"ігнорувався, :const:`signal.SIG_DFL` означає, що стандартний спосіб обробки "
"сигналу використовувався раніше, а ``None`` означає, що попередній обробник "
"сигналів не було встановлено з Python."

msgid ""
"Return the system description of the signal *signalnum*, such as "
"\"Interrupt\", \"Segmentation fault\", etc. Returns :const:`None` if the "
"signal is not recognized."
msgstr ""
"Повертає системний опис сигналу *signalnum*, наприклад \"Interrupt\", "
"\"Segmentation fault\" тощо. Повертає :const:`None`, якщо сигнал не "
"розпізнано."

msgid ""
"Return the set of valid signal numbers on this platform.  This can be less "
"than ``range(1, NSIG)`` if some signals are reserved by the system for "
"internal use."
msgstr ""
"Повернути набір дійсних номерів сигналу на цій платформі. Це може бути менше "
"ніж діапазон (1, NSIG) якщо деякі сигнали зарезервовані системою для "
"внутрішнього використання."

msgid ""
"Cause the process to sleep until a signal is received; the appropriate "
"handler will then be called.  Returns nothing."
msgstr ""
"Перевести процес у режим сну, доки не буде отримано сигнал; потім буде "
"викликано відповідний обробник. Нічого не повертає."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`signal(2)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте довідкову сторінку :"
"manpage:`signal(2)` для отримання додаткової інформації."

msgid ""
"See also :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` and :"
"func:`sigpending`."
msgstr ""
"Дивіться також :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` і :"
"func:`sigpending`."

msgid "Sends a signal to the calling process. Returns nothing."
msgstr "Надсилає сигнал процесу виклику. Нічого не повертає."

msgid ""
"Send signal *sig* to the process referred to by file descriptor *pidfd*. "
"Python does not currently support the *siginfo* parameter; it must be "
"``None``.  The *flags* argument is provided for future extensions; no flag "
"values are currently defined."
msgstr ""
"Надішліть сигнал *sig* до процесу, на який посилається дескриптор файлу "
"*pidfd*. Python наразі не підтримує параметр *siginfo*; це має бути "
"``None``. Аргумент *flags* надається для майбутніх розширень; значення "
"прапорів наразі не визначено."

msgid "See the :manpage:`pidfd_send_signal(2)` man page for more information."
msgstr ""
"Перегляньте довідкову сторінку :manpage:`pidfd_send_signal(2)` для отримання "
"додаткової інформації."

msgid ":ref:`Availability <availability>`: Linux 5.1+"
msgstr ":ref:`Наявність <availability>`: Linux 5.1+"

msgid ""
"Send the signal *signalnum* to the thread *thread_id*, another thread in the "
"same process as the caller.  The target thread can be executing any code "
"(Python or not).  However, if the target thread is executing the Python "
"interpreter, the Python signal handlers will be :ref:`executed by the main "
"thread of the main interpreter <signals-and-threads>`.  Therefore, the only "
"point of sending a signal to a particular Python thread would be to force a "
"running system call to fail with :exc:`InterruptedError`."
msgstr ""
"Надішліть сигнал *signalnum* до потоку *thread_id*, іншого потоку в тому "
"самому процесі, що й абонент. Цільовий потік може виконувати будь-який код "
"(Python чи ні). Однак, якщо цільовий потік виконує інтерпретатор Python, "
"обробники сигналів Python будуть :ref:`виконуватися головним потоком "
"основного інтерпретатора <signals-and-threads>`. Таким чином, єдиним пунктом "
"надсилання сигналу до певного потоку Python було б примусово завершити "
"запущений системний виклик з :exc:`InterruptedError`."

msgid ""
"Use :func:`threading.get_ident()` or the :attr:`~threading.Thread.ident` "
"attribute of :class:`threading.Thread` objects to get a suitable value for "
"*thread_id*."
msgstr ""
"Використовуйте :func:`threading.get_ident()` або атрибут :attr:`~threading."
"Thread.ident` об’єктів :class:`threading.Thread`, щоб отримати відповідне "
"значення для *thread_id*."

msgid ""
"If *signalnum* is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check if the target thread is still running."
msgstr ""
"Якщо *signalnum* дорівнює 0, тоді сигнал не надсилається, але перевірка "
"помилок все одно виконується; це можна використовувати, щоб перевірити, чи "
"цільовий потік все ще працює."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``signal.pthread_kill`` with "
"arguments ``thread_id``, ``signalnum``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``signal.pthread_kill`` з "
"аргументами ``thread_id``, ``signalnum``."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`pthread_kill(3)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`pthread_kill(3)` для отримання додаткової інформації."

msgid "See also :func:`os.kill`."
msgstr "Дивіться також :func:`os.kill`."

msgid ""
"Fetch and/or change the signal mask of the calling thread.  The signal mask "
"is the set of signals whose delivery is currently blocked for the caller. "
"Return the old signal mask as a set of signals."
msgstr ""
"Отримати та/або змінити маску сигналу викликаючого потоку. Маска сигналу - "
"це набір сигналів, доставка яких на даний момент заблокована для абонента. "
"Повернути стару сигнальну маску як набір сигналів."

msgid ""
"The behavior of the call is dependent on the value of *how*, as follows."
msgstr "Поведінка виклику залежить від значення *how*, як показано нижче."

msgid ""
":data:`SIG_BLOCK`: The set of blocked signals is the union of the current "
"set and the *mask* argument."
msgstr ""
":data:`SIG_BLOCK`: Набір заблокованих сигналів є об’єднанням поточного "
"набору та аргументу *mask*."

msgid ""
":data:`SIG_UNBLOCK`: The signals in *mask* are removed from the current set "
"of blocked signals.  It is permissible to attempt to unblock a signal which "
"is not blocked."
msgstr ""
":data:`SIG_UNBLOCK`: Сигнали в *mask* видаляються з поточного набору "
"заблокованих сигналів. Дозволено спробувати розблокувати сигнал, який не "
"заблоковано."

msgid ""
":data:`SIG_SETMASK`: The set of blocked signals is set to the *mask* "
"argument."
msgstr ""
":data:`SIG_SETMASK`: Набір заблокованих сигналів встановлюється на аргумент "
"*mask*."

msgid ""
"*mask* is a set of signal numbers (e.g. {:const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`}). Use :func:`~signal.valid_signals` for a full mask "
"including all signals."
msgstr ""
"*mask* — це набір номерів сигналів (наприклад, {:const:`signal.SIGINT`, :"
"const:`signal.SIGTERM`}). Використовуйте :func:`~signal.valid_signals` для "
"повної маски, включаючи всі сигнали."

msgid ""
"For example, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` reads the "
"signal mask of the calling thread."
msgstr ""
"Наприклад, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` читає маску "
"сигналу викликаючого потоку."

msgid ":data:`SIGKILL` and :data:`SIGSTOP` cannot be blocked."
msgstr ":data:`SIGKILL` і :data:`SIGSTOP` не можна заблокувати."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigprocmask(2)` and :manpage:`pthread_sigmask(3)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`sigprocmask(2)` і :manpage:`pthread_sigmask(3)` для отримання додаткової "
"інформації."

msgid "See also :func:`pause`, :func:`sigpending` and :func:`sigwait`."
msgstr "Дивіться також :func:`pause`, :func:`sigpending` і :func:`sigwait`."

msgid ""
"Sets given interval timer (one of :const:`signal.ITIMER_REAL`, :const:"
"`signal.ITIMER_VIRTUAL` or :const:`signal.ITIMER_PROF`) specified by *which* "
"to fire after *seconds* (float is accepted, different from :func:`alarm`) "
"and after that every *interval* seconds (if *interval* is non-zero). The "
"interval timer specified by *which* can be cleared by setting *seconds* to "
"zero."
msgstr ""
"Встановлює заданий інтервальний таймер (один із :const:`signal."
"ITIMER_REAL`, :const:`signal.ITIMER_VIRTUAL` або :const:`signal."
"ITIMER_PROF`), визначений *який* запускати через *секунд* (дозволено число, "
"відмінний від :func:`alarm`) і після цього кожні *інтервал* секунд (якщо "
"*інтервал* відмінний від нуля). Інтервальний таймер, визначений *яким*, "
"можна скинути, встановивши *секунд* на нуль."

msgid ""
"When an interval timer fires, a signal is sent to the process. The signal "
"sent is dependent on the timer being used; :const:`signal.ITIMER_REAL` will "
"deliver :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` sends :const:"
"`SIGVTALRM`, and :const:`signal.ITIMER_PROF` will deliver :const:`SIGPROF`."
msgstr ""
"Коли спрацьовує інтервальний таймер, процесу надсилається сигнал. Надісланий "
"сигнал залежить від таймера, який використовується; :const:`signal."
"ITIMER_REAL` доставить :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` "
"надішле :const:`SIGVTALRM`, а :const:`signal.ITIMER_PROF` доставить :const:"
"`SIGPROF` ."

msgid "The old values are returned as a tuple: (delay, interval)."
msgstr "Старі значення повертаються як кортеж: (затримка, інтервал)."

msgid ""
"Attempting to pass an invalid interval timer will cause an :exc:"
"`ItimerError`."
msgstr ""
"Спроба передати недійсний таймер інтервалу спричинить :exc:`ItimerError`."

msgid "Returns current value of a given interval timer specified by *which*."
msgstr ""
"Повертає поточне значення заданого інтервального таймера, визначеного "
"*which*."

msgid ""
"Set the wakeup file descriptor to *fd*.  When a signal is received, the "
"signal number is written as a single byte into the fd.  This can be used by "
"a library to wakeup a poll or select call, allowing the signal to be fully "
"processed."
msgstr ""
"Встановіть дескриптор файлу пробудження на *fd*. Коли сигнал отримано, номер "
"сигналу записується як один байт у fd. Це може бути використано бібліотекою "
"для пробудження опитування або виклику вибору, дозволяючи повністю обробити "
"сигнал."

msgid ""
"The old wakeup fd is returned (or -1 if file descriptor wakeup was not "
"enabled).  If *fd* is -1, file descriptor wakeup is disabled. If not -1, "
"*fd* must be non-blocking.  It is up to the library to remove any bytes from "
"*fd* before calling poll or select again."
msgstr ""
"Повертається старий fd пробудження (або -1, якщо пробудження дескриптора "
"файлу не було ввімкнено). Якщо *fd* дорівнює -1, пробудження дескриптора "
"файлу вимкнено. Якщо не -1, *fd* має бути неблокуючим. Бібліотека має "
"видалити будь-які байти з *fd* перед повторним викликом опитування або "
"вибору."

msgid ""
"When threads are enabled, this function can only be called from :ref:`the "
"main thread of the main interpreter <signals-and-threads>`; attempting to "
"call it from other threads will cause a :exc:`ValueError` exception to be "
"raised."
msgstr ""
"Коли потоки ввімкнено, цю функцію можна викликати лише з :ref:`основного "
"потоку головного інтерпретатора <signals-and-threads>`; спроба викликати "
"його з інших потоків призведе до виникнення винятку :exc:`ValueError`."

msgid ""
"There are two common ways to use this function. In both approaches, you use "
"the fd to wake up when a signal arrives, but then they differ in how they "
"determine *which* signal or signals have arrived."
msgstr ""
"Існує два поширених способи використання цієї функції. В обох підходах ви "
"використовуєте fd для пробудження, коли надходить сигнал, але вони "
"відрізняються тим, як вони визначають, *який* сигнал або сигнали надійшли."

msgid ""
"In the first approach, we read the data out of the fd's buffer, and the byte "
"values give you the signal numbers. This is simple, but in rare cases it can "
"run into a problem: generally the fd will have a limited amount of buffer "
"space, and if too many signals arrive too quickly, then the buffer may "
"become full, and some signals may be lost. If you use this approach, then "
"you should set ``warn_on_full_buffer=True``, which will at least cause a "
"warning to be printed to stderr when signals are lost."
msgstr ""
"У першому підході ми зчитуємо дані з буфера fd, а значення байтів дають вам "
"номери сигналів. Це просто, але в рідкісних випадках може виникнути "
"проблема: зазвичай fd матиме обмежений обсяг буферного простору, і якщо "
"забагато сигналів надходить надто швидко, буфер може переповнитися, а деякі "
"сигнали можуть бути втрачені. Якщо ви використовуєте цей підхід, то вам слід "
"встановити ``warn_on_full_buffer=True``, що принаймні призведе до друку "
"попередження в stderr у разі втрати сигналів."

msgid ""
"In the second approach, we use the wakeup fd *only* for wakeups, and ignore "
"the actual byte values. In this case, all we care about is whether the fd's "
"buffer is empty or non-empty; a full buffer doesn't indicate a problem at "
"all. If you use this approach, then you should set "
"``warn_on_full_buffer=False``, so that your users are not confused by "
"spurious warning messages."
msgstr ""
"У другому підході ми використовуємо fd пробудження *лише* для пробудження та "
"ігноруємо фактичні значення байтів. У цьому випадку все, що нас хвилює, це "
"чи є буфер fd порожнім чи непорожнім; заповнений буфер взагалі не вказує на "
"проблему. Якщо ви використовуєте цей підхід, вам слід встановити "
"``warn_on_full_buffer=False``, щоб ваші користувачі не були збентежені "
"фальшивими попередженнями."

msgid "On Windows, the function now also supports socket handles."
msgstr "У Windows функція тепер також підтримує ручки сокетів."

msgid "Added ``warn_on_full_buffer`` parameter."
msgstr "Додано параметр ``warn_on_full_buffer``."

msgid ""
"Change system call restart behaviour: if *flag* is :const:`False`, system "
"calls will be restarted when interrupted by signal *signalnum*, otherwise "
"system calls will be interrupted.  Returns nothing."
msgstr ""
"Змінити поведінку перезапуску системного виклику: якщо *flag* має значення :"
"const:`False`, системні виклики буде перезапущено, коли їх перериватиме "
"сигнал *signalnum*, інакше системні виклики буде перервано. Нічого не "
"повертає."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`siginterrupt(3)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`signinterrupt(3)` для отримання додаткової інформації."

msgid ""
"Note that installing a signal handler with :func:`signal` will reset the "
"restart behaviour to interruptible by implicitly calling :c:func:"
"`siginterrupt` with a true *flag* value for the given signal."
msgstr ""
"Зауважте, що встановлення обробника сигналів із :func:`signal` скине "
"поведінку перезапуску до переривання шляхом неявного виклику :c:func:"
"`siginterrupt` із справжнім значенням *flag* для даного сигналу."

msgid ""
"Set the handler for signal *signalnum* to the function *handler*.  *handler* "
"can be a callable Python object taking two arguments (see below), or one of "
"the special values :const:`signal.SIG_IGN` or :const:`signal.SIG_DFL`.  The "
"previous signal handler will be returned (see the description of :func:"
"`getsignal` above).  (See the Unix man page :manpage:`signal(2)` for further "
"information.)"
msgstr ""
"Встановіть обробник для сигналу *signalnum* на функцію *handler*. *обробник* "
"може бути викликаним об’єктом Python, який приймає два аргументи (див. "
"нижче) або одне зі спеціальних значень :const:`signal.SIG_IGN` або :const:"
"`signal.SIG_DFL`. Буде повернено попередній обробник сигналу (див. опис :"
"func:`getsignal` вище). (Див. сторінку довідки Unix :manpage:`signal(2)` для "
"отримання додаткової інформації.)"

msgid ""
"The *handler* is called with two arguments: the signal number and the "
"current stack frame (``None`` or a frame object; for a description of frame "
"objects, see the :ref:`description in the type hierarchy <frame-objects>` or "
"see the attribute descriptions in the :mod:`inspect` module)."
msgstr ""
"*Обробник* викликається з двома аргументами: номером сигналу та поточним "
"фреймом стека (``None`` або об’єкт фрейму; для опису об’єктів фрейму див. :"
"ref:`опис в ієрархії типів <frame-objects>` або див. описи атрибутів у "
"модулі :mod:`inspect`)."

msgid ""
"On Windows, :func:`signal` can only be called with :const:`SIGABRT`, :const:"
"`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:"
"`SIGTERM`, or :const:`SIGBREAK`. A :exc:`ValueError` will be raised in any "
"other case. Note that not all systems define the same set of signal names; "
"an :exc:`AttributeError` will be raised if a signal name is not defined as "
"``SIG*`` module level constant."
msgstr ""
"У Windows :func:`signal` можна викликати лише за допомогою :const:"
"`SIGABRT`, :const:`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:"
"`SIGSEGV`,  :const:`SIGTERM` або :const:`SIGBREAK`. Помилка :exc:"
"`ValueError` буде викликана в будь-якому іншому випадку. Зауважте, що не всі "
"системи визначають однаковий набір назв сигналів; :exc:`AttributeError` буде "
"викликано, якщо назва сигналу не визначена як константа рівня модуля "
"``SIG*``."

msgid ""
"Examine the set of signals that are pending for delivery to the calling "
"thread (i.e., the signals which have been raised while blocked).  Return the "
"set of the pending signals."
msgstr ""
"Перевірте набір сигналів, які очікують на доставку до викликаючого потоку "
"(тобто сигнали, які були підняті під час блокування). Повертає набір "
"незавершених сигналів."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigpending(2)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`sigpending(2)` для отримання додаткової інформації."

msgid "See also :func:`pause`, :func:`pthread_sigmask` and :func:`sigwait`."
msgstr ""
"Дивіться також :func:`pause`, :func:`pthread_sigmask` і :func:`sigwait`."

msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal (removes it from the pending list of signals), and returns the signal "
"number."
msgstr ""
"Призупинити виконання викликаючого потоку до доставки одного із сигналів, "
"указаних у наборі сигналів *sigset*. Функція приймає сигнал (видаляє його зі "
"списку очікуваних сигналів) і повертає номер сигналу."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigwait(3)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`sigwait(3)` для отримання додаткової інформації."

msgid ""
"See also :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo` and :func:`sigtimedwait`."
msgstr ""
"Дивіться також :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :"
"func:`sigwaitinfo` і :func:`sigtimedwait`."

msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal and removes it from the pending list of signals. If one of the "
"signals in *sigset* is already pending for the calling thread, the function "
"will return immediately with information about that signal. The signal "
"handler is not called for the delivered signal. The function raises an :exc:"
"`InterruptedError` if it is interrupted by a signal that is not in *sigset*."
msgstr ""
"Призупинити виконання викликаючого потоку до доставки одного із сигналів, "
"указаних у наборі сигналів *sigset*. Функція приймає сигнал і видаляє його "
"зі списку очікуваних сигналів. Якщо один із сигналів у *sigset* вже очікує "
"на виклик потоку, функція негайно повернеться з інформацією про цей сигнал. "
"Обробник сигналу не викликається для надісланого сигналу. Функція викликає :"
"exc:`InterruptedError`, якщо її перериває сигнал, якого немає в *sigset*."

msgid ""
"The return value is an object representing the data contained in the :c:type:"
"`siginfo_t` structure, namely: :attr:`si_signo`, :attr:`si_code`, :attr:"
"`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."
msgstr ""
"Повернене значення — це об’єкт, який представляє дані, що містяться в "
"структурі :c:type:`siginfo_t`, а саме: :attr:`si_signo`, :attr:`si_code`, :"
"attr:`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigwaitinfo(2)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`sigwaitinfo(2)` для отримання додаткової інформації."

msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigtimedwait`."
msgstr "Дивіться також :func:`pause`, :func:`sigwait` і :func:`sigtimedwait`."

msgid ""
"The function is now retried if interrupted by a signal not in *sigset* and "
"the signal handler does not raise an exception (see :pep:`475` for the "
"rationale)."
msgstr ""
"Тепер функція виконується повторно, якщо її перериває сигнал не в *sigset*, "
"і обробник сигналу не викликає винятку (див. :pep:`475` для обґрунтування)."

msgid ""
"Like :func:`sigwaitinfo`, but takes an additional *timeout* argument "
"specifying a timeout. If *timeout* is specified as :const:`0`, a poll is "
"performed. Returns :const:`None` if a timeout occurs."
msgstr ""
"Подібно до :func:`sigwaitinfo`, але приймає додатковий аргумент *timeout*, "
"який визначає час очікування. Якщо *timeout* указано як :const:`0`, "
"виконується опитування. Повертає :const:`None`, якщо час очікування вийшов."

msgid ""
":ref:`Availability <availability>`: Unix.  See the man page :manpage:"
"`sigtimedwait(2)` for further information."
msgstr ""
":ref:`Наявність <availability>`: Unix. Перегляньте сторінку довідки :manpage:"
"`sigtimedwait(2)` для отримання додаткової інформації."

msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigwaitinfo`."
msgstr "Дивіться також :func:`pause`, :func:`sigwait` і :func:`sigwaitinfo`."

msgid ""
"The function is now retried with the recomputed *timeout* if interrupted by "
"a signal not in *sigset* and the signal handler does not raise an exception "
"(see :pep:`475` for the rationale)."
msgstr ""
"Тепер функція виконується повторно з повторно обчисленим *тайм-аутом*, якщо "
"її перериває сигнал не в *sigset*, і обробник сигналу не викликає виняткової "
"ситуації (див. :pep:`475` для обґрунтування)."

msgid "Example"
msgstr "приклад"

msgid ""
"Here is a minimal example program. It uses the :func:`alarm` function to "
"limit the time spent waiting to open a file; this is useful if the file is "
"for a serial device that may not be turned on, which would normally cause "
"the :func:`os.open` to hang indefinitely.  The solution is to set a 5-second "
"alarm before opening the file; if the operation takes too long, the alarm "
"signal will be sent, and the handler raises an exception. ::"
msgstr ""
"Ось мінімальний приклад програми. Він використовує функцію :func:`alarm` для "
"обмеження часу очікування відкриття файлу; це корисно, якщо файл призначений "
"для послідовного пристрою, який може бути не ввімкнено, що зазвичай призведе "
"до зависання :func:`os.open` на невизначений час. Рішення полягає в тому, "
"щоб встановити 5-секундний будильник перед відкриттям файлу; якщо операція "
"триває надто довго, буде надіслано сигнал тривоги, і обробник викличе "
"виняток. ::"

msgid "Note on SIGPIPE"
msgstr "Примітка щодо SIGPIPE"

msgid ""
"Piping output of your program to tools like :manpage:`head(1)` will cause a :"
"const:`SIGPIPE` signal to be sent to your process when the receiver of its "
"standard output closes early.  This results in an exception like :code:"
"`BrokenPipeError: [Errno 32] Broken pipe`.  To handle this case, wrap your "
"entry point to catch this exception as follows::"
msgstr ""
"Передача виводу вашої програми до таких інструментів, як :manpage:`head(1)`, "
"призведе до надсилання сигналу :const:`SIGPIPE` до вашого процесу, коли "
"отримувач його стандартного виводу закривається раніше. Це призводить до "
"виключення на зразок :code:`BrokenPipeError: [Errno 32] Broken pipe`. Щоб "
"впоратися з цим випадком, оберніть свою точку входу, щоб перехопити цю "
"виняток, наступним чином:"

msgid ""
"Do not set :const:`SIGPIPE`'s disposition to :const:`SIG_DFL` in order to "
"avoid :exc:`BrokenPipeError`.  Doing that would cause your program to exit "
"unexpectedly whenever any socket connection is interrupted while your "
"program is still writing to it."
msgstr ""
"Не встановлюйте розташування :const:`SIGPIPE` як :const:`SIG_DFL`, щоб "
"уникнути :exc:`BrokenPipeError`. Це спричинило б несподіваний вихід вашої "
"програми щоразу, коли будь-яке з’єднання з сокетом переривається, поки ваша "
"програма все ще записує в нього."

msgid "Note on Signal Handlers and Exceptions"
msgstr "Примітка щодо обробників сигналів і винятків"

msgid ""
"If a signal handler raises an exception, the exception will be propagated to "
"the main thread and may be raised after any :term:`bytecode` instruction. "
"Most notably, a :exc:`KeyboardInterrupt` may appear at any point during "
"execution. Most Python code, including the standard library, cannot be made "
"robust against this, and so a :exc:`KeyboardInterrupt` (or any other "
"exception resulting from a signal handler) may on rare occasions put the "
"program in an unexpected state."
msgstr ""
"Якщо обробник сигналу викликає виняток, виняток буде передано в основний "
"потік і може бути викликано після будь-якої інструкції :term:`bytecode`. "
"Зокрема, :exc:`KeyboardInterrupt` може з’явитися в будь-який момент під час "
"виконання. Більшість коду Python, включаючи стандартну бібліотеку, не можна "
"зробити стійкими до цього, і тому :exc:`KeyboardInterrupt` (або будь-який "
"інший виняток, що є результатом обробки сигналу) може в рідкісних випадках "
"переводити програму в неочікуваний стан."

msgid "To illustrate this issue, consider the following code::"
msgstr "Щоб проілюструвати цю проблему, розглянемо такий код:"

msgid ""
"For many programs, especially those that merely want to exit on :exc:"
"`KeyboardInterrupt`, this is not a problem, but applications that are "
"complex or require high reliability should avoid raising exceptions from "
"signal handlers. They should also avoid catching :exc:`KeyboardInterrupt` as "
"a means of gracefully shutting down.  Instead, they should install their "
"own :const:`SIGINT` handler. Below is an example of an HTTP server that "
"avoids :exc:`KeyboardInterrupt`::"
msgstr ""
"Для багатьох програм, особливо тих, які просто хочуть завершити роботу "
"після :exc:`KeyboardInterrupt`, це не є проблемою, але програми, які є "
"складними або потребують високої надійності, повинні уникати виклику "
"винятків від обробників сигналів. Вони також повинні уникати перехоплення :"
"exc:`KeyboardInterrupt` як засобу плавного завершення роботи. Натомість вони "
"повинні встановити власний обробник :const:`SIGINT`. Нижче наведено приклад "
"HTTP-сервера, який уникає :exc:`KeyboardInterrupt`::"
