# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:09+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`logging` --- Logging facility for Python"
msgstr ":mod:`logging` --- Можливість журналювання для Python"

msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**Вихідний код:** :source:`Lib/logging/__init__.py`"

msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr ""
"Ця сторінка містить довідкову інформацію про API. Інформацію про підручники "
"та обговорення більш складних тем див"

msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Основний посібник <logging-basic-tutorial>`"

msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Розширений посібник <logging-advanced-tutorial>`"

msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Кулінарна книга журналювання <logging-cookbook>`"

msgid ""
"This module defines functions and classes which implement a flexible event "
"logging system for applications and libraries."
msgstr ""
"Цей модуль визначає функції та класи, які реалізують гнучку систему "
"реєстрації подій для програм і бібліотек."

msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages from "
"third-party modules."
msgstr ""
"Ключовою перевагою використання API журналювання, що надається стандартним "
"бібліотечним модулем, є те, що всі модулі Python можуть брати участь у "
"журналюванні, тому ваш журнал програми може містити ваші власні "
"повідомлення, інтегровані з повідомленнями від сторонніх модулів."

msgid "The simplest example:"
msgstr "Найпростіший приклад:"

msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to view the "
"tutorials (**see the links above and on the right**)."
msgstr ""
"Модуль забезпечує багато функціональних можливостей і гнучкості. Якщо ви не "
"знайомі з веденням журналів, найкращий спосіб зрозуміти це — переглянути "
"навчальні посібники (**перегляньте посилання вище та праворуч**)."

msgid ""
"The basic classes defined by the module, together with their functions, are "
"listed below."
msgstr ""
"Основні класи, визначені модулем, разом із їхніми функціями перераховані "
"нижче."

msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"Логери відкривають інтерфейс, який безпосередньо використовує код програми."

msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"Обробники надсилають записи журналу (створені реєстраторами) у відповідне "
"місце призначення."

msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"Фільтри забезпечують точніші засоби для визначення того, які записи журналу "
"виводити."

msgid "Formatters specify the layout of log records in the final output."
msgstr ""
"Засоби форматування вказують макет записів журналу в кінцевому виведенні."

msgid "Logger Objects"
msgstr "Логер об'єктів"

msgid ""
"Loggers have the following attributes and methods.  Note that Loggers should "
"*NEVER* be instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to :func:`getLogger` "
"with the same name will always return a reference to the same Logger object."
msgstr ""
"Реєстратори мають такі атрибути та методи. Зауважте, що Логери *НІКОЛИ* не "
"повинні створюватися безпосередньо, а завжди через функцію рівня модуля "
"``logging.getLogger(name)``. Кілька викликів :func:`getLogger` з однаковою "
"назвою завжди повертатимуть посилання на той самий об’єкт Logger."

msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for example). "
"Loggers that are further down in the hierarchical list are children of "
"loggers higher up in the list.  For example, given a logger with a name of "
"``foo``, loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` "
"are all descendants of ``foo``.  The logger name hierarchy is analogous to "
"the Python package hierarchy, and identical to it if you organise your "
"loggers on a per-module basis using the recommended construction ``logging."
"getLogger(__name__)``.  That's because in a module, ``__name__`` is the "
"module's name in the Python package namespace."
msgstr ""
"``name`` потенційно є ієрархічним значенням, розділеним крапкою, наприклад "
"``foo.bar.baz`` (хоча це також може бути просто ``foo``, наприклад). "
"Реєстратори, розташовані нижче в ієрархічному списку, є нащадками "
"реєстраторів, розташованих вище в списку. Наприклад, якщо задано реєстратор "
"із іменем ``foo``, усі реєстратори з іменами ``foo.bar``, ``foo.bar.baz`` і "
"``foo.bam`` є нащадками ``фу``. Ієрархія імен реєстратора аналогічна "
"ієрархії пакетів Python і ідентична їй, якщо ви організовуєте свої "
"реєстратори на основі кожного модуля за допомогою рекомендованої конструкції "
"``logging.getLogger(__name__)``. Це тому, що в модулі ``__name__`` є назвою "
"модуля в просторі імен пакета Python."

msgid ""
"If this attribute evaluates to true, events logged to this logger will be "
"passed to the handlers of higher level (ancestor) loggers, in addition to "
"any handlers attached to this logger. Messages are passed directly to the "
"ancestor loggers' handlers - neither the level nor filters of the ancestor "
"loggers in question are considered."
msgstr ""
"Якщо цей атрибут оцінюється як істина, події, зареєстровані в цьому "
"реєстраторі, будуть передані обробникам реєстраторів вищого рівня (предків), "
"на додаток до будь-яких обробників, приєднаних до цього реєстратора. "
"Повідомлення передаються безпосередньо до обробників попередніх реєстраторів "
"- ні рівень, ні фільтри попередніх реєстраторів, про які йдеться."

msgid ""
"If this evaluates to false, logging messages are not passed to the handlers "
"of ancestor loggers."
msgstr ""
"Якщо це значення має значення false, повідомлення журналу не передаються до "
"обробників попередніх реєстраторів."

msgid ""
"Spelling it out with an example: If the propagate attribute of the logger "
"named ``A.B.C`` evaluates to true, any event logged to ``A.B.C`` via a "
"method call such as ``logging.getLogger('A.B.C').error(...)`` will [subject "
"to passing that logger's level and filter settings] be passed in turn to any "
"handlers attached to loggers named ``A.B``, ``A`` and the root logger, after "
"first being passed to any handlers attached to ``A.B.C``. If any logger in "
"the chain ``A.B.C``, ``A.B``, ``A`` has its ``propagate`` attribute set to "
"false, then that is the last logger whose handlers are offered the event to "
"handle, and propagation stops at that point."
msgstr ""
"Напишіть це на прикладі: якщо атрибут propagate реєстратора під назвою ``A.B."
"C`` має значення true, будь-яка подія, зареєстрована в ``A.B.C`` через "
"виклик методу, наприклад ``logging.getLogger('A.B.C') .error(...)`` [за "
"умови передачі цього рівня реєстратора та налаштувань фільтра] буде передано "
"по черзі будь-яким обробникам, приєднаним до реєстраторів з назвами ``A.B``, "
"``A`` і кореневому реєстратору після першого передається будь-яким "
"обробникам, приєднаним до ``A.B.C``. Якщо будь-який реєстратор у ланцюжку "
"``A.B.C``, ``A.B``, ``A`` має атрибут ``propagate``, встановлений на false, "
"то це останній реєстратор, обробникам якого пропонується подія для обробки, "
"і на цьому розповсюдження припиняється."

msgid "The constructor sets this attribute to ``True``."
msgstr "Конструктор встановлює цьому атрибуту значення ``True``."

msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, it "
"may emit the same record multiple times. In general, you should not need to "
"attach a handler to more than one logger - if you just attach it to the "
"appropriate logger which is highest in the logger hierarchy, then it will "
"see all events logged by all descendant loggers, provided that their "
"propagate setting is left set to ``True``. A common scenario is to attach "
"handlers only to the root logger, and to let propagation take care of the "
"rest."
msgstr ""
"Якщо ви приєднаєте обробник до реєстратора *і* одного або кількох його "
"предків, він може створювати той самий запис кілька разів. Загалом, вам не "
"потрібно приєднувати обробник до кількох реєстраторів — якщо ви просто "
"приєднаєте його до відповідного реєстратора, який є найвищим в ієрархії "
"реєстратора, тоді він бачитиме всі події, зареєстровані всіма нащадками "
"реєстраторів, за умови, що вони поширюються параметр залишається "
"встановленим на ``True``. Поширеним сценарієм є приєднання обробників лише "
"до кореневого реєстратора, а розповсюдження подбає про решту."

msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are "
"less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or handlers "
"service this logger, unless a handler's level has been set to a higher "
"severity level than *level*."
msgstr ""
"Встановлює порогове значення для цього реєстратора на *рівень*. Повідомлення "
"журналу, менш суворі, ніж *рівень*, ігноруватимуться; Повідомлення "
"журналювання, які мають рівень серйозності *рівень* або вищий, будуть "
"випущені будь-яким обробником або обробниками, які обслуговують цей "
"реєстратор, якщо рівень серйозності обробника не встановлено на вищий рівень "
"серйозності, ніж *рівень*."

msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which causes "
"all messages to be processed when the logger is the root logger, or "
"delegation to the parent when the logger is a non-root logger). Note that "
"the root logger is created with level :const:`WARNING`."
msgstr ""
"Коли реєстратор створюється, рівень встановлюється на :const:`NOTSET` (що "
"спричиняє обробку всіх повідомлень, коли реєстратор є кореневим "
"реєстратором, або делегування батьківському, якщо реєстратор є некореневим). "
"Зверніть увагу, що кореневий реєстратор створюється з рівнем :const:"
"`WARNING`."

msgid ""
"The term 'delegation to the parent' means that if a logger has a level of "
"NOTSET, its chain of ancestor loggers is traversed until either an ancestor "
"with a level other than NOTSET is found, or the root is reached."
msgstr ""
"Термін \"делегування батьківському\" означає, що якщо реєстратор має рівень "
"NOTSET, його ланцюжок реєстраторів предків обходиться, доки не буде знайдено "
"предка з рівнем, відмінним від NOTSET, або досягнуто кореня."

msgid ""
"If an ancestor is found with a level other than NOTSET, then that ancestor's "
"level is treated as the effective level of the logger where the ancestor "
"search began, and is used to determine how a logging event is handled."
msgstr ""
"Якщо знайдено предка з рівнем, відмінним від NOTSET, тоді цей рівень предка "
"розглядається як ефективний рівень реєстратора, з якого почався пошук "
"предка, і використовується для визначення того, як обробляється подія "
"журналювання."

msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages will "
"be processed. Otherwise, the root's level will be used as the effective "
"level."
msgstr ""
"Якщо кореневий доступ досягнутий і він має рівень NOTSET, то всі "
"повідомлення будуть оброблені. В іншому випадку кореневий рівень буде "
"використано як ефективний рівень."

msgid "See :ref:`levels` for a list of levels."
msgstr "Перегляньте :ref:`levels` список рівнів."

msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`. "
"Note, however, that levels are internally stored as integers, and methods "
"such as e.g. :meth:`getEffectiveLevel` and :meth:`isEnabledFor` will return/"
"expect to be passed integers."
msgstr ""
"Параметр *level* тепер приймає рядкове представлення рівня, наприклад "
"\"INFO\", як альтернативу цілим константам, таким як :const:`INFO`. Однак "
"зауважте, що рівні внутрішньо зберігаються як цілі числа, а такі методи, як, "
"наприклад, :meth:`getEffectiveLevel` і :meth:`isEnabledFor` повертатимуть/"
"очікуватимуть передачу цілих чисел."

msgid ""
"Indicates if a message of severity *level* would be processed by this "
"logger. This method checks first the module-level level set by ``logging."
"disable(level)`` and then the logger's effective level as determined by :"
"meth:`getEffectiveLevel`."
msgstr ""
"Вказує, чи буде оброблено повідомлення *рівня* серйозності цим реєстратором. "
"Цей метод спочатку перевіряє рівень модуля, встановлений ``logging."
"disable(level)``, а потім ефективний рівень реєстратора, визначений :meth:"
"`getEffectiveLevel`."

msgid ""
"Indicates the effective level for this logger. If a value other than :const:"
"`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise, the "
"hierarchy is traversed towards the root until a value other than :const:"
"`NOTSET` is found, and that value is returned. The value returned is an "
"integer, typically one of :const:`logging.DEBUG`, :const:`logging.INFO` etc."
msgstr ""
"Вказує ефективний рівень для цього реєстратора. Якщо значення, відмінне від :"
"const:`NOTSET`, було встановлено за допомогою :meth:`setLevel`, воно "
"повертається. В іншому випадку ієрархія переміщається до кореня, доки не "
"буде знайдено значення, відмінне від :const:`NOTSET`, і це значення "
"повертається. Значення, що повертається, є цілим числом, зазвичай одне з :"
"const:`logging.DEBUG`, :const:`logging.INFO` тощо."

msgid ""
"Returns a logger which is a descendant to this logger, as determined by the "
"suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would return "
"the same logger as would be returned by ``logging.getLogger('abc.def."
"ghi')``. This is a convenience method, useful when the parent logger is "
"named using e.g. ``__name__`` rather than a literal string."
msgstr ""
"Повертає реєстратор, який є нащадком цього реєстратора, як визначено "
"суфіксом. Таким чином, ``logging.getLogger('abc').getChild('def.ghi')`` "
"повертатиме той самий реєстратор, який повертає ``logging.getLogger('abc.def."
"ghi')``. Це зручний метод, корисний, коли батьківський реєстратор "
"називається, наприклад, ``__name__``, а не літеральний рядок."

msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the "
"message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.) No % formatting operation is performed on *msg* when no *args* "
"are supplied."
msgstr ""
"Записує повідомлення з рівнем :const:`DEBUG` у цьому реєстраторі. *msg* — це "
"рядок формату повідомлення, а *args* — це аргументи, які об’єднуються в "
"*msg* за допомогою оператора форматування рядка. (Зауважте, що це означає, "
"що ви можете використовувати ключові слова в рядку формату разом із одним "
"аргументом словника.) Операція форматування % не виконується для *msg*, якщо "
"не надано *args*."

msgid ""
"There are four keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, *stacklevel* and *extra*."
msgstr ""
"У *kwargs* є чотири аргументи ключових слів, які перевіряються: *exc_info*, "
"*stack_info*, *stacklevel* і *extra*."

msgid ""
"If *exc_info* does not evaluate as false, it causes exception information to "
"be added to the logging message. If an exception tuple (in the format "
"returned by :func:`sys.exc_info`) or an exception instance is provided, it "
"is used; otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr ""
"Якщо *exc_info* не оцінюється як false, це спричиняє додавання інформації "
"про винятки до повідомлення журналу. Якщо надано кортеж винятків (у форматі, "
"який повертає :func:`sys.exc_info`) або екземпляр винятку, він "
"використовується; інакше :func:`sys.exc_info` викликається для отримання "
"інформації про винятки."

msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former is "
"stack frames from the bottom of the stack up to the logging call in the "
"current thread, whereas the latter is information about stack frames which "
"have been unwound, following an exception, while searching for exception "
"handlers."
msgstr ""
"Другим необов’язковим ключовим аргументом є *stack_info*, який за умовчанням "
"має значення ``False``. Якщо значення true, інформація про стек додається до "
"повідомлення журналу, включаючи фактичний виклик журналу. Зауважте, що це "
"інша інформація про стек, яка відображається за допомогою *exc_info*: перша "
"– це кадри стеку від нижньої частини стеку до виклику журналювання в "
"поточному потоці, тоді як остання – це інформація про кадри стеку, які були "
"переглянуті. unwind, після винятку, під час пошуку обробників винятків."

msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just show "
"how you got to a certain point in your code, even when no exceptions were "
"raised. The stack frames are printed following a header line which says:"
msgstr ""
"Ви можете вказати *stack_info* незалежно від *exc_info*, наприклад. щоб "
"просто показати, як ви дійшли до певної точки у своєму коді, навіть якщо "
"винятків не було викликано. Фрейми стека друкуються після рядка заголовка, "
"який говорить:"

msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when "
"displaying exception frames."
msgstr ""
"Це імітує ``Traceback (останній останній виклик):``, який використовується "
"під час відображення кадрів винятків."

msgid ""
"The third optional keyword argument is *stacklevel*, which defaults to "
"``1``. If greater than 1, the corresponding number of stack frames are "
"skipped when computing the line number and function name set in the :class:"
"`LogRecord` created for the logging event. This can be used in logging "
"helpers so that the function name, filename and line number recorded are not "
"the information for the helper function/method, but rather its caller. The "
"name of this parameter mirrors the equivalent one in the :mod:`warnings` "
"module."
msgstr ""
"Третій необов’язковий аргумент ключового слова — *stacklevel*, який за "
"замовчуванням має значення \"1\". Якщо більше 1, відповідна кількість кадрів "
"стека пропускається під час обчислення номера рядка та назви функції, "
"встановленої в :class:`LogRecord`, створеному для події журналювання. Це "
"можна використовувати в помічниках журналювання, щоб ім’я функції, ім’я "
"файлу та номер рядка були записані не для допоміжної функції/методу, а для "
"її викликаючого. Назва цього параметра відображає еквівалентну назву в "
"модулі :mod:`warnings`."

msgid ""
"The fourth keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the :class:`LogRecord` "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr ""
"Четвертий аргумент ключового слова — *extra*, який можна використовувати для "
"передачі словника, який використовується для заповнення __dict__ :class:"
"`LogRecord`, створеного для події журналювання, атрибутами, визначеними "
"користувачем. Потім ці настроювані атрибути можна використовувати як "
"завгодно. Наприклад, їх можна включити до зареєстрованих повідомлень. "
"Наприклад::"

msgid "would print something like"
msgstr "надрукував би щось подібне"

msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the :class:`Formatter` documentation for "
"more information on which keys are used by the logging system.)"
msgstr ""
"Ключі в словнику, передані в *extra*, не повинні конфліктувати з ключами, "
"які використовуються системою журналювання. (Див. документацію :class:"
"`Formatter`, щоб дізнатися більше про те, які ключі використовуються "
"системою журналювання.)"

msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the :class:`LogRecord`. If these "
"are missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"Якщо ви вирішите використовувати ці атрибути в зареєстрованих повідомленнях, "
"вам потрібно бути обережними. У наведеному вище прикладі, наприклад, :class:"
"`Formatter` було налаштовано за допомогою рядка формату, який очікує "
"'clientip' і 'user' у словнику атрибутів :class:`LogRecord`. Якщо вони "
"відсутні, повідомлення не буде зареєстровано, оскільки виникне виняток "
"форматування рядка. Тому в цьому випадку вам завжди потрібно передавати "
"*додатковий* словник за допомогою цих ключів."

msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise are "
"dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it is "
"likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"Хоча це може дратувати, ця функція призначена для використання в особливих "
"умовах, наприклад, на багатопоточних серверах, де той самий код виконується "
"в багатьох контекстах, і цікаві умови, які виникають, залежать від цього "
"контексту (наприклад, IP-адреса віддаленого клієнта та автентифікований ім’я "
"користувача, у наведеному вище прикладі). За таких обставин цілком імовірно, "
"що спеціалізовані :class:`Formatter`\\ s будуть використовуватися з певними :"
"class:`Handler`\\ s."

msgid ""
"If no handler is attached to this logger (or any of its ancestors, taking "
"into account the relevant :attr:`Logger.propagate` attributes), the message "
"will be sent to the handler set on :attr:`lastResort`."
msgstr ""
"Якщо до цього реєстратора (або будь-якого з його предків) не приєднано "
"жодного обробника, враховуючи відповідні атрибути :attr:`Logger.propagate`, "
"повідомлення буде надіслано до обробника, встановленого на :attr:"
"`lastResort`."

msgid "The *stack_info* parameter was added."
msgstr "Додано параметр *stack_info*."

msgid "The *exc_info* parameter can now accept exception instances."
msgstr "Параметр *exc_info* тепер може приймати винятки."

msgid "The *stacklevel* parameter was added."
msgstr "Додано параметр *stacklevel*."

msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`INFO` у цьому реєстраторі. Аргументи "
"інтерпретуються як для :meth:`debug`."

msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`WARNING` до цього реєстратора. "
"Аргументи інтерпретуються як для :meth:`debug`."

msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"Існує застарілий метод ``warn``, який функціонально ідентичний ``warning``. "
"Оскільки ``попередження`` є застарілим, будь ласка, не використовуйте його - "
"використовуйте замість нього ``попередження``."

msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`ERROR` у цьому реєстраторі. Аргументи "
"інтерпретуються як для :meth:`debug`."

msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`CRITICAL` до цього реєстратора. "
"Аргументи інтерпретуються як для :meth:`debug`."

msgid ""
"Logs a message with integer level *level* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr ""
"Записує повідомлення з цілочисельним рівнем *level* у цьому реєстраторі. "
"Інші аргументи інтерпретуються як для :meth:`debug`."

msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`. Exception info is added to the logging "
"message. This method should only be called from an exception handler."
msgstr ""
"Реєструє повідомлення з рівнем :const:`ERROR` у цьому реєстраторі. Аргументи "
"інтерпретуються як для :meth:`debug`. Інформація про винятки додається до "
"повідомлення журналу. Цей метод слід викликати лише з обробника винятків."

msgid "Adds the specified filter *filter* to this logger."
msgstr "Додає вказаний фільтр *filter* до цього реєстратора."

msgid "Removes the specified filter *filter* from this logger."
msgstr "Видаляє вказаний фільтр *filter* з цього реєстратора."

msgid ""
"Apply this logger's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be processed (passed to handlers). If one returns a false value, no further "
"processing of the record occurs."
msgstr ""
"Застосуйте фільтри цього реєстратора до запису та поверніть ``True``, якщо "
"запис потрібно обробити. Фільтри перевіряються по черзі, поки один із них не "
"поверне хибне значення. Якщо жоден із них не повертає хибне значення, запис "
"буде оброблено (передано обробникам). Якщо повертається хибне значення, "
"подальша обробка запису не відбувається."

msgid "Adds the specified handler *hdlr* to this logger."
msgstr "Додає вказаний обробник *hdlr* до цього реєстратора."

msgid "Removes the specified handler *hdlr* from this logger."
msgstr "Видаляє вказаний обробник *hdlr* із цього реєстратора."

msgid ""
"Finds the caller's source filename and line number. Returns the filename, "
"line number, function name and stack information as a 4-element tuple. The "
"stack information is returned as ``None`` unless *stack_info* is ``True``."
msgstr ""
"Знаходить назву вихідного файлу абонента та номер рядка. Повертає назву "
"файлу, номер рядка, назву функції та інформацію про стек у вигляді 4-"
"елементного кортежу. Інформація про стек повертається як ``None``, якщо "
"*stack_info* не має значення ``True``."

msgid ""
"The *stacklevel* parameter is passed from code calling the :meth:`debug` and "
"other APIs. If greater than 1, the excess is used to skip stack frames "
"before determining the values to be returned. This will generally be useful "
"when calling logging APIs from helper/wrapper code, so that the information "
"in the event log refers not to the helper/wrapper code, but to the code that "
"calls it."
msgstr ""
"Параметр *stacklevel* передається з коду, який викликає :meth:`debug` та "
"інші API. Якщо більше 1, надлишок використовується для пропуску кадрів стека "
"перед визначенням значень, які потрібно повернути. Як правило, це буде "
"корисно під час виклику API реєстрації з допоміжного коду/обгортки, щоб "
"інформація в журналі подій стосувалася не допоміжного/оболонкового коду, а "
"коду, який його викликає."

msgid ""
"Handles a record by passing it to all handlers associated with this logger "
"and its ancestors (until a false value of *propagate* is found). This method "
"is used for unpickled records received from a socket, as well as those "
"created locally. Logger-level filtering is applied using :meth:`~Logger."
"filter`."
msgstr ""
"Обробляє запис, передаючи його всім обробникам, пов’язаним із цим "
"реєстратором та його предками (поки не буде знайдено хибне значення "
"*propagate*). Цей метод використовується для невибраних записів, отриманих "
"із сокета, а також тих, що створюються локально. Фільтрування на рівні "
"реєстратора застосовується за допомогою :meth:`~Logger.filter`."

msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr ""
"Це фабричний метод, який можна замінити в підкласах для створення "
"спеціалізованих екземплярів :class:`LogRecord`."

msgid ""
"Checks to see if this logger has any handlers configured. This is done by "
"looking for handlers in this logger and its parents in the logger hierarchy. "
"Returns ``True`` if a handler was found, else ``False``. The method stops "
"searching up the hierarchy whenever a logger with the 'propagate' attribute "
"set to false is found - that will be the last logger which is checked for "
"the existence of handlers."
msgstr ""
"Перевіряє, чи цей реєстратор має налаштовані обробники. Це робиться шляхом "
"пошуку обробників у цьому реєстраторі та його батьків в ієрархії "
"реєстратора. Повертає ``True``, якщо обробник знайдено, інакше ``False``. "
"Метод припиняє пошук в ієрархії щоразу, коли знайдено реєстратор з атрибутом "
"'propagate', встановленим на false - це буде останній реєстратор, який "
"перевіряється на наявність обробників."

msgid "Loggers can now be pickled and unpickled."
msgstr "Лісоруби тепер можна маринувати та не пикувати."

msgid "Logging Levels"
msgstr "Рівні реєстрації"

msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"Числові значення рівнів журналювання наведено в наступній таблиці. Це "
"насамперед цікаво, якщо ви бажаєте визначити власні рівні та потребуєте, щоб "
"вони мали певні значення відносно попередньо визначених рівнів. Якщо ви "
"визначаєте рівень з тим самим числовим значенням, він перезаписує попередньо "
"визначене значення; попередньо визначене ім'я втрачено."

msgid "Level"
msgstr "Рівень"

msgid "Numeric value"
msgstr "Числове значення"

msgid "``CRITICAL``"
msgstr "``КРИТИЧНО``"

msgid "50"
msgstr "50"

msgid "``ERROR``"
msgstr "``ПОМИЛКА``"

msgid "40"
msgstr "40"

msgid "``WARNING``"
msgstr "``ПОПЕРЕДЖЕННЯ``"

msgid "30"
msgstr "30"

msgid "``INFO``"
msgstr "``ІНФО``"

msgid "20"
msgstr "20"

msgid "``DEBUG``"
msgstr "``НАЛАШТУВАННЯ``"

msgid "10"
msgstr "10"

msgid "``NOTSET``"
msgstr "``NOTSET``"

msgid "0"
msgstr "0"

msgid "Handler Objects"
msgstr "Об’єкти обробки"

msgid ""
"Handlers have the following attributes and methods. Note that :class:"
"`Handler` is never instantiated directly; this class acts as a base for more "
"useful subclasses. However, the :meth:`__init__` method in subclasses needs "
"to call :meth:`Handler.__init__`."
msgstr ""
"Обробники мають такі атрибути та методи. Зауважте, що :class:`Handler` "
"ніколи не створюється безпосередньо; цей клас діє як основа для більш "
"корисних підкласів. Однак метод :meth:`__init__` у підкласах має викликати :"
"meth:`Handler.__init__`."

msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting the "
"list of filters to the empty list and creating a lock (using :meth:"
"`createLock`) for serializing access to an I/O mechanism."
msgstr ""
"Ініціалізує екземпляр :class:`Handler`, встановлюючи його рівень, "
"встановлюючи список фільтрів у порожній список і створюючи блокування (за "
"допомогою :meth:`createLock`) для серіалізації доступу до механізму введення-"
"виведення."

msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr ""
"Ініціалізує блокування потоку, який можна використовувати для серіалізації "
"доступу до основної функції введення-виведення, яка може бути небезпечною "
"для потоків."

msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr "Отримує блокування потоку, створене за допомогою :meth:`createLock`."

msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr "Звільняє блокування потоку, отримане за допомогою :meth:`acquire`."

msgid ""
"Sets the threshold for this handler to *level*. Logging messages which are "
"less severe than *level* will be ignored. When a handler is created, the "
"level is set to :const:`NOTSET` (which causes all messages to be processed)."
msgstr ""
"Встановлює порогове значення для цього обробника на *рівень*. Повідомлення "
"журналу, менш суворі, ніж *рівень*, ігноруватимуться. Коли обробник "
"створюється, рівень встановлюється на :const:`NOTSET` (що спричиняє обробку "
"всіх повідомлень)."

msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`."
msgstr ""
"Параметр *level* тепер приймає рядкове представлення рівня, наприклад "
"\"INFO\", як альтернативу цілим константам, таким як :const:`INFO`."

msgid "Sets the :class:`Formatter` for this handler to *fmt*."
msgstr "Встановлює :class:`Formatter` для цього обробника на *fmt*."

msgid "Adds the specified filter *filter* to this handler."
msgstr "Додає вказаний фільтр *filter* до цього обробника."

msgid "Removes the specified filter *filter* from this handler."
msgstr "Видаляє вказаний фільтр *filter* з цього обробника."

msgid ""
"Apply this handler's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be emitted. If one returns a false value, the handler will not emit the "
"record."
msgstr ""
"Застосуйте фільтри цього обробника до запису та поверніть ``True``, якщо "
"запис потрібно обробити. Фільтри перевіряються по черзі, доки один із них не "
"поверне хибне значення. Якщо жоден із них не повертає хибне значення, запис "
"буде видано. Якщо повертається хибне значення, обробник не видасть запис."

msgid ""
"Ensure all logging output has been flushed. This version does nothing and is "
"intended to be implemented by subclasses."
msgstr ""
"Переконайтеся, що всі вихідні дані журналу скинуто. Ця версія нічого не "
"робить і призначена для реалізації підкласами."

msgid ""
"Tidy up any resources used by the handler. This version does no output but "
"removes the handler from an internal list of handlers which is closed when :"
"func:`shutdown` is called. Subclasses should ensure that this gets called "
"from overridden :meth:`close` methods."
msgstr ""
"Приберіть усі ресурси, які використовує обробник. Ця версія не виводить, але "
"видаляє обробник із внутрішнього списку обробників, який закривається під "
"час виклику :func:`shutdown`. Підкласи повинні гарантувати, що це "
"викликається з перевизначених методів :meth:`close`."

msgid ""
"Conditionally emits the specified logging record, depending on filters which "
"may have been added to the handler. Wraps the actual emission of the record "
"with acquisition/release of the I/O thread lock."
msgstr ""
"Умовно створює вказаний запис журналу залежно від фільтрів, які могли бути "
"додані до обробника. Обгортає фактичний випуск запису з отриманням/"
"вивільненням блокування потоку вводу-виводу."

msgid ""
"This method should be called from handlers when an exception is encountered "
"during an :meth:`emit` call. If the module-level attribute "
"``raiseExceptions`` is ``False``, exceptions get silently ignored. This is "
"what is mostly wanted for a logging system - most users will not care about "
"errors in the logging system, they are more interested in application "
"errors. You could, however, replace this with a custom handler if you wish. "
"The specified record is the one which was being processed when the exception "
"occurred. (The default value of ``raiseExceptions`` is ``True``, as that is "
"more useful during development)."
msgstr ""
"Цей метод слід викликати з обробників, коли під час виклику :meth:`emit` "
"виникає виняткова ситуація. Якщо атрибут на рівні модуля ``raiseExceptions`` "
"має значення ``False``, винятки мовчки ігноруються. Це те, що здебільшого "
"потрібно для системи журналювання - більшість користувачів не будуть дбати "
"про помилки в системі журналювання, їх більше цікавлять помилки програми. "
"Однак ви можете замінити це спеціальним обробником, якщо хочете. Указаний "
"запис є записом, який оброблявся, коли сталася виняток. (Значенням за "
"замовчуванням ``raiseExceptions`` є ``True``, оскільки це більш корисно під "
"час розробки)."

msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, use "
"the default formatter for the module."
msgstr ""
"Виконайте форматування для запису - якщо встановлено форматувальник, "
"використовуйте його. В іншому випадку використовуйте стандартний формататор "
"для модуля."

msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a :exc:"
"`NotImplementedError`."
msgstr ""
"Зробіть усе можливе, щоб фактично зареєструвати вказаний запис журналу. Ця "
"версія призначена для реалізації підкласами, тому викликає :exc:"
"`NotImplementedError`."

msgid ""
"For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr "Перелік стандартних обробників див. :mod:`logging.handlers`."

msgid "Formatter Objects"
msgstr "Об’єкти форматування"

msgid ""
":class:`Formatter` objects have the following attributes and methods. They "
"are responsible for converting a :class:`LogRecord` to (usually) a string "
"which can be interpreted by either a human or an external system. The base :"
"class:`Formatter` allows a formatting string to be specified. If none is "
"supplied, the default value of ``'%(message)s'`` is used, which just "
"includes the message in the logging call. To have additional items of "
"information in the formatted output (such as a timestamp), keep reading."
msgstr ""
"Об’єкти :class:`Formatter` мають такі атрибути та методи. Вони відповідають "
"за перетворення :class:`LogRecord` на (зазвичай) рядок, який може "
"інтерпретувати або людина, або зовнішня система. База :class:`Formatter` "
"дозволяє вказати рядок форматування. Якщо жодного не вказано, "
"використовується значення за замовчуванням ``'%(message)s'``, яке просто "
"включає повідомлення у виклик журналювання. Щоб мати додаткову інформацію у "
"відформатованому виведенні (наприклад, позначку часу), продовжуйте читати."

msgid ""
"A Formatter can be initialized with a format string which makes use of "
"knowledge of the :class:`LogRecord` attributes - such as the default value "
"mentioned above making use of the fact that the user's message and arguments "
"are pre-formatted into a :class:`LogRecord`'s *message* attribute.  This "
"format string contains standard Python %-style mapping keys. See section :"
"ref:`old-string-formatting` for more information on string formatting."
msgstr ""
"Formatter можна ініціалізувати за допомогою рядка формату, який використовує "
"знання атрибутів :class:`LogRecord`, таких як значення за замовчуванням, "
"згадане вище, з використанням того факту, що повідомлення та аргументи "
"користувача попередньо відформатовано в атрибут *повідомлення* у :class:"
"`LogRecord`. Цей рядок формату містить стандартні ключі зіставлення Python %-"
"style. Перегляньте розділ :ref:`old-string-formatting` для отримання "
"додаткової інформації про форматування рядка."

msgid ""
"The useful mapping keys in a :class:`LogRecord` are given in the section on :"
"ref:`logrecord-attributes`."
msgstr ""
"Корисні ключі зіставлення в :class:`LogRecord` подано в розділі про :ref:"
"`logrecord-attributes`."

msgid ""
"Returns a new instance of the :class:`Formatter` class.  The instance is "
"initialized with a format string for the message as a whole, as well as a "
"format string for the date/time portion of a message.  If no *fmt* is "
"specified, ``'%(message)s'`` is used.  If no *datefmt* is specified, a "
"format is used which is described in the :meth:`formatTime` documentation."
msgstr ""
"Повертає новий екземпляр класу :class:`Formatter`. Примірник ініціалізується "
"рядком формату для повідомлення в цілому, а також рядком формату для частини "
"дати/часу повідомлення. Якщо *fmt* не вказано, використовується "
"\"%(message)s\". Якщо *datefmt* не вказано, використовується формат, який "
"описано в документації :meth:`formatTime`."

msgid ""
"The *style* parameter can be one of '%', '{' or '$' and determines how the "
"format string will be merged with its data: using one of %-formatting, :meth:"
"`str.format` or :class:`string.Template`. This only applies to the format "
"string *fmt* (e.g. ``'%(message)s'`` or ``{message}``), not to the actual "
"log messages passed to ``Logger.debug`` etc; see :ref:`formatting-styles` "
"for more information on using {- and $-formatting for log messages."
msgstr ""
"Параметр *style* може мати значення \"%\", \"{\" або \"$\" і визначає, як "
"рядок формату буде об’єднано з його даними: за допомогою %-formatting, :meth:"
"`str.format` або :class:`рядок.Шаблон`. Це стосується лише рядка формату "
"*fmt* (наприклад, ``'%(message)s''`` або ``{message}``), а не фактичних "
"повідомлень журналу, що передаються до ``Logger.debug`` тощо; див. :ref:"
"`formatting-styles` для отримання додаткової інформації про використання {- "
"і $-форматування для повідомлень журналу."

msgid ""
"The *defaults* parameter can be a dictionary with default values to use in "
"custom fields. For example: ``logging.Formatter('%(ip)s %(message)s', "
"defaults={\"ip\": None})``"
msgstr ""
"Параметр *defaults* може бути словником зі значеннями за замовчуванням для "
"використання в спеціальних полях. Наприклад: ``logging.Formatter('%(ip)s "
"%(message)s', defaults={\"ip\": None})``"

msgid "The *style* parameter was added."
msgstr "Додано параметр *style*."

msgid ""
"The *validate* parameter was added. Incorrect or mismatched style and fmt "
"will raise a ``ValueError``. For example: ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."
msgstr ""
"Додано параметр *validate*. Неправильний або невідповідний стиль і fmt "
"викличе ``ValueError``. Наприклад: ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."

msgid "The *defaults* parameter was added."
msgstr "Додано параметр *defaults*."

msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the "
"dictionary, a couple of preparatory steps are carried out. The *message* "
"attribute of the record is computed using *msg* % *args*. If the formatting "
"string contains ``'(asctime)'``, :meth:`formatTime` is called to format the "
"event time. If there is exception information, it is formatted using :meth:"
"`formatException` and appended to the message. Note that the formatted "
"exception information is cached in attribute *exc_text*. This is useful "
"because the exception information can be pickled and sent across the wire, "
"but you should be careful if you have more than one :class:`Formatter` "
"subclass which customizes the formatting of exception information. In this "
"case, you will have to clear the cached value (by setting the *exc_text* "
"attribute to ``None``) after a formatter has done its formatting, so that "
"the next formatter to handle the event doesn't use the cached value, but "
"recalculates it afresh."
msgstr ""
"Словник атрибутів запису використовується як операнд для операції "
"форматування рядка. Повертає отриманий рядок. Перед форматуванням словника "
"виконується кілька підготовчих кроків. Атрибут *message* запису обчислюється "
"за допомогою *msg* % *args*. Якщо рядок форматування містить "
"``'(asctime)'``, :meth:`formatTime` викликається для форматування часу "
"події. Якщо є інформація про винятки, вона форматується за допомогою :meth:"
"`formatException` і додається до повідомлення. Зауважте, що відформатована "
"інформація про винятки кешується в атрибуті *exc_text*. Це корисно, оскільки "
"інформацію про винятки можна відібрати та надіслати по мережі, але ви "
"повинні бути обережними, якщо у вас є більше одного підкласу :class:"
"`Formatter`, який налаштовує форматування інформації про винятки. У цьому "
"випадку вам доведеться очистити кешоване значення (встановивши для атрибута "
"*exc_text* значення ``None``) після того, як засіб форматування виконає своє "
"форматування, щоб наступний засіб форматування для обробки події не "
"використовував кешований значення, але перераховує його заново."

msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr ""
"Якщо інформація про стек доступна, вона додається після інформації про "
"винятки, використовуючи :meth:`formatStack` для її перетворення, якщо "
"необхідно."

msgid ""
"This method should be called from :meth:`format` by a formatter which wants "
"to make use of a formatted time. This method can be overridden in formatters "
"to provide for any specific requirement, but the basic behavior is as "
"follows: if *datefmt* (a string) is specified, it is used with :func:`time."
"strftime` to format the creation time of the record. Otherwise, the format "
"'%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part is a millisecond value "
"and the other letters are as per the :func:`time.strftime` documentation.  "
"An example time in this format is ``2003-01-23 00:29:50,411``.  The "
"resulting string is returned."
msgstr ""
"Цей метод має викликатися з :meth:`format` програмою форматування, яка бажає "
"використати відформатований час. Цей метод можна замінити у форматах для "
"забезпечення будь-якої конкретної вимоги, але основна поведінка така: якщо "
"вказано *datefmt* (рядок), він використовується з :func:`time.strftime` для "
"форматування часу створення запису. В іншому випадку використовується формат "
"\"%Y-%m-%d %H:%M:%S,uuu\", де частина uuu є значенням у мілісекундах, а інші "
"літери відповідають :func:`time.strftime` документація. Прикладом часу в "
"цьому форматі є ``2003-01-23 00:29:50,411``. Повертається отриманий рядок."

msgid ""
"This function uses a user-configurable function to convert the creation time "
"to a tuple. By default, :func:`time.localtime` is used; to change this for a "
"particular formatter instance, set the ``converter`` attribute to a function "
"with the same signature as :func:`time.localtime` or :func:`time.gmtime`. To "
"change it for all formatters, for example if you want all logging times to "
"be shown in GMT, set the ``converter`` attribute in the ``Formatter`` class."
msgstr ""
"Ця функція використовує настроювану користувачем функцію для перетворення "
"часу створення в кортеж. За замовчуванням використовується :func:`time."
"localtime`; щоб змінити це для конкретного екземпляра форматера, встановіть "
"атрибут ``converter`` на функцію з тим самим підписом, що й :func:`time."
"localtime` або :func:`time.gmtime`. Щоб змінити його для всіх засобів "
"форматування, наприклад, якщо ви хочете, щоб усі часи журналювання "
"відображалися за GMT, установіть атрибут ``converter`` у класі ``Formatter``."

msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by a "
"strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after the "
"comma is a millisecond value. Because strptime does not have a format "
"placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings "
"have been hardcoded into this method. With the change, these strings are "
"defined as class-level attributes which can be overridden at the instance "
"level when desired. The names of the attributes are ``default_time_format`` "
"(for the strptime format string) and ``default_msec_format`` (for appending "
"the millisecond value)."
msgstr ""
"Раніше формат за замовчуванням був жорстко закодований, як у цьому прикладі: "
"``2010-09-06 22:38:15,292``, де частина перед комою обробляється рядком "
"формату strptime (``'%Y-%m -%d %H:%M:%S''``), а частина після коми є "
"значенням у мілісекундах. Оскільки strptime не має заповнювача формату для "
"мілісекунд, значення мілісекунди додається за допомогою іншого рядка "
"формату, ``'%s,%03d''`` --- і обидва ці рядки формату були жорстко "
"закодовані в цьому методі. Зі зміною ці рядки визначаються як атрибути рівня "
"класу, які за бажанням можна замінити на рівні екземпляра. Назви атрибутів: "
"``default_time_format`` (для рядка формату strptime) і "
"``default_msec_format`` (для додавання значення в мілісекундах)."

msgid "The ``default_msec_format`` can be ``None``."
msgstr "``default_msec_format`` може бути ``None``."

msgid ""
"Formats the specified exception information (a standard exception tuple as "
"returned by :func:`sys.exc_info`) as a string. This default implementation "
"just uses :func:`traceback.print_exception`. The resulting string is "
"returned."
msgstr ""
"Форматує вказану інформацію про винятки (стандартний кортеж винятків, який "
"повертає :func:`sys.exc_info`) як рядок. Ця реалізація за умовчанням просто "
"використовує :func:`traceback.print_exception`. Повертається отриманий рядок."

msgid ""
"Formats the specified stack information (a string as returned by :func:"
"`traceback.print_stack`, but with the last newline removed) as a string. "
"This default implementation just returns the input value."
msgstr ""
"Форматує вказану інформацію про стек (рядок, який повертає :func:`traceback."
"print_stack`, але з видаленням останнього нового рядка) як рядок. Ця "
"реалізація за умовчанням лише повертає вхідне значення."

msgid "Filter Objects"
msgstr "Фільтр об'єктів"

msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class "
"only allows events which are below a certain point in the logger hierarchy. "
"For example, a filter initialized with 'A.B' will allow events logged by "
"loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc. "
"If initialized with the empty string, all events are passed."
msgstr ""
"``Фільтри`` можуть використовуватися ``Обробниками`` і ``Реєстраторами`` для "
"більш складної фільтрації, ніж передбачено рівнями. Базовий клас фільтра "
"дозволяє лише події, які знаходяться нижче певної точки в ієрархії "
"реєстратора. Наприклад, фільтр, ініціалізований \"A.B\", дозволить події, "
"зареєстровані реєстраторами \"A.B\", \"A.B.C\", \"A.B.C.D\", \"A.B.D\" тощо, "
"але не \"A.BB\", \"B.A.B\" тощо. Якщо ініціалізовано порожнім рядком, усі "
"події передаються."

msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified, it "
"names a logger which, together with its children, will have its events "
"allowed through the filter. If *name* is the empty string, allows every "
"event."
msgstr ""
"Повертає екземпляр класу :class:`Filter`. Якщо вказано *ім’я*, воно називає "
"реєстратор, події якого разом із дочірніми елементами будуть дозволені через "
"фільтр. Якщо *ім’я* є порожнім рядком, дозволяється кожна подія."

msgid ""
"Is the specified record to be logged? Returns zero for no, nonzero for yes. "
"If deemed appropriate, the record may be modified in-place by this method."
msgstr ""
"Чи потрібно реєструвати вказаний запис? Повертає нуль для ні, відмінне від "
"нуля для так. Якщо це буде визнано доцільним, запис може бути змінено на "
"місці за допомогою цього методу."

msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted "
"whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have been "
"generated by descendant loggers will not be filtered by a logger's filter "
"setting, unless the filter has also been applied to those descendant loggers."
msgstr ""
"Зауважте, що фільтри, приєднані до обробників, звертаються до того, як "
"обробник випустить подію, тоді як фільтри, приєднані до реєстраторів, "
"звертаються до кожного, коли подія реєструється (за допомогою :meth:"
"`debug`, :meth:`info` тощо), до відправка події обробникам. Це означає, що "
"події, які були згенеровані нащадками реєстраторів, не будуть відфільтровані "
"налаштуваннями фільтра реєстратора, якщо фільтр також не застосовано до цих "
"нащадків реєстраторів."

msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance "
"which has a ``filter`` method with the same semantics."
msgstr ""
"Насправді вам не потрібно створювати підклас ``Filter``: ви можете передати "
"будь-який екземпляр, який має метод ``filter`` з тією самою семантикою."

msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other callable) "
"as a filter. The filtering logic will check to see if the filter object has "
"a ``filter`` attribute: if it does, it's assumed to be a ``Filter`` and its :"
"meth:`~Filter.filter` method is called. Otherwise, it's assumed to be a "
"callable and called with the record as the single parameter. The returned "
"value should conform to that returned by :meth:`~Filter.filter`."
msgstr ""
"Вам не потрібно створювати спеціалізовані класи ``Filter`` або "
"використовувати інші класи з методом ``filter``: ви можете використовувати "
"функцію (або інший виклик) як фільтр. Логіка фільтрації перевірить, чи має "
"об’єкт фільтра атрибут ``filter``: якщо він має, він вважається ``Filter`` і "
"викликається його метод :meth:`~Filter.filter`. В іншому випадку вважається, "
"що він викликається та викликається із записом як єдиним параметром. "
"Повернене значення має відповідати тому, яке повертає :meth:`~Filter.filter`."

msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is "
"processed by the handler or logger they're attached to: this can be useful "
"if you want to do things like counting how many records were processed by a "
"particular logger or handler, or adding, changing or removing attributes in "
"the :class:`LogRecord` being processed. Obviously changing the LogRecord "
"needs to be done with some care, but it does allow the injection of "
"contextual information into logs (see :ref:`filters-contextual`)."
msgstr ""
"Хоча фільтри використовуються в основному для фільтрації записів на основі "
"більш складних критеріїв, ніж рівні, вони бачать кожен запис, який "
"обробляється обробником або реєстратором, до якого вони підключені: це може "
"бути корисним, якщо ви хочете зробити щось, наприклад, підрахувати, скільки "
"записи були оброблені певним реєстратором чи обробником, або додаванням, "
"зміною чи видаленням атрибутів у :class:`LogRecord`, що обробляється. "
"Очевидно, змінювати LogRecord потрібно з певною обережністю, але це дозволяє "
"вставляти контекстну інформацію в журнали (див. :ref:`filters-contextual`)."

msgid "LogRecord Objects"
msgstr "Об'єкти LogRecord"

msgid ""
":class:`LogRecord` instances are created automatically by the :class:"
"`Logger` every time something is logged, and can be created manually via :"
"func:`makeLogRecord` (for example, from a pickled event received over the "
"wire)."
msgstr ""
"Екземпляри :class:`LogRecord` створюються автоматично :class:`Logger` "
"щоразу, коли щось реєструється, і можуть бути створені вручну за допомогою :"
"func:`makeLogRecord` (наприклад, з марінованої події, отриманої по мережі)."

msgid "Contains all the information pertinent to the event being logged."
msgstr "Містить всю інформацію, що стосується події, яка реєструється."

msgid ""
"The primary information is passed in :attr:`msg` and :attr:`args`, which are "
"combined using ``msg % args`` to create the :attr:`message` field of the "
"record."
msgstr ""
"Основна інформація передається в :attr:`msg` і :attr:`args`, які поєднуються "
"за допомогою ``msg % args`` для створення поля :attr:`message` запису."

msgid "Parameters"
msgstr "Параметри"

msgid ""
"The name of the logger used to log the event represented by this LogRecord. "
"Note that this name will always have this value, even though it may be "
"emitted by a handler attached to a different (ancestor) logger."
msgstr ""
"Ім'я реєстратора, який використовується для реєстрації події, представленої "
"цим LogRecord. Зауважте, що це ім’я завжди матиме це значення, навіть якщо "
"воно може видаватись обробником, приєднаним до іншого (попереднього) "
"реєстратора."

msgid ""
"The numeric level of the logging event (one of DEBUG, INFO etc.) Note that "
"this is converted to *two* attributes of the LogRecord: ``levelno`` for the "
"numeric value and ``levelname`` for the corresponding level name."
msgstr ""
"Числовий рівень події журналювання (один із DEBUG, INFO тощо) Зауважте, що "
"він перетворюється на *два* атрибути LogRecord: ``levelno`` для числового "
"значення та ``levelname`` для відповідної назви рівня. ."

msgid "The full pathname of the source file where the logging call was made."
msgstr ""
"Повний шлях до вихідного файлу, у якому було здійснено виклик журналювання."

msgid "The line number in the source file where the logging call was made."
msgstr "Номер рядка у вихідному файлі, де було здійснено виклик журналювання."

msgid ""
"The event description message, possibly a format string with placeholders "
"for variable data."
msgstr ""
"Повідомлення з описом події, можливо, рядок формату з заповнювачами для "
"змінних даних."

msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr ""
"Змінні дані, які потрібно об’єднати в аргумент *msg*, щоб отримати опис "
"події."

msgid ""
"An exception tuple with the current exception information, or ``None`` if no "
"exception information is available."
msgstr ""
"Кортеж винятків із поточною інформацією про винятки або ``None``, якщо "
"інформація про винятки недоступна."

msgid ""
"The name of the function or method from which the logging call was invoked."
msgstr "Ім'я функції або методу, з якого було викликано журналювання."

msgid ""
"A text string representing stack information from the base of the stack in "
"the current thread, up to the logging call."
msgstr ""
"Текстовий рядок, що представляє інформацію про стек від основи стека в "
"поточному потоці до виклику журналювання."

msgid ""
"Returns the message for this :class:`LogRecord` instance after merging any "
"user-supplied arguments with the message. If the user-supplied message "
"argument to the logging call is not a string, :func:`str` is called on it to "
"convert it to a string. This allows use of user-defined classes as messages, "
"whose ``__str__`` method can return the actual format string to be used."
msgstr ""
"Повертає повідомлення для цього екземпляра :class:`LogRecord` після "
"об’єднання будь-яких наданих користувачем аргументів із повідомленням. Якщо "
"наданий користувачем аргумент повідомлення для виклику журналювання не є "
"рядком, :func:`str` викликається для нього, щоб перетворити його на рядок. "
"Це дозволяє використовувати визначені користувачем класи як повідомлення, "
"чий метод ``__str__`` може повертати фактичний рядок формату для "
"використання."

msgid ""
"The creation of a :class:`LogRecord` has been made more configurable by "
"providing a factory which is used to create the record. The factory can be "
"set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` (see "
"this for the factory's signature)."
msgstr ""
"Створення :class:`LogRecord` було зроблено більш настроюваним шляхом надання "
"фабрики, яка використовується для створення запису. Фабрику можна встановити "
"за допомогою :func:`getLogRecordFactory` і :func:`setLogRecordFactory` (див. "
"тут підпис фабрики)."

msgid ""
"This functionality can be used to inject your own values into a :class:"
"`LogRecord` at creation time. You can use the following pattern::"
msgstr ""
"Цю функцію можна використовувати для введення ваших власних значень у :class:"
"`LogRecord` під час створення. Ви можете використовувати наступний шаблон:"

msgid ""
"With this pattern, multiple factories could be chained, and as long as they "
"don't overwrite each other's attributes or unintentionally overwrite the "
"standard attributes listed above, there should be no surprises."
msgstr ""
"За допомогою цього шаблону кілька фабрик можуть бути з’єднані в ланцюг, і "
"якщо вони не перезаписують атрибути одна одної або ненавмисно перезаписують "
"стандартні атрибути, перелічені вище, не повинно бути сюрпризів."

msgid "LogRecord attributes"
msgstr "Атрибути LogRecord"

msgid ""
"The LogRecord has a number of attributes, most of which are derived from the "
"parameters to the constructor. (Note that the names do not always correspond "
"exactly between the LogRecord constructor parameters and the LogRecord "
"attributes.) These attributes can be used to merge data from the record into "
"the format string. The following table lists (in alphabetical order) the "
"attribute names, their meanings and the corresponding placeholder in a %-"
"style format string."
msgstr ""
"LogRecord має низку атрибутів, більшість із яких є похідними від параметрів "
"конструктора. (Зауважте, що імена параметрів конструктора LogRecord і "
"атрибутів LogRecord не завжди точно збігаються.) Ці атрибути можна "
"використовувати для об’єднання даних із запису в рядок формату. У наведеній "
"нижче таблиці наведено (в алфавітному порядку) назви атрибутів, їх значення "
"та відповідний заповнювач у рядку формату %-style."

msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use ``{attrname}"
"`` as the placeholder in the format string. If you are using $-formatting (:"
"class:`string.Template`), use the form ``${attrname}``. In both cases, of "
"course, replace ``attrname`` with the actual attribute name you want to use."
msgstr ""
"Якщо ви використовуєте {}-formatting (:func:`str.format`), ви можете "
"використовувати ``{attrname}`` як заповнювач у рядку формату. Якщо ви "
"використовуєте $-форматування (:class:`string.Template`), використовуйте "
"форму ``${attrname}``. В обох випадках, звичайно, замініть ``attrname`` "
"фактичним ім'ям атрибута, який ви хочете використовувати."

msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing "
"them after the attribute name, separated from it with a colon. For example: "
"a placeholder of ``{msecs:03d}`` would format a millisecond value of ``4`` "
"as ``004``. Refer to the :meth:`str.format` documentation for full details "
"on the options available to you."
msgstr ""
"У випадку {}-форматування ви можете вказати прапорці форматування, "
"розмістивши їх після назви атрибута, відокремивши від нього двокрапку. "
"Наприклад: заповнювач ``{msecs:03d}`` відформатує мілісекундне значення "
"``4`` як ``004``. Зверніться до документації :meth:`str.format`, щоб "
"отримати детальну інформацію про доступні вам параметри."

msgid "Attribute name"
msgstr "Назва атрибута"

msgid "Format"
msgstr "Формат"

msgid "Description"
msgstr "опис"

msgid "args"
msgstr "арг"

msgid "You shouldn't need to format this yourself."
msgstr "Вам не потрібно форматувати це самостійно."

msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a dict "
"whose values are used for the merge (when there is only one argument, and it "
"is a dictionary)."
msgstr ""
"Кортеж аргументів об’єднано в ``msg`` для створення ``message`` або dict, "
"значення якого використовуються для злиття (якщо є лише один аргумент, і це "
"словник)."

msgid "asctime"
msgstr "asctime"

msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the comma "
"are millisecond portion of the time)."
msgstr ""
"Зрозумілий для людини час створення :class:`LogRecord`. За замовчуванням це "
"має форму \"2003-07-08 16:49:45,896\" (числа після коми є частиною часу в "
"мілісекундах)."

msgid "created"
msgstr "створений"

msgid "``%(created)f``"
msgstr "``%(created)f``"

msgid ""
"Time when the :class:`LogRecord` was created (as returned by :func:`time."
"time`)."
msgstr "Час створення :class:`LogRecord` (як повернуто :func:`time.time`)."

msgid "exc_info"
msgstr "exc_info"

msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred, "
"``None``."
msgstr ""
"Кортеж винятків (à la ``sys.exc_info``) або, якщо винятків не сталося, "
"``None``."

msgid "filename"
msgstr "ім'я файлу"

msgid "``%(filename)s``"
msgstr "``%(filename)s``"

msgid "Filename portion of ``pathname``."
msgstr "Частина імені файлу ``шляху``."

msgid "funcName"
msgstr "ім'я функції"

msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

msgid "Name of function containing the logging call."
msgstr "Назва функції, яка містить виклик журналювання."

msgid "levelname"
msgstr "ім'я рівня"

msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, "
"``'ERROR'``, ``'CRITICAL'``)."
msgstr ""
"Рівень реєстрації тексту для повідомлення (``'DEBUG'``, ``'INFO'``, "
"``'WARNING'``, ``'ERROR'``, ``'CRITICAL'``)."

msgid "levelno"
msgstr "levelno"

msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""
"Числовий рівень журналювання для повідомлення (:const:`DEBUG`, :const:"
"`INFO`, :const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."

msgid "lineno"
msgstr "lineno"

msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

msgid "Source line number where the logging call was issued (if available)."
msgstr ""
"Номер вихідного рядка, де було здійснено виклик реєстрації (за наявності)."

msgid "message"
msgstr "повідомлення"

msgid "``%(message)s``"
msgstr "``%(message)s``"

msgid ""
"The logged message, computed as ``msg % args``. This is set when :meth:"
"`Formatter.format` is invoked."
msgstr ""
"Зареєстроване повідомлення, обчислене як ``msg % args``. Це встановлюється "
"під час виклику :meth:`Formatter.format`."

msgid "module"
msgstr "модуль"

msgid "``%(module)s``"
msgstr "``%(module)s``"

msgid "Module (name portion of ``filename``)."
msgstr "Модуль (частина назви ``назви файлу``)."

msgid "msecs"
msgstr "мс"

msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

msgid ""
"Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr "Частина мілісекунд часу, коли було створено :class:`LogRecord`."

msgid "msg"
msgstr "повідомлення"

msgid ""
"The format string passed in the original logging call. Merged with ``args`` "
"to produce ``message``, or an arbitrary object (see :ref:`arbitrary-object-"
"messages`)."
msgstr ""
"Рядок формату, переданий у вихідному виклику журналювання. Об’єднано з "
"``args`` для отримання ``message`` або довільного об’єкта (див. :ref:"
"`arbitrary-object-messages`)."

msgid "name"
msgstr "назва"

msgid "``%(name)s``"
msgstr "``%(name)s``"

msgid "Name of the logger used to log the call."
msgstr "Ім'я реєстратора, який використовувався для реєстрації виклику."

msgid "pathname"
msgstr "шлях"

msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr ""
"Повний шлях до вихідного файлу, до якого було здійснено виклик журналювання "
"(за наявності)."

msgid "process"
msgstr "процес"

msgid "``%(process)d``"
msgstr "``%(process)d``"

msgid "Process ID (if available)."
msgstr "ID процесу (за наявності)."

msgid "processName"
msgstr "назва процесу"

msgid "``%(processName)s``"
msgstr "``%(processName)s``"

msgid "Process name (if available)."
msgstr "Назва процесу (якщо є)."

msgid "relativeCreated"
msgstr "relativeCreated"

msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time "
"the logging module was loaded."
msgstr ""
"Час у мілісекундах, коли було створено LogRecord, відносно часу завантаження "
"модуля журналювання."

msgid "stack_info"
msgstr "stack_info"

msgid ""
"Stack frame information (where available) from the bottom of the stack in "
"the current thread, up to and including the stack frame of the logging call "
"which resulted in the creation of this record."
msgstr ""
"Інформація про стек (якщо доступно) від нижньої частини стека в поточному "
"потоці до та включно з кадром стека виклику журналювання, який призвів до "
"створення цього запису."

msgid "thread"
msgstr "нитка"

msgid "``%(thread)d``"
msgstr "``%(thread)d``"

msgid "Thread ID (if available)."
msgstr "ID потоку (якщо є)."

msgid "threadName"
msgstr "ім'я потоку"

msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

msgid "Thread name (if available)."
msgstr "Назва теми (за наявності)."

msgid "*processName* was added."
msgstr "Додано *processName*."

msgid "LoggerAdapter Objects"
msgstr "Об’єкти LoggerAdapter"

msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual "
"information into logging calls. For a usage example, see the section on :ref:"
"`adding contextual information to your logging output <context-info>`."
msgstr ""
"Екземпляри :class:`LoggerAdapter` використовуються для зручної передачі "
"контекстної інформації у виклики журналювання. Для прикладу використання "
"дивіться розділ про :ref:`додавання контекстної інформації до вихідних даних "
"журналу <context-info>`."

msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr ""
"Повертає екземпляр :class:`LoggerAdapter`, ініціалізований базовим "
"екземпляром :class:`Logger` і dict-подібним об’єктом."

msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in "
"order to insert contextual information. This implementation takes the object "
"passed as *extra* to the constructor and adds it to *kwargs* using key "
"'extra'. The return value is a (*msg*, *kwargs*) tuple which has the "
"(possibly modified) versions of the arguments passed in."
msgstr ""
"Змінює повідомлення та/або ключові аргументи, передані виклику журналювання, "
"щоб вставити контекстну інформацію. Ця реалізація приймає об’єкт, переданий "
"як *extra* до конструктора, і додає його до *kwargs* за допомогою ключа "
"\"extra\". Поверненим значенням є кортеж (*msg*, *kwargs*), який містить "
"(можливо, змінені) версії переданих аргументів."

msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :"
"meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :"
"meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`, :"
"meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` and :meth:"
"`~Logger.hasHandlers`. These methods have the same signatures as their "
"counterparts in :class:`Logger`, so you can use the two types of instances "
"interchangeably."
msgstr ""
"На додаток до вищезазначеного, :class:`LoggerAdapter` підтримує такі методи :"
"class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :meth:`~Logger ."
"warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :meth:`~Logger."
"critical`, :meth:`~Logger.log`, :meth:`~Logger .isEnabledFor`, :meth:"
"`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` і :meth:`~Logger."
"hasHandlers`. Ці методи мають ті самі сигнатури, що й їхні аналоги в :class:"
"`Logger`, тому ви можете використовувати обидва типи екземплярів як "
"взаємозамінні."

msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:"
"`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were added to :"
"class:`LoggerAdapter`.  These methods delegate to the underlying logger."
msgstr ""
"Методи :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :"
"meth:`~Logger.setLevel` і :meth:`~Logger.hasHandlers` додано до :class:"
"`LoggerAdapter` . Ці методи делегують базовому реєстратору."

msgid ""
"Attribute :attr:`manager` and method :meth:`_log` were added, which delegate "
"to the underlying logger and allow adapters to be nested."
msgstr ""
"Було додано атрибут :attr:`manager` і метод :meth:`_log`, які делегують "
"базовому реєстратору та дозволяють адаптерам бути вкладеними."

msgid "Thread Safety"
msgstr "Безпека ниток"

msgid ""
"The logging module is intended to be thread-safe without any special work "
"needing to be done by its clients. It achieves this though using threading "
"locks; there is one lock to serialize access to the module's shared data, "
"and each handler also creates a lock to serialize access to its underlying I/"
"O."
msgstr ""
"Модуль журналювання призначений для потокобезпечної роботи без необхідності "
"виконання будь-якої спеціальної роботи клієнтами. Це досягається за "
"допомогою різьбових замків; існує одне блокування для серіалізації доступу "
"до спільних даних модуля, і кожен обробник також створює блокування для "
"серіалізації доступу до базового введення-виведення."

msgid ""
"If you are implementing asynchronous signal handlers using the :mod:`signal` "
"module, you may not be able to use logging from within such handlers. This "
"is because lock implementations in the :mod:`threading` module are not "
"always re-entrant, and so cannot be invoked from such signal handlers."
msgstr ""
"Якщо ви впроваджуєте асинхронні обробники сигналів за допомогою модуля :mod:"
"`signal`, можливо, ви не зможете використовувати журналювання в таких "
"обробниках. Це пов’язано з тим, що реалізації блокувань у модулі :mod:"
"`threading` не завжди можна повторно входити, і тому їх не можна викликати з "
"таких обробників сигналів."

msgid "Module-Level Functions"
msgstr "Функції рівня модуля"

msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr "На додаток до класів, описаних вище, існує ряд функцій рівня модуля."

msgid ""
"Return a logger with the specified name or, if name is ``None``, return a "
"logger which is the root logger of the hierarchy. If specified, the name is "
"typically a dot-separated hierarchical name like *'a'*, *'a.b'* or *'a.b.c."
"d'*. Choice of these names is entirely up to the developer who is using "
"logging."
msgstr ""
"Повертає реєстратор із вказаною назвою або, якщо ім’я ``None``, повертає "
"реєстратор, який є кореневим реєстратором ієрархії. Якщо вказано, це "
"зазвичай ієрархічне ім’я, розділене крапками, наприклад *'a'*, *'a.b'* або "
"*'a.b.c.d'*. Вибір цих імен повністю залежить від розробника, який "
"використовує журналювання."

msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed between "
"different parts of an application."
msgstr ""
"Усі виклики цієї функції з заданим іменем повертають той самий екземпляр "
"журналу. Це означає, що екземпляри реєстратора ніколи не потрібно передавати "
"між різними частинами програми."

msgid ""
"Return either the standard :class:`Logger` class, or the last class passed "
"to :func:`setLoggerClass`. This function may be called from within a new "
"class definition, to ensure that installing a customized :class:`Logger` "
"class will not undo customizations already applied by other code. For "
"example::"
msgstr ""
"Повертає або стандартний клас :class:`Logger`, або останній клас, переданий :"
"func:`setLoggerClass`. Цю функцію можна викликати з нового визначення класу, "
"щоб гарантувати, що встановлення налаштованого класу :class:`Logger` не "
"скасує налаштування, уже застосовані іншим кодом. Наприклад::"

msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr ""
"Повертає виклик, який використовується для створення :class:`LogRecord`."

msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"Цю функцію було надано разом із :func:`setLogRecordFactory`, щоб дозволити "
"розробникам більше контролювати те, як створюється :class:`LogRecord`, що "
"представляє подію журналювання."

msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr ""
"Перегляньте :func:`setLogRecordFactory` для отримання додаткової інформації "
"про те, як називається фабрика."

msgid ""
"Logs a message with level :const:`DEBUG` on the root logger. The *msg* is "
"the message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.)"
msgstr ""
"Записує повідомлення з рівнем :const:`DEBUG` на кореневому реєстраторі. "
"*msg* — це рядок формату повідомлення, а *args* — це аргументи, які "
"об’єднуються в *msg* за допомогою оператора форматування рядка. (Зауважте, "
"що це означає, що ви можете використовувати ключові слова в рядку формату "
"разом із одним аргументом словника.)"

msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info* which, if it does not evaluate as false, causes exception "
"information to be added to the logging message. If an exception tuple (in "
"the format returned by :func:`sys.exc_info`) or an exception instance is "
"provided, it is used; otherwise, :func:`sys.exc_info` is called to get the "
"exception information."
msgstr ""
"У *kwargs* є три аргументи ключових слів, які перевіряються: *exc_info*, "
"який, якщо він не оцінюється як false, призводить до додавання інформації "
"про винятки до повідомлення журналу. Якщо надано кортеж винятків (у форматі, "
"який повертає :func:`sys.exc_info`) або екземпляр винятку, він "
"використовується; інакше :func:`sys.exc_info` викликається для отримання "
"інформації про винятки."

msgid ""
"The third optional keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the LogRecord created "
"for the logging event with user-defined attributes. These custom attributes "
"can then be used as you like. For example, they could be incorporated into "
"logged messages. For example::"
msgstr ""
"Третій необов’язковий аргумент ключового слова — *extra*, який можна "
"використовувати для передачі словника, який використовується для заповнення "
"__dict__ LogRecord, створеного для події журналювання, атрибутами, "
"визначеними користувачем. Потім ці настроювані атрибути можна "
"використовувати як завгодно. Наприклад, їх можна включити до зареєстрованих "
"повідомлень. Наприклад::"

msgid "would print something like:"
msgstr "надрукував би щось на зразок:"

msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the LogRecord. If these are "
"missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"Якщо ви вирішите використовувати ці атрибути в зареєстрованих повідомленнях, "
"вам потрібно бути обережними. У наведеному вище прикладі, наприклад, :class:"
"`Formatter` було налаштовано за допомогою рядка формату, який очікує "
"\"clientip\" і \"user\" у словнику атрибутів LogRecord. Якщо вони відсутні, "
"повідомлення не буде зареєстровано, оскільки виникне виняток форматування "
"рядка. Тому в цьому випадку вам завжди потрібно передавати *додатковий* "
"словник за допомогою цих ключів."

msgid ""
"This function (as well as :func:`info`, :func:`warning`, :func:`error` and :"
"func:`critical`) will call :func:`basicConfig` if the root logger doesn't "
"have any handler attached."
msgstr ""
"Ця функція (а також :func:`info`, :func:`warning`, :func:`error` і :func:"
"`critical`) викличе :func:`basicConfig`, якщо кореневий реєстратор не має "
"будь-який доданий обробник."

msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`INFO` на кореневому реєстраторі. "
"Аргументи інтерпретуються як для :func:`debug`."

msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`WARNING` на кореневому реєстраторі. "
"Аргументи інтерпретуються як для :func:`debug`."

msgid ""
"There is an obsolete function ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"Існує застаріла функція ``warn``, яка функціонально ідентична ``warning``. "
"Оскільки ``попередження`` застаріло, будь ласка, не використовуйте його - "
"використовуйте замість нього ``попередження``."

msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`ERROR` на кореневому реєстраторі. "
"Аргументи інтерпретуються як для :func:`debug`."

msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr ""
"Записує повідомлення з рівнем :const:`CRITICAL` на кореневому реєстраторі. "
"Аргументи інтерпретуються як для :func:`debug`."

msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`. Exception info is added to the logging "
"message. This function should only be called from an exception handler."
msgstr ""
"Записує повідомлення з рівнем :const:`ERROR` на кореневому реєстраторі. "
"Аргументи інтерпретуються як для :func:`debug`. Інформація про винятки "
"додається до повідомлення журналу. Цю функцію слід викликати лише з "
"обробника винятків."

msgid ""
"Logs a message with level *level* on the root logger. The other arguments "
"are interpreted as for :func:`debug`."
msgstr ""
"Записує повідомлення з рівнем *level* на кореневому реєстраторі. Інші "
"аргументи інтерпретуються як для :func:`debug`."

msgid ""
"Provides an overriding level *level* for all loggers which takes precedence "
"over the logger's own level. When the need arises to temporarily throttle "
"logging output down across the whole application, this function can be "
"useful. Its effect is to disable all logging calls of severity *level* and "
"below, so that if you call it with a value of INFO, then all INFO and DEBUG "
"events would be discarded, whereas those of severity WARNING and above would "
"be processed according to the logger's effective level. If ``logging."
"disable(logging.NOTSET)`` is called, it effectively removes this overriding "
"level, so that logging output again depends on the effective levels of "
"individual loggers."
msgstr ""
"Забезпечує переважний рівень *рівень* для всіх реєстраторів, який має "
"перевагу над власним рівнем реєстратора. Ця функція може бути корисною, коли "
"виникає потреба тимчасово зменшити вивід журналювання в усій програмі. Його "
"ефект полягає в тому, щоб вимкнути всі виклики журналювання рівня "
"серйозності *рівня* і нижче, так що якщо ви викликаєте його зі значенням "
"INFO, тоді всі події INFO та DEBUG будуть відхилені, тоді як події "
"серйозності WARNING і вище будуть оброблені відповідно до ефективний рівень "
"реєстратора. Якщо викликається ``logging.disable(logging.NOTSET)``, це "
"фактично видаляє цей переважний рівень, так що вихід журналу знову залежить "
"від ефективних рівнів окремих реєстраторів."

msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *level* parameter, but will have to explicitly supply "
"a suitable value."
msgstr ""
"Зауважте, що якщо ви визначили будь-який спеціальний рівень журналювання, "
"вищий за ``КРИТИЧНИЙ`` (це не рекомендовано), ви не зможете покладатися на "
"значення за замовчуванням для параметра *level*, але вам доведеться явно "
"вказати відповідне значення."

msgid ""
"The *level* parameter was defaulted to level ``CRITICAL``. See :issue:"
"`28524` for more information about this change."
msgstr ""
"Параметр *level* за замовчуванням мав рівень ``КРИТИЧНИЙ``. Перегляньте :"
"issue:`28524`, щоб дізнатися більше про цю зміну."

msgid ""
"Associates level *level* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for example "
"when a :class:`Formatter` formats a message. This function can also be used "
"to define your own levels. The only constraints are that all levels used "
"must be registered using this function, levels should be positive integers "
"and they should increase in increasing order of severity."
msgstr ""
"Пов’язує рівень *level* із текстом *levelName* у внутрішньому словнику, який "
"використовується для відображення числових рівнів у текстовому "
"представленні, наприклад, коли :class:`Formatter` форматує повідомлення. Цю "
"функцію також можна використовувати для визначення власних рівнів. Єдині "
"обмеження полягають у тому, що всі використовувані рівні мають бути "
"зареєстровані за допомогою цієї функції, рівні мають бути додатними цілими "
"числами, і вони мають збільшуватися в порядку зростання серйозності."

msgid ""
"If you are thinking of defining your own levels, please see the section on :"
"ref:`custom-levels`."
msgstr ""
"Якщо ви плануєте визначити власні рівні, перегляньте розділ про :ref:`custom-"
"levels`."

msgid "Returns the textual or numeric representation of logging level *level*."
msgstr "Повертає текстове або числове представлення рівня реєстрації *level*."

msgid ""
"If *level* is one of the predefined levels :const:`CRITICAL`, :const:"
"`ERROR`, :const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the "
"corresponding string. If you have associated levels with names using :func:"
"`addLevelName` then the name you have associated with *level* is returned. "
"If a numeric value corresponding to one of the defined levels is passed in, "
"the corresponding string representation is returned."
msgstr ""
"Якщо *level* є одним із попередньо визначених рівнів :const:`CRITICAL`, :"
"const:`ERROR`, :const:`WARNING`, :const:`INFO` або :const:`DEBUG`, тоді ви "
"отримаєте відповідний рядок . Якщо ви пов’язали рівні з іменами за "
"допомогою :func:`addLevelName`, тоді повертається ім’я, яке ви пов’язали з "
"*рівнем*. Якщо передано числове значення, що відповідає одному з визначених "
"рівнів, повертається відповідне представлення рядка."

msgid ""
"The *level* parameter also accepts a string representation of the level such "
"as 'INFO'. In such cases, this functions returns the corresponding numeric "
"value of the level."
msgstr ""
"Параметр *level* також приймає рядкове представлення рівня, наприклад "
"\"INFO\". У таких випадках ця функція повертає відповідне числове значення "
"рівня."

msgid ""
"If no matching numeric or string value is passed in, the string 'Level %s' % "
"level is returned."
msgstr ""
"Якщо відповідного числового або рядкового значення не передано, повертається "
"рядок \"Рівень %s\" % рівня."

msgid ""
"Levels are internally integers (as they need to be compared in the logging "
"logic). This function is used to convert between an integer level and the "
"level name displayed in the formatted log output by means of the "
"``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`), and "
"vice versa."
msgstr ""
"Рівні є внутрішніми цілими числами (оскільки їх потрібно порівнювати в "
"логіці журналювання). Ця функція використовується для перетворення між "
"цілочисельним рівнем і назвою рівня, що відображається у форматованому "
"виведенні журналу за допомогою специфікатора формату ``%(levelname)s`` "
"(див. :ref:`logrecord-attributes`), і навпаки."

msgid ""
"In Python versions earlier than 3.4, this function could also be passed a "
"text level, and would return the corresponding numeric value of the level. "
"This undocumented behaviour was considered a mistake, and was removed in "
"Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility."
msgstr ""
"У версіях Python, раніших за 3.4, ця функція також могла передаватися на "
"текстовий рівень і повертала б відповідне числове значення рівня. Ця "
"незадокументована поведінка вважалася помилкою та була видалена в Python "
"3.4, але відновлена в 3.4.2 через збереження зворотної сумісності."

msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes are "
"defined by *attrdict*. This function is useful for taking a pickled :class:"
"`LogRecord` attribute dictionary, sent over a socket, and reconstituting it "
"as a :class:`LogRecord` instance at the receiving end."
msgstr ""
"Створює та повертає новий екземпляр :class:`LogRecord`, атрибути якого "
"визначено *attrdict*. Ця функція корисна для того, щоб взяти вибраний "
"словник атрибутів :class:`LogRecord`, надісланий через сокет, і відтворити "
"його як екземпляр :class:`LogRecord` на кінці прийому."

msgid ""
"Does basic configuration for the logging system by creating a :class:"
"`StreamHandler` with a default :class:`Formatter` and adding it to the root "
"logger. The functions :func:`debug`, :func:`info`, :func:`warning`, :func:"
"`error` and :func:`critical` will call :func:`basicConfig` automatically if "
"no handlers are defined for the root logger."
msgstr ""
"Виконує базову конфігурацію для системи журналювання, створюючи :class:"
"`StreamHandler` із стандартним :class:`Formatter` і додаючи його до "
"кореневого реєстратора. Функції :func:`debug`, :func:`info`, :func:"
"`warning`, :func:`error` і :func:`critical` викличуть :func:`basicConfig` "
"автоматично, якщо не визначено обробників для кореневого реєстратора."

msgid ""
"This function does nothing if the root logger already has handlers "
"configured, unless the keyword argument *force* is set to ``True``."
msgstr ""
"Ця функція нічого не робить, якщо кореневий реєстратор уже має налаштовані "
"обробники, якщо для ключового аргументу *force* не встановлено значення "
"``True``."

msgid ""
"This function should be called from the main thread before other threads are "
"started. In versions of Python prior to 2.7.1 and 3.2, if this function is "
"called from multiple threads, it is possible (in rare circumstances) that a "
"handler will be added to the root logger more than once, leading to "
"unexpected results such as messages being duplicated in the log."
msgstr ""
"Цю функцію слід викликати з основного потоку перед запуском інших потоків. У "
"версіях Python до 2.7.1 і 3.2, якщо ця функція викликається з кількох "
"потоків, можливо (у рідкісних випадках), що обробник буде додано до "
"кореневого журналу більше одного разу, що призведе до неочікуваних "
"результатів, таких як повідомлення дублюється в журналі."

msgid "The following keyword arguments are supported."
msgstr "Підтримуються наступні аргументи ключових слів."

msgid "*filename*"
msgstr "*назва файлу*"

msgid ""
"Specifies that a :class:`FileHandler` be created, using the specified "
"filename, rather than a :class:`StreamHandler`."
msgstr ""
"Вказує, що буде створено :class:`FileHandler`, використовуючи вказане ім’я "
"файлу, а не :class:`StreamHandler`."

msgid "*filemode*"
msgstr "*файловий режим*"

msgid ""
"If *filename* is specified, open the file in this :ref:`mode <filemodes>`. "
"Defaults to ``'a'``."
msgstr ""
"Якщо вказано *ім’я файлу*, відкрийте файл у цьому :ref:`режимі <filemodes>`. "
"За замовчуванням ``'a''``."

msgid "*format*"
msgstr "*формат*"

msgid ""
"Use the specified format string for the handler. Defaults to attributes "
"``levelname``, ``name`` and ``message`` separated by colons."
msgstr ""
"Використовуйте вказаний рядок формату для обробника. За замовчуванням "
"атрибути ``levelname``, ``name`` і ``message``, розділені двокрапками."

msgid "*datefmt*"
msgstr "*datefmt*"

msgid ""
"Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr ""
"Використовуйте вказаний формат дати/часу, прийнятний :func:`time.strftime`."

msgid "*style*"
msgstr "*стиль*"

msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` respectively. "
"Defaults to ``'%'``."
msgstr ""
"Якщо вказано *format*, використовуйте цей стиль для рядка формату. Один із "
"``'%'``, ``'{'`` або ``'$'`` для :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` або :class:`string .Template` відповідно. "
"За замовчуванням ``'%''``."

msgid "*level*"
msgstr "*рівень*"

msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr ""
"Встановіть рівень кореневого реєстратора на вказаний :ref:`level <levels>`."

msgid "*stream*"
msgstr "*потік*"

msgid ""
"Use the specified stream to initialize the :class:`StreamHandler`. Note that "
"this argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""
"Використовуйте вказаний потік для ініціалізації :class:`StreamHandler`. "
"Зауважте, що цей аргумент несумісний з *ім’ям файлу* – якщо присутні обидва, "
"виникає помилка \"ValueError\"."

msgid "*handlers*"
msgstr "*обробники*"

msgid ""
"If specified, this should be an iterable of already created handlers to add "
"to the root logger. Any handlers which don't already have a formatter set "
"will be assigned the default formatter created in this function. Note that "
"this argument is incompatible with *filename* or *stream* - if both are "
"present, a ``ValueError`` is raised."
msgstr ""
"Якщо вказано, це має бути ітерація вже створених обробників для додавання до "
"кореневого реєстратора. Усім обробникам, які ще не мають встановленого "
"форматера, буде призначено стандартний форматер, створений у цій функції. "
"Зауважте, що цей аргумент несумісний з *filename* або *stream* - якщо обидва "
"присутні, виникає помилка ValueError."

msgid "*force*"
msgstr "*сила*"

msgid ""
"If this keyword argument is specified as true, any existing handlers "
"attached to the root logger are removed and closed, before carrying out the "
"configuration as specified by the other arguments."
msgstr ""
"Якщо цей аргумент ключового слова вказано як true, будь-які існуючі "
"обробники, приєднані до кореневого реєстратора, видаляються та закриваються "
"перед виконанням конфігурації, як зазначено іншими аргументами."

msgid "*encoding*"
msgstr "*кодування*"

msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file."
msgstr ""
"Якщо цей аргумент ключового слова вказано разом із *filename*, його значення "
"використовується під час створення :class:`FileHandler` і, таким чином, "
"використовується під час відкриття вихідного файлу."

msgid "*errors*"
msgstr "*помилки*"

msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file. If not specified, the value 'backslashreplace' is used. "
"Note that if ``None`` is specified, it will be passed as such to :func:"
"`open`, which means that it will be treated the same as passing 'errors'."
msgstr ""
"Якщо цей аргумент ключового слова вказано разом із *filename*, його значення "
"використовується під час створення :class:`FileHandler` і, таким чином, "
"використовується під час відкриття вихідного файлу. Якщо не вказано, "
"використовується значення \"backslashreplace\". Зауважте, що якщо вказано "
"``None``, воно буде передано як таке до :func:`open`, що означає, що воно "
"розглядатиметься так само, як передача 'errors'."

msgid "The *style* argument was added."
msgstr "Додано аргумент *style*."

msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with *filename*)."
msgstr ""
"Додано аргумент *обробники*. Було додано додаткові перевірки для виявлення "
"ситуацій, коли вказано несумісні аргументи (наприклад, *обробники* разом із "
"*потоком* або *ім’ям файлу*, або *потік* разом із *ім’ям файлу*)."

msgid "The *force* argument was added."
msgstr "Додано аргумент *force*."

msgid "The *encoding* and *errors* arguments were added."
msgstr "Додано аргументи *encoding* і *errors*."

msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and "
"closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr ""
"Повідомляє системі журналювання виконати впорядковане завершення роботи "
"шляхом очищення та закриття всіх обробників. Це слід викликати під час "
"виходу з програми, і після цього виклику не слід використовувати систему "
"журналювання."

msgid ""
"When the logging module is imported, it registers this function as an exit "
"handler (see :mod:`atexit`), so normally there's no need to do that manually."
msgstr ""
"Коли модуль журналювання імпортовано, він реєструє цю функцію як обробник "
"виходу (див. :mod:`atexit`), тому зазвичай немає потреби робити це вручну."

msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`__init__` such that only a name "
"argument is required, and the :meth:`__init__` should call :meth:`Logger."
"__init__`. This function is typically called before any loggers are "
"instantiated by applications which need to use custom logger behavior. After "
"this call, as at any other time, do not instantiate loggers directly using "
"the subclass: continue to use the :func:`logging.getLogger` API to get your "
"loggers."
msgstr ""
"Вказує системі ведення журналу використовувати клас *klass* під час "
"створення екземпляра реєстратора. Клас має визначати :meth:`__init__` таким "
"чином, щоб потрібен був лише аргумент імені, а :meth:`__init__` має "
"викликати :meth:`Logger.__init__`. Ця функція зазвичай викликається перед "
"створенням будь-яких реєстраторів програмами, які потребують використання "
"власної поведінки реєстратора. Після цього виклику, як і в будь-який інший "
"час, не створюйте екземпляри реєстраторів безпосередньо за допомогою "
"підкласу: продовжуйте використовувати :func:`logging.getLogger` API, щоб "
"отримати свої журнали."

msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr ""
"Встановіть виклик, який використовується для створення :class:`LogRecord`."

msgid "The factory callable to be used to instantiate a log record."
msgstr ""
"Фабричний виклик, який буде використано для створення екземпляра запису "
"журналу."

msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"Цю функцію було надано разом із :func:`getLogRecordFactory`, щоб дозволити "
"розробникам більше контролювати те, як створюється :class:`LogRecord`, що "
"представляє подію журналювання."

msgid "The factory has the following signature:"
msgstr "Завод має такий підпис:"

msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"
msgstr ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"

msgid "The logger name."
msgstr "Ім'я реєстратора."

msgid "level"
msgstr "рівень"

msgid "The logging level (numeric)."
msgstr "Рівень журналювання (числовий)."

msgid "fn"
msgstr "фн"

msgid "The full pathname of the file where the logging call was made."
msgstr "Повний шлях до файлу, у якому було здійснено виклик журналювання."

msgid "lno"
msgstr "льно"

msgid "The line number in the file where the logging call was made."
msgstr "Номер рядка у файлі, де було здійснено виклик журналювання."

msgid "The logging message."
msgstr "Повідомлення реєстрації."

msgid "The arguments for the logging message."
msgstr "Аргументи для повідомлення журналу."

msgid "An exception tuple, or ``None``."
msgstr "Кортеж винятків або ``None``."

msgid "func"
msgstr "функц"

msgid "The name of the function or method which invoked the logging call."
msgstr "Ім'я функції або методу, які викликали журналювання."

msgid "sinfo"
msgstr "sinfo"

msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr ""
"Зворотне трасування стека, наприклад, надається :func:`traceback."
"print_stack`, показуючи ієрархію викликів."

msgid "kwargs"
msgstr "kwargs"

msgid "Additional keyword arguments."
msgstr "Додаткові аргументи ключових слів."

msgid "Module-Level Attributes"
msgstr "Атрибути рівня модуля"

msgid ""
"A \"handler of last resort\" is available through this attribute. This is a :"
"class:`StreamHandler` writing to ``sys.stderr`` with a level of ``WARNING``, "
"and is used to handle logging events in the absence of any logging "
"configuration. The end result is to just print the message to ``sys."
"stderr``. This replaces the earlier error message saying that \"no handlers "
"could be found for logger XYZ\". If you need the earlier behaviour for some "
"reason, ``lastResort`` can be set to ``None``."
msgstr ""
"Через цей атрибут доступний \"обробник останньої надії\". Це :class:"
"`StreamHandler`, який записує в ``sys.stderr`` з рівнем ``WARNING`` і "
"використовується для обробки подій журналювання за відсутності будь-якої "
"конфігурації журналювання. Кінцевим результатом є просто друк повідомлення в "
"``sys.stderr``. Це замінює попереднє повідомлення про помилку про те, що "
"\"не вдалося знайти обробників для реєстратора XYZ\". Якщо з якоїсь причини "
"вам потрібна попередня поведінка, для lastResort можна встановити значення "
"None."

msgid "Integration with the warnings module"
msgstr "Інтеграція з модулем попереджень"

msgid ""
"The :func:`captureWarnings` function can be used to integrate :mod:`logging` "
"with the :mod:`warnings` module."
msgstr ""
"Функцію :func:`captureWarnings` можна використовувати для інтеграції :mod:"
"`logging` з модулем :mod:`warnings`."

msgid ""
"This function is used to turn the capture of warnings by logging on and off."
msgstr ""
"Ця функція використовується для ввімкнення та вимкнення захоплення "
"попереджень під час входу."

msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module will "
"be redirected to the logging system. Specifically, a warning will be "
"formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of :const:"
"`WARNING`."
msgstr ""
"Якщо *capture* має значення ``True``, попередження, видані модулем :mod:"
"`warnings`, будуть перенаправлені до системи журналювання. Зокрема, "
"попередження буде відформатовано за допомогою :func:`warnings."
"formatwarning`, а результуючий рядок буде зареєстровано в журналі під назвою "
"``'py.warnings`` з серйозністю :const:`WARNING`."

msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging system "
"will stop, and warnings will be redirected to their original destinations (i."
"e. those in effect before ``captureWarnings(True)`` was called)."
msgstr ""
"Якщо *capture* має значення ``False``, перенаправлення попереджень до "
"системи журналювання припиниться, і попередження будуть перенаправлені до "
"початкових місць призначення (тобто тих, які діяли до виклику "
"``captureWarnings(True)``)."

msgid "Module :mod:`logging.config`"
msgstr "Модуль :mod:`logging.config`"

msgid "Configuration API for the logging module."
msgstr "API конфігурації для модуля журналювання."

msgid "Module :mod:`logging.handlers`"
msgstr "Модуль :mod:`logging.handlers`"

msgid "Useful handlers included with the logging module."
msgstr "Корисні обробники, включені в модуль журналювання."

msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - Система реєстрації"

msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr ""
"Пропозиція, яка описує цю функцію для включення в стандартну бібліотеку "
"Python."

msgid ""
"`Original Python logging package <https://old.red-dove.com/python_logging."
"html>`_"
msgstr ""
"`Оригінальний пакет журналювання Python <https://old.red-dove.com/"
"python_logging.html>`_"

msgid ""
"This is the original source for the :mod:`logging` package.  The version of "
"the package available from this site is suitable for use with Python 1.5.2, "
"2.1.x and 2.2.x, which do not include the :mod:`logging` package in the "
"standard library."
msgstr ""
"Це оригінальне джерело пакета :mod:`logging`. Версія пакета, доступна на "
"цьому сайті, підходить для використання з Python 1.5.2, 2.1.x і 2.2.x, які "
"не містять пакет :mod:`logging` у стандартній бібліотеці."
