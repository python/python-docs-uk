# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`shutil` --- High-level file operations"
msgstr ":mod:`shutil` --- Високорівневі операції з файлами"

msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**Вихідний код:** :source:`Lib/shutil.py`"

msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
"Модуль :mod:`shutil` пропонує низку високорівневих операцій над файлами та "
"колекціями файлів. Зокрема, передбачені функції, які підтримують копіювання "
"та видалення файлів. Для операцій з окремими файлами дивіться також модуль :"
"mod:`os`."

msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"Навіть функції копіювання файлів вищого рівня (:func:`shutil.copy`, :func:"
"`shutil.copy2`) не можуть скопіювати всі метадані файлу."

msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""
"На платформах POSIX це означає, що власник файлу та група втрачаються, а "
"також ACL. У Mac OS форк ресурсів та інші метадані не використовуються. Це "
"означає, що ресурси буде втрачено, а тип файлу та коди творця будуть "
"неправильними. У Windows власники файлів, ACL та альтернативні потоки даних "
"не копіюються."

msgid "Directory and files operations"
msgstr "Операції з каталогами та файлами"

msgid ""
"Copy the contents of the file-like object *fsrc* to the file-like object "
"*fdst*. The integer *length*, if given, is the buffer size. In particular, a "
"negative *length* value means to copy the data without looping over the "
"source data in chunks; by default the data is read in chunks to avoid "
"uncontrolled memory consumption. Note that if the current file position of "
"the *fsrc* object is not 0, only the contents from the current file position "
"to the end of the file will be copied."
msgstr ""
"Скопіюйте вміст файлоподібного об’єкта *fsrc* до файлоподібного об’єкта "
"*fdst*. Ціле число *length*, якщо вказано, є розміром буфера. Зокрема, "
"від’ємне значення *length* означає копіювання даних без циклічного перегляду "
"вихідних даних порціями; за замовчуванням дані зчитуються частинами, щоб "
"уникнути неконтрольованого споживання пам'яті. Зауважте, що якщо поточна "
"позиція файлу об’єкта *fsrc* не дорівнює 0, буде скопійовано лише вміст із "
"поточної позиції файлу до кінця файлу."

msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are path-like objects or path names given as strings."
msgstr ""
"Скопіюйте вміст (без метаданих) файлу з назвою *src* у файл з назвою *dst* і "
"поверніть *dst* найефективнішим способом. *src* і *dst* є об’єктами, "
"подібними до шляху, або іменами шляхів, поданими у вигляді рядків."

msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* має бути повним ім’ям цільового файлу; подивіться на :func:`~shutil."
"copy` копію, яка приймає шлях цільового каталогу. Якщо *src* і *dst* "
"вказують той самий файл, виникає :exc:`SameFileError`."

msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"Місце призначення має бути доступним для запису; інакше буде викликано "
"виняток :exc:`OSError`. Якщо *dst* вже існує, його буде замінено. За "
"допомогою цієї функції неможливо скопіювати спеціальні файли, такі як "
"символьні або блокові пристрої та канали."

msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* є символічним посиланням, "
"замість копіювання файлу, на який вказує *src*, буде створено нове "
"символічне посилання."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copyfile`` з аргументами "
"``src``, ``dst``."

msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"Раніше викликалося :exc:`IOError` замість :exc:`OSError`. Додано аргумент "
"*follow_symlinks*. Тепер повертає *dst*."

msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"Викликати :exc:`SameFileError` замість :exc:`Error`. Оскільки перший є "
"підкласом останнього, ця зміна є зворотно сумісною."

msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy "
"the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"Спеціальні для платформи системні виклики швидкого копіювання можуть "
"використовуватися внутрішньо для більш ефективного копіювання файлу. "
"Перегляньте розділ :ref:`shutil-platform-dependent-efficient-copy-"
"operations`."

msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ""
"Цей виняток виникає, якщо джерело та призначення у :func:`copyfile` є одним "
"і тим самим файлом."

msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are path-like objects or path names "
"given as strings. If *follow_symlinks* is false, and both *src* and *dst* "
"are symbolic links, :func:`copymode` will attempt to modify the mode of "
"*dst* itself (rather than the file it points to).  This functionality is not "
"available on every platform; please see :func:`copystat` for more "
"information.  If :func:`copymode` cannot modify symbolic links on the local "
"platform, and it is asked to do so, it will do nothing and return."
msgstr ""
"Скопіюйте біти дозволу з *src* в *dst*. Вміст файлу, власник і група "
"залишаються незмінними. *src* і *dst* є об’єктами, подібними до шляху, або "
"іменами шляхів, поданими у вигляді рядків. Якщо *follow_symlinks* має "
"значення false, а *src* і *dst* є символічними посиланнями, :func:`copymode` "
"намагатиметься змінити режим самого *dst* (а не файлу, на який він вказує). "
"Ця функція доступна не на всіх платформах; див. :func:`copystat` для "
"отримання додаткової інформації. Якщо :func:`copymode` не може змінити "
"символічні посилання на локальній платформі, і його попросять це зробити, "
"він нічого не зробить і повернеться."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copymode`` з аргументами "
"``src``, ``dst``."

msgid "Added *follow_symlinks* argument."
msgstr "Додано аргумент *follow_symlinks*."

msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group "
"are unaffected.  *src* and *dst* are path-like objects or path names given "
"as strings."
msgstr ""
"Скопіюйте біти дозволу, час останнього доступу, час останньої модифікації та "
"прапорці з *src* до *dst*. У Linux :func:`copystat` також копіює \"розширені "
"атрибути\", де це можливо. Вміст файлу, власник і група залишаються "
"незмінними. *src* і *dst* є об’єктами, подібними до шляху, або іменами "
"шляхів, поданими у вигляді рядків."

msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather "
"than the files the symbolic links refer to—reading the information from the "
"*src* symbolic link, and writing the information to the *dst* symbolic link."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* і *dst* посилаються на "
"символічні посилання, :func:`copystat` працюватиме з самими символьними "
"посиланнями, а не з файлами, на які посилаються символічні посилання, "
"зчитуючи інформацію з *символьне посилання src* і запис інформації до "
"символічного посилання *dst*."

msgid ""
"Not all platforms provide the ability to examine and modify symbolic links.  "
"Python itself can tell you what functionality is locally available."
msgstr ""
"Не всі платформи надають можливість перевіряти та змінювати символічні "
"посилання. Python сам може сказати вам, які функції доступні локально."

msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the permission bits of a symbolic link."
msgstr ""
"Якщо ``os.chmod в os.supports_follow_symlinks`` має значення ``True``, :func:"
"`copystat` може змінити біти дозволу символічного посилання."

msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the last access and modification times of a symbolic link."
msgstr ""
"Якщо ``os.utime в os.supports_follow_symlinks`` має значення ``True``, :func:"
"`copystat` може змінити час останнього доступу та модифікації символічного "
"посилання."

msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, :func:"
"`copystat` can modify the flags of a symbolic link.  (``os.chflags`` is not "
"available on all platforms.)"
msgstr ""
"Якщо ``os.chflags в os.supports_follow_symlinks`` має значення ``True``, :"
"func:`copystat` може змінювати прапорці символічного посилання. (``os."
"chflags`` доступний не на всіх платформах.)"

msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"На платформах, де деякі або всі ці функції недоступні, коли буде "
"запропоновано змінити символічне посилання, :func:`copystat` скопіює все, що "
"зможе. :func:`copystat` ніколи не повертає помилку."

msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr ""
"Для отримання додаткової інформації перегляньте :data:`os."
"supports_follow_symlinks`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copystat`` з аргументами "
"``src``, ``dst``."

msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr ""
"Додано аргумент *follow_symlinks* і підтримку розширених атрибутів Linux."

msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst* "
"specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"Копіює файл *src* у файл або каталог *dst*. *src* і *dst* повинні бути :term:"
"`шляховими об’єктами <path-like object>` або рядками. Якщо *dst* визначає "
"каталог, файл буде скопійовано в *dst* з використанням базового імені файлу "
"з *src*. Якщо *dst* вказує на файл, який уже існує, його буде замінено. "
"Повертає шлях до щойно створеного файлу."

msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* є символічним посиланням, "
"*dst* буде створено як символічне посилання. Якщо *follow_symlinks* має "
"значення true і *src* є символічним посиланням, *dst* буде копією файлу, на "
"який посилається *src*."

msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the "
"original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` копіює дані файлу та режим дозволу файлу (див. :func:"
"`os.chmod`). Інші метадані, наприклад час створення та модифікації файлу, не "
"зберігаються. Щоб зберегти всі метадані файлу з оригіналу, замість цього "
"використовуйте :func:`~shutil.copy2`."

msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created file."
msgstr ""
"Додано аргумент *follow_symlinks*. Тепер повертає шлях до щойно створеного "
"файлу."

msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to "
"preserve file metadata."
msgstr ""
"Ідентичний :func:`~shutil.copy` за винятком того, що :func:`copy2` також "
"намагається зберегти метадані файлу."

msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2` "
"attempts to copy all metadata from the *src* symbolic link to the newly-"
"created *dst* symbolic link. However, this functionality is not available on "
"all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; :func:"
"`copy2` never raises an exception because it cannot preserve file metadata."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* є символічним "
"посиланням, :func:`copy2` намагається скопіювати всі метадані з символічного "
"посилання *src* до щойно створеного символічного посилання *dst*. Однак ця "
"функція доступна не на всіх платформах. На платформах, де деякі або всі ці "
"функції недоступні, :func:`copy2` збереже всі метадані, які зможе; :func:"
"`copy2` ніколи не викликає винятків, оскільки не може зберегти метадані "
"файлу."

msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see :"
"func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` використовує :func:`copystat` для копіювання метаданих файлу. "
"Перегляньте :func:`copystat` для отримання додаткової інформації про "
"підтримку платформи для зміни метаданих символічних посилань."

msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created "
"file."
msgstr ""
"Додано аргумент *follow_symlinks*, також спробуйте скопіювати розширені "
"атрибути файлової системи (наразі лише для Linux). Тепер повертає шлях до "
"щойно створеного файлу."

msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"Ця фабрична функція створює функцію, яку можна використовувати як виклик для "
"аргументу *ignore* :func:`copytree`\\, ігноруючи файли та каталоги, які "
"відповідають одному з наданих *шаблонів* стилю glob. Дивіться приклад нижче."

msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"Рекурсивно скопіюйте все дерево каталогів із коренем *src* до каталогу з "
"назвою *dst* і поверніть каталог призначення. Усі проміжні каталоги, які "
"повинні містити *dst*, також будуть створені за замовчуванням."

msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"Дозволи та час каталогів копіюються за допомогою :func:`copystat`, окремі "
"файли копіюються за допомогою :func:`~shutil.copy2`."

msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"Якщо *symlinks* має значення true, символічні посилання у вихідному дереві "
"представлені як символічні посилання в новому дереві, а метадані "
"оригінальних посилань буде скопійовано, наскільки це дозволяє платформа; "
"якщо false або пропущено, вміст і метадані пов’язаних файлів копіюються до "
"нового дерева."

msgid ""
"When *symlinks* is false, if the file pointed by the symlink doesn't exist, "
"an exception will be added in the list of errors raised in an :exc:`Error` "
"exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"Якщо *symlinks* має значення false, якщо файл, на який вказує символічне "
"посилання, не існує, виняток буде додано до списку помилок, викликаних "
"винятком :exc:`Error` наприкінці процесу копіювання. Ви можете встановити "
"необов’язковий прапорець *ignore_dangling_symlinks* на true, якщо ви хочете "
"вимкнути цей виняток. Зауважте, що цей параметр не діє на платформах, які не "
"підтримують :func:`os.symlink`."

msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""
"Якщо задано *ignore*, це має бути виклик, який отримає як аргументи каталог, "
"який відвідує :func:`copytree`, і список його вмісту, який повертає :func:"
"`os.listdir`. Оскільки :func:`copytree` викликається рекурсивно, *ignore* "
"викликається один раз для кожного каталогу, який копіюється. Викликаний має "
"повертати послідовність імен каталогу та файлу відносно поточного каталогу "
"(тобто підмножину елементів у другому аргументі); ці імена будуть "
"проігноровані в процесі копіювання. :func:`ignore_patterns` можна "
"використати для створення такого виклику, який ігнорує імена на основі "
"шаблонів у стилі glob."

msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""
"Якщо трапляються винятки, виникає повідомлення :exc:`Error` зі списком "
"причин."

msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"Якщо задано *copy_function*, це має бути виклик, який використовуватиметься "
"для копіювання кожного файлу. Він буде викликаний із вихідним шляхом і "
"цільовим шляхом як аргументами. За замовчуванням використовується :func:"
"`~shutil.copy2`, але можна використовувати будь-яку функцію, яка підтримує "
"такий самий підпис (наприклад, :func:`~shutil.copy`)."

msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a :exc:"
"`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"Якщо *dirs_exist_ok* має значення false (за замовчуванням), а *dst* уже "
"існує, виникає :exc:`FileExistsError`. Якщо *dirs_exist_ok* має значення "
"true, операція копіювання продовжуватиметься, якщо буде виявлено існуючі "
"каталоги, а файли в дереві *dst* будуть перезаписані відповідними файлами з "
"дерева *src*."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copytree`` з аргументами "
"``src``, ``dst``."

msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr ""
"Копіювати метадані, якщо *symlinks* має значення false. Тепер повертає *dst*."

msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"Додано аргумент *copy_function*, щоб мати можливість надати спеціальну "
"функцію копіювання. Додано аргумент *ignore_dangling_symlinks*, щоб вимкнути "
"помилки висячих символьних посилань, коли *symlinks* має значення false."

msgid "The *dirs_exist_ok* parameter."
msgstr "Параметр *dirs_exist_ok*."

msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onerror* or, if that is omitted, "
"they raise an exception."
msgstr ""
"Видалити все дерево каталогів; *шлях* має вказувати на каталог (але не "
"символічне посилання на каталог). Якщо *ignore_errors* має значення true, "
"помилки, що виникли внаслідок невдалого видалення, ігноруватимуться; якщо "
"false або пропущено, такі помилки обробляються шляхом виклику обробника, "
"визначеного *onerror* або, якщо це опущено, вони викликають виняток."

msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms, "
"the :func:`rmtree` implementation is susceptible to a symlink attack: given "
"proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"На платформах, які підтримують необхідні функції на основі fd, за "
"замовчуванням використовується стійка до атак символічних посилань версія :"
"func:`rmtree`. На інших платформах реалізація :func:`rmtree` чутлива до "
"атаки через символічні посилання: за належного часу та обставин зловмисники "
"можуть маніпулювати символічними посиланнями у файловій системі, щоб "
"видалити файли, до яких вони не мали б доступу інакше. Програми можуть "
"використовувати атрибут функції :data:`rmtree.avoids_symlink_attacks`, щоб "
"визначити, який регістр застосовний."

msgid ""
"If *onerror* is provided, it must be a callable that accepts three "
"parameters: *function*, *path*, and *excinfo*."
msgstr ""
"Якщо вказано *onerror*, це має бути виклик, який приймає три параметри: "
"*function*, *path* і *excinfo*."

msgid ""
"The first parameter, *function*, is the function which raised the exception; "
"it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, will be the exception information returned by :func:`sys."
"exc_info`.  Exceptions raised by *onerror* will not be caught."
msgstr ""
"Перший параметр, *function*, це функція, яка викликала виняток; це залежить "
"від платформи та реалізації. Другий параметр, *шлях*, буде іменем шляху, "
"переданим до *функції*. Третій параметр, *excinfo*, буде інформацією про "
"винятки, яку повертає :func:`sys.exc_info`. Винятки, викликані *onerror*, не "
"будуть перехоплені."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with argument "
"``path``."
msgstr ""

msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"Додано версію, стійку до атак символічних посилань, яка використовується "
"автоматично, якщо платформа підтримує функції на основі fd."

msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr ""
"У Windows більше не буде видаляти вміст з’єднання каталогу перед видаленням "
"з’єднання."

msgid ""
"Indicates whether the current platform and implementation provides a symlink "
"attack resistant version of :func:`rmtree`.  Currently this is only true for "
"platforms supporting fd-based directory access functions."
msgstr ""
"Вказує, чи поточна платформа та реалізація забезпечують стійку до атак "
"символічних посилань версію :func:`rmtree`. Наразі це стосується лише "
"платформ, які підтримують функції доступу до каталогу на основі fd."

msgid ""
"Recursively move a file or directory (*src*) to another location (*dst*) and "
"return the destination."
msgstr ""
"Рекурсивно перемістіть файл або каталог (*src*) в інше місце (*dst*) і "
"поверніть місце призначення."

msgid ""
"If the destination is an existing directory, then *src* is moved inside that "
"directory. If the destination already exists but is not a directory, it may "
"be overwritten depending on :func:`os.rename` semantics."
msgstr ""
"Якщо призначенням є існуючий каталог, тоді *src* переміщується всередину "
"цього каталогу. Якщо місце призначення вже існує, але не є каталогом, воно "
"може бути перезаписано залежно від семантики :func:`os.rename`."

msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to *dst* using *copy_function* and then "
"removed.  In case of symlinks, a new symlink pointing to the target of *src* "
"will be created in or as *dst* and *src* will be removed."
msgstr ""
"Якщо місцем призначення є поточна файлова система, тоді використовується :"
"func:`os.rename`. В іншому випадку *src* копіюється в *dst* за допомогою "
"*copy_function*, а потім видаляється. У випадку символічних посилань нове "
"символічне посилання, що вказує на ціль *src*, буде створено в або як *dst* "
"і *src* буде видалено."

msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments "
"*src* and *dst*, and will be used to copy *src* to *dst* if :func:`os."
"rename` cannot be used.  If the source is a directory, :func:`copytree` is "
"called, passing it the :func:`copy_function`. The default *copy_function* "
"is :func:`copy2`.  Using :func:`~shutil.copy` as the *copy_function* allows "
"the move to succeed when it is not possible to also copy the metadata, at "
"the expense of not copying any of the metadata."
msgstr ""
"Якщо надано *copy_function*, це має бути виклик, який приймає два аргументи "
"*src* і *dst*, і використовуватиметься для копіювання *src* до *dst*, якщо :"
"func:`os.rename` не можна використовувати. Якщо джерелом є каталог, "
"викликається :func:`copytree`, передаючи йому :func:`copy_function`. Типовою "
"*copy_function* є :func:`copy2`. Використання :func:`~shutil.copy` як "
"*copy_function* дозволяє переміщенню бути успішним, коли неможливо також "
"скопіювати метадані, за рахунок відсутності копіювання будь-яких метаданих."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.move`` з аргументами "
"``src``, ``dst``."

msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to "
"the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"Додано явну обробку символічних посилань для іноземних файлових систем, "
"таким чином адаптуючи її до поведінки GNU :program:`mv`. Тепер повертає "
"*dst*."

msgid "Added the *copy_function* keyword argument."
msgstr "Додано аргумент ключового слова *copy_function*."

msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "Приймає :term:`path-like object` для *src* і *dst*."

msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"Повертає статистику використання диска щодо заданого шляху як :term:`named "
"tuple` з атрибутами *total*, *used* і *free*, які є обсягом загального, "
"використаного та вільного простору в байтах. *шлях* може бути файлом або "
"каталогом."

msgid "On Windows, *path* can now be a file or directory."
msgstr "У Windows *шлях* тепер може бути файлом або каталогом."

msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Наявність <availability>`: Unix, Windows."

msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "Змінити власника *користувача* та/або *групу* вказаного *шляху*."

msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr ""
"*user* може бути системним іменем користувача або uid; те саме стосується "
"*групи*. Потрібен принаймні один аргумент."

msgid "See also :func:`os.chown`, the underlying function."
msgstr "Дивіться також :func:`os.chown`, базову функцію."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.chown`` з аргументами "
"``path``, ``user``, ``group``."

msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Наявність <availability>`: Unix."

msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"Повертає шлях до виконуваного файлу, який буде запущено, якщо буде викликано "
"заданий *cmd*. Якщо *cmd* не буде викликано, поверніть ``None``."

msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and executable."
msgstr ""
"*mode* — це маска дозволу, яка передається в :func:`os.access`, за "
"замовчуванням визначає, чи файл існує та є виконуваним."

msgid ""
"When no *path* is specified, the results of :func:`os.environ` are used, "
"returning either the \"PATH\" value or a fallback of :attr:`os.defpath`."
msgstr ""
"Якщо *path* не вказано, використовуються результати :func:`os.environ`, "
"повертаючи або значення \"PATH\", або резервний варіант :attr:`os.defpath`."

msgid ""
"On Windows, the current directory is always prepended to the *path* whether "
"or not you use the default or provide your own, which is the behavior the "
"command shell uses when finding executables.  Additionally, when finding the "
"*cmd* in the *path*, the ``PATHEXT`` environment variable is checked.  For "
"example, if you call ``shutil.which(\"python\")``, :func:`which` will search "
"``PATHEXT`` to know that it should look for ``python.exe`` within the *path* "
"directories.  For example, on Windows::"
msgstr ""
"У Windows поточний каталог завжди додається до *шляху* незалежно від того, "
"використовуєте ви за замовчуванням чи вказуєте свій власний, що є поведінкою "
"командної оболонки під час пошуку виконуваних файлів. Крім того, при "
"знаходженні *cmd* у *шляху* перевіряється змінна середовища ``PATHEXT``. "
"Наприклад, якщо ви викликаєте ``shutil.which(\"python\")``, :func:`which` "
"шукатиме ``PATHEXT``, щоб знати, що він повинен шукати ``python.exe`` у "
"*шляху* довідники. Наприклад, у Windows::"

msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"Тип :class:`bytes` тепер прийнятний. Якщо тип *cmd* :class:`bytes`, тип "
"результату також :class:`bytes`."

msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"Цей виняток збирає винятки, які виникають під час операції з кількома "
"файлами. Для :func:`copytree` аргумент винятку — це список із 3-х кортежів "
"(*srcname*, *dstname*, *exception*)."

msgid "Platform-dependent efficient copy operations"
msgstr "Залежні від платформи ефективні операції копіювання"

msgid ""
"Starting from Python 3.8, all functions involving a file copy (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, and :func:"
"`move`) may use platform-specific \"fast-copy\" syscalls in order to copy "
"the file more efficiently (see :issue:`33671`). \"fast-copy\" means that the "
"copying operation occurs within the kernel, avoiding the use of userspace "
"buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"Починаючи з Python 3.8, усі функції, пов’язані з копіюванням файлу (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree` та :func:"
"`move` ) може використовувати специфічні для платформи системні виклики "
"\"швидкого копіювання\" для більш ефективного копіювання файлу (див. :issue:"
"`33671`). \"швидке копіювання\" означає, що операція копіювання відбувається "
"всередині ядра, уникаючи використання буферів простору користувача в Python, "
"як у \"``outfd.write(infd.read())``\"."

msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr ""
"У macOS `fcopyfile`_ використовується для копіювання вмісту файлу (а не "
"метаданих)."

msgid "On Linux :func:`os.sendfile` is used."
msgstr "У Linux використовується :func:`os.sendfile`."

msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of :func:`shutil."
"copyfileobj` is used."
msgstr ""
"У Windows :func:`shutil.copyfile` використовує більший розмір буфера за "
"замовчуванням (1 МіБ замість 64 КіБ) і використовується варіант :func:"
"`memoryview` на основі :func:`shutil.copyfileobj`."

msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient :func:"
"`copyfileobj` function internally."
msgstr ""
"Якщо операція швидкого копіювання зазнала невдачі і дані не були записані в "
"цільовий файл, програма shutil мовчки повернеться до використання менш "
"ефективної внутрішньої функції :func:`copyfileobj`."

msgid "copytree example"
msgstr "приклад копіювання"

msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "Приклад, який використовує помічник :func:`ignore_patterns`::"

msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"Буде скопійовано все, крім файлів ``.pyc`` і файлів або каталогів, назва "
"яких починається з ``tmp``."

msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr ""
"Інший приклад, який використовує аргумент *ignore* для додавання виклику "
"журналювання::"

msgid "rmtree example"
msgstr "приклад rmtree"

msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onerror callback to "
"clear the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"У цьому прикладі показано, як видалити дерево каталогів у Windows, де для "
"деяких файлів встановлено біт лише для читання. Він використовує зворотний "
"виклик onerror, щоб очистити біт readonly і повторити спробу видалення. Будь-"
"який наступний збій поширюватиметься. ::"

msgid "Archiving operations"
msgstr "Архівні операції"

msgid "Added support for the *xztar* format."
msgstr "Додано підтримку формату *xztar*."

msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"Також надаються утиліти високого рівня для створення та читання стиснених і "
"архівованих файлів. Вони покладаються на модулі :mod:`zipfile` і :mod:"
"`tarfile`."

msgid "Create an archive file (such as zip or tar) and return its name."
msgstr ""
"Створіть архівний файл (наприклад, zip або tar) і поверніть його назву."

msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension. *format* is the archive format: one of "
"\"zip\" (if the :mod:`zlib` module is available), \"tar\", \"gztar\" (if "
"the :mod:`zlib` module is available), \"bztar\" (if the :mod:`bz2` module is "
"available), or \"xztar\" (if the :mod:`lzma` module is available)."
msgstr ""
"*базова_ім’я* — це ім’я файлу, який потрібно створити, включаючи шлях, без "
"будь-якого розширення, що залежить від формату. *format* — це формат архіву: "
"\"zip\" (якщо доступний модуль :mod:`zlib`), \"tar\", \"gztar\" (якщо "
"доступний модуль :mod:`zlib`), \"bztar \" (якщо доступний модуль :mod:`bz2`) "
"або \"xztar\" (якщо доступний модуль :mod:`lzma`)."

msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* – це каталог, який буде кореневим каталогом архіву, усі шляхи в "
"архіві будуть відносними до нього; наприклад, ми зазвичай chdir в *root_dir* "
"перед створенням архіву."

msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-archiving-"
"example-with-basedir` for how to use *base_dir* and *root_dir* together."
msgstr ""
"*base_dir* - це каталог, з якого ми починаємо архівування; тобто *base_dir* "
"буде загальним префіксом для всіх файлів і каталогів в архіві. *base_dir* "
"має бути задано відносно *root_dir*. Перегляньте :ref:`shutil-archiving-"
"example-with-basedir`, щоб дізнатися, як використовувати *base_dir* і "
"*root_dir* разом."

msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* і *base_dir* за замовчуванням є поточним каталогом."

msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr ""
"Якщо *dry_run* має значення true, архів не створюється, але операції, які "
"будуть виконані, реєструються в *logger*."

msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*власник* і *група* використовуються під час створення архіву tar. За "
"замовчуванням використовуються поточний власник і група."

msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* має бути об’єктом, сумісним з :pep:`282`, зазвичай екземпляром :"
"class:`logging.Logger`."

msgid "The *verbose* argument is unused and deprecated."
msgstr "Аргумент *verbose* не використовується та не підтримується."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.make_archive`` з "
"аргументами ``base_name``, ``format``, ``root_dir``, ``base_dir``."

msgid "This function is not thread-safe."
msgstr ""

msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"Сучасний формат pax (POSIX.1-2001) тепер використовується замість "
"застарілого формату GNU для архівів, створених за допомогою "
"``format=\"tar\"``."

msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"Повернути список підтримуваних форматів для архівування. Кожен елемент "
"повернутої послідовності є кортежем ``(назва, опис)``."

msgid "By default :mod:`shutil` provides these formats:"
msgstr "Типово :mod:`shutil` надає такі формати:"

msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP-файл (якщо доступний модуль :mod:`zlib`)."

msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr ""
"*tar*: Нестиснутий файл tar. Використовує формат POSIX.1-2001 pax для нових "
"архівів."

msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: заархівований tar-файл (якщо доступний модуль :mod:`zlib`)."

msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr "*bztar*: bzip2-файл tar (якщо доступний модуль :mod:`bz2`)."

msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz'ed tar-файл (якщо доступний модуль :mod:`lzma`)."

msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"Ви можете зареєструвати нові формати або надати власний архіватор для будь-"
"яких існуючих форматів, використовуючи :func:`register_archive_format`."

msgid "Register an archiver for the format *name*."
msgstr "Зареєструйте архіватор для формату *назва*."

msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the "
"*base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*функція* — це виклик, який використовуватиметься для розпакування архівів. "
"Викликаний отримає *base_name* файлу для створення, а потім *base_dir* (який "
"за замовчуванням :data:`os.curdir`), щоб розпочати архівування. Подальші "
"аргументи передаються як ключові аргументи: *owner*, *group*, *dry_run* і "
"*logger* (як передано в :func:`make_archive`)."

msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""
"Якщо задано, *extra_args* — це послідовність пар ``(ім’я, значення)``, які "
"використовуватимуться як додаткові аргументи ключових слів, коли "
"використовується виклик архіватора."

msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*опис* використовується :func:`get_archive_formats`, який повертає список "
"архіваторів. За замовчуванням порожній рядок."

msgid "Remove the archive format *name* from the list of supported formats."
msgstr "Видаліть формат архіву *назва* зі списку підтримуваних форматів."

msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "Розпакуйте архів. *ім’я файлу* — це повний шлях до архіву."

msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* — назва цільового каталогу, куди розпаковується архів. Якщо не "
"вказано, використовується поточний робочий каталог."

msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with :func:"
"`register_unpack_format`.  If not provided, :func:`unpack_archive` will use "
"the archive file name extension and see if an unpacker was registered for "
"that extension.  In case none is found, a :exc:`ValueError` is raised."
msgstr ""
"*format* — це формат архіву: \"zip\", \"tar\", \"gztar\", \"bztar\" або "
"\"xztar\". Або будь-який інший формат, зареєстрований у :func:"
"`register_unpack_format`. Якщо не вказано, :func:`unpack_archive` "
"використовуватиме розширення назви архівного файлу та перевірятиме, чи було "
"зареєстровано розпаковувач для цього розширення. Якщо нічого не знайдено, "
"виникає :exc:`ValueError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.unpack_archive`` з "
"аргументами ``filename``, ``extract_dir``, ``format``."

msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"Ніколи не витягуйте архіви з ненадійних джерел без попередньої перевірки. "
"Можливо, що файли створюються поза шляхом, указаним у аргументі "
"*extract_dir*, наприклад. члени, які мають абсолютні імена файлів, що "
"починаються з \"/\" або імена файлів із двома крапками \"..\"."

msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr "Приймає :term:`path-like object` для *filename* і *extract_dir*."

msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""
"Реєструє формат розпакування. *ім’я* — це назва формату, а *розширення* — це "
"список розширень, що відповідають формату, наприклад ``.zip`` для файлів Zip."

msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the path of the archive, followed by the directory the "
"archive must be extracted to."
msgstr ""
"*функція* — це виклик, який використовуватиметься для розпакування архівів. "
"Викликаний отримає шлях до архіву, а потім каталог, куди потрібно "
"розпакувати архів."

msgid ""
"When provided, *extra_args* is a sequence of ``(name, value)`` tuples that "
"will be passed as keywords arguments to the callable."
msgstr ""
"Якщо вказано, *extra_args* — це послідовність кортежів ``(ім’я, значення)``, "
"які будуть передані як аргументи ключових слів до викликаного."

msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"Для опису формату може бути надано *description*, яке буде повернено "
"функцією :func:`get_unpack_formats`."

msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "Скасувати реєстрацію формату розпакування. *ім'я* - це назва формату."

msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"Повернути список усіх зареєстрованих форматів для розпакування. Кожен "
"елемент повернутої послідовності є кортежем ``(назва, розширення, опис)``."

msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr ""
"*zip*: ZIP-файл (розпакування стиснених файлів працює лише за наявності "
"відповідного модуля)."

msgid "*tar*: uncompressed tar file."
msgstr "*tar*: нестиснутий файл tar."

msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"Ви можете зареєструвати нові формати або надати власний розпаковувач для "
"будь-яких існуючих форматів за допомогою :func:`register_unpack_format`."

msgid "Archiving example"
msgstr "Приклад архівування"

msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"У цьому прикладі ми створюємо архів tar-файлів у форматі gzip, який містить "
"усі файли, знайдені в каталозі :file:`.ssh` користувача::"

msgid "The resulting archive contains:"
msgstr "Отриманий архів містить:"

msgid "Archiving example with *base_dir*"
msgstr "Приклад архівування з *base_dir*"

msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we "
"show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"У цьому прикладі, подібному до `один вище <shutil-archiving-example_>`_, ми "
"показуємо, як використовувати :func:`make_archive`, але цього разу з "
"використанням *base_dir*. Тепер у нас є така структура каталогу:"

msgid ""
"In the final archive, :file:`please_add.txt` should be included, but :file:"
"`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"У остаточному архіві слід включити :file:`please_add.txt`, а :file:"
"`do_not_add.txt` — ні. Тому ми використовуємо наступне:"

msgid "Listing the files in the resulting archive gives us:"
msgstr "Перелік файлів у отриманому архіві дає нам:"

msgid "Querying the size of the output terminal"
msgstr "Запит розміру вихідного терміналу"

msgid "Get the size of the terminal window."
msgstr "Отримайте розмір вікна терміналу."

msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value "
"is a positive integer, it is used."
msgstr ""
"Для кожного з двох вимірів перевіряється змінна середовища, ``COLUMNS`` і "
"``LINES`` відповідно. Якщо змінна визначена і значення є додатним цілим "
"числом, вона використовується."

msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking :func:"
"`os.get_terminal_size`."
msgstr ""
"Якщо ``COLUMNS`` або ``LINES`` не визначені, що є звичайним випадком, "
"термінал, підключений до :data:`sys.__stdout__`, запитується через виклик :"
"func:`os.get_terminal_size`."

msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"Якщо розмір терміналу не може бути успішно запитаний через те, що система не "
"підтримує запити, або тому, що ми не підключені до терміналу, "
"використовується значення, указане в параметрі ``резервного``. ``fallback`` "
"за замовчуванням ``(80, 24)``, який є розміром за замовчуванням, який "
"використовується багатьма емуляторами терміналів."

msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr ""
"Повернене значення є іменованим кортежем типу :class:`os.terminal_size`."

msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"Дивіться також: Єдина специфікація UNIX, версія 2, Інші змінні середовища "
"(`Other Environment Variables`_)."
