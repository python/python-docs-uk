# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/shutil.rst:2
msgid ":mod:`!shutil` --- High-level file operations"
msgstr ""

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**Вихідний код:** :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
"Модуль :mod:`shutil` пропонує низку високорівневих операцій над файлами та "
"колекціями файлів. Зокрема, передбачені функції, які підтримують копіювання "
"та видалення файлів. Для операцій з окремими файлами дивіться також модуль "
":mod:`os`."

#: ../../library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, "
":func:`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"Навіть функції копіювання файлів вищого рівня (:func:`shutil.copy`, "
":func:`shutil.copy2`) не можуть скопіювати всі метадані файлу."

#: ../../library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as"
" ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not"
" copied."
msgstr ""
"На платформах POSIX це означає, що власник файлу та група втрачаються, а "
"також ACL. У Mac OS форк ресурсів та інші метадані не використовуються. Це "
"означає, що ресурси буде втрачено, а тип файлу та коди творця будуть "
"неправильними. У Windows власники файлів, ACL та альтернативні потоки даних "
"не копіюються."

#: ../../library/shutil.rst:38
msgid "Directory and files operations"
msgstr "Операції з каталогами та файлами"

#: ../../library/shutil.rst:42
msgid ""
"Copy the contents of the :term:`file-like object <file object>` *fsrc* to "
"the file-like object *fdst*. The integer *length*, if given, is the buffer "
"size. In particular, a negative *length* value means to copy the data "
"without looping over the source data in chunks; by default the data is read "
"in chunks to avoid uncontrolled memory consumption. Note that if the current"
" file position of the *fsrc* object is not 0, only the contents from the "
"current file position to the end of the file will be copied."
msgstr ""

#: ../../library/shutil.rst:53
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are :term:`path-like objects <path-like object>` or path names given as "
"strings."
msgstr ""

#: ../../library/shutil.rst:57
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify"
" the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* має бути повним ім’ям цільового файлу; подивіться на "
":func:`~shutil.copy` копію, яка приймає шлях цільового каталогу. Якщо *src* "
"і *dst* вказують той самий файл, виникає :exc:`SameFileError`."

#: ../../library/shutil.rst:61
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"Місце призначення має бути доступним для запису; інакше буде викликано "
"виняток :exc:`OSError`. Якщо *dst* вже існує, його буде замінено. За "
"допомогою цієї функції неможливо скопіювати спеціальні файли, такі як "
"символьні або блокові пристрої та канали."

#: ../../library/shutil.rst:66
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* є символічним посиланням,"
" замість копіювання файлу, на який вказує *src*, буде створено нове "
"символічне посилання."

#: ../../library/shutil.rst:70 ../../library/shutil.rst:177
#: ../../library/shutil.rst:208
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copyfile`` з аргументами "
"``src``, ``dst``."

#: ../../library/shutil.rst:72
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"Раніше викликалося :exc:`IOError` замість :exc:`OSError`. Додано аргумент "
"*follow_symlinks*. Тепер повертає *dst*."

#: ../../library/shutil.rst:77
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"Викликати :exc:`SameFileError` замість :exc:`Error`. Оскільки перший є "
"підкласом останнього, ця зміна є зворотно сумісною."

#: ../../library/shutil.rst:81 ../../library/shutil.rst:185
#: ../../library/shutil.rst:217 ../../library/shutil.rst:287
#: ../../library/shutil.rst:396
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy"
" the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"Спеціальні для платформи системні виклики швидкого копіювання можуть "
"використовуватися внутрішньо для більш ефективного копіювання файлу. "
"Перегляньте розділ :ref:`shutil-platform-dependent-efficient-copy-"
"operations`."

#: ../../library/shutil.rst:88
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ""
"Цей виняток виникає, якщо джерело та призначення у :func:`copyfile` є одним "
"і тим самим файлом."

#: ../../library/shutil.rst:96
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and"
" group are unaffected.  *src* and *dst* are :term:`path-like objects <path-"
"like object>` or path names given as strings. If *follow_symlinks* is false,"
" and both *src* and *dst* are symbolic links, :func:`copymode` will attempt "
"to modify the mode of *dst* itself (rather than the file it points to).  "
"This functionality is not available on every platform; please see "
":func:`copystat` for more information.  If :func:`copymode` cannot modify "
"symbolic links on the local platform, and it is asked to do so, it will do "
"nothing and return."
msgstr ""

#: ../../library/shutil.rst:106 ../../library/shutil.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copymode`` з аргументами "
"``src``, ``dst``."

#: ../../library/shutil.rst:108
msgid "Added *follow_symlinks* argument."
msgstr "Додано аргумент *follow_symlinks*."

#: ../../library/shutil.rst:113
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group"
" are unaffected.  *src* and *dst* are :term:`path-like objects <path-like "
"object>` or path names given as strings."
msgstr ""

#: ../../library/shutil.rst:119
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather"
" than the files the symbolic links refer to—reading the information from the"
" *src* symbolic link, and writing the information to the *dst* symbolic "
"link."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* і *dst* посилаються на "
"символічні посилання, :func:`copystat` працюватиме з самими символьними "
"посиланнями, а не з файлами, на які посилаються символічні посилання, "
"зчитуючи інформацію з *символьне посилання src* і запис інформації до "
"символічного посилання *dst*."

#: ../../library/shutil.rst:128
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links."
"  Python itself can tell you what functionality is locally available."
msgstr ""
"Не всі платформи надають можливість перевіряти та змінювати символічні "
"посилання. Python сам може сказати вам, які функції доступні локально."

#: ../../library/shutil.rst:132
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat`"
" can modify the permission bits of a symbolic link."
msgstr ""
"Якщо ``os.chmod в os.supports_follow_symlinks`` має значення ``True``, "
":func:`copystat` може змінити біти дозволу символічного посилання."

#: ../../library/shutil.rst:136
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat`"
" can modify the last access and modification times of a symbolic link."
msgstr ""
"Якщо ``os.utime в os.supports_follow_symlinks`` має значення ``True``, "
":func:`copystat` може змінити час останнього доступу та модифікації "
"символічного посилання."

#: ../../library/shutil.rst:140
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, "
":func:`copystat` can modify the flags of a symbolic link.  (``os.chflags`` "
"is not available on all platforms.)"
msgstr ""
"Якщо ``os.chflags в os.supports_follow_symlinks`` має значення ``True``, "
":func:`copystat` може змінювати прапорці символічного посилання. "
"(``os.chflags`` доступний не на всіх платформах.)"

#: ../../library/shutil.rst:145
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"На платформах, де деякі або всі ці функції недоступні, коли буде "
"запропоновано змінити символічне посилання, :func:`copystat` скопіює все, що"
" зможе. :func:`copystat` ніколи не повертає помилку."

#: ../../library/shutil.rst:150
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr ""
"Для отримання додаткової інформації перегляньте "
":data:`os.supports_follow_symlinks`."

#: ../../library/shutil.rst:153 ../../library/shutil.rst:210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copystat`` з аргументами "
"``src``, ``dst``."

#: ../../library/shutil.rst:155
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr ""
"Додано аргумент *follow_symlinks* і підтримку розширених атрибутів Linux."

#: ../../library/shutil.rst:160
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst*"
" specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"Копіює файл *src* у файл або каталог *dst*. *src* і *dst* повинні бути "
":term:`шляховими об’єктами <path-like object>` або рядками. Якщо *dst* "
"визначає каталог, файл буде скопійовано в *dst* з використанням базового "
"імені файлу з *src*. Якщо *dst* вказує на файл, який уже існує, його буде "
"замінено. Повертає шлях до щойно створеного файлу."

#: ../../library/shutil.rst:166
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"Якщо *follow_symlinks* має значення false, а *src* є символічним посиланням,"
" *dst* буде створено як символічне посилання. Якщо *follow_symlinks* має "
"значення true і *src* є символічним посиланням, *dst* буде копією файлу, на "
"який посилається *src*."

#: ../../library/shutil.rst:171
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the"
" original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` копіює дані файлу та режим дозволу файлу (див. "
":func:`os.chmod`). Інші метадані, наприклад час створення та модифікації "
"файлу, не зберігаються. Щоб зберегти всі метадані файлу з оригіналу, замість"
" цього використовуйте :func:`~shutil.copy2`."

#: ../../library/shutil.rst:181
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created "
"file."
msgstr ""
"Додано аргумент *follow_symlinks*. Тепер повертає шлях до щойно створеного "
"файлу."

#: ../../library/shutil.rst:192
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to"
" preserve file metadata."
msgstr ""
"Ідентичний :func:`~shutil.copy` за винятком того, що :func:`copy2` також "
"намагається зберегти метадані файлу."

#: ../../library/shutil.rst:195
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2`"
" attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on"
" all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; "
":func:`copy2` never raises an exception because it cannot preserve file "
"metadata."
msgstr ""

#: ../../library/shutil.rst:204
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see "
":func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` використовує :func:`copystat` для копіювання метаданих файлу. "
"Перегляньте :func:`copystat` для отримання додаткової інформації про "
"підтримку платформи для зміни метаданих символічних посилань."

#: ../../library/shutil.rst:212
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created"
" file."
msgstr ""
"Додано аргумент *follow_symlinks*, також спробуйте скопіювати розширені "
"атрибути файлової системи (наразі лише для Linux). Тепер повертає шлях до "
"щойно створеного файлу."

#: ../../library/shutil.rst:224
msgid ""
"This factory function creates a function that can be used as a callable for "
":func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"Ця фабрична функція створює функцію, яку можна використовувати як виклик для"
" аргументу *ignore* :func:`copytree`\\, ігноруючи файли та каталоги, які "
"відповідають одному з наданих *шаблонів* стилю glob. Дивіться приклад нижче."

#: ../../library/shutil.rst:233
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"Рекурсивно скопіюйте все дерево каталогів із коренем *src* до каталогу з "
"назвою *dst* і поверніть каталог призначення. Усі проміжні каталоги, які "
"повинні містити *dst*, також будуть створені за замовчуванням."

#: ../../library/shutil.rst:237
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"Дозволи та час каталогів копіюються за допомогою :func:`copystat`, окремі "
"файли копіюються за допомогою :func:`~shutil.copy2`."

#: ../../library/shutil.rst:240
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"Якщо *symlinks* має значення true, символічні посилання у вихідному дереві "
"представлені як символічні посилання в новому дереві, а метадані "
"оригінальних посилань буде скопійовано, наскільки це дозволяє платформа; "
"якщо false або пропущено, вміст і метадані пов’язаних файлів копіюються до "
"нового дерева."

#: ../../library/shutil.rst:245
msgid ""
"When *symlinks* is false, if the file pointed to by the symlink doesn't "
"exist, an exception will be added in the list of errors raised in an "
":exc:`Error` exception at the end of the copy process. You can set the "
"optional *ignore_dangling_symlinks* flag to true if you want to silence this"
" exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""

#: ../../library/shutil.rst:252
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its"
" contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items"
" in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that"
" ignores names based on glob-style patterns."
msgstr ""
"Якщо задано *ignore*, це має бути виклик, який отримає як аргументи каталог,"
" який відвідує :func:`copytree`, і список його вмісту, який повертає "
":func:`os.listdir`. Оскільки :func:`copytree` викликається рекурсивно, "
"*ignore* викликається один раз для кожного каталогу, який копіюється. "
"Викликаний має повертати послідовність імен каталогу та файлу відносно "
"поточного каталогу (тобто підмножину елементів у другому аргументі); ці "
"імена будуть проігноровані в процесі копіювання. :func:`ignore_patterns` "
"можна використати для створення такого виклику, який ігнорує імена на основі"
" шаблонів у стилі glob."

#: ../../library/shutil.rst:262
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""
"Якщо трапляються винятки, виникає повідомлення :exc:`Error` зі списком "
"причин."

#: ../../library/shutil.rst:264
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy"
" each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"Якщо задано *copy_function*, це має бути виклик, який використовуватиметься "
"для копіювання кожного файлу. Він буде викликаний із вихідним шляхом і "
"цільовим шляхом як аргументами. За замовчуванням використовується "
":func:`~shutil.copy2`, але можна використовувати будь-яку функцію, яка "
"підтримує такий самий підпис (наприклад, :func:`~shutil.copy`)."

#: ../../library/shutil.rst:269
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a "
":exc:`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"Якщо *dirs_exist_ok* має значення false (за замовчуванням), а *dst* уже "
"існує, виникає :exc:`FileExistsError`. Якщо *dirs_exist_ok* має значення "
"true, операція копіювання продовжуватиметься, якщо буде виявлено існуючі "
"каталоги, а файли в дереві *dst* будуть перезаписані відповідними файлами з "
"дерева *src*."

#: ../../library/shutil.rst:275
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.copytree`` з аргументами "
"``src``, ``dst``."

#: ../../library/shutil.rst:277
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"Додано аргумент *copy_function*, щоб мати можливість надати спеціальну "
"функцію копіювання. Додано аргумент *ignore_dangling_symlinks*, щоб вимкнути"
" помилки висячих символьних посилань, коли *symlinks* має значення false."

#: ../../library/shutil.rst:283
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr ""
"Копіювати метадані, якщо *symlinks* має значення false. Тепер повертає "
"*dst*."

#: ../../library/shutil.rst:292
msgid "Added the *dirs_exist_ok* parameter."
msgstr ""

#: ../../library/shutil.rst:299
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a"
" symbolic link to a directory).  If *ignore_errors* is true, errors "
"resulting from failed removals will be ignored; if false or omitted, such "
"errors are handled by calling a handler specified by *onexc* or *onerror* "
"or, if both are omitted, exceptions are propagated to the caller."
msgstr ""

#: ../../library/shutil.rst:305
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Ця функція може підтримувати :ref:`шляхи відносно дескрипторів каталогу "
"<dir_fd>`."

#: ../../library/shutil.rst:310
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms,"
" the :func:`rmtree` implementation is susceptible to a symlink attack: given"
" proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"На платформах, які підтримують необхідні функції на основі fd, за "
"замовчуванням використовується стійка до атак символічних посилань версія "
":func:`rmtree`. На інших платформах реалізація :func:`rmtree` чутлива до "
"атаки через символічні посилання: за належного часу та обставин зловмисники "
"можуть маніпулювати символічними посиланнями у файловій системі, щоб "
"видалити файли, до яких вони не мали б доступу інакше. Програми можуть "
"використовувати атрибут функції :data:`rmtree.avoids_symlink_attacks`, щоб "
"визначити, який регістр застосовний."

#: ../../library/shutil.rst:318
msgid ""
"If *onexc* is provided, it must be a callable that accepts three parameters:"
" *function*, *path*, and *excinfo*."
msgstr ""

#: ../../library/shutil.rst:321
msgid ""
"The first parameter, *function*, is the function which raised the exception;"
" it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, is the exception that was raised. Exceptions raised by *onexc* "
"will not be caught."
msgstr ""

#: ../../library/shutil.rst:327
msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""

#: ../../library/shutil.rst:330
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""

#: ../../library/shutil.rst:332
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"Додано версію, стійку до атак символічних посилань, яка використовується "
"автоматично, якщо платформа підтримує функції на основі fd."

#: ../../library/shutil.rst:336
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr ""
"У Windows більше не буде видаляти вміст з’єднання каталогу перед видаленням "
"з’єднання."

#: ../../library/shutil.rst:340
msgid "Added the *dir_fd* parameter."
msgstr "Додано параметр *dir_fd*."

#: ../../library/shutil.rst:343
msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr ""

#: ../../library/shutil.rst:346
msgid ""
":func:`!rmtree` now ignores :exc:`FileNotFoundError` exceptions for all but "
"the top-level path. Exceptions other than :exc:`OSError` and subclasses of "
":exc:`!OSError` are now always propagated to the caller."
msgstr ""

#: ../../library/shutil.rst:354
msgid ""
"Indicates whether the current platform and implementation provides a symlink"
" attack resistant version of :func:`rmtree`.  Currently this is only true "
"for platforms supporting fd-based directory access functions."
msgstr ""
"Вказує, чи поточна платформа та реалізація забезпечують стійку до атак "
"символічних посилань версію :func:`rmtree`. Наразі це стосується лише "
"платформ, які підтримують функції доступу до каталогу на основі fd."

#: ../../library/shutil.rst:363
msgid ""
"Recursively move a file or directory (*src*) to another location and return "
"the destination."
msgstr ""

#: ../../library/shutil.rst:366
msgid ""
"If *dst* is an existing directory or a symlink to a directory, then *src* is"
" moved inside that directory. The destination path in that directory must "
"not already exist."
msgstr ""

#: ../../library/shutil.rst:370
msgid ""
"If *dst* already exists but is not a directory, it may be overwritten "
"depending on :func:`os.rename` semantics."
msgstr ""

#: ../../library/shutil.rst:373
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to the destination using *copy_function* "
"and then removed.  In case of symlinks, a new symlink pointing to the target"
" of *src* will be created as the destination and *src* will be removed."
msgstr ""

#: ../../library/shutil.rst:378
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments,"
" *src* and the destination, and will be used to copy *src* to the "
"destination if :func:`os.rename` cannot be used.  If the source is a "
"directory, :func:`copytree` is called, passing it the *copy_function*. The "
"default *copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the"
" *copy_function* allows the move to succeed when it is not possible to also "
"copy the metadata, at the expense of not copying any of the metadata."
msgstr ""

#: ../../library/shutil.rst:386
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.move`` з аргументами "
"``src``, ``dst``."

#: ../../library/shutil.rst:388
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to"
" the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"Додано явну обробку символічних посилань для іноземних файлових систем, "
"таким чином адаптуючи її до поведінки GNU :program:`mv`. Тепер повертає "
"*dst*."

#: ../../library/shutil.rst:393
msgid "Added the *copy_function* keyword argument."
msgstr "Додано аргумент ключового слова *copy_function*."

#: ../../library/shutil.rst:401
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "Приймає :term:`path-like object` для *src* і *dst*."

#: ../../library/shutil.rst:406
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"Повертає статистику використання диска щодо заданого шляху як :term:`named "
"tuple` з атрибутами *total*, *used* і *free*, які є обсягом загального, "
"використаного та вільного простору в байтах. *шлях* може бути файлом або "
"каталогом."

#: ../../library/shutil.rst:413
msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""

#: ../../library/shutil.rst:419
msgid "On Windows, *path* can now be a file or directory."
msgstr "У Windows *шлях* тепер може бути файлом або каталогом."

#: ../../library/shutil.rst:422 ../../library/shutil.rst:436
msgid "Availability"
msgstr ""

#: ../../library/shutil.rst:427
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "Змінити власника *користувача* та/або *групу* вказаного *шляху*."

#: ../../library/shutil.rst:429
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr ""
"*user* може бути системним іменем користувача або uid; те саме стосується "
"*групи*. Потрібен принаймні один аргумент."

#: ../../library/shutil.rst:432
msgid "See also :func:`os.chown`, the underlying function."
msgstr "Дивіться також :func:`os.chown`, базову функцію."

#: ../../library/shutil.rst:434
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.chown`` з аргументами "
"``path``, ``user``, ``group``."

#: ../../library/shutil.rst:440
msgid "Added *dir_fd* and *follow_symlinks* parameters."
msgstr ""

#: ../../library/shutil.rst:446
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"Повертає шлях до виконуваного файлу, який буде запущено, якщо буде викликано"
" заданий *cmd*. Якщо *cmd* не буде викликано, поверніть ``None``."

#: ../../library/shutil.rst:449
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and is executable."
msgstr ""

#: ../../library/shutil.rst:452
msgid ""
"*path* is a \"``PATH`` string\" specifying the directories to look in, "
"delimited by :data:`os.pathsep`. When no *path* is specified, the "
":envvar:`PATH` environment variable is read from :data:`os.environ`, falling"
" back to :data:`os.defpath` if it is not set."
msgstr ""

#: ../../library/shutil.rst:457
msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* does "
"not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, the "
"Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To avoid "
"consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""

#: ../../library/shutil.rst:464
msgid ""
"Also on Windows, the :envvar:`PATHEXT` environment variable is used to "
"resolve commands that may not already include an extension. For example, if "
"you call ``shutil.which(\"python\")``, :func:`which` will search ``PATHEXT``"
" to know that it should look for ``python.exe`` within the *path* "
"directories. For example, on Windows::"
msgstr ""

#: ../../library/shutil.rst:470
msgid ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""

#: ../../library/shutil.rst:473
msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr ""

#: ../../library/shutil.rst:476
msgid ""
">> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""

#: ../../library/shutil.rst:481
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"Тип :class:`bytes` тепер прийнятний. Якщо тип *cmd* :class:`bytes`, тип "
"результату також :class:`bytes`."

#: ../../library/shutil.rst:485
msgid ""
"On Windows, the current directory is no longer prepended to the search path "
"if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; ``PATHEXT``"
" is used now even when *cmd* includes a directory component or ends with an "
"extension that is in ``PATHEXT``; and filenames that have no extension can "
"now be found."
msgstr ""

#: ../../library/shutil.rst:494
msgid ""
"On Windows, if *mode* includes ``os.X_OK``, executables with an extension in"
" ``PATHEXT`` will be preferred over executables without a matching "
"extension. This brings behavior closer to that of Python 3.11."
msgstr ""

#: ../../library/shutil.rst:502
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of "
"3-tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"Цей виняток збирає винятки, які виникають під час операції з кількома "
"файлами. Для :func:`copytree` аргумент винятку — це список із 3-х кортежів "
"(*srcname*, *dstname*, *exception*)."

#: ../../library/shutil.rst:509
msgid "Platform-dependent efficient copy operations"
msgstr "Залежні від платформи ефективні операції копіювання"

#: ../../library/shutil.rst:511
msgid ""
"Starting from Python 3.8, all functions involving a file copy "
"(:func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, "
"and :func:`move`) may use platform-specific \"fast-copy\" syscalls in order "
"to copy the file more efficiently (see :issue:`33671`). \"fast-copy\" means "
"that the copying operation occurs within the kernel, avoiding the use of "
"userspace buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"Починаючи з Python 3.8, усі функції, пов’язані з копіюванням файлу "
"(:func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree` та "
":func:`move` ) може використовувати специфічні для платформи системні "
"виклики \"швидкого копіювання\" для більш ефективного копіювання файлу (див."
" :issue:`33671`). \"швидке копіювання\" означає, що операція копіювання "
"відбувається всередині ядра, уникаючи використання буферів простору "
"користувача в Python, як у \"``outfd.write(infd.read())``\"."

#: ../../library/shutil.rst:519
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr ""
"У macOS `fcopyfile`_ використовується для копіювання вмісту файлу (а не "
"метаданих)."

#: ../../library/shutil.rst:521
msgid "On Linux :func:`os.sendfile` is used."
msgstr "У Linux використовується :func:`os.sendfile`."

#: ../../library/shutil.rst:523
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of "
":func:`shutil.copyfileobj` is used."
msgstr ""
"У Windows :func:`shutil.copyfile` використовує більший розмір буфера за "
"замовчуванням (1 МіБ замість 64 КіБ) і використовується варіант "
":func:`memoryview` на основі :func:`shutil.copyfileobj`."

#: ../../library/shutil.rst:527
msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient "
":func:`copyfileobj` function internally."
msgstr ""
"Якщо операція швидкого копіювання зазнала невдачі і дані не були записані в "
"цільовий файл, програма shutil мовчки повернеться до використання менш "
"ефективної внутрішньої функції :func:`copyfileobj`."

#: ../../library/shutil.rst:536
msgid "copytree example"
msgstr "приклад копіювання"

#: ../../library/shutil.rst:538
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "Приклад, який використовує помічник :func:`ignore_patterns`::"

#: ../../library/shutil.rst:540
msgid ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"
msgstr ""

#: ../../library/shutil.rst:544
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"Буде скопійовано все, крім файлів ``.pyc`` і файлів або каталогів, назва "
"яких починається з ``tmp``."

#: ../../library/shutil.rst:547
msgid ""
"Another example that uses the *ignore* argument to add a logging call::"
msgstr ""
"Інший приклад, який використовує аргумент *ignore* для додавання виклику "
"журналювання::"

#: ../../library/shutil.rst:549
msgid ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"
msgstr ""

#: ../../library/shutil.rst:562
msgid "rmtree example"
msgstr "приклад rmtree"

#: ../../library/shutil.rst:564
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onexc callback to clear "
"the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""

#: ../../library/shutil.rst:569
msgid ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"
msgstr ""

#: ../../library/shutil.rst:582
msgid "Archiving operations"
msgstr "Архівні операції"

#: ../../library/shutil.rst:586
msgid "Added support for the *xztar* format."
msgstr "Додано підтримку формату *xztar*."

#: ../../library/shutil.rst:590
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"Також надаються утиліти високого рівня для створення та читання стиснених і "
"архівованих файлів. Вони покладаються на модулі :mod:`zipfile` і "
":mod:`tarfile`."

#: ../../library/shutil.rst:595
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr ""
"Створіть архівний файл (наприклад, zip або tar) і поверніть його назву."

#: ../../library/shutil.rst:597
msgid ""
"*base_name* is the name of the file to create, including the path, minus any"
" format-specific extension."
msgstr ""

#: ../../library/shutil.rst:600
msgid ""
"*format* is the archive format: one of \"zip\" (if the :mod:`zlib` module is"
" available), \"tar\", \"gztar\" (if the :mod:`zlib` module is available), "
"\"bztar\" (if the :mod:`bz2` module is available), or \"xztar\" (if the "
":mod:`lzma` module is available)."
msgstr ""

#: ../../library/shutil.rst:605
msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* – це каталог, який буде кореневим каталогом архіву, усі шляхи в "
"архіві будуть відносними до нього; наприклад, ми зазвичай chdir в *root_dir*"
" перед створенням архіву."

#: ../../library/shutil.rst:609
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-"
"archiving-example-with-basedir` for how to use *base_dir* and *root_dir* "
"together."
msgstr ""
"*base_dir* - це каталог, з якого ми починаємо архівування; тобто *base_dir* "
"буде загальним префіксом для всіх файлів і каталогів в архіві. *base_dir* "
"має бути задано відносно *root_dir*. Перегляньте :ref:`shutil-archiving-"
"example-with-basedir`, щоб дізнатися, як використовувати *base_dir* і "
"*root_dir* разом."

#: ../../library/shutil.rst:615
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* і *base_dir* за замовчуванням є поточним каталогом."

#: ../../library/shutil.rst:617
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr ""
"Якщо *dry_run* має значення true, архів не створюється, але операції, які "
"будуть виконані, реєструються в *logger*."

#: ../../library/shutil.rst:620
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*власник* і *група* використовуються під час створення архіву tar. За "
"замовчуванням використовуються поточний власник і група."

#: ../../library/shutil.rst:623
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* має бути об’єктом, сумісним з :pep:`282`, зазвичай екземпляром "
":class:`logging.Logger`."

#: ../../library/shutil.rst:626
msgid "The *verbose* argument is unused and deprecated."
msgstr "Аргумент *verbose* не використовується та не підтримується."

#: ../../library/shutil.rst:628
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.make_archive`` з "
"аргументами ``base_name``, ``format``, ``root_dir``, ``base_dir``."

#: ../../library/shutil.rst:632
msgid ""
"This function is not thread-safe when custom archivers registered with "
":func:`register_archive_format` do not support the *root_dir* argument.  In "
"this case it temporarily changes the current working directory of the "
"process to *root_dir* to perform archiving."
msgstr ""

#: ../../library/shutil.rst:638
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"Сучасний формат pax (POSIX.1-2001) тепер використовується замість "
"застарілого формату GNU для архівів, створених за допомогою "
"``format=\"tar\"``."

#: ../../library/shutil.rst:642
msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr ""

#: ../../library/shutil.rst:648
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"Повернути список підтримуваних форматів для архівування. Кожен елемент "
"повернутої послідовності є кортежем ``(назва, опис)``."

#: ../../library/shutil.rst:651 ../../library/shutil.rst:762
msgid "By default :mod:`shutil` provides these formats:"
msgstr "Типово :mod:`shutil` надає такі формати:"

#: ../../library/shutil.rst:653
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP-файл (якщо доступний модуль :mod:`zlib`)."

#: ../../library/shutil.rst:654
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr ""
"*tar*: Нестиснутий файл tar. Використовує формат POSIX.1-2001 pax для нових "
"архівів."

#: ../../library/shutil.rst:655 ../../library/shutil.rst:767
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: заархівований tar-файл (якщо доступний модуль :mod:`zlib`)."

#: ../../library/shutil.rst:656 ../../library/shutil.rst:768
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr "*bztar*: bzip2-файл tar (якщо доступний модуль :mod:`bz2`)."

#: ../../library/shutil.rst:657 ../../library/shutil.rst:769
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz'ed tar-файл (якщо доступний модуль :mod:`lzma`)."

#: ../../library/shutil.rst:659
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"Ви можете зареєструвати нові формати або надати власний архіватор для будь-"
"яких існуючих форматів, використовуючи :func:`register_archive_format`."

#: ../../library/shutil.rst:665
msgid "Register an archiver for the format *name*."
msgstr "Зареєструйте архіватор для формату *назва*."

#: ../../library/shutil.rst:667
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the"
" *base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*функція* — це виклик, який використовуватиметься для розпакування архівів. "
"Викликаний отримає *base_name* файлу для створення, а потім *base_dir* (який"
" за замовчуванням :data:`os.curdir`), щоб розпочати архівування. Подальші "
"аргументи передаються як ключові аргументи: *owner*, *group*, *dry_run* і "
"*logger* (як передано в :func:`make_archive`)."

#: ../../library/shutil.rst:673
msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set to"
" ``True``, the *root_dir* argument is passed as a keyword argument. "
"Otherwise the current working directory of the process is temporarily "
"changed to *root_dir* before calling *function*. In this case "
":func:`make_archive` is not thread-safe."
msgstr ""

#: ../../library/shutil.rst:679
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be"
" used as extra keywords arguments when the archiver callable is used."
msgstr ""
"Якщо задано, *extra_args* — це послідовність пар ``(ім’я, значення)``, які "
"використовуватимуться як додаткові аргументи ключових слів, коли "
"використовується виклик архіватора."

#: ../../library/shutil.rst:682
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*опис* використовується :func:`get_archive_formats`, який повертає список "
"архіваторів. За замовчуванням порожній рядок."

#: ../../library/shutil.rst:685
msgid "Added support for functions supporting the *root_dir* argument."
msgstr ""

#: ../../library/shutil.rst:691
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "Видаліть формат архіву *назва* зі списку підтримуваних форматів."

#: ../../library/shutil.rst:696
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "Розпакуйте архів. *ім’я файлу* — це повний шлях до архіву."

#: ../../library/shutil.rst:698
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* — назва цільового каталогу, куди розпаковується архів. Якщо не"
" вказано, використовується поточний робочий каталог."

#: ../../library/shutil.rst:701
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with "
":func:`register_unpack_format`.  If not provided, :func:`unpack_archive` "
"will use the archive file name extension and see if an unpacker was "
"registered for that extension.  In case none is found, a :exc:`ValueError` "
"is raised."
msgstr ""
"*format* — це формат архіву: \"zip\", \"tar\", \"gztar\", \"bztar\" або "
"\"xztar\". Або будь-який інший формат, зареєстрований у "
":func:`register_unpack_format`. Якщо не вказано, :func:`unpack_archive` "
"використовуватиме розширення назви архівного файлу та перевірятиме, чи було "
"зареєстровано розпаковувач для цього розширення. Якщо нічого не знайдено, "
"виникає :exc:`ValueError`."

#: ../../library/shutil.rst:708
msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to set it to ``'data'``, unless using features specific to tar "
"and UNIX-like filesystems. (See :ref:`tarfile-extraction-filter` for "
"details.) The ``'data'`` filter will become the default for tar files in "
"Python 3.14."
msgstr ""

#: ../../library/shutil.rst:716
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``shutil.unpack_archive`` з "
"аргументами ``filename``, ``extract_dir``, ``format``."

#: ../../library/shutil.rst:720
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"Ніколи не витягуйте архіви з ненадійних джерел без попередньої перевірки. "
"Можливо, що файли створюються поза шляхом, указаним у аргументі "
"*extract_dir*, наприклад. члени, які мають абсолютні імена файлів, що "
"починаються з \"/\" або імена файлів із двома крапками \"..\"."

#: ../../library/shutil.rst:725
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr "Приймає :term:`path-like object` для *filename* і *extract_dir*."

#: ../../library/shutil.rst:728
msgid "Added the *filter* argument."
msgstr ""

#: ../../library/shutil.rst:733
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like "
"``.zip`` for Zip files."
msgstr ""
"Реєструє формат розпакування. *ім’я* — це назва формату, а *розширення* — це"
" список розширень, що відповідають формату, наприклад ``.zip`` для файлів "
"Zip."

#: ../../library/shutil.rst:737
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr ""

#: ../../library/shutil.rst:740
msgid "the path of the archive, as a positional argument;"
msgstr ""

#: ../../library/shutil.rst:741
msgid ""
"the directory the archive must be extracted to, as a positional argument;"
msgstr ""

#: ../../library/shutil.rst:742
msgid ""
"possibly a *filter* keyword argument, if it was given to "
":func:`unpack_archive`;"
msgstr ""

#: ../../library/shutil.rst:744
msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr ""

#: ../../library/shutil.rst:747
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"Для опису формату може бути надано *description*, яке буде повернено "
"функцією :func:`get_unpack_formats`."

#: ../../library/shutil.rst:753
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "Скасувати реєстрацію формату розпакування. *ім'я* - це назва формату."

#: ../../library/shutil.rst:758
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"Повернути список усіх зареєстрованих форматів для розпакування. Кожен "
"елемент повернутої послідовності є кортежем ``(назва, розширення, опис)``."

#: ../../library/shutil.rst:764
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr ""
"*zip*: ZIP-файл (розпакування стиснених файлів працює лише за наявності "
"відповідного модуля)."

#: ../../library/shutil.rst:766
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: нестиснутий файл tar."

#: ../../library/shutil.rst:771
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"Ви можете зареєструвати нові формати або надати власний розпаковувач для "
"будь-яких існуючих форматів за допомогою :func:`register_unpack_format`."

#: ../../library/shutil.rst:778
msgid "Archiving example"
msgstr "Приклад архівування"

#: ../../library/shutil.rst:780
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"У цьому прикладі ми створюємо архів tar-файлів у форматі gzip, який містить "
"усі файли, знайдені в каталозі :file:`.ssh` користувача::"

#: ../../library/shutil.rst:783
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"
msgstr ""

#: ../../library/shutil.rst:790
msgid "The resulting archive contains:"
msgstr "Отриманий архів містить:"

#: ../../library/shutil.rst:792
msgid ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"
msgstr ""

#: ../../library/shutil.rst:808
msgid "Archiving example with *base_dir*"
msgstr "Приклад архівування з *base_dir*"

#: ../../library/shutil.rst:810
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we"
" show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"У цьому прикладі, подібному до `один вище <shutil-archiving-example_>`_, ми "
"показуємо, як використовувати :func:`make_archive`, але цього разу з "
"використанням *base_dir*. Тепер у нас є така структура каталогу:"

#: ../../library/shutil.rst:814
msgid ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"
msgstr ""

#: ../../library/shutil.rst:824
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but "
":file:`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"У остаточному архіві слід включити :file:`please_add.txt`, а "
":file:`do_not_add.txt` — ні. Тому ми використовуємо наступне:"

#: ../../library/shutil.rst:827
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/my_archive.tar'"
msgstr ""

#: ../../library/shutil.rst:838
msgid "Listing the files in the resulting archive gives us:"
msgstr "Перелік файлів у отриманому архіві дає нам:"

#: ../../library/shutil.rst:840
msgid ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"
msgstr ""

#: ../../library/shutil.rst:848
msgid "Querying the size of the output terminal"
msgstr "Запит розміру вихідного терміналу"

#: ../../library/shutil.rst:852
msgid "Get the size of the terminal window."
msgstr "Отримайте розмір вікна терміналу."

#: ../../library/shutil.rst:854
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value"
" is a positive integer, it is used."
msgstr ""
"Для кожного з двох вимірів перевіряється змінна середовища, ``COLUMNS`` і "
"``LINES`` відповідно. Якщо змінна визначена і значення є додатним цілим "
"числом, вона використовується."

#: ../../library/shutil.rst:858
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking "
":func:`os.get_terminal_size`."
msgstr ""
"Якщо ``COLUMNS`` або ``LINES`` не визначені, що є звичайним випадком, "
"термінал, підключений до :data:`sys.__stdout__`, запитується через виклик "
":func:`os.get_terminal_size`."

#: ../../library/shutil.rst:862
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"Якщо розмір терміналу не може бути успішно запитаний через те, що система не"
" підтримує запити, або тому, що ми не підключені до терміналу, "
"використовується значення, указане в параметрі ``резервного``. ``fallback`` "
"за замовчуванням ``(80, 24)``, який є розміром за замовчуванням, який "
"використовується багатьма емуляторами терміналів."

#: ../../library/shutil.rst:868
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr ""
"Повернене значення є іменованим кортежем типу :class:`os.terminal_size`."

#: ../../library/shutil.rst:870
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"Дивіться також: Єдина специфікація UNIX, версія 2, Інші змінні середовища "
"(`Other Environment Variables`_)."

#: ../../library/shutil.rst:875
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr ""

#: ../../library/shutil.rst:12
msgid "file"
msgstr ""

#: ../../library/shutil.rst:12
msgid "copying"
msgstr ""

#: ../../library/shutil.rst:12
msgid "copying files"
msgstr ""

#: ../../library/shutil.rst:297
msgid "directory"
msgstr ""

#: ../../library/shutil.rst:297
msgid "deleting"
msgstr ""
