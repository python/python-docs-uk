# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`queue` --- A synchronized queue class"
msgstr ":mod:`queue` --- Синхронізований клас черги"

msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Вихідний код:** :source:`Lib/queue.py`"

msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""
"Модуль :mod:`queue` реалізує черги з кількома виробниками та кількома "
"споживачами. Це особливо корисно в потоковому програмуванні, коли необхідно "
"безпечно обмінюватися інформацією між декількома потоками. Клас :class:"
"`Queue` у цьому модулі реалізує всю необхідну семантику блокування."

msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved. In a :abbr:`LIFO (last-"
"in, first-out)` queue, the most recently added entry is the first retrieved "
"(operating like a stack).  With a priority queue, the entries are kept "
"sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"Модуль реалізує три типи черги, які відрізняються лише порядком отримання "
"записів. У черзі :abbr:`FIFO (першим увійшов, першим вийшов)` перші додані "
"завдання є першими отриманими. У черзі :abbr:`LIFO (останній прийшов, перший "
"вийшов)` останній доданий запис є першим отриманим (працює як стек). З "
"пріоритетною чергою записи зберігаються впорядкованими (за допомогою модуля :"
"mod:`heapq`), і запис із найменшим значенням отримується першим."

msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"Внутрішньо ці три типи черг використовують блокування для тимчасового "
"блокування конкуруючих потоків; однак вони не призначені для обробки "
"повторного входу в потік."

msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Крім того, модуль реалізує \"простий\" тип черги :abbr:`FIFO (перший "
"увійшов, перший вийшов)`, :class:`SimpleQueue`, конкретна реалізація якого "
"забезпечує додаткові гарантії в обмін на меншу функціональність."

msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr "Модуль :mod:`queue` визначає такі класи та винятки:"

msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор для черги :abbr:`FIFO (першим увійшов, першим вийшов)`. "
"*maxsize* — це ціле число, яке встановлює верхню межу кількості елементів, "
"які можна розмістити в черзі. Вставлення буде заблоковано, коли буде "
"досягнуто цього розміру, доки елементи черги не будуть використані. Якщо "
"*maxsize* менше або дорівнює нулю, розмір черги є нескінченним."

msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор для :abbr:`LIFO (останній увійшов, перший вийшов)` черги. "
"*maxsize* — це ціле число, яке встановлює верхню межу кількості елементів, "
"які можна розмістити в черзі. Вставлення буде заблоковано після досягнення "
"цього розміру, доки елементи черги не будуть використані. Якщо *maxsize* "
"менше або дорівнює нулю, розмір черги є нескінченним."

msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Конструктор для пріоритетної черги. *maxsize* — це ціле число, яке "
"встановлює верхню межу кількості елементів, які можна розмістити в черзі. "
"Вставлення буде заблоковано після досягнення цього розміру, доки елементи "
"черги не будуть використані. Якщо *maxsize* менше або дорівнює нулю, розмір "
"черги є нескінченним."

msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one returned by ``sorted(list(entries))[0]``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"Записи з найменшим значенням витягуються першими (запис із найменшим "
"значенням повертається ``sorted(list(entries))[0]``. Типовим шаблоном для "
"записів є кортеж у формі: ``(число_пріоритету, дані)``."

msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Якщо елементи *data* не можна порівняти, дані можна загорнути в клас, який "
"ігнорує елемент даних і порівнює лише номер пріоритету::"

msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Конструктор для необмеженої черги :abbr:`FIFO (першим увійшов, першим "
"вийшов)`. Прості черги не мають розширених функцій, таких як відстеження "
"завдань."

msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Виняток виникає, коли неблокуючий :meth:`~Queue.get` (або :meth:`~Queue."
"get_nowait`) викликається для порожнього об’єкта :class:`Queue`."

msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Виняток виникає, коли неблокуючий :meth:`~Queue.put` (або :meth:`~Queue."
"put_nowait`) викликається для заповненого об’єкта :class:`Queue`."

msgid "Queue Objects"
msgstr "Об'єкти черги"

msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Об’єкти черги (:class:`Queue`, :class:`LifoQueue` або :class:"
"`PriorityQueue`) надають публічні методи, описані нижче."

msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Повертає приблизний розмір черги. Зауважте, що qsize() > 0 не гарантує, що "
"наступний get() не заблокує, а також qsize() < maxsize не гарантує, що put() "
"не заблокує."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Повертає ``True``, якщо черга порожня, ``False`` інакше. Якщо empty() "
"повертає ``True``, це не гарантує, що наступний виклик put() не "
"заблокується. Подібним чином, якщо empty() повертає ``False``, це не "
"гарантує, що наступний виклик get() не заблокується."

msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Повертає ``True``, якщо черга заповнена, ``False`` інакше. Якщо full() "
"повертає ``True``, це не гарантує, що наступний виклик get() не "
"заблокується. Так само, якщо full() повертає ``False``, це не гарантує, що "
"наступний виклик put() не буде заблоковано."

msgid ""
"Put *item* into the queue. If optional args *block* is true and *timeout* is "
"``None`` (the default), block if necessary until a free slot is available. "
"If *timeout* is a positive number, it blocks at most *timeout* seconds and "
"raises the :exc:`Full` exception if no free slot was available within that "
"time. Otherwise (*block* is false), put an item on the queue if a free slot "
"is immediately available, else raise the :exc:`Full` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Поставте *товар* в чергу. Якщо необов’язкові аргументи *block* мають "
"значення true, а *timeout* має значення ``None`` (за замовчуванням), за "
"потреби блокуйте, доки не з’явиться вільний слот. Якщо *timeout* є "
"позитивним числом, він блокує щонайбільше *timeout* секунд і викликає "
"виняток :exc:`Full`, якщо протягом цього часу не було вільного слота. В "
"іншому випадку (*block* має значення false), помістіть елемент у чергу, якщо "
"вільний слот є негайно доступним, інакше спричиніть виняток :exc:`Full` (у "
"цьому випадку *timeout* ігнорується)."

msgid "Equivalent to ``put(item, block=False)``."
msgstr "Еквівалент ``put(item, block=False)``."

msgid ""
"Remove and return an item from the queue. If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Видалити та повернути елемент із черги. Якщо необов’язкові аргументи *block* "
"мають значення true, а *timeout* має значення ``None`` (за замовчуванням), "
"за потреби блокуйте, доки елемент не стане доступним. Якщо *timeout* є "
"позитивним числом, він блокує щонайбільше *timeout* секунд і викликає "
"виключення :exc:`Empty`, якщо жоден елемент не був доступний протягом цього "
"часу. В іншому випадку (*block* — false), повертає елемент, якщо він одразу "
"доступний, інакше викликає виняток :exc:`Empty` (у цьому випадку *timeout* "
"ігнорується)."

msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock. This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""
"Раніше 3.0 у системах POSIX і для всіх версій у Windows, якщо *block* має "
"значення true і *timeout* має значення ``None``, ця операція переходить у "
"режим безперервного очікування основного блокування. Це означає, що жодних "
"винятків не може бути, і, зокрема, SIGINT не ініціюватиме :exc:"
"`KeyboardInterrupt`."

msgid "Equivalent to ``get(False)``."
msgstr "Еквівалент ``get(False)``."

msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"Пропонуються два методи підтримки відстеження того, чи завдання, поставлені "
"в чергу, були повністю оброблені потоками споживачів демона."

msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Вказує на те, що завдання, яке раніше було в черзі, виконано. "
"Використовується потоками споживачів черги. Для кожного :meth:`get`, який "
"використовується для отримання завдання, наступний виклик :meth:`task_done` "
"повідомляє черзі, що обробку завдання завершено."

msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Якщо :meth:`join` зараз блокується, воно відновиться, коли всі елементи буде "
"оброблено (це означає, що виклик :meth:`task_done` отримано для кожного "
"елемента, який був :meth:`put` у чергу) ."

msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Викликає :exc:`ValueError`, якщо викликається стільки разів, скільки було "
"елементів, розміщених у черзі."

msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "Блокує, доки всі елементи в черзі не будуть отримані та оброблені."

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete. When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Кількість незавершених завдань зростає щоразу, коли елемент додається до "
"черги. Підрахунок зменшується щоразу, коли потік споживача викликає :meth:"
"`task_done`, щоб вказати, що елемент отримано та вся робота над ним "
"завершена. Коли кількість незавершених завдань падає до нуля, :meth:`join` "
"розблоковується."

msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "Приклад очікування виконання завдань, поставлених у чергу::"

msgid "SimpleQueue Objects"
msgstr "Об’єкти SimpleQueue"

msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
"Об’єкти :class:`SimpleQueue` забезпечують публічні методи, описані нижче."

msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Повертає приблизний розмір черги. Зауважте, що qsize() > 0 не гарантує, що "
"наступний get() не заблокує."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise. If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""
"Повертає ``True``, якщо черга порожня, ``False`` інакше. Якщо empty() "
"повертає ``False``, це не гарантує, що наступний виклик get() не "
"заблокується."

msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Поставте *товар* в чергу. Метод ніколи не блокується і завжди виконується "
"успішно (за винятком потенційних низькорівневих помилок, таких як помилка "
"виділення пам’яті). Необов’язкові аргументи *block* і *timeout* ігноруються "
"та надаються лише для сумісності з :meth:`Queue.put`."

msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""
"Еквівалент ``put(item, block=False)``, передбачений для сумісності з :meth:"
"`Queue.put_nowait`."

msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Видалити та повернути елемент із черги. Якщо необов’язкові аргументи *block* "
"мають значення true, а *timeout* має значення ``None`` (за замовчуванням), "
"за потреби блокуйте, доки елемент не стане доступним. Якщо *timeout* є "
"позитивним числом, він блокує щонайбільше *timeout* секунд і викликає "
"виключення :exc:`Empty`, якщо жоден елемент не був доступний протягом цього "
"часу. В іншому випадку (*block* — false), повертає елемент, якщо він одразу "
"доступний, інакше викликає виняток :exc:`Empty` (у цьому випадку *timeout* "
"ігнорується)."

msgid "Class :class:`multiprocessing.Queue`"
msgstr "Клас :class:`multiprocessing.Queue`"

msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"Клас черги для використання в багатопроцесорному (а не багатопоточному) "
"контексті."

msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
":class:`collections.deque` — це альтернативна реалізація необмежених черг із "
"швидкими атомарними операціями :meth:`~collections.deque.append` і :meth:"
"`~collections.deque.popleft`, які не потребують блокування, а також "
"підтримують індексація."
