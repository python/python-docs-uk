# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- Паралелізм на основі процесу"

msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Вихідний код:** :source:`Lib/multiprocessing/`"

msgid "Introduction"
msgstr "Вступ"

msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both Unix and Windows."
msgstr ""
":mod:`multiprocessing` — це пакет, який підтримує процеси породження за "
"допомогою API, подібного до модуля :mod:`threading`. Пакет :mod:"
"`multiprocessing` пропонує як локальний, так і віддалений паралелізм, "
"ефективно обходячи :term:`Global Interpreter Lock <global interpreter lock>` "
"шляхом використання підпроцесів замість потоків. Завдяки цьому модуль :mod:"
"`multiprocessing` дозволяє програмісту повністю використовувати кілька "
"процесорів на певній машині. Він працює як на Unix, так і на Windows."

msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"Модуль :mod:`multiprocessing` також представляє API, які не мають аналогів у "
"модулі :mod:`threading`. Яскравим прикладом цього є об’єкт :class:"
"`~multiprocessing.pool.Pool`, який пропонує зручний засіб розпаралелювання "
"виконання функції для кількох вхідних значень, розподіляючи вхідні дані між "
"процесами (паралелізм даних). Наступний приклад демонструє звичайну практику "
"визначення таких функцій у модулі, щоб дочірні процеси могли успішно "
"імпортувати цей модуль. Цей базовий приклад паралелізму даних з "
"використанням :class:`~multiprocessing.pool.Pool`, ::"

msgid "will print to standard output ::"
msgstr "друкуватиме стандартний вихід ::"

msgid "The :class:`Process` class"
msgstr "Клас :class:`Process`"

msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"У :mod:`multiprocessing` процеси породжуються шляхом створення об’єкта :"
"class:`Process` і виклику його методу :meth:`~Process.start`. :class:"
"`Process` відповідає API :class:`threading.Thread`. Тривіальним прикладом "
"багатопроцесорної програми є:"

msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr "Щоб показати ідентифікатори окремих процесів, ось розширений приклад:"

msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"Щоб отримати пояснення, чому потрібна частина ``if __name__ == "
"'__main__''``, див. :ref:`multiprocessing-programming`."

msgid "Contexts and start methods"
msgstr "Контексти та методи запуску"

msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Залежно від платформи :mod:`multiprocessing` підтримує три способи запуску "
"процесу. Це *методи запуску*"

msgid "*spawn*"
msgstr "*спаун*"

msgid ""
"The parent process starts a fresh python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"Батьківський процес запускає новий процес інтерпретатора Python. Дочірній "
"процес успадкує лише ті ресурси, які необхідні для запуску методу :meth:"
"`~Process.run` об’єкта процесу. Зокрема, непотрібні файлові дескриптори та "
"дескриптори батьківського процесу не успадковуються. Запуск процесу за "
"допомогою цього методу досить повільний порівняно з використанням *fork* або "
"*forkserver*."

msgid "Available on Unix and Windows.  The default on Windows and macOS."
msgstr "Доступно в Unix і Windows. За умовчанням у Windows і macOS."

msgid "*fork*"
msgstr "*вилка*"

msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"Батьківський процес використовує :func:`os.fork` для розгалуження "
"інтерпретатора Python. Дочірній процес, коли він починається, фактично "
"ідентичний батьківському процесу. Усі ресурси батьківського процесу "
"успадковуються дочірнім процесом. Зверніть увагу, що безпечне розгалуження "
"багатопотокового процесу є проблематичним."

msgid "Available on Unix only.  The default on Unix."
msgstr "Доступно лише для Unix. За замовчуванням в Unix."

msgid "*forkserver*"
msgstr "*форксервер*"

msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is started.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded so it is safe for it to "
"use :func:`os.fork`.  No unnecessary resources are inherited."
msgstr ""
"Коли програма запускається та вибирає метод запуску *forkserver*, "
"запускається серверний процес. Відтоді, щоразу, коли потрібен новий процес, "
"батьківський процес підключається до сервера та запитує розгалуження нового "
"процесу. Процес сервера fork є однопотоковим, тому для нього безпечно "
"використовувати :func:`os.fork`. Ніякі непотрібні ресурси не успадковуються."

msgid ""
"Available on Unix platforms which support passing file descriptors over Unix "
"pipes."
msgstr ""
"Доступно на платформах Unix, які підтримують передачу дескрипторів файлів "
"через канали Unix."

msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"У macOS метод запуску *spawn* тепер є типовим. Метод запуску *fork* слід "
"вважати небезпечним, оскільки він може призвести до збою підпроцесу. Див. :"
"issue:`33725`."

msgid ""
"*spawn* added on all unix platforms, and *forkserver* added for some unix "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"*spawn* додано на всіх платформах unix, а *forkserver* додано для деяких "
"платформ unix. Дочірні процеси більше не успадковують усі успадковані "
"дескриптори батьків у Windows."

msgid ""
"On Unix using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"В Unix використання методів запуску *spawn* або *forkserver* також запускає "
"процес *відстеження ресурсів*, який відстежує незв’язані іменовані системні "
"ресурси (такі як іменовані семафори або об’єкти :class:`~multiprocessing."
"shared_memory.SharedMemory`), створені процеси програми. Після завершення "
"роботи всіх процесів засіб відстеження ресурсів від’єднує будь-який "
"відстежуваний об’єкт, що залишився. Зазвичай їх не повинно бути, але якщо "
"процес було вбито сигналом, можливо, є деякі \"витік\" ресурсів. (Ані витік "
"семафорів, ані сегменти спільної пам’яті не будуть автоматично від’єднані до "
"наступного перезавантаження. Це проблематично для обох об’єктів, оскільки "
"система дозволяє лише обмежену кількість іменованих семафорів, а сегменти "
"спільної пам’яті займають деякий простір в основній пам’яті.)"

msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"Щоб вибрати метод запуску, ви використовуєте :func:`set_start_method` в "
"пункті ``if __name__ == '__main__'`` головного модуля. Наприклад::"

msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` не слід використовувати більше одного разу в "
"програмі."

msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Крім того, ви можете використовувати :func:`get_context`, щоб отримати "
"об’єкт контексту. Контекстні об’єкти мають той самий API, що й "
"багатопроцесорний модуль, і дозволяють використовувати кілька методів "
"запуску в одній програмі. ::"

msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Зауважте, що об’єкти, пов’язані з одним контекстом, можуть бути несумісними "
"з процесами для іншого контексту. Зокрема, блокування, створені за допомогою "
"контексту *fork*, не можна передати процесам, запущеним за допомогою методів "
"запуску *spawn* або *forkserver*."

msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr ""
"Бібліотека, яка хоче використовувати певний метод запуску, ймовірно, повинна "
"використовувати :func:`get_context`, щоб уникнути втручання у вибір "
"користувача бібліотеки."

msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods cannot currently be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on Unix. The ``'fork'`` start method does "
"work."
msgstr ""
"Методи запуску ``'spawn'`` і ``'forkserver'`` наразі не можна "
"використовувати із \"замороженими\" виконуваними файлами (тобто двійковими "
"файлами, створеними такими пакетами, як **PyInstaller** і **cx_Freeze**) в "
"Unix. Метод запуску ``'fork'`` працює."

msgid "Exchanging objects between processes"
msgstr "Обмін об'єктами між процесами"

msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` підтримує два типи каналів зв'язку між процесами:"

msgid "**Queues**"
msgstr "**Черги**"

msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr "Клас :class:`Queue` є майже клоном :class:`queue.Queue`. Наприклад::"

msgid "Queues are thread and process safe."
msgstr "Черги є потоковими та безпечними."

msgid "**Pipes**"
msgstr "**Труби**"

msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"Функція :func:`Pipe` повертає пару об’єктів з’єднання, з’єднаних трубою, яка "
"за умовчанням є дуплексною (двосторонньою). Наприклад::"

msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"Два об’єкти з’єднання, які повертає :func:`Pipe`, представляють два кінці "
"труби. Кожен об’єкт підключення має методи :meth:`~Connection.send` і :meth:"
"`~Connection.recv` (серед інших). Зауважте, що дані в каналі можуть бути "
"пошкоджені, якщо два процеси (або потоки) намагаються зчитувати або писати в "
"*той самий* кінець каналу одночасно. Звичайно, немає ризику пошкодження "
"через процеси, що використовують різні кінці труби одночасно."

msgid "Synchronization between processes"
msgstr "Синхронізація між процесами"

msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` містить еквіваленти всіх примітивів синхронізації з :"
"mod:`threading`. Наприклад, можна використовувати блокування, щоб "
"гарантувати, що лише один процес друкує на стандартний вивід одночасно:"

msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Без використання блокування вихідні дані різних процесів можуть "
"переплутатися."

msgid "Sharing state between processes"
msgstr "Спільне використання стану між процесами"

msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Як згадувалося вище, під час паралельного програмування зазвичай краще "
"уникати використання спільного стану, наскільки це можливо. Це особливо "
"актуально при використанні кількох процесів."

msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"Однак, якщо вам справді потрібно використовувати спільні дані, тоді :mod:"
"`multiprocessing` надає кілька способів зробити це."

msgid "**Shared memory**"
msgstr "**Спільна пам'ять**"

msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Дані можна зберігати в спільній карті пам’яті за допомогою :class:`Value` "
"або :class:`Array`. Наприклад, такий код::"

msgid "will print ::"
msgstr "надрукую ::"

msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Аргументи ``'d'`` і ``'i'``, що використовуються під час створення ``num`` і "
"``arr``, є кодами типу, які використовуються модулем :mod:`array`: ``' d''`` "
"вказує на число з плаваючою точкою подвійної точності, а ``'i''`` вказує на "
"ціле число зі знаком. Ці спільні об’єкти будуть безпечними для процесу та "
"потоків."

msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"Для більшої гнучкості використання спільної пам’яті можна використовувати "
"модуль :mod:`multiprocessing.sharedctypes`, який підтримує створення "
"довільних об’єктів ctypes, виділених із спільної пам’яті."

msgid "**Server process**"
msgstr "**Серверний процес**"

msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Об’єкт менеджера, який повертає :func:`Manager`, контролює серверний процес, "
"який містить об’єкти Python і дозволяє іншим процесам маніпулювати ними за "
"допомогою проксі-серверів."

msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
"Менеджер, який повертає :func:`Manager`, підтримуватиме типи :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock` і :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`. Наприклад, ::"

msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Менеджери серверних процесів є більш гнучкими, ніж використання спільних "
"об’єктів пам’яті, оскільки вони можуть підтримувати довільні типи об’єктів. "
"Крім того, один менеджер може спільно використовуватися процесами на різних "
"комп’ютерах у мережі. Однак вони повільніші, ніж використання спільної "
"пам’яті."

msgid "Using a pool of workers"
msgstr "Використання пулу працівників"

msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"Клас :class:`~multiprocessing.pool.Pool` представляє пул робочих процесів. "
"Він має методи, які дозволяють розвантажувати завдання на робочі процеси "
"кількома різними способами."

msgid "For example::"
msgstr "Наприклад::"

msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Зверніть увагу, що методи пулу повинні використовуватися тільки тим "
"процесом, який його створив."

msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"Функціональність цього пакета вимагає, щоб модуль ``__main__`` міг "
"імпортуватися дочірніми елементами. Це описано в :ref:`multiprocessing-"
"programming`, проте тут варто звернути увагу на це. Це означає, що деякі "
"приклади, такі як приклади :class:`multiprocessing.pool.Pool` не "
"працюватимуть в інтерактивному інтерпретаторі. Наприклад::"

msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Якщо ви спробуєте це, він фактично виведе три повні трасування, чергувані "
"напіввипадковим чином, і тоді вам, можливо, доведеться якось зупинити "
"батьківський процес.)"

msgid "Reference"
msgstr "довідка"

msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"Пакет :mod:`multiprocessing` здебільшого повторює API модуля :mod:"
"`threading`."

msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` і винятки"

msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Об’єкти процесу представляють діяльність, яка виконується в окремому "
"процесі. Клас :class:`Process` має еквіваленти всіх методів :class:"
"`threading.Thread`."

msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"Конструктор завжди слід викликати з ключовими аргументами. *group* завжди "
"має бути ``None``; він існує виключно для сумісності з :class:`threading."
"Thread`. *target* — об’єкт, який викликається методом :meth:`run()`. За "
"умовчанням встановлено ``None``, тобто нічого не викликається. *name* — це "
"ім’я процесу (див. :attr:`name` для отримання додаткової інформації). *args* "
"— це кортеж аргументів для цільового виклику. *kwargs* — це словник ключових "
"аргументів для цільового виклику. Якщо надано, аргумент *daemon*, що містить "
"лише ключове слово, встановлює для прапора процесу :attr:`daemon` значення "
"``True`` або ``False``. Якщо ``None`` (за замовчуванням), цей прапор буде "
"успадковано від процесу створення."

msgid "By default, no arguments are passed to *target*."
msgstr "За замовчуванням аргументи *target* не передаються."

msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""
"Якщо підклас перевизначає конструктор, він повинен переконатися, що він "
"викликає конструктор базового класу (:meth:`Process.__init__`), перш ніж "
"щось робити з процесом."

msgid "Added the *daemon* argument."
msgstr "Додано аргумент *daemon*."

msgid "Method representing the process's activity."
msgstr "Метод, що представляє діяльність процесу."

msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Ви можете перевизначити цей метод у підкласі. Стандартний метод :meth:`run` "
"викликає викликаний об’єкт, переданий конструктору об’єкта як цільовий "
"аргумент, якщо такий є, з послідовними аргументами та ключовими аргументами, "
"взятими з аргументів *args* і *kwargs* відповідно."

msgid "Start the process's activity."
msgstr "Запустіть процес."

msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Це має бути викликано щонайбільше один раз на об’єкт процесу. Він "
"організовує виклик методу :meth:`run` об’єкта в окремому процесі."

msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Якщо додатковий аргумент *timeout* має значення ``None`` (за замовчуванням), "
"метод блокується, доки процес, чий метод :meth:`join` викликається, не "
"завершиться. Якщо *timeout* є додатним числом, воно блокує щонайбільше "
"*timeout* секунд. Зауважте, що метод повертає ``None``, якщо його процес "
"завершується або якщо метод закінчився. Перевірте :attr:`exitcode` процесу, "
"щоб визначити, чи він завершився."

msgid "A process can be joined many times."
msgstr "До процесу можна приєднуватися багато разів."

msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"Процес не може приєднатися до себе, оскільки це спричинить тупикову "
"блокування. Спроба приєднатися до процесу до його запуску є помилкою."

msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"Назва процесу. Ім'я - це рядок, який використовується лише для "
"ідентифікації. Він не має семантики. Кілька процесів можуть мати однакові "
"назви."

msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"Початкове ім'я задається конструктором. Якщо конструктору не надано явної "
"назви, ім’я у формі 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`' "
"побудований, де кожен N\\ :sub:`k` є N-м дочірнім елементом свого батька."

msgid "Return whether the process is alive."
msgstr "Повернути, чи процес активний."

msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Приблизно, об’єкт процесу живий з моменту повернення методу :meth:`start` до "
"завершення дочірнього процесу."

msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"Прапор демона процесу, логічне значення. Це має бути встановлено перед "
"викликом :meth:`start`."

msgid "The initial value is inherited from the creating process."
msgstr "Початкове значення успадковується від процесу створення."

msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"Коли процес завершується, він намагається завершити всі свої демонічні "
"дочірні процеси."

msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Зауважте, що демонічному процесу не дозволяється створювати дочірні процеси. "
"Інакше демонічний процес залишив би своїх нащадків сиротами, якщо він буде "
"припинений під час завершення процесу батьківського процесу. Крім того, це "
"**не** демони чи служби Unix, це звичайні процеси, які будуть припинені (і "
"не приєднані), якщо недемонічні процеси вийшли."

msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"Окрім API :class:`threading.Thread`, об’єкти :class:`Process` також "
"підтримують такі атрибути та методи:"

msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Поверніть ідентифікатор процесу. До того, як процес буде створено, це буде "
"``None``."

msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr "Код виходу дитини. Це буде ``None``, якщо процес ще не завершено."

msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Якщо дочірній метод :meth:`run` повернувся нормально, код виходу буде 0. "
"Якщо він закінчився через :func:`sys.exit` із цілим аргументом *N*, код "
"виходу буде *N*."

msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Якщо дочірній процес завершився через виняток, який не було перехоплено в :"
"meth:`run`, код виходу буде 1. Якщо його було завершено сигналом *N*, код "
"виходу матиме від’ємне значення *-N*."

msgid "The process's authentication key (a byte string)."
msgstr "Ключ автентифікації процесу (рядок байтів)."

msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"Коли :mod:`multiprocessing` ініціалізовано, головному процесу призначається "
"випадковий рядок за допомогою :func:`os.urandom`."

msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"Коли об’єкт :class:`Process` створюється, він успадковує ключ автентифікації "
"свого батьківського процесу, хоча це можна змінити, встановивши :attr:"
"`authkey` інший байтовий рядок."

msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Перегляньте :ref:`multiprocessing-auth-keys`."

msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Числовий дескриптор системного об’єкта, який стане \"готовим\" після "
"завершення процесу."

msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` is "
"simpler."
msgstr ""
"Ви можете використовувати це значення, якщо хочете очікувати на кілька подій "
"одночасно за допомогою :func:`multiprocessing.connection.wait`. Інакше "
"викликати :meth:`join()` простіше."

msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On Unix, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"У Windows це дескриптор ОС, який можна використовувати з сімейством викликів "
"API ``WaitForSingleObject`` і ``WaitForMultipleObjects``. В Unix це файловий "
"дескриптор, який можна використовувати з примітивами з модуля :mod:`select`."

msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""
"Припиніть процес. В Unix це робиться за допомогою сигналу ``SIGTERM``; у "
"Windows використовується :c:func:`TerminateProcess`. Зауважте, що обробники "
"виходу, пропозиції finally тощо не виконуватимуться."

msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Зверніть увагу, що процеси-нащадки процесу *не* будуть припинені -- вони "
"просто стануть сиротами."

msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Якщо цей метод використовується, коли пов’язаний процес використовує канал "
"або чергу, канал або чергу можуть бути пошкоджені та можуть стати "
"непридатними для використання іншим процесом. Подібним чином, якщо процес "
"отримав блокування або семафор тощо, його завершення може призвести до "
"блокування інших процесів."

msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on Unix."
msgstr ""
"Те саме, що :meth:`terminate()`, але використовує сигнал ``SIGKILL`` в Unix."

msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Закрийте об’єкт :class:`Process`, звільнивши всі пов’язані з ним ресурси. :"
"exc:`ValueError` виникає, якщо основний процес все ще виконується. Після "
"успішного повернення :meth:`close` більшість інших методів і атрибутів "
"об’єкта :class:`Process` викличуть :exc:`ValueError`."

msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Зауважте, що методи :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` і :attr:`exitcode` має викликати лише процес, який створив "
"об’єкт процесу ."

msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Приклад використання деяких методів :class:`Process`:"

msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "Базовий клас усіх винятків :mod:`multiprocessing`."

msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"Виняток, викликаний :meth:`Connection.recv_bytes_into()`, коли наданий "
"об’єкт буфера замалий для прочитання повідомлення."

msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Якщо ``e`` є екземпляром :exc:`BufferTooShort`, то ``e.args[0]`` видасть "
"повідомлення як рядок байтів."

msgid "Raised when there is an authentication error."
msgstr "Викликається, коли виникає помилка автентифікації."

msgid "Raised by methods with a timeout when the timeout expires."
msgstr "Викликається методами з тайм-аутом, коли час очікування закінчується."

msgid "Pipes and Queues"
msgstr "Труби та черги"

msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"При використанні кількох процесів зазвичай використовується передача "
"повідомлень для зв’язку між процесами та уникається використання будь-яких "
"примітивів синхронізації, таких як блокування."

msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"Для передачі повідомлень можна використовувати :func:`Pipe` (для з’єднання "
"між двома процесами) або чергу (що дозволяє використовувати кілька "
"виробників і споживачів)."

msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Типи :class:`Queue`, :class:`SimpleQueue` і :class:`JoinableQueue` є чергами "
"багатьох виробників і споживачів :abbr:`FIFO (першим увійшов, першим "
"вийшов)`, змодельованими на основі :class:`queue.Queue` клас у стандартній "
"бібліотеці. Вони відрізняються тим, що :class:`Queue` не має методів :meth:"
"`~queue.Queue.task_done` і :meth:`~queue.Queue.join`, представлених у :class:"
"`queue.Queue` Python 2.5 клас."

msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Якщо ви використовуєте :class:`JoinableQueue`, тоді ви **має** викликати :"
"meth:`JoinableQueue.task_done` для кожного завдання, вилученого з черги, "
"інакше семафор, який використовується для підрахунку кількості незавершених "
"завдань, може зрештою переповнитися, викликаючи виняток."

msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Зауважте, що можна також створити спільну чергу за допомогою об’єкта "
"менеджера – див. :ref:`multiprocessing-managers`."

msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` використовує звичайні винятки :exc:`queue.Empty` і :"
"exc:`queue.Full`, щоб сигналізувати про час очікування. Вони недоступні в "
"просторі імен :mod:`multiprocessing`, тому їх потрібно імпортувати з :mod:"
"`queue`."

msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"Коли об’єкт ставиться в чергу, об’єкт очищається, а фоновий потік пізніше "
"скидає обрані дані в базовий канал. Це має деякі наслідки, які є трохи "
"дивними, але не повинні викликати жодних практичних труднощів - якщо вони "
"дійсно вас турбують, ви можете натомість використати чергу, створену за "
"допомогою :ref:`manager <multiprocessing-managers>`."

msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Після розміщення об’єкта в порожній черзі може виникнути нескінченно мала "
"затримка, перш ніж метод :meth:`~Queue.empty` черги поверне :const:`False`, "
"а :meth:`~Queue.get_nowait` зможе повернутися без виклику :exc:`queue.Empty`."

msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Якщо кілька процесів ставлять об’єкти в чергу, об’єкти можуть бути отримані "
"на іншому кінці не за порядком. Однак об’єкти, поставлені в чергу одним і "
"тим же процесом, завжди будуть в очікуваному порядку один відносно одного."

msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Якщо процес зупинено за допомогою :meth:`Process.terminate` або :func:`os."
"kill` під час спроби використання :class:`Queue`, то дані в черзі, ймовірно, "
"будуть пошкоджені. Це може призвести до того, що будь-який інший процес "
"отримає виняток, коли він спробує використати чергу пізніше."

msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Як згадувалося вище, якщо дочірній процес поставив елементи в чергу (і він "
"не використовував :meth:`JoinableQueue.cancel_join_thread <multiprocessing."
"Queue.cancel_join_thread>`), тоді цей процес не завершиться, доки всі "
"буферизовані елементи не будуть скинуті в канал."

msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Це означає, що якщо ви спробуєте приєднатися до цього процесу, ви можете "
"отримати тупикову блокування, якщо ви не впевнені, що всі елементи, які були "
"поставлені в чергу, використано. Так само, якщо дочірній процес є "
"недемонічним, тоді батьківський процес може зависнути при виході, коли він "
"намагається приєднатися до всіх своїх недемонічних дочірніх процесів."

msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Зауважте, що черга, створена за допомогою менеджера, не має цієї проблеми. "
"Дивіться :ref:`multiprocessing-programming`."

msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"Для прикладу використання черг для міжпроцесного зв’язку див. :ref:"
"`multiprocessing-examples`."

msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Повертає пару об’єктів ``(conn1, conn2)`` :class:`~multiprocessing."
"connection.Connection`, що представляють кінці труби."

msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Якщо *duplex* має значення ``True`` (за замовчуванням), тоді канал є "
"двонаправленим. Якщо *duplex* має значення ``False``, тоді канал є "
"односпрямованим: ``conn1`` можна використовувати лише для отримання "
"повідомлень, а ``conn2`` — лише для надсилання повідомлень."

msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Повертає спільну чергу процесу, реалізовану за допомогою каналу та кількох "
"блокувань/семафорів. Коли процес вперше ставить елемент у чергу, "
"запускається потік, який передає об’єкти з буфера в канал."

msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"Звичайні винятки :exc:`queue.Empty` і :exc:`queue.Full` із модуля :mod:"
"`queue` стандартної бібліотеки створюються, щоб повідомити про час "
"очікування."

msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` реалізує всі методи :class:`queue.Queue`, крім :meth:`~queue."
"Queue.task_done` і :meth:`~queue.Queue.join`."

msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Повертає приблизний розмір черги. Через семантику багатопоточності/"
"багатопроцесорності це число ненадійне."

msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"macOS where ``sem_getvalue()`` is not implemented."
msgstr ""
"Зауважте, що це може викликати :exc:`NotImplementedError` на платформах "
"Unix, таких як macOS, де ``sem_getvalue()`` не реалізовано."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Повертає ``True``, якщо черга порожня, ``False`` інакше. Через семантику "
"багатопоточності/багатопроцесорності це ненадійно."

msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Повертає ``True``, якщо черга заповнена, ``False`` інакше. Через семантику "
"багатопоточності/багатопроцесорності це ненадійно."

msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Помістіть obj у чергу. Якщо необов’язковий аргумент *block* має значення "
"``True`` (за замовчуванням), а *timeout* має значення ``None`` (за "
"замовчуванням), за потреби блокуйте, доки не з’явиться вільний слот. Якщо "
"*timeout* є додатним числом, він блокує щонайбільше *timeout* секунд і "
"викликає виняток :exc:`queue.Full`, якщо протягом цього часу не було "
"вільного місця. В іншому випадку (*block* має значення ``False``), помістіть "
"елемент у чергу, якщо вільний слот є негайно доступним, інакше викликайте "
"виняток :exc:`queue.Full` (*timeout* у цьому випадку ігнорується)."

msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Якщо чергу закрито, замість :exc:`AssertionError` виникає :exc:`ValueError`."

msgid "Equivalent to ``put(obj, False)``."
msgstr "Еквівалент ``put(obj, False)``."

msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Видалити та повернути елемент із черги. Якщо необов’язкові аргументи *block* "
"мають значення ``True`` (за замовчуванням), а *timeout* — ``None`` (за "
"замовчуванням), за потреби блокуйте, доки елемент не стане доступним. Якщо "
"*timeout* є додатним числом, він блокує щонайбільше *timeout* секунд і "
"викликає виняток :exc:`queue.Empty`, якщо жоден елемент не був доступний "
"протягом цього часу. В іншому випадку (блок має значення ``False``), "
"повертає елемент, якщо він одразу доступний, інакше викликає виняток :exc:"
"`queue.Empty` (у цьому випадку *timeout* ігнорується)."

msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr "Якщо чергу закрито, замість :exc:`OSError` виникає :exc:`ValueError`."

msgid "Equivalent to ``get(False)``."
msgstr "Еквівалент ``get(False)``."

msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` має кілька додаткових методів, яких немає в :"
"class:`queue.Queue`. Ці методи зазвичай непотрібні для більшості коду:"

msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""
"Укажіть, що поточний процес більше не додаватиме дані до цієї черги. Фоновий "
"потік завершиться, коли всі буферизовані дані буде скинуто в канал. Це "
"викликається автоматично, коли в черзі збирається сміття."

msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Приєднайтеся до фонової нитки. Це можна використовувати лише після виклику :"
"meth:`close`. Він блокується, доки не завершиться фоновий потік, гарантуючи, "
"що всі дані в буфері скинуті в канал."

msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"За замовчуванням, якщо процес не є творцем черги, після виходу він спробує "
"приєднатися до фонового потоку черги. Процес може викликати :meth:"
"`cancel_join_thread`, щоб змусити :meth:`join_thread` нічого не робити."

msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Запобігти блокуванню :meth:`join_thread`. Зокрема, це запобігає "
"автоматичному приєднанню фонового потоку під час завершення процесу -- див. :"
"meth:`join_thread`."

msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Кращою назвою для цього методу може бути ``allow_exit_without_flush()``. "
"Ймовірно, це спричинить втрату даних у черзі, і вам майже напевно не "
"потрібно буде їх використовувати. Насправді він доступний лише тоді, коли "
"вам потрібно, щоб поточний процес завершився негайно, не чекаючи, щоб "
"скинути дані з черги в основний канал, і ви не дбаєте про втрачені дані."

msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"Функціональність цього класу вимагає функціонуючої спільної реалізації "
"семафора в головній операційній системі. Без нього функціональні можливості "
"цього класу будуть вимкнені, а спроби створити екземпляр :class:`Queue` "
"призведуть до :exc:`ImportError`. Додаткову інформацію див. :issue:`3770`. "
"Те саме стосується будь-якого зі спеціалізованих типів черги, перелічених "
"нижче."

msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"Це спрощений тип :class:`Queue`, дуже схожий на заблокований :class:`Pipe`."

msgid "Close the queue: release internal resources."
msgstr "Закрийте чергу: звільніть внутрішні ресурси."

msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"Після закриття чергу більше не можна використовувати. Наприклад, методи :"
"meth:`get`, :meth:`put` і :meth:`empty` більше не можна викликати."

msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Повертає ``True``, якщо черга порожня, ``False`` інакше."

msgid "Remove and return an item from the queue."
msgstr "Видалити та повернути елемент із черги."

msgid "Put *item* into the queue."
msgstr "Поставте *товар* в чергу."

msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, підклас :class:`Queue`, це черга, яка додатково має "
"методи :meth:`task_done` і :meth:`join`."

msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Вказує на те, що завдання, яке раніше було в черзі, виконано. "
"Використовується споживачами черги. Для кожного :meth:`~Queue.get`, який "
"використовується для отримання завдання, наступний виклик :meth:`task_done` "
"повідомляє черзі, що обробку завдання завершено."

msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Якщо :meth:`~queue.Queue.join` зараз блокується, воно відновиться, коли всі "
"елементи будуть оброблені (це означає, що виклик :meth:`task_done` отримано "
"для кожного елемента, який був :meth:`~Queue.put` в чергу)."

msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Викликає :exc:`ValueError`, якщо викликається стільки разів, скільки було "
"елементів у черзі."

msgid "Block until all items in the queue have been gotten and processed."
msgstr "Блокуйте, доки не буде отримано та оброблено всі елементи в черзі."

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"Кількість незавершених завдань зростає щоразу, коли елемент додається до "
"черги. Підрахунок зменшується щоразу, коли споживач викликає :meth:"
"`task_done`, щоб вказати, що елемент отримано та вся робота над ним "
"завершена. Коли кількість незавершених завдань падає до нуля, :meth:`~queue."
"Queue.join` розблоковується."

msgid "Miscellaneous"
msgstr "Різне"

msgid "Return list of all live children of the current process."
msgstr "Повернути список усіх живих дітей поточного процесу."

msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Виклик цього має побічний ефект \"приєднання\" до будь-яких процесів, які "
"вже завершилися."

msgid "Return the number of CPUs in the system."
msgstr "Повертає кількість процесорів у системі."

msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"Це число не еквівалентно кількості ЦП, які може використовувати поточний "
"процес. Кількість доступних ЦП можна отримати за допомогою ``len(os."
"sched_getaffinity(0))``"

msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"Коли кількість ЦП не може бути визначена, виникає :exc:`NotImplementedError`."

msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "Повертає об’єкт :class:`Process`, що відповідає поточному процесу."

msgid "An analogue of :func:`threading.current_thread`."
msgstr "Аналог :func:`threading.current_thread`."

msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Повертає об’єкт :class:`Process`, що відповідає батьківському процесу :func:"
"`current_process`. Для основного процесу ``parent_process`` буде ``None``."

msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Додайте підтримку, коли програма, яка використовує :mod:`multiprocessing`, "
"була заморожена для створення виконуваного файлу Windows. (Було перевірено "
"за допомогою **py2exe**, **PyInstaller** і **cx_Freeze**.)"

msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"Цю функцію потрібно викликати відразу після рядка ``if __name__ == "
"'__main__'`` головного модуля. Наприклад::"

msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Якщо рядок ``freeze_support()`` пропущено, спроба запустити заморожений "
"виконуваний файл викличе :exc:`RuntimeError`."

msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"Виклик ``freeze_support()`` не має ефекту під час виклику в будь-якій "
"операційній системі, крім Windows. Крім того, якщо модуль нормально "
"запускається інтерпретатором Python у Windows (програма не була заморожена), "
"то ``freeze_support()`` не має ефекту."

msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being the "
"default."
msgstr ""
"Повертає список підтримуваних методів запуску, перший із яких є типовим. "
"Можливі методи запуску: ``'fork'``, ``'spawn'`` і ``'forkserver'``. У "
"Windows доступний лише ``'spawn''``. В Unix ``'fork'`` і ``'spawn'`` завжди "
"підтримуються, при цьому ``'fork''`` є типовим."

msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Повертає об’єкт контексту, який має ті самі атрибути, що й модуль :mod:"
"`multiprocessing`."

msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available."
msgstr ""
"Якщо *method* має значення ``None``, тоді повертається контекст за "
"замовчуванням. Інакше *method* має бути ``'fork'``, ``'spawn'``, "
"``'forkserver'``. :exc:`ValueError` виникає, якщо вказаний метод запуску "
"недоступний."

msgid "Return the name of start method used for starting processes."
msgstr ""
"Повертає назву методу запуску, який використовується для запуску процесів."

msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"Якщо метод запуску не було виправлено і *allow_none* має значення false, "
"тоді метод запуску фіксується за замовчуванням і повертається ім’я. Якщо "
"метод запуску не було виправлено і *allow_none* має значення true, тоді "
"повертається ``None``."

msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows and macOS."
msgstr ""
"Поверненим значенням може бути ``'fork'``, ``'spawn'``, ``'forkserver'`` або "
"``None``. ``'fork'`` є типовим для Unix, тоді як ``'spawn''`` є типовим для "
"Windows і macOS."

msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Встановіть шлях інтерпретатора Python для використання під час запуску "
"дочірнього процесу. (За замовчуванням використовується :data:`sys."
"executable`). Вбудовувачі, ймовірно, повинні будуть зробити щось на зразок:"

msgid "before they can create child processes."
msgstr "перш ніж вони зможуть створити дочірні процеси."

msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr ""
"Тепер підтримується в Unix, коли використовується метод запуску ``'spawn'``."

msgid ""
"Set the method which should be used to start child processes. *method* can "
"be ``'fork'``, ``'spawn'`` or ``'forkserver'``."
msgstr ""
"Встановіть метод, який слід використовувати для запуску дочірніх процесів. "
"*метод* може бути ``'fork'``, ``'spawn'`` або ``'forkserver'``."

msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Зверніть увагу, що це має бути викликано щонайбільше один раз, і його слід "
"захистити всередині пропозиції ``if __name__ == '__main__'`` головного "
"модуля."

msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` не містить аналогів :func:`threading.active_count`, :"
"func:`threading.enumerate`, :func:`threading.settrace`, :func:`threading."
"setprofile`, :class:`threading.Timer` або :class:`threading.local`."

msgid "Connection Objects"
msgstr "Об'єкти підключення"

msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Об’єкти підключення дозволяють надсилати та отримувати об’єкти або рядки, "
"які можна вибрати. Їх можна розглядати як підключені сокети, орієнтовані на "
"повідомлення."

msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Об’єкти підключення зазвичай створюються за допомогою :func:`Pipe "
"<multiprocessing.Pipe>` -- див. також :ref:`multiprocessing-listeners-"
"clients`."

msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Надішліть об’єкт на інший кінець з’єднання, який слід прочитати за "
"допомогою :meth:`recv`."

msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"Об'єкт має бути маринованим. Дуже великі pickles (приблизно 32 MiB+, хоча це "
"залежить від ОС) можуть викликати виняток :exc:`ValueError`."

msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Повернути об’єкт, надісланий з іншого кінця з’єднання за допомогою :meth:"
"`send`. Блокує, поки не буде що отримати. Викликає :exc:`EOFError`, якщо не "
"залишилося нічого для отримання, а інший кінець був закритий."

msgid "Return the file descriptor or handle used by the connection."
msgstr ""
"Повертає дескриптор файлу або дескриптор, який використовується підключенням."

msgid "Close the connection."
msgstr "Закрийте з'єднання."

msgid "This is called automatically when the connection is garbage collected."
msgstr "Це викликається автоматично, коли підключення збирається сміттям."

msgid "Return whether there is any data available to be read."
msgstr "Повернути, чи є дані для читання."

msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Якщо *timeout* не вказано, він негайно повернеться. Якщо *timeout* є числом, "
"це вказує максимальний час у секундах для блокування. Якщо *timeout* має "
"значення ``None``, тоді використовується нескінченний тайм-аут."

msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Зауважте, що кілька об’єктів з’єднання можна опитувати одночасно за "
"допомогою :func:`multiprocessing.connection.wait`."

msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Надіслати байтові дані з :term:`bytes-like object` як повне повідомлення."

msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Якщо вказано *зсув*, дані зчитуються з цієї позиції в *буфері*. Якщо задано "
"*size*, то стільки байтів буде прочитано з буфера. Дуже великі буфери "
"(приблизно 32 MiB+, хоча це залежить від ОС) можуть викликати виключення :"
"exc:`ValueError`"

msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Повертає повне повідомлення байтових даних, надісланих з іншого кінця "
"з’єднання, у вигляді рядка. Блокує, поки не буде що отримати. Викликає :exc:"
"`EOFError`, якщо не залишилося нічого для отримання, а інший кінець закрито."

msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Якщо вказано *maxlength* і повідомлення довше, ніж *maxlength*, тоді "
"виникає :exc:`OSError` і з’єднання більше не читається."

msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Раніше ця функція викликала :exc:`IOError`, який тепер є псевдонімом :exc:"
"`OSError`."

msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Прочитайте в *buffer* повне повідомлення байтових даних, надісланих з іншого "
"кінця з’єднання, і поверніть кількість байтів у повідомленні. Блокує, поки "
"не буде що отримати. Викликає :exc:`EOFError`, якщо не залишилося нічого для "
"отримання, а інший кінець був закритий."

msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* має бути доступним для запису :term:`bytes-like object`. Якщо "
"задано *offset*, повідомлення буде записано в буфер із цієї позиції. Зсув "
"має бути невід’ємним цілим числом, меншим за довжину *буфера* (у байтах)."

msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Якщо буфер закороткий, виникає виняток :exc:`BufferTooShort`, і повне "
"повідомлення доступне як ``e.args[0]``, де ``e`` є винятком."

msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Самі об’єкти підключення тепер можна передавати між процесами за допомогою :"
"meth:`Connection.send` і :meth:`Connection.recv`."

msgid ""
"Connection objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Об’єкти підключення тепер підтримують протокол керування контекстом – див. :"
"ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` повертає об’єкт "
"підключення, а :meth:`~contextmanager.__exit__` викликає :meth:`close`."

msgid "For example:"
msgstr "Наприклад:"

msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"Метод :meth:`Connection.recv` автоматично видаляє отримані дані, що може "
"становити загрозу безпеці, якщо ви не можете довіряти процесу, який надіслав "
"повідомлення."

msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Таким чином, якщо об’єкт підключення не було створено за допомогою :func:"
"`Pipe`, ви повинні використовувати лише методи :meth:`~Connection.recv` і :"
"meth:`~Connection.send` після виконання певної автентифікації. Перегляньте :"
"ref:`multiprocessing-auth-keys`."

msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Якщо процес зупиняється під час спроби читання або запису в канал, то дані в "
"каналі, ймовірно, будуть пошкоджені, тому що може стати неможливо точно "
"визначити, де пролягають межі повідомлення."

msgid "Synchronization primitives"
msgstr "Примітиви синхронізації"

msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Зазвичай примітиви синхронізації не такі необхідні в багатопроцесовій "
"програмі, як у багатопотоковій програмі. Перегляньте документацію для "
"модуля :mod:`threading`."

msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Зауважте, що можна також створити примітиви синхронізації за допомогою "
"об’єкта менеджера – див. :ref:`multiprocessing-managers`."

msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Бар’єрний об’єкт: клон :class:`threading.Barrier`."

msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Обмежений семафорний об’єкт: близький аналог :class:`threading."
"BoundedSemaphore`."

msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"Існує єдина відмінність від його близького аналога: перший аргумент методу "
"``acquire`` має назву *block*, що узгоджується з :meth:`Lock.acquire`."

msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"У macOS це неможливо відрізнити від :class:`Semaphore`, оскільки "
"``sem_getvalue()`` не реалізовано на цій платформі."

msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "Змінна умови: псевдонім для :class:`threading.Condition`."

msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Якщо вказано *lock*, це має бути об’єкт :class:`Lock` або :class:`RLock` із :"
"mod:`multiprocessing`."

msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "Додано метод :meth:`~threading.Condition.wait_for`."

msgid "A clone of :class:`threading.Event`."
msgstr "Клон :class:`threading.Event`."

msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Нерекурсивний об’єкт блокування: близький аналог :class:`threading.Lock`. "
"Після того, як процес або потік отримав блокування, наступні спроби отримати "
"його від будь-якого процесу або потоку будуть блокуватися, доки його не буде "
"звільнено; будь-який процес або потік може його звільнити. Концепції та "
"поведінка :class:`threading.Lock`, які застосовуються до потоків, відтворені "
"тут у :class:`multiprocessing.Lock`, оскільки вони застосовуються до "
"процесів або потоків, за винятком зазначених випадків."

msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Зауважте, що :class:`Lock` насправді є фабричною функцією, яка повертає "
"примірник ``multiprocessing.synchronize.Lock``, ініціалізований контекстом "
"за замовчуванням."

msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` підтримує протокол :term:`context manager` і тому може "
"використовуватися в :keyword:`with` операторах."

msgid "Acquire a lock, blocking or non-blocking."
msgstr "Отримайте блокування, блокування або неблокування."

msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Якщо для аргументу *block* встановлено значення ``True`` (за замовчуванням), "
"виклик методу блокуватиметься, доки блокування не перейде в розблокований "
"стан, а потім встановлюватиме для нього значення ``True`` і повертатиме "
"``True``. Зауважте, що назва цього першого аргументу відрізняється від такої "
"в :meth:`threading.Lock.acquire`."

msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Якщо для аргументу *block* встановлено значення ``False``, виклик методу не "
"блокується. Якщо блокування зараз у заблокованому стані, поверніть "
"``False``; інакше встановіть блокування в заблокований стан і поверніть "
"``True``."

msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"При виклику з додатним значенням з плаваючою комою для *timeout*, блокувати "
"щонайбільше на кількість секунд, визначену *timeout*, доки не вдасться "
"отримати блокування. Виклики з від’ємним значенням для *timeout* "
"еквівалентні *timeout* рівному нулю. Виклики зі значенням *timeout* ``None`` "
"(за замовчуванням) встановлюють період очікування як нескінченний. Зауважте, "
"що обробка негативних значень або значень ``None`` для *timeout* "
"відрізняється від реалізованої поведінки в :meth:`threading.Lock.acquire`. "
"Аргумент *timeout* не має практичного значення, якщо для аргументу *block* "
"встановлено значення ``False`` і, таким чином, він ігнорується. Повертає "
"``True``, якщо блокування отримано, або ``False``, якщо період очікування "
"минув."

msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Відпустіть блокування. Це може бути викликано з будь-якого процесу або "
"потоку, а не тільки процесу або потоку, який спочатку отримав блокування."

msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"Поведінка така ж, як у :meth:`threading.Lock.release`, за винятком того, що "
"під час виклику для розблокованого блокування виникає :exc:`ValueError`."

msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Об’єкт рекурсивного блокування: близький аналог :class:`threading.RLock`. "
"Рекурсивне блокування має бути звільнено процесом або потоком, який його "
"отримав. Після того як процес або потік отримав рекурсивне блокування, той "
"самий процес або потік може отримати його знову без блокування; цей процес "
"або потік повинен випускати його один раз за кожен раз, коли його було "
"отримано."

msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Зауважте, що :class:`RLock` насправді є фабричною функцією, яка повертає "
"екземпляр ``multiprocessing.synchronize.RLock``, ініціалізований контекстом "
"за замовчуванням."

msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` підтримує протокол :term:`context manager` і тому може "
"використовуватися в :keyword:`with` операторах."

msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"При виклику з аргументом *block*, встановленим у значення ``True``, "
"блокувати, доки блокування не буде в розблокованому стані (не належить "
"жодному процесу або потоку), якщо блокування вже не належить поточному "
"процесу або потоку. Тоді поточний процес або потік отримує право власності "
"на блокування (якщо він ще не має права власності), а рівень рекурсії "
"всередині блокування збільшується на одиницю, що призводить до повернення "
"значення ``True``. Зауважте, що є кілька відмінностей у поведінці цього "
"першого аргументу порівняно з реалізацією :meth:`threading.RLock.acquire`, "
"починаючи з назви самого аргументу."

msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"При виклику з аргументом *block*, встановленим на ``False``, не блокувати. "
"Якщо блокування вже було отримано (і, отже, ним володіє) інший процес або "
"потік, поточний процес або потік не приймає права власності, а рівень "
"рекурсії в межах блокування не змінюється, що призводить до повернення "
"значення ``False`` . Якщо блокування знаходиться в розблокованому стані, "
"поточний процес або потік приймає право власності, і рівень рекурсії "
"збільшується, що призводить до повернення значення ``True``."

msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"Використання та поведінка аргументу *timeout* такі ж, як і в :meth:`Lock."
"acquire`. Зауважте, що деякі з цих дій *timeout* відрізняються від "
"реалізованих у :meth:`threading.RLock.acquire`."

msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Зніміть блокування, зменшивши рівень рекурсії. Якщо після зменшення рівень "
"рекурсії дорівнює нулю, скиньте блокування до розблокованого (не належить "
"жодному процесу чи потоку), а якщо будь-які інші процеси чи потоки "
"заблоковані в очікуванні розблокування блокування, дозвольте рівно одному з "
"них продовжити. Якщо після декременту рівень рекурсії все ще ненульовий, "
"блокування залишається заблокованим і належить процесу або потоку, що "
"викликає."

msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Викликайте цей метод лише тоді, коли процес або потік, що викликає, володіє "
"блокуванням. Помилка :exc:`AssertionError` виникає, якщо цей метод "
"викликається процесом або потоком, відмінним від власника, або якщо "
"блокування знаходиться в розблокованому стані (не належить). Зауважте, що "
"тип винятку, викликаного в цій ситуації, відрізняється від реалізованої "
"поведінки в :meth:`threading.RLock.release`."

msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "Об’єкт семафор: близький аналог :class:`threading.Semaphore`."

msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"У macOS ``sem_timedwait`` не підтримується, тому виклик ``acquire()`` із "
"тайм-аутом буде емулювати поведінку цієї функції за допомогою циклу сну."

msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""
"Якщо сигнал SIGINT, згенерований :kbd:`Ctrl-C`, надходить, коли основний "
"потік заблоковано викликом :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` або :meth:`Condition.wait`, тоді виклик буде негайно перервано та :"
"exc:`KeyboardInterrupt` буде викликано."

msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""
"Це відрізняється від поведінки :mod:`threading`, де SIGINT ігноруватиметься, "
"поки виконуються еквівалентні виклики блокування."

msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"Для деяких функцій цього пакета необхідна функціональна реалізація спільного "
"семафора в головній операційній системі. Без нього модуль :mod:"
"`multiprocessing.synchronize` буде вимкнено, а спроби його імпортувати "
"призведуть до :exc:`ImportError`. Додаткову інформацію див. :issue:`3770`."

msgid "Shared :mod:`ctypes` Objects"
msgstr "Спільні об’єкти :mod:`ctypes`"

msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"Можна створювати спільні об’єкти, використовуючи спільну пам’ять, яку можуть "
"успадковувати дочірні процеси."

msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Повертає об’єкт :mod:`ctypes`, виділений зі спільної пам’яті. За "
"замовчуванням значення, що повертається, фактично є синхронізованою "
"оболонкою для об’єкта. До самого об’єкта можна отримати доступ через атрибут "
"*value* :class:`Value`."

msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* визначає тип повернутого об’єкта: це або тип ctypes, або "
"односимвольний код типу, який використовується модулем :mod:`array`. "
"*\\*args* передається конструктору для типу."

msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Якщо *lock* має значення ``True`` (за замовчуванням), тоді створюється новий "
"об’єкт рекурсивного блокування для синхронізації доступу до значення. Якщо "
"*lock* є об’єктом :class:`Lock` або :class:`RLock`, то він "
"використовуватиметься для синхронізації доступу до значення. Якщо *lock* має "
"значення ``False``, тоді доступ до повернутого об’єкта не буде автоматично "
"захищений блокуванням, тому він не обов’язково буде \"безпечним для "
"процесу\"."

msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Такі операції, як ``+=``, які передбачають читання та запис, не є "
"атомарними. Отже, якщо, наприклад, ви хочете атомарно збільшити спільне "
"значення, недостатньо просто зробити ::"

msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Якщо припустити, що пов’язане блокування є рекурсивним (що є за "
"замовчуванням), ви можете замість цього зробити:"

msgid "Note that *lock* is a keyword-only argument."
msgstr "Зверніть увагу, що *lock* є аргументом лише для ключового слова."

msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Повертає масив ctypes, виділений зі спільної пам’яті. За замовчуванням "
"значення, що повертається, фактично є синхронізованою оболонкою для масиву."

msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* визначає тип елементів повернутого масиву: це або тип "
"ctypes, або односимвольний код типу, який використовується модулем :mod:"
"`array`. Якщо *size_or_initializer* є цілим числом, воно визначає довжину "
"масиву, і масив буде спочатку обнулений. В іншому випадку "
"*size_or_initializer* — це послідовність, яка використовується для "
"ініціалізації масиву, довжина якої визначає довжину масиву."

msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Якщо *lock* має значення ``True`` (за замовчуванням), тоді створюється новий "
"об’єкт блокування для синхронізації доступу до значення. Якщо *lock* є "
"об’єктом :class:`Lock` або :class:`RLock`, то він використовуватиметься для "
"синхронізації доступу до значення. Якщо *lock* має значення ``False``, тоді "
"доступ до повернутого об’єкта не буде автоматично захищений блокуванням, "
"тому він не обов’язково буде \"безпечним для процесу\"."

msgid "Note that *lock* is a keyword only argument."
msgstr "Зауважте, що *lock* є лише ключовим аргументом."

msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Зауважте, що масив :data:`ctypes.c_char` має атрибути *value* і *raw*, які "
"дозволяють використовувати його для зберігання та отримання рядків."

msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr "Модуль :mod:`multiprocessing.sharedctypes`"

msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"Модуль :mod:`multiprocessing.sharedctypes` надає функції для виділення "
"об’єктів :mod:`ctypes` зі спільної пам’яті, які можуть бути успадковані "
"дочірніми процесами."

msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Хоча можна зберігати вказівник у спільній пам’яті, пам’ятайте, що це "
"посилатиметься на розташування в адресному просторі певного процесу. Однак "
"вказівник, швидше за все, буде недійсним у контексті другого процесу, і "
"спроба розіменувати вказівник з другого процесу може спричинити збій."

msgid "Return a ctypes array allocated from shared memory."
msgstr "Повертає масив ctypes, виділений зі спільної пам’яті."

msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* визначає тип елементів повернутого масиву: це або тип "
"ctypes, або односимвольний код типу, який використовується модулем :mod:"
"`array`. Якщо *size_or_initializer* є цілим числом, воно визначає довжину "
"масиву, і масив буде спочатку обнулено. В іншому випадку "
"*size_or_initializer* — це послідовність, яка використовується для "
"ініціалізації масиву і довжина якої визначає довжину масиву."

msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Зауважте, що встановлення й отримання елемента потенційно не є атомарним — "
"замість цього використовуйте :func:`Array`, щоб переконатися, що доступ "
"автоматично синхронізується за допомогою блокування."

msgid "Return a ctypes object allocated from shared memory."
msgstr "Повертає об’єкт ctypes, виділений зі спільної пам’яті."

msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Зауважте, що встановлення й отримання значення потенційно не є атомарним — "
"замість цього використовуйте :func:`Value`, щоб переконатися, що доступ "
"автоматично синхронізується за допомогою блокування."

msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Зауважте, що масив :data:`ctypes.c_char` має атрибути ``value`` і ``raw``, "
"які дозволяють використовувати його для зберігання та отримання рядків - "
"дивіться документацію для :mod:`ctypes`."

msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"Те саме, що :func:`RawArray`, за винятком того, що залежно від значення "
"*lock* замість необробленого масиву ctypes може повертатися обгортка "
"синхронізації, безпечна для процесу."

msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Якщо *lock* має значення ``True`` (за замовчуванням), тоді створюється новий "
"об’єкт блокування для синхронізації доступу до значення. Якщо *lock* є "
"об’єктом :class:`~multiprocessing.Lock` або :class:`~multiprocessing.RLock`, "
"то він використовуватиметься для синхронізації доступу до значення. Якщо "
"*lock* має значення ``False``, тоді доступ до повернутого об’єкта не буде "
"автоматично захищений блокуванням, тому він не обов’язково буде \"безпечним "
"для процесу\"."

msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"Те саме, що :func:`RawValue`, за винятком того, що залежно від значення "
"*lock* замість необробленого об’єкта ctypes може повертатися безпечна для "
"процесу оболонка синхронізації."

msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Повертає об’єкт ctypes, виділений зі спільної пам’яті, який є копією об’єкта "
"ctypes *obj*."

msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Повертає безпечний для процесу об’єкт оболонки для об’єкта ctypes, який "
"використовує *lock* для синхронізації доступу. Якщо *lock* має значення "
"``None`` (за замовчуванням), то об’єкт :class:`multiprocessing.RLock` "
"створюється автоматично."

msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"Синхронізована оболонка матиме два методи на додаток до методів об’єкта, "
"який вона обертає: :meth:`get_obj` повертає обгорнутий об’єкт, а :meth:"
"`get_lock` повертає об’єкт блокування, який використовується для "
"синхронізації."

msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Зверніть увагу, що доступ до об’єкта ctypes через оболонку може бути "
"набагато повільнішим, ніж доступ до необробленого об’єкта ctypes."

msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "Синхронізовані об’єкти підтримують протокол :term:`context manager`."

msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"У наведеній нижче таблиці порівнюється синтаксис для створення спільних "
"об’єктів ctypes зі спільної пам’яті зі звичайним синтаксисом ctypes. (У "
"таблиці ``MyStruct`` є деякий підклас :class:`ctypes.Structure`.)"

msgid "ctypes"
msgstr "ctypes"

msgid "sharedctypes using type"
msgstr "sharedctypes за допомогою типу"

msgid "sharedctypes using typecode"
msgstr "sharedctypes з використанням коду типу"

msgid "c_double(2.4)"
msgstr "c_double (2,4)"

msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2,4)"

msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2,4)"

msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"Нижче наведено приклад, коли кілька об’єктів ctypes змінено дочірнім "
"процесом:"

msgid "The results printed are ::"
msgstr "Надруковані результати:"

msgid "Managers"
msgstr "Менеджери"

msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Менеджери надають можливість створювати дані, якими можна ділитися між "
"різними процесами, включно з загальним доступом через мережу між процесами, "
"що виконуються на різних машинах. Об’єкт менеджера контролює серверний "
"процес, який керує *спільними об’єктами*. Інші процеси можуть отримати "
"доступ до спільних об’єктів за допомогою проксі-серверів."

msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Повертає запущений об’єкт :class:`~multiprocessing.managers.SyncManager`, "
"який можна використовувати для спільного використання об’єктів між "
"процесами. Повернений об’єкт менеджера відповідає породженому дочірньому "
"процесу та має методи, які створюватимуть спільні об’єкти та повертатимуть "
"відповідні проксі-сервери."

msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Процеси менеджера буде закрито, щойно їх буде зібрано сміття або їхній "
"батьківський процес завершиться. Класи менеджерів визначені в модулі :mod:"
"`multiprocessing.managers`:"

msgid "Create a BaseManager object."
msgstr "Створіть об’єкт BaseManager."

msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"Після створення потрібно викликати :meth:`start` або ``get_server()."
"serve_forever()``, щоб переконатися, що об’єкт менеджера посилається на "
"запущений процес менеджера."

msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*адреса* — це адреса, на якій процес менеджера прослуховує нові підключення. "
"Якщо *адреса* має значення ``None``, тоді вибирається довільна адреса."

msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* — це ключ автентифікації, який використовуватиметься для перевірки "
"дійсності вхідних підключень до процесу сервера. Якщо *authkey* має значення "
"``None``, тоді використовується ``current_process().authkey``. В іншому "
"випадку використовується *authkey*, і це має бути рядок байтів."

msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Запустіть підпроцес, щоб запустити менеджер. Якщо *initializer* не ``None``, "
"тоді підпроцес викличе ``initializer(*initargs)`` під час запуску."

msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Повертає об’єкт :class:`Server`, який представляє фактичний сервер під "
"керуванням менеджера. Об’єкт :class:`Server` підтримує метод :meth:"
"`serve_forever`::"

msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` додатково має атрибут :attr:`address`."

msgid "Connect a local manager object to a remote manager process::"
msgstr ""
"Підключіть об’єкт локального менеджера до віддаленого процесу менеджера:"

msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Зупиніть процес, який використовує менеджер. Це доступно, лише якщо :meth:"
"`start` було використано для запуску процесу сервера."

msgid "This can be called multiple times."
msgstr "Це можна викликати кілька разів."

msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"Метод класу, який можна використовувати для реєстрації типу або виклику в "
"класі менеджера."

msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* — це \"ідентифікатор типу\", який використовується для "
"ідентифікації певного типу спільного об’єкта. Це має бути рядок."

msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* — це виклик, який використовується для створення об’єктів для "
"ідентифікатора цього типу. Якщо екземпляр менеджера буде підключено до "
"сервера за допомогою методу :meth:`connect` або якщо аргумент "
"*create_method* має значення ``False``, тоді це можна залишити як ``None``."

msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* є підкласом :class:`BaseProxy`, який використовується для "
"створення проксі для спільних об’єктів із цим *typeid*. Якщо ``None``, то "
"проксі-клас створюється автоматично."

msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* використовується для визначення послідовності назв методів, до "
"яких проксі-серверам для цього typeid має бути дозволено доступ за "
"допомогою :meth:`BaseProxy._callmethod`. (Якщо *exposed* має значення "
"``None``, тоді замість нього використовується :attr:`proxytype._exposed_`, "
"якщо він існує.) У випадку, коли відкритий список не вказано, усі "
"\"загальнодоступні методи\" спільного об’єкта будуть доступними. . (Тут "
"\"публічний метод\" означає будь-який атрибут, який має метод :meth:`~object."
"__call__` і ім’я якого не починається з ``'_'``.)"

msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* — це зіставлення, яке використовується для визначення "
"типу повернення тих відкритих методів, які мають повертати проксі. Він "
"відображає назви методів у рядках typeid. (Якщо *method_to_typeid* має "
"значення ``None``, тоді замість нього використовується :attr:`proxytype."
"_method_to_typeid_`, якщо він існує.) Якщо назва методу не є ключем цього "
"відображення або якщо відображення має значення ``None``, тоді об'єкт, "
"повернутий методом, буде скопійовано за значенням."

msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* визначає, чи слід створювати метод з іменем *typeid*, яке "
"можна використовувати, щоб наказати серверному процесу створити новий "
"спільний об’єкт і повернути для нього проксі. За замовчуванням це ``True``."

msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""
"Екземпляри :class:`BaseManager` також мають одну властивість лише для "
"читання:"

msgid "The address used by the manager."
msgstr "Адреса, яку використовує менеджер."

msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Об’єкти менеджера підтримують протокол керування контекстом – див. :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` запускає серверний "
"процес (якщо він ще не запущений), а потім повертає об’єкт менеджера. :meth:"
"`~contextmanager.__exit__` викликає :meth:`shutdown`."

msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"У попередніх версіях :meth:`~contextmanager.__enter__` не запускав серверний "
"процес менеджера, якщо він ще не був запущений."

msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"Підклас :class:`BaseManager`, який можна використовувати для синхронізації "
"процесів. Об’єкти цього типу повертає :func:`multiprocessing.Manager`."

msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Його методи створюють і повертають :ref:`multiprocessing-proxy_objects` для "
"ряду типів даних, які зазвичай використовуються, щоб синхронізувати між "
"процесами. Це, зокрема, включає спільні списки та словники."

msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.Barrier` і поверніть для нього "
"проксі."

msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.BoundedSemaphore` і поверніть для "
"нього проксі."

msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.Condition` і поверніть для нього "
"проксі."

msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Якщо вказано *lock*, це має бути проксі для об’єкта :class:`threading.Lock` "
"або :class:`threading.RLock`."

msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.Event` і поверніть для нього "
"проксі."

msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.Lock` і поверніть для нього "
"проксі."

msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`Namespace` і поверніть для нього проксі."

msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`queue.Queue` і поверніть для нього проксі."

msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.RLock` і поверніть для нього "
"проксі."

msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Створіть спільний об’єкт :class:`threading.Semaphore` і поверніть для нього "
"проксі."

msgid "Create an array and return a proxy for it."
msgstr "Створіть масив і поверніть для нього проксі."

msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Створіть об’єкт із доступним для запису атрибутом \"значення\" та поверніть "
"для нього проксі-сервер."

msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "Створіть спільний об’єкт :class:`dict` і поверніть для нього проксі."

msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "Створіть спільний об’єкт :class:`list` і поверніть для нього проксі."

msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Спільні об’єкти можуть бути вкладеними. Наприклад, спільний об’єкт-"
"контейнер, такий як спільний список, може містити інші спільні об’єкти, "
"якими керуватиме та синхронізуватиме :class:`SyncManager`."

msgid "A type that can register with :class:`SyncManager`."
msgstr "Тип, який можна зареєструвати в :class:`SyncManager`."

msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Об’єкт простору імен не має відкритих методів, але має атрибути, доступні "
"для запису. Його подання показує значення його атрибутів."

msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"Однак, коли використовується проксі для об’єкта простору імен, атрибут, що "
"починається з ``'_''`` буде атрибутом проксі, а не атрибутом референта:"

msgid "Customized managers"
msgstr "Індивідуальні менеджери"

msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"Щоб створити власний менеджер, потрібно створити підклас :class:"
"`BaseManager` і використовувати метод класу :meth:`~BaseManager.register` "
"для реєстрації нових типів або викликів у класі менеджера. Наприклад::"

msgid "Using a remote manager"
msgstr "Використання віддаленого менеджера"

msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"Можна запустити керуючий сервер на одній машині, а клієнти "
"використовуватимуть його з інших машин (за умови, що задіяні брандмауери "
"дозволяють це)."

msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"Виконання наступних команд створює сервер для однієї спільної черги, до якої "
"мають доступ віддалені клієнти:"

msgid "One client can access the server as follows::"
msgstr "Один клієнт може отримати доступ до сервера наступним чином:"

msgid "Another client can also use it::"
msgstr "Інший клієнт також може використовувати його:"

msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Локальні процеси також можуть отримати доступ до цієї черги, використовуючи "
"код вище на клієнті для доступу до неї віддалено:"

msgid "Proxy Objects"
msgstr "Проксі об'єкти"

msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"Проксі — це об’єкт, який *посилається* на спільний об’єкт, який живе "
"(імовірно) в іншому процесі. Спільний об’єкт називається *референтом* "
"проксі. Кілька проксі-об’єктів можуть мати один і той же референт."

msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Проксі-об’єкт має методи, які викликають відповідні методи його референта "
"(хоча не кожен метод референта обов’язково буде доступним через проксі). "
"Таким чином, проксі можна використовувати так само, як і його референт:"

msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Зауважте, що застосування :func:`str` до проксі поверне подання референта, "
"тоді як застосування :func:`repr` поверне подання проксі."

msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"Важливою особливістю проксі-об’єктів є те, що їх можна вибирати, тому їх "
"можна передавати між процесами. Таким чином, референт може містити :ref:"
"`multiprocessing-proxy_objects`. Це дозволяє вкладати ці керовані списки, "
"dicts та інші :ref:`multiprocessing-proxy_objects`:"

msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""
"Подібним чином, проксі dict і список можуть бути вкладені один в одного:"

msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Якщо стандартні (не проксі) :class:`list` або :class:`dict` об’єкти "
"містяться в референті, модифікації цих змінних значень не поширюватимуться "
"через менеджер, оскільки проксі не може дізнатися, коли значення що "
"містяться в них, змінено. Однак збереження значення в проксі-контейнері (що "
"запускає ``__setitem__`` в проксі-об’єкті) поширюється через менеджер, тому "
"для ефективної зміни такого елемента можна повторно призначити змінене "
"значення проксі-серверу контейнера: :"

msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Цей підхід, можливо, менш зручний, ніж використання вкладених :ref:"
"`multiprocessing-proxy_objects` для більшості випадків використання, але "
"також демонструє рівень контролю над синхронізацією."

msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Проксі-типи в :mod:`multiprocessing` не підтримують порівняння за значенням. "
"Так, наприклад, ми маємо:"

msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "Під час порівнянь слід просто використовувати копію референта."

msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "Проксі-об’єкти є екземплярами підкласів :class:`BaseProxy`."

msgid "Call and return the result of a method of the proxy's referent."
msgstr "Виклик і повернення результату методу референта проксі."

msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "Якщо ``proxy`` є проксі, референтом якого є ``obj``, тоді вираз ::"

msgid "will evaluate the expression ::"
msgstr "обчислить вираз ::"

msgid "in the manager's process."
msgstr "в процесі менеджера."

msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"Поверненим значенням буде копія результату виклику або проксі для нового "
"спільного об’єкта – див. документацію щодо аргументу *method_to_typeid* :"
"meth:`BaseManager.register`."

msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Якщо виклик викликає виняток, він повторно викликається :meth:`_callmethod`. "
"Якщо в процесі менеджера виникає інший виняток, він перетворюється на "
"виняток :exc:`RemoteError` і викликається :meth:`_callmethod`."

msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Зокрема, зауважте, що виняток буде створено, якщо *methodname* не було "
"*виявлено*."

msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Приклад використання :meth:`_callmethod`:"

msgid "Return a copy of the referent."
msgstr "Повернути копію референту."

msgid "If the referent is unpicklable then this will raise an exception."
msgstr "Якщо референт неможливо вибрати, це спричинить виняток."

msgid "Return a representation of the proxy object."
msgstr "Повертає представлення проксі-об’єкта."

msgid "Return the representation of the referent."
msgstr "Повернути представлення референта."

msgid "Cleanup"
msgstr "Прибирати"

msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Проксі-об’єкт використовує зворотний виклик weakref, щоб, коли він збирає "
"сміття, він скасовує реєстрацію в менеджері, якому належить його референт."

msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Спільний об’єкт видаляється з процесу менеджера, коли більше немає проксі-"
"серверів, які посилаються на нього."

msgid "Process Pools"
msgstr "Пули процесів"

msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"Можна створити пул процесів, які виконуватимуть передані йому завдання за "
"допомогою класу :class:`Pool`."

msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Об’єкт пулу процесів, який керує пулом робочих процесів, до яких можна "
"надсилати завдання. Він підтримує асинхронні результати з тайм-аутами та "
"зворотними викликами та має реалізацію паралельної карти."

msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* — це кількість робочих процесів, які потрібно використовувати. "
"Якщо *processes* має значення ``None``, тоді використовується число, яке "
"повертає :func:`os.cpu_count`."

msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Якщо *initializer* не ``None``, тоді кожен робочий процес викличе "
"``initializer(*initargs)`` під час свого запуску."

msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* — це кількість завдань, які робочий процес може виконати, "
"перш ніж він вийде та буде замінений новим робочим процесом, щоб звільнити "
"невикористані ресурси. Типовим значенням *maxtasksperchild* є ``None``, що "
"означає, що робочі процеси живуть стільки ж, скільки пул."

msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* можна використовувати для визначення контексту, який "
"використовується для запуску робочих процесів. Зазвичай пул створюється за "
"допомогою функції :func:`multiprocessing.Pool` або методу :meth:`Pool` "
"контекстного об’єкта. В обох випадках *контекст* встановлено належним чином."

msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"Зауважте, що методи об’єкта пулу має викликати тільки процес, який створив "
"пул."

msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
"Об’єкти :class:`multiprocessing.pool` мають внутрішні ресурси, якими "
"потрібно належним чином керувати (як і будь-яким іншим ресурсом), "
"використовуючи пул як контекстний менеджер або викликаючи :meth:`close` і :"
"meth:`terminate` вручну. Якщо цього не зробити, процес може призупинити "
"завершення."

msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"Зауважте, що **некоректно** покладатися на збирач сміття для знищення пулу, "
"оскільки CPython не гарантує, що буде викликано фіналізатор пулу (див. :meth:"
"`object.__del__` для отримання додаткової інформації)."

msgid "*maxtasksperchild*"
msgstr "*maxtaskperchild*"

msgid "*context*"
msgstr "*контекст*"

msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Робочі процеси в межах :class:`Pool` зазвичай живі протягом повної "
"тривалості робочої черги пулу. Частий шаблон, який зустрічається в інших "
"системах (таких як Apache, mod_wsgi тощо) для звільнення ресурсів, які "
"зберігаються робочими засобами, полягає в тому, щоб дозволити робочому в "
"межах пулу завершити лише певний обсяг роботи перед виходом, очищенням і "
"породженням нового процесу на заміну старого. Аргумент *maxtasksperchild* "
"для :class:`Pool` надає цю можливість кінцевому користувачеві."

msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Виклик *func* з аргументами *args* і ключовими аргументами *kwds*. "
"Блокується, поки не буде готовий результат. Враховуючи ці блоки, :meth:"
"`apply_async` краще підходить для виконання роботи паралельно. Крім того, "
"*func* виконується лише в одному з воркерів пулу."

msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Варіант методу :meth:`apply`, який повертає об’єкт :class:`~multiprocessing."
"pool.AsyncResult`."

msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Якщо вказано *callback*, це має бути виклик, який приймає один аргумент. "
"Коли результат стає готовим, до нього застосовується *callback*, якщо тільки "
"виклик не вдався, у цьому випадку замість нього застосовується "
"*error_callback*."

msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Якщо вказано *error_callback*, це має бути виклик, який приймає один "
"аргумент. Якщо цільова функція дає збій, то *error_callback* викликається з "
"екземпляром винятку."

msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Зворотні виклики мають завершитися негайно, інакше потік, який обробляє "
"результати, буде заблоковано."

msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
"Паралельний еквівалент вбудованої функції :func:`map` (хоча вона підтримує "
"лише один аргумент *iterable*, для кількох ітерацій див. :meth:`starmap`). "
"Блокується, поки не буде готовий результат."

msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"Цей метод розбиває iterable на декілька фрагментів, які він надсилає до пулу "
"процесів як окремі завдання. (Приблизний) розмір цих фрагментів можна "
"вказати, встановивши для *chunksize* додатне ціле число."

msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"Зауважте, що це може спричинити велике використання пам’яті для дуже довгих "
"ітерацій. Розгляньте можливість використання :meth:`imap` або :meth:"
"`imap_unordered` з явним параметром *chunksize* для кращої ефективності."

msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Варіант методу :meth:`.map`, який повертає об’єкт :class:`~multiprocessing."
"pool.AsyncResult`."

msgid "A lazier version of :meth:`.map`."
msgstr "Ленича версія :meth:`.map`."

msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"Аргумент *chunksize* такий самий, як той, який використовується методом :"
"meth:`.map`. Для дуже довгих ітерацій використання великого значення для "
"*chunksize* може зробити роботу завершеною **набагато** швидше, ніж "
"використання значення за замовчуванням ``1``."

msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Крім того, якщо *chunksize* дорівнює ``1``, тоді метод :meth:`!next` "
"ітератора, який повертає метод :meth:`imap`, має додатковий параметр "
"*timeout*: ``next(timeout)`` викличе :exc:`multiprocessing.TimeoutError`, "
"якщо результат не може бути повернутий протягом *часу очікування* секунд."

msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"Те саме, що :meth:`imap`, за винятком того, що порядок результатів від "
"повернутого ітератора слід вважати довільним. (Тільки коли є лише один "
"робочий процес, порядок гарантовано буде \"правильним\".)"

msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"Подібно до :meth:`~multiprocessing.pool.Pool.map`, за винятком того, що "
"елементи *iterable* мають бути ітерованими, які розпаковуються як аргументи."

msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Тому *ітерація* ``[(1,2), (3, 4)]`` призводить до ``[func(1,2), func(3,4)]``."

msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"Комбінація :meth:`starmap` і :meth:`map_async`, яка виконує ітерацію по "
"*iterable* ітерацій і викликає *func* з розпакованими ітераціями. Повертає "
"об’єкт результату."

msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Запобігає надсиланню додаткових завдань до пулу. Після виконання всіх "
"завдань робочі процеси завершаться."

msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Негайно зупиняє робочі процеси, не завершуючи незавершену роботу. Коли "
"об’єкт пулу збирається як сміття, негайно буде викликано :meth:`terminate`."

msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Зачекайте, поки робочі процеси завершаться. Потрібно викликати :meth:`close` "
"або :meth:`terminate` перед використанням :meth:`join`."

msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Об’єкти пулу тепер підтримують протокол керування контекстом – див. :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` повертає об’єкт "
"пулу, а :meth:`~contextmanager.__exit__` викликає :meth:`terminate`."

msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"Клас результату, який повертають :meth:`Pool.apply_async` і :meth:`Pool."
"map_async`."

msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Поверніть результат, коли він надійде. Якщо *timeout* не ``None`` і "
"результат не надходить протягом *timeout* секунд, тоді виникає :exc:"
"`multiprocessing.TimeoutError`. Якщо віддалений виклик викликав виняток, цей "
"виняток буде повторно викликано :meth:`get`."

msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Зачекайте, поки буде доступний результат або поки не мине *тайм-аут* секунди."

msgid "Return whether the call has completed."
msgstr "Повідомити, чи завершено виклик."

msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"Повертає, чи завершено виклик без виклику винятку. Викличе :exc:"
"`ValueError`, якщо результат не готовий."

msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Якщо результат не готовий, замість :exc:`AssertionError` виникає :exc:"
"`ValueError`."

msgid "The following example demonstrates the use of a pool::"
msgstr "Наступний приклад демонструє використання пулу:"

msgid "Listeners and Clients"
msgstr "Слухачі та клієнти"

msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Зазвичай передача повідомлень між процесами здійснюється за допомогою черг "
"або за допомогою об’єктів :class:`~Connection`, які повертає :func:"
"`~multiprocessing.Pipe`."

msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"Однак модуль :mod:`multiprocessing.connection` забезпечує додаткову "
"гнучкість. По суті, це надає API високого рівня, орієнтований на "
"повідомлення, для роботи з сокетами або іменованими каналами Windows. Він "
"також підтримує *дайджест-автентифікацію* за допомогою модуля :mod:`hmac` і "
"для опитування кількох з’єднань одночасно."

msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Надішліть випадково згенероване повідомлення на інший кінець з’єднання та "
"дочекайтеся відповіді."

msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Якщо відповідь відповідає дайджесту повідомлення з використанням *authkey* "
"як ключа, тоді на інший кінець з’єднання надсилається вітальне повідомлення. "
"Інакше виникає :exc:`~multiprocessing.AuthenticationError`."

msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Отримайте повідомлення, обчисліть дайджест повідомлення, використовуючи "
"*authkey* як ключ, а потім надішліть дайджест назад."

msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Якщо вітальне повідомлення не отримано, виникає :exc:`~multiprocessing."
"AuthenticationError`."

msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Спроба встановити з’єднання зі слухачем, який використовує адресу *address*, "
"повертаючи :class:`~Connection`."

msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"Тип з’єднання визначається аргументом *family*, але зазвичай його можна "
"опустити, оскільки його зазвичай можна визначити з формату *address*. (Див. :"
"ref:`multiprocessing-address-formats`)"

msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Якщо вказано *authkey*, а не None, це має бути рядок байтів і "
"використовуватиметься як секретний ключ для виклику автентифікації на основі "
"HMAC. Автентифікація не виконується, якщо *authkey* має значення None. :exc:"
"`~multiprocessing.AuthenticationError` виникає, якщо автентифікація не "
"вдається. Перегляньте :ref:`multiprocessing-auth-keys`."

msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Обгортка для пов’язаного сокета або каналу з іменем Windows, який \"слухає\" "
"з’єднання."

msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* — це адреса, яка буде використовуватися зв’язаним сокетом або "
"іменованим каналом об’єкта слухача."

msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Якщо використовується адреса \"0.0.0.0\", ця адреса не буде кінцевою точкою "
"підключення в Windows. Якщо вам потрібна підключена кінцева точка, вам слід "
"використовувати \"127.0.0.1\"."

msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*сімейство* — це тип розетки (або названої труби), яку слід використовувати. "
"Це може бути один із рядків ``'AF_INET'`` (для сокета TCP), ``'AF_UNIX'`` "
"(для сокета домену Unix) або ``'AF_PIPE''`` (для іменованого каналу "
"Windows) . З них лише перший гарантовано доступний. Якщо *family* має "
"значення ``None``, тоді сім'я виводиться з формату *address*. Якщо *адреса* "
"також ``None``, тоді вибрано значення за замовчуванням. Це за замовчуванням "
"сімейство, яке вважається найшвидшим із доступних. Дивіться :ref:"
"`multiprocessing-address-formats`. Зауважте, що якщо *сімейство* має "
"значення ``'AF_UNIX``, а адреса ``None``, то сокет буде створено в "
"приватному тимчасовому каталозі, створеному за допомогою :func:`tempfile."
"mkstemp`."

msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Якщо об’єкт слухача використовує сокет, тоді *backlog* (1 за замовчуванням) "
"передається в метод :meth:`~socket.socket.listen` сокета після того, як його "
"буде зв’язано."

msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Прийняти підключення до зв’язаного сокета або іменованого каналу об’єкта "
"слухача та повернути об’єкт :class:`~Connection`. Якщо спроба автентифікації "
"не вдається, виникає :exc:`~multiprocessing.AuthenticationError`."

msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Закрийте прив’язаний сокет або іменований канал об’єкта слухача. Це "
"викликається автоматично, коли слухач збирає сміття. Однак бажано називати "
"це явно."

msgid "Listener objects have the following read-only properties:"
msgstr "Об’єкти слухача мають такі властивості лише для читання:"

msgid "The address which is being used by the Listener object."
msgstr "Адреса, яка використовується об’єктом Listener."

msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"Адреса, з якої надійшло останнє прийняте підключення. Якщо це недоступно, це "
"``None``."

msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Об’єкти слухача тепер підтримують протокол керування контекстом – див. :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` повертає об’єкт "
"слухача, а :meth:`~contextmanager.__exit__` викликає :meth:`close`."

msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Зачекайте, поки об'єкт у *object_list* буде готовий. Повертає список тих "
"об'єктів у *object_list*, які готові. Якщо *timeout* є числом з плаваючою "
"точкою, виклик блокується щонайбільше на стільки секунд. Якщо *timeout* має "
"значення ``None``, тоді він блокуватиметься на необмежений період. Від’ємний "
"тайм-аут еквівалентний нульовому тайм-ауту."

msgid ""
"For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr ""
"Як для Unix, так і для Windows, об’єкт може з’явитися в *object_list*, якщо "
"він є"

msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "читабельний об’єкт :class:`~multiprocessing.connection.Connection`;"

msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "підключений і читабельний об’єкт :class:`socket.socket`; або"

msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"атрибут :attr:`~multiprocessing.Process.sentinel` об’єкта :class:"
"`~multiprocessing.Process`."

msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"Об’єкт з’єднання або сокета готовий, коли є доступні дані для читання з "
"нього, або інший кінець закрито."

msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**Unix**: ``wait(object_list, timeout)`` майже еквівалент ``select."
"select(object_list, [], [], timeout)``. Різниця полягає в тому, що якщо :"
"func:`select.select` переривається сигналом, він може викликати :exc:"
"`OSError` з номером помилки ``EINTR``, тоді як :func:`wait` не буде."

msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`fileno` method which returns a socket handle or pipe handle.  (Note "
"that pipe handles and socket handles are **not** waitable handles.)"
msgstr ""
"**Windows**: елемент у *object_list* має бути цілочисельним дескриптором, "
"який можна очікувати (відповідно до визначення, що використовується в "
"документації функції Win32 ``WaitForMultipleObjects()``), або це може бути "
"об’єкт із :meth:`fileno` метод, який повертає дескриптор сокета або каналу. "
"(Зауважте, що маркери труб і розеток **не** є маркерами очікування.)"

msgid "**Examples**"
msgstr "**Приклади**"

msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"Наступний код сервера створює прослуховувач, який використовує ``'секретний "
"пароль`` як ключ автентифікації. Потім він очікує з’єднання та надсилає "
"деякі дані клієнту::"

msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""
"Наступний код підключається до сервера та отримує деякі дані з сервера:"

msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"Наступний код використовує :func:`~multiprocessing.connection.wait` для "
"очікування повідомлень від кількох процесів одночасно::"

msgid "Address Formats"
msgstr "Формати адрес"

msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"Адреса \"AF_INET\" — це кортеж у формі \"(ім’я хоста, порт)\", де *ім’я "
"хоста* — рядок, а *порт* — ціле число."

msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"Адреса \"AF_UNIX\" — це рядок, що представляє назву файлу у файловій системі."

msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\.\\\\pipe\\"
"\\{PipeName}'`.  To use :func:`Client` to connect to a named pipe on a "
"remote computer called *ServerName* one should use an address of the form :"
"samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` instead."
msgstr ""
"Адреса ``'AF_PIPE'`` — це рядок у формі :samp:`r'\\\\\\\\.\\\\pipe\\"
"\\{PipeName}'`. Щоб використовувати :func:`Client` для з’єднання з "
"іменованим каналом на віддаленому комп’ютері під назвою *ServerName*, "
"потрібно використовувати адресу у формі :samp:`r'\\\\\\\\{ServerName}\\"
"\\pipe\\\\{PipeName }''` замість цього."

msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Зауважте, що будь-який рядок, який починається двома зворотними похилими "
"рисками, за замовчуванням вважається адресою ``'AF_PIPE'``, а не адресою "
"``'AF_UNIX'``."

msgid "Authentication keys"
msgstr "Ключі автентифікації"

msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"Коли використовується :meth:`Connection.recv <Connection.recv>`, отримані "
"дані автоматично видаляються. На жаль, видалення даних із ненадійного "
"джерела становить загрозу безпеці. Тому :class:`Listener` і :func:`Client` "
"використовують модуль :mod:`hmac` для забезпечення автентифікації дайджесту."

msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"Ключ автентифікації — це рядок байтів, який можна розглядати як пароль: коли "
"з’єднання встановлено, обидва кінці вимагатимуть підтвердження того, що "
"інший знає ключ автентифікації. (Демонстрація того, що обидві сторони "
"використовують той самий ключ, **не** передбачає надсилання ключа через "
"з’єднання.)"

msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Якщо автентифікація запитується, але ключ автентифікації не вказано, тоді "
"використовується значення, що повертається ``current_process().authkey`` "
"(див. :class:`~multiprocessing.Process`). Це значення буде автоматично "
"успадковано будь-яким об’єктом :class:`~multiprocessing.Process`, який "
"створює поточний процес. Це означає, що (за замовчуванням) усі процеси "
"багатопроцесної програми спільно використовуватимуть один ключ "
"автентифікації, який можна використовувати під час встановлення з’єднань між "
"собою."

msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Відповідні ключі автентифікації також можна згенерувати за допомогою :func:"
"`os.urandom`."

msgid "Logging"
msgstr "Лісозаготівля"

msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Доступна певна підтримка журналювання. Однак зауважте, що пакунок :mod:"
"`logging` не використовує спільні блокування процесів, тому (залежно від "
"типу обробника) повідомлення від різних процесів можуть переплутатися."

msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Повертає реєстратор, який використовується :mod:`multiprocessing`. За "
"потреби буде створено новий."

msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"Під час першого створення реєстратор має рівень :data:`logging.NOTSET` і не "
"має обробника за замовчуванням. Повідомлення, надіслані до цього "
"реєстратора, за умовчанням не поширюватимуться до кореневого реєстратора."

msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Зауважте, що у Windows дочірні процеси успадковуватимуть лише рівень "
"реєстратора батьківського процесу – будь-які інші налаштування реєстратора "
"не успадковуватимуться."

msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"Ця функція виконує виклик :func:`get_logger`, але окрім повернення "
"реєстратора, створеного get_logger, вона додає обробник, який надсилає "
"вихідні дані до :data:`sys.stderr` у форматі ``'[%(levelname)s/"
"%(processName)s] %(message)s ''``. Ви можете змінити ``levelname`` "
"реєстратора, передавши аргумент ``level``."

msgid "Below is an example session with logging turned on::"
msgstr "Нижче наведено приклад сеансу з увімкненим журналюванням::"

msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"Щоб отримати повну таблицю рівнів журналювання, перегляньте модуль :mod:"
"`logging`."

msgid "The :mod:`multiprocessing.dummy` module"
msgstr "Модуль :mod:`multiprocessing.dummy`"

msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` повторює API :mod:`multiprocessing`, але є не "
"більше ніж обгорткою модуля :mod:`threading`."

msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"Зокрема, функція ``Pool``, надана :mod:`multiprocessing.dummy`, повертає "
"екземпляр :class:`ThreadPool`, який є підкласом :class:`Pool`, який "
"підтримує всі виклики методів, але використовує пул робочих потоків, а не "
"робочих процесів."

msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"Об’єкт пулу потоків, який керує пулом робочих потоків, до яких можна "
"надсилати завдання. Екземпляри :class:`ThreadPool` повністю сумісні з "
"інтерфейсом екземплярів :class:`Pool`, і їхніми ресурсами також потрібно "
"правильно керувати, використовуючи пул як контекстний менеджер або "
"викликаючи :meth:`~multiprocessing.pool. Pool.close` і :meth:"
"`~multiprocessing.pool.Pool.terminate` вручну."

msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* — це кількість робочих потоків для використання. Якщо "
"*processes* має значення ``None``, тоді використовується число, яке "
"повертає :func:`os.cpu_count`."

msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""
"На відміну від :class:`Pool`, *maxtasksperchild* і *context* не можна надати."

msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
":class:`ThreadPool` має той самий інтерфейс, що й :class:`Pool`, який "
"розроблено навколо пулу процесів і передує появі модуля :class:`concurrent."
"futures`. Таким чином, він успадковує деякі операції, які не мають сенсу для "
"пулу, що підтримується потоками, і має власний тип для представлення статусу "
"асинхронних завдань, :class:`AsyncResult`, який не розуміється жодною іншою "
"бібліотекою."

msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"Зазвичай користувачі мають віддавати перевагу використанню :class:"
"`concurrent.futures.ThreadPoolExecutor`, який має простіший інтерфейс, "
"розроблений навколо потоків із самого початку та повертає :class:`concurrent."
"futures.Future` екземпляри, сумісні з багатьма інші бібліотеки, включаючи :"
"mod:`asyncio`."

msgid "Programming guidelines"
msgstr "Інструкції з програмування"

msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Існують певні вказівки та ідіоми, яких слід дотримуватися під час "
"використання :mod:`multiprocessing`."

msgid "All start methods"
msgstr "Всі методи запуску"

msgid "The following applies to all start methods."
msgstr "Наступне стосується всіх методів запуску."

msgid "Avoid shared state"
msgstr "Уникайте спільного стану"

msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"Наскільки це можливо, слід намагатися уникати переміщення великих обсягів "
"даних між процесами."

msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Ймовірно, найкраще використовувати черги або канали для зв’язку між "
"процесами, а не використовувати примітиви синхронізації нижчого рівня."

msgid "Picklability"
msgstr "Пробірність"

msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "Переконайтеся, що аргументи методів проксі-серверів можна вибрати."

msgid "Thread safety of proxies"
msgstr "Безпека потоків проксі"

msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"Не використовуйте проксі-об’єкт із кількох потоків, якщо ви не захистите "
"його за допомогою блокування."

msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Ніколи не виникає проблем із різними процесами, які використовують *той "
"самий* проксі.)"

msgid "Joining zombie processes"
msgstr "Приєднання до зомбованих процесів"

msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie. "
"There should never be very many because each time a new process starts (or :"
"func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr ""
"В Unix, коли процес завершується, але до нього не приєднується, він стає "
"зомбі. Їх ніколи не повинно бути дуже багато, оскільки кожного разу, коли "
"запускається новий процес (або викликається :func:`~multiprocessing."
"active_children`), усі завершені процеси, які ще не приєдналися, будуть "
"об’єднані. Також виклик завершеного процесу :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` приєднається до процесу. Незважаючи на "
"це, ймовірно, гарною практикою є явне приєднання до всіх процесів, які ви "
"починаєте."

msgid "Better to inherit than pickle/unpickle"
msgstr "Краще успадкувати, ніж маринувати/розмаринувати"

msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"Під час використання методів запуску *spawn* або *forkserver* багато типів "
"із :mod:`multiprocessing` мають бути доступними для вибору, щоб дочірні "
"процеси могли їх використовувати. Однак зазвичай слід уникати надсилання "
"спільних об’єктів іншим процесам за допомогою каналів або черг. Натомість ви "
"повинні організувати програму так, щоб процес, якому потрібен доступ до "
"спільного ресурсу, створеного в іншому місці, міг успадкувати його від "
"процесу-предка."

msgid "Avoid terminating processes"
msgstr "Уникайте завершення процесів"

msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"Використання методу :meth:`Process.terminate <multiprocessing.Process."
"terminate>` для зупинки процесу може призвести до того, що будь-які спільні "
"ресурси (такі як блокування, семафори, канали та черги), які зараз "
"використовуються цим процесом, стануть несправними або недоступними для "
"інших процесів."

msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Тому, ймовірно, найкраще використовувати :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` лише для процесів, які ніколи не "
"використовують спільні ресурси."

msgid "Joining processes that use queues"
msgstr "Приєднання до процесів, які використовують черги"

msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Майте на увазі, що процес, який поставив елементи в чергу, чекатиме перед "
"завершенням, доки всі буферизовані елементи не будуть передані потоком "
"\"фідера\" до основного каналу. (Дочірній процес може викликати метод :meth:"
"`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` черги, "
"щоб уникнути такої поведінки.)"

msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Це означає, що щоразу, коли ви використовуєте чергу, вам потрібно "
"переконатися, що всі елементи, які було поставлено в чергу, зрештою буде "
"видалено перед приєднанням до процесу. Інакше ви не можете бути впевнені, що "
"процеси, які поставили елементи в чергу, завершаться. Пам'ятайте також, що "
"недемонічні процеси будуть приєднані автоматично."

msgid "An example which will deadlock is the following::"
msgstr "Прикладом, який призведе до взаємоблокування, є наступний:"

msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"Виправити тут можна було б поміняти місцями останні два рядки (або просто "
"видалити рядок ``p.join()``)."

msgid "Explicitly pass resources to child processes"
msgstr "Явно передати ресурси дочірнім процесам"

msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"В Unix за допомогою методу запуску *fork* дочірній процес може "
"використовувати спільний ресурс, створений у батьківському процесі за "
"допомогою глобального ресурсу. Однак краще передати об’єкт як аргумент "
"конструктору дочірнього процесу."

msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Окрім того, що код (потенційно) сумісний із Windows та іншими методами "
"запуску, це також гарантує, що поки дочірній процес живий, об’єкт не "
"збиратиме сміття в батьківському процесі. Це може бути важливо, якщо якийсь "
"ресурс звільняється, коли об’єкт збирається як сміття в батьківському "
"процесі."

msgid "So for instance ::"
msgstr "Так наприклад ::"

msgid "should be rewritten as ::"
msgstr "слід переписати як ::"

msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr "Остерігайтеся заміни :data:`sys.stdin` на \"файлоподібний об’єкт\""

msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` спочатку безумовно називався::"

msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"у методі :meth:`multiprocessing.Process._bootstrap` --- це призвело до "
"проблем із процесами в процесах. Це було змінено на::"

msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close()` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""
"Це вирішує фундаментальну проблему зіткнення процесів один з одним, що "
"призводить до помилки неправильного дескриптора файлу, але представляє "
"потенційну небезпеку для програм, які замінюють :func:`sys.stdin` на "
"\"файлоподібний об’єкт\" із буферизацією виводу. Ця небезпека полягає в "
"тому, що якщо кілька процесів викликають :meth:`~io.IOBase.close()` для "
"цього файлоподібного об’єкта, це може призвести до того, що ті самі дані "
"будуть скидатися в об’єкт кілька разів, що призведе до пошкодження."

msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"Якщо ви пишете файлоподібний об’єкт і використовуєте власне кешування, ви "
"можете зробити його безпечним для розгалуження, зберігаючи pid кожного разу, "
"коли ви додаєте його до кешу, і відкидаючи кеш, коли pid змінюється. "
"Наприклад::"

msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""
"Для отримання додаткової інформації перегляньте :issue:`5155`, :issue:`5313` "
"та :issue:`5331`"

msgid "The *spawn* and *forkserver* start methods"
msgstr "Методи запуску *spawn* і *forkserver*"

msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr ""
"Є кілька додаткових обмежень, які не застосовуються до методу запуску *fork*."

msgid "More picklability"
msgstr "Більше маринування"

msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""
"Переконайтеся, що всі аргументи :meth:`Process.__init__` можна вибрати. Крім "
"того, якщо ви створите підклас :class:`~multiprocessing.Process`, то "
"переконайтеся, що екземпляри можна вибрати під час виклику методу :meth:"
"`Process.start <multiprocessing.Process.start>`."

msgid "Global variables"
msgstr "Глобальні змінні"

msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Майте на увазі, що якщо код, запущений у дочірньому процесі, намагається "
"отримати доступ до глобальної змінної, тоді значення, яке він бачить (якщо "
"таке є), може не збігатися зі значенням у батьківському процесі під час :"
"meth:`Process.start викликано <multiprocessing.Process.start>`."

msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"Однак глобальні змінні, які є лише константами рівня модуля, не викликають "
"проблем."

msgid "Safe importing of main module"
msgstr "Безпечне імпортування основного модуля"

msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr ""
"Переконайтеся, що основний модуль можна безпечно імпортувати за допомогою "
"нового інтерпретатора Python, не викликаючи небажаних побічних ефектів "
"(наприклад, запуск нового процесу)."

msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Наприклад, використання методу запуску *spawn* або *forkserver* під час "
"запуску наступного модуля призведе до помилки з :exc:`RuntimeError`::"

msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"Натомість слід захистити \"точку входу\" програми за допомогою ``if __name__ "
"== '__main__':`` наступним чином::"

msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(Рядок ``freeze_support()`` можна опустити, якщо програма буде працювати "
"нормально, а не зависати.)"

msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Це дозволяє щойно створеному інтерпретатору Python безпечно імпортувати "
"модуль, а потім запускати функцію foo() модуля."

msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Подібні обмеження застосовуються, якщо пул або менеджер створено в основному "
"модулі."

msgid "Examples"
msgstr "Приклади"

msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""
"Демонстрація створення та використання налаштованих менеджерів і проксі-"
"серверів:"

msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "Використання :class:`~multiprocessing.pool.Pool`:"

msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Приклад, який показує, як використовувати черги для передачі завдань у "
"колекцію робочих процесів і збору результатів:"
