# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Policies"
msgstr "політики"

msgid ""
"An event loop policy is a global per-process object that controls the "
"management of the event loop. Each event loop has a default policy, which "
"can be changed and customized using the policy API."
msgstr ""
"Політика циклу подій — це глобальний об’єкт для кожного процесу, який "
"контролює керування циклом подій. Кожен цикл подій має стандартну політику, "
"яку можна змінити та налаштувати за допомогою API політики."

msgid ""
"A policy defines the notion of *context* and manages a separate event loop "
"per context. The default policy defines *context* to be the current thread."
msgstr ""
"Політика визначає поняття *контексту* та керує окремим циклом подій для "
"кожного контексту. Політика за умовчанням визначає *контекст* як поточний "
"потік."

msgid ""
"By using a custom event loop policy, the behavior of :func:"
"`get_event_loop`, :func:`set_event_loop`, and :func:`new_event_loop` "
"functions can be customized."
msgstr ""
"За допомогою спеціальної політики циклу подій можна налаштувати поведінку "
"функцій :func:`get_event_loop`, :func:`set_event_loop` і :func:"
"`new_event_loop`."

msgid ""
"Policy objects should implement the APIs defined in the :class:"
"`AbstractEventLoopPolicy` abstract base class."
msgstr ""
"Об’єкти політики мають реалізовувати API, визначені в :class:"
"`AbstractEventLoopPolicy` абстрактному базовому класі."

msgid "Getting and Setting the Policy"
msgstr "Отримання та налаштування політики"

msgid ""
"The following functions can be used to get and set the policy for the "
"current process:"
msgstr ""
"Наступні функції можна використовувати для отримання та налаштування "
"політики для поточного процесу:"

msgid "Return the current process-wide policy."
msgstr "Повернути поточну політику для всього процесу."

msgid "Set the current process-wide policy to *policy*."
msgstr "Установіть поточну політику для всього процесу на *policy*."

msgid "If *policy* is set to ``None``, the default policy is restored."
msgstr ""
"Якщо *policy* встановлено на ``None``, політика за замовчуванням буде "
"відновлена."

msgid "Policy Objects"
msgstr "Об'єкти політики"

msgid "The abstract event loop policy base class is defined as follows:"
msgstr ""
"Базовий клас політики абстрактного циклу подій визначається наступним чином:"

msgid "An abstract base class for asyncio policies."
msgstr "Абстрактний базовий клас для асинхронних політик."

msgid "Get the event loop for the current context."
msgstr "Отримати цикл подій для поточного контексту."

msgid ""
"Return an event loop object implementing the :class:`AbstractEventLoop` "
"interface."
msgstr ""
"Повертає об’єкт циклу подій, що реалізує інтерфейс :class:"
"`AbstractEventLoop`."

msgid "This method should never return ``None``."
msgstr "Цей метод ніколи не повинен повертати ``None``."

msgid "Set the event loop for the current context to *loop*."
msgstr "Встановіть для циклу подій для поточного контексту значення *loop*."

msgid "Create and return a new event loop object."
msgstr "Створити та повернути новий об’єкт циклу подій."

msgid "Get a child process watcher object."
msgstr "Отримайте дочірній об’єкт спостереження за процесом."

msgid ""
"Return a watcher object implementing the :class:`AbstractChildWatcher` "
"interface."
msgstr ""
"Повертає об’єкт спостереження, що реалізує інтерфейс :class:"
"`AbstractChildWatcher`."

msgid "This function is Unix specific."
msgstr "Ця функція є специфічною для Unix."

msgid "Set the current child process watcher to *watcher*."
msgstr ""
"Встановіть для поточного спостерігача дочірнього процесу значення *watcher*."

msgid "asyncio ships with the following built-in policies:"
msgstr "asyncio поставляється з такими вбудованими політиками:"

msgid ""
"The default asyncio policy.  Uses :class:`SelectorEventLoop` on Unix and :"
"class:`ProactorEventLoop` on Windows."
msgstr ""
"Стандартна асинхронна політика. Використовує :class:`SelectorEventLoop` в "
"Unix і :class:`ProactorEventLoop` у Windows."

msgid ""
"There is no need to install the default policy manually. asyncio is "
"configured to use the default policy automatically."
msgstr ""
"Немає необхідності встановлювати стандартну політику вручну. asyncio "
"налаштовано на автоматичне використання політики за замовчуванням."

msgid "On Windows, :class:`ProactorEventLoop` is now used by default."
msgstr ""
"У Windows :class:`ProactorEventLoop` тепер використовується за замовчуванням."

msgid ""
"An alternative event loop policy that uses the :class:`SelectorEventLoop` "
"event loop implementation."
msgstr ""
"Альтернативна політика циклу подій, яка використовує реалізацію циклу подій :"
"class:`SelectorEventLoop`."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid ""
"An alternative event loop policy that uses the :class:`ProactorEventLoop` "
"event loop implementation."
msgstr ""
"Альтернативна політика циклу подій, яка використовує реалізацію циклу подій :"
"class:`ProactorEventLoop`."

msgid "Process Watchers"
msgstr "Спостерігачі процесів"

msgid ""
"A process watcher allows customization of how an event loop monitors child "
"processes on Unix. Specifically, the event loop needs to know when a child "
"process has exited."
msgstr ""
"Спостерігач процесів дозволяє налаштувати те, як цикл подій відстежує "
"дочірні процеси в Unix. Зокрема, цикл подій повинен знати, коли завершився "
"дочірній процес."

msgid ""
"In asyncio, child processes are created with :func:`create_subprocess_exec` "
"and :meth:`loop.subprocess_exec` functions."
msgstr ""
"В asyncio дочірні процеси створюються за допомогою функцій :func:"
"`create_subprocess_exec` і :meth:`loop.subprocess_exec`."

msgid ""
"asyncio defines the :class:`AbstractChildWatcher` abstract base class, which "
"child watchers should implement, and has four different implementations: :"
"class:`ThreadedChildWatcher` (configured to be used by default), :class:"
"`MultiLoopChildWatcher`, :class:`SafeChildWatcher`, and :class:"
"`FastChildWatcher`."
msgstr ""
"asyncio визначає абстрактний базовий клас :class:`AbstractChildWatcher`, "
"який повинні реалізувати дочірні спостерігачі, і має чотири різні "
"реалізації: :class:`ThreadedChildWatcher` (налаштований для використання за "
"замовчуванням), :class:`MultiLoopChildWatcher`, :class:`SafeChildWatcher` і :"
"class:`FastChildWatcher`."

msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ""
"Дивіться також розділ :ref:`Subprocess and Threads <asyncio-subprocess-"
"threads>`."

msgid ""
"The following two functions can be used to customize the child process "
"watcher implementation used by the asyncio event loop:"
msgstr ""
"Наступні дві функції можна використовувати для налаштування реалізації "
"спостерігача дочірніх процесів, що використовується циклом асинхронних подій:"

msgid "Return the current child watcher for the current policy."
msgstr "Повертає поточний дочірній спостерігач для поточної політики."

msgid ""
"Set the current child watcher to *watcher* for the current policy.  "
"*watcher* must implement methods defined in the :class:"
"`AbstractChildWatcher` base class."
msgstr ""
"Установіть для поточного дочірнього спостерігача значення *watcher* для "
"поточної політики. *watcher* повинен реалізовувати методи, визначені в "
"базовому класі :class:`AbstractChildWatcher`."

msgid ""
"Third-party event loops implementations might not support custom child "
"watchers.  For such event loops, using :func:`set_child_watcher` might be "
"prohibited or have no effect."
msgstr ""
"Реалізації сторонніх циклів подій можуть не підтримувати користувацькі "
"дочірні спостерігачі. Для таких циклів подій використання :func:"
"`set_child_watcher` може бути заборонено або не матиме ефекту."

msgid "Register a new child handler."
msgstr "Зареєструвати нового дочірнього обробника."

msgid ""
"Arrange for ``callback(pid, returncode, *args)`` to be called when a process "
"with PID equal to *pid* terminates.  Specifying another callback for the "
"same process replaces the previous handler."
msgstr ""
"Організуйте виклик ``callback(pid, returncode, *args)`` під час завершення "
"процесу з PID, рівним *pid*. Зазначення іншого зворотного виклику для того "
"самого процесу замінює попередній обробник."

msgid "The *callback* callable must be thread-safe."
msgstr "Функція *callback* має бути потокобезпечною."

msgid "Removes the handler for process with PID equal to *pid*."
msgstr "Видаляє обробник для процесу з PID рівним *pid*."

msgid ""
"The function returns ``True`` if the handler was successfully removed, "
"``False`` if there was nothing to remove."
msgstr ""
"Функція повертає ``True``, якщо обробник було успішно видалено, ``False``, "
"якщо не було нічого для видалення."

msgid "Attach the watcher to an event loop."
msgstr "Приєднайте спостерігач до циклу подій."

msgid ""
"If the watcher was previously attached to an event loop, then it is first "
"detached before attaching to the new loop."
msgstr ""
"Якщо спостерігач був раніше приєднаний до циклу подій, то він спочатку "
"від'єднується перед приєднанням до нового циклу."

msgid "Note: loop may be ``None``."
msgstr "Примітка: цикл може бути ``None``."

msgid "Return ``True`` if the watcher is ready to use."
msgstr "Повертає ``True``, якщо спостерігач готовий до використання."

msgid ""
"Spawning a subprocess with *inactive* current child watcher raises :exc:"
"`RuntimeError`."
msgstr ""
"Створення підпроцесу з *неактивним* поточним дочірнім спостерігачем "
"викликає :exc:`RuntimeError`."

msgid "Close the watcher."
msgstr "Закрийте спостерігач."

msgid ""
"This method has to be called to ensure that underlying resources are cleaned-"
"up."
msgstr ""
"Цей метод потрібно викликати, щоб переконатися, що базові ресурси очищені."

msgid ""
"This implementation starts a new waiting thread for every subprocess spawn."
msgstr ""
"Ця реалізація запускає новий потік очікування для кожного породження "
"підпроцесу."

msgid ""
"It works reliably even when the asyncio event loop is run in a non-main OS "
"thread."
msgstr ""
"Він працює надійно, навіть якщо цикл асинхронних подій виконується в "
"неосновному потоці ОС."

msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates), but starting a thread per process "
"requires extra memory."
msgstr ""
"Немає помітних накладних витрат при обробці великої кількості дітей (*O(1)* "
"кожного разу, коли дитина завершується), але для запуску потоку для кожного "
"процесу потрібна додаткова пам’ять."

msgid "This watcher is used by default."
msgstr "Цей спостерігач використовується за замовчуванням."

msgid ""
"This implementation registers a :py:data:`SIGCHLD` signal handler on "
"instantiation. That can break third-party code that installs a custom "
"handler for :py:data:`SIGCHLD` signal."
msgstr ""
"Ця реалізація реєструє обробник сигналу :py:data:`SIGCHLD` під час створення "
"екземпляра. Це може порушити код третьої сторони, який встановлює "
"спеціальний обробник для сигналу :py:data:`SIGCHLD`."

msgid ""
"The watcher avoids disrupting other code spawning processes by polling every "
"process explicitly on a :py:data:`SIGCHLD` signal."
msgstr ""
"Спостерігач уникає порушення інших процесів створення коду, явно опитуючи "
"кожен процес за сигналом :py:data:`SIGCHLD`."

msgid ""
"There is no limitation for running subprocesses from different threads once "
"the watcher is installed."
msgstr ""
"Немає обмежень для запуску підпроцесів з різних потоків після встановлення "
"спостерігача."

msgid ""
"The solution is safe but it has a significant overhead when handling a big "
"number of processes (*O(n)* each time a :py:data:`SIGCHLD` is received)."
msgstr ""
"Рішення є безпечним, але воно має значні витрати під час обробки великої "
"кількості процесів (*O(n)* щоразу, коли отримується :py:data:`SIGCHLD`)."

msgid ""
"This implementation uses active event loop from the main thread to handle :"
"py:data:`SIGCHLD` signal. If the main thread has no running event loop "
"another thread cannot spawn a subprocess (:exc:`RuntimeError` is raised)."
msgstr ""
"Ця реалізація використовує активний цикл подій з основного потоку для "
"обробки сигналу :py:data:`SIGCHLD`. Якщо основний потік не має запущеного "
"циклу подій, інший потік не може породити підпроцес (виникає :exc:"
"`RuntimeError`)."

msgid ""
"This solution is as safe as :class:`MultiLoopChildWatcher` and has the same "
"*O(N)* complexity but requires a running event loop in the main thread to "
"work."
msgstr ""
"Це рішення таке ж безпечне, як і :class:`MultiLoopChildWatcher`, і має таку "
"ж складність *O(N)*, але для роботи потрібен запущений цикл подій у "
"головному потоці."

msgid ""
"This implementation reaps every terminated processes by calling ``os."
"waitpid(-1)`` directly, possibly breaking other code spawning processes and "
"waiting for their termination."
msgstr ""
"Ця реалізація збирає всі завершені процеси шляхом безпосереднього виклику "
"``os.waitpid(-1)``, можливо, порушуючи інші процеси породження коду та "
"чекаючи їх завершення."

msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates)."
msgstr ""
"Немає помітних накладних витрат при обробці великої кількості дітей (*O(1)* "
"кожного разу, коли дитина завершує роботу)."

msgid ""
"This solution requires a running event loop in the main thread to work, as :"
"class:`SafeChildWatcher`."
msgstr ""
"Для роботи цього рішення потрібен запущений цикл подій у головному потоці, "
"як :class:`SafeChildWatcher`."

msgid ""
"This implementation polls process file descriptors (pidfds) to await child "
"process termination. In some respects, :class:`PidfdChildWatcher` is a "
"\"Goldilocks\" child watcher implementation. It doesn't require signals or "
"threads, doesn't interfere with any processes launched outside the event "
"loop, and scales linearly with the number of subprocesses launched by the "
"event loop. The main disadvantage is that pidfds are specific to Linux, and "
"only work on recent (5.3+) kernels."
msgstr ""
"Ця реалізація опитує дескриптори файлів процесу (pidfds) для очікування "
"завершення дочірнього процесу. У деяких відношеннях :class:"
"`PidfdChildWatcher` є реалізацією дочірнього спостерігача \"Золотовласка\". "
"Він не потребує сигналів чи потоків, не заважає жодним процесам, запущеним "
"поза циклом подій, і масштабується лінійно залежно від кількості "
"підпроцесів, запущених циклом подій. Основним недоліком є те, що pidfds є "
"специфічними для Linux і працюють лише на останніх (5.3+) ядрах."

msgid "Custom Policies"
msgstr "Спеціальна політика"

msgid ""
"To implement a new event loop policy, it is recommended to subclass :class:"
"`DefaultEventLoopPolicy` and override the methods for which custom behavior "
"is wanted, e.g.::"
msgstr ""
"Щоб запровадити нову політику циклу подій, рекомендується створити підклас :"
"class:`DefaultEventLoopPolicy` і перевизначити методи, для яких потрібна "
"спеціальна поведінка, наприклад::"
