# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ""
":mod:`argparse` --- Parser for command-line options, arguments and sub-"
"commands"
msgstr ""
":mod:`argparse` --- аналізатор параметрів командного рядка, аргументів і "
"підкоманд"

msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**Вихідний код:** :source:`Lib/argparse.py`"

msgid "Tutorial"
msgstr "Підручник"

msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the :ref:"
"`argparse tutorial <argparse-tutorial>`."
msgstr ""
"Ця сторінка містить довідкову інформацію про API. Для більш обережного "
"ознайомлення з розбором командного рядка Python перегляньте :ref:`argparse "
"tutorial <argparse-tutorial>`."

msgid ""
"The :mod:`argparse` module makes it easy to write user-friendly command-line "
"interfaces. The program defines what arguments it requires, and :mod:"
"`argparse` will figure out how to parse those out of :data:`sys.argv`.  The :"
"mod:`argparse` module also automatically generates help and usage messages "
"and issues errors when users give the program invalid arguments."
msgstr ""

msgid "Example"
msgstr "приклад"

msgid ""
"The following code is a Python program that takes a list of integers and "
"produces either the sum or the max::"
msgstr ""
"Наступний код є програмою на Python, яка отримує список цілих чисел і "
"створює або суму, або максимум::"

msgid ""
"Assuming the Python code above is saved into a file called ``prog.py``, it "
"can be run at the command line and provides useful help messages:"
msgstr ""

msgid ""
"When run with the appropriate arguments, it prints either the sum or the max "
"of the command-line integers:"
msgstr ""
"При запуску з відповідними аргументами він друкує або суму, або максимальне "
"значення цілих чисел командного рядка:"

msgid "If invalid arguments are passed in, it will issue an error:"
msgstr ""

msgid "The following sections walk you through this example."
msgstr "У наступних розділах ви ознайомитеся з цим прикладом."

msgid "Creating a parser"
msgstr "Створення синтаксичного аналізатора"

msgid ""
"The first step in using the :mod:`argparse` is creating an :class:"
"`ArgumentParser` object::"
msgstr ""
"Першим кроком у використанні :mod:`argparse` є створення об’єкта :class:"
"`ArgumentParser`::"

msgid ""
"The :class:`ArgumentParser` object will hold all the information necessary "
"to parse the command line into Python data types."
msgstr ""
"Об’єкт :class:`ArgumentParser` буде містити всю інформацію, необхідну для "
"аналізу командного рядка на типи даних Python."

msgid "Adding arguments"
msgstr "Додавання аргументів"

msgid ""
"Filling an :class:`ArgumentParser` with information about program arguments "
"is done by making calls to the :meth:`~ArgumentParser.add_argument` method. "
"Generally, these calls tell the :class:`ArgumentParser` how to take the "
"strings on the command line and turn them into objects.  This information is "
"stored and used when :meth:`~ArgumentParser.parse_args` is called. For "
"example::"
msgstr ""
"Заповнення :class:`ArgumentParser` інформацією про аргументи програми "
"здійснюється шляхом виклику методу :meth:`~ArgumentParser.add_argument`. "
"Зазвичай ці виклики повідомляють :class:`ArgumentParser`, як брати рядки в "
"командному рядку та перетворювати їх на об’єкти. Ця інформація зберігається "
"та використовується під час виклику :meth:`~ArgumentParser.parse_args`. "
"Наприклад::"

msgid ""
"Later, calling :meth:`~ArgumentParser.parse_args` will return an object with "
"two attributes, ``integers`` and ``accumulate``.  The ``integers`` attribute "
"will be a list of one or more ints, and the ``accumulate`` attribute will be "
"either the :func:`sum` function, if ``--sum`` was specified at the command "
"line, or the :func:`max` function if it was not."
msgstr ""

msgid "Parsing arguments"
msgstr "Розбір аргументів"

msgid ""
":class:`ArgumentParser` parses arguments through the :meth:`~ArgumentParser."
"parse_args` method.  This will inspect the command line, convert each "
"argument to the appropriate type and then invoke the appropriate action. In "
"most cases, this means a simple :class:`Namespace` object will be built up "
"from attributes parsed out of the command line::"
msgstr ""
":class:`ArgumentParser` аналізує аргументи за допомогою методу :meth:"
"`~ArgumentParser.parse_args`. Це перевірить командний рядок, перетворить "
"кожен аргумент у відповідний тип, а потім викличе відповідну дію. У "
"більшості випадків це означає, що простий об’єкт :class:`Namespace` буде "
"створено з атрибутів, проаналізованих із командного рядка::"

msgid ""
"In a script, :meth:`~ArgumentParser.parse_args` will typically be called "
"with no arguments, and the :class:`ArgumentParser` will automatically "
"determine the command-line arguments from :data:`sys.argv`."
msgstr ""
"У сценарії :meth:`~ArgumentParser.parse_args` зазвичай викликається без "
"аргументів, а :class:`ArgumentParser` автоматично визначатиме аргументи "
"командного рядка з :data:`sys.argv`."

msgid "ArgumentParser objects"
msgstr "Об’єкти ArgumentParser"

msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed "
"as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"Створіть новий об’єкт :class:`ArgumentParser`. Усі параметри слід передати "
"як аргументи ключового слова. Кожен параметр має власний більш детальний "
"опис нижче, але коротко вони:"

msgid ""
"prog_ - The name of the program (default: ``os.path.basename(sys.argv[0])``)"
msgstr ""
"prog_ - назва програми (за замовчуванням: ``os.path.basename(sys.argv[0])``)"

msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr ""
"usage_ - рядок, що описує використання програми (за замовчуванням: "
"генерується з аргументів, доданих до аналізатора)"

msgid "description_ - Text to display before the argument help (default: none)"
msgstr ""
"description_ - текст для відображення перед аргументом довідки (за "
"замовчуванням: немає)"

msgid "epilog_ - Text to display after the argument help (default: none)"
msgstr ""
"epilog_ - текст для відображення після аргументу help (за замовчуванням: "
"немає)"

msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr ""
"Parents_ - список об'єктів :class:`ArgumentParser`, аргументи яких також "
"мають бути включені"

msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - клас для налаштування виведення довідки"

msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""
"prefix_chars_ - набір символів, які є префіксом необов'язкових аргументів "
"(за замовчуванням: '-')"

msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr ""
"fromfile_prefix_chars_ - набір символів, які є префіксами файлів, з яких "
"слід читати додаткові аргументи (за замовчуванням: ``None``)"

msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""
"argument_default_ - глобальне значення за замовчуванням для аргументів (за "
"замовчуванням: ``None``)"

msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""
"конфлікт_обробник_ - стратегія вирішення конфліктних опцій (зазвичай "
"непотрібних)"

msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""
"add_help_ - додає опцію ``-h/--help`` до аналізатора (за замовчуванням: "
"``True``)"

msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is "
"unambiguous. (default: ``True``)"
msgstr ""
"allow_abbrev_ - Дозволяє скорочувати довгі параметри, якщо скорочення є "
"однозначним. (за замовчуванням: ``True``)"

msgid ""
"exit_on_error_ - Determines whether or not ArgumentParser exits with error "
"info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ – визначає, чи завершує роботу ArgumentParser з інформацією "
"про помилку, коли виникає помилка. (за замовчуванням: ``True``)"

msgid "*allow_abbrev* parameter was added."
msgstr "Додано параметр *allow_abbrev*."

msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr ""
"У попередніх версіях *allow_abbrev* також вимикав групування коротких "
"прапорців, таких як ``-vv``, щоб означати ``-v -v``."

msgid "*exit_on_error* parameter was added."
msgstr "Додано параметр *exit_on_error*."

msgid "The following sections describe how each of these are used."
msgstr "У наступних розділах описано, як використовується кожен із них."

msgid "prog"
msgstr "прог"

msgid ""
"By default, :class:`ArgumentParser` objects use ``sys.argv[0]`` to determine "
"how to display the name of the program in help messages.  This default is "
"almost always desirable because it will make the help messages match how the "
"program was invoked on the command line.  For example, consider a file named "
"``myprogram.py`` with the following code::"
msgstr ""
"За замовчуванням об’єкти :class:`ArgumentParser` використовують ``sys."
"argv[0]``, щоб визначити, як відображати назву програми в довідкових "
"повідомленнях. Це за замовчуванням є майже завжди бажаним, оскільки воно "
"змусить повідомлення довідки відповідати тому, як програма була викликана в "
"командному рядку. Наприклад, розглянемо файл з назвою ``myprogram.py`` з "
"таким кодом::"

msgid ""
"The help for this program will display ``myprogram.py`` as the program name "
"(regardless of where the program was invoked from):"
msgstr ""
"Довідка для цієї програми відображатиме ``myprogram.py`` як назву програми "
"(незалежно від того, звідки програму було викликано):"

msgid ""
"To change this default behavior, another value can be supplied using the "
"``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Щоб змінити цю типову поведінку, можна надати інше значення за допомогою "
"аргументу ``prog=`` до :class:`ArgumentParser`::"

msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or from "
"the ``prog=`` argument, is available to help messages using the ``%(prog)s`` "
"format specifier."
msgstr ""
"Зауважте, що ім’я програми, незалежно від того, чи визначається з ``sys."
"argv[0]`` або з ``prog=`` аргументу, доступне для довідкових повідомлень за "
"допомогою специфікатора формату ``%(prog)s``."

msgid "usage"
msgstr "використання"

msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains::"
msgstr ""
"За замовчуванням :class:`ArgumentParser` обчислює повідомлення про "
"використання з аргументів, які він містить:"

msgid ""
"The default message can be overridden with the ``usage=`` keyword argument::"
msgstr ""
"Повідомлення за замовчуванням можна замінити аргументом ключового слова "
"``usage=``::"

msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr ""
"Специфікатор формату ``%(prog)s`` доступний для заповнення назви програми у "
"ваших повідомленнях про використання."

msgid "description"
msgstr "опис"

msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments::"
msgstr ""
"Більшість викликів конструктора :class:`ArgumentParser` використовуватимуть "
"аргумент ключового слова ``description=``. Цей аргумент дає короткий опис "
"того, що програма робить і як вона працює. У довідкових повідомленнях опис "
"відображається між рядком використання командного рядка та довідковими "
"повідомленнями для різних аргументів:"

msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr ""
"За замовчуванням опис буде перенесено на рядок, щоб він поміщався в заданий "
"простір. Щоб змінити цю поведінку, перегляньте аргумент formatter_class_."

msgid "epilog"
msgstr "епілог"

msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Деякі програми люблять відображати додатковий опис програми після опису "
"аргументів. Такий текст можна вказати за допомогою аргументу ``epilog=`` "
"для :class:`ArgumentParser`::"

msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"Як і в випадку з аргументом description_, текст ``epilog=`` за замовчуванням "
"переносить рядки, але цю поведінку можна налаштувати за допомогою аргументу "
"formatter_class_ на :class:`ArgumentParser`."

msgid "parents"
msgstr "батьки"

msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to :class:"
"`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :"
"class:`ArgumentParser` objects, collects all the positional and optional "
"actions from them, and adds these actions to the :class:`ArgumentParser` "
"object being constructed::"
msgstr ""
"Іноді кілька аналізаторів використовують загальний набір аргументів. Замість "
"того, щоб повторювати визначення цих аргументів, можна використати єдиний "
"синтаксичний аналізатор із усіма спільними аргументами та переданим "
"аргументом ``parents=`` для :class:`ArgumentParser`. Аргумент ``parents=`` "
"бере список об’єктів :class:`ArgumentParser`, збирає всі позиційні та "
"необов’язкові дії з них і додає ці дії до об’єкта :class:`ArgumentParser`, "
"який створюється::"

msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"Зауважте, що більшість батьківських аналізаторів вказуватимуть "
"``add_help=False``. Інакше :class:`ArgumentParser` побачить два параметри ``-"
"h/--help`` (один у батьківському і один у дочірньому) і викличе помилку."

msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr ""
"Ви повинні повністю ініціалізувати аналізатори перед тим, як передавати їх "
"через ``parents=``. Якщо ви змінюєте батьківські аналізатори після "
"дочірнього, ці зміни не відображатимуться в дочірньому."

msgid "formatter_class"
msgstr "formatter_class"

msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such "
"classes:"
msgstr ""
"Об’єкти :class:`ArgumentParser` дозволяють налаштувати форматування довідки "
"шляхом визначення альтернативного класу форматування. На даний момент існує "
"чотири таких класи:"

msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, :class:"
"`ArgumentParser` objects line-wrap the description_ and epilog_ texts in "
"command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` і :class:`RawTextHelpFormatter` дають "
"більше контролю над тим, як відображаються текстові описи. За замовчуванням "
"об’єкти :class:`ArgumentParser` переносять тексти description_ і epilog_ у "
"довідкові повідомлення командного рядка:"

msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"Передача :class:`RawDescriptionHelpFormatter` як ``formatter_class=`` вказує "
"на те, що description_ і epilog_ вже правильно відформатовані і не повинні "
"бути перенесені в рядок::"

msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple new lines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` зберігає пробіли для всіх видів довідкового "
"тексту, включаючи описи аргументів. Однак кілька нових рядків замінено "
"одним. Якщо ви бажаєте зберегти кілька порожніх рядків, додайте пробіли між "
"новими рядками."

msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` автоматично додає інформацію про "
"значення за замовчуванням до кожного довідкового повідомлення аргументу::"

msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` використовує ім’я аргументу type_ для "
"кожного аргументу як відображуване ім’я для його значень (замість "
"використання dest_, як це робить звичайний засіб форматування):"

msgid "prefix_chars"
msgstr "prefix_chars"

msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g. "
"for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the ArgumentParser constructor::"
msgstr ""
"Більшість параметрів командного рядка використовуватимуть ``-`` як префікс, "
"напр. ``-f/--foo``. Парсери, які повинні підтримувати різні або додаткові "
"префіксні символи, напр. для таких параметрів, як ``+f`` або ``/foo``, можна "
"вказати їх за допомогою аргументу ``prefix_chars=`` конструктора "
"ArgumentParser::"

msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be "
"disallowed."
msgstr ""
"Аргумент ``prefix_chars=`` за умовчанням має значення ``'-'``. Якщо вказати "
"набір символів, який не містить ``-``, параметри ``-f/--foo`` будуть "
"заборонені."

msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

msgid ""
"Sometimes, for example when dealing with a particularly long argument list, "
"it may make sense to keep the list of arguments in a file rather than typing "
"it out at the command line.  If the ``fromfile_prefix_chars=`` argument is "
"given to the :class:`ArgumentParser` constructor, then arguments that start "
"with any of the specified characters will be treated as files, and will be "
"replaced by the arguments they contain.  For example::"
msgstr ""

msgid ""
"Arguments read from a file must by default be one per line (but see also :"
"meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they "
"were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-"
"f', 'bar']``."
msgstr ""
"Аргументи, зчитані з файлу, за замовчуванням мають бути по одному на рядок "
"(але дивіться також :meth:`~ArgumentParser.convert_arg_line_to_args`) і "
"обробляються так, ніби вони знаходяться в тому самому місці, що й вихідний "
"аргумент посилання на файл у командному рядку. Отже, у наведеному вище "
"прикладі вираз ``['-f', 'foo', '@args.txt']`` вважається еквівалентним "
"виразу ``['-f', 'foo', '-f ', 'бар']``."

msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr ""
"Аргумент ``fromfile_prefix_chars=`` за умовчанням має значення ``None``, що "
"означає, що аргументи ніколи не розглядатимуться як посилання на файли."

msgid "argument_default"
msgstr "аргумент_за замовчуванням"

msgid ""
"Generally, argument defaults are specified either by passing a default to :"
"meth:`~ArgumentParser.add_argument` or by calling the :meth:`~ArgumentParser."
"set_defaults` methods with a specific set of name-value pairs.  Sometimes "
"however, it may be useful to specify a single parser-wide default for "
"arguments.  This can be accomplished by passing the ``argument_default=`` "
"keyword argument to :class:`ArgumentParser`.  For example, to globally "
"suppress attribute creation on :meth:`~ArgumentParser.parse_args` calls, we "
"supply ``argument_default=SUPPRESS``::"
msgstr ""
"Як правило, параметри за замовчуванням вказуються або передачею значення за "
"замовчуванням :meth:`~ArgumentParser.add_argument`, або викликом методів :"
"meth:`~ArgumentParser.set_defaults` із певним набором пар ім’я-значення. "
"Іноді, однак, може бути корисно вказати єдине значення за замовчуванням для "
"параметрів аналізатора. Це можна зробити, передавши аргумент ключового слова "
"``argument_default=`` до :class:`ArgumentParser`. Наприклад, щоб глобально "
"заборонити створення атрибутів у викликах :meth:`~ArgumentParser."
"parse_args`, ми надаємо ``argument_default=SUPPRESS``::"

msgid "allow_abbrev"
msgstr "дозволити_скорочене"

msgid ""
"Normally, when you pass an argument list to the :meth:`~ArgumentParser."
"parse_args` method of an :class:`ArgumentParser`, it :ref:`recognizes "
"abbreviations <prefix-matching>` of long options."
msgstr ""
"Зазвичай, коли ви передаєте список аргументів у метод :meth:`~ArgumentParser."
"parse_args` :class:`ArgumentParser`, він :ref:`розпізнає абревіатури <prefix-"
"matching>` довгих параметрів."

msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""
"Цю функцію можна вимкнути, встановивши для параметра ``allow_abbrev`` "
"значення ``False``::"

msgid "conflict_handler"
msgstr "обробник_конфлікту"

msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
"Об’єкти :class:`ArgumentParser` не дозволяють дві дії з однаковим рядком "
"параметрів. За замовчуванням об’єкти :class:`ArgumentParser` викликають "
"виняток, якщо робиться спроба створити аргумент із рядком параметрів, який "
"уже використовується:"

msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any "
"older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument "
"of :class:`ArgumentParser`::"
msgstr ""
"Іноді (наприклад, під час використання батьків_) може бути корисним просто "
"замінити будь-які старіші аргументи тим самим рядком параметрів. Щоб "
"отримати таку поведінку, значення ``'resolve'`` можна надати аргументу "
"``conflict_handler=`` :class:`ArgumentParser`::"

msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old ``-f/--"
"foo`` action is retained as the ``-f`` action, because only the ``--foo`` "
"option string was overridden."
msgstr ""
"Зауважте, що об’єкти :class:`ArgumentParser` видаляють дію лише в тому "
"випадку, якщо перевизначено всі рядки параметрів. Отже, у наведеному вище "
"прикладі стара дія ``-f/--foo`` зберігається як дія ``-f``, тому що було "
"замінено лише рядок опції ``--foo``."

msgid "add_help"
msgstr "add_help"

msgid ""
"By default, ArgumentParser objects add an option which simply displays the "
"parser's help message. For example, consider a file named ``myprogram.py`` "
"containing the following code::"
msgstr ""
"За замовчуванням об’єкти ArgumentParser додають параметр, який просто "
"відображає довідкове повідомлення аналізатора. Наприклад, розглянемо файл з "
"назвою ``myprogram.py``, який містить наступний код:"

msgid ""
"If ``-h`` or ``--help`` is supplied at the command line, the ArgumentParser "
"help will be printed:"
msgstr ""
"Якщо в командному рядку вказано ``-h`` або ``--help``, буде надруковано "
"довідку ArgumentParser:"

msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to :"
"class:`ArgumentParser`::"
msgstr ""
"Іноді може бути корисним вимкнути додавання цієї опції довідки. Цього можна "
"досягти, передавши ``False`` як аргумент ``add_help=`` до :class:"
"`ArgumentParser`::"

msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case ``-"
"h`` and ``--help`` are not valid options.  In this case, the first character "
"in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"Параметром довідки зазвичай є ``-h/--help``. Винятком є те, що "
"``prefix_chars=`` указано і не містить ``-``, у цьому випадку ``-h`` і ``--"
"help`` не є дійсними параметрами. У цьому випадку перший символ у "
"``prefix_chars`` використовується для префіксу параметрів довідки::"

msgid "exit_on_error"
msgstr "exit_on_error"

msgid ""
"Normally, when you pass an invalid argument list to the :meth:"
"`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it will "
"exit with error info."
msgstr ""
"Зазвичай, коли ви передаєте недійсний список аргументів у метод :meth:"
"`~ArgumentParser.parse_args` :class:`ArgumentParser`, він завершить роботу з "
"інформацією про помилку."

msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"Якщо користувач хоче виловлювати помилки вручну, цю функцію можна ввімкнути, "
"встановивши для ``exit_on_error`` значення ``False``::"

msgid "The add_argument() method"
msgstr "Метод add_argument()."

msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr ""
"Визначте, як слід аналізувати один аргумент командного рядка. Кожен параметр "
"має власний більш детальний опис нижче, але коротко вони:"

msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``foo`` "
"or ``-f, --foo``."
msgstr ""
"`name or flags`_ - або ім'я, або список рядків параметрів, напр. ``foo`` або "
"``-f, --foo``."

msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""
"action_ - основний тип дії, яку потрібно виконати, коли цей аргумент "
"зустрічається в командному рядку."

msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr ""
"nargs_ – кількість аргументів командного рядка, які мають бути використані."

msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""
"const_ – постійне значення, необхідне для вибору деяких action_ і nargs_."

msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr ""
"default_ – значення, створене, якщо аргумент відсутній у командному рядку та "
"якщо він відсутній в об’єкті простору імен."

msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr "type_ – тип, до якого потрібно перетворити аргумент командного рядка."

msgid "choices_ - A container of the allowable values for the argument."
msgstr "choices_ – контейнер допустимих значень для аргументу."

msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals "
"only)."
msgstr ""
"required_ – чи можна пропустити параметр командного рядка (тільки "
"необов’язковий)."

msgid "help_ - A brief description of what the argument does."
msgstr "help_ - короткий опис того, що робить аргумент."

msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ – назва аргументу в повідомленнях про використання."

msgid ""
"dest_ - The name of the attribute to be added to the object returned by :"
"meth:`parse_args`."
msgstr ""
"dest_ – ім’я атрибута, який буде додано до об’єкта, повернутого :meth:"
"`parse_args`."

msgid "name or flags"
msgstr "назву чи прапори"

msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to :meth:"
"`~ArgumentParser.add_argument` must therefore be either a series of flags, "
"or a simple argument name.  For example, an optional argument could be "
"created like::"
msgstr ""

msgid "while a positional argument could be created like::"
msgstr "тоді як позиційний аргумент може бути створений таким чином::"

msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"Під час виклику :meth:`~ArgumentParser.parse_args` необов’язкові аргументи "
"ідентифікуються префіксом ``-``, а решта аргументів вважатиметься "
"позиційними:"

msgid "action"
msgstr "дію"

msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
"Об’єкти :class:`ArgumentParser` пов’язують аргументи командного рядка з "
"діями. Ці дії можуть робити що завгодно з пов’язаними з ними аргументами "
"командного рядка, хоча більшість дій просто додають атрибут до об’єкта, який "
"повертає :meth:`~ArgumentParser.parse_args`. Аргумент ключового слова "
"``action`` визначає, як слід обробляти аргументи командного рядка. Надані "
"дії:"

msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action. For example::"
msgstr ""
"``'store'`` – тут лише зберігається значення аргументу. Це типова дія. "
"Наприклад::"

msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument.  The ``'store_const'`` action is most commonly used with optional "
"arguments that specify some sort of flag.  For example::"
msgstr ""

msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively.  For example::"
msgstr ""
"``'store_true'`` і ``'store_false'`` – це особливі випадки "
"``'store_const'``, які використовуються для зберігання значень ``True`` і "
"``False`` відповідно. Крім того, вони створюють значення за замовчуванням "
"``False`` і ``True`` відповідно. Наприклад::"

msgid ""
"``'append'`` - This stores a list, and appends each argument value to the "
"list.  This is useful to allow an option to be specified multiple times. "
"Example usage::"
msgstr ""

msgid ""
"``'append_const'`` - This stores a list, and appends the value specified by "
"the const_ keyword argument to the list.  (Note that the const_ keyword "
"argument defaults to ``None``.)  The ``'append_const'`` action is typically "
"useful when multiple arguments need to store constants to the same list. For "
"example::"
msgstr ""

msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. For "
"example, this is useful for increasing verbosity levels::"
msgstr ""
"``'count'`` – підраховує кількість разів, коли виникає аргумент ключового "
"слова. Наприклад, це корисно для збільшення рівнів докладності:"

msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr ""
"Зауважте, *за замовчуванням* буде ``None``, якщо явно не встановлено *0*."

msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` - друкує повне повідомлення довідки для всіх параметрів у "
"поточному парсері, а потім завершує роботу. За замовчуванням дія довідки "
"автоматично додається до аналізатора. Дивіться :class:`ArgumentParser` для "
"детальної інформації про те, як створюється вихід."

msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the :meth:"
"`~ArgumentParser.add_argument` call, and prints version information and "
"exits when invoked::"
msgstr ""
"``'version'`` – очікується ключовий аргумент ``version=`` у виклику :meth:"
"`~ArgumentParser.add_argument`, друкується інформація про версію та "
"завершується після виклику::"

msgid ""
"``'extend'`` - This stores a list, and extends each argument value to the "
"list. Example usage::"
msgstr ""
"``'extend'`` – це зберігає список і розширює кожне значення аргументу до "
"списку. Приклад використання::"

msgid ""
"You may also specify an arbitrary action by passing an Action subclass or "
"other object that implements the same interface. The "
"``BooleanOptionalAction`` is available in ``argparse`` and adds support for "
"boolean actions such as ``--foo`` and ``--no-foo``::"
msgstr ""
"Ви також можете вказати довільну дію, передавши підклас Action або інший "
"об’єкт, який реалізує той самий інтерфейс. ``BooleanOptionalAction`` "
"доступна в ``argparse`` і додає підтримку логічних дій, таких як ``--foo`` і "
"``--no-foo``::"

msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the ``__call__`` method and optionally the ``__init__`` and "
"``format_usage`` methods."
msgstr ""
"Рекомендований спосіб створити спеціальну дію — розширити :class:`Action`, "
"замінивши метод ``__call__`` і, за бажанням, ``__init__`` та "
"``format_usage``."

msgid "An example of a custom action::"
msgstr "Приклад спеціальної дії::"

msgid "For more details, see :class:`Action`."
msgstr "Для отримання додаткової інформації див. :class:`Action`."

msgid "nargs"
msgstr "наргс"

msgid ""
"ArgumentParser objects usually associate a single command-line argument with "
"a single action to be taken.  The ``nargs`` keyword argument associates a "
"different number of command-line arguments with a single action.  The "
"supported values are:"
msgstr ""
"Об’єкти ArgumentParser зазвичай пов’язують один аргумент командного рядка з "
"однією дією, яку потрібно виконати. Аргумент ключового слова ``nargs`` "
"пов’язує різну кількість аргументів командного рядка з однією дією. "
"Підтримувані значення:"

msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr ""
"``N`` (ціле число). ``N`` аргументів з командного рядка буде зібрано разом у "
"список. Наприклад::"

msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr ""
"Зауважте, що ``nargs=1`` створює список з одного елемента. Це відрізняється "
"від типового, коли елемент створюється сам по собі."

msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. Один аргумент буде використано з командного рядка, якщо це можливо, "
"і створено як окремий елемент. Якщо аргумент командного рядка відсутній, "
"буде отримано значення з default_. Зауважте, що для необов’язкових "
"аргументів існує додатковий випадок – рядок параметрів присутній, але не "
"слідує за аргументом командного рядка. У цьому випадку буде отримано "
"значення з const_. Деякі приклади для ілюстрації:"

msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr ""
"Одне з найпоширеніших застосувань ``nargs='?''`` — дозволити додаткові файли "
"введення та виведення:"

msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note "
"that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``. Усі присутні аргументи командного рядка збираються у список. "
"Зауважте, що зазвичай не має сенсу мати більше одного позиційного аргументу "
"з ``nargs='*'``, але кілька необов'язкових аргументів з ``nargs='*'`` "
"можливі. Наприклад::"

msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered into "
"a list.  Additionally, an error message will be generated if there wasn't at "
"least one command-line argument present.  For example::"
msgstr ""
"``'+'``. Подібно до ``'*'``, усі наявні аргументи командного рядка "
"збираються в список. Крім того, буде створено повідомлення про помилку, якщо "
"не було принаймні одного аргументу командного рядка. Наприклад::"

msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced."
msgstr ""
"Якщо аргумент ключового слова ``nargs`` не надано, кількість споживаних "
"аргументів визначається дією_. Загалом це означає, що один аргумент "
"командного рядка буде використано, і буде створено один елемент (не список)."

msgid "const"
msgstr "конст"

msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
"Аргумент ``const`` :meth:`~ArgumentParser.add_argument` використовується для "
"зберігання постійних значень, які не читаються з командного рядка, але "
"потрібні для різних дій :class:`ArgumentParser`. Два найпоширеніші його "
"використання:"

msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by :meth:"
"`~ArgumentParser.parse_args`. See the action_ description for examples."
msgstr ""

msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be assumed "
"instead. See the nargs_ description for examples."
msgstr ""

msgid ""
"With the ``'store_const'`` and ``'append_const'`` actions, the ``const`` "
"keyword argument must be given.  For other actions, it defaults to ``None``."
msgstr ""

msgid "default"
msgstr "за замовчуванням"

msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of :meth:`~ArgumentParser."
"add_argument`, whose value defaults to ``None``, specifies what value should "
"be used if the command-line argument is not present. For optional arguments, "
"the ``default`` value is used when the option string was not present at the "
"command line::"
msgstr ""
"Усі додаткові аргументи та деякі позиційні аргументи можна пропустити в "
"командному рядку. Аргумент ключового слова ``default`` :meth:"
"`~ArgumentParser.add_argument`, значення якого за замовчуванням ``None``, "
"визначає, яке значення слід використовувати, якщо аргумент командного рядка "
"відсутній. Для необов’язкових аргументів використовується значення ``за "
"замовчуванням``, якщо рядок параметрів відсутній у командному рядку::"

msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not over write it::"
msgstr ""
"Якщо цільовий простір імен уже має встановлений атрибут, дія *default* не "
"перезаписує його:"

msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the :class:"
"`Namespace` return value.  Otherwise, the parser uses the value as is::"
msgstr ""
"Якщо значенням ``default`` є рядок, синтаксичний аналізатор аналізує "
"значення так, ніби це аргумент командного рядка. Зокрема, синтаксичний "
"аналізатор застосовує будь-який аргумент перетворення type_, якщо він "
"надається, перед встановленням атрибута для значення, що повертається :class:"
"`Namespace`. В іншому випадку аналізатор використовує значення як є::"

msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""
"Для позиційних аргументів, у яких nargs_ дорівнює ``?`` або ``*``, значення "
"``default`` використовується, якщо аргумент командного рядка відсутній:"

msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr ""
"Якщо вказати ``default=argparse.SUPPRESS``, атрибут не буде додано, якщо "
"аргумент командного рядка відсутній:"

msgid "type"
msgstr "типу"

msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"За замовчуванням аналізатор читає аргументи командного рядка як прості "
"рядки. Однак досить часто рядок командного рядка слід інтерпретувати як "
"інший тип, наприклад :class:`float` або :class:`int`. Ключове слово ``type`` "
"для :meth:`~ArgumentParser.add_argument` дозволяє виконувати будь-які "
"необхідні перевірки типів і перетворення типів."

msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr ""
"Якщо ключове слово type_ використовується з ключовим словом default_, "
"конвертер типів застосовується, лише якщо значенням за замовчуванням є рядок."

msgid ""
"The argument to ``type`` can be any callable that accepts a single string. "
"If the function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or :exc:"
"`ValueError`, the exception is caught and a nicely formatted error message "
"is displayed.  No other exception types are handled."
msgstr ""
"Аргументом типу може бути будь-який виклик, який приймає один рядок. Якщо "
"функція викликає помилку :exc:`ArgumentTypeError`, :exc:`TypeError` або :exc:"
"`ValueError`, виняток буде перехоплено, і відобразиться повідомлення про "
"помилку в гарному форматі. Інші типи винятків не обробляються."

msgid "Common built-in types and functions can be used as type converters:"
msgstr ""
"Загальні вбудовані типи та функції можна використовувати як перетворювачі "
"типів:"

msgid "User defined functions can be used as well:"
msgstr "Також можна використовувати визначені користувачем функції:"

msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"Функцію :func:`bool` не рекомендується використовувати як перетворювач "
"типів. Усе, що він робить, це перетворює порожні рядки на ``False``, а "
"непорожні рядки — на ``True``. Зазвичай це не те, чого хочеться."

msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"Загалом, ключове слово ``type`` є зручним, і його слід використовувати лише "
"для простих перетворень, які можуть викликати лише одне з трьох "
"підтримуваних винятків. Усе, що має більш цікаву обробку помилок або "
"керування ресурсами, має бути зроблено нижче за течією після аналізу "
"аргументів."

msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A :exc:`~json."
"JSONDecodeError` would not be well formatted and a :exc:`FileNotFound` "
"exception would not be handled at all."
msgstr ""
"Наприклад, перетворення JSON або YAML мають складні випадки помилок, які "
"вимагають кращого звітування, ніж те, що може надати ключове слово ``type``. "
"Помилка :exc:`~json.JSONDecodeError` буде неправильно відформатована, а "
"виняток :exc:`FileNotFound` взагалі не оброблятиметься."

msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses *FileType* and then a subsequent "
"argument fails, an error is reported but the file is not automatically "
"closed.  In this case, it would be better to wait until after the parser has "
"run and then use the :keyword:`with`-statement to manage the files."
msgstr ""
"Навіть :class:`~argparse.FileType` має свої обмеження щодо використання з "
"ключовим словом ``type``. Якщо один аргумент використовує *FileType*, а "
"наступний аргумент не виконується, повідомляється про помилку, але файл не "
"закривається автоматично. У цьому випадку було б краще дочекатися завершення "
"роботи синтаксичного аналізатора, а потім використовувати оператор :keyword:"
"`with` для керування файлами."

msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr ""
"Для засобів перевірки типів, які просто перевіряють фіксований набір "
"значень, подумайте про використання ключового слова choices_."

msgid "choices"
msgstr "вибір"

msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a container object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"Деякі аргументи командного рядка слід вибирати з обмеженого набору значень. "
"З ними можна впоратися, передавши об’єкт-контейнер як аргумент ключового "
"слова *choices* до :meth:`~ArgumentParser.add_argument`. Під час "
"синтаксичного аналізу командного рядка значення аргументів буде перевірено, "
"і якщо аргумент не буде одним із допустимих значень, відобразиться "
"повідомлення про помилку:"

msgid ""
"Note that inclusion in the *choices* container is checked after any type_ "
"conversions have been performed, so the type of the objects in the *choices* "
"container should match the type_ specified::"
msgstr ""
"Зауважте, що включення до контейнера *choices* перевіряється після виконання "
"будь-яких перетворень type_, тому тип об’єктів у контейнері *choices* має "
"відповідати вказаному type_::"

msgid ""
"Any container can be passed as the *choices* value, so :class:`list` "
"objects, :class:`set` objects, and custom containers are all supported."
msgstr ""
"Будь-який контейнер можна передати як значення *choices*, тому підтримуються "
"об’єкти :class:`list`, об’єкти :class:`set` і спеціальні контейнери."

msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""
"Використання :class:`enum.Enum` не рекомендується, оскільки важко "
"контролювати його появу в повідомленнях про використання, довідці та "
"помилках."

msgid ""
"Formatted choices overrides the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""

msgid "required"
msgstr "вимагається"

msgid ""
"In general, the :mod:`argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"Загалом, модуль :mod:`argparse` припускає, що такі прапорці, як ``-f`` і ``--"
"bar``, вказують на *необов’язкові* аргументи, які завжди можна пропустити в "
"командному рядку. Щоб зробити опцію *обов’язковою*, можна вказати ``True`` "
"для ключового аргументу ``required=`` для :meth:`~ArgumentParser."
"add_argument`::"

msgid ""
"As the example shows, if an option is marked as ``required``, :meth:"
"`~ArgumentParser.parse_args` will report an error if that option is not "
"present at the command line."
msgstr ""
"Як показує приклад, якщо параметр позначено як ``required``, :meth:"
"`~ArgumentParser.parse_args` повідомить про помилку, якщо цей параметр "
"відсутній у командному рядку."

msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr ""
"Обов’язкові параметри зазвичай вважаються поганим тоном, оскільки "
"користувачі очікують, що *параметри* будуть *необов’язковими*, тому їх слід "
"уникати, коли це можливо."

msgid "help"
msgstr "допомогти"

msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument::"
msgstr ""
"Значення ``help`` - це рядок, що містить короткий опис аргументу. Коли "
"користувач запитує довідку (зазвичай за допомогою ``-h`` або ``--help`` у "
"командному рядку), ці описи ``help`` відображатимуться з кожним аргументом:"

msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword "
"arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"Рядки ``help`` можуть містити різні специфікатори формату, щоб уникнути "
"повторення таких речей, як назва програми або аргумент default_. Доступні "
"специфікатори включають назву програми, ``%(prog)s`` та більшість ключових "
"аргументів для :meth:`~ArgumentParser.add_argument`, напр. ``%(default)s``, "
"``%(type)s`` тощо::"

msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"Оскільки рядок довідки підтримує %-formatting, якщо ви хочете, щоб літерал "
"``%`` з’явився в рядку довідки, ви повинні екранувати його як ``%%``."

msgid ""
":mod:`argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`argparse` підтримує вимикання запису довідки для певних параметрів "
"шляхом встановлення значення ``help`` на ``argparse.SUPPRESS``::"

msgid "metavar"
msgstr "метавар"

msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, ArgumentParser objects use the "
"dest_ value as the \"name\" of each object.  By default, for positional "
"argument actions, the dest_ value is used directly, and for optional "
"argument actions, the dest_ value is uppercased.  So, a single positional "
"argument with ``dest='bar'`` will be referred to as ``bar``. A single "
"optional argument ``--foo`` that should be followed by a single command-line "
"argument will be referred to as ``FOO``.  An example::"
msgstr ""
"Коли :class:`ArgumentParser` створює довідкові повідомлення, йому потрібен "
"певний спосіб посилатися на кожен очікуваний аргумент. За замовчуванням "
"об’єкти ArgumentParser використовують значення dest_ як \"ім’я\" кожного "
"об’єкта. За замовчуванням для дій позиційного аргументу значення dest_ "
"використовується безпосередньо, а для необов’язкових дій аргументу значення "
"dest_ пишеться у верхньому регістрі. Отже, один позиційний аргумент із "
"``dest='bar`` буде називатися ``bar``. Один необов’язковий аргумент ``--"
"foo``, за яким має слідувати один аргумент командного рядка, буде називатися "
"``FOO``. Приклад::"

msgid "An alternative name can be specified with ``metavar``::"
msgstr "Альтернативну назву можна вказати за допомогою ``metavar``::"

msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"Зауважте, що ``metavar`` змінює лише *відображене* ім’я – ім’я атрибута "
"об’єкта :meth:`~ArgumentParser.parse_args` все ще визначається значенням "
"dest_."

msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"Різні значення ``nargs`` можуть спричинити багаторазове використання "
"метаперемінної. Надання кортежу для ``metavar`` визначає інше відображення "
"для кожного з аргументів::"

msgid "dest"
msgstr "дест"

msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of :meth:"
"`~ArgumentParser.add_argument`.  For positional argument actions, ``dest`` "
"is normally supplied as the first argument to :meth:`~ArgumentParser."
"add_argument`::"
msgstr ""
"Більшість дій :class:`ArgumentParser` додають певне значення як атрибут "
"об’єкта, який повертає :meth:`~ArgumentParser.parse_args`. Ім’я цього "
"атрибута визначається ключовим аргументом ``dest`` :meth:`~ArgumentParser."
"add_argument`. Для дій позиційного аргументу ``dest`` зазвичай надається як "
"перший аргумент :meth:`~ArgumentParser.add_argument`::"

msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"Для необов’язкових дій аргументів значення ``dest`` зазвичай виводиться з "
"рядків параметрів. :class:`ArgumentParser` генерує значення ``dest``, беручи "
"перший довгий рядок параметрів і видаляючи початковий рядок ``--``. Якщо не "
"було надано довгих рядків параметрів, ``dest`` буде отримано з першого "
"короткого рядка параметрів шляхом видалення початкового символу ``-``. Усі "
"внутрішні символи \"-\" буде перетворено на символи \"_\", щоб переконатися, "
"що рядок є дійсною назвою атрибута. Наведені нижче приклади ілюструють цю "
"поведінку:"

msgid "``dest`` allows a custom attribute name to be provided::"
msgstr "``dest`` дозволяє надати ім'я спеціального атрибута:"

msgid "Action classes"
msgstr "Класи дії"

msgid ""
"Action classes implement the Action API, a callable which returns a callable "
"which processes arguments from the command-line. Any object which follows "
"this API may be passed as the ``action`` parameter to :meth:`add_argument`."
msgstr ""
"Класи дій реалізують Action API, виклик, який повертає виклик, який обробляє "
"аргументи з командного рядка. Будь-який об’єкт, який слідує за цим API, "
"можна передати як параметр ``action`` до :meth:`add_argument`."

msgid ""
"Action objects are used by an ArgumentParser to represent the information "
"needed to parse a single argument from one or more strings from the command "
"line. The Action class must accept the two positional arguments plus any "
"keyword arguments passed to :meth:`ArgumentParser.add_argument` except for "
"the ``action`` itself."
msgstr ""
"Об’єкти дії використовуються ArgumentParser для представлення інформації, "
"необхідної для аналізу одного аргументу з одного або кількох рядків із "
"командного рядка. Клас Action повинен приймати два позиційні аргументи плюс "
"будь-які ключові аргументи, передані в :meth:`ArgumentParser.add_argument`, "
"крім самої ``action``."

msgid ""
"Instances of Action (or return value of any callable to the ``action`` "
"parameter) should have attributes \"dest\", \"option_strings\", \"default\", "
"\"type\", \"required\", \"help\", etc. defined. The easiest way to ensure "
"these attributes are defined is to call ``Action.__init__``."
msgstr ""
"Екземпляри Action (або значення, що повертається будь-яким викликом "
"параметра ``action``) повинні мати визначені атрибути \"dest\", "
"\"option_strings\", \"default\", \"type\", \"required\", \"help\" тощо. "
"Найпростіший спосіб переконатися, що ці атрибути визначені, це викликати "
"``Action.__init__``."

msgid ""
"Action instances should be callable, so subclasses must override the "
"``__call__`` method, which should accept four parameters:"
msgstr ""
"Екземпляри дій мають бути викликаними, тому підкласи повинні перевизначати "
"метод ``__call__``, який має приймати чотири параметри:"

msgid "``parser`` - The ArgumentParser object which contains this action."
msgstr "``parser`` – об’єкт ArgumentParser, який містить цю дію."

msgid ""
"``namespace`` - The :class:`Namespace` object that will be returned by :meth:"
"`~ArgumentParser.parse_args`.  Most actions add an attribute to this object "
"using :func:`setattr`."
msgstr ""
"``простір імен`` – об’єкт :class:`Namespace`, який повертатиме :meth:"
"`~ArgumentParser.parse_args`. Більшість дій додають атрибут до цього об’єкта "
"за допомогою :func:`setattr`."

msgid ""
"``values`` - The associated command-line arguments, with any type "
"conversions applied.  Type conversions are specified with the type_ keyword "
"argument to :meth:`~ArgumentParser.add_argument`."
msgstr ""
"``значення`` – пов’язані аргументи командного рядка з будь-якими "
"застосованими перетвореннями типів. Перетворення типів вказуються аргументом "
"ключового слова type_ для :meth:`~ArgumentParser.add_argument`."

msgid ""
"``option_string`` - The option string that was used to invoke this action. "
"The ``option_string`` argument is optional, and will be absent if the action "
"is associated with a positional argument."
msgstr ""
"``option_string`` - рядок параметра, який використовувався для виклику цієї "
"дії. Аргумент ``option_string`` необов’язковий і буде відсутній, якщо дію "
"пов’язано з позиційним аргументом."

msgid ""
"The ``__call__`` method may perform arbitrary actions, but will typically "
"set attributes on the ``namespace`` based on ``dest`` and ``values``."
msgstr ""
"Метод ``__call__`` може виконувати довільні дії, але зазвичай встановлює "
"атрибути в ``простір імен`` на основі ``dest`` і ``values``."

msgid ""
"Action subclasses can define a ``format_usage`` method that takes no "
"argument and return a string which will be used when printing the usage of "
"the program. If such method is not provided, a sensible default will be used."
msgstr ""
"Підкласи дій можуть визначати метод ``format_usage``, який не приймає "
"аргументів і повертає рядок, який використовуватиметься під час друку "
"використання програми. Якщо такий метод не надано, буде використано розумне "
"значення за умовчанням."

msgid "The parse_args() method"
msgstr "Метод parse_args()."

msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""
"Перетворіть рядки аргументів на об’єкти та призначте їх як атрибути простору "
"імен. Повернути заповнений простір імен."

msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for :meth:"
"`add_argument` for details."
msgstr ""
"Попередні виклики :meth:`add_argument` точно визначають, які об’єкти "
"створюються та як вони призначаються. Перегляньте документацію для :meth:"
"`add_argument` для деталей."

msgid ""
"args_ - List of strings to parse.  The default is taken from :data:`sys."
"argv`."
msgstr ""
"args_ - список рядків для аналізу. Типове значення взято з :data:`sys.argv`."

msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty :"
"class:`Namespace` object."
msgstr ""
"namespace_ – об’єкт для отримання атрибутів. Типовим є новий порожній "
"об’єкт :class:`Namespace`."

msgid "Option value syntax"
msgstr "Синтаксис значення опції"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""
"Метод :meth:`~ArgumentParser.parse_args` підтримує кілька способів "
"визначення значення параметра (якщо воно приймається). У найпростішому "
"випадку параметр і його значення передаються як два окремих аргументи:"

msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using "
"``=`` to separate them::"
msgstr ""
"Для довгих параметрів (параметрів з іменами, довшими за один символ), "
"параметр і значення також можна передати як один аргумент командного рядка, "
"використовуючи ``=``, щоб розділити їх::"

msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""
"Для коротких опцій (опції лише з одного символу) опцію та її значення можна "
"об’єднати:"

msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr ""
"Кілька коротких опцій можна об’єднати разом, використовуючи лише один "
"префікс ``-``, якщо тільки остання опція (або жодна з них) вимагає значення::"

msgid "Invalid arguments"
msgstr "Недійсні аргументи"

msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid "
"options, wrong number of positional arguments, etc.  When it encounters such "
"an error, it exits and prints the error along with a usage message::"
msgstr ""
"Під час аналізу командного рядка :meth:`~ArgumentParser.parse_args` "
"перевіряє наявність різноманітних помилок, включаючи неоднозначні параметри, "
"недійсні типи, недійсні параметри, неправильну кількість позиційних "
"аргументів тощо. Коли він стикається з такою помилкою, він виходить і друкує "
"помилку разом із повідомленням про використання::"

msgid "Arguments containing ``-``"
msgstr "Аргументи, що містять ``-``"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""
"Метод :meth:`~ArgumentParser.parse_args` намагається видавати помилки "
"щоразу, коли користувач явно зробив помилку, але деякі ситуації за своєю "
"суттю неоднозначні. Наприклад, аргумент командного рядка \"-1\" може бути "
"або спробою вказати параметр, або спробою надати позиційний аргумент. Метод :"
"meth:`~ArgumentParser.parse_args` тут обережний: позиційні аргументи можуть "
"починатися лише з ``-``, якщо вони виглядають як від’ємні числа, і в "
"аналізаторі немає параметрів, які виглядають як від’ємні числа:"

msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""
"Якщо у вас є позиційні аргументи, які повинні починатися з ``-`` і не "
"виглядати як від’ємні числа, ви можете вставити псевдоаргумент ``''--'``, "
"який повідомляє :meth:`~ArgumentParser.parse_args`, що все після цього є "
"позиційним аргументом::"

msgid "Argument abbreviations (prefix matching)"
msgstr "Скорочення аргументів (відповідність префіксу)"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
"Метод :meth:`~ArgumentParser.parse_args` :ref:`за замовчуванням "
"<allow_abbrev>` дозволяє скорочувати довгі параметри до префікса, якщо "
"скорочення є однозначним (префікс відповідає унікальному параметру)::"

msgid ""
"An error is produced for arguments that could produce more than one options. "
"This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr ""
"Помилка створюється для аргументів, які можуть давати більше одного "
"варіанту. Цю функцію можна вимкнути, встановивши для :ref:`allow_abbrev` "
"значення ``False``."

msgid "Beyond ``sys.argv``"
msgstr "За межами ``sys.argv``"

msgid ""
"Sometimes it may be useful to have an ArgumentParser parse arguments other "
"than those of :data:`sys.argv`.  This can be accomplished by passing a list "
"of strings to :meth:`~ArgumentParser.parse_args`.  This is useful for "
"testing at the interactive prompt::"
msgstr ""
"Іноді може бути корисним, щоб ArgumentParser аналізував аргументи, відмінні "
"від аргументів :data:`sys.argv`. Це можна зробити, передавши список рядків "
"до :meth:`~ArgumentParser.parse_args`. Це корисно для тестування в "
"інтерактивному запиті:"

msgid "The Namespace object"
msgstr "Об'єкт простору імен"

msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create "
"an object holding attributes and return it."
msgstr ""
"Простий клас, який за замовчуванням використовується :meth:`~ArgumentParser."
"parse_args` для створення об’єкта з атрибутами та повернення його."

msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"Цей клас навмисне простий, просто підклас :class:`object` із читабельним "
"представленням рядка. Якщо ви віддаєте перевагу перегляду атрибутів у "
"форматі dict, ви можете використовувати стандартну ідіому Python :func:"
"`vars`::"

msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object.  "
"This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""
"Також може бути корисним, щоб :class:`ArgumentParser` призначав атрибути вже "
"існуючому об’єкту, а не новому об’єкту :class:`Namespace`. Цього можна "
"досягти, вказавши аргумент ключового слова ``namespace=``::"

msgid "Other utilities"
msgstr "Інші комунальні послуги"

msgid "Sub-commands"
msgstr "Підкоманди"

msgid ""
"Many programs split up their functionality into a number of sub-commands, "
"for example, the ``svn`` program can invoke sub-commands like ``svn "
"checkout``, ``svn update``, and ``svn commit``.  Splitting up functionality "
"this way can be a particularly good idea when a program performs several "
"different functions which require different kinds of command-line "
"arguments. :class:`ArgumentParser` supports the creation of such sub-"
"commands with the :meth:`add_subparsers` method.  The :meth:`add_subparsers` "
"method is normally called with no arguments and returns a special action "
"object.  This object has a single method, :meth:`~ArgumentParser."
"add_parser`, which takes a command name and any :class:`ArgumentParser` "
"constructor arguments, and returns an :class:`ArgumentParser` object that "
"can be modified as usual."
msgstr ""
"Багато програм поділяють свої функції на декілька підкоманд, наприклад, "
"програма ``svn`` може викликати такі підкоманди, як ``svn checkout``, ``svn "
"update`` і ``svn commit``. Поділ функціональності таким чином може бути "
"особливо гарною ідеєю, коли програма виконує кілька різних функцій, які "
"потребують різних типів аргументів командного рядка. :class:`ArgumentParser` "
"підтримує створення таких підкоманд за допомогою методу :meth:"
"`add_subparsers`. Метод :meth:`add_subparsers` зазвичай викликається без "
"аргументів і повертає спеціальний об’єкт дії. Цей об’єкт має один метод, :"
"meth:`~ArgumentParser.add_parser`, який приймає ім’я команди та будь-які "
"аргументи конструктора :class:`ArgumentParser` і повертає об’єкт :class:"
"`ArgumentParser`, який можна змінювати як зазвичай."

msgid "Description of parameters:"
msgstr "Опис параметрів:"

msgid ""
"title - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""
"title - заголовок для групи суб-парсера у виведенні довідки; за "
"замовчуванням \"підкоманди\", якщо надається опис, інакше використовує "
"заголовок для позиційних аргументів"

msgid ""
"description - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""
"description - опис для групи суб-парсера у виведенні довідки, за "
"замовчуванням ``None``"

msgid ""
"prog - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""
"prog - інформація про використання, яка відображатиметься з довідкою "
"підкоманд, за замовчуванням назва програми та будь-які позиційні аргументи "
"перед аргументом subparser"

msgid ""
"parser_class - class which will be used to create sub-parser instances, by "
"default the class of the current parser (e.g. ArgumentParser)"
msgstr ""
"parser_class - клас, який використовуватиметься для створення екземплярів "
"суб-парсера, за замовчуванням клас поточного аналізатора (наприклад, "
"ArgumentParser)"

msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""
"action_ - основний тип дії, яка виконується, коли цей аргумент зустрічається "
"в командному рядку"

msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr ""
"dest_ - ім'я атрибута, під яким буде зберігатися ім'я підкоманди; за "
"замовчуванням ``None`` і жодне значення не зберігається"

msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr ""
"required_ - чи потрібно надавати підкоманду, за замовчуванням ``False`` "
"(додано в 3.7)"

msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""
"help_ - довідка для групи суб-парсера у виведенні довідки, за замовчуванням "
"``None``"

msgid ""
"metavar_ - string presenting available sub-commands in help; by default it "
"is ``None`` and presents sub-commands in form {cmd1, cmd2, ..}"
msgstr ""
"metavar_ - рядок, що представляє доступні підкоманди в довідці; за "
"замовчуванням це ``None`` і представляє підкоманди у формі {cmd1, cmd2, ..}"

msgid "Some example usage::"
msgstr "Деякі приклади використання::"

msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""
"Зауважте, що об’єкт, який повертає :meth:`parse_args`, міститиме лише "
"атрибути для головного синтаксичного аналізатора та підпарсера, вибраного "
"командним рядком (а не будь-яких інших підпарсерів). Отже, у прикладі вище, "
"коли вказано команду ``a``, присутні лише атрибути ``foo`` і ``bar``, а коли "
"вказано команду ``b``, лише наявні атрибути ``foo`` і ``baz``."

msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument "
"to :meth:`add_parser` as above.)"
msgstr ""
"Подібним чином, коли довідкове повідомлення запитується від субпарсера, буде "
"надруковано лише довідку для цього конкретного парсера. Повідомлення довідки "
"не включатиме повідомлення батьківського аналізатора або братського "
"аналізатора. (Однак довідкове повідомлення для кожної команди субпарсера "
"можна надати, надавши аргумент ``help=`` для :meth:`add_parser`, як "
"зазначено вище.)"

msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""
"Метод :meth:`add_subparsers` також підтримує ключові аргументи ``title`` і "
"``description``. Якщо будь-який з них присутній, команди субпарсера "
"відображатимуться у власній групі у виведенні довідки. Наприклад::"

msgid ""
"Furthermore, ``add_parser`` supports an additional ``aliases`` argument, "
"which allows multiple strings to refer to the same subparser. This example, "
"like ``svn``, aliases ``co`` as a shorthand for ``checkout``::"
msgstr ""
"Крім того, ``add_parser`` підтримує додатковий аргумент ``aliases``, який "
"дозволяє кільком рядкам посилатися на той самий підпарсер. Цей приклад, як і "
"``svn``, використовує псевдонім ``co`` як скорочення для ``checkout``::"

msgid ""
"One particularly effective way of handling sub-commands is to combine the "
"use of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` "
"so that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""
"Одним із особливо ефективних способів обробки підкоманд є поєднання "
"використання методу :meth:`add_subparsers` із викликами :meth:"
"`set_defaults`, щоб кожен підрозмір знав, яку функцію Python він має "
"виконати. Наприклад::"

msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"Таким чином, ви можете дозволити :meth:`parse_args` виконати роботу з "
"виклику відповідної функції після завершення аналізу аргументу. Пов’язування "
"функцій із подібними діями зазвичай є найпростішим способом обробки різних "
"дій для кожного з ваших підпарсерів. Однак, якщо необхідно перевірити ім’я "
"викликаного субпарсера, аргумент ключового слова ``dest`` для виклику :meth:"
"`add_subparsers` буде працювати:"

msgid "New *required* keyword argument."
msgstr "Новий *обов’язковий* аргумент ключового слова."

msgid "FileType objects"
msgstr "Об'єкти FileType"

msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type "
"argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:"
"`FileType` objects as their type will open command-line arguments as files "
"with the requested modes, buffer sizes, encodings and error handling (see "
"the :func:`open` function for more details)::"
msgstr ""
"Фабрика :class:`FileType` створює об’єкти, які можна передати в аргумент "
"типу :meth:`ArgumentParser.add_argument`. Аргументи, які мають тип об’єктів :"
"class:`FileType`, відкриватимуть аргументи командного рядка як файли з "
"потрібними режимами, розмірами буфера, кодуванням і обробкою помилок "
"(додаткову інформацію див. у функції :func:`open`)::"

msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into ``sys.stdin`` for readable :class:`FileType` objects and "
"``sys.stdout`` for writable :class:`FileType` objects::"
msgstr ""
"Об’єкти FileType розуміють псевдоаргумент ``'-''`` і автоматично "
"перетворюють його на ``sys.stdin`` для читабельних об’єктів :class:"
"`FileType` і ``sys.stdout`` для :class:`FileType, доступних для запису` "
"об'єкти::"

msgid "The *encodings* and *errors* keyword arguments."
msgstr "Аргументи ключових слів *encodings* і *errors*."

msgid "Argument groups"
msgstr "Групи аргументів"

msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"optional arguments\" when displaying help "
"messages. When there is a better conceptual grouping of arguments than this "
"default one, appropriate groups can be created using the :meth:"
"`add_argument_group` method::"
msgstr ""
"За замовчуванням :class:`ArgumentParser` групує аргументи командного рядка в "
"\"позиційні аргументи\" та \"необов’язкові аргументи\" під час відображення "
"довідкових повідомлень. Якщо існує краща концептуальна група аргументів, ніж "
"стандартна, відповідні групи можна створити за допомогою методу :meth:"
"`add_argument_group`::"

msgid ""
"The :meth:`add_argument_group` method returns an argument group object which "
"has an :meth:`~ArgumentParser.add_argument` method just like a regular :"
"class:`ArgumentParser`.  When an argument is added to the group, the parser "
"treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""
"Метод :meth:`add_argument_group` повертає об’єкт групи аргументів, який має "
"метод :meth:`~ArgumentParser.add_argument`, як і звичайний :class:"
"`ArgumentParser`. Коли аргумент додається до групи, аналізатор розглядає "
"його як звичайний аргумент, але відображає аргумент в окремій групі для "
"довідкових повідомлень. Метод :meth:`add_argument_group` приймає аргументи "
"*title* і *description*, які можна використовувати для налаштування цього "
"відображення:"

msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr ""
"Зверніть увагу, що будь-які аргументи, які не входять до визначених "
"користувачем груп, повертаються до звичайних розділів \"позиційні "
"аргументи\" та \"необов’язкові аргументи\"."

msgid "Mutual exclusion"
msgstr "Взаємне виключення"

msgid ""
"Create a mutually exclusive group. :mod:`argparse` will make sure that only "
"one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr ""
"Створіть взаємовиключну групу. :mod:`argparse` переконається, що лише один "
"із аргументів у взаємовиключній групі присутній у командному рядку::"

msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""
"Метод :meth:`add_mutually_exclusive_group` також приймає *обов’язковий* "
"аргумент, щоб вказати, що потрібен принаймні один із взаємовиключних "
"аргументів:"

msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of :meth:`~ArgumentParser."
"add_argument_group`."
msgstr ""
"Зауважте, що наразі взаємовиключні групи аргументів не підтримують аргументи "
"*title* і *description* :meth:`~ArgumentParser.add_argument_group`."

msgid "Parser defaults"
msgstr "Параметри аналізатора за замовчуванням"

msgid ""
"Most of the time, the attributes of the object returned by :meth:"
"`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""
"У більшості випадків атрибути об’єкта, які повертає :meth:`parse_args`, "
"будуть повністю визначені шляхом перевірки аргументів командного рядка та "
"дій аргументів. :meth:`set_defaults` дозволяє додавати деякі додаткові "
"атрибути, які визначаються без перевірки командного рядка:"

msgid ""
"Note that parser-level defaults always override argument-level defaults::"
msgstr ""
"Зверніть увагу, що значення за замовчуванням на рівні аналізатора завжди "
"перекривають значення за замовчуванням на рівні аргументів::"

msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""
"Значення за замовчуванням на рівні парсера можуть бути особливо корисними "
"під час роботи з декількома парсерами. Перегляньте метод :meth:"
"`~ArgumentParser.add_subparsers` для прикладу цього типу."

msgid ""
"Get the default value for a namespace attribute, as set by either :meth:"
"`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::"
msgstr ""
"Отримати значення за замовчуванням для атрибута простору імен, встановлене "
"або :meth:`~ArgumentParser.add_argument`, або :meth:`~ArgumentParser."
"set_defaults`::"

msgid "Printing help"
msgstr "Друк довідки"

msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""
"У більшості типових програм :meth:`~ArgumentParser.parse_args` подбає про "
"форматування та друк будь-яких повідомлень про використання чи помилки. "
"Однак доступно кілька методів форматування:"

msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""
"Надрукуйте короткий опис того, як :class:`ArgumentParser` слід викликати в "
"командному рядку. Якщо *file* має значення ``None``, передбачається :data:"
"`sys.stdout`."

msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"Надрукуйте довідкове повідомлення, включно з використанням програми та "
"інформацією про аргументи, зареєстровані в :class:`ArgumentParser`. Якщо "
"*file* має значення ``None``, передбачається :data:`sys.stdout`."

msgid ""
"There are also variants of these methods that simply return a string instead "
"of printing it:"
msgstr ""
"Існують також варіанти цих методів, які просто повертають рядок замість "
"того, щоб друкувати його:"

msgid ""
"Return a string containing a brief description of how the :class:"
"`ArgumentParser` should be invoked on the command line."
msgstr ""
"Повертає рядок, що містить короткий опис того, як :class:`ArgumentParser` "
"слід викликати в командному рядку."

msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr ""
"Повертає рядок, що містить довідкове повідомлення, включаючи використання "
"програми та інформацію про аргументи, зареєстровані в :class:"
"`ArgumentParser`."

msgid "Partial parsing"
msgstr "Частковий розбір"

msgid ""
"Sometimes a script may only parse a few of the command-line arguments, "
"passing the remaining arguments on to another script or program. In these "
"cases, the :meth:`~ArgumentParser.parse_known_args` method can be useful.  "
"It works much like :meth:`~ArgumentParser.parse_args` except that it does "
"not produce an error when extra arguments are present.  Instead, it returns "
"a two item tuple containing the populated namespace and the list of "
"remaining argument strings."
msgstr ""
"Іноді сценарій може аналізувати лише кілька аргументів командного рядка, "
"передаючи решту аргументів іншому сценарію чи програмі. У цих випадках може "
"бути корисним метод :meth:`~ArgumentParser.parse_known_args`. Він працює так "
"само, як :meth:`~ArgumentParser.parse_args`, за винятком того, що не створює "
"помилки, коли присутні додаткові аргументи. Замість цього він повертає "
"кортеж із двома елементами, що містить заповнений простір імен і список "
"решти рядків аргументів."

msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to :meth:"
"`parse_known_args`. The parser may consume an option even if it's just a "
"prefix of one of its known options, instead of leaving it in the remaining "
"arguments list."
msgstr ""
":ref:`Правила префікса, що відповідає <prefix-matching>`, застосовуються до :"
"meth:`parse_known_args`. Синтаксичний аналізатор може використати опцію, "
"навіть якщо це просто префікс однієї з відомих опцій, замість того, щоб "
"залишити її в списку аргументів, що залишилися."

msgid "Customizing file parsing"
msgstr "Налаштування аналізу файлів"

msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword "
"argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""
"Аргументи, які зчитуються з файлу (див. аргумент ключового слова "
"*fromfile_prefix_chars* конструктора :class:`ArgumentParser`), зчитуються по "
"одному аргументу на рядок. :meth:`convert_arg_line_to_args` можна замінити "
"для кращого читання."

msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""
"Цей метод приймає один аргумент *arg_line*, який є рядком, прочитаним з "
"файлу аргументів. Він повертає список аргументів, розібраних із цього рядка. "
"Метод викликається один раз на рядок, який читається з файлу аргументів, по "
"порядку."

msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""
"Корисною заміною цього методу є те, що розглядає кожне розділене пробілом "
"слово як аргумент. Наступний приклад демонструє, як це зробити:"

msgid "Exiting methods"
msgstr "Методи виходу"

msgid ""
"This method terminates the program, exiting with the specified *status* and, "
"if given, it prints a *message* before that. The user can override this "
"method to handle these steps differently::"
msgstr ""
"Цей метод завершує програму, виходячи з указаним *статусом* і, якщо він "
"заданий, перед цим друкує *повідомлення*. Користувач може перевизначити цей "
"метод, щоб виконати ці кроки інакше:"

msgid ""
"This method prints a usage message including the *message* to the standard "
"error and terminates the program with a status code of 2."
msgstr ""
"Цей метод друкує повідомлення про використання, включаючи *повідомлення* до "
"стандартної помилки, і завершує роботу програми з кодом стану 2."

msgid "Intermixed parsing"
msgstr "Змішаний розбір"

msgid ""
"A number of Unix commands allow the user to intermix optional arguments with "
"positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""
"Ряд команд Unix дозволяє користувачеві змішувати додаткові аргументи з "
"позиційними. Методи :meth:`~ArgumentParser.parse_intermixed_args` і :meth:"
"`~ArgumentParser.parse_known_intermixed_args` підтримують цей стиль аналізу."

msgid ""
"These parsers do not support all the argparse features, and will raise "
"exceptions if unsupported features are used.  In particular, subparsers, "
"``argparse.REMAINDER``, and mutually exclusive groups that include both "
"optionals and positionals are not supported."
msgstr ""
"Ці парсери не підтримують усі функції argparse і викликають винятки, якщо "
"використовуються непідтримувані функції. Зокрема, не підтримуються "
"субаналізатори, ``argparse.REMAINDER`` і взаємовиключні групи, які включають "
"опціональні та позиційні."

msgid ""
"The following example shows the difference between :meth:`~ArgumentParser."
"parse_known_args` and :meth:`~ArgumentParser.parse_intermixed_args`: the "
"former returns ``['2', '3']`` as unparsed arguments, while the latter "
"collects all the positionals into ``rest``.  ::"
msgstr ""
"У наступному прикладі показано різницю між :meth:`~ArgumentParser."
"parse_known_args` і :meth:`~ArgumentParser.parse_intermixed_args`: перший "
"повертає ``['2', '3']`` як нерозібрані аргументи, а другий збирає всі "
"позиційні елементи в ``rest``. ::"

msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple "
"containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` повертає кортеж із двома "
"елементами, що містить заповнений простір імен і список решти рядків "
"аргументів. :meth:`~ArgumentParser.parse_intermixed_args` викликає помилку, "
"якщо залишилися нерозібрані рядки аргументів."

msgid "Upgrading optparse code"
msgstr "Оновлення коду optparse"

msgid ""
"Originally, the :mod:`argparse` module had attempted to maintain "
"compatibility with :mod:`optparse`.  However, :mod:`optparse` was difficult "
"to extend transparently, particularly with the changes required to support "
"the new ``nargs=`` specifiers and better usage messages.  When most "
"everything in :mod:`optparse` had either been copy-pasted over or monkey-"
"patched, it no longer seemed practical to try to maintain the backwards "
"compatibility."
msgstr ""
"Спочатку модуль :mod:`argparse` намагався підтримувати сумісність із :mod:"
"`optparse`. Однак :mod:`optparse` було важко розширити прозоро, особливо зі "
"змінами, необхідними для підтримки нових специфікаторів ``nargs=`` і кращих "
"повідомлень про використання. Коли майже все в :mod:`optparse` було або "
"скопійовано, або виправлено мавпами, більше не здавалося практичним "
"намагатися підтримувати зворотну сумісність."

msgid ""
"The :mod:`argparse` module improves on the standard library :mod:`optparse` "
"module in a number of ways including:"
msgstr ""
"Модуль :mod:`argparse` покращує модуль стандартної бібліотеки :mod:"
"`optparse` кількома способами, зокрема:"

msgid "Handling positional arguments."
msgstr "Обробка позиційних аргументів."

msgid "Supporting sub-commands."
msgstr "Допоміжні підкоманди."

msgid "Allowing alternative option prefixes like ``+`` and ``/``."
msgstr "Дозволяє альтернативні префікси параметрів, наприклад ``+`` і ``/``."

msgid "Handling zero-or-more and one-or-more style arguments."
msgstr "Обробка нуля або більше та одного або кількох аргументів стилю."

msgid "Producing more informative usage messages."
msgstr "Створення більш інформативних повідомлень про використання."

msgid "Providing a much simpler interface for custom ``type`` and ``action``."
msgstr ""
"Забезпечення набагато простішого інтерфейсу для користувацького ``типу`` і "
"``дії``."

msgid "A partial upgrade path from :mod:`optparse` to :mod:`argparse`:"
msgstr "Шлях часткового оновлення з :mod:`optparse` до :mod:`argparse`:"

msgid ""
"Replace all :meth:`optparse.OptionParser.add_option` calls with :meth:"
"`ArgumentParser.add_argument` calls."
msgstr ""
"Замініть усі виклики :meth:`optparse.OptionParser.add_option` на виклики :"
"meth:`ArgumentParser.add_argument`."

msgid ""
"Replace ``(options, args) = parser.parse_args()`` with ``args = parser."
"parse_args()`` and add additional :meth:`ArgumentParser.add_argument` calls "
"for the positional arguments. Keep in mind that what was previously called "
"``options``, now in the :mod:`argparse` context is called ``args``."
msgstr ""
"Замініть ``(options, args) = parser.parse_args()`` на ``args = parser."
"parse_args()`` і додайте додаткові виклики :meth:`ArgumentParser."
"add_argument` для позиційних аргументів. Майте на увазі, що те, що раніше "
"називалося ``options``, тепер у контексті :mod:`argparse` називається "
"``args``."

msgid ""
"Replace :meth:`optparse.OptionParser.disable_interspersed_args` by using :"
"meth:`~ArgumentParser.parse_intermixed_args` instead of :meth:"
"`~ArgumentParser.parse_args`."
msgstr ""
"Замініть :meth:`optparse.OptionParser.disable_interspersed_args` на "
"використання :meth:`~ArgumentParser.parse_intermixed_args` замість :meth:"
"`~ArgumentParser.parse_args`."

msgid ""
"Replace callback actions and the ``callback_*`` keyword arguments with "
"``type`` or ``action`` arguments."
msgstr ""
"Замініть дії зворотного виклику та аргументи ключового слова ``callback_*`` "
"на аргументи ``type`` або ``action``."

msgid ""
"Replace string names for ``type`` keyword arguments with the corresponding "
"type objects (e.g. int, float, complex, etc)."
msgstr ""
"Замініть назви рядків для ключових аргументів ``type`` відповідними "
"об’єктами типу (наприклад, int, float, complex тощо)."

msgid ""
"Replace :class:`optparse.Values` with :class:`Namespace` and :exc:`optparse."
"OptionError` and :exc:`optparse.OptionValueError` with :exc:`ArgumentError`."
msgstr ""
"Замініть :class:`optparse.Values` на :class:`Namespace` і :exc:`optparse."
"OptionError` і :exc:`optparse.OptionValueError` на :exc:`ArgumentError`."

msgid ""
"Replace strings with implicit arguments such as ``%default`` or ``%prog`` "
"with the standard Python syntax to use dictionaries to format strings, that "
"is, ``%(default)s`` and ``%(prog)s``."
msgstr ""
"Замініть рядки неявними аргументами, такими як ``%default`` або ``%prog`` "
"стандартним синтаксисом Python, щоб використовувати словники для "
"форматування рядків, тобто ``%(default)s`` і ``%(prog)s``."

msgid ""
"Replace the OptionParser constructor ``version`` argument with a call to "
"``parser.add_argument('--version', action='version', version='<the "
"version>')``."
msgstr ""
"Замініть аргумент ``version`` конструктора OptionParser на виклик ``parser."
"add_argument('--version', action='version', version=' <the version> ')``."
