# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:04+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ""
":mod:`decimal` --- десяткова арифметика з фіксованою та плаваючою комою"

msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**Вихідний код:** :source:`Lib/decimal.py`"

msgid ""
"The :mod:`decimal` module provides support for fast correctly-rounded "
"decimal floating point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""
"Модуль :mod:`decimal` забезпечує підтримку швидкої правильно округленої "
"десяткової арифметики з плаваючою комою. Він пропонує кілька переваг перед "
"типом даних :class:`float`:"

msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimal \"базується на моделі з плаваючою комою, яка була розроблена з "
"урахуванням людей, і обов'язково має головний керівний принцип - комп'ютери "
"повинні забезпечувати арифметику, яка працює так само, як арифметика, яку "
"люди вивчають у школі\". -- витяг із специфікації десяткової арифметики."

msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like :"
"const:`1.1` and :const:`2.2` do not have exact representations in binary "
"floating point. End users typically would not expect ``1.1 + 2.2`` to "
"display as :const:`3.3000000000000003` as it does with binary floating point."
msgstr ""
"Десяткові числа можуть бути представлені точно. Навпаки, такі числа, як :"
"const:`1.1` і :const:`2.2`, не мають точного представлення у двійковій формі "
"з плаваючою комою. Кінцеві користувачі зазвичай не очікують, що ``1.1 + "
"2.2`` відображатиметься як :const:`3.3000000000000003`, як це відбувається з "
"двійковими числами з плаваючою комою."

msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is :const:`5.5511151231257827e-017`.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"Точність переходить в арифметику. У десятковій комі з плаваючою комою \"0,1 "
"+ 0,1 + 0,1 - 0,3\" точно дорівнює нулю. У двійковій формі з плаваючою комою "
"результатом є :const:`5.5511151231257827e-017`. Хоча відмінності близькі до "
"нуля, вони перешкоджають надійному тестуванню на рівність, і відмінності "
"можуть накопичуватися. З цієї причини десяткове число є кращим у програмах "
"бухгалтерського обліку, які мають суворі інваріанти рівності."

msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30 "
"* 1.20`` gives :const:`1.5600`."
msgstr ""
"Десятковий модуль містить поняття значущих розрядів, тому ``1,30 + 1,20`` "
"дорівнює :const:`2,50`. Кінцевий нуль зберігається, щоб вказати значимість. "
"Це звичайна презентація для грошових заявок. Для множення підхід \"шкільного "
"підручника\" використовує всі цифри в множених. Наприклад, ``1.3 * 1.2`` "
"дає :const:`1.56`, а ``1.30 * 1.20`` дає :const:`1.5600`."

msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"На відміну від двійкового числа з плаваючою комою на апаратній основі, "
"десятковий модуль має змінну користувачем точність (за замовчуванням 28 "
"знаків), яка може бути настільки великою, наскільки це потрібно для даної "
"проблеми:"

msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"І двійкові, і десяткові числа з плаваючою комою реалізовані відповідно до "
"опублікованих стандартів. У той час як вбудований тип float відкриває лише "
"скромну частину своїх можливостей, десятковий модуль відкриває всі необхідні "
"частини стандарту. За потреби програміст має повний контроль над округленням "
"і обробкою сигналу. Це включає в себе опцію для застосування точної "
"арифметики за допомогою винятків для блокування будь-яких неточних операцій."

msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Десятковий модуль був розроблений для підтримки \"без шкоди як точної "
"неокругленої десяткової арифметики (іноді її називають арифметикою з "
"фіксованою комою), так і округленої арифметики з плаваючою комою\". -- витяг "
"із специфікації десяткової арифметики."

msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"Конструкція модуля зосереджена навколо трьох понять: десяткове число, "
"контекст для арифметики та сигнали."

msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as :const:"
"`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also "
"differentiates :const:`-0` from :const:`+0`."
msgstr ""
"Десяткове число є незмінним. Він має знак, цифри коефіцієнта та експоненту. "
"Щоб зберегти значущість, цифри коефіцієнта не скорочують кінцеві нулі. "
"Десяткові числа також включають спеціальні значення, такі як :const:"
"`Infinity`, :const:`-Infinity` і :const:`NaN`. Стандарт також відрізняє :"
"const:`-0` від :const:`+0`."

msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"Контекст для арифметики — це середовище, що визначає точність, правила "
"округлення, обмеження на експоненти, прапори, що вказують результати "
"операцій, і засоби перехоплення, які визначають, чи розглядаються сигнали як "
"винятки. Параметри округлення включають :const:`ROUND_CEILING`, :const:"
"`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:"
"`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:`ROUND_UP` і :const:"
"`ROUND_05UP`."

msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"Сигнали - це групи виняткових умов, що виникають під час обчислень. Залежно "
"від потреб програми, сигнали можуть ігноруватися, розглядатися як "
"інформаційні або розглядатися як винятки. Сигнали в десятковому модулі: :"
"const:`Clamped`, :const:`InvalidOperation`, :const:`DivisionByZero`, :const:"
"`Inexact`, :const:`Rounded`, :const:`Subnormal`, :const:`Overflow`, :const:"
"`Underflow` і :const:`FloatOperation`."

msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"Для кожного сигналу є прапорець і активатор пастки. Коли зустрічається "
"сигнал, його прапорець встановлюється на одиницю, тоді, якщо активатор "
"перехоплення встановлений на одиницю, виникає виняток. Прапори є липкими, "
"тому користувачеві потрібно скинути їх, перш ніж контролювати обчислення."

msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <http://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"Загальна десяткова арифметична специфікація IBM, `Загальна десяткова "
"арифметична специфікація <http://speleotrove.com/decimal/decarith.html>`_."

msgid "Quick-start Tutorial"
msgstr "Короткий підручник"

msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"Звичайним початком використання десяткових дробів є імпортування модуля, "
"перегляд поточного контексту за допомогою :func:`getcontext` і, якщо "
"необхідно, встановлення нових значень для точності, округлення або "
"ввімкнення перехоплень::"

msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as :const:`NaN` which stands for \"Not a number\", positive and "
"negative :const:`Infinity`, and :const:`-0`::"
msgstr ""
"Десяткові екземпляри можуть бути створені з цілих чисел, рядків, чисел з "
"плаваючою точкою або кортежів. Конструкція з цілого числа або числа з "
"плаваючою точкою виконує точне перетворення значення цього цілого числа або "
"числа з плаваючою точкою. Десяткові числа включають спеціальні значення, "
"такі як :const:`NaN`, що означає \"Не число\", додатні та від’ємні :const:"
"`Infinity` та :const:`-0`::"

msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
"Якщо сигнал :exc:`FloatOperation` перехоплюється, випадкове змішування "
"десяткових дробів і чисел з плаваючою точкою в конструкторах або "
"впорядкованих порівняннях викликає виняток:"

msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"Значення нового десяткового дробу визначається виключно кількістю введених "
"цифр. Точність контексту та округлення застосовуються лише під час "
"арифметичних операцій."

msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"Якщо внутрішні обмеження версії C перевищено, побудова десяткового числа "
"призводить до :class:`InvalidOperation`::"

msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr ""
"Десяткові числа добре взаємодіють із більшою частиною решти Python. Ось "
"невеликий літаючий цирк з десятковою комою:"

msgid "And some mathematical functions are also available to Decimal:"
msgstr "І деякі математичні функції також доступні для Decimal:"

msgid ""
"The :meth:`quantize` method rounds a number to a fixed exponent.  This "
"method is useful for monetary applications that often round results to a "
"fixed number of places:"
msgstr ""
"Метод :meth:`quantize` округлює число до фіксованого показника. Цей метод "
"корисний для грошових програм, які часто округлюють результати до фіксованої "
"кількості місць:"

msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"Як показано вище, функція :func:`getcontext` отримує доступ до поточного "
"контексту та дозволяє змінювати налаштування. Такий підхід відповідає "
"потребам більшості програм."

msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""
"Для більш складної роботи може бути корисним створити альтернативні "
"контексти за допомогою конструктора Context(). Щоб зробити альтернативу "
"активною, використовуйте функцію :func:`setcontext`."

msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"Відповідно до стандарту, модуль :mod:`decimal` надає два готові до "
"використання стандартні контексти, :const:`BasicContext` і :const:"
"`ExtendedContext`. Перший особливо корисний для налагодження, оскільки "
"багато пасток увімкнено:"

msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`clear_flags` method. ::"
msgstr ""
"Контексти також мають сигнальні прапорці для моніторингу виняткових умов, що "
"виникають під час обчислень. Прапори залишаються встановленими, доки вони не "
"будуть очищені явно, тому найкраще знімати прапори перед кожним набором "
"контрольованих обчислень за допомогою методу :meth:`clear_flags`. ::"

msgid ""
"The *flags* entry shows that the rational approximation to :const:`Pi` was "
"rounded (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr ""
"Запис *flags* показує, що раціональне наближення до :const:`Pi` було "
"округлено (цифри, що виходять за межі точності контексту, були викинуті) і "
"що результат є неточним (деякі з відкинутих цифр були ненульовими)."

msgid ""
"Individual traps are set using the dictionary in the :attr:`traps` field of "
"a context:"
msgstr ""
"Індивідуальні пастки встановлюються за допомогою словника в полі :attr:"
"`traps` контексту:"

msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"Більшість програм коригують поточний контекст лише один раз, на початку "
"програми. І в багатьох програмах дані перетворюються на :class:`Decimal` за "
"допомогою одного приведення всередині циклу. З набором контексту та "
"створеними десятковими знаками основна частина програми маніпулює даними не "
"інакше, як з іншими числовими типами Python."

msgid "Decimal objects"
msgstr "Десяткові об'єкти"

msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "Створіть новий об’єкт :class:`Decimal` на основі *value*."

msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*значення* може бути цілим числом, рядком, кортежем, :class:`float` або "
"іншим об’єктом :class:`Decimal`. Якщо *значення* не вказано, повертає "
"``Decimal('0')``. Якщо *значення* є рядком, воно має відповідати синтаксису "
"десяткового числового рядка після видалення початкових і кінцевих пробілів, "
"а також символів підкреслення::"

msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"Інші десяткові цифри Юнікоду також дозволені там, де вказано \"цифра\" вище. "
"До них входять десяткові цифри з різних інших алфавітів (наприклад, цифри "
"арабо-індійської мови та цифри Деванагарі), а також цифри повної ширини від "
"``'\\uff10'`` до ``'\\uff19'``."

msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign (:"
"const:`0` for positive or :const:`1` for negative), a :class:`tuple` of "
"digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returns ``Decimal('1.414')``."
msgstr ""
"Якщо *value* є :class:`tuple`, воно має містити три компоненти, знак (:const:"
"`0` для позитивного або :const:`1` для негативного), :class:`tuple` цифр , і "
"цілий показник степеня. Наприклад, ``Decimal((0, (1, 4, 1, 4), -3))`` "
"повертає ``Decimal('1,414')``."

msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"Якщо *value* є :class:`float`, двійкове значення з плаваючою комою без втрат "
"перетворюється на його точний десятковий еквівалент. Для цього перетворення "
"часто може знадобитися 53 або більше цифр точності. Наприклад, "
"``Decimal(float('1.1'))`` перетворюється на "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."

msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"Точність *контексту* не впливає на кількість збережених цифр. Це "
"визначається виключно кількістю цифр у *значенні*. Наприклад, "
"``Decimal('3.00000')`` записує всі п'ять нулів, навіть якщо точність "
"контексту становить лише три."

msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of :const:`NaN`."
msgstr ""
"Метою аргументу *context* є визначення того, що робити, якщо *value* є "
"неправильним рядком. Якщо контекст перехоплює :const:`InvalidOperation`, "
"виникає виняток; інакше конструктор повертає новий Decimal зі значенням :"
"const:`NaN`."

msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "Після створення об’єкти :class:`Decimal` є незмінними."

msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr ""
"Аргументом конструктора тепер дозволено бути екземпляром :class:`float`."

msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
"Аргументи :class:`float` викликають виняток, якщо встановлено перехоплення :"
"exc:`FloatOperation`. За замовчуванням перехоплення вимкнено."

msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"Підкреслення дозволено для групування, як і з інтегральними літералами та "
"літералами з плаваючою комою в коді."

msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"Десяткові об’єкти з плаваючою комою мають багато спільних властивостей з "
"іншими вбудованими числовими типами, такими як :class:`float` і :class:"
"`int`. Застосовуються всі звичайні математичні операції та спеціальні "
"методи. Так само десяткові об’єкти можна копіювати, маринувати, друкувати, "
"використовувати як ключі до словника, використовувати як елементи набору, "
"порівнювати, сортувати та переводити до іншого типу (наприклад, :class:"
"`float` або :class:`int`)."

msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Існують деякі невеликі відмінності між арифметикою на десяткових об’єктах і "
"арифметикою на цілих числах і числах з плаваючою точкою. Коли оператор "
"залишку ``%`` застосовується до десяткових об’єктів, знаком результату є "
"знак *діленого*, а не знак дільника::"

msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"Оператор цілочисельного ділення ``//`` поводиться аналогічно, повертаючи "
"цілу частину справжньої частки (урізану до нуля), а не її нижню частину, щоб "
"зберегти звичайну тотожність ``x == (x // y) * y + x % y``::"

msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"Оператори ``%`` і ``//`` реалізують операції ``remainder`` і ``divide-"
"integer`` (відповідно), як описано в специфікації."

msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Десяткові об’єкти зазвичай не можна поєднувати з числами з плаваючою точкою "
"або екземплярами :class:`fractions.Fraction` в арифметичних операціях: "
"спроба додати :class:`Decimal` до :class:`float`, наприклад, призведе до :"
"exc:`TypeError`. Однак можна використовувати оператори порівняння Python для "
"порівняння :class:`Decimal` екземпляра ``x`` з іншим числом ``y``. Це "
"дозволяє уникнути плутанини в результатах під час порівняння рівності між "
"числами різних типів."

msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
"Порівняння змішаного типу між екземплярами :class:`Decimal` та іншими "
"числовими типами тепер повністю підтримуються."

msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr ""
"Окрім стандартних числових властивостей, десяткові об’єкти з плаваючою комою "
"також мають ряд спеціалізованих методів:"

msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"Повертає скоригований експонент після зміщення крайніх правих цифр "
"коефіцієнта, доки не залишиться лише головна цифра: ``Decimal('321e+5')."
"adjusted()`` повертає сім. Використовується для визначення позиції старшого "
"розряду відносно коми."

msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"Повертає пару ``(n, d)`` цілих чисел, які представляють даний екземпляр :"
"class:`Decimal` у вигляді дробу в найменших членах і з позитивним "
"знаменником::"

msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"Перетворення точне. Викликайте OverflowError на нескінченності та ValueError "
"на NaN."

msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"Повертає представлення числа :term:`named tuple`: ``DecimalTuple(знак, "
"цифри, експонента)``."

msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"Повертає канонічне кодування аргументу. Наразі кодування екземпляра :class:"
"`Decimal` завжди канонічне, тому ця операція повертає його аргумент без змін."

msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"Порівняйте значення двох екземплярів Decimal. :meth:`compare` повертає "
"екземпляр Decimal, і якщо один із операндів є NaN, то результатом є NaN::"

msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"Ця операція ідентична методу :meth:`compare`, за винятком того, що "
"сигналізують усі NaN. Тобто, якщо жоден операнд не є сигнальним NaN, тоді "
"будь-який тихий NaN операнд розглядається як сигнальний NaN."

msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"Порівняйте два операнди, використовуючи їх абстрактне представлення, а не "
"числове значення. Подібно до методу :meth:`compare`, але результат дає "
"загальне впорядкування екземплярів :class:`Decimal`. Два екземпляри :class:"
"`Decimal` з однаковим числовим значенням, але різними представленнями "
"порівнюються нерівномірно в такому порядку:"

msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"Безшумні та сигнальні NaN також включені в загальне замовлення. Результатом "
"цієї функції є ``Decimal('0')``, якщо обидва операнди мають однакове "
"представлення, ``Decimal('-1')``, якщо перший операнд є нижчим у загальному "
"порядку, ніж другий, і ``Decimal('1')``, якщо перший операнд вищий у "
"загальному порядку, ніж другий операнд. Дивіться специфікацію для детальної "
"інформації про загальне замовлення."

msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"Ця операція не залежить від контексту та є тихою: прапорці не змінюються та "
"округлення не виконується. Як виняток, версія C може викликати "
"InvalidOperation, якщо другий операнд не може бути точно перетворений."

msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"Порівняйте два операнди, використовуючи їх абстрактне представлення, а не "
"значення, як у :meth:`compare_total`, але ігноруючи знак кожного операнда. "
"``x.compare_total_mag(y)`` еквівалентно ``x.copy_abs().compare_total(y."
"copy_abs())``."

msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"Просто повертає self, цей метод призначений лише для відповідності "
"десятковій специфікації."

msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Повертає абсолютне значення аргументу. Ця операція не залежить від контексту "
"та є тихою: прапорці не змінюються та округлення не виконується."

msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Повернути заперечення аргументу. Ця операція не залежить від контексту та є "
"тихою: прапорці не змінюються та округлення не виконується."

msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""
"Повертає копію першого операнда зі знаком, який збігається зі знаком другого "
"операнда. Наприклад:"

msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"Повертає значення (натуральної) експоненціальної функції ``e**x`` за заданим "
"числом. Результат правильно округлюється за допомогою режиму округлення :"
"const:`ROUND_HALF_EVEN`."

msgid ""
"Alternative constructor that only accepts instances of :class:`float` or :"
"class:`int`."
msgstr ""
"Альтернативний конструктор, який приймає лише екземпляри :class:`float` або :"
"class:`int`."

msgid ""
"Note `Decimal.from_float(0.1)` is not the same as `Decimal('0.1')`. Since "
"0.1 is not exactly representable in binary floating point, the value is "
"stored as the nearest representable value which is `0x1.999999999999ap-4`.  "
"That equivalent value in decimal is "
"`0.1000000000000000055511151231257827021181583404541015625`."
msgstr ""
"Примітка. `Decimal.from_float(0.1)` не те саме, що `Decimal('0.1')`. "
"Оскільки 0,1 не можна точно представити у двійковій формі з плаваючою комою, "
"значення зберігається як найближче значення, яке можна представити, яке є "
"`0x1.999999999999ap-4`. Це еквівалентне значення в десятковій системі "
"дорівнює `0,1000000000000000055511151231257827021181583404541015625`."

msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"Починаючи з Python 3.2 і далі, екземпляр :class:`Decimal` також можна "
"створити безпосередньо з :class:`float`."

msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"Злитий множення-додавання. Повертає self*other+third без округлення "
"проміжного продукту self*other."

msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"Повертає :const:`True`, якщо аргумент є канонічним, і :const:`False` в "
"іншому випадку. Наразі екземпляр :class:`Decimal` завжди є канонічним, тому "
"ця операція завжди повертає :const:`True`."

msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"Повертає :const:`True`, якщо аргумент є скінченним числом, і :const:`False`, "
"якщо аргументом є нескінченність або NaN."

msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"Повертає :const:`True`, якщо аргумент є додатною або від’ємною "
"нескінченністю, і :const:`False` в іншому випадку."

msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"Повертає :const:`True`, якщо аргумент є (тихим або сигнальним) NaN, і :const:"
"`False` в іншому випадку."

msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"Повертає :const:`True`, якщо аргумент є *звичайним* кінцевим числом. "
"Повертає :const:`False`, якщо аргумент нульовий, субнормальний, нескінченний "
"або NaN."

msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"Повертає :const:`True`, якщо аргумент є тихим NaN, і :const:`False` в іншому "
"випадку."

msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"Повертає :const:`True`, якщо аргумент має негативний знак, і :const:`False` "
"в іншому випадку. Зауважте, що і нулі, і NaN можуть мати знаки."

msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"Повертає :const:`True`, якщо аргумент є сигнальним NaN, і :const:`False` в "
"іншому випадку."

msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"Повертає :const:`True`, якщо аргумент ненормальний, і :const:`False` в "
"іншому випадку."

msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"Повертає :const:`True`, якщо аргумент є (позитивним або від’ємним) нулем, і :"
"const:`False` в іншому випадку."

msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Повертає натуральний (за основою e) логарифм операнда. Результат правильно "
"округлюється за допомогою режиму округлення :const:`ROUND_HALF_EVEN`."

msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Повертає десятий логарифм операнда. Результат правильно округлюється за "
"допомогою режиму округлення :const:`ROUND_HALF_EVEN`."

msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"Для відмінного від нуля числа поверніть скоригований експонент його операнда "
"як екземпляр :class:`Decimal`. Якщо операнд дорівнює нулю, повертається "
"``Decimal('-Infinity')`` і піднімається прапор :const:`DivisionByZero`. Якщо "
"операнд є нескінченністю, тоді повертається ``Decimal('Infinity')``."

msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logical_and` — це логічна операція, яка приймає два *логічних "
"операнда* (див. :ref:`logical_operands_label`). Результатом є порозрядне "
"``і`` двох операндів."

msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`logical_invert` є логічною операцією. Результатом є порозрядна "
"інверсія операнда."

msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` — це логічна операція, яка приймає два *логічних "
"операнда* (див. :ref:`logical_operands_label`). Результатом є порозрядне "
"\"або\" двох операндів."

msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` — це логічна операція, яка приймає два *логічних "
"операнда* (див. :ref:`logical_operands_label`). Результатом є розрядний "
"виключний або двох операндів."

msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Подібно до ``max(self, other)``, за винятком того, що правило округлення "
"контексту застосовується перед поверненням і що значення :const:`NaN` або "
"сигналізуються, або ігноруються (залежно від контексту та того, чи є вони "
"сигнальними чи тихими)."

msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Подібно до методу :meth:`.max`, але порівняння виконується з використанням "
"абсолютних значень операндів."

msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Подібно до ``min(self, other)``, за винятком того, що правило округлення "
"контексту застосовується перед поверненням і що значення :const:`NaN` або "
"сигналізуються, або ігноруються (залежно від контексту та того, чи є вони "
"сигнальними чи тихими)."

msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Подібно до методу :meth:`.min`, але порівняння виконується з використанням "
"абсолютних значень операндів."

msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"Повертає найбільше число, яке можна представити в заданому контексті (або в "
"контексті поточного потоку, якщо контекст не задано), яке є меншим за "
"заданий операнд."

msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"Повертає найменше число, яке можна представити в заданому контексті (або в "
"контексті поточного потоку, якщо контекст не задано), яке більше заданого "
"операнда."

msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"Якщо два операнди нерівні, поверніть число, найближче до першого операнду в "
"напрямку другого операнда. Якщо обидва операнди чисельно рівні, поверніть "
"копію першого операнда зі знаком, встановленим таким самим, як знак другого "
"операнда."

msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to :const:`Decimal('0')` to :const:"
"`Decimal('0e0')`. Used for producing canonical values for attributes of an "
"equivalence class. For example, ``Decimal('32.100')`` and "
"``Decimal('0.321000e+2')`` both normalize to the equivalent value "
"``Decimal('32.1')``."
msgstr ""
"Нормалізуйте число, видаливши крайні праві кінцеві нулі та перетворивши будь-"
"який результат, рівний :const:`Decimal('0')` на :const:`Decimal('0e0')`. "
"Використовується для отримання канонічних значень для атрибутів класу "
"еквівалентності. Наприклад, ``Decimal('32.100')`` і "
"``Decimal('0.321000e+2')`` нормалізуються до еквівалентного значення "
"``Decimal('32.1')``."

msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"Повертає рядок, що описує *клас* операнда. Повернене значення є одним із "
"наступних десяти рядків."

msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, що вказує, що операнд є негативною нескінченністю."

msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``, вказуючи, що операнд є від’ємним нормальним числом."

msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr ""
"``\"-Subnormal\"``, що вказує на те, що операнд від'ємний і ненормальний."

msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, вказуючи, що операнд є від’ємним нулем."

msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, вказуючи, що операнд є позитивним нулем."

msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``, що вказує, що операнд є додатним і субнормальним."

msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``, вказуючи, що операнд є додатним нормальним числом."

msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, що вказує, що операнд є позитивною нескінченністю."

msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr "``\"NaN\"``, вказуючи, що операнд є тихим NaN (не числом)."

msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, вказуючи, що операнд є сигнальним NaN."

msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"Повертає значення, що дорівнює першому операнду після округлення та має "
"експоненту другого операнда."

msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"На відміну від інших операцій, якщо довжина коефіцієнта після операції "
"квантування буде більшою за точність, тоді сигналізується :const:"
"`InvalidOperation`. Це гарантує, що, якщо немає умови помилки, квантований "
"показник степеня завжди дорівнює показнику правого операнда."

msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"Крім того, на відміну від інших операцій, квантування ніколи не сигналізує "
"про переповнення, навіть якщо результат ненормальний і неточний."

msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"Якщо експонента другого операнда більша, ніж експонента першого, може "
"знадобитися округлення. У цьому випадку режим округлення визначається "
"аргументом ``округлення``, якщо задано, інакше заданим аргументом "
"``контексту``; якщо жоден аргумент не задано, використовується режим "
"округлення контексту поточного потоку."

msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`Emax` or less than :attr:`Etiny`."
msgstr ""
"Помилка повертається щоразу, коли кінцевий показник степеня більший за :attr:"
"`Emax` або менший за :attr:`Etiny`."

msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"Повертає ``Decimal(10)``, основу (базу), у якій клас :class:`Decimal` "
"виконує всю свою арифметику. Включено для сумісності зі специфікацією."

msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"Повертає залишок від ділення *self* на *other*. Це відрізняється від ``self "
"% other`` тим, що знак залишку вибрано таким чином, щоб мінімізувати його "
"абсолютне значення. Точніше, повертається значення ``self - n * other``, де "
"``n`` є цілим числом, найближчим до точного значення ``self / other``, і "
"якщо два цілі числа однаково близькі, то парне вибрано."

msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "Якщо результат дорівнює нулю, то його знак буде знаком *self*."

msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"Повертає результат повороту цифр першого операнда на величину, визначену "
"другим операндом. Другий операнд має бути цілим числом у діапазоні від "
"точності до точності. Абсолютне значення другого операнда дає кількість "
"місць для обертання. Якщо другий операнд додатний, то обертання відбувається "
"вліво; інакше обертання праворуч. Коефіцієнт першого операнда доповнюється "
"зліва нулями з точністю до довжини, якщо необхідно. Знак і експонента "
"першого операнда не змінюються."

msgid ""
"Test whether self and other have the same exponent or whether both are :"
"const:`NaN`."
msgstr ""
"Перевірте, чи self та other мають однаковий показник чи обидва є :const:"
"`NaN`."

msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"Повертає перший операнд з експонентою, скоригованою другим. Аналогічно "
"повертає перший операнд, помножений на ``10**other``. Другий операнд має "
"бути цілим числом."

msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"Повертає результат зсуву цифр першого операнда на величину, визначену другим "
"операндом. Другий операнд має бути цілим числом у діапазоні від точності до "
"точності. Абсолютне значення другого операнда дає кількість місць для зсуву. "
"Якщо другий операнд позитивний, то зсув виконується вліво; інакше зсув "
"відбувається вправо. Цифри, зсунуті в коефіцієнт, є нулями. Знак і "
"експонента першого операнда не змінюються."

msgid "Return the square root of the argument to full precision."
msgstr "Повертає квадратний корінь аргументу з повною точністю."

msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr ""
"Перетворіть на рядок, використовуючи технічну нотацію, якщо потрібен "
"експонент."

msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"Інженерна нотація має експоненту, кратну 3. Це може залишати до 3 цифр "
"ліворуч від десяткового знака та може потребувати додавання одного або двох "
"нулів у кінці."

msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"Наприклад, це перетворює ``Decimal('123E+1')`` на ``Decimal('1.23E+3')``."

msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
"Ідентичний методу :meth:`to_integral_value`. Ім'я ``to_integral`` було "
"збережено для сумісності зі старими версіями."

msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"Округлити до найближчого цілого числа, сигналізуючи :const:`Inexact` або :"
"const:`Rounded` відповідно, якщо відбувається округлення. Режим округлення "
"визначається параметром ``rounding``, якщо він заданий, інакше заданим "
"``context``. Якщо жоден параметр не вказано, використовується режим "
"округлення поточного контексту."

msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"Округлення до найближчого цілого без сигналізації :const:`Inexact` або :"
"const:`Rounded`. Якщо вказано, застосовує *округлення*; інакше використовує "
"метод округлення або в наданому *контексті*, або в поточному контексті."

msgid "Logical operands"
msgstr "Логічні операнди"

msgid ""
"The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and :"
"meth:`logical_xor` methods expect their arguments to be *logical operands*.  "
"A *logical operand* is a :class:`Decimal` instance whose exponent and sign "
"are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ""
"Методи :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or` і :"
"meth:`logical_xor` очікують, що їхні аргументи будуть *логічними "
"операндами*. *Логічний операнд* — це екземпляр :class:`Decimal`, експонента "
"та знак якого дорівнюють нулю, а всі цифри — :const:`0` або :const:`1`."

msgid "Context objects"
msgstr "Об'єкти контексту"

msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"Контексти - це середовища для арифметичних операцій. Вони керують точністю, "
"встановлюють правила округлення, визначають, які сигнали розглядаються як "
"винятки, і обмежують діапазон для експонент."

msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"Кожен потік має власний поточний контекст, до якого можна отримати доступ "
"або змінити його за допомогою функцій :func:`getcontext` і :func:"
"`setcontext`:"

msgid "Return the current context for the active thread."
msgstr "Повертає поточний контекст для активного потоку."

msgid "Set the current context for the active thread to *c*."
msgstr "Установіть поточний контекст для активного потоку на *c*."

msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
"Ви також можете використовувати оператор :keyword:`with` і функцію :func:"
"`localcontext`, щоб тимчасово змінити активний контекст."

msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used."
msgstr ""
"Повернути менеджер контексту, який встановить поточний контекст для "
"активного потоку на копію *ctx* під час входу в оператор with і відновить "
"попередній контекст під час виходу з оператора with. Якщо контекст не "
"вказано, використовується копія поточного контексту."

msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"Наприклад, наступний код встановлює поточну десяткову точність на 42 знаки, "
"виконує обчислення, а потім автоматично відновлює попередній контекст::"

msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"Нові контексти також можна створити за допомогою конструктора :class:"
"`Context`, описаного нижче. Крім того, модуль надає три готові контексти:"

msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"Це стандартний контекст, визначений Загальною специфікацією десяткової "
"арифметики. Точність встановлена на дев'ять. Округлення встановлено на :"
"const:`ROUND_HALF_UP`. Усі прапори видалено. Усі перехоплення ввімкнено "
"(розглядаються як винятки), крім :const:`Inexact`, :const:`Rounded` і :const:"
"`Subnormal`."

msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""
"Оскільки багато пасток увімкнено, цей контекст корисний для налагодження."

msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"Це стандартний контекст, визначений Загальною специфікацією десяткової "
"арифметики. Точність встановлена на дев'ять. Округлення встановлено на :"
"const:`ROUND_HALF_EVEN`. Усі прапори видалено. Перехоплення не ввімкнено "
"(щоб винятки не виникали під час обчислень)."

msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of :const:`NaN` or :const:`Infinity` instead of "
"raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr ""
"Оскільки перехоплення вимкнено, цей контекст корисний для програм, які "
"віддають перевагу отриманню значення результату :const:`NaN` або :const:"
"`Infinity` замість виклику винятків. Це дозволяє програмі завершити "
"виконання за наявності умов, які в іншому випадку зупинили б програму."

msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"Цей контекст використовується конструктором :class:`Context` як прототип для "
"нових контекстів. Зміна поля (така точність) призводить до зміни типового "
"значення для нових контекстів, створених конструктором :class:`Context`."

msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"Цей контекст найбільш корисний у багатопоточних середовищах. Зміна одного з "
"полів перед запуском потоків призводить до встановлення загальносистемних "
"значень за замовчуванням. Змінювати поля після початку потоків не "
"рекомендується, оскільки це потребуватиме синхронізації потоків, щоб "
"запобігти конкуренції."

msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"В однопотокових середовищах краще взагалі не використовувати цей контекст. "
"Натомість просто створіть контексти явно, як описано нижче."

msgid ""
"The default values are :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ "
"=\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:`Overflow`, :"
"class:`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"Значення за замовчуванням: :attr:`prec`\\ =\\ :const:`28`, :attr:"
"`rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, і ввімкнені пастки для :class:"
"`Overflow`, :class:`InvalidOperation` і :class:`DivisionByZero`."

msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"На додаток до трьох наданих контекстів, нові контексти можна створювати за "
"допомогою конструктора :class:`Context`."

msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"Створює новий контекст. Якщо поле не вказано або має значення :const:`None`, "
"значення за замовчуванням копіюються з :const:`DefaultContext`. Якщо поле "
"*flags* не вказано або має значення :const:`None`, усі прапорці скидаються."

msgid ""
"*prec* is an integer in the range [:const:`1`, :const:`MAX_PREC`] that sets "
"the precision for arithmetic operations in the context."
msgstr ""
"*prec* — це ціле число в діапазоні [:const:`1`, :const:`MAX_PREC`], яке "
"встановлює точність для арифметичних операцій у контексті."

msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr ""
"Опція *округлення* є однією з констант, перелічених у розділі `Режими "
"округлення`_."

msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr ""
"У полях *traps* і *flags* перелічено всі сигнали, які потрібно встановити. "
"Загалом, нові контексти мають лише встановлювати пастки та залишати прапорці "
"вільними."

msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [:const:`MIN_EMIN`, :"
"const:`0`], *Emax* in the range [:const:`0`, :const:`MAX_EMAX`]."
msgstr ""
"Поля *Emin* і *Emax* є цілими числами, що вказують зовнішні межі, допустимі "
"для експонент. *Emin* має бути в діапазоні [:const:`MIN_EMIN`, :const:`0`], "
"*Emax* в діапазоні [:const:`0`, :const:`MAX_EMAX`]."

msgid ""
"The *capitals* field is either :const:`0` or :const:`1` (the default). If "
"set to :const:`1`, exponents are printed with a capital :const:`E`; "
"otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr ""
"Поле *capitals* має значення :const:`0` або :const:`1` (за замовчуванням). "
"Якщо встановлено значення :const:`1`, показники степеня друкуються з великої "
"літери :const:`E`; інакше :const:`e` використовується в нижньому регістрі: :"
"const:`Decimal('6.02e+23')`."

msgid ""
"The *clamp* field is either :const:`0` (the default) or :const:`1`. If set "
"to :const:`1`, the exponent ``e`` of a :class:`Decimal` instance "
"representable in this context is strictly limited to the range ``Emin - prec "
"+ 1 <= e <= Emax - prec + 1``.  If *clamp* is :const:`0` then a weaker "
"condition holds: the adjusted exponent of the :class:`Decimal` instance is "
"at most ``Emax``.  When *clamp* is :const:`1`, a large normal number will, "
"where possible, have its exponent reduced and a corresponding number of "
"zeros added to its coefficient, in order to fit the exponent constraints; "
"this preserves the value of the number but loses information about "
"significant trailing zeros.  For example::"
msgstr ""
"Поле *clamp* має значення :const:`0` (за замовчуванням) або :const:`1`. Якщо "
"встановлено значення :const:`1`, експонента ``e`` екземпляра :class:"
"`Decimal`, який можна представити в цьому контексті, суворо обмежена "
"діапазоном ``Emin - prec + 1 <= e <= Emax - prec + 1``. Якщо *clamp* "
"дорівнює :const:`0`, тоді виконується слабша умова: скоригований експонент "
"екземпляра :class:`Decimal` не перевищує ``Emax``. Коли *clamp* дорівнює :"
"const:`1`, експонента великого нормального числа буде, де це можливо, "
"зменшена, а до його коефіцієнта додано відповідну кількість нулів, щоб "
"відповідати обмеженням експоненти; це зберігає значення числа, але втрачає "
"інформацію про значні кінцеві нулі. Наприклад::"

msgid ""
"A *clamp* value of :const:`1` allows compatibility with the fixed-width "
"decimal interchange formats specified in IEEE 754."
msgstr ""
"Значення *clamp* :const:`1` забезпечує сумісність із десятковими форматами "
"обміну фіксованою шириною, визначеними в IEEE 754."

msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` "
"methods) there is a corresponding :class:`Context` method.  For example, for "
"a :class:`Context` instance ``C`` and :class:`Decimal` instance ``x``, ``C."
"exp(x)`` is equivalent to ``x.exp(context=C)``.  Each :class:`Context` "
"method accepts a Python integer (an instance of :class:`int`) anywhere that "
"a Decimal instance is accepted."
msgstr ""
"Клас :class:`Context` визначає кілька методів загального призначення, а "
"також велику кількість методів для виконання арифметики безпосередньо в "
"заданому контексті. Крім того, для кожного з описаних вище методів :class:"
"`Decimal` (за винятком методів :meth:`adjusted` і :meth:`as_tuple`) існує "
"відповідний метод :class:`Context`. Наприклад, для екземпляра :class:"
"`Context` ``C`` і :class:`Decimal` примірника ``x``, ``C.exp(x)`` "
"еквівалентний ``x.exp( context=C)``. Кожен метод :class:`Context` приймає "
"ціле число Python (екземпляр :class:`int`) будь-де, де приймається примірник "
"Decimal."

msgid "Resets all of the flags to :const:`0`."
msgstr "Скидає всі прапорці на :const:`0`."

msgid "Resets all of the traps to :const:`0`."
msgstr "Скидає всі пастки до :const:`0`."

msgid "Return a duplicate of the context."
msgstr "Повернути дублікат контексту."

msgid "Return a copy of the Decimal instance num."
msgstr "Повернути копію екземпляра Decimal num."

msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"Створює новий екземпляр Decimal з *num*, але використовуючи *self* як "
"контекст. На відміну від конструктора :class:`Decimal`, до перетворення "
"застосовуються точність контексту, метод округлення, прапорці та "
"перехоплення."

msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"Це корисно, оскільки константи часто надаються з більшою точністю, ніж це "
"потрібно програмі. Ще одна перевага полягає в тому, що округлення негайно "
"усуває ненавмисні ефекти від цифр, що перевищують поточну точність. У "
"наступному прикладі використання неокруглених вхідних даних означає, що "
"додавання нуля до суми може змінити результат:"

msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"Цей метод реалізує операцію до числа специфікації IBM. Якщо аргумент є "
"рядком, пробіли чи підкреслення на початку або в кінці не допускаються."

msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"Створює новий екземпляр Decimal із числа з плаваючою точкою *f*, але "
"округляючи, використовуючи *self* як контекст. На відміну від методу класу :"
"meth:`Decimal.from_float`, до перетворення застосовуються точність "
"контексту, метод округлення, прапорці та перехоплення."

msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"Повертає значення, що дорівнює ``Emin - prec + 1``, що є мінімальним "
"значенням експоненти для субнормальних результатів. Коли відбувається "
"переповнення, експонента встановлюється на :const:`Etiny`."

msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "Повертає значення, рівне ``Emax - prec + 1``."

msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"Звичайним підходом до роботи з десятковими числами є створення :class:"
"`Decimal` екземплярів, а потім застосування арифметичних операцій, які "
"виконуються в поточному контексті для активного потоку. Альтернативним "
"підходом є використання контекстних методів для обчислення в конкретному "
"контексті. Методи подібні до методів класу :class:`Decimal` і тут лише "
"коротко перераховані."

msgid "Returns the absolute value of *x*."
msgstr "Повертає абсолютне значення *x*."

msgid "Return the sum of *x* and *y*."
msgstr "Повертає суму *x* і *y*."

msgid "Returns the same Decimal object *x*."
msgstr "Повертає той самий об’єкт Decimal *x*."

msgid "Compares *x* and *y* numerically."
msgstr "Чисельно порівнює *x* і *y*."

msgid "Compares the values of the two operands numerically."
msgstr "Чисельно порівнює значення двох операндів."

msgid "Compares two operands using their abstract representation."
msgstr "Порівнює два операнди, використовуючи їх абстрактне представлення."

msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""
"Порівнює два операнди, використовуючи їх абстрактне представлення, ігноруючи "
"знак."

msgid "Returns a copy of *x* with the sign set to 0."
msgstr "Повертає копію *x* зі знаком 0."

msgid "Returns a copy of *x* with the sign inverted."
msgstr "Повертає копію *x* з перевернутим знаком."

msgid "Copies the sign from *y* to *x*."
msgstr "Копіює знак з *y* на *x*."

msgid "Return *x* divided by *y*."
msgstr "Повертає *x*, поділене на *y*."

msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "Повертає *x*, поділене на *y*, усічене до цілого числа."

msgid "Divides two numbers and returns the integer part of the result."
msgstr "Ділить два числа та повертає цілу частину результату."

msgid "Returns `e ** x`."
msgstr "Повертає `e ** x`."

msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "Повертає *x*, помножене на *y*, плюс *z*."

msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr "Повертає ``True``, якщо *x* канонічний; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "Повертає ``True``, якщо *x* є кінцевим; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "Повертає ``True``, якщо *x* є нескінченним; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"Повертає ``True``, якщо *x* є qNaN або sNaN; інакше повертає ``False``."

msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"Повертає ``True``, якщо *x* є нормальним числом; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr "Повертає ``True``, якщо *x* є тихим NaN; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr "Повертає ``True``, якщо *x* від'ємне; інакше повертає ``False``."

msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"Повертає ``True``, якщо *x* є сигнальним NaN; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""
"Повертає ``True``, якщо *x* є субнормальним; інакше повертає ``False``."

msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "Повертає ``True``, якщо *x* дорівнює нулю; інакше повертає ``False``."

msgid "Returns the natural (base e) logarithm of *x*."
msgstr "Повертає натуральний (за основою e) логарифм *x*."

msgid "Returns the base 10 logarithm of *x*."
msgstr "Повертає логарифм *x* за основою 10."

msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "Повертає експоненту величини MSD операнда."

msgid "Applies the logical operation *and* between each operand's digits."
msgstr "Застосовує логічну операцію *і* між цифрами кожного операнда."

msgid "Invert all the digits in *x*."
msgstr "Інвертуйте всі цифри в *x*."

msgid "Applies the logical operation *or* between each operand's digits."
msgstr "Застосовує логічну операцію *або* між цифрами кожного операнда."

msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "Застосовує логічну операцію *xor* між цифрами кожного операнда."

msgid "Compares two values numerically and returns the maximum."
msgstr "Чисельно порівнює два значення та повертає максимальне значення."

msgid "Compares the values numerically with their sign ignored."
msgstr "Числово порівнює значення без урахування знака."

msgid "Compares two values numerically and returns the minimum."
msgstr "Чисельно порівнює два значення та повертає мінімум."

msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Мінус відповідає унарному префіксному оператору мінус у Python."

msgid "Return the product of *x* and *y*."
msgstr "Поверніть добуток *x* і *y*."

msgid "Returns the largest representable number smaller than *x*."
msgstr "Повертає найбільше представлене число, менше за *x*."

msgid "Returns the smallest representable number larger than *x*."
msgstr "Повертає найменше число, яке можна представити, більше за *x*."

msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "Повертає число, найближче до *x*, у напрямку до *y*."

msgid "Reduces *x* to its simplest form."
msgstr "Зводить *x* до найпростішої форми."

msgid "Returns an indication of the class of *x*."
msgstr "Повертає вказівник класу *x*."

msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Плюс відповідає унарному префіксу плюс-оператор у Python. Ця операція "
"застосовує точність контексту та округлення, тому це *не* операція "
"ідентифікації."

msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"Повертає ``x`` до степеня ``y``, зменшеного за модулем ``modulo``, якщо "
"задано."

msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly-rounded "
"in the Python version."
msgstr ""
"З двома аргументами обчисліть ``x**y``. Якщо ``x`` від'ємне, ``y`` має бути "
"цілим. Результат буде неточним, якщо ``y`` не є цілим, а результат "
"скінченним і може бути точно виражений цифрами 'точності'. Використовується "
"режим округлення контексту. У версії Python результати завжди правильно "
"округлюються."

msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)`` призводить до ``InvalidOperation``, і якщо "
"``InvalidOperation`` не перехоплюється, то призводить до ``Decimal('NaN')``."

msgid ""
"The C module computes :meth:`power` in terms of the correctly-rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly-rounded\"."
msgstr ""
"Модуль C обчислює :meth:`power` в термінах правильно округлених функцій :"
"meth:`exp` і :meth:`ln`. Результат чітко визначений, але лише \"майже завжди "
"правильно округлений\"."

msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"З трьома аргументами обчисліть ``(x**y) % по модулю``. Для форми з трьома "
"аргументами діють такі обмеження на аргументи:"

msgid "all three arguments must be integral"
msgstr "всі три аргументи повинні бути цілими"

msgid "``y`` must be nonnegative"
msgstr "\"y\" має бути невід'ємним"

msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "принаймні один із ``x`` або ``y`` має бути ненульовим"

msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` має бути ненульовим і мати щонайбільше цифр \"точності\"."

msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"Значення, отримане за допомогою ``Context.power(x, y, modulo)``, дорівнює "
"значенню, яке було б отримано шляхом обчислення ``(x**y) % по модулю`` з "
"необмеженою точністю, але обчислюється ефективніше . Показник ступеня "
"результату дорівнює нулю, незалежно від показників ``x``, ``y`` і "
"``modulo``. Результат завжди точний."

msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "Повертає значення, яке дорівнює *x* (округлене), має експоненту *y*."

msgid "Just returns 10, as this is Decimal, :)"
msgstr "Просто повертає 10, оскільки це десяткове значення :)"

msgid "Returns the remainder from integer division."
msgstr "Повертає залишок від цілочисельного ділення."

msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""
"Знак результату, якщо він відмінний від нуля, такий самий, як у вихідного "
"дивіденда."

msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"Повертає ``x - y * n``, де *n* — це ціле число, найближче до точного "
"значення ``x / y`` (якщо результат дорівнює 0, то його знаком буде знак *x*)."

msgid "Returns a rotated copy of *x*, *y* times."
msgstr "Повертає повернуту копію *x*, *y* разів."

msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "Повертає ``True``, якщо два операнди мають однаковий експонент."

msgid "Returns the first operand after adding the second value its exp."
msgstr "Повертає перший операнд після додавання другого значення його виразу."

msgid "Returns a shifted copy of *x*, *y* times."
msgstr "Повертає зміщену копію *x*, *y* разів."

msgid "Square root of a non-negative number to context precision."
msgstr "Квадратний корінь із невід’ємного числа до точності контексту."

msgid "Return the difference between *x* and *y*."
msgstr "Повертає різницю між *x* і *y*."

msgid "Rounds to an integer."
msgstr "Округлює до цілого числа."

msgid "Converts a number to a string using scientific notation."
msgstr "Перетворює число на рядок, використовуючи наукову нотацію."

msgid "Constants"
msgstr "Константи"

msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"Константи в цьому розділі актуальні лише для модуля C. Вони також включені в "
"чисту версію Python для сумісності."

msgid "32-bit"
msgstr "32-розрядний"

msgid "64-bit"
msgstr "64-розрядний"

msgid ":const:`425000000`"
msgstr ":const:`425000000`"

msgid ":const:`999999999999999999`"
msgstr ":const:`999999999999999999`"

msgid ":const:`-425000000`"
msgstr ":const:`-425000000`"

msgid ":const:`-999999999999999999`"
msgstr ":const:`-999999999999999999`"

msgid ":const:`-849999999`"
msgstr ":const:`-849999999`"

msgid ":const:`-1999999999999999997`"
msgstr ":const:`-1999999999999999997`"

msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr ""
"Значенням є ``True``. Застаріло, оскільки Python тепер завжди має потоки."

msgid ""
"The default value is ``True``. If Python is :option:`configured using the --"
"without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"Значення за замовчуванням – ``True``. Якщо Python :option:`налаштовано за "
"допомогою параметра --without-decimal-contextvar <--without-decimal-"
"contextvar>`, версія C використовує локальний контекст потоку, а не "
"локальний контекст співпрограми, а значенням є ``False``. Це трохи швидше в "
"деяких сценаріях вкладеного контексту."

msgid "backported to 3.7 and 3.8."
msgstr "перенесено на версії 3.7 і 3.8."

msgid "Rounding modes"
msgstr "Режими округлення"

msgid "Round towards :const:`Infinity`."
msgstr "Округлення в напрямку :const:`Infinity`."

msgid "Round towards zero."
msgstr "Округлити в бік нуля."

msgid "Round towards :const:`-Infinity`."
msgstr "Округлення в напрямку :const:`-Infinity`."

msgid "Round to nearest with ties going towards zero."
msgstr "Округліть до найближчого із рівністю до нуля."

msgid "Round to nearest with ties going to nearest even integer."
msgstr ""
"Округліть до найближчого зі зв’язками до найближчого парного цілого числа."

msgid "Round to nearest with ties going away from zero."
msgstr "Округліть до найближчого із рівнем від нуля."

msgid "Round away from zero."
msgstr "Округлити від нуля."

msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"Округлити від нуля, якщо остання цифра після округлення до нуля була б 0 або "
"5; інакше округліть до нуля."

msgid "Signals"
msgstr "Сигнали"

msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"Сигнали представляють умови, які виникають під час обчислення. Кожен "
"відповідає одному прапорцю контексту та одному активатору перехоплення "
"контексту."

msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"Прапор контексту встановлюється щоразу, коли зустрічається умова. Після "
"обчислення прапорці можуть бути перевірені в інформаційних цілях (наприклад, "
"щоб визначити, чи було обчислення точним). Після перевірки прапорів "
"обов’язково видаліть усі прапорці перед початком наступного обчислення."

msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"Якщо для сигналу встановлено активатор перехоплення контексту, тоді умова "
"викликає виняток Python. Наприклад, якщо встановлено перехоплення :class:"
"`DivisionByZero`, тоді виникає виняткова ситуація :exc:`DivisionByZero`, "
"коли зустрічається умова."

msgid "Altered an exponent to fit representation constraints."
msgstr "Змінено експоненту, щоб відповідати обмеженням представлення."

msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced "
"to fit by adding zeros to the coefficient."
msgstr ""
"Як правило, обмеження відбувається, коли експонента виходить за межі "
"контексту :attr:`Emin` і :attr:`Emax`. Якщо можливо, експонента скорочується "
"до відповідності шляхом додавання нулів до коефіцієнта."

msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "Базовий клас для інших сигналів і підклас :exc:`ArithmeticError`."

msgid "Signals the division of a non-infinite number by zero."
msgstr "Сигналізує про ділення нескінченного числа на нуль."

msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns :const:`Infinity` "
"or :const:`-Infinity` with the sign determined by the inputs to the "
"calculation."
msgstr ""
"Може виникнути при діленні, діленні за модулем або під час піднесення числа "
"до від’ємного степеня. Якщо цей сигнал не перехоплюється, повертає :const:"
"`Infinity` або :const:`-Infinity` зі знаком, визначеним вхідними даними "
"обчислення."

msgid "Indicates that rounding occurred and the result is not exact."
msgstr "Вказує на те, що відбулося округлення і результат неточний."

msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"Сигнали, коли під час округлення були відкинуті ненульові цифри. "
"Повертається округлений результат. Сигнальний прапор або пастка "
"використовується для виявлення неточних результатів."

msgid "An invalid operation was performed."
msgstr "Виконано недійсну операцію."

msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns :const:`NaN`.  Possible causes include::"
msgstr ""
"Вказує на те, що запитувалась операція, яка не має сенсу. Якщо не "
"перехоплено, повертає :const:`NaN`. Можливі причини:"

msgid "Numerical overflow."
msgstr "Числове переповнення."

msgid ""
"Indicates the exponent is larger than :attr:`Emax` after rounding has "
"occurred.  If not trapped, the result depends on the rounding mode, either "
"pulling inward to the largest representable finite number or rounding "
"outward to :const:`Infinity`.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"Указує, що експонента більша за :attr:`Emax` після округлення. Якщо не "
"зафіксовано, результат залежить від режиму округлення, або тягнучи всередину "
"до найбільшого кінцевого числа, яке можна представити, або округляючи "
"назовні до :const:`Infinity`. У будь-якому випадку також сигналізується :"
"class:`Inexact` і :class:`Rounded`."

msgid "Rounding occurred though possibly no information was lost."
msgstr ""
"Відбулося округлення, хоча, можливо, жодної інформації не було втрачено."

msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns "
"the result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr ""
"Сигналізується щоразу, коли округлення відкидає цифри; навіть якщо ці цифри "
"дорівнюють нулю (наприклад, округлення :const:`5.00` до :const:`5.0`). Якщо "
"не перехоплено, повертає результат без змін. Цей сигнал використовується для "
"виявлення втрати значущих цифр."

msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr "Експонента була нижчою за :attr:`Emin` до округлення."

msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"Виникає, коли результат операції є ненормальним (експонента занадто мала). "
"Якщо не перехоплено, повертає результат без змін."

msgid "Numerical underflow with result rounded to zero."
msgstr "Числове недоповнення з результатом, округленим до нуля."

msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"Виникає, коли субнормальний результат обнулюється шляхом округлення. :class:"
"`Inexact` і :class:`Subnormal` також сигналізуються."

msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr ""
"Увімкніть суворішу семантику для змішування чисел із плаваючою точкою та "
"десяткових знаків."

msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"Якщо сигнал не перехоплюється (за замовчуванням), змішування чисел із "
"плаваючою точкою та десяткових знаків дозволено в конструкторі :class:"
"`~decimal.Decimal`, :meth:`~decimal.Context.create_decimal` та в усіх "
"операторах порівняння. І перетворення, і порівняння точні. Будь-який випадок "
"змішаної операції автоматично записується шляхом встановлення :exc:"
"`FloatOperation` у прапорцях контексту. Явні перетворення за допомогою :meth:"
"`~decimal.Decimal.from_float` або :meth:`~decimal.Context."
"create_decimal_from_float` не встановлюють прапор."

msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""
"В іншому випадку (сигнал перехоплюється), лише порівняння рівності та явні "
"перетворення мовчать. Усі інші змішані операції викликають :exc:"
"`FloatOperation`."

msgid "The following table summarizes the hierarchy of signals::"
msgstr "У наступній таблиці підсумовано ієрархію сигналів:"

msgid "Floating Point Notes"
msgstr "Примітки з плаваючою комою"

msgid "Mitigating round-off error with increased precision"
msgstr "Зменшення помилки округлення з підвищеною точністю"

msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent :const:`0.1` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed the "
"fixed precision."
msgstr ""
"Використання десяткової коми з плаваючою комою усуває помилку десяткового "
"представлення (дозволяє точно представити :const:`0.1`); проте, деякі "
"операції все ще можуть викликати помилку округлення, коли ненульові цифри "
"перевищують фіксовану точність."

msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"Вплив помилки округлення може посилюватися шляхом додавання або віднімання "
"величин, які майже зміщуються, що призводить до втрати значущості. Кнут "
"наводить два повчальних приклади, коли округлена арифметика з плаваючою "
"комою з недостатньою точністю спричиняє порушення асоціативних і "
"розподільних властивостей додавання:"

msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""
"Модуль :mod:`decimal` дає змогу відновити ідентифікаційні дані, збільшивши "
"точність настільки, щоб уникнути втрати значущості:"

msgid "Special values"
msgstr "Особливі цінності"

msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:"
"`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ""
"Система числення для модуля :mod:`decimal` надає спеціальні значення, "
"включаючи :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:`Infinity` "
"та два нулі,  :const:`+0` і :const:`-0`."

msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"Нескінченності можна побудувати безпосередньо за допомогою: "
"``Decimal('Infinity')``. Крім того, вони можуть виникнути через ділення на "
"нуль, коли сигнал :exc:`DivisionByZero` не перехоплюється. Подібним чином, "
"коли сигнал :exc:`Overflow` не перехоплюється, нескінченність може бути "
"результатом округлення за межі найбільшого представленого числа."

msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""
"Нескінченності мають знак (афінні) і можуть використовуватися в арифметичних "
"операціях, де вони розглядаються як дуже великі невизначені числа. "
"Наприклад, додавання константи до нескінченності дає інший нескінченний "
"результат."

msgid ""
"Some operations are indeterminate and return :const:`NaN`, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of :"
"const:`NaN` is quiet and, once created, will flow through other computations "
"always resulting in another :const:`NaN`.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"Деякі операції є невизначеними та повертають :const:`NaN` або, якщо сигнал :"
"exc:`InvalidOperation` перехоплюється, викликають виняток. Наприклад, "
"``0/0`` повертає :const:`NaN`, що означає \"не число\". Цей різновид :const:"
"`NaN` є тихим і, створений, проходитиме через інші обчислення, що завжди "
"призводить до іншого :const:`NaN`. Така поведінка може бути корисною для "
"серії обчислень, у яких час від часу відсутні вхідні дані --- вона дозволяє "
"продовжувати обчислення, позначаючи певні результати як недійсні."

msgid ""
"A variant is :const:`sNaN` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result needs "
"to interrupt a calculation for special handling."
msgstr ""
"Варіантом є :const:`sNaN`, який сигналізує, а не мовчить після кожної "
"операції. Це корисне повертане значення, коли недійсний результат потребує "
"переривання обчислення для спеціальної обробки."

msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a :const:`NaN` is involved.  A test for equality where one of the "
"operands is a quiet or signaling :const:`NaN` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two Decimals "
"using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :"
"exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and "
"return :const:`False` if this signal is not trapped.  Note that the General "
"Decimal Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a :const:`NaN` were taken "
"from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`compare` and :meth:`compare-signal` "
"methods instead."
msgstr ""
"Поведінка операторів порівняння Python може бути трохи несподіваною, якщо "
"залучено :const:`NaN`. Тест на рівність, коли один із операндів є тихим або "
"сигнальним :const:`NaN` завжди повертає :const:`False` (навіть якщо "
"виконується ``Decimal('NaN')==Decimal('NaN')`` ), а перевірка нерівності "
"завжди повертає :const:`True`. Спроба порівняти два десяткові знаки за "
"допомогою будь-якого з операторів ``<``, ``<=``, ``>`` або ``>=`` викличе "
"сигнал :exc:`InvalidOperation`, якщо будь-який з операндів є :const:`NaN`, і "
"поверне :const:`False`, якщо цей сигнал не перехоплюється. Зауважте, що "
"специфікація General Decimal Arithmetic не визначає поведінку прямих "
"порівнянь; ці правила для порівнянь за участю :const:`NaN` були взяті зі "
"стандарту IEEE 854 (див. Таблицю 3 у розділі 5.7). Щоб забезпечити сувору "
"відповідність стандартам, замість цього використовуйте методи :meth:"
"`compare` і :meth:`compare-signal`."

msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"Нулі зі знаком можуть виникати в результаті обчислень, які занижуються. Вони "
"зберігають знак, який був би отриманий, якби розрахунок проводився з більшою "
"точністю. Оскільки їх величина дорівнює нулю, додатні та від’ємні нулі "
"вважаються рівними, а їх знак є інформаційним."

msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"На додаток до двох нулів зі знаком, які є різними, але однаковими, існують "
"різні представлення нуля з різною точністю, але еквівалентні за значенням. "
"До цього потрібно трохи звикнути. Для ока, яке звикло до нормалізованих "
"представлень із плаваючою комою, не відразу стане очевидним, що наступне "
"обчислення повертає значення, що дорівнює нулю:"

msgid "Working with threads"
msgstr "Робота з нитками"

msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
"Функція :func:`getcontext` отримує доступ до іншого об’єкта :class:`Context` "
"для кожного потоку. Наявність окремих контекстів потоків означає, що потоки "
"можуть вносити зміни (наприклад, ``getcontext().prec=10``), не заважаючи "
"іншим потокам."

msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""
"Подібним чином функція :func:`setcontext` автоматично призначає свою ціль "
"поточному потоку."

msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""
"Якщо :func:`setcontext` не викликався раніше :func:`getcontext`, тоді :func:"
"`getcontext` автоматично створить новий контекст для використання в "
"поточному потоці."

msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"Новий контекст скопійовано з контексту прототипу під назвою "
"*DefaultContext*. Щоб керувати параметрами за замовчуванням, щоб кожен потік "
"використовував однакові значення в усій програмі, безпосередньо змініть "
"об’єкт *DefaultContext*. Це слід зробити *перед* запуском будь-яких потоків, "
"щоб не виникало змагання між потоками, що викликають :func:`getcontext`. "
"Наприклад::"

msgid "Recipes"
msgstr "рецепти"

msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""
"Ось кілька рецептів, які служать допоміжними функціями та демонструють "
"способи роботи з класом :class:`Decimal`::"

msgid "Decimal FAQ"
msgstr "Десятковий FAQ"

msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""
"З. Громіздко вводити ``decimal.Decimal('1234.5')``. Чи є спосіб мінімізувати "
"введення під час використання інтерактивного перекладача?"

msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. Деякі користувачі скорочують конструктор лише до однієї літери:"

msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"Q. У програмі з фіксованою комою з двома знаками після коми деякі вхідні "
"дані мають багато знаків і їх потрібно округлити. Інші не повинні мати "
"зайвих цифр і потребують перевірки. Які методи слід використовувати?"

msgid ""
"A. The :meth:`quantize` method rounds to a fixed number of decimal places. "
"If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr ""
"A. Метод :meth:`quantize` округлює до фіксованої кількості знаків після "
"коми. Якщо встановлено перехоплення :const:`Inexact`, це також корисно для "
"перевірки:"

msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""
"З. Якщо я маю дійсні двомісні введення, як мені підтримувати цей інваріант у "
"всій програмі?"

msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`quantize` step:"
msgstr ""
"A. Деякі операції, такі як додавання, віднімання та множення на ціле число, "
"автоматично зберігають фіксовану кому. Інші операції, як-от ділення та "
"неціле множення, змінюватимуть кількість десяткових знаків і потребуватимуть "
"подальших кроків :meth:`quantize`:"

msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`quantize` step:"
msgstr ""
"У розробці додатків із фіксованою крапкою зручно визначати функції для "
"обробки кроку :meth:`quantize`:"

msgid ""
"Q. There are many ways to express the same value.  The numbers :const:"
"`200`, :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same "
"value at various precisions. Is there a way to transform them to a single "
"recognizable canonical value?"
msgstr ""
"Q. Є багато способів вираження того самого значення. Числа :const:`200`, :"
"const:`200.000`, :const:`2E2` і :const:`.02E+4` мають однакові значення з "
"різною точністю. Чи є спосіб перетворити їх до єдиного розпізнаваного "
"канонічного значення?"

msgid ""
"A. The :meth:`normalize` method maps all equivalent values to a single "
"representative:"
msgstr ""
"A. Метод :meth:`normalize` відображає всі еквівалентні значення в одному "
"представнику:"

msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""
"З. Деякі десяткові значення завжди друкуються в експоненціальному вигляді. "
"Чи є спосіб отримати неекспоненціальне представлення?"

msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing :"
"const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"A. Для деяких значень експоненціальний запис є єдиним способом вираження "
"кількості значущих місць у коефіцієнті. Наприклад, вираження :const:`5.0E+3` "
"як :const:`5000` зберігає значення постійним, але не може показати двозначне "
"значення оригіналу."

msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""
"Якщо програма не піклується про відстеження значущості, можна легко видалити "
"експоненту та кінцеві нулі, втрачаючи значущість, але зберігаючи значення "
"незмінним:"

msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr "Q. Чи є спосіб перетворити звичайний float на :class:`Decimal`?"

msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""
"A. Так, будь-яке двійкове число з плаваючою комою можна точно виразити як "
"десяткове число, хоча точне перетворення може вимагати більшої точності, ніж "
"передбачає інтуїція:"

msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""
"Q. Як я можу переконатися, що в рамках складного обчислення я не отримав "
"фальшивий результат через недостатню точність або аномалії округлення."

msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"A. Десятковий модуль дозволяє легко перевірити результати. Найкраща практика "
"— повторити обчислення з більшою точністю та різними режимами округлення. "
"Різні результати вказують на недостатню точність, проблеми з режимом "
"округлення, погано обумовлені вхідні дані або чисельно нестабільний алгоритм."

msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""
"З. Я помітив, що точність контексту застосовується до результатів операцій, "
"але не до вхідних даних. Чи є на що слід звернути увагу під час змішування "
"значень різної точності?"

msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"А. Так. Принцип полягає в тому, що всі значення вважаються точними, як і "
"арифметика цих значень. Округлюються лише результати. Перевага введення "
"даних полягає в тому, що \"те, що ви вводите, те й отримуєте\". Недоліком є "
"те, що результати можуть виглядати дивно, якщо ви забудете, що вхідні дані "
"не були округлені:"

msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""
"Рішення полягає в тому, щоб підвищити точність або примусово округлити "
"вхідні дані за допомогою унарної операції плюс:"

msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""
"Крім того, вхідні дані можна округлити під час створення за допомогою "
"методу :meth:`Context.create_decimal`:"

msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "Q. Чи швидка реалізація CPython для великих чисел?"

msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly-rounded decimal floating point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""
"А. Так. У реалізаціях CPython і PyPy3 версії десяткового модуля C/CFFI "
"інтегрують високошвидкісну бібліотеку `libmpdec <https://www.bytereef.org/"
"mpdecimal/doc/libmpdec/index.html>`_ для правильно округленої десяткової "
"арифметики з плаваючою комою довільної точності [#]_. ``libmpdec`` "
"використовує `Множення Карацуби <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ для чисел середнього розміру та `Теоретичне "
"перетворення чисел <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ для дуже "
"великих чисел."

msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`Emin` and :attr:`Emax` should always be set to the maximum values, :attr:"
"`clamp` should always be 0 (the default).  Setting :attr:`prec` requires "
"some care."
msgstr ""
"Контекст має бути адаптований для точної арифметики довільної точності. :"
"attr:`Emin` і :attr:`Emax` завжди повинні бути встановлені на максимальні "
"значення, :attr:`clamp` завжди має бути 0 (за замовчуванням). Налаштування :"
"attr:`prec` вимагає певної обережності."

msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`prec` as well [#]_::"
msgstr ""
"Найпростіший підхід для випробування арифметики bignum — використовувати "
"максимальне значення для :attr:`prec`, а також [#]_::"

msgid ""
"For inexact results, :attr:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""
"Для отримання неточних результатів :attr:`MAX_PREC` є занадто великим на 64-"
"розрядних платформах, тому доступної пам’яті буде недостатньо:"

msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`prec` to the amount of available RAM.  Suppose that you "
"have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB "
"each::"
msgstr ""
"У системах із загальним розподілом (наприклад, Linux) більш складним "
"підходом є налаштування :attr:`prec` на обсяг доступної оперативної пам’яті. "
"Припустімо, що у вас є 8 ГБ оперативної пам’яті та ви очікуєте 10 одночасних "
"операндів, використовуючи максимум 500 МБ кожен:"

msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""
"Загалом (і особливо в системах без загального розподілу) рекомендується "
"оцінювати ще більш жорсткі межі та встановлювати пастку :attr:`Inexact`, "
"якщо очікується, що всі обчислення будуть точними."

msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr ""
"Цей підхід тепер працює для всіх точних результатів, за винятком нецілих "
"степенів."
