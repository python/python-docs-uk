# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- оболонка TLS/SSL для об'єктів сокета"

msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Вихідний код:** :source:`Lib/ssl.py`"

msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Цей модуль надає доступ до шифрування транспортного рівня безпеки (часто "
"відомого як \"рівень захищених сокетів\") і засобів автентифікації "
"однорангових мережевих сокетів як на стороні клієнта, так і на стороні "
"сервера. Цей модуль використовує бібліотеку OpenSSL. Він доступний у всіх "
"сучасних системах Unix, Windows, macOS і, ймовірно, на додаткових "
"платформах, якщо на цій платформі встановлено OpenSSL."

msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 with OpenSSL version "
"1.1.1."
msgstr ""
"Деяка поведінка може залежати від платформи, оскільки виклики здійснюються "
"до API сокетів операційної системи. Установлена версія OpenSSL також може "
"спричиняти зміни в поведінці. Наприклад, TLSv1.3 з OpenSSL версії 1.1.1."

msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"Не використовуйте цей модуль, не прочитавши :ref:`ssl-security`. Це може "
"призвести до помилкового відчуття безпеки, оскільки стандартні параметри "
"модуля ssl не обов’язково підходять для вашої програми."

msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"У цьому розділі описано об’єкти та функції модуля ``ssl``; для отримання "
"більш загальної інформації про TLS, SSL і сертифікати, читач буде направлено "
"до документів у розділі \"Див. також\" внизу."

msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"Цей модуль надає клас :class:`ssl.SSLSocket`, який є похідним від типу :"
"class:`socket.socket`, і забезпечує оболонку, схожу на сокет, яка також "
"шифрує та розшифровує дані, що передаються через сокет за допомогою SSL. . "
"Він підтримує додаткові методи, такі як :meth:`getpeercert`, який отримує "
"сертифікат іншого боку з’єднання, і :meth:`cipher`, який отримує шифр, який "
"використовується для безпечного з’єднання."

msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"Для складніших програм клас :class:`ssl.SSLContext` допомагає керувати "
"налаштуваннями та сертифікатами, які потім можуть бути успадковані сокетами "
"SSL, створеними за допомогою методу :meth:`SSLContext.wrap_socket`."

msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Оновлено для підтримки зв’язування з OpenSSL 1.1.0"

msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 і 1.0.1 застаріли та більше не підтримуються. У "
"майбутньому модуль ssl потребуватиме принаймні OpenSSL 1.0.2 або 1.1.0."

msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""
":pep:`644` реалізовано. Модуль ssl вимагає OpenSSL 1.1.1 або новішої версії."

msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""
"Використання застарілих констант і функцій призводить до попереджень про "
"застаріле."

msgid "Functions, Constants, and Exceptions"
msgstr "Функції, константи та винятки"

msgid "Socket creation"
msgstr "Створення розетки"

msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` of an :class:`SSLContext` instance to wrap sockets as :class:"
"`SSLSocket` objects. The helper functions :func:`create_default_context` "
"returns a new context with secure default settings. The old :func:"
"`wrap_socket` function is deprecated since it is both inefficient and has no "
"support for server name indication (SNI) and hostname matching."
msgstr ""
"Починаючи з Python 3.2 і 2.7.9, рекомендується використовувати :meth:"
"`SSLContext.wrap_socket` екземпляра :class:`SSLContext` для обгортання "
"сокетів як об’єктів :class:`SSLSocket`. Допоміжні функції :func:"
"`create_default_context` повертають новий контекст із безпечними параметрами "
"за замовчуванням. Стара функція :func:`wrap_socket` є застарілою, оскільки "
"вона є неефективною та не підтримує індикацію імені сервера (SNI) та "
"відповідність імені хоста."

msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""
"Приклад клієнтського сокета з контекстом за замовчуванням і подвійним стеком "
"IPv4/IPv6::"

msgid "Client socket example with custom context and IPv4::"
msgstr "Приклад клієнтського сокета з власним контекстом і IPv4::"

msgid "Server socket example listening on localhost IPv4::"
msgstr "Приклад серверного сокета, який прослуховує локальний хост IPv4::"

msgid "Context creation"
msgstr "Створення контексту"

msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"Зручна функція допомагає створювати об’єкти :class:`SSLContext` для "
"звичайних цілей."

msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Повертає новий об’єкт :class:`SSLContext` із налаштуваннями за замовчуванням "
"для заданої *цілі*. Параметри вибираються модулем :mod:`ssl` і зазвичай "
"представляють вищий рівень безпеки, ніж під час безпосереднього виклику "
"конструктора :class:`SSLContext`."

msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* представляють додаткові сертифікати ЦС, яким "
"можна довіряти для перевірки сертифікатів, як у :meth:`SSLContext."
"load_verify_locations`. Якщо всі три параметри :const:`None`, ця функція "
"може натомість довіряти стандартним сертифікатам ЦС системи."

msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :data:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"Параметри такі: :data:`PROTOCOL_TLS_CLIENT` або :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2` і :data:`OP_NO_SSLv3` з наборами "
"шифрів високого рівня шифрування без RC4 і без неавтентифікованих наборів "
"шифрів. Передача :data:`~Purpose.SERVER_AUTH` як *purpose* встановлює :data:"
"`~SSLContext.verify_mode` на :data:`CERT_REQUIRED` і або завантажує "
"сертифікати ЦС (якщо принаймні один із *cafile*, *capath* або *cadata* "
"задано) або використовує :meth:`SSLContext.load_default_certs` для "
"завантаження стандартних сертифікатів ЦС."

msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"Якщо підтримується :attr:`~SSLContext.keylog_filename` і встановлено змінну "
"середовища :envvar:`SSLKEYLOGFILE`, :func:`create_default_context` вмикає "
"журналювання ключів."

msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"Протокол, параметри, шифр та інші параметри можуть будь-коли змінитися на "
"більш обмежувальні значення без попереднього припинення. Значення "
"представляють справедливий баланс між сумісністю та безпекою."

msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Якщо вашій програмі потрібні певні налаштування, ви повинні створити :class:"
"`SSLContext` і застосувати налаштування самостійно."

msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Якщо ви виявите, що коли певні старіші клієнти чи сервери намагаються "
"підключитися за допомогою :class:`SSLContext`, створеного цією функцією, "
"вони отримують помилку \"Невідповідність протоколу чи набору шифрів\", "
"можливо, вони підтримують лише SSL3.0, який ця функція виключає "
"використання :data:`OP_NO_SSLv3`. SSL3.0 широко вважається `повністю "
"зламаним <https://en.wikipedia.org/wiki/POODLE>`_. Якщо ви все ще бажаєте "
"продовжувати використовувати цю функцію, але все ще дозволяєте підключення "
"SSL 3.0, ви можете повторно ввімкнути їх за допомогою::"

msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 було видалено з рядка шифру за замовчуванням."

msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 додано до рядка шифру за замовчуванням."

msgid "3DES was dropped from the default cipher string."
msgstr "3DES було видалено з рядка шифру за замовчуванням."

msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "Додано підтримку реєстрації ключів у :envvar:`SSLKEYLOGFILE`."

msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""
"Контекст тепер використовує протокол :data:`PROTOCOL_TLS_CLIENT` або :data:"
"`PROTOCOL_TLS_SERVER` замість загального :data:`PROTOCOL_TLS`."

msgid "Exceptions"
msgstr "Винятки"

msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Піднято, щоб повідомити про помилку базової реалізації SSL (наразі надається "
"бібліотекою OpenSSL). Це означає певну проблему на рівні шифрування та "
"автентифікації вищого рівня, який накладається на базове мережеве з’єднання. "
"Ця помилка є підтипом :exc:`OSError`. Код помилки та повідомлення "
"екземплярів :exc:`SSLError` надає бібліотека OpenSSL."

msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` раніше був підтипом :exc:`socket.error`."

msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"Рядкова мнемоніка, що позначає субмодуль OpenSSL, у якому сталася помилка, "
"наприклад ``SSL``, ``PEM`` або ``X509``. Діапазон можливих значень залежить "
"від версії OpenSSL."

msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"Рядок мнемоніки, що вказує причину цієї помилки, наприклад "
"``CERTIFICATE_VERIFY_FAILED``. Діапазон можливих значень залежить від версії "
"OpenSSL."

msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"Підклас :exc:`SSLError` викликається під час спроби читання або запису, а "
"SSL-з’єднання було закрито. Зауважте, що це не означає, що основний "
"транспорт (читай TCP) закрито."

msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Підклас :exc:`SSLError`, викликаний :ref:`неблокуючим SSL-сокетом <ssl-"
"nonblocking>` під час спроби прочитати або записати дані, але для виконання "
"запиту потрібно отримати більше даних базовим транспортом TCP."

msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Підклас :exc:`SSLError`, викликаний :ref:`неблокуючим SSL-сокетом <ssl-"
"nonblocking>` під час спроби прочитати або записати дані, але більше даних "
"потрібно надіслати базовим транспортом TCP, перш ніж запит буде виконано."

msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"Підклас :exc:`SSLError` викликається, коли виникла системна помилка під час "
"спроби виконати операцію на SSL-сокеті. На жаль, немає простого способу "
"перевірити оригінальний номер errno."

msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"Підклас :exc:`SSLError` викликається, коли з’єднання SSL було раптово "
"розірвано. Як правило, ви не повинні намагатися повторно використовувати "
"базовий транспорт, коли виникає ця помилка."

msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"Підклас :exc:`SSLError` викликається, коли не вдається перевірити сертифікат."

msgid "A numeric error number that denotes the verification error."
msgstr "Числовий номер помилки, який позначає помилку підтвердження."

msgid "A human readable string of the verification error."
msgstr "Зрозумілий для людини рядок помилки перевірки."

msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Псевдонім для :exc:`SSLCertVerificationError`."

msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "Винятком тепер є псевдонім для :exc:`SSLCertVerificationError`."

msgid "Random generation"
msgstr "Випадкова генерація"

msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Повертає *num* криптографічно надійних псевдовипадкових байтів. Викликає :"
"class:`SSLError`, якщо PRNG не було заповнено достатньою кількістю даних або "
"якщо операція не підтримується поточним методом RAND. :func:`RAND_status` "
"можна використовувати для перевірки статусу PRNG, а :func:`RAND_add` можна "
"використовувати для заповнення PRNG."

msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "Майже для всіх програм :func:`os.urandom` є кращим."

msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Прочитайте статтю Вікіпедії `Криптографічно захищений генератор "
"псевдовипадкових чисел (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, щоб дізнатися про "
"вимоги до криптографічно надійного генератора."

msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the "
"current RAND method."
msgstr ""
"Повернення (байти, is_cryptographic): байти — це *кількість* "
"псевдовипадкових байтів, is_cryptographic має значення ``True``, якщо "
"згенеровані байти є криптографічно надійними. Викликає :class:`SSLError`, "
"якщо операція не підтримується поточним методом RAND."

msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""
"Згенеровані псевдовипадкові послідовності байтів будуть унікальними, якщо "
"вони мають достатню довжину, але не обов’язково є непередбачуваними. Їх "
"можна використовувати для некриптографічних цілей і для певних цілей у "
"криптографічних протоколах, але зазвичай не для генерації ключів тощо."

msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use :func:`ssl."
"RAND_bytes` instead."
msgstr ""
"OpenSSL застарів :func:`ssl.RAND_pseudo_bytes`, замість нього "
"використовуйте :func:`ssl.RAND_bytes`."

msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Повертає ``True``, якщо генератор псевдовипадкових чисел SSL заповнено "
"достатньою випадковістю, і ``False`` в іншому випадку. Ви можете "
"використовувати :func:`ssl.RAND_egd` і :func:`ssl.RAND_add`, щоб збільшити "
"випадковість генератора псевдовипадкових чисел."

msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Змішайте надані *байти* в генераторі псевдовипадкових чисел SSL. Параметр "
"*entropy* (float) є нижньою межею ентропії, яка міститься в рядку (тому ви "
"завжди можете використовувати :const:`0.0`). Перегляньте :rfc:`1750` для "
"отримання додаткової інформації про джерела ентропії."

msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Записуваний :term:`bytes-like object` тепер приймається."

msgid "Certificate handling"
msgstr "Обробка сертифікатів"

msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, :rfc:"
"`5280` and :rfc:`6125`.  In addition to HTTPS, this function should be "
"suitable for checking the identity of servers in various SSL-based protocols "
"such as FTPS, IMAPS, POPS and others."
msgstr ""
"Переконайтеся, що *cert* (у декодованому форматі, який повертає :meth:"
"`SSLSocket.getpeercert`) відповідає заданому *назві хосту*. Застосовуються "
"правила для перевірки ідентичності серверів HTTPS, як описано в :rfc:"
"`2818`, :rfc:`5280` та :rfc:`6125`. Окрім HTTPS, ця функція має бути "
"придатною для перевірки ідентичності серверів у різних протоколах на основі "
"SSL, таких як FTPS, IMAPS, POPS та інші."

msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""
":exc:`CertificateError` виникає в разі помилки. У разі успіху функція нічого "
"не повертає::"

msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"Функція тепер відповідає :rfc:`6125`, розділ 6.4.3, і не відповідає ні "
"кільком символам підстановки (наприклад, ``*.*.com`` або ``*a*.example."
"org``), ні символу підстановки всередині фрагмент інтернаціоналізованих "
"доменних імен (IDN). А-мітки IDN, такі як ``www*.xn--pthon-kva.org``, як і "
"раніше підтримуються, але ``x*.python.org`` більше не відповідає ``xn--tda."
"python.org``."

msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr ""
"Тепер підтримується зіставлення IP-адрес, якщо вони присутні в полі "
"subjectAltName сертифіката."

msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""
"Ця функція більше не використовується для підключень TLS. Зіставлення імен "
"хостів тепер виконує OpenSSL."

msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer supported."
msgstr ""
"Дозволити підстановку, якщо це крайній лівий і єдиний символ у сегменті. "
"Часткові символи узагальнення, наприклад ``www*.example.com`` більше не "
"підтримуються."

msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Повертає час у секундах з епохи, враховуючи рядок ``cert_time``, що "
"представляє дату \"notBefore\" або \"notAfter\" із сертифіката в ``\"%b %d "
"%H:%M:%S %Y %Z\"`` формат strptime (C локаль)."

msgid "Here's an example:"
msgstr "Ось приклад:"

msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr ""
"Дати \"notBefore\" або \"notAfter\" мають використовувати GMT (:rfc:`5280`)."

msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Інтерпретуйте введений час як час у UTC, як зазначено часовим поясом \"GMT\" "
"у вхідному рядку. Раніше використовувався місцевий часовий пояс. Повертає "
"ціле число (без часток секунди у форматі введення)"

msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :meth:`SSLContext."
"wrap_socket`.  The call will attempt to validate the server certificate "
"against that set of root certificates, and will fail if the validation "
"attempt fails.  A timeout can be specified with the ``timeout`` parameter."
msgstr ""
"Враховуючи адресу ``addr`` сервера, захищеного SSL, у вигляді пари (*ім’я "
"хоста*, *номер порту*) отримує сертифікат сервера та повертає його як рядок, "
"закодований PEM. Якщо вказано ``ssl_version``, використовується ця версія "
"протоколу SSL для спроби підключитися до сервера. Якщо вказано ``ca_certs``, "
"це має бути файл, що містить список кореневих сертифікатів, у тому самому "
"форматі, який використовується для того самого параметра в :meth:`SSLContext."
"wrap_socket`. Виклик спробує перевірити сертифікат сервера на відповідність "
"цьому набору кореневих сертифікатів і завершиться невдачею, якщо спроба "
"перевірки не вдасться. Тайм-аут можна вказати за допомогою параметра "
"``timeout``."

msgid "This function is now IPv6-compatible."
msgstr "Тепер ця функція сумісна з IPv6."

msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"Стандартну *ssl_version* змінено з :data:`PROTOCOL_SSLv3` на :data:"
"`PROTOCOL_TLS` для максимальної сумісності з сучасними серверами."

msgid "The *timeout* parameter was added."
msgstr "Додано параметр *timeout*."

msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Надано сертифікат як DER-кодований блок байтів, повертає PEM-кодовану "
"рядкову версію того самого сертифіката."

msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Надано сертифікат як рядок ASCII PEM, повертає закодовану DER послідовність "
"байтів для того самого сертифіката."

msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Повертає іменований кортеж із шляхами до cafile і capath OpenSSL за "
"замовчуванням. Шляхи такі самі, як і :meth:`SSLContext."
"set_default_verify_paths`. Поверненим значенням є :term:`named tuple` "
"``DefaultVerifyPaths``:"

msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - визначений шлях до cafile або ``None``, якщо файл не існує,"

msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - дозволений шлях до capath або ``None``, якщо каталог не "
"існує,"

msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - ключ середовища OpenSSL, який вказує на cafile,"

msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - жорстко закодований шлях до cafile,"

msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - ключ середовища OpenSSL, який вказує на capath,"

msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - жорстко закодований шлях до каталогу capath"

msgid ""
":ref:`Availability <availability>`: LibreSSL ignores the environment vars :"
"attr:`openssl_cafile_env` and :attr:`openssl_capath_env`."
msgstr ""
":ref:`Доступність <availability>`: LibreSSL ігнорує змінні середовища :attr:"
"`openssl_cafile_env` і :attr:`openssl_capath_env`."

msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Отримати сертифікати зі сховища сертифікатів системи Windows. *store_name* "
"може бути одним із ``CA``, ``ROOT`` або ``MY``. Windows також може надавати "
"додаткові сховища сертифікатів."

msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"Функція повертає список кортежів (cert_bytes, encoding_type, trust). "
"Encoding_type визначає кодування cert_bytes. Це або :const:`x509_asn` для "
"даних X.509 ASN.1, або :const:`pkcs_7_asn` для даних PKCS#7 ASN.1. Trust "
"визначає призначення сертифіката як набір OIDS або точно ``True``, якщо "
"сертифікат є надійним для всіх цілей."

msgid "Example::"
msgstr "Приклад::"

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Отримати CRL із сховища системних сертифікатів Windows. *store_name* може "
"бути одним із ``CA``, ``ROOT`` або ``MY``. Windows також може надавати "
"додаткові сховища сертифікатів."

msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"Функція повертає список кортежів (cert_bytes, encoding_type, trust). "
"Encoding_type визначає кодування cert_bytes. Це або :const:`x509_asn` для "
"даних X.509 ASN.1, або :const:`pkcs_7_asn` для даних PKCS#7 ASN.1."

msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a :"
"data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Бере екземпляр ``sock`` :class:`socket.socket` і повертає екземпляр :class:"
"`ssl.SSLSocket`, підтип :class:`socket.socket`, який обертає основний сокет "
"у контекст SSL. ``sock`` має бути :data:`~socket.SOCK_STREAM` сокетом; інші "
"типи сокетів не підтримуються."

msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations`, and :meth:`SSLContext.set_ciphers`."
msgstr ""
"Внутрішньо функція створює :class:`SSLContext` із протоколом *ssl_version* "
"і :attr:`SSSLContext.options` зі значенням *cert_reqs*. Якщо встановлено "
"параметри *keyfile*, *certfile*, *ca_certs* або *ciphers*, тоді значення "
"передаються до :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations` і :meth:`SSLContext .set_ciphers`."

msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as :meth:`SSLContext."
"wrap_socket`."
msgstr ""
"Аргументи *server_side*, *do_handshake_on_connect* і *suppress_ragged_eofs* "
"мають те саме значення, що й :meth:`SSLContext.wrap_socket`."

msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` instead of :func:`wrap_socket`. The top-level function is "
"limited and creates an insecure client socket without server name indication "
"or hostname matching."
msgstr ""
"Починаючи з Python 3.2 і 2.7.9, рекомендується використовувати :meth:"
"`SSLContext.wrap_socket` замість :func:`wrap_socket`. Функція верхнього "
"рівня обмежена та створює незахищений клієнтський сокет без індикації імені "
"сервера або відповідності імені хоста."

msgid "Constants"
msgstr "Константи"

msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Усі константи тепер є колекціями :class:`enum.IntEnum` або :class:`enum."
"IntFlag`."

msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored "
"and do not abort the TLS/SSL handshake."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_mode` або параметра "
"``cert_reqs`` для :func:`wrap_socket`. За винятком :const:"
"`PROTOCOL_TLS_CLIENT`, це режим за замовчуванням. З сокетами на стороні "
"клієнта приймаються майже будь-які сертифікати. Помилки перевірки, такі як "
"ненадійний або прострочений сертифікат, ігноруються та не переривають "
"рукостискання TLS/SSL."

msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"У режимі сервера від клієнта не запитується сертифікат, тому клієнт не "
"надсилає жодного сертифіката для автентифікації клієнта."

msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Дивіться обговорення :ref:`ssl-security` нижче."

msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use :"
"const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_mode` або параметра "
"``cert_reqs`` для :func:`wrap_socket`. У режимі клієнта :const:"
"`CERT_OPTIONAL` має те саме значення, що і :const:`CERT_REQUIRED`. "
"Рекомендується використовувати :const:`CERT_REQUIRED` для клієнтських "
"сокетів."

msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"У режимі сервера клієнту надсилається запит на сертифікат клієнта. Клієнт "
"може або проігнорувати запит, або надіслати сертифікат, щоб виконати "
"автентифікацію клієнта за допомогою TLS. Якщо клієнт вирішує надіслати "
"сертифікат, він перевіряється. Будь-яка помилка перевірки негайно перериває "
"рукостискання TLS."

msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"Для використання цього параметра потрібен дійсний набір сертифікатів ЦС у :"
"meth:`SSLContext.load_verify_locations` або як значення параметра "
"``ca_certs`` у :func:`wrap_socket`."

msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well "
"to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses :"
"const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_mode` або параметра "
"``cert_reqs`` для :func:`wrap_socket`. У цьому режимі потрібні сертифікати з "
"іншого боку сокет-з’єднання; :class:`SSLError` буде викликано, якщо "
"сертифікат не надано, або якщо його перевірка не вдається. Цього режиму "
"**не** достатньо для перевірки сертифіката в режимі клієнта, оскільки він не "
"відповідає іменам хостів. :attr:`~SSLContext.check_hostname` також має бути "
"ввімкнено, щоб перевірити автентичність сертифіката. :const:"
"`PROTOCOL_TLS_CLIENT` використовує :const:`CERT_REQUIRED` і вмикає :attr:"
"`~SSLContext.check_hostname` за умовчанням."

msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"З серверним сокетом цей режим забезпечує обов’язкову автентифікацію клієнта "
"за допомогою TLS. Запит на сертифікат клієнта надсилається клієнту, і клієнт "
"повинен надати дійсний і надійний сертифікат."

msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` колекція констант CERT_*."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. У цьому режимі списки "
"відкликаних сертифікатів (CRL) не перевіряються. За замовчуванням OpenSSL не "
"вимагає і не перевіряє CRL."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. У цьому режимі "
"перевіряється лише одноранговий сертифікат, але не перевіряються проміжні "
"сертифікати ЦС. Для режиму потрібен дійсний CRL, підписаний видавцем "
"однорангового сертифіката (його прямим предком CA). Якщо не було завантажено "
"відповідний CRL з :attr:`SSLContext.load_verify_locations`, перевірка не "
"вдасться."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. У цьому режимі "
"перевіряються CRL усіх сертифікатів у ланцюжку однорангових сертифікатів."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags` для вимкнення обхідних "
"шляхів для пошкоджених сертифікатів X.509."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags` для ввімкнення "
"перевірки сертифіката проксі."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. Він наказує OpenSSL "
"віддавати перевагу надійним сертифікатам під час побудови ланцюжка довіри "
"для перевірки сертифіката. Цей прапорець увімкнено за замовчуванням."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. Він наказує OpenSSL "
"приймати проміжні ЦС у довірчому сховищі, щоб вони розглядалися як прив’язки "
"довіри, так само, як і самопідписані кореневі сертифікати ЦС. Це дає змогу "
"довіряти сертифікатам, виданим проміжним ЦС, не довіряючи кореневому ЦС "
"предка."

msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` колекція констант VERIFY_*."

msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Вибирає найвищу версію протоколу, яку підтримують як клієнт, так і сервер. "
"Незважаючи на назву, ця опція може вибрати як протоколи \"SSL\", так і "
"\"TLS\"."

msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Клієнтам і серверам TLS потрібні різні параметри за замовчуванням для "
"безпечного зв’язку. Загальна константа протоколу TLS застаріла на користь :"
"data:`PROTOCOL_TLS_CLIENT` і :data:`PROTOCOL_TLS_SERVER`."

msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Автоматичне узгодження найвищої версії протоколу, яку підтримують як клієнт, "
"так і сервер, і налаштування контекстних підключень на стороні клієнта. "
"Протокол вмикає :data:`CERT_REQUIRED` і :attr:`~SSSLContext.check_hostname` "
"за умовчанням."

msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""
"Автоматичне узгодження найвищої версії протоколу, яку підтримують як клієнт, "
"так і сервер, і налаштування контекстних підключень на стороні сервера."

msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Псевдонім для :data:`PROTOCOL_TLS`."

msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Натомість використовуйте :data:`PROTOCOL_TLS`."

msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "Вибирає SSL версії 2 як протокол шифрування каналу."

msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl2`` "
"option."
msgstr ""
"Цей протокол недоступний, якщо OpenSSL скомпільовано з опцією ``no-ssl2``."

msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL версії 2 небезпечний. Його використання вкрай не рекомендується."

msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL припиняє підтримку SSLv2."

msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Вибирає SSL версії 3 як протокол шифрування каналу."

msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr ""
"Цей протокол недоступний, якщо OpenSSL скомпільовано з опцією ``no-ssl3``."

msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL версії 3 небезпечний. Його використання вкрай не рекомендується."

msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL не підтримує всі протоколи для окремих версій. Замість цього "
"використовуйте протокол за замовчуванням :data:`PROTOCOL_TLS_SERVER` або :"
"data:`PROTOCOL_TLS_CLIENT` з :attr:`SSLContext.minimum_version` і :attr:"
"`SSLContext.maximum_version`."

msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Вибирає TLS версії 1.0 як протокол шифрування каналу."

msgid "OpenSSL has deprecated all version specific protocols."
msgstr "OpenSSL не підтримує всі протоколи для окремих версій."

msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Вибирає TLS версії 1.1 як протокол шифрування каналу. Доступно лише з "
"openssl версії 1.0.1+."

msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Вибирає TLS версії 1.2 як протокол шифрування каналу. Доступно лише з "
"openssl версії 1.0.1+."

msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Дозволяє обійти різні помилки, наявні в інших реалізаціях SSL. Ця опція "
"встановлена за замовчуванням. Він не обов’язково встановлює ті самі "
"позначки, що й константа ``SSL_OP_ALL`` OpenSSL."

msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Запобігає підключенню SSLv2. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами SSLv2 як "
"версії протоколу."

msgid "SSLv2 is deprecated"
msgstr "SSLv2 застарів"

msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Запобігає підключенню SSLv3. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами SSLv3 як "
"версії протоколу."

msgid "SSLv3 is deprecated"
msgstr "SSLv3 застарів"

msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Запобігає підключенню TLSv1. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору партнерами TLSv1 як версії "
"протоколу."

msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"Опція застаріла з OpenSSL 1.1.0, замість неї використовуйте нові :attr:"
"`SSLContext.minimum_version` і :attr:`SSSLContext.maximum_version`."

msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Запобігає підключенню TLSv1.1. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами TLSv1.1 як "
"версії протоколу. Доступно лише з openssl версії 1.0.1+."

msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Опція застаріла з OpenSSL 1.1.0."

msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Запобігає підключенню TLSv1.2. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами TLSv1.2 як "
"версії протоколу. Доступно лише з openssl версії 1.0.1+."

msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Запобігає підключенню TLSv1.3. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами TLSv1.3 як "
"версії протоколу. TLS 1.3 доступний з OpenSSL 1.1.1 або новішої версії. Якщо "
"Python скомпільовано зі старішою версією OpenSSL, прапорець за замовчуванням "
"має значення *0*."

msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"Опція застаріла з OpenSSL 1.1.0. Він був доданий до 2.7.15, 3.6.3 і 3.7.0 "
"для зворотної сумісності з OpenSSL 1.0.2."

msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Вимкніть усі повторні узгодження в TLSv1.2 і попередніх версіях. Не "
"надсилайте повідомлення HelloRequest і ігноруйте запити на повторне "
"узгодження через ClientHello."

msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Ця опція доступна лише для OpenSSL 1.1.0h і пізніших версій."

msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Використовуйте параметри впорядкування шифрів сервера, а не клієнта. Цей "
"параметр не впливає на клієнтські сокети та серверні сокети SSLv2."

msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""
"Запобігає повторному використанню того самого ключа DH для різних сеансів "
"SSL. Це покращує пряму секретність, але вимагає більше обчислювальних "
"ресурсів. Цей параметр стосується лише серверних сокетів."

msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"Запобігає повторному використанню того самого ключа ECDH для різних сеансів "
"SSL. Це покращує пряму секретність, але вимагає більше обчислювальних "
"ресурсів. Цей параметр стосується лише серверних сокетів."

msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Надсилайте фіктивні повідомлення про зміну шифру (CCS) у рукостисканні TLS "
"1.3, щоб зробити з’єднання TLS 1.3 більш схожим на з’єднання TLS 1.2."

msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Ця опція доступна лише з OpenSSL 1.1.1 і новіших версій."

msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Вимкніть стиснення на каналі SSL. Це корисно, якщо протокол програми "
"підтримує власну схему стиснення."

msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` колекція констант OP_*."

msgid "Prevent client side from requesting a session ticket."
msgstr "Заборонити стороні клієнта запитувати квиток сеансу."

msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Ігноруйте несподіване завершення з’єднань TLS."

msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Цей параметр доступний лише з OpenSSL 3.0.0 і пізніших версій."

msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку розширення TLS *Application-"
"Layer Protocol Negotiation*, як описано в :rfc:`7301`."

msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку, яка не перевіряє загальне "
"ім’я суб’єкта та :attr:`SSLContext.hostname_checks_common_name`, доступний "
"для запису."

msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку для обміну ключами Діффі-"
"Хеллмана на основі еліптичної кривої. Це має бути правдою, якщо цю функцію "
"явно не вимкнув розповсюджувач."

msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку розширення *Індикація імені "
"сервера* (як визначено в :rfc:`6066`)."

msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку *Узгодження наступного "
"протоколу*, як описано в розділі `Узгодження протоколу прикладного рівня "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Якщо значення true, ви можете використовувати метод :meth:`SSLContext."
"set_npn_protocols`, щоб повідомити, які протоколи ви хочете підтримувати."

msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "Чи бібліотека OpenSSL має вбудовану підтримку протоколу SSL 2.0."

msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "Чи має бібліотека OpenSSL вбудовану підтримку протоколу SSL 3.0."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "Чи бібліотека OpenSSL має вбудовану підтримку протоколу TLS 1.0."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "Чи має бібліотека OpenSSL вбудовану підтримку протоколу TLS 1.1."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "Чи бібліотека OpenSSL має вбудовану підтримку протоколу TLS 1.2."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "Чи має бібліотека OpenSSL вбудовану підтримку протоколу TLS 1.3."

msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Список підтримуваних типів прив’язки каналу TLS. Рядки в цьому списку можна "
"використовувати як аргументи для :meth:`SSLSocket.get_channel_binding`."

msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "Рядок версії бібліотеки OpenSSL, завантажений інтерпретатором::"

msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"Кортеж із п’яти цілих чисел, що представляє інформацію про версію бібліотеки "
"OpenSSL::"

msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""
"Необроблений номер версії бібліотеки OpenSSL у вигляді одного цілого числа::"

msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Описи сповіщень від :rfc:`5246` та інших. `Реєстр сповіщень IANA TLS "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ містить цей список і посилання на RFC, де визначено їх "
"значення."

msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Використовується як значення, що повертається функцією зворотного виклику в :"
"meth:`SSLContext.set_servername_callback`."

msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` колекція констант ALERT_DESCRIPTION_*."

msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
"Опція для :func:`create_default_context` і :meth:`SSLContext."
"load_default_certs`. Це значення вказує на те, що контекст можна "
"використовувати для автентифікації веб-серверів (отже, він "
"використовуватиметься для створення сокетів на стороні клієнта)."

msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
"Опція для :func:`create_default_context` і :meth:`SSLContext."
"load_default_certs`. Це значення вказує на те, що контекст можна "
"використовувати для автентифікації веб-клієнтів (отже, він "
"використовуватиметься для створення сокетів на стороні сервера)."

msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` колекція констант SSL_ERROR_*."

msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` колекція версій SSL і TLS для :attr:`SSLContext."
"maximum_version` і :attr:`SSLContext.minimum_version`."

msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"Мінімальна або максимальна підтримувана версія SSL або TLS. Це магічні "
"константи. Їх значення не відображають найнижчу та найвищу доступні версії "
"TLS/SSL."

msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 до TLS 1.3."

msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"Усі члени :class:`TLSVersion`, крім :attr:`TLSVersion.TLSv1_2` і :attr:"
"`TLSVersion.TLSv1_3`, застаріли."

msgid "SSL Sockets"
msgstr "SSL-сокети"

msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL-сокети надають такі методи :ref:`socket-objects`:"

msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"

msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (але "
"передача ненульового аргументу ``flags`` заборонена)"

msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (з тим самим "
"обмеженням)"

msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (але :mod:`os.sendfile` "
"використовуватиметься лише для простих текстових сокетів, інакше "
"використовуватиметься :meth:`~socket.socket.send()` )"

msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Однак, оскільки протокол SSL (і TLS) має власне фреймування поверх TCP, "
"абстракція сокетів SSL може в певних аспектах відрізнятися від специфікації "
"звичайних сокетів рівня ОС. Особливо дивіться :ref:`примітки щодо "
"неблокуючих сокетів <ssl-nonblocking>`."

msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Примірники :class:`SSLSocket` повинні бути створені за допомогою методу :"
"meth:`SSSLContext.wrap_socket`."

msgid "The :meth:`sendfile` method was added."
msgstr "Додано метод :meth:`sendfile`."

msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now to maximum total duration of the "
"shutdown."
msgstr ""
":meth:`shutdown` не скидає тайм-аут сокета кожного разу, коли байти "
"надходять або надсилаються. Час очікування сокета тепер становить "
"максимальну загальну тривалість вимкнення."

msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Безпосереднє створення екземпляра :class:`SSLSocket` є застарілим, "
"використовуйте :meth:`SSSLContext.wrap_socket` для упаковки сокета."

msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
":class:`SSLSocket` екземпляри повинні бути створені за допомогою :meth:"
"`~SSSLContext.wrap_socket`. У попередніх версіях можна було створювати "
"екземпляри безпосередньо. Це ніколи не було задокументовано чи офіційно "
"підтверджено."

msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""
"Тепер Python внутрішньо використовує ``SSL_read_ex`` і ``SSL_write_ex``. "
"Функції підтримують читання та запис даних розміром понад 2 ГБ. Запис даних "
"нульової довжини більше не завершується помилкою порушення протоколу."

msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL-сокети також мають такі додаткові методи та атрибути:"

msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Читайте до *len* байтів даних із SSL-сокета та повертайте результат як "
"екземпляр ``bytes``. Якщо вказано *buffer*, то замість цього зчитується в "
"буфер і повертається кількість прочитаних байтів."

msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Викликайте :exc:`SSLWantReadError` або :exc:`SSLWantWriteError`, якщо сокет :"
"ref:`неблокує <ssl-nonblocking>`, і читання буде заблоковано."

msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Оскільки в будь-який час можливе повторне узгодження, виклик :meth:`read` "
"також може викликати операції запису."

msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to read up to *len* "
"bytes."
msgstr ""
"Тайм-аут сокета більше не скидається щоразу, коли байти надходять або "
"надсилаються. Час очікування сокета тепер становить максимальну загальну "
"тривалість для читання до *len* байтів."

msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr ""
"Використовуйте :meth:`~SSLSocket.recv` замість :meth:`~SSLSocket.read`."

msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Запишіть *buf* у SSL-сокет і поверніть кількість записаних байтів. Аргумент "
"*buf* має бути об’єктом, що підтримує інтерфейс буфера."

msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Викликайте :exc:`SSLWantReadError` або :exc:`SSLWantWriteError`, якщо сокет :"
"ref:`неблокує <ssl-nonblocking>`, і запис буде заблоковано."

msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Оскільки в будь-який час можливе повторне узгодження, виклик :meth:`write` "
"також може викликати операції читання."

msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to write *buf*."
msgstr ""
"Тайм-аут сокета більше не скидається щоразу, коли байти надходять або "
"надсилаються. Час очікування сокета тепер досяг максимальної загальної "
"тривалості для запису *buf*."

msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr ""
"Використовуйте :meth:`~SSLSocket.send` замість :meth:`~SSLSocket.write`."

msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Методи :meth:`~SSLSocket.read` і :meth:`~SSLSocket.write` є низькорівневими "
"методами, які читають і записують незашифровані дані на рівні програми та "
"розшифровують/шифрують їх у зашифровані дані на рівні проводів. Для цих "
"методів потрібне активне з’єднання SSL, тобто рукостискання завершено і :"
"meth:`SSLSocket.unwrap` не викликано."

msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Зазвичай замість цих методів слід використовувати такі методи API сокетів, "
"як :meth:`~socket.socket.recv` і :meth:`~socket.socket.send`."

msgid "Perform the SSL setup handshake."
msgstr "Виконайте рукостискання налаштування SSL."

msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"Метод рукостискання також виконує :func:`match_hostname`, якщо атрибут :attr:"
"`~SSLContext.check_hostname` :attr:`~SSLSocket.context` сокета має значення "
"true."

msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration of the handshake."
msgstr ""
"Тайм-аут сокета більше не скидається щоразу, коли байти надходять або "
"надсилаються. Час очікування сокета тепер становить максимальну загальну "
"тривалість рукостискання."

msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"send to the peer."
msgstr ""
"Ім’я хоста або IP-адреса збігається з OpenSSL під час рукостискання. "
"Функція :func:`match_hostname` більше не використовується. Якщо OpenSSL "
"відмовляється надати ім’я хоста чи IP-адресу, рукостискання припиняється "
"достроково, а однорангові надсилається попереджувальне повідомлення TLS."

msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Якщо немає сертифіката для вузла на іншому кінці з’єднання, поверніть "
"``None``. Якщо SSL-рукостискання ще не виконано, підніміть :exc:`ValueError`."

msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Якщо параметр ``binary_form`` має значення :const:`False`, а сертифікат "
"отримано від однорангового пристрою, цей метод повертає екземпляр :class:"
"`dict`. Якщо сертифікат не підтверджено, dict порожній. Якщо сертифікат "
"перевірено, він повертає dict із кількома ключами, серед яких ``subject`` "
"(принципал, для якого видано сертифікат) і ``issuer`` (принципал, який видає "
"сертифікат). Якщо сертифікат містить примірник розширення *Subject "
"Alternative Name* (див. :rfc:`3280`), у словнику також буде ключ "
"``subjectAltName``."

msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Поля ``subject`` і ``issuer`` — це кортежі, що містять послідовність "
"відносних розрізняючих імен (RDN), наведених у структурі даних сертифіката "
"для відповідних полів, і кожен RDN є послідовністю пар ім’я-значення. Ось "
"реальний приклад:"

msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr ""
"Щоб перевірити сертифікат для певної служби, ви можете скористатися "
"функцією :func:`match_hostname`."

msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Якщо параметр ``binary_form`` має значення :const:`True` і надано "
"сертифікат, цей метод повертає закодовану DER форму всього сертифіката у "
"вигляді послідовності байтів або :const:`None`, якщо одноранговий сертифікат "
"не надав. Чи надає партнер сертифікат, залежить від ролі SSL-сокета:"

msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"для клієнтського SSL-сокета сервер завжди надаватиме сертифікат, незалежно "
"від того, чи була потрібна перевірка;"

msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"для серверного SSL-сокета клієнт надасть сертифікат лише за запитом сервера; "
"тому :meth:`getpeercert` поверне :const:`None`, якщо ви використали :const:"
"`CERT_NONE` (а не :const:`CERT_OPTIONAL` або :const:`CERT_REQUIRED`)."

msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"Повернений словник містить додаткові елементи, такі як ``issuer`` і "
"``notBefore``."

msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` виникає, коли рукостискання не виконано. Повернений "
"словник містить додаткові елементи розширення X509v3, такі як "
"``crlDistributionPoints``, ``caIssuers`` і ``OCSP`` URI."

msgid "IPv6 address strings no longer have a trailing new line."
msgstr "Рядки адрес IPv6 більше не мають кінцевого нового рядка."

msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Повертає кортеж із трьох значень, що містить назву шифру, який "
"використовується, версію протоколу SSL, яка визначає його використання, і "
"кількість секретних бітів, які використовуються. Якщо з’єднання не "
"встановлено, повертає ``None``."

msgid ""
"Return the list of ciphers shared by the client during the handshake.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"Повертає список шифрів, наданих клієнтом під час рукостискання. Кожен запис "
"повернутого списку є кортежем із трьох значень, що містить назву шифру, "
"версію протоколу SSL, яка визначає його використання, і кількість секретних "
"бітів, які використовує шифр. :meth:`~SSLSocket.shared_ciphers` повертає "
"``None``, якщо з’єднання не встановлено або сокет є клієнтським."

msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Повертає використаний алгоритм стиснення у вигляді рядка або ``None``, якщо "
"з'єднання не стиснуте."

msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Якщо протокол вищого рівня підтримує власний механізм стиснення, ви можете "
"використовувати :data:`OP_NO_COMPRESSION`, щоб вимкнути стиснення на рівні "
"SSL."

msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Отримайте дані прив’язки каналу для поточного з’єднання як об’єкт bytes. "
"Повертає ``None``, якщо немає підключення або рукостискання не було "
"завершено."

msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"Параметр *cb_type* дозволяє вибрати потрібний тип прив’язки каналу. Дійсні "
"типи зв’язування каналів наведено в списку :data:`CHANNEL_BINDING_TYPES`. "
"Наразі підтримується лише прив’язка каналу \"tls-unique\", визначена :rfc:"
"`5929`. :exc:`ValueError` буде викликано, якщо запитується непідтримуваний "
"тип прив’язки каналу."

msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Повернути протокол, вибраний під час рукостискання TLS. Якщо :meth:"
"`SSLContext.set_alpn_protocols` не було викликано, якщо інша сторона не "
"підтримує ALPN, якщо цей сокет не підтримує жодного із запропонованих "
"клієнтом протоколів або якщо рукостискання ще не відбулося, ``None`` буде "
"повернувся."

msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Повернути протокол вищого рівня, вибраний під час рукостискання TLS/SSL. "
"Якщо :meth:`SSLContext.set_npn_protocols` не було викликано, або якщо інша "
"сторона не підтримує NPN, або якщо рукостискання ще не відбулося, це поверне "
"``None``."

msgid "NPN has been superseded by ALPN"
msgstr "NPN було замінено на ALPN"

msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Виконує рукостискання завершення роботи SSL, яке видаляє рівень TLS із "
"базового сокета та повертає базовий об’єкт сокета. Це можна використовувати "
"для переходу від зашифрованої операції через з’єднання до незашифрованої. "
"Повернений сокет завжди слід використовувати для подальшого зв’язку з іншою "
"стороною з’єднання, а не оригінальний сокет."

msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Запитує автентифікацію після рукостискання (PHA) від клієнта TLS 1.3. PHA "
"можна ініціювати лише для з’єднання TLS 1.3 із сокета на стороні сервера "
"після початкового рукостискання TLS і з увімкненим PHA з обох сторін, див. :"
"attr:`SSLContext.post_handshake_auth`."

msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"Метод не виконує обмін сертифікатами негайно. Сторона сервера надсилає "
"CertificateRequest під час наступної події запису та очікує, що клієнт "
"відповість сертифікатом під час наступної події читання."

msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Якщо будь-яка передумова не виконується (наприклад, не TLS 1.3, PHA не "
"ввімкнено), виникає :exc:`SSLError`."

msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Доступно лише з увімкненими OpenSSL 1.1.1 і TLS 1.3. Без підтримки TLS 1.3 "
"метод викликає :exc:`NotImplementedError`."

msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Повертає фактичну версію протоколу SSL, узгоджену з’єднанням, у вигляді "
"рядка або \"Немає\", якщо безпечне з’єднання не встановлено. На момент "
"написання цієї статті можливі значення, що повертаються, включають "
"``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` і "
"``\"TLSv1.2\"``. Останні версії OpenSSL можуть визначати більше значень, що "
"повертаються."

msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Повертає кількість уже розшифрованих байтів, доступних для читання, які "
"очікують підключення."

msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""
"Об’єкт :class:`SSLContext`, до якого прив’язаний цей SSL-сокет. Якщо SSL-"
"сокет було створено за допомогою застарілої функції :func:`wrap_socket` (а "
"не :meth:`SSSLContext.wrap_socket`), це спеціальний контекстний об’єкт, "
"створений для цього SSL-сокета."

msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"Логічне значення, яке має значення ``True`` для сокетів на стороні сервера "
"та ``False`` для сокетів на стороні клієнта."

msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Ім’я хоста сервера: тип :class:`str` або ``None`` для серверного сокета або "
"якщо ім’я хосту не було вказано в конструкторі."

msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"Тепер атрибут завжди є текстом ASCII. Якщо ``server_hostname`` є "
"інтернаціоналізованим доменним іменем (IDN), цей атрибут тепер зберігає "
"форму A-мітки (``\"xn--pythn-mua.org\"``), а не форму U-мітки (``\"pythön."
"org\"``)."

msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
":class:`SSLSession` для цього з’єднання SSL. Сеанс доступний для сокетів на "
"стороні клієнта та сервера після того, як було виконано рукостискання TLS. "
"Для клієнтських сокетів сеанс можна встановити до виклику :meth:`~SSLSocket."
"do_handshake` для повторного використання сеансу."

msgid "SSL Contexts"
msgstr "Контексти SSL"

msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"Контекст SSL зберігає різноманітні дані, які живуть довше, ніж окремі "
"з’єднання SSL, наприклад параметри конфігурації SSL, сертифікат(и) і "
"закритий ключ(и). Він також керує кеш-пам’яттю сеансів SSL для сокетів на "
"стороні сервера, щоб пришвидшити повторювані підключення від тих самих "
"клієнтів."

msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Створіть новий контекст SSL. Ви можете передати *протокол*, який має бути "
"однією з констант ``PROTOCOL_*``, визначених у цьому модулі. Параметр "
"визначає, яку версію протоколу SSL використовувати. Як правило, сервер "
"вибирає певну версію протоколу, а клієнт повинен адаптуватися до вибору "
"сервера. Більшість версій не сумісні з іншими версіями. Якщо не вказано, "
"типовим є :data:`PROTOCOL_TLS`; він забезпечує найбільшу сумісність з іншими "
"версіями."

msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Ось таблиця, яка показує, які версії клієнта (збоку) можуть підключатися до "
"яких версій на сервері (вгорі):"

msgid "*client* / **server**"
msgstr "*клієнт* / **сервер**"

msgid "**SSLv2**"
msgstr "**SSLv2**"

msgid "**SSLv3**"
msgstr "**SSLv3**"

msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

msgid "**TLSv1**"
msgstr "**TLSv1**"

msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

msgid "*SSLv2*"
msgstr "*SSLv2*"

msgid "yes"
msgstr "так"

msgid "no"
msgstr "ні"

msgid "no [1]_"
msgstr "ні [1]_"

msgid "*SSLv3*"
msgstr "*SSLv3*"

msgid "no [2]_"
msgstr "ні [2]_"

msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

msgid "*TLSv1*"
msgstr "*TLSv1*"

msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

msgid "Footnotes"
msgstr "Виноски"

msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` вимикає SSLv2 за допомогою :data:`OP_NO_SSLv2` за "
"замовчуванням."

msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` вимикає SSLv3 за допомогою :data:`OP_NO_SSLv3` за "
"замовчуванням."

msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"Протокол TLS 1.3 буде доступний із :data:`PROTOCOL_TLS` у OpenSSL >= 1.1.1. "
"Немає виділеної константи PROTOCOL лише для TLS 1.3."

msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` дозволяє модулю :mod:`ssl` вибрати параметри "
"безпеки для певної мети."

msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (except "
"for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for :data:"
"`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list contains "
"only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers (except "
"for :data:`PROTOCOL_SSLv2`)."
msgstr ""
"Контекст створюється із безпечними значеннями за замовчуванням. Параметри :"
"data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (крім :"
"data:`PROTOCOL_SSLv2`) і :data:`OP_NO_SSLv3` (крім :data:`PROTOCOL_SSLv3`) "
"встановлено за замовчуванням. Початковий список набору шифрів містить лише "
"шифри ``HIGH``, шифри ``NULL`` і шифри ``MD5`` (крім :data:`PROTOCOL_SSLv2`)."

msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` без аргументу протоколу застаріло. У майбутньому клас "
"контексту потребуватиме протоколу :data:`PROTOCOL_TLS_CLIENT` або :data:"
"`PROTOCOL_TLS_SERVER`."

msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""
"Набір шифрів за замовчуванням тепер включає лише захищені шифри AES і "
"ChaCha20 із прямою секретністю та рівнем безпеки 2. Ключі RSA та DH із менш "
"ніж 2048 бітами та ключі ECC із менш ніж 224 бітами заборонені. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT` і :data:`PROTOCOL_TLS_SERVER` "
"використовують TLS 1.2 як мінімальну версію TLS."

msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` об’єкти мають такі методи та атрибути:"

msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"Отримайте статистичні дані про кількість завантажених сертифікатів X.509, "
"кількість сертифікатів X.509, позначених як сертифікати ЦС, і списки "
"відкликаних сертифікатів як словник."

msgid "Example for a context with one CA cert and one other cert::"
msgstr ""
"Приклад для контексту з одним сертифікатом CA та одним іншим сертифікатом::"

msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"Завантажте закритий ключ і відповідний сертифікат. Рядок *certfile* має бути "
"шляхом до одного файлу у форматі PEM, що містить сертифікат, а також будь-"
"яку кількість сертифікатів ЦС, необхідних для встановлення автентичності "
"сертифіката. Рядок *keyfile*, якщо він присутній, має вказувати на файл, що "
"містить закритий ключ. Інакше закритий ключ також буде взято з *certfile*. "
"Перегляньте обговорення :ref:`ssl-certificates` для отримання додаткової "
"інформації про те, як сертифікат зберігається у *certfile*."

msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"Аргумент *password* може бути функцією для виклику, щоб отримати пароль для "
"розшифровки закритого ключа. Він буде викликаний, лише якщо закритий ключ "
"зашифрований і потрібен пароль. Він буде викликаний без аргументів і повинен "
"повернути рядок, байти або масив байтів. Якщо значення, що повертається, є "
"рядком, воно буде закодовано як UTF-8 перед використанням для розшифровки "
"ключа. Крім того, значення рядка, байтів або масиву байтів можна надати "
"безпосередньо як аргумент *пароль*. Він буде проігнорований, якщо закритий "
"ключ не зашифрований і пароль не потрібен."

msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Якщо аргумент *password* не вказано, а пароль потрібен, вбудований механізм "
"підказки пароля OpenSSL буде використано для інтерактивного запиту "
"користувача пароля."

msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
":class:`SSLError` виникає, якщо закритий ключ не збігається з сертифікатом."

msgid "New optional argument *password*."
msgstr "Новий необов'язковий аргумент *пароль*."

msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"Завантажте набір стандартних сертифікатів \"центру сертифікації\" (CA) із "
"стандартних розташувань. У Windows він завантажує сертифікати ЦС із "
"системних сховищ ``CA`` і ``ROOT``. У всіх системах він викликає :meth:"
"`SSLContext.set_default_verify_paths`. У майбутньому цей метод може також "
"завантажувати сертифікати ЦС з інших місць."

msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"Прапор *purpose* визначає тип сертифікатів ЦС, які завантажуються. Параметри "
"за замовчуванням :data:`Purpose.SERVER_AUTH` завантажують сертифікати, які "
"позначено та є довіреними для автентифікації веб-сервера TLS (сокети на "
"стороні клієнта). :data:`Purpose.CLIENT_AUTH` завантажує сертифікати ЦС для "
"перевірки сертифікатів клієнта на стороні сервера."

msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Завантажте набір сертифікатів \"центру сертифікації\" (CA), які "
"використовуються для перевірки сертифікатів інших вузлів, якщо :data:"
"`verify_mode` відрізняється від :data:`CERT_NONE`. Потрібно вказати "
"принаймні один із *cafile* або *capath*."

msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Цей метод також може завантажувати списки відкликаних сертифікатів (CRL) у "
"форматі PEM або DER. Щоб використовувати CRL, :attr:`SSLContext."
"verify_flags` має бути правильно налаштовано."

msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"Рядок *cafile*, якщо він присутній, є шляхом до файлу об’єднаних "
"сертифікатів ЦС у форматі PEM. Перегляньте обговорення :ref:`ssl-"
"certificates` для отримання додаткової інформації про те, як упорядкувати "
"сертифікати в цьому файлі."

msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."
msgstr ""
"Рядок *capath*, якщо він присутній, є шляхом до каталогу, що містить кілька "
"сертифікатів ЦС у форматі PEM, відповідно до `спеціального макета OpenSSL "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."

msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"Об’єкт *cadata*, якщо він присутній, є рядком ASCII одного чи кількох "
"сертифікатів у кодуванні PEM або :term:`bytes-like object` сертифікатів у "
"кодуванні DER. Подібно до *capath* додаткові рядки навколо PEM-кодованих "
"сертифікатів ігноруються, але принаймні один сертифікат має бути присутнім."

msgid "New optional argument *cadata*"
msgstr "Новий необов'язковий аргумент *cadata*"

msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Отримайте список завантажених сертифікатів \"центру сертифікації\" (CA). "
"Якщо параметр ``binary_form`` має значення :const:`False`, кожен запис у "
"списку є диктофоном, подібним до результату :meth:`SSLSocket.getpeercert`. В "
"іншому випадку метод повертає список сертифікатів, закодованих DER. "
"Повернений список не містить сертифікатів від *capath*, якщо тільки "
"сертифікат не було запитано та завантажено через підключення SSL."

msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Сертифікати в каталозі capath не завантажуються, якщо вони не були "
"використані принаймні один раз."

msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"Отримайте список увімкнених шифрів. Список розташований у порядку пріоритету "
"шифру. Перегляньте :meth:`SSLContext.set_ciphers`."

msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Завантажте набір стандартних сертифікатів \"центру сертифікації\" (CA) із "
"шляху файлової системи, визначеного під час створення бібліотеки OpenSSL. На "
"жаль, немає простого способу дізнатися, чи цей метод успішний: помилка не "
"повертається, якщо сертифікати не знайдені. Однак, коли бібліотека OpenSSL "
"надається як частина операційної системи, вона, швидше за все, буде "
"налаштована належним чином."

msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. If no cipher can be selected (because "
"compile-time options or other configuration forbids use of all the specified "
"ciphers), an :class:`SSLError` will be raised."
msgstr ""
"Встановіть доступні шифри для сокетів, створених із цим контекстом. Це має "
"бути рядок у `форматі списку шифрів OpenSSL <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. Якщо жоден шифр не може бути обраний "
"(оскільки параметри під час компіляції чи інша конфігурація забороняють "
"використовувати всі вказані шифри), буде викликано :class:`SSLError`."

msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"під час підключення метод :meth:`SSLSocket.cipher` для сокетів SSL дасть "
"поточний вибраний шифр."

msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr ""
"Набори шифрів TLS 1.3 не можна вимкнути за допомогою :meth:`~SSLContext."
"set_ciphers`."

msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Укажіть, які протоколи має сповіщати сокет під час рукостискання SSL/TLS. Це "
"має бути список рядків ASCII, наприклад ``['http/1.1', 'spdy/2']``, "
"упорядкованих за перевагами. Вибір протоколу відбуватиметься під час "
"рукостискання та відтворюватиметься відповідно до :rfc:`7301`. Після "
"успішного рукостискання метод :meth:`SSLSocket.selected_alpn_protocol` "
"поверне узгоджений протокол."

msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Цей метод викличе :exc:`NotImplementedError`, якщо :data:`HAS_ALPN` має "
"значення ``False``."

msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Укажіть, які протоколи має сповіщати сокет під час рукостискання SSL/TLS. Це "
"має бути список рядків, наприклад ``['http/1.1', 'spdy/2']``, упорядкованих "
"за перевагами. Вибір протоколу відбуватиметься під час рукостискання та "
"відтворюватиметься відповідно до `Узгодження протоколу прикладного рівня "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Після успішного рукостискання метод :meth:`SSLSocket.selected_npn_protocol` "
"поверне узгоджений протокол."

msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Цей метод викличе :exc:`NotImplementedError`, якщо :data:`HAS_NPN` має "
"значення ``False``."

msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Зареєструйте функцію зворотного виклику, яка буде викликана після отримання "
"повідомлення рукостискання TLS Client Hello сервером SSL/TLS, коли клієнт "
"TLS вказує вказівку імені сервера. Механізм індикації імені сервера вказано "
"в :rfc:`6066` розділі 3 - Індикація імені сервера."

msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Для кожного SSLContext можна встановити лише один зворотний виклик. Якщо "
"*sni_callback* встановлено на ``None``, тоді зворотний виклик вимкнено. "
"Наступний виклик цієї функції вимкне попередньо зареєстрований зворотний "
"виклик."

msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"Функція зворотного виклику буде викликана з трьома аргументами; перший — це :"
"class:`ssl.SSLSocket`, другий — це рядок, який представляє ім’я сервера, з "
"яким клієнт має намір зв’язатися (або :const:`None`, якщо TLS Client Hello "
"не містить імені сервера) а третій аргумент — вихідний :class:`SSLContext`. "
"Аргументом імені сервера є текст. Для інтернаціоналізованого доменного імені "
"ім’я сервера є міткою IDN A (``\"xn--pythn-mua.org\"``)."

msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"Типовим використанням цього зворотного виклику є зміна атрибута :attr:"
"`SSLSocket.context` :class:`ssl.SSLSocket` на новий об’єкт типу :class:"
"`SSLContext`, який представляє ланцюжок сертифікатів, який відповідає імені "
"сервера ."

msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` and :meth:`SSLSocket.compression` "
"methods require that the TLS connection has progressed beyond the TLS Client "
"Hello and therefore will not return meaningful values nor can they be called "
"safely."
msgstr ""
"Через ранню фазу узгодження TLS-з’єднання можна використовувати лише "
"обмежені методи та атрибути, наприклад :meth:`SSLSocket."
"selected_alpn_protocol` і :attr:`SSLSocket.context`. Методи :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` і :meth:`SSLSocket.compression` "
"вимагають, щоб TLS-з’єднання просунулося за межі TLS Client Hello, тому не "
"повертають значущих значень і не можуть викликати безпечно."

msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"Функція *sni_callback* має повертати ``None``, щоб узгодження TLS "
"продовжилося. Якщо потрібна помилка TLS, можна повернути константу :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>`. Інші значення, що "
"повертаються, призведуть до фатальної помилки TLS із :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Якщо функція *sni_callback* викликає виняток, TLS-з’єднання буде розірвано з "
"небезпечним TLS-повідомленням :const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Цей метод викличе :exc:`NotImplementedError`, якщо під час створення "
"бібліотеки OpenSSL було визначено OPENSSL_NO_TLSEXT."

msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Це застарілий API, збережений для зворотної сумісності. Якщо можливо, "
"замість цього слід використовувати :attr:`sni_callback`. Наданий "
"*server_name_callback* подібний до *sni_callback*, за винятком того, що коли "
"ім’я хосту сервера є інтернаціоналізованим доменним ім’ям із кодуванням IDN, "
"*server_name_callback* отримує декодовану U-мітку (``\"pythön.org\"``)."

msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"Якщо в імені сервера є помилка декодування, TLS-з’єднання буде розірвано з "
"повідомленням TLS-сповіщення клієнта :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Завантажте параметри генерації ключів для обміну ключами Діффі-Хеллмана "
"(DH). Використання обміну ключами DH покращує пряму секретність за рахунок "
"обчислювальних ресурсів (як на сервері, так і на клієнті). Параметр *dhfile* "
"має бути шляхом до файлу, що містить параметри DH у форматі PEM."

msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Цей параметр не застосовується до клієнтських сокетів. Ви також можете "
"використовувати параметр :data:`OP_SINGLE_DH_USE` для подальшого покращення "
"безпеки."

msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Встановіть назву кривої для обміну ключами Діффі-Хеллмана (ECDH) на основі "
"еліптичної кривої. ECDH значно швидший, ніж звичайний DH, але, можливо, "
"такий же безпечний. Параметр *curve_name* має бути рядком, що описує добре "
"відому еліптичну криву, наприклад ``prime256v1`` для широко підтримуваної "
"кривої."

msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Цей параметр не застосовується до клієнтських сокетів. Ви також можете "
"використовувати опцію :data:`OP_SINGLE_ECDH_USE` для подальшого покращення "
"безпеки."

msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Цей метод недоступний, якщо :data:`HAS_ECDH` має значення ``False``."

msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"

msgid "Vincent Bernat."
msgstr "Вінсент Бернат."

msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Оберніть існуючий сокет Python *sock* і поверніть екземпляр :attr:"
"`SSSLContext.sslsocket_class` (за замовчуванням :class:`SSLSocket`). "
"Повернений сокет SSL прив’язаний до контексту, його налаштувань і "
"сертифікатів. *sock* має бути сокетом :data:`~socket.SOCK_STREAM`; інші типи "
"сокетів не підтримуються."

msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"Параметр ``server_side`` є логічним значенням, яке визначає, яка поведінка "
"для цього сокета – серверна чи клієнтська."

msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"Для сокетів на стороні клієнта конструкція контексту є ледачою; якщо "
"основний сокет ще не підключено, конструкція контексту буде виконана після "
"виклику :meth:`connect` для сокета. Для сокетів на стороні сервера, якщо "
"сокет не має віддаленого однорангового пристрою, він вважається сокетом, що "
"прослуховує, і обернення SSL на стороні сервера автоматично виконується для "
"підключень клієнта, прийнятих через метод :meth:`accept`. Метод може "
"викликати :exc:`SSLError`."

msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"У клієнтських з’єднаннях необов’язковий параметр *server_hostname* визначає "
"ім’я хоста служби, до якої ми під’єднуємося. Це дозволяє одному серверу "
"розміщувати кілька служб на основі SSL з окремими сертифікатами, подібно до "
"віртуальних хостів HTTP. Якщо вказати *server_hostname*, виникне :exc:"
"`ValueError`, якщо *server_side* має значення true."

msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"Параметр ``do_handshake_on_connect`` визначає, чи виконувати SSL-"
"рукостискання автоматично після виконання :meth:`socket.connect`, чи "
"прикладна програма викличе його явно, викликаючи метод :meth:`SSLSocket."
"do_handshake`. Виклик :meth:`SSLSocket.do_handshake` явно дає програмі "
"контроль над поведінкою блокування вводу-виводу сокета, залученого до "
"рукостискання."

msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"Параметр ``suppress_ragged_eofs`` визначає, як метод :meth:`SSLSocket.recv` "
"повинен сигналізувати про неочікуваний EOF з іншого боку з’єднання. Якщо "
"вказано як :const:`True` (за замовчуванням), він повертає звичайний EOF "
"(порожній об’єкт байтів) у відповідь на неочікувані помилки EOF, викликані "
"базовим сокетом; якщо :const:`False`, винятки повертаються до абонента."

msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*сеанс*, див. :attr:`~SSLSocket.session`."

msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Завжди дозволяйте передачу server_hostname, навіть якщо OpenSSL не має SNI."

msgid "*session* argument was added."
msgstr "Додано аргумент *сеанс*."

msgid ""
"The method returns on instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""

msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""
"Тип повернення :meth:`SSLContext.wrap_socket` за замовчуванням :class:"
"`SSLSocket`. Атрибут можна перевизначити в екземплярі класу, щоб повернути "
"настроюваний підклас :class:`SSLSocket`."

msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Об’єднайте BIO-об’єкти *incoming* і *outgoing* і поверніть екземпляр :attr:"
"`SSLContext.sslobject_class` (за замовчуванням :class:`SSLObject`). "
"Підпрограми SSL читатимуть вхідні дані з вхідного BIO та записуватимуть дані "
"у вихідний BIO."

msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Параметри *server_side*, *server_hostname* і *session* мають те саме "
"значення, що й у :meth:`SSLContext.wrap_socket`."

msgid ""
"The method returns on instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""

msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
"Тип повернення :meth:`SSLContext.wrap_bio` за замовчуванням :class:"
"`SSLObject`. Атрибут можна перевизначити в екземплярі класу, щоб повернути "
"настроюваний підклас :class:`SSLObject`."

msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.1/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"Чи відповідати імені хосту однорангового сертифіката в :meth:`SSLSocket."
"do_handshake`. :attr:`~SSLContext.verify_mode` контексту має бути "
"встановлено на :data:`CERT_OPTIONAL` або :data:`CERT_REQUIRED`, і ви повинні "
"передати *server_hostname* до :meth:`~SSLContext.wrap_socket` для "
"відповідності ім'я хоста. Увімкнення перевірки імені хоста автоматично "
"встановлює :attr:`~SSLContext.verify_mode` з :data:`CERT_NONE` на :data:"
"`CERT_REQUIRED`. Його не можна повернути до :data:`CERT_NONE`, доки "
"ввімкнено перевірку імені хоста. Протокол :data:`PROTOCOL_TLS_CLIENT` умикає "
"перевірку імені хоста за умовчанням. Для інших протоколів перевірка імені "
"хоста повинна бути включена явно."

msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSSLContext.verify_mode` тепер автоматично змінюється на :data:"
"`CERT_REQUIRED`, коли перевірку імені хоста ввімкнено, а :attr:`~SSSLContext."
"verify_mode` має значення :data:`CERT_NONE`. Раніше ця сама операція не "
"виконувалася з помилкою :exc:`ValueError`."

msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Записуйте ключі TLS у файл клавіатурного журналу щоразу, коли створюється "
"або отримується ключовий матеріал. Файл клавіатурного журналу створено лише "
"для налагодження. Формат файлу визначається NSS і використовується багатьма "
"аналізаторами трафіку, такими як Wireshark. Файл журналу відкривається в "
"режимі лише додавання. Записи синхронізуються між потоками, але не між "
"процесами."

msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Член переліку :class:`TLSVersion` представляє найвищу підтримувану версію "
"TLS. Значенням за замовчуванням є :attr:`TLSVersion.MAXIMUM_SUPPORTED`. "
"Атрибут доступний лише для читання для інших протоколів, ніж :attr:"
"`PROTOCOL_TLS`, :attr:`PROTOCOL_TLS_CLIENT` і :attr:`PROTOCOL_TLS_SERVER`."

msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"Атрибути :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` і :attr:`SSLContext.options` впливають на підтримувані "
"версії контексту SSL і TLS. Реалізація не запобігає недійсній комбінації. "
"Наприклад, контекст із :attr:`OP_NO_TLSv1_2` у :attr:`~SSLContext.options` "
"і :attr:`~SSLContext.maximum_version` зі значенням :attr:`TLSVersion."
"TLSv1_2` не зможе встановити TLS 1.2 підключення."

msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Як :attr:`SSLContext.maximum_version`, за винятком того, що це найнижча "
"підтримувана версія або :attr:`TLSVersion.MINIMUM_SUPPORTED`."

msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""
"Контролюйте кількість квитків сесії TLS 1.3 контексту :attr:"
"`PROTOCOL_TLS_SERVER`. Параметр не впливає на підключення TLS 1.0 до 1.2."

msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Ціле число, що представляє набір параметрів SSL, увімкнених у цьому "
"контексті. Стандартним значенням є :data:`OP_ALL`, але ви можете вказати "
"інші параметри, наприклад :data:`OP_NO_SSLv2`, об’єднавши їх разом."

msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` повертає прапорці :class:`Options`:"

msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""
"Усі параметри ``OP_NO_SSL*`` і ``OP_NO_TLS*`` стали застарілими з Python "
"3.7. Замість цього використовуйте :attr:`SSLContext.minimum_version` і :attr:"
"`SSLContext.maximum_version`."

msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Увімкнути автентифікацію клієнта після рукостискання TLS 1.3. Автентифікація "
"після рукостискання вимкнена за замовчуванням, і сервер може запитувати "
"сертифікат клієнта TLS лише під час початкового рукостискання. Якщо "
"ввімкнено, сервер може запитувати сертифікат клієнта TLS у будь-який час "
"після рукостискання."

msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"Якщо ввімкнено на сокетах на стороні клієнта, клієнт сигналізує серверу, що "
"він підтримує автентифікацію після рукостискання."

msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"Якщо ввімкнено на серверних сокетах, :attr:`SSLContext.verify_mode` також "
"має бути встановлено на :data:`CERT_OPTIONAL` або :data:`CERT_REQUIRED`. "
"Фактичний обмін сертифікатами клієнта відкладено, доки не буде викликано :"
"meth:`SSLSocket.verify_client_post_handshake` і не буде виконано деякий ввід-"
"вивід."

msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"Версія протоколу, обрана під час побудови контексту. Цей атрибут доступний "
"лише для читання."

msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Чи повертається :attr:`~SSLContext.check_hostname` для перевірки загальної "
"назви суб’єкта сертифіката за відсутності альтернативного розширення імені "
"суб’єкта (за умовчанням: істина)."

msgid ""
"The flag had no effect with OpenSSL before version 1.1.1k. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"Прапор не мав ефекту з OpenSSL до версії 1.1.1k. Python 3.8.9, 3.9.3 і 3.10 "
"містять обхідні шляхи для попередніх версій."

msgid ""
"An integer representing the `security level <https://www.openssl.org/docs/"
"manmaster/man3/SSL_CTX_get_security_level.html>`_ for the context. This "
"attribute is read-only."
msgstr ""
"Ціле число, що представляє `рівень безпеки <https://www.openssl.org/docs/"
"manmaster/man3/SSL_CTX_get_security_level.html>`_ для контексту. Цей атрибут "
"доступний лише для читання."

msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"Прапори для операцій перевірки сертифіката. Ви можете встановити такі "
"прапорці, як :data:`VERIFY_CRL_CHECK_LEAF`, об’єднавши їх разом. За "
"замовчуванням OpenSSL не вимагає і не перевіряє списки відкликаних "
"сертифікатів (CRL)."

msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""
":attr:`SSLContext.verify_flags` повертає :class:`VerifyFlags` прапорці:"

msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Чи намагатися перевірити сертифікати інших вузлів і як поводитися, якщо "
"перевірка не вдається. Цей атрибут має бути одним із :data:`CERT_NONE`, :"
"data:`CERT_OPTIONAL` або :data:`CERT_REQUIRED`."

msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` повертає :class:`VerifyMode` enum:"

msgid "Certificates"
msgstr "Сертифікати"

msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"Загалом сертифікати є частиною системи відкритого/приватного ключа. У цій "
"системі кожному *принципалу* (яким може бути машина, або особа, або "
"організація) призначається унікальний ключ шифрування, що складається з двох "
"частин. Одна частина ключа є відкритою і називається *відкритим ключем*; "
"інша частина зберігається в таємниці та називається *приватним ключем*. Ці "
"дві частини пов’язані між собою, оскільки якщо ви зашифровуєте повідомлення "
"за допомогою однієї з частин, ви можете розшифрувати його за допомогою іншої "
"частини та **тільки** за допомогою іншої частини."

msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Сертифікат містить інформацію про двох принципалів. Він містить назву "
"*суб’єкта* та відкритий ключ суб’єкта. Він також містить заяву другого "
"принципала, *емітента*, про те, що суб’єкт є тим, за кого себе видає, і що "
"це справді відкритий ключ суб’єкта. Заява емітента підписується закритим "
"ключем емітента, який відомий лише емітенту. Проте будь-хто може перевірити "
"заяву емітента, знайшовши відкритий ключ емітента, розшифрувавши за його "
"допомогою заяву та порівнявши її з іншою інформацією в сертифікаті. "
"Сертифікат також містить інформацію про термін його дії. Це виражається "
"двома полями, які називаються \"notBefore\" і \"notAfter\"."

msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"При використанні сертифікатів Python клієнт або сервер можуть "
"використовувати сертифікат, щоб підтвердити, ким вони є. Інша сторона "
"мережевого з’єднання також може вимагати створення сертифіката, і цей "
"сертифікат може бути перевірений відповідно до вимог клієнта або сервера, "
"які потребують такої перевірки. Спробу підключення можна налаштувати так, "
"щоб викликати виняток, якщо перевірка не вдається. Перевірка виконується "
"автоматично базовою структурою OpenSSL; програмі не потрібно займатися своєю "
"механікою. Але програмі зазвичай потрібно надати набори сертифікатів, щоб "
"дозволити цей процес."

msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python використовує файли для зберігання сертифікатів. Вони повинні бути "
"відформатовані як \"PEM\" (див. :rfc:`1422`), який є формою, закодованою на "
"базі 64, оберненою рядком верхнього та нижнього колонтитулів::"

msgid "Certificate chains"
msgstr "Ланцюжки сертифікатів"

msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"Файли Python, які містять сертифікати, можуть містити послідовність "
"сертифікатів, яку іноді називають *ланцюжком сертифікатів*. Цей ланцюжок має "
"починатися з конкретного сертифіката для принципала, який \"є\" клієнтом або "
"сервером, а потім сертифіката для видавця цього сертифіката, а потім "
"сертифіката для видавця *цього* сертифіката, і так далі вгору по ланцюжку "
"доки ви не дійдете до *самопідписаного* сертифіката, тобто сертифіката з тим "
"самим суб’єктом і видавцем, який іноді називають *кореневим сертифікатом*. "
"Сертифікати потрібно просто об’єднати у файлі сертифікатів. Наприклад, "
"припустімо, що ми маємо ланцюжок із трьох сертифікатів: від сертифіката "
"нашого сервера до сертифіката центру сертифікації, який підписав наш "
"сертифікат сервера, до кореневого сертифіката агентства, яке видало "
"сертифікат центру сертифікації:"

msgid "CA certificates"
msgstr "сертифікати ЦС"

msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"Якщо ви збираєтеся вимагати підтвердження іншої сторони сертифіката "
"з’єднання, вам потрібно надати файл \"сертифікатів ЦС\", заповнений "
"ланцюжками сертифікатів для кожного видавця, якому ви готові довіряти. Знову "
"ж таки, цей файл містить ці ланцюжки, об’єднані разом. Для перевірки Python "
"використовуватиме перший ланцюжок, знайдений у файлі, який відповідає. Файл "
"сертифікатів платформи можна використовувати, викликавши :meth:`SSLContext."
"load_default_certs`, це робиться автоматично за допомогою :func:`."
"create_default_context`."

msgid "Combined key and certificate"
msgstr "Комбінований ключ і сертифікат"

msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""
"Часто закритий ключ зберігається в тому ж файлі, що й сертифікат; у цьому "
"випадку потрібно передати лише параметр ``certfile`` для :meth:`SSSLContext."
"load_cert_chain` і :func:`wrap_socket`. Якщо приватний ключ зберігається "
"разом із сертифікатом, він має бути перед першим сертифікатом у ланцюжку "
"сертифікатів:"

msgid "Self-signed certificates"
msgstr "Самопідписані сертифікати"

msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Якщо ви збираєтеся створити сервер, який надає послуги з’єднання з "
"шифруванням SSL, вам потрібно буде отримати сертифікат для цієї послуги. Є "
"багато способів отримати відповідні сертифікати, наприклад придбати "
"сертифікат в центрі сертифікації. Іншою поширеною практикою є створення "
"самопідписаного сертифіката. Найпростіший спосіб зробити це за допомогою "
"пакета OpenSSL, використовуючи щось на зразок наступного:"

msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"Недоліком самопідписаного сертифіката є те, що це його власний кореневий "
"сертифікат, і ніхто інший не матиме його в кеш-пам’яті відомих (і надійних) "
"кореневих сертифікатів."

msgid "Examples"
msgstr "Приклади"

msgid "Testing for SSL support"
msgstr "Тестування підтримки SSL"

msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"Щоб перевірити наявність підтримки SSL у встановленому Python, код "
"користувача має використовувати таку ідіому:"

msgid "Client-side operation"
msgstr "Робота на стороні клієнта"

msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"У цьому прикладі створюється контекст SSL із рекомендованими налаштуваннями "
"безпеки для клієнтських сокетів, включаючи автоматичну перевірку сертифіката:"

msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Якщо ви бажаєте налаштувати параметри безпеки самостійно, ви можете створити "
"контекст з нуля (але пам’ятайте, що ви можете неправильно встановити "
"параметри):"

msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(цей фрагмент припускає, що ваша операційна система розміщує пакет усіх "
"сертифікатів ЦС у ``/etc/ssl/certs/ca-bundle.crt``; якщо ні, ви отримаєте "
"повідомлення про помилку, і вам доведеться змінити розташування)"

msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"Протокол :data:`PROTOCOL_TLS_CLIENT` налаштовує контекст для перевірки "
"сертифіката та перевірки імені хоста. :attr:`~SSLContext.verify_mode` "
"встановлено на :data:`CERT_REQUIRED`, а :attr:`~SSLContext.check_hostname` "
"встановлено на ``True``. Усі інші протоколи створюють контексти SSL із "
"незахищеними значеннями за умовчанням."

msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"Коли ви використовуєте контекст для підключення до сервера, :const:"
"`CERT_REQUIRED` і :attr:`~SSSLContext.check_hostname` перевіряють сертифікат "
"сервера: це гарантує, що сертифікат сервера було підписано одним із "
"сертифікатів ЦС, перевіряє підпис на коректність і перевіряє інші "
"властивості, такі як дійсність та ідентичність імені хоста::"

msgid "You may then fetch the certificate::"
msgstr "Потім ви можете отримати сертифікат:"

msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"Візуальна перевірка показує, що сертифікат ідентифікує потрібну службу "
"(тобто хост HTTPS ``www.python.org``):"

msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Тепер SSL-канал встановлено та сертифікат перевірено, ви можете продовжити "
"спілкування з сервером:"

msgid "Server-side operation"
msgstr "Робота на стороні сервера"

msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"Для роботи сервера зазвичай потрібно мати сертифікат сервера та закритий "
"ключ, кожен у файлі. Спочатку ви створите контекст, що містить ключ і "
"сертифікат, щоб клієнти могли перевірити вашу автентичність. Потім ви "
"відкриєте сокет, прив’яжете його до порту, викличете на ньому :meth:`listen` "
"і почнете чекати підключення клієнтів::"

msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"Коли клієнт підключається, ви викличете :meth:`accept` для сокета, щоб "
"отримати новий сокет з іншого боку, і використаєте контекстний метод :meth:"
"`SSLContext.wrap_socket`, щоб створити серверний сокет SSL для зв'язок::"

msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Потім ви будете читати дані з ``connstream`` і щось робити з ними, поки не "
"закінчите роботу з клієнтом (або клієнт не закінчить роботу з вами):"

msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"І поверніться до прослуховування нових клієнтських з’єднань (звичайно, "
"реальний сервер, ймовірно, оброблятиме кожне клієнтське з’єднання в окремому "
"потоці або переведе сокети в :ref:`неблокуючий режим <ssl-nonblocking>` і "
"використає цикл подій)."

msgid "Notes on non-blocking sockets"
msgstr "Примітки щодо неблокуючих розеток"

msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"SSL-сокети поводяться дещо інакше, ніж звичайні сокети в неблокуючому "
"режимі. Працюючи з неблокуючими сокетами, ви повинні знати про кілька речей:"

msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"Більшість методів :class:`SSLSocket` викликають або :exc:"
"`SSLWantWriteError`, або :exc:`SSLWantReadError` замість :exc:"
"`BlockingIOError`, якщо операція вводу/виводу буде заблокована. :exc:"
"`SSLWantReadError` буде викликано, якщо операція читання базового сокета є "
"необхідною, і :exc:`SSLWantWriteError` для операції запису базового сокета. "
"Зауважте, що спроби *запису* в сокет SSL можуть вимагати спочатку *читання* "
"з базового сокета, а спроби *читання* з сокета SSL можуть вимагати "
"попереднього *запису* в базовий сокет."

msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"У попередніх версіях Python метод :meth:`!SSLSocket.send` повертав нуль "
"замість того, щоб викликати :exc:`SSLWantWriteError` або :exc:"
"`SSLWantReadError`."

msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"Виклик :func:`~select.select` повідомляє вам, що сокет рівня ОС можна "
"зчитувати (або записувати), але це не означає, що на верхньому рівні SSL "
"достатньо даних. Наприклад, могла надійти лише частина кадру SSL. Таким "
"чином, ви повинні бути готові впоратися з помилками :meth:`SSLSocket.recv` "
"і :meth:`SSLSocket.send` і повторити спробу після іншого виклику :func:"
"`~select.select`."

msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"І навпаки, оскільки рівень SSL має власне фреймування, сокет SSL все ще може "
"мати дані, доступні для читання, не знаючи про це :func:`~select.select`. "
"Таким чином, ви повинні спочатку викликати :meth:`SSLSocket.recv`, щоб "
"вичерпати будь-які потенційно доступні дані, а потім лише заблокувати "
"виклик :func:`~select.select`, якщо все ще необхідно."

msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(звичайно, подібні положення застосовуються при використанні інших "
"примітивів, таких як :func:`~select.poll` або в модулі :mod:`selectors`)"

msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"Саме рукостискання SSL буде неблокуючим: метод :meth:`SSLSocket."
"do_handshake` потрібно повторити, поки він не повернеться успішно. Ось "
"короткий опис використання :func:`~select.select` для очікування готовності "
"сокета::"

msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""
"Модуль :mod:`asyncio` підтримує :ref:`неблокуючі сокети SSL <ssl-"
"nonblocking>` і забезпечує API вищого рівня. Він опитує події за допомогою "
"модуля :mod:`selectors` і обробляє винятки :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` і :exc:`BlockingIOError`. Він також запускає "
"рукостискання SSL асинхронно."

msgid "Memory BIO Support"
msgstr "Підтримка BIO пам'яті"

msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"З тих пір, як модуль SSL було представлено в Python 2.6, клас :class:"
"`SSLSocket` забезпечив дві пов’язані, але різні області функціональності:"

msgid "SSL protocol handling"
msgstr "Обробка протоколу SSL"

msgid "Network IO"
msgstr "Мережа IO"

msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"Мережевий IO API ідентичний тому, який надає :class:`socket.socket`, від "
"якого також успадковується :class:`SSLSocket`. Це дозволяє використовувати "
"сокет SSL як додаткову заміну звичайного сокета, що дозволяє дуже легко "
"додати підтримку SSL до існуючої програми."

msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"Поєднання обробки протоколу SSL і мережевого введення-виведення зазвичай "
"працює добре, але в деяких випадках це не так. Прикладом є асинхронні "
"структури вводу-виводу, які хочуть використовувати іншу модель "
"мультиплексування вводу-виводу, ніж модель \"вибір/опитування дескриптора "
"файлу\" (на основі готовності), яка передбачається :class:`socket.socket` і "
"внутрішнім вводом-виводом сокета OpenSSL рутини. Це в основному актуально "
"для таких платформ, як Windows, де ця модель не ефективна. Для цього "
"надається зменшений варіант :class:`SSLSocket` під назвою :class:`SSLObject`."

msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"Зменшений варіант :class:`SSLSocket`, що представляє екземпляр протоколу "
"SSL, який не містить жодних мережевих методів введення-виведення. Цей клас "
"зазвичай використовується авторами фреймворків, які хочуть реалізувати "
"асинхронний IO для SSL через буфери пам’яті."

msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Цей клас реалізує інтерфейс поверх об’єкта SSL низького рівня, реалізованого "
"OpenSSL. Цей об’єкт фіксує стан SSL-з’єднання, але сам не надає мережевий "
"IO. IO потрібно виконувати через окремі об’єкти \"BIO\", які є рівнем "
"абстракції IO OpenSSL."

msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"Цей клас не має публічного конструктора. Екземпляр :class:`SSLObject` має "
"бути створений за допомогою методу :meth:`~SSLContext.wrap_bio`. Цей метод "
"створить екземпляр :class:`SSLObject` і прив’яже його до пари BIO. *Вхідний* "
"BIO використовується для передачі даних від Python до примірника протоколу "
"SSL, тоді як *вихідний* BIO використовується для передачі даних навпаки."

msgid "The following methods are available:"
msgstr "Доступні такі методи:"

msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.сторона_сервера`"

msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.сервер_hostname`"

msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.очікує`"

msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"У порівнянні з :class:`SSLSocket` цьому об’єкту бракує наступних функцій:"

msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""
"Будь-яка форма мережевого вводу-виводу; ``recv()`` і ``send()`` читають і "
"записують лише в базові буфери :class:`MemoryBIO`."

msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"Не існує механізму *do_handshake_on_connect*. Ви завжди повинні вручну "
"викликати :meth:`~SSLSocket.do_handshake`, щоб почати рукостискання."

msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"Немає обробки *suppress_ragged_eofs*. Усі умови кінця файлу, які порушують "
"протокол, повідомляються через виняток :exc:`SSLEOFError`."

msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"Виклик методу :meth:`~SSLSocket.unwrap` нічого не повертає, на відміну від "
"сокета SSL, де він повертає основний сокет."

msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"Зворотний виклик *server_name_callback*, переданий :meth:`SSLContext."
"set_servername_callback`, отримає екземпляр :class:`SSLObject` замість "
"екземпляра :class:`SSLSocket` як перший параметр."

msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "Деякі зауваження щодо використання :class:`SSLObject`:"

msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
"Усі IO для :class:`SSLObject` є :ref:`неблокуючими <ssl-nonblocking>`. Це "
"означає, що, наприклад, :meth:`~SSLSocket.read` викличе :exc:"
"`SSLWantReadError`, якщо йому потрібно більше даних, ніж доступно у вхідному "
"BIO."

msgid ""
"There is no module-level ``wrap_bio()`` call like there is for :meth:"
"`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via an :"
"class:`SSLContext`."
msgstr ""
"Немає виклику ``wrap_bio()`` на рівні модуля, як для :meth:`~SSLContext."
"wrap_socket`. :class:`SSLObject` завжди створюється через :class:"
"`SSLContext`."

msgid ""
":class:`SSLObject` instances must to created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"Екземпляри :class:`SSLObject` повинні бути створені за допомогою :meth:"
"`~SSSLContext.wrap_bio`. У попередніх версіях можна було створювати "
"екземпляри безпосередньо. Це ніколи не було задокументовано чи офіційно "
"підтверджено."

msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject спілкується із зовнішнім світом за допомогою буферів пам’яті. "
"Клас :class:`MemoryBIO` забезпечує буфер пам’яті, який можна використовувати "
"для цієї мети. Він обертає об’єкт BIO пам’яті OpenSSL (Basic IO):"

msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"Буфер пам’яті, який можна використовувати для передачі даних між Python та "
"екземпляром протоколу SSL."

msgid "Return the number of bytes currently in the memory buffer."
msgstr "Повертає кількість байтів у буфері пам'яті."

msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"Логічне значення, яке вказує, чи є BIO пам’яті поточним у позиції кінця "
"файлу."

msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Прочитати до *n* байт із буфера пам’яті. Якщо *n* не вказано або має "
"негативне значення, повертаються всі байти."

msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Запишіть байти з *buf* в пам'ять BIO. Аргумент *buf* має бути об’єктом, що "
"підтримує протокол буфера."

msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"Поверненим значенням є кількість записаних байтів, яка завжди дорівнює "
"довжині *buf*."

msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"Запишіть маркер EOF в пам'ять BIO. Після виклику цього методу викликати :"
"meth:`~MemoryBIO.write` заборонено. Атрибут :attr:`eof` стане істинним після "
"того, як усі дані, які зараз знаходяться в буфері, будуть прочитані."

msgid "SSL session"
msgstr "Сеанс SSL"

msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Об’єкт сеансу, який використовує :attr:`~SSLSocket.session`."

msgid "Security considerations"
msgstr "Міркування безпеки"

msgid "Best defaults"
msgstr "Найкращі параметри за замовчуванням"

msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"Для **користування клієнтом**, якщо у вас немає особливих вимог до вашої "
"політики безпеки, настійно рекомендується використовувати функцію :func:"
"`create_default_context` для створення контексту SSL. Він завантажить "
"довірені сертифікати ЦС системи, увімкне перевірку сертифіката та перевірку "
"імені хоста, а також спробує вибрати достатньо безпечний протокол і "
"налаштування шифру."

msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Наприклад, ось як можна використовувати клас :class:`smtplib.SMTP` для "
"створення надійного безпечного з’єднання з сервером SMTP:"

msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Якщо для підключення потрібен сертифікат клієнта, його можна додати за "
"допомогою :meth:`SSSLContext.load_cert_chain`."

msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Навпаки, якщо ви створюєте контекст SSL, викликаючи конструктор :class:"
"`SSLContext` самостійно, за замовчуванням не буде ввімкнено ні перевірку "
"сертифіката, ні перевірку імені хоста. Якщо ви це зробите, будь ласка, "
"прочитайте параграфи нижче, щоб досягти хорошого рівня безпеки."

msgid "Manual settings"
msgstr "Ручні налаштування"

msgid "Verifying certificates"
msgstr "Перевірка сертифікатів"

msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of time you would "
"like to ensure the authenticity of the server you're talking to. Therefore, "
"when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used.  This common check is "
"automatically performed when :attr:`SSLContext.check_hostname` is enabled."
msgstr ""
"Під час безпосереднього виклику конструктора :class:`SSLContext` типовим є :"
"const:`CERT_NONE`. Оскільки він не автентифікує іншого однорангового вузла, "
"він може бути небезпечним, особливо в режимі клієнта, де більшу частину часу "
"ви хочете переконатися в автентичності сервера, з яким спілкуєтеся. Тому в "
"режимі клієнта настійно рекомендується використовувати :const:"
"`CERT_REQUIRED`. Однак цього самого по собі недостатньо; ви також повинні "
"перевірити, чи сертифікат сервера, який можна отримати, викликавши :meth:"
"`SSLSocket.getpeercert`, відповідає бажаній службі. Для багатьох протоколів "
"і програм послугу можна ідентифікувати за іменем хоста; у цьому випадку "
"можна використати функцію :func:`match_hostname`. Ця звичайна перевірка "
"виконується автоматично, коли :attr:`SSLContext.check_hostname` увімкнено."

msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""
"Зіставлення імен хостів тепер виконує OpenSSL. Python більше не "
"використовує :func:`match_hostname`."

msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"У режимі сервера, якщо ви хочете автентифікувати своїх клієнтів за допомогою "
"рівня SSL (замість використання механізму автентифікації вищого рівня), вам "
"також доведеться вказати :const:`CERT_REQUIRED` і так само перевірити "
"сертифікат клієнта."

msgid "Protocol versions"
msgstr "Версії протоколу"

msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"SSL версії 2 і 3 вважаються небезпечними, тому їх використання небезпечно. "
"Якщо вам потрібна максимальна сумісність між клієнтами та серверами, "
"рекомендується використовувати :const:`PROTOCOL_TLS_CLIENT` або :const:"
"`PROTOCOL_TLS_SERVER` як версію протоколу. SSLv2 і SSLv3 вимкнено за "
"замовчуванням."

msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"Контекст SSL, створений вище, дозволить лише TLSv1.2 і новіші (якщо "
"підтримується вашою системою) підключення до сервера. :const:"
"`PROTOCOL_TLS_CLIENT` за замовчуванням передбачає перевірку сертифіката та "
"перевірку імені хоста. Ви повинні завантажити сертифікати в контекст."

msgid "Cipher selection"
msgstr "Вибір шифру"

msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/manmaster/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled "
"by a given cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl "
"ciphers`` command on your system."
msgstr ""

msgid "Multi-processing"
msgstr "Багатопроцесорність"

msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:"
"`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""
"Якщо ви використовуєте цей модуль як частину багатопроцесорної програми "
"(використовуючи, наприклад, модулі :mod:`multiprocessing` або :mod:"
"`concurrent.futures`), майте на увазі, що внутрішній генератор випадкових "
"чисел OpenSSL не обробляє належним чином роздвоєні процеси . Програми "
"повинні змінити стан PRNG батьківського процесу, якщо вони використовують "
"будь-яку функцію SSL із :func:`os.fork`. Достатньо будь-якого успішного "
"виклику :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` або :func:`~ssl."
"RAND_pseudo_bytes`."

msgid "TLS 1.3"
msgstr "TLS 1.3"

msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"Протокол TLS 1.3 працює дещо інакше, ніж попередня версія TLS/SSL. Деякі "
"нові функції TLS 1.3 ще недоступні."

msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 використовує диз’юнктний набір наборів шифрів. Усі набори шифрів AES-"
"GCM і ChaCha20 увімкнено за замовчуванням. Метод :meth:`SSLContext."
"set_ciphers` ще не може ввімкнути чи вимкнути будь-які шифри TLS 1.3, але :"
"meth:`SSLContext.get_ciphers` повертає їх."

msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Заявки на сеанс більше не надсилаються як частина початкового рукостискання "
"та обробляються інакше. :attr:`SSLSocket.session` і :class:`SSLSession` "
"несумісні з TLS 1.3."

msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Клієнтські сертифікати також більше не перевіряються під час початкового "
"рукостискання. Сервер може запитати сертифікат у будь-який час. Клієнти "
"обробляють запити на сертифікати, коли вони надсилають або отримують дані "
"програми з сервера."

msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"Такі функції TLS 1.3, як ранні дані, відкладений запит на сертифікат клієнта "
"TLS, конфігурація алгоритму підпису та повторне введення ключів, ще не "
"підтримуються."

msgid "Class :class:`socket.socket`"
msgstr "Клас :class:`socket.socket`"

msgid "Documentation of underlying :mod:`socket` class"
msgstr "Документація основного класу :mod:`socket`"

msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`Надійне шифрування SSL/TLS: Вступ <https://httpd.apache.org/docs/trunk/en/"
"ssl/ssl_intro.html>`_"

msgid "Intro from the Apache HTTP Server documentation"
msgstr "Введення з документації Apache HTTP Server"

msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Покращення конфіденційності електронної пошти в Інтернеті: "
"Частина II: Керування ключами на основі сертифікатів <1422>`"

msgid "Steve Kent"
msgstr "Стів Кент"

msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Вимоги до випадковості для безпеки <4086>`"

msgid "Donald E., Jeffrey I. Schiller"
msgstr "Дональд Е., Джеффрі І. Шиллер"

msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Сертифікат інфраструктури відкритих ключів Інтернету X.509 і "
"профіль відкликаних сертифікатів (CRL) <5280>`"

msgid "D. Cooper"
msgstr "Д. Купер"

msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: Протокол безпеки транспортного рівня (TLS) версії 1.2 <5246>`"

msgid "T. Dierks et. al."
msgstr "Т. Діркс та ін. al."

msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: Розширення безпеки транспортного рівня (TLS) <6066>`"

msgid "D. Eastlake"
msgstr "Д. Істлейк"

msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Параметри безпеки транспортного рівня (TLS) <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"

msgid "IANA"
msgstr "IANA"

msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Рекомендації щодо безпечного використання безпеки "
"транспортного рівня (TLS) і захисту транспортного рівня датаграм (DTLS) "
"<7525>`"

msgid "IETF"
msgstr "IETF"

msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Рекомендації TLS на стороні сервера Mozilla <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

msgid "Mozilla"
msgstr "Mozilla"
