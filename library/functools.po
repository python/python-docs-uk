# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ""
":mod:`functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ""
":mod:`functools` --- Функції вищого порядку та операції над об'єктами, що "
"викликаються"

msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**Вихідний код:** :source:`Lib/functools.py`"

msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ""
"Модуль :mod:`functools` призначений для функцій вищого порядку: функцій, які "
"діють або повертають інші функції. Загалом, будь-який викликуваний об’єкт "
"можна розглядати як функцію для цілей цього модуля."

msgid "The :mod:`functools` module defines the following functions:"
msgstr "Модуль :mod:`functools` визначає такі функції:"

msgid ""
"Simple lightweight unbounded function cache.  Sometimes called `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""
"Простий легкий необмежений кеш функцій. Іноді називається `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."

msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than :func:"
"`lru_cache()` with a size limit."
msgstr ""
"Повертає те саме, що ``lru_cache(maxsize=None)``, створюючи тонку обгортку "
"навколо пошуку в словнику для аргументів функції. Оскільки йому ніколи не "
"потрібно вилучати старі значення, він менший і швидший, ніж :func:"
"`lru_cache()` з обмеженням розміру."

msgid "For example::"
msgstr "Наприклад::"

msgid ""
"Transform a method of a class into a property whose value is computed once "
"and then cached as a normal attribute for the life of the instance. Similar "
"to :func:`property`, with the addition of caching. Useful for expensive "
"computed properties of instances that are otherwise effectively immutable."
msgstr ""
"Перетворення методу класу на властивість, значення якого обчислюється один "
"раз, а потім кешується як звичайний атрибут протягом життя екземпляра. "
"Подібно до :func:`property`, з додаванням кешування. Корисно для дорогих "
"обчислених властивостей екземплярів, які в іншому випадку є фактично "
"незмінними."

msgid "Example::"
msgstr "Приклад::"

msgid ""
"The mechanics of :func:`cached_property` are somewhat different from :func:"
"`property`.  A regular property blocks attribute writes unless a setter is "
"defined. In contrast, a *cached_property* allows writes."
msgstr ""
"Механіка :func:`cached_property` дещо відрізняється від :func:`property`. "
"Звичайна властивість блокує запис атрибута, якщо не визначено установщик. На "
"відміну від цього, *cached_property* дозволяє запис."

msgid ""
"The *cached_property* decorator only runs on lookups and only when an "
"attribute of the same name doesn't exist.  When it does run, the "
"*cached_property* writes to the attribute with the same name. Subsequent "
"attribute reads and writes take precedence over the *cached_property* method "
"and it works like a normal attribute."
msgstr ""
"Декоратор *cached_property* працює лише під час пошуку й лише тоді, коли "
"атрибут із такою ж назвою не існує. Коли він виконується, *cached_property* "
"записує в атрибут з таким же ім’ям. Наступні атрибути читання та запису "
"мають пріоритет над методом *cached_property*, і він працює як звичайний "
"атрибут."

msgid ""
"The cached value can be cleared by deleting the attribute.  This allows the "
"*cached_property* method to run again."
msgstr ""
"Кешоване значення можна очистити, видаливши атрибут. Це дозволяє знову "
"запустити метод *cached_property*."

msgid ""
"Note, this decorator interferes with the operation of :pep:`412` key-sharing "
"dictionaries.  This means that instance dictionaries can take more space "
"than usual."
msgstr ""
"Зауважте, що цей декоратор заважає роботі словників спільного ключа :pep:"
"`412`. Це означає, що словники примірників можуть займати більше місця, ніж "
"зазвичай."

msgid ""
"Also, this decorator requires that the ``__dict__`` attribute on each "
"instance be a mutable mapping. This means it will not work with some types, "
"such as metaclasses (since the ``__dict__`` attributes on type instances are "
"read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots (as "
"such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"Крім того, цей декоратор вимагає, щоб атрибут ``__dict__`` для кожного "
"екземпляра був змінним відображенням. Це означає, що він не працюватиме з "
"деякими типами, такими як метакласи (оскільки атрибути ``__dict__`` в "
"екземплярах типу є проксі-серверами лише для читання для простору імен "
"класу), і ті, які вказують ``__slots__`` без включення ``__dict__`` як один "
"із визначених слотів (оскільки такі класи взагалі не надають атрибут "
"``__dict__``)."

msgid ""
"If a mutable mapping is not available or if space-efficient key sharing is "
"desired, an effect similar to :func:`cached_property` can be achieved by a "
"stacking :func:`property` on top of :func:`cache`::"
msgstr ""
"Якщо змінне відображення недоступне або якщо потрібен спільний доступ до "
"ключів з ефективним використанням простору, ефект, подібний до :func:"
"`cached_property`, може бути досягнутий стекуванням :func:`property` поверх :"
"func:`cache`::"

msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`).  This function is primarily used as a transition tool "
"for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"Перетворіть функцію порівняння старого стилю на :term:`key function`. "
"Використовується з інструментами, які приймають ключові функції (такі як :"
"func:`sorted`, :func:`min`, :func:`max`, :func:`heapq.nlargest`, :func:"
"`heapq.nsmallest`,  :func:`itertools.groupby`). Ця функція в основному "
"використовується як інструмент переходу для програм, які перетворюються з "
"Python 2, який підтримує використання функцій порівняння."

msgid ""
"A comparison function is any callable that accept two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts "
"one argument and returns another value to be used as the sort key."
msgstr ""
"Функція порівняння — це будь-який виклик, який приймає два аргументи, "
"порівнює їх і повертає від’ємне число для меншого, нуль для рівності або "
"позитивне число для більшого. Ключова функція — це виклик, який приймає один "
"аргумент і повертає інше значення, яке використовується як ключ сортування."

msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Приклади сортування та короткий посібник із сортування див. :ref:"
"`sortinghowto`."

msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr ""
"Декоратор для обгортання функції викликом мемоізації, який зберігає до "
"*maxsize* останніх викликів. Це може заощадити час, коли дорога функція або "
"функція, пов’язана з вводом/виводом, періодично викликається з однаковими "
"аргументами."

msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be hashable."
msgstr ""
"Оскільки словник використовується для кешування результатів, позиційні та "
"ключові аргументи функції мають хешуватися."

msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, `f(a=1, b=2)` and `f(b=2, a=1)` differ "
"in their keyword argument order and may have two separate cache entries."
msgstr ""
"Різні шаблони аргументів можна вважати різними викликами з окремими записами "
"кешу. Наприклад, `f(a=1, b=2)` і `f(b=2, a=1)` відрізняються порядком "
"аргументів ключових слів і можуть мати два окремі записи кешу."

msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving the "
"*maxsize* at its default value of 128::"
msgstr ""
"Якщо вказано *user_function*, вона має бути викликаною. Це дозволяє "
"застосувати декоратор *lru_cache* безпосередньо до функції користувача, "
"залишаючи значення *maxsize* за замовчуванням 128::"

msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound."
msgstr ""
"Якщо для параметра *maxsize* встановлено значення ``None``, функція LRU "
"вимкнена, і кеш може збільшуватися без обмежень."

msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  If *typed* is false, the implementation will usually "
"regard them as equivalent calls and only cache a single result. (Some types "
"such as *str* and *int* may be cached separately even when *typed* is false.)"
msgstr ""
"Якщо *typed* має значення true, аргументи функції різних типів "
"кешуватимуться окремо. Якщо *typed* має значення false, реалізація зазвичай "
"розглядатиме їх як еквівалентні виклики та кешуватиме лише один результат. "
"(Деякі типи, такі як *str* і *int*, можуть кешуватися окремо, навіть якщо "
"*typed* має значення false.)"

msgid ""
"Note, type specificity applies only to the function's immediate arguments "
"rather than their contents.  The scalar arguments, ``Decimal(42)`` and "
"``Fraction(42)`` are be treated as distinct calls with distinct results. In "
"contrast, the tuple arguments ``('answer', Decimal(42))`` and ``('answer', "
"Fraction(42))`` are treated as equivalent."
msgstr ""
"Зауважте, що специфічність типу застосовується лише до безпосередніх "
"аргументів функції, а не до їх вмісту. Скалярні аргументи ``Decimal(42)`` і "
"``Fraction(42)`` розглядаються як окремі виклики з різними результатами. "
"Навпаки, аргументи кортежу ``('answer', Decimal(42))`` і ``('answer', "
"Fraction(42))`` розглядаються як еквівалентні."

msgid ""
"The wrapped function is instrumented with a :func:`cache_parameters` "
"function that returns a new :class:`dict` showing the values for *maxsize* "
"and *typed*.  This is for information purposes only.  Mutating the values "
"has no effect."
msgstr ""
"Обгорнута функція оснащена функцією :func:`cache_parameters`, яка повертає "
"новий :class:`dict` із значеннями для *maxsize* і *typed*. Це лише для "
"інформаційних цілей. Зміна значень не має ефекту."

msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*."
msgstr ""
"Щоб допомогти виміряти ефективність кешу та налаштувати параметр *maxsize*, "
"обгорнута функція обладнана функцією :func:`cache_info`, яка повертає :term:"
"`named tuple`, що показує *влучення*, *промахи*, *maxsize* і *currsize*."

msgid ""
"The decorator also provides a :func:`cache_clear` function for clearing or "
"invalidating the cache."
msgstr ""
"Декоратор також надає функцію :func:`cache_clear` для очищення або "
"анулювання кешу."

msgid ""
"The original underlying function is accessible through the :attr:"
"`__wrapped__` attribute.  This is useful for introspection, for bypassing "
"the cache, or for rewrapping the function with a different cache."
msgstr ""
"Оригінальна базова функція доступна через атрибут :attr:`__wrapped__`. Це "
"корисно для самоаналізу, для обходу кешу або для перезагортання функції в "
"інший кеш."

msgid ""
"The cache keeps references to the arguments and return values until they age "
"out of the cache or until the cache is cleared."
msgstr ""
"Кеш зберігає посилання на аргументи та значення, що повертаються, доки вони "
"не вичерпаються з кешу або поки кеш не буде очищено."

msgid ""
"An `LRU (least recently used) cache <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_recently_used_(LRU)>`_ works best when the "
"most recent calls are the best predictors of upcoming calls (for example, "
"the most popular articles on a news server tend to change each day).  The "
"cache's size limit assures that the cache does not grow without bound on "
"long-running processes such as web servers."
msgstr ""
"Кеш `LRU (найменше використовуваний) <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_recently_used_(LRU)>`_ працює найкраще, "
"коли останні дзвінки є найкращим прогнозом майбутніх дзвінків (наприклад, "
"найпопулярніші статті на сервері новин, як правило, змінюються щодня). "
"Обмеження розміру кешу гарантує, що кеш не буде безмежно зростати "
"довготривалими процесами, такими як веб-сервери."

msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call, or impure functions such as time() or random()."
msgstr ""
"Загалом кеш LRU слід використовувати лише тоді, коли потрібно повторно "
"використати попередньо обчислені значення. Відповідно, немає сенсу кешувати "
"функції з побічними ефектами, функції, які потребують створення окремих "
"змінних об’єктів під час кожного виклику, або нечисті функції, такі як "
"time() або random()."

msgid "Example of an LRU cache for static web content::"
msgstr "Приклад кешу LRU для статичного веб-контенту::"

msgid ""
"Example of efficiently computing `Fibonacci numbers <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ using a cache to implement a `dynamic "
"programming <https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"Приклад ефективного обчислення `чисел Фібоначчі <https://en.wikipedia.org/"
"wiki/Fibonacci_number>`_ з використанням кешу для реалізації техніки "
"`динамічного програмування <https://en.wikipedia.org/wiki/"
"Dynamic_programming>`_::"

msgid "Added the *typed* option."
msgstr "Додано параметр *введений*."

msgid "Added the *user_function* option."
msgstr "Додано опцію *user_function*."

msgid "Added the function :func:`cache_parameters`"
msgstr "Додано функцію :func:`cache_parameters`"

msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr ""
"Враховуючи клас, що визначає один або більше методів розширеного "
"впорядкування порівняння, цей декоратор класу забезпечує решту. Це спрощує "
"завдання, пов’язані з визначенням усіх можливих операцій розширеного "
"порівняння:"

msgid ""
"The class must define one of :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, "
"or :meth:`__ge__`. In addition, the class should supply an :meth:`__eq__` "
"method."
msgstr ""
"Клас має визначати одне з :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__` "
"або :meth:`__ge__`. Крім того, клас повинен надати метод :meth:`__eq__`."

msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack "
"traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six "
"rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"Незважаючи на те, що цей декоратор дозволяє легко створювати повністю "
"впорядковані типи, що добре ведуть себе, це *ціна* відбувається за рахунок "
"повільнішого виконання та більш складних трасувань стека для похідних "
"методів порівняння. Якщо порівняльний аналіз продуктивності вказує на те, що "
"це вузьке місце для даної програми, впровадження всіх шести розширених "
"методів порівняння натомість, ймовірно, забезпечить легке підвищення "
"швидкості."

msgid ""
"This decorator makes no attempt to override methods that have been declared "
"in the class *or its superclasses*. Meaning that if a superclass defines a "
"comparison operator, *total_ordering* will not implement it again, even if "
"the original method is abstract."
msgstr ""
"Цей декоратор не намагається перевизначити методи, які були оголошені в "
"класі *або його суперкласах*. Це означає, що якщо суперклас визначає "
"оператор порівняння, *total_ordering* не реалізує його знову, навіть якщо "
"вихідний метод є абстрактним."

msgid ""
"Returning NotImplemented from the underlying comparison function for "
"unrecognised types is now supported."
msgstr ""
"Тепер підтримується повернення NotImplemented із основної функції порівняння "
"для нерозпізнаних типів."

msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"Повертає новий :ref:`частковий об’єкт <partial-objects>`, який під час "
"виклику поводитиметься як *func*, що викликається з позиційними аргументами "
"*args* і ключовими аргументами *keywords*. Якщо до виклику надається більше "
"аргументів, вони додаються до *args*. Якщо надаються додаткові ключові "
"аргументи, вони розширюють і замінюють *ключові слова*. Приблизно "
"еквівалентно::"

msgid ""
"The :func:`partial` is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords resulting "
"in a new object with a simplified signature.  For example, :func:`partial` "
"can be used to create a callable that behaves like the :func:`int` function "
"where the *base* argument defaults to two:"
msgstr ""
":func:`partial` використовується для застосування часткової функції, яка "
"\"заморожує\" деяку частину аргументів функції та/або ключових слів, у "
"результаті чого створюється новий об’єкт зі спрощеною сигнатурою. "
"Наприклад, :func:`partial` можна використовувати для створення виклику, який "
"поводиться як функція :func:`int`, де аргумент *base* за замовчуванням "
"дорівнює двом:"

msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like :class:"
"`partial` except that it is designed to be used as a method definition "
"rather than being directly callable."
msgstr ""
"Повертає новий дескриптор :class:`partialmethod`, який поводиться як :class:"
"`partial`, за винятком того, що він призначений для використання як "
"визначення методу, а не для безпосереднього виклику."

msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr ""
"*func* має бути :term:`descriptor` або викликаним (об’єкти, які, як і "
"звичайні функції, обробляються як дескриптори)."

msgid ""
"When *func* is a descriptor (such as a normal Python function, :func:"
"`classmethod`, :func:`staticmethod`, :func:`abstractmethod` or another "
"instance of :class:`partialmethod`), calls to ``__get__`` are delegated to "
"the underlying descriptor, and an appropriate :ref:`partial object<partial-"
"objects>` returned as the result."
msgstr ""
"Коли *func* є дескриптором (наприклад, звичайною функцією Python, :func:"
"`classmethod`, :func:`staticmethod`, :func:`abstractmethod` або іншим "
"екземпляром :class:`partialmethod`), викликається ``__get__`` делегуються "
"базовому дескриптору, а в результаті повертається відповідний :ref:"
"`частковий об’єкт <partial-objects>`."

msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as "
"a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the :class:"
"`partialmethod` constructor."
msgstr ""
"Коли *func* є недескрипторним викликом, відповідний пов’язаний метод "
"створюється динамічно. Це поводиться як звичайна функція Python, коли "
"використовується як метод: аргумент *self* буде вставлено як перший "
"позиційний аргумент, навіть перед *args* і *keywords*, наданими "
"конструктору :class:`partialmethod`."

msgid ""
"Apply *function* of two arguments cumulatively to the items of *iterable*, "
"from left to right, so as to reduce the iterable to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *iterable*.  If the "
"optional *initializer* is present, it is placed before the items of the "
"iterable in the calculation, and serves as a default when the iterable is "
"empty.  If *initializer* is not given and *iterable* contains only one item, "
"the first item is returned."
msgstr ""
"Застосуйте *функцію* двох аргументів сукупно до елементів *iterable*, зліва "
"направо, щоб зменшити iterable до одного значення. Наприклад, "
"``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` обчислює "
"``((((1+2)+3)+4)+5)``. Лівий аргумент, *x*, — це накопичене значення, а "
"правий аргумент, *y*, — це значення оновлення з *iterable*. Якщо "
"необов’язковий *ініціалізатор* присутній, він розміщується перед елементами "
"об’єкта ітерації в обчисленні та служить за замовчуванням, коли об’єкт "
"ітерації порожній. Якщо *initializer* не вказано, а *iterable* містить лише "
"один елемент, повертається перший елемент."

msgid "Roughly equivalent to::"
msgstr "Приблизно еквівалентно::"

msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr ""
"Перегляньте :func:`itertools.accumulate` для ітератора, який видає всі "
"проміжні значення."

msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"Перетворення функції на :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."

msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. When defining a function using ``@singledispatch``, note that the "
"dispatch happens on the type of the first argument::"
msgstr ""
"Щоб визначити загальну функцію, прикрасьте її за допомогою декоратора "
"``@singledispatch``. Визначаючи функцію за допомогою ``@singledispatch``, "
"зауважте, що відправлення відбувається за типом першого аргументу::"

msgid ""
"To add overloaded implementations to the function, use the :func:`register` "
"attribute of the generic function, which can be used as a decorator.  For "
"functions annotated with types, the decorator will infer the type of the "
"first argument automatically::"
msgstr ""
"Щоб додати перевантажені реалізації до функції, використовуйте атрибут :func:"
"`register` загальної функції, який можна використовувати як декоратор. Для "
"функцій, анотованих типами, декоратор автоматично визначить тип першого "
"аргументу:"

msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr ""
"Для коду, який не використовує анотації типу, відповідний аргумент типу "
"можна явно передати самому декоратору::"

msgid ""
"To enable registering :term:`lambdas<lambda>` and pre-existing functions, "
"the :func:`register` attribute can also be used in a functional form::"
msgstr ""
"Щоб увімкнути реєстрацію :term:`lambdas <lambda>` і вже існуючих функцій, "
"атрибут :func:`register` також можна використовувати у функціональній формі:"

msgid ""
"The :func:`register` attribute returns the undecorated function. This "
"enables decorator stacking, :mod:`pickling<pickle>`, and the creation of "
"unit tests for each variant independently::"
msgstr ""
"Атрибут :func:`register` повертає недекоровану функцію. Це дозволяє "
"стекувати декоратор, :mod:`піклінг <pickle>` і створювати модульні тести для "
"кожного варіанту незалежно:"

msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr "Під час виклику загальна функція надсилає тип першого аргументу::"

msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original "
"function decorated with ``@singledispatch`` is registered for the base :"
"class:`object` type, which means it is used if no better implementation is "
"found."
msgstr ""
"Якщо немає зареєстрованої реалізації для певного типу, його порядок "
"вирішення методів використовується для пошуку більш загальної реалізації. "
"Оригінальна функція, прикрашена ``@singledispatch``, зареєстрована для "
"базового типу :class:`object`, що означає, що вона використовується, якщо не "
"знайдено кращої реалізації."

msgid ""
"If an implementation is registered to an :term:`abstract base class`, "
"virtual subclasses of the base class will be dispatched to that "
"implementation::"
msgstr ""
"Якщо реалізацію зареєстровано в :term:`abstract base class`, віртуальні "
"підкласи базового класу будуть відправлені до цієї реалізації::"

msgid ""
"To check which implementation the generic function will choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr ""
"Щоб перевірити, яку реалізацію вибере загальна функція для заданого типу, "
"використовуйте атрибут ``dispatch()``::"

msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr ""
"Щоб отримати доступ до всіх зареєстрованих реалізацій, використовуйте "
"атрибут ``registry`` лише для читання::"

msgid "The :func:`register` attribute now supports using type annotations."
msgstr "Атрибут :func:`register` тепер підтримує використання анотацій типу."

msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"Перетворення методу на :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."

msgid ""
"To define a generic method, decorate it with the ``@singledispatchmethod`` "
"decorator. When defining a function using ``@singledispatchmethod``, note "
"that the dispatch happens on the type of the first non-*self* or non-*cls* "
"argument::"
msgstr ""
"Щоб визначити загальний метод, прикрасьте його декоратором "
"``@singledispatchmethod``. Визначаючи функцію за допомогою "
"``@singledispatchmethod``, зауважте, що відправлення відбувається за типом "
"першого не*self* або не*cls* аргументу::"

msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as :"
"func:`@classmethod<classmethod>`. Note that to allow for ``dispatcher."
"register``, ``singledispatchmethod`` must be the *outer most* decorator. "
"Here is the ``Negator`` class with the ``neg`` methods bound to the class, "
"rather than an instance of the class::"
msgstr ""
"``@singledispatchmethod`` підтримує вкладення з іншими декораторами, такими "
"як :func:`@classmethod <classmethod>`. Зауважте, що для того, щоб дозволити "
"``dispatcher.register``, ``singledispatchmethod`` має бути *зовнішнім* "
"декоратором. Ось клас ``Negator`` з методами ``neg``, прив'язаними до класу, "
"а не екземпляр класу::"

msgid ""
"The same pattern can be used for other similar decorators: :func:"
"`@staticmethod<staticmethod>`, :func:`@abstractmethod<abc.abstractmethod>`, "
"and others."
msgstr ""
"Той самий шаблон можна використовувати для інших подібних декораторів: :func:"
"`@staticmethod <staticmethod>`, :func:`@abstractmethod <abc.abstractmethod>` "
"та інших."

msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's ``__module__``, ``__name__``, "
"``__qualname__``, ``__annotations__`` and ``__doc__``, the documentation "
"string) and ``WRAPPER_UPDATES`` (which updates the wrapper function's "
"``__dict__``, i.e. the instance dictionary)."
msgstr ""
"Оновіть функцію *wrapper*, щоб виглядати як функція *wrapper*. Необов’язкові "
"аргументи — це кортежі, які вказують, які атрибути вихідної функції "
"призначаються безпосередньо відповідним атрибутам у функції-огортці та які "
"атрибути функції-огортки оновлюються відповідними атрибутами з вихідної "
"функції. Значеннями за замовчуванням для цих аргументів є константи рівня "
"модуля ``WRAPPER_ASSIGNMENTS`` (які призначають функції-оболонки "
"``__module__``, ``__name__``, ``__qualname__``, ``__annotations__`` і "
"``__doc__``, рядок документації) і ``WRAPPER_UPDATES`` (який оновлює "
"``__dict__`` функції-огортки, тобто словник екземпляра)."

msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"Щоб дозволити доступ до оригінальної функції для самоаналізу та інших цілей "
"(наприклад, обхід декоратора кешування, такого як :func:`lru_cache`), ця "
"функція автоматично додає атрибут ``__wrapped__`` до оболонки, яка "
"посилається на функцію, яку обгортають."

msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"Основним призначенням цієї функції є функції :term:`decorator`, які "
"обертають декоровану функцію та повертають оболонку. Якщо функція-оболонка "
"не оновлена, метадані повернутої функції відображатимуть визначення "
"оболонки, а не початкове визначення функції, що зазвичай не дуже корисно."

msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object "
"being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` можна використовувати з іншими викликами, ніж "
"функції. Будь-які атрибути з іменами *assigned* або *updated*, яких немає в "
"об’єкті, що обгортається, ігноруються (тобто ця функція не намагатиметься "
"встановити їх у функції обгортки). :exc:`AttributeError` все ще виникає, "
"якщо в самій функції-обгортки відсутні будь-які атрибути, названі в "
"*updated*."

msgid "Automatic addition of the ``__wrapped__`` attribute."
msgstr "Автоматичне додавання атрибута ``__wrapped__``."

msgid "Copying of the ``__annotations__`` attribute by default."
msgstr "Копіювання атрибута ``__annotations__`` за замовчуванням."

msgid "Missing attributes no longer trigger an :exc:`AttributeError`."
msgstr "Відсутні атрибути більше не викликають :exc:`AttributeError`."

msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see :issue:"
"`17482`)"
msgstr ""
"Атрибут ``__wrapped__`` тепер завжди посилається на обгорнуту функцію, "
"навіть якщо ця функція визначила атрибут ``__wrapped__``. (див. :issue:"
"`17482`)"

msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"Це зручна функція для виклику :func:`update_wrapper` як декоратора функції "
"під час визначення функції-огортки. Це еквівалентно "
"``partial(update_wrapper, wrapped=wrapped, assigned=призначено, "
"updated=updated)``. Наприклад::"

msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original :func:"
"`example` would have been lost."
msgstr ""
"Без використання цієї фабрики декораторів назва функції прикладу була б "
"``'wrapper``, а рядок документації оригінального :func:`example` було б "
"втрачено."

msgid ":class:`partial` Objects"
msgstr ":class:`partial` Об'єкти"

msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ""
":class:`partial` об’єкти – це викликані об’єкти, створені :func:`partial`. "
"Вони мають три атрибути лише для читання:"

msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be "
"forwarded to :attr:`func` with new arguments and keywords."
msgstr ""
"Викликаний об’єкт або функція. Виклики об’єкта :class:`partial` будуть "
"перенаправлені до :attr:`func` з новими аргументами та ключовими словами."

msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr ""
"Крайні ліві позиційні аргументи, які будуть додані до позиційних аргументів, "
"наданих до виклику об’єкта :class:`partial`."

msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object "
"is called."
msgstr ""
"Ключові аргументи, які будуть надані під час виклику об’єкта :class:"
"`partial`."

msgid ""
":class:`partial` objects are like :class:`function` objects in that they are "
"callable, weak referencable, and can have attributes.  There are some "
"important differences.  For instance, the :attr:`~definition.__name__` and :"
"attr:`__doc__` attributes are not created automatically.  Also, :class:"
"`partial` objects defined in classes behave like static methods and do not "
"transform into bound methods during instance attribute look-up."
msgstr ""
"Об’єкти :class:`partial` схожі на об’єкти :class:`function` тим, що їх можна "
"викликати, на них можна слабко посилатися та вони можуть мати атрибути. Є "
"деякі важливі відмінності. Наприклад, атрибути :attr:`~definition.__name__` "
"і :attr:`__doc__` не створюються автоматично. Крім того, об’єкти :class:"
"`partial`, визначені в класах, поводяться як статичні методи і не "
"перетворюються на зв’язані методи під час пошуку атрибутів екземпляра."
