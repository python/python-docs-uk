# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`numbers` --- Numeric abstract base classes"
msgstr ":mod:`numbers` --- Числові абстрактні базові класи"

msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**Вихідний код:** :source:`Lib/numbers.py`"

msgid ""
"The :mod:`numbers` module (:pep:`3141`) defines a hierarchy of numeric :term:"
"`abstract base classes <abstract base class>` which progressively define "
"more operations.  None of the types defined in this module are intended to "
"be instantiated."
msgstr ""
"Модуль :mod:`numbers` (:pep:`3141`) визначає ієрархію числових :term:"
"`абстрактних базових класів <abstract base class>`, які поступово визначають "
"більше операцій. Жоден із типів, визначених у цьому модулі, не призначений "
"для створення екземплярів."

msgid ""
"The root of the numeric hierarchy. If you just want to check if an argument "
"*x* is a number, without caring what kind, use ``isinstance(x, Number)``."
msgstr ""
"Корінь числової ієрархії. Якщо ви просто хочете перевірити, чи є аргумент "
"*x* числом, не звертаючи уваги на те, якого типу, використовуйте "
"``isinstance(x, Number)``."

msgid "The numeric tower"
msgstr "Числова вежа"

msgid ""
"Subclasses of this type describe complex numbers and include the operations "
"that work on the built-in :class:`complex` type. These are: conversions to :"
"class:`complex` and :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, ``-"
"``, ``*``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, ``==``, and ``!"
"=``. All except ``-`` and ``!=`` are abstract."
msgstr ""
"Підкласи цього типу описують комплексні числа та включають операції, які "
"працюють із вбудованим типом :class:`complex`. Це: перетворення на :class:"
"`complex` і :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, ``-``, ``* "
"``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, ``==`` і ``!=``. Усі, "
"крім ``-`` і ``!=``, є абстрактними."

msgid "Abstract. Retrieves the real component of this number."
msgstr "Анотація. Отримує дійсний компонент цього числа."

msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "Анотація. Отримує уявний компонент цього числа."

msgid ""
"Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate() "
"== (1-3j)``."
msgstr ""
"Анотація. Повертає комплексне сполучення. Наприклад, ``(1+3j).conjugate() == "
"(1-3j)``."

msgid ""
"To :class:`Complex`, :class:`Real` adds the operations that work on real "
"numbers."
msgstr ""
"До :class:`Complex` :class:`Real` додає операції, які працюють над дійсними "
"числами."

msgid ""
"In short, those are: a conversion to :class:`float`, :func:`math.trunc`, :"
"func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, "
"``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"Якщо коротко, це: перетворення на :class:`float`, :func:`math.trunc`, :func:"
"`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, "
"``%``, ``<``, ``<=``, ``>`` і ``>=``."

msgid ""
"Real also provides defaults for :func:`complex`, :attr:`~Complex.real`, :"
"attr:`~Complex.imag`, and :meth:`~Complex.conjugate`."
msgstr ""
"Real також надає значення за замовчуванням для :func:`complex`, :attr:"
"`~Complex.real`, :attr:`~Complex.imag` і :meth:`~Complex.conjugate`."

msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` and :attr:"
"`~Rational.denominator` properties, which should be in lowest terms. With "
"these, it provides a default for :func:`float`."
msgstr ""
"Підтипи :class:`Real` і додає властивості :attr:`~Rational.numerator` і :"
"attr:`~Rational.denominator`, які мають бути в найнижчих термінах. З ними "
"він забезпечує типове значення для :func:`float`."

msgid "Abstract."
msgstr "Анотація."

msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  Provides "
"defaults for :func:`float`, :attr:`~Rational.numerator`, and :attr:"
"`~Rational.denominator`.  Adds abstract methods for :func:`pow` with modulus "
"and bit-string operations: ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~``."
msgstr ""
"Підтипує :class:`Rational` і додає перетворення до :class:`int`. Надає "
"значення за замовчуванням для :func:`float`, :attr:`~Rational.numerator` і :"
"attr:`~Rational.denominator`. Додає абстрактні методи для :func:`pow` з "
"операціями модуля та бітового рядка: ``<<``, ``>>``, ``&``, ``^``, ``|``, "
"``~``."

msgid "Notes for type implementors"
msgstr "Примітки для розробників типу"

msgid ""
"Implementors should be careful to make equal numbers equal and hash them to "
"the same values. This may be subtle if there are two different extensions of "
"the real numbers. For example, :class:`fractions.Fraction` implements :func:"
"`hash` as follows::"
msgstr ""
"Розробники повинні бути обережними, щоб зробити однакові числа рівними та "
"хешувати їх до однакових значень. Це може бути непомітно, якщо є два різних "
"розширення дійсних чисел. Наприклад, :class:`fractions.Fraction` реалізує :"
"func:`hash` наступним чином:"

msgid "Adding More Numeric ABCs"
msgstr "Додавання додаткових числових букв"

msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a "
"poor hierarchy if it precluded the possibility of adding those. You can add "
"``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"Звичайно, існує більше можливих азбуки для чисел, і це була б погана "
"ієрархія, якби вона виключала можливість їх додавання. Ви можете додати "
"``MyFoo`` між :class:`Complex` і :class:`Real` за допомогою::"

msgid "Implementing the arithmetic operations"
msgstr "Реалізація арифметичних дій"

msgid ""
"We want to implement the arithmetic operations so that mixed-mode operations "
"either call an implementation whose author knew about the types of both "
"arguments, or convert both to the nearest built in type and do the operation "
"there. For subtypes of :class:`Integral`, this means that :meth:`__add__` "
"and :meth:`__radd__` should be defined as::"
msgstr ""
"Ми хочемо реалізувати арифметичні операції так, щоб операції змішаного "
"режиму або викликали реалізацію, автор якої знав про типи обох аргументів, "
"або конвертували обидва до найближчого вбудованого типу та виконували "
"операцію там. Для підтипів :class:`Integral` це означає, що :meth:`__add__` "
"і :meth:`__radd__` мають бути визначені як:"

msgid ""
"There are 5 different cases for a mixed-type operation on subclasses of :"
"class:`Complex`. I'll refer to all of the above code that doesn't refer to "
"``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` will be "
"an instance of ``A``, which is a subtype of :class:`Complex` (``a : A <: "
"Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
"Є 5 різних випадків для операції змішаного типу над підкласами :class:"
"`Complex`. Я буду називати весь наведений вище код, який не посилається на "
"``MyIntegral`` і ``OtherTypeIKnowAbout``, як \"шаблонний\". ``a`` буде "
"екземпляром ``A``, який є підтипом :class:`Complex` (``a : A <: Complex``), "
"і ``b : B <: Complex``. Я розглядаю ``a + b``:"

msgid "If ``A`` defines an :meth:`__add__` which accepts ``b``, all is well."
msgstr "Якщо ``A`` визначає :meth:`__add__`, який приймає ``b``, все добре."

msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a value "
"from :meth:`__add__`, we'd miss the possibility that ``B`` defines a more "
"intelligent :meth:`__radd__`, so the boilerplate should return :const:"
"`NotImplemented` from :meth:`__add__`. (Or ``A`` may not implement :meth:"
"`__add__` at all.)"
msgstr ""
"Якщо ``A`` повернеться до шаблонного коду, і він мав би повернути значення "
"з :meth:`__add__`, ми упустимо можливість того, що ``B`` визначає більш "
"розумний :meth:`__radd__` , тому шаблон має повертати :const:"
"`NotImplemented` з :meth:`__add__`. (Або ``A`` може взагалі не "
"реалізовувати :meth:`__add__`.)"

msgid ""
"Then ``B``'s :meth:`__radd__` gets a chance. If it accepts ``a``, all is "
"well."
msgstr ""
"Тоді ``B`` :meth:`__radd__` отримує шанс. Якщо він приймає ``a``, все добре."

msgid ""
"If it falls back to the boilerplate, there are no more possible methods to "
"try, so this is where the default implementation should live."
msgstr ""
"Якщо він повернеться до шаблону, більше не буде можливих методів, які можна "
"спробувати, тому тут має бути реалізація за замовчуванням."

msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is ok, "
"because it was implemented with knowledge of ``A``, so it can handle those "
"instances before delegating to :class:`Complex`."
msgstr ""
"Якщо ``B <: A``, Python намагається ``B.__radd__`` перед ``A.__add__``. Це "
"нормально, тому що його було реалізовано зі знанням ``A``, тому він може "
"обробити ці випадки перед делегуванням :class:`Complex`."

msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge, "
"then the appropriate shared operation is the one involving the built in :"
"class:`complex`, and both :meth:`__radd__` s land there, so ``a+b == b+a``."
msgstr ""
"Якщо ``A <: Complex`` і ``B <: Real`` без спільного використання будь-яких "
"інших знань, то відповідною спільною операцією є та, що включає вбудований :"
"class:`complex`, і обидві :meth:`__radd__`s земля там, тому ``a+b == b+a``."

msgid ""
"Because most of the operations on any given type will be very similar, it "
"can be useful to define a helper function which generates the forward and "
"reverse instances of any given operator. For example, :class:`fractions."
"Fraction` uses::"
msgstr ""
"Оскільки більшість операцій над будь-яким заданим типом будуть дуже схожими, "
"може бути корисним визначити допоміжну функцію, яка генерує прямі та "
"зворотні екземпляри будь-якого даного оператора. Наприклад, :class:"
"`fractions.Fraction` використовує::"
