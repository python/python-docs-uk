# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- Реалізація :keyword:`!import`"

msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/__init__.py`"

msgid "Introduction"
msgstr "вступ"

msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to provide "
"the implementation of the :keyword:`import` statement (and thus, by "
"extension, the :func:`__import__` function) in Python source code. This "
"provides an implementation of :keyword:`!import` which is portable to any "
"Python interpreter. This also provides an implementation which is easier to "
"comprehend than one implemented in a programming language other than Python."
msgstr ""

msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"По-друге, компоненти для реалізації :keyword:`import` представлені в цьому "
"пакунку, що полегшує користувачам створення власних користувацьких об’єктів "
"(відомих загалом як :term:`importer`) для участі в процесі імпорту."

msgid ":ref:`import`"
msgstr ":ref:`import`"

msgid "The language reference for the :keyword:`import` statement."
msgstr "Посилання на мову для оператора :keyword:`import`."

msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`Специфікація пакетів <https://www.python.org/doc/essays/packages/>`__"

msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"Оригінальна специфікація пакетів. Деяка семантика змінилася з моменту "
"написання цього документа (наприклад, переспрямування на основі ``None`` у :"
"data:`sys.modules`)."

msgid "The :func:`.__import__` function"
msgstr "Функція :func:`.__import__`"

msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr "Оператор :keyword:`import` є синтаксичним цукром для цієї функції."

msgid ":pep:`235`"
msgstr ":pep:`235`"

msgid "Import on Case-Insensitive Platforms"
msgstr "Імпорт на платформи без урахування регістру"

msgid ":pep:`263`"
msgstr ":pep:`263`"

msgid "Defining Python Source Code Encodings"
msgstr "Визначення кодувань вихідного коду Python"

msgid ":pep:`302`"
msgstr ":pep:`302`"

msgid "New Import Hooks"
msgstr "Нові гачки імпорту"

msgid ":pep:`328`"
msgstr ":pep:`328`"

msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Імпорт: багаторядковий і абсолютний/відносний"

msgid ":pep:`366`"
msgstr ":pep:`366`"

msgid "Main module explicit relative imports"
msgstr "Явний відносний імпорт головного модуля"

msgid ":pep:`420`"
msgstr ":pep:`420`"

msgid "Implicit namespace packages"
msgstr "Неявні пакети простору імен"

msgid ":pep:`451`"
msgstr ":pep:`451`"

msgid "A ModuleSpec Type for the Import System"
msgstr "Тип ModuleSpec для системи імпорту"

msgid ":pep:`488`"
msgstr ":pep:`488`"

msgid "Elimination of PYO files"
msgstr "Видалення файлів PYO"

msgid ":pep:`489`"
msgstr ":pep:`489`"

msgid "Multi-phase extension module initialization"
msgstr "Багатофазна ініціалізація модуля розширення"

msgid ":pep:`552`"
msgstr ":pep:`552`"

msgid "Deterministic pycs"
msgstr "Детерміновані фото"

msgid ":pep:`3120`"
msgstr ":pep:`3120`"

msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Використання UTF-8 як вихідного кодування за умовчанням"

msgid ":pep:`3147`"
msgstr ":pep:`3147`"

msgid "PYC Repository Directories"
msgstr "Каталоги репозиторіїв PYC"

msgid "Functions"
msgstr "Функції"

msgid "An implementation of the built-in :func:`__import__` function."
msgstr "Реалізація вбудованої функції :func:`__import__`."

msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"Програмне імпортування модулів має використовувати :func:`import_module` "
"замість цієї функції."

msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Імпортувати модуль. Аргумент *name* визначає, який модуль імпортувати в "
"абсолютних чи відносних значеннях (наприклад, ``pkg.mod`` або ``..mod``). "
"Якщо ім’я вказано у відносних термінах, тоді в аргументі *package* має бути "
"встановлено ім’я пакета, який має діяти як прив’язка для визначення імені "
"пакета (наприклад, ``import_module('..mod', 'pkg' .subpkg')`` імпортує ``pkg."
"mod``)."

msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"Функція :func:`import_module` діє як спрощена оболонка навколо :func:"
"`importlib.__import__`. Це означає, що вся семантика функції походить від :"
"func:`importlib.__import__`. Найважливіша відмінність між цими двома "
"функціями полягає в тому, що :func:`import_module` повертає вказаний пакунок "
"або модуль (наприклад, ``pkg.mod``), а :func:`__import__` повертає пакунок "
"або модуль верхнього рівня (напр. ``пакет``)."

msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Якщо ви динамічно імпортуєте модуль, який було створено після того, як "
"інтерпретатор почав виконання (наприклад, створив вихідний файл Python), вам "
"може знадобитися викликати :func:`invalidate_caches`, щоб система імпорту "
"помітила новий модуль."

msgid "Parent packages are automatically imported."
msgstr "Батьківські пакети імпортуються автоматично."

msgid ""
"Find the loader for a module, optionally within the specified *path*. If the "
"module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case :"
"exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path` "
"is done. ``None`` is returned if no loader is found."
msgstr ""
"Знайдіть завантажувач для модуля, необов’язково в межах указаного *шляху*. "
"Якщо модуль знаходиться в :attr:`sys.modules`, тоді повертається ``sys."
"modules[name].__loader__`` (якщо завантажувач не буде ``None`` або не "
"встановлено, у такому випадку :exc:`ValueError` виникає). В іншому випадку "
"виконується пошук за допомогою :attr:`sys.meta_path`. ``None`` повертається, "
"якщо завантажувач не знайдено."

msgid ""
"A dotted name does not have its parents implicitly imported as that requires "
"loading them and that may not be desired. To properly import a submodule you "
"will need to import all parent packages of the submodule and use the correct "
"argument to *path*."
msgstr ""
"Ім’я з крапками не має неявно імпортованих батьків, оскільки це вимагає їх "
"завантаження, а це може бути небажаним. Щоб правильно імпортувати підмодуль, "
"вам потрібно буде імпортувати всі батьківські пакети підмодуля та "
"використати правильний аргумент для *шляху*."

msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr ""
"Якщо ``__loader__`` не встановлено, викличте :exc:`ValueError`, так само, як "
"коли для атрибута встановлено значення ``None``."

msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "Натомість використовуйте :func:`importlib.util.find_spec`."

msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Визнати недійсними внутрішні кеші засобів пошуку, які зберігаються в :data:"
"`sys.meta_path`. Якщо засіб пошуку реалізує ``invalidate_caches()``, тоді "
"він буде викликаний для виконання недійсності. Цю функцію слід викликати, "
"якщо будь-які модулі створюються/встановлюються під час роботи вашої "
"програми, щоб гарантувати, що всі шукачі помітять існування нового модуля."

msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Перезавантажте раніше імпортований *модуль*. Аргумент має бути об’єктом "
"модуля, тому він має бути успішно імпортований раніше. Це корисно, якщо ви "
"відредагували вихідний файл модуля за допомогою зовнішнього редактора і "
"хочете випробувати нову версію, не виходячи з інтерпретатора Python. "
"Поверненим значенням є об’єкт модуля (який може бути іншим, якщо повторне "
"імпортування спричиняє розміщення іншого об’єкта в :data:`sys.modules`)."

msgid "When :func:`reload` is executed:"
msgstr "Коли :func:`reload` виконується:"

msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"Код модуля Python перекомпілюється, а код рівня модуля повторно виконується, "
"визначаючи новий набір об’єктів, які прив’язуються до імен у словнику модуля "
"шляхом повторного використання :term:`loader`, який початково завантажив "
"модуль. Функція ``init`` модулів розширення не викликається вдруге."

msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Як і у випадку з усіма іншими об’єктами в Python, старі об’єкти "
"відновлюються лише після того, як їх кількість посилань зменшується до нуля."

msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Імена в просторі імен модуля оновлюються, щоб вказувати на будь-які нові або "
"змінені об’єкти."

msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Інші посилання на старі об’єкти (наприклад, імена, зовнішні по відношенню до "
"модуля) не повертаються до нових об’єктів і повинні бути оновлені в кожному "
"просторі імен, де вони зустрічаються, якщо це потрібно."

msgid "There are a number of other caveats:"
msgstr "Існує ряд інших застережень:"

msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Коли модуль перезавантажується, його словник (що містить глобальні змінні "
"модуля) зберігається. Перевизначення імен замінить старі визначення, тому "
"це, як правило, не проблема. Якщо нова версія модуля не визначає назву, яка "
"була визначена старою версією, старе визначення залишається. Цю функцію "
"можна використовувати на користь модуля, якщо він підтримує глобальну "
"таблицю або кеш об’єктів --- за допомогою оператора :keyword:`try` він може "
"перевірити наявність таблиці та за бажанням пропустити її ініціалізацію::"

msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Зазвичай не дуже корисно перезавантажувати вбудовані або динамічно "
"завантажувані модулі. Перезавантажувати :mod:`sys`, :mod:`__main__`, :mod:"
"`builtins` та інші ключові модулі не рекомендується. У багатьох випадках "
"модулі розширення не призначені для ініціалізації більше одного разу, і "
"можуть виникати будь-які збої під час перезавантаження."

msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"Якщо модуль імпортує об’єкти з іншого модуля за допомогою :keyword:"
"`from` ... :keyword:`import` ..., виклик :func:`reload` для іншого модуля не "
"перевизначає об’єкти, імпортовані з нього --- один із способів обійти це — "
"повторно виконати оператор :keyword:`!from`, інший — використати замість "
"нього :keyword:`!import` і кваліфіковані імена (*module.name*)."

msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Якщо модуль створює екземпляри класу, перезавантаження модуля, який визначає "
"клас, не впливає на визначення методів екземплярів --- вони продовжують "
"використовувати старе визначення класу. Те саме стосується похідних класів."

msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` виникає, коли модуль, який перезавантажується, не "
"має :class:`~importlib.machinery.ModuleSpec`."

msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- Абстрактні базові класи, пов'язані з імпортом"

msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/abc.py`"

msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
"Модуль :mod:`importlib.abc` містить усі основні абстрактні базові класи, які "
"використовуються :keyword:`import`. Деякі підкласи основних абстрактних "
"базових класів також надаються для допомоги в реалізації основних ABC."

msgid "ABC hierarchy::"
msgstr "Ієрархія ABC::"

msgid "An abstract base class representing a :term:`finder`."
msgstr "Абстрактний базовий клас, що представляє :term:`finder`."

msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr ""
"Замість цього використовуйте :class:`MetaPathFinder` або :class:"
"`PathEntryFinder`."

msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in :data:"
"`sys.meta_path` and in the path-based import subsystem."
msgstr ""
"Абстрактний метод пошуку :term:`loader` для вказаного модуля. Спочатку "
"вказаний у :pep:`302`, цей метод був призначений для використання в :data:"
"`sys.meta_path` і в підсистемі імпорту на основі шляху."

msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr ""
"Повертає ``None`` під час виклику замість виклику :exc:`NotImplementedError`."

msgid ""
"Implement :meth:`MetaPathFinder.find_spec` or :meth:`PathEntryFinder."
"find_spec` instead."
msgstr ""
"Натомість застосуйте :meth:`MetaPathFinder.find_spec` або :meth:"
"`PathEntryFinder.find_spec`."

msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "Абстрактний базовий клас, що представляє :term:`meta path finder`."

msgid "No longer a subclass of :class:`Finder`."
msgstr "Більше не є підкласом :class:`Finder`."

msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``MetaPathFinders``."
msgstr ""
"Абстрактний метод для пошуку :term:`spec <module spec>` для вказаного "
"модуля. Якщо це імпорт верхнього рівня, *path* матиме значення ``None``. В "
"іншому випадку це буде пошук підпакета або модуля, і *path* буде значенням :"
"attr:`__path__` з батьківського пакета. Якщо специфікацію неможливо знайти, "
"повертається ``None``. Коли передано, ``target`` є об’єктом модуля, який "
"шукач може використовувати, щоб зробити більш освічене припущення про те, "
"яку специфікацію потрібно повернути. :func:`importlib.util.spec_from_loader` "
"може бути корисним для реалізації конкретних ``MetaPathFinders``."

msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of :attr:"
"`__path__` from the parent package. If a loader cannot be found, ``None`` is "
"returned."
msgstr ""
"Застарілий метод пошуку :term:`loader` для вказаного модуля. Якщо це імпорт "
"верхнього рівня, *path* матиме значення ``None``. В іншому випадку це буде "
"пошук підпакета або модуля, і *path* буде значенням :attr:`__path__` з "
"батьківського пакета. Якщо завантажувач не знайдено, повертається ``None``."

msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ""
"Якщо визначено :meth:`find_spec`, надається функція зворотної сумісності."

msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""
"Повертає ``None`` під час виклику замість виклику :exc:"
"`NotImplementedError`. Можна використовувати :meth:`find_spec` для "
"забезпечення функціональності."

msgid "Use :meth:`find_spec` instead."
msgstr "Замість цього використовуйте :meth:`find_spec`."

msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"Додатковий метод, який під час виклику має зробити недійсним будь-який "
"внутрішній кеш, який використовує шукач. Використовується :func:`importlib."
"invalidate_caches` під час визнання недійсними кешів усіх засобів пошуку на :"
"data:`sys.meta_path`."

msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr "Повертає ``None`` під час виклику замість ``NotImplemented``."

msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
"Абстрактний базовий клас, що представляє :term:`path entry finder`. Хоча він "
"має певну схожість із :class:`MetaPathFinder`, ``PathEntryFinder`` "
"призначений для використання лише в підсистемі імпорту на основі шляху, яку "
"надає :class:`importlib.machinery.PathFinder`."

msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"Абстрактний метод для пошуку :term:`spec <module spec>` для вказаного "
"модуля. Шукач шукатиме модуль лише в межах :term:`path entry`, якому він "
"призначений. Якщо специфікацію неможливо знайти, повертається ``None``. Коли "
"передано, ``target`` є об’єктом модуля, який шукач може використовувати, щоб "
"зробити більш освічене припущення про те, яку специфікацію потрібно "
"повернути. :func:`importlib.util.spec_from_loader` може бути корисним для "
"реалізації конкретних ``PathEntryFinders``."

msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""
"Застарілий метод для пошуку :term:`loader` для вказаного модуля. Повертає 2-"
"кортеж ``(loader, portion)``, де ``portion`` – це послідовність розташувань "
"файлової системи, що входять до частини пакета простору імен. Завантажувач "
"може мати значення ``None``, коли вказано ``portion``, щоб позначити внесок "
"розташування файлової системи в пакет простору імен. Порожній список можна "
"використовувати для ``portion``, щоб вказати, що завантажувач не є частиною "
"пакета простору імен. Якщо ``завантажувач`` має значення ``None``, а "
"``порція`` є порожнім списком, тоді не знайдено завантажувача або "
"розташування для пакета простору імен (тобто неможливо знайти нічого для "
"модуля)."

msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr ""
"Якщо визначено :meth:`find_spec`, то надається функція зворотної сумісності."

msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses :"
"meth:`find_spec` when available to provide functionality."
msgstr ""
"Повертає ``(None, [])`` замість виклику :exc:`NotImplementedError`. "
"Використовує :meth:`find_spec`, коли доступний, щоб забезпечити "
"функціональність."

msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""
"Конкретна реалізація :meth:`Finder.find_module`, яка еквівалентна ``self."
"find_loader(fullname)[0]``."

msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"Додатковий метод, який під час виклику має зробити недійсним будь-який "
"внутрішній кеш, який використовує шукач. Використовується :meth:`importlib."
"machinery.PathFinder.invalidate_caches` під час визнання недійсними кешів "
"усіх кешованих засобів пошуку."

msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"Абстрактний базовий клас для :term:`loader`. Перегляньте :pep:`302` для "
"точного визначення завантажувача."

msgid ""
"Loaders that wish to support resource reading should implement a "
"``get_resource_reader(fullname)`` method as specified by :class:`importlib."
"abc.ResourceReader`."
msgstr ""

msgid "Introduced the optional ``get_resource_reader()`` method."
msgstr ""

msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"Метод, який повертає об’єкт модуля для використання під час імпорту модуля. "
"Цей метод може повертати ``None``, вказуючи, що семантика створення модуля "
"за замовчуванням має мати місце."

msgid ""
"Starting in Python 3.6, this method will not be optional when :meth:"
"`exec_module` is defined."
msgstr ""

msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when ``exec_module()`` is called. When this method exists, :meth:`~importlib."
"abc.Loader.create_module` must be defined."
msgstr ""

msgid ":meth:`~importlib.abc.Loader.create_module` must also be defined."
msgstr ""

msgid ""
"A legacy method for loading a module. If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""

msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import. If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""

msgid ""
"The loader should set several attributes on the module. (Note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""

msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

msgid "The name of the module."
msgstr ""

msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

msgid ""
"The path to where the module data is stored (not set for built-in modules)."
msgstr ""

msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

msgid ""
"The path to where a compiled version of the module is/should be stored (not "
"set when the attribute would be inappropriate)."
msgstr ""

msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr ""

msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

msgid ""
"The fully-qualified name of the package under which the module was loaded as "
"a submodule (or the empty string for top-level modules). For packages, it is "
"the same as :attr:`__name__`.  The :func:`importlib.util.module_for_loader` "
"decorator can handle the details for :attr:`__package__`."
msgstr ""

msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

msgid ""
"The loader used to load the module. The :func:`importlib.util."
"module_for_loader` decorator can handle the details for :attr:`__package__`."
msgstr ""

msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"Коли :meth:`exec_module` доступний, тоді надається функція зворотної "
"сумісності."

msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`. "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""

msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of load_module().  "
"The import machinery takes care of all the other responsibilities of "
"load_module() when exec_module() is implemented."
msgstr ""

msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's repr, as a string. The module type's default repr() will use the "
"result of this method as appropriate."
msgstr ""

msgid "Made optional instead of an abstractmethod."
msgstr "Зроблено необов’язковим замість абстрактного методу."

msgid "The import machinery now takes care of this automatically."
msgstr "Імпортний механізм тепер подбає про це автоматично."

msgid "*Superseded by TraversableResources*"
msgstr "*Замінено TraversableResources*"

msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ":term:`abstract base class` для надання можливості читати *ресурси*."

msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored in a e.g. zip "
"file versus on the file system."
msgstr ""
"З точки зору цієї ABC, *ресурс* — це бінарний артефакт, який доставляється в "
"пакеті. Зазвичай це щось на зразок файлу даних, який знаходиться поруч із "
"файлом ``__init__.py`` файлу пакета. Мета цього класу полягає в тому, щоб "
"допомогти абстрагуватися від доступу до таких файлів даних, щоб не мати "
"значення, чи зберігається пакет і його файл(и) даних у, наприклад, zip-файл "
"проти файлової системи."

msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"Для будь-якого методу цього класу очікується, що аргумент *resource* буде :"
"term:`path-like object`, який концептуально представляє лише ім’я файлу. Це "
"означає, що шляхи підкаталогів не повинні включатися в аргумент *resource*. "
"Це пояснюється тим, що місце розташування пакета, для якого призначений "
"зчитувач, діє як \"каталог\". Тому метафорою для каталогів і імен файлів є "
"пакети та ресурси відповідно. Ось чому очікується, що екземпляри цього класу "
"безпосередньо співвідносяться з певним пакетом (замість того, щоб потенційно "
"представляти кілька пакетів або модуль)."

msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""
"Очікується, що завантажувачі, які бажають підтримувати читання ресурсів, "
"нададуть метод під назвою ``get_resource_reader(fullname)``, який повертає "
"об’єкт, що реалізує цей інтерфейс ABC. Якщо модуль, указаний повним іменем, "
"не є пакетом, цей метод має повернути :const:`None`. Об’єкт, сумісний із цим "
"ABC, слід повертати лише тоді, коли вказаний модуль є пакетом."

msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Повертає відкритий :term:`file-like object` для двійкового читання *ресурсу*."

msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "Якщо ресурс не знайдено, виникає :exc:`FileNotFoundError`."

msgid "Returns the file system path to the *resource*."
msgstr "Повертає шлях файлової системи до *ресурсу*."

msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"Якщо ресурс конкретно не існує у файловій системі, викликайте :exc:"
"`FileNotFoundError`."

msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Повертає ``True``, якщо назване *ім’я* вважається ресурсом. :exc:"
"`FileNotFoundError` виникає, якщо *name* не існує."

msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""
"Повертає :term:`iterable` рядків над вмістом пакета. Зауважте, що не "
"обов’язково, щоб усі імена, які повертає ітератор, були фактичними "
"ресурсами, наприклад. прийнятно повертати імена, для яких :meth:"
"`is_resource` буде false."

msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""
"Дозволити повертати нересурсні імена, щоб дозволити ситуації, коли те, як "
"пакет і його ресурси зберігаються, відомі апріорі, і нересурсні імена будуть "
"корисними. Наприклад, дозволено повертати імена підкаталогів, щоб, якщо "
"відомо, що пакет і ресурси зберігаються у файловій системі, ці імена "
"підкаталогів можна було використовувати безпосередньо."

msgid "The abstract method returns an iterable of no items."
msgstr "Абстрактний метод повертає ітерацію без елементів."

msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"Абстрактний базовий клас для :term:`loader`, який реалізує необов’язковий "
"протокол :pep:`302` для завантаження довільних ресурсів із внутрішнього "
"сховища."

msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.abc.ResourceReader`."
msgstr ""
"Цей ABC застарів на користь підтримки завантаження ресурсів через :class:"
"`importlib.abc.ResourceReader`."

msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"Абстрактний метод для повернення байтів для даних, розташованих за *шляхом*. "
"Завантажувачі, які мають серверну систему зберігання, подібну до файлів, яка "
"дозволяє зберігати довільні дані, можуть реалізувати цей абстрактний метод, "
"щоб надати прямий доступ до збережених даних. :exc:`OSError` виникає, якщо "
"*шлях* не може бути знайдений. Очікується, що *шлях* буде створено за "
"допомогою атрибута :attr:`__file__` модуля або елемента з :attr:`__path__` "
"пакета."

msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Викликає :exc:`OSError` замість :exc:`NotImplementedError`."

msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Абстрактний базовий клас для :term:`loader`, який реалізує додатковий "
"протокол :pep:`302` для завантажувачів, які перевіряють модулі."

msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Повертає об’єкт коду для модуля або ``None``, якщо модуль не має об’єкта "
"коду (як, наприклад, у випадку вбудованого модуля). Викликати :exc:"
"`ImportError`, якщо завантажувач не може знайти запитуваний модуль."

msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Хоча метод має реалізацію за замовчуванням, пропонується замінити його, якщо "
"це можливо для продуктивності."

msgid "No longer abstract and a concrete implementation is provided."
msgstr "Більше не абстрактне, а конкретна реалізація."

msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"Абстрактний метод для повернення вихідного коду модуля. Він повертається як "
"текстовий рядок з використанням :term:`universal newlines`, переводячи всі "
"розпізнані роздільники рядків у символи ``'\\n'``. Повертає ``None``, якщо "
"джерело недоступне (наприклад, вбудований модуль). Викликає :exc:"
"`ImportError`, якщо завантажувач не може знайти вказаний модуль."

msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Викликає :exc:`ImportError` замість :exc:`NotImplementedError`."

msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"Додатковий метод для повернення істинного значення, якщо модуль є пакетом, і "
"хибного значення в іншому випадку. :exc:`ImportError` виникає, якщо :term:"
"`loader` не може знайти модуль."

msgid "Create a code object from Python source."
msgstr "Створіть об’єкт коду з джерела Python."

msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"Аргументом *data* може бути те, що підтримує функція :func:`compile` (тобто "
"рядок або байти). Аргумент *path* має бути \"шляхом\", звідки походить "
"вихідний код, що може бути абстрактним поняттям (наприклад, розташуванням у "
"файлі zip)."

msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"З наступним об’єктом коду можна виконати його в модулі, запустивши "
"``exec(code, module.__dict__)``."

msgid "Made the method static."
msgstr "Зробив метод статичним."

msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Реалізація :meth:`Loader.exec_module`."

msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Реалізація :meth:`Loader.load_module`."

msgid "use :meth:`exec_module` instead."
msgstr "замість цього використовуйте :meth:`exec_module`."

msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Абстрактний базовий клас, успадкований від :class:`InspectLoader`, який, "
"реалізований, допомагає модулю виконуватися як сценарій. ABC представляє "
"необов’язковий протокол :pep:`302`."

msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"Абстрактний метод, який повертає значення :attr:`__file__` для зазначеного "
"модуля. Якщо шлях недоступний, виникає :exc:`ImportError`."

msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Якщо вихідний код доступний, тоді метод має повертати шлях до вихідного "
"файлу, незалежно від того, чи використовувався байт-код для завантаження "
"модуля."

msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Абстрактний базовий клас, який успадковує :class:`ResourceLoader` і :class:"
"`ExecutionLoader`, надаючи конкретні реалізації :meth:`ResourceLoader."
"get_data` і :meth:`ExecutionLoader.get_filename`."

msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"Аргумент *повне ім’я* — це повністю визначене ім’я модуля, який має "
"обробляти завантажувач. Аргумент *path* — це шлях до файлу модуля."

msgid "The name of the module the loader can handle."
msgstr "Назва модуля, який може обробляти завантажувач."

msgid "Path to the file of the module."
msgstr "Шлях до файлу модуля."

msgid "Calls super's ``load_module()``."
msgstr "Викликає ``load_module()`` супер."

msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Натомість використовуйте :meth:`Loader.exec_module`."

msgid "Returns :attr:`path`."
msgstr "Повертає :attr:`path`."

msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Читає *шлях* як двійковий файл і повертає байти з нього."

msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Абстрактний базовий клас для реалізації вихідного (і необов’язково байт-"
"коду) завантаження файлу. Клас успадковує як :class:`ResourceLoader`, так і :"
"class:`ExecutionLoader`, що вимагає реалізації:"

msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Має повертати лише шлях до вихідного файлу; завантаження без джерел не "
"підтримується."

msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Абстрактні методи, визначені цим класом, призначені для додавання додаткової "
"підтримки файлу байт-коду. Нереалізація цих додаткових методів (або виклик "
"їх :exc:`NotImplementedError`) змушує завантажувач працювати лише з вихідним "
"кодом. Реалізація методів дозволяє завантажувачу працювати з вихідними *та* "
"файлами байт-коду; він не допускає *безджерельного* завантаження, де "
"надається лише байт-код. Файли байт-коду є оптимізацією для прискорення "
"завантаження шляхом видалення кроку синтаксичного аналізу компілятора "
"Python, тому API, специфічний для байт-коду, не розкривається."

msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Додатковий абстрактний метод, який повертає :class:`dict`, що містить "
"метадані про вказаний шлях. Підтримувані ключі словника:"

msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (обов'язковий): ціле число або число з плаваючою комою, що "
"представляє час модифікації вихідного коду;"

msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (необов'язковий): розмір у байтах вихідного коду."

msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Будь-які інші ключі в словнику ігноруються, щоб дозволити майбутні "
"розширення. Якщо шлях не можна обробити, виникає :exc:`OSError`."

msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Викликати :exc:`OSError` замість :exc:`NotImplementedError`."

msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Додатковий абстрактний метод, який повертає час модифікації для вказаного "
"шляху."

msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Цей метод застарів на користь :meth:`path_stats`. Вам не потрібно його "
"впроваджувати, але він все ще доступний для цілей сумісності. Викликати :exc:"
"`OSError`, якщо шлях неможливо обробити."

msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Додатковий абстрактний метод, який записує вказані байти в шлях до файлу. "
"Будь-які проміжні каталоги, яких не існує, створюються автоматично."

msgid ""
"When writing to the path fails because the path is read-only (:attr:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""
"Якщо запис у шлях не вдається через те, що шлях доступний лише для читання (:"
"attr:`errno.EACCES`/:exc:`PermissionError`), не поширюйте виняткову ситуацію."

msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Більше не викликає :exc:`NotImplementedError` під час виклику."

msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Конкретна реалізація :meth:`InspectLoader.get_code`."

msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Конкретна реалізація :meth:`Loader.exec_module`."

msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Конкретна реалізація :meth:`Loader.load_module`."

msgid "Use :meth:`exec_module` instead."
msgstr "Замість цього використовуйте :meth:`exec_module`."

msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Конкретна реалізація :meth:`InspectLoader.get_source`."

msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Конкретна реалізація :meth:`InspectLoader.is_package`. Модуль вважається "
"пакетом, якщо його шлях до файлу (як надано :meth:`ExecutionLoader."
"get_filename`) є файлом з назвою ``__init__``, коли розширення файлу "
"видалено **і** сама назва модуля не закінчується на ``__init__``."

msgid ""
"An object with a subset of pathlib.Path methods suitable for traversing "
"directories and opening files."
msgstr ""
"Об’єкт із підмножиною методів pathlib.Path, придатних для обходу каталогів і "
"відкриття файлів."

msgid "The base name of this object without any parent references."
msgstr ""

msgid "Yield Traversable objects in self."
msgstr "Прибуток Traversable об'єктів в себе."

msgid "Return True if self is a directory."
msgstr "Повертає True, якщо self є каталогом."

msgid "Return True if self is a file."
msgstr "Повертає True, якщо self є файлом."

msgid "Return Traversable child in self."
msgstr "Повернення Прохідної дитини в себе."

msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* може бути \"r\" або \"rb\", щоб відкрити як текстовий або двійковий "
"файл. Повертає дескриптор, придатний для читання (те саме, що :attr:`pathlib."
"Path.open`)."

msgid ""
"When opening as text, accepts encoding parameters such as those accepted by :"
"attr:`io.TextIOWrapper`."
msgstr ""
"Коли відкривається як текст, приймає параметри кодування, такі як ті, які "
"приймає :attr:`io.TextIOWrapper`."

msgid "Read contents of self as bytes."
msgstr "Читати вміст себе як байти."

msgid "Read contents of self as text."
msgstr "Прочитати вміст себе як текст."

msgid ""
"An abstract base class for resource readers capable of serving the ``files`` "
"interface. Subclasses ResourceReader and provides concrete implementations "
"of the ResourceReader's abstract methods. Therefore, any loader supplying "
"TraversableReader also supplies ResourceReader."
msgstr ""

msgid ""
"Loaders that wish to support resource reading are expected to implement this "
"interface."
msgstr ""
"Очікується, що завантажувачі, які бажають підтримувати читання ресурсів, "
"реалізують цей інтерфейс."

msgid ":mod:`importlib.resources` -- Resources"
msgstr ""

msgid "**Source code:** :source:`Lib/importlib/resources.py`"
msgstr ""

msgid ""
"This module leverages Python's import system to provide access to "
"*resources* within *packages*.  If you can import a package, you can access "
"resources within that package.  Resources can be opened or read, in either "
"binary or text mode."
msgstr ""

msgid ""
"Resources are roughly akin to files inside directories, though it's "
"important to keep in mind that this is just a metaphor.  Resources and "
"packages **do not** have to exist as physical files and directories on the "
"file system."
msgstr ""

msgid ""
"This module provides functionality similar to `pkg_resources <https://"
"setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ `Basic Resource "
"Access <http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-"
"resource-access>`_ without the performance overhead of that package.  This "
"makes reading resources included in packages easier, with more stable and "
"consistent semantics."
msgstr ""

msgid ""
"The standalone backport of this module provides more information on `using "
"importlib.resources <http://importlib-resources.readthedocs.io/en/latest/"
"using.html>`_ and `migrating from pkg_resources to importlib.resources "
"<http://importlib-resources.readthedocs.io/en/latest/migration.html>`_."
msgstr ""

msgid "The following types are defined."
msgstr ""

msgid ""
"The ``Package`` type is defined as ``Union[str, ModuleType]``.  This means "
"that where the function describes accepting a ``Package``, you can pass in "
"either a string or a module.  Module objects must have a resolvable "
"``__spec__.submodule_search_locations`` that is not ``None``."
msgstr ""

msgid ""
"This type describes the resource names passed into the various functions in "
"this package.  This is defined as ``Union[str, os.PathLike]``."
msgstr ""

msgid "The following functions are available."
msgstr ""

msgid ""
"Returns an :class:`importlib.resources.abc.Traversable` object representing "
"the resource container for the package (think directory) and its resources "
"(think files). A Traversable may contain other containers (think "
"subdirectories)."
msgstr ""

msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""

msgid ""
"Given a :class:`importlib.resources.abc.Traversable` object representing a "
"file, typically from :func:`importlib.resources.files`, return a context "
"manager for use in a :keyword:`with` statement. The context manager provides "
"a :class:`pathlib.Path` object."
msgstr ""

msgid ""
"Exiting the context manager cleans up any temporary file created when the "
"resource was extracted from e.g. a zip file."
msgstr ""

msgid ""
"Use ``as_file`` when the Traversable methods (``read_text``, etc) are "
"insufficient and an actual file on the file system is required."
msgstr ""

msgid "Open for binary reading the *resource* within *package*."
msgstr ""

msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  This function returns a ``typing."
"BinaryIO`` instance, a binary I/O stream open for reading."
msgstr ""

msgid ""
"Open for text reading the *resource* within *package*.  By default, the "
"resource is opened for reading as UTF-8."
msgstr ""

msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  *encoding* and *errors* have the "
"same meaning as with built-in :func:`open`."
msgstr ""

msgid ""
"This function returns a ``typing.TextIO`` instance, a text I/O stream open "
"for reading."
msgstr ""

msgid ""
"Read and return the contents of the *resource* within *package* as ``bytes``."
msgstr ""

msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  This function returns the "
"contents of the resource as :class:`bytes`."
msgstr ""

msgid ""
"Read and return the contents of *resource* within *package* as a ``str``. By "
"default, the contents are read as strict UTF-8."
msgstr ""

msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  *encoding* and *errors* have the "
"same meaning as with built-in :func:`open`.  This function returns the "
"contents of the resource as :class:`str`."
msgstr ""

msgid ""
"Return the path to the *resource* as an actual file system path.  This "
"function returns a context manager for use in a :keyword:`with` statement. "
"The context manager provides a :class:`pathlib.Path` object."
msgstr ""

msgid ""
"Exiting the context manager cleans up any temporary file created when the "
"resource needs to be extracted from e.g. a zip file."
msgstr ""

msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory)."
msgstr ""

msgid ""
"Return ``True`` if there is a resource named *name* in the package, "
"otherwise ``False``.  Remember that directories are *not* resources! "
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""

msgid ""
"Return an iterable over the named items within the package.  The iterable "
"returns :class:`str` resources (e.g. files) and non-resources (e.g. "
"directories).  The iterable does not recurse into subdirectories."
msgstr ""

msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Імпортери та перехоплювачі шляху"

msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/machinery.py`"

msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Цей модуль містить різноманітні об’єкти, які допомагають :keyword:`import` "
"знаходити та завантажувати модулі."

msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"Список рядків, що представляють розпізнані суфікси файлів для вихідних "
"модулів."

msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"Список рядків, що представляють суфікси файлів для неоптимізованих модулів "
"байт-коду."

msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "Натомість використовуйте :attr:`BYTECODE_SUFFIXES`."

msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"Список рядків, що представляють суфікси файлів для оптимізованих модулів "
"байт-коду."

msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"Список рядків, що представляють розпізнані суфікси файлів для модулів байт-"
"коду (включно з початковою крапкою)."

msgid "The value is no longer dependent on ``__debug__``."
msgstr "Значення більше не залежить від ``__debug__``."

msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"Список рядків, що представляють розпізнані суфікси файлів для модулів "
"розширення."

msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"Повертає комбінований список рядків, що представляють усі суфікси файлів для "
"модулів, розпізнаних стандартним механізмом імпорту. Це допоміжний засіб для "
"коду, якому просто потрібно знати, чи шлях до файлової системи потенційно "
"посилається на модуль, не потребуючи жодних деталей щодо типу модуля "
"(наприклад, :func:`inspect.getmodulename`)."

msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
":term:`importer` для вбудованих модулів. Усі відомі вбудовані модулі "
"перераховані в :data:`sys.builtin_module_names`. Цей клас реалізує ABC :"
"class:`importlib.abc.MetaPathFinder` і :class:`importlib.abc.InspectLoader`."

msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"У цьому класі визначені лише методи класу, щоб полегшити потребу в створенні "
"екземплярів."

msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Як частина :pep:`489`, вбудований імпортер тепер реалізує :meth:`Loader."
"create_module` і :meth:`Loader.exec_module`"

msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
":term:`importer` для заморожених модулів. Цей клас реалізує ABC :class:"
"`importlib.abc.MetaPathFinder` і :class:`importlib.abc.InspectLoader`."

msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""
"Отримано методи :meth:`~Loader.create_module` і :meth:`~Loader.exec_module`."

msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` для модулів, оголошених у реєстрі Windows. Цей клас "
"реалізує :class:`importlib.abc.MetaPathFinder` ABC."

msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Натомість використовуйте конфігурацію :mod:`site`. Майбутні версії Python "
"можуть не вмикати цей засіб пошуку за замовчуванням."

msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"A :term:`Finder <finder>` для атрибутів :data:`sys.path` і пакета "
"``__path__``. Цей клас реалізує :class:`importlib.abc.MetaPathFinder` ABC."

msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"Метод класу, який намагається знайти :term:`spec <module spec>` для модуля, "
"указаного *повним ім’ям* у :data:`sys.path` або, якщо визначено, у *path*. "
"Для кожного запису шляху, який шукається, перевіряється :data:`sys."
"path_importer_cache`. Якщо знайдено нефальшивий об’єкт, він використовується "
"як :term:`path entry finder` для пошуку модуля, який шукається. Якщо в :data:"
"`sys.path_importer_cache` не знайдено жодного запису, тоді :data:`sys."
"path_hooks` шукає засіб пошуку для запису шляху та, якщо знайдено, "
"зберігається в :data:`sys.path_importer_cache` із запитанням про модуль. "
"Якщо жоден шукач не знайдено, тоді ``None`` зберігається в кеші та "
"повертається."

msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"Якщо поточний робочий каталог, представлений порожнім рядком, більше не "
"дійсний, тоді повертається ``None``, але жодне значення не кешується в :data:"
"`sys.path_importer_cache`."

msgid "A legacy wrapper around :meth:`find_spec`."
msgstr "Застаріла обгортка навколо :meth:`find_spec`."

msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Викликає :meth:`importlib.abc.PathEntryFinder.invalidate_caches` для всіх "
"засобів пошуку, збережених у :data:`sys.path_importer_cache`, які визначають "
"метод. Інакше записи в :data:`sys.path_importer_cache`, для яких встановлено "
"значення ``None``, видаляються."

msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr "Записи ``None`` у :data:`sys.path_importer_cache` видаляються."

msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Викликає об’єкти в :data:`sys.path_hooks` з поточним робочим каталогом для "
"``''`` (тобто порожній рядок)."

msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.PathEntryFinder`, яка кешує "
"результати з файлової системи."

msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "Аргумент *шлях* — це каталог, пошук якого відповідає за пошук."

msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"Аргумент *loader_details* — це змінна кількість кортежів із 2 елементів, "
"кожен із яких містить завантажувач і послідовність суфіксів файлів, які "
"розпізнає завантажувач. Очікується, що завантажувачі будуть викликаними, які "
"приймають два аргументи імені модуля та шляху до знайденого файлу."

msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"Засіб пошуку кешуватиме вміст каталогу за потреби, виконуючи stat виклики "
"для кожного пошуку модуля, щоб переконатися, що кеш не застарів. Оскільки "
"нестабільність кешу залежить від деталізації інформації про стан операційної "
"системи файлової системи, існує потенційна конкуренція щодо пошуку модуля, "
"створення нового файлу, а потім пошуку модуля, який представляє новий файл. "
"Якщо операції відбуваються досить швидко, щоб відповідати деталізації "
"викликів stat, пошук модулів не вдасться. Щоб цього не сталося, під час "
"динамічного створення модуля обов’язково викликайте :func:`importlib."
"invalidate_caches`."

msgid "The path the finder will search in."
msgstr "Шлях, за яким шукач шукатиме."

msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Спробуйте знайти специфікацію для обробки *повного імені* в :attr:`path`."

msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ""
"Спробуйте знайти завантажувач для обробки *повного імені* в межах :attr:"
"`path`."

msgid "Clear out the internal cache."
msgstr "Очистіть внутрішній кеш."

msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"Метод класу, який повертає закриття для використання на :attr:`sys."
"path_hooks`. Екземпляр :class:`FileFinder` повертається закриттям за "
"допомогою аргументу шляху, наданого замиканню безпосередньо та "
"*loader_details* опосередковано."

msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"Якщо аргумент закриття не є існуючим каталогом, виникає :exc:`ImportError`."

msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.SourceLoader` шляхом створення "
"підкласу :class:`importlib.abc.FileLoader` і надання деяких конкретних "
"реалізацій інших методів."

msgid "The name of the module that this loader will handle."
msgstr "Назва модуля, який оброблятиме цей завантажувач."

msgid "The path to the source file."
msgstr "Шлях до вихідного файлу."

msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Повертає ``True``, якщо :attr:`path` є для пакета."

msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr "Конкретна реалізація :meth:`importlib.abc.SourceLoader.path_stats`."

msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "Конкретна реалізація :meth:`importlib.abc.SourceLoader.set_data`."

msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Конкретна реалізація :meth:`importlib.abc.Loader.load_module`, де вказувати "
"назву модуля для завантаження необов’язково."

msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Замість цього використовуйте :meth:`importlib.abc.Loader.exec_module`."

msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.FileLoader`, яка може імпортувати "
"файли байт-коду (тобто файлів вихідного коду не існує)."

msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"Зауважте, що пряме використання файлів байт-коду (а отже, не файлів "
"вихідного коду) перешкоджає використанню ваших модулів усіма реалізаціями "
"Python або новими версіями Python, які змінюють формат байт-коду."

msgid "The name of the module the loader will handle."
msgstr "Назва модуля, який оброблятиме завантажувач."

msgid "The path to the bytecode file."
msgstr "Шлях до файлу байт-коду."

msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Визначає, чи є модуль пакетом на основі :attr:`path`."

msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr "Повертає об’єкт коду для :attr:`name`, створеного з :attr:`path`."

msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Повертає ``None``, оскільки файли байт-коду не мають джерела, коли "
"використовується цей завантажувач."

msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.ExecutionLoader` для модулів "
"розширення."

msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"Аргумент *fullname* вказує назву модуля, який має підтримувати завантажувач. "
"Аргумент *path* — це шлях до файлу модуля розширення."

msgid "Name of the module the loader supports."
msgstr "Назва модуля, який підтримує завантажувач."

msgid "Path to the extension module."
msgstr "Шлях до модуля розширення."

msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr "Створює об’єкт модуля з заданої специфікації відповідно до :pep:`489`."

msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Ініціалізує вказаний об’єкт модуля відповідно до :pep:`489`."

msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
"Повертає ``True``, якщо шлях до файлу вказує на модуль ``__init__`` пакета "
"на основі :attr:`EXTENSION_SUFFIXES`."

msgid "Returns ``None`` as extension modules lack a code object."
msgstr "Повертає ``None``, оскільки модулі розширення не мають об’єкта коду."

msgid "Returns ``None`` as extension modules do not have source code."
msgstr "Повертає ``None``, оскільки модулі розширення не мають вихідного коду."

msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's ``__spec__`` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object. E.g. ``module.__spec__."
"origin == module.__file__``.  Note however that while the *values* are "
"usually equivalent, they can differ since there is no synchronization "
"between the two objects.  Thus it is possible to update the module's "
"``__path__`` at runtime, and this will not be automatically reflected in "
"``__spec__.submodule_search_locations``."
msgstr ""

msgid "(``__name__``)"
msgstr ""

msgid "A string for the fully-qualified name of the module."
msgstr ""

msgid "(``__loader__``)"
msgstr ""

msgid ""
"The :term:`Loader <loader>` that should be used when loading the module.  :"
"term:`Finders <finder>` should always set this."
msgstr ""

msgid "(``__file__``)"
msgstr ""

msgid ""
"Name of the place from which the module is loaded, e.g. \"builtin\" for "
"built-in modules and the filename for modules loaded from source. Normally "
"\"origin\" should be set, but it may be ``None`` (the default) which "
"indicates it is unspecified (e.g. for namespace packages)."
msgstr ""

msgid "(``__path__``)"
msgstr ""

msgid ""
"List of strings for where to find submodules, if a package (``None`` "
"otherwise)."
msgstr ""

msgid ""
"Container of extra module-specific data for use during loading (or ``None``)."
msgstr ""

msgid "(``__cached__``)"
msgstr ""

msgid "String for where the compiled module should be stored (or ``None``)."
msgstr ""

msgid "(``__package__``)"
msgstr ""

msgid ""
"(Read-only) The fully-qualified name of the package under which the module "
"should be loaded as a submodule (or the empty string for top-level modules). "
"For packages, it is the same as :attr:`__name__`."
msgstr ""

msgid ""
"Boolean indicating whether or not the module's \"origin\" attribute refers "
"to a loadable location."
msgstr ""

msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- Код утиліти для імпортерів"

msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/util.py`"

msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""
"Цей модуль містить різні об’єкти, які допомагають у створенні :term:"
"`importer`."

msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Байти, які представляють номер версії байт-коду. Якщо вам потрібна допомога "
"із завантаженням/записом байт-коду, скористайтеся :class:`importlib.abc."
"SourceLoader`."

msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"Поверніть шлях :pep:`3147`/:pep:`488` до скомпільованого файлу, пов’язаного "
"з вихідним *шляхом*. Наприклад, якщо *path* є ``/foo/bar/baz.py``, значення, "
"що повертається, буде ``/foo/bar/__pycache__/baz.cpython-32.pyc`` для Python "
"3.2. Рядок ``cpython-32`` походить від поточного магічного тегу (див. :func:"
"`get_tag`; якщо :attr:`sys.implementation.cache_tag` не визначено, тоді буде "
"викликана :exc:`NotImplementedError`)."

msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"Параметр *optimization* використовується для визначення рівня оптимізації "
"файлу байт-коду. Порожній рядок не означає оптимізації, тому ``/foo/bar/baz."
"py`` з *оптимізацією* ``''`` призведе до шляху байт-коду ``/foo/bar/"
"__pycache__/baz. cpython-32.pyc``. ``None`` спричиняє використання рівня "
"оптимізації інтерпретатора. Використовується будь-яке інше представлення "
"рядка значення, тому ``/foo/bar/baz.py`` з *оптимізацією* ``2`` призведе до "
"шляху байт-коду ``/foo/bar/__pycache__/baz. cpython-32.opt-2.pyc``. Рядкове "
"представлення *оптимізації* може бути лише буквено-цифровим, інакше виникає :"
"exc:`ValueError`."

msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"Параметр *debug_override* є застарілим і може використовуватися для заміни "
"системного значення для ``__debug__``. Значення ``True`` є еквівалентом "
"налаштування *optimization* для порожнього рядка. Значення ``False`` те "
"саме, що встановити *optimization* на ``1``. Якщо *debug_override* і "
"*оптимізація* не мають значення ``None``, тоді виникає :exc:`TypeError`."

msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"Параметр *optimization* було додано, а параметр *debug_override* визнано "
"застарілим."

msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Враховуючи *шлях* до імені файлу :pep:`3147`, поверніть пов’язаний шлях до "
"файлу вихідного коду. Наприклад, якщо *шлях* є ``/foo/bar/__pycache__/baz."
"cpython-32.pyc``, повернутий шлях буде ``/foo/bar/baz.py``. *path* не "
"обов’язково існує, однак якщо він не відповідає формату :pep:`3147` або :pep:"
"`488`, виникає помилка :exc:`ValueError`. Якщо :attr:`sys.implementation."
"cache_tag` не визначено, виникає :exc:`NotImplementedError`."

msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"Декодуйте задані байти, що представляють вихідний код, і поверніть його як "
"рядок із універсальними символами нового рядка (як вимагає :meth:`importlib."
"abc.InspectLoader.get_source`)."

msgid "Resolve a relative module name to an absolute one."
msgstr "Розділіть відносну назву модуля на абсолютну."

msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"Якщо **ім’я** не має початкових крапок, то **ім’я** просто повертається. Це "
"дозволяє використовувати таке як ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` без виконання перевірки, щоб побачити, чи потрібен "
"аргумент **package**."

msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""

msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"Щоб покращити узгодженість із операторами імпорту, підніміть :exc:"
"`ImportError` замість :exc:`ValueError` для недійсних відносних спроб "
"імпорту."

msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""
"Знайдіть :term:`spec <module spec>` для модуля, необов’язково відносно "
"вказаної назви **пакета**. Якщо модуль знаходиться в :attr:`sys.modules`, "
"тоді повертається ``sys.modules[name].__spec__`` (якщо специфікація не буде "
"``None`` або не встановлена, у такому випадку :exc:`ValueError` виникає). В "
"іншому випадку виконується пошук за допомогою :attr:`sys.meta_path`. "
"``None`` повертається, якщо специфікація не знайдена."

msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Якщо **назва** призначена для підмодуля (містить крапку), батьківський "
"модуль імпортується автоматично."

msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""
"**name** і **package** працюють так само, як і для :func:`import_module`."

msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""
"Викликає :exc:`ModuleNotFoundError` замість :exc:`AttributeError`, якщо "
"**package** насправді не є пакетом (тобто не має атрибута :attr:`__path__`)."

msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Створіть новий модуль на основі **spec** і :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Якщо :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"не повертає ``None``, тоді будь-які раніше існуючі атрибути не будуть "
"скинуті. Крім того, помилка :exc:`AttributeError` не буде викликана, якщо "
"вона буде активована під час доступу до **spec** або встановлення атрибута в "
"модулі."

msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Цій функції краще використовувати :class:`types.ModuleType` для створення "
"нового модуля, оскільки **spec** використовується для встановлення якомога "
"більшої кількості керованих імпортом атрибутів для модуля."

msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not "
"work on static methods because of the assumption of two arguments."
msgstr ""
":term:`decorator` для :meth:`importlib.abc.Loader.load_module` для обробки "
"вибору належного об’єкта модуля для завантаження. Очікується, що декорований "
"метод матиме підпис виклику, що приймає два позиційні аргументи (наприклад, "
"``load_module(self, module)``), для яких другим аргументом буде **об’єкт** "
"модуля, який використовуватиме завантажувач. Зверніть увагу, що декоратор не "
"працюватиме зі статичними методами через припущення двох аргументів."

msgid ""
"The decorated method will take in the **name** of the module to be loaded as "
"expected for a :term:`loader`. If the module is not found in :data:`sys."
"modules` then a new one is constructed. Regardless of where the module came "
"from, :attr:`__loader__` set to **self** and :attr:`__package__` is set "
"based on what :meth:`importlib.abc.InspectLoader.is_package` returns (if "
"available). These attributes are set unconditionally to support reloading."
msgstr ""
"Декорований метод прийматиме **ім’я** модуля, який буде завантажено, як "
"очікувалося для :term:`loader`. Якщо модуль не знайдено в :data:`sys."
"modules`, буде створено новий. Незалежно від того, звідки взявся модуль, :"
"attr:`__loader__` встановлюється на **self**, а :attr:`__package__` "
"встановлюється на основі того, що повертає :meth:`importlib.abc."
"InspectLoader.is_package` (якщо доступно) . Ці атрибути встановлюються "
"безумовно для підтримки перезавантаження."

msgid ""
"If an exception is raised by the decorated method and a module was added to :"
"data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""
"Якщо декорований метод викликає виняток і модуль додається до :data:`sys."
"modules`, тоді модуль буде видалено, щоб запобігти частково ініціалізованому "
"модулю, який залишився в :data:`sys.modules`. Якщо модуль уже був у :data:"
"`sys.modules`, то він залишається в спокої."

msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ""
":attr:`__loader__` і :attr:`__package__` встановлюються автоматично (якщо це "
"можливо)."

msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally "
"to support reloading."
msgstr ""
"Налаштуйте :attr:`__name__`, :attr:`__loader__` :attr:`__package__` без "
"умовної підтримки перезавантаження."

msgid ""
"The import machinery now directly performs all the functionality provided by "
"this function."
msgstr ""
"Механізм імпорту тепер безпосередньо виконує всі функції, які забезпечує ця "
"функція."

msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what :attr:"
"`__loader__` should be set to."
msgstr ""
":term:`decorator` для :meth:`importlib.abc.Loader.load_module` для "
"встановлення атрибута :attr:`__loader__` для повернутого модуля. Якщо "
"атрибут уже встановлено, декоратор нічого не робить. Передбачається, що "
"перший позиційний аргумент загорнутого методу (тобто ``self``) — це те, що "
"має бути встановлено :attr:`__loader__`."

msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr ""
"Встановіть ``__loader__``, якщо встановлено ``None``, ніби атрибут не існує."

msgid "The import machinery takes care of this automatically."
msgstr "Імпортна техніка подбає про це автоматично."

msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__package__` attribute on the returned module. If :attr:`__package__` "
"is set and has a value other than ``None`` it will not be changed."
msgstr ""
":term:`decorator` для :meth:`importlib.abc.Loader.load_module` для "
"встановлення атрибута :attr:`__package__` для повернутого модуля. Якщо :attr:"
"`__package__` встановлено та має значення, відмінне від ``None``, воно не "
"буде змінено."

msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"Фабрична функція для створення екземпляра :class:`~importlib.machinery."
"ModuleSpec` на основі завантажувача. Параметри мають таке ж значення, як і "
"для ModuleSpec. Функція використовує доступні API :term:`loader`, такі як :"
"meth:`InspectLoader.is_package`, щоб заповнити будь-яку відсутню інформацію "
"в специфікації."

msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"Фабрична функція для створення екземпляра :class:`~importlib.machinery."
"ModuleSpec` на основі шляху до файлу. Відсутню інформацію буде заповнено в "
"специфікації за допомогою API завантажувача та через те, що модуль буде "
"заснований на файлі."

msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Повертає хеш *source_bytes* як байти. Файл ``.pyc`` на основі хешу вставляє :"
"func:`source_hash` вмісту відповідного вихідного файлу у свій заголовок."

msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"Клас, який відкладає виконання завантажувача модуля, поки модуль не отримає "
"доступ до атрибута."

msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :attr:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""
"Цей клас працює **тільки** із завантажувачами, які визначають :meth:"
"`~importlib.abc.Loader.exec_module` як контроль над тим, який тип модуля "
"використовується для модуля. З тих самих причин метод завантажувача :meth:"
"`~importlib.abc.Loader.create_module` повинен повертати ``None`` або тип, "
"для якого його атрибут ``__class__`` може бути змінений разом із "
"невикористанням :term:`слоти <__slots__>`. Нарешті, модулі, які замінюють "
"об’єкт, розміщений у :attr:`sys.modules`, не працюватимуть, оскільки немає "
"способу безпечно замінити посилання на модулі в інтерпретаторі; :exc:"
"`ValueError` викликається, якщо така заміна виявлена."

msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"Для проектів, де час запуску є критичним, цей клас дозволяє потенційно "
"мінімізувати вартість завантаження модуля, якщо він ніколи не "
"використовується. Для проектів, де час запуску не є суттєвим, використання "
"цього класу **суворо** не рекомендується через те, що повідомлення про "
"помилки, створені під час завантаження, відкладаються та, таким чином, "
"виникають поза контекстом."

msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Почався виклик :meth:`~importlib.abc.Loader.create_module`, видаляючи "
"попередження про сумісність для :class:`importlib.machinery.BuiltinImporter` "
"і :class:`importlib.machinery.ExtensionFileLoader`."

msgid ""
"A static method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"Статичний метод, який повертає виклик, що створює відкладений завантажувач. "
"Це призначено для використання в ситуаціях, коли завантажувач передається "
"класом, а не екземпляром. ::"

msgid "Examples"
msgstr "Приклади"

msgid "Importing programmatically"
msgstr "Програмний імпорт"

msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"Щоб програмно імпортувати модуль, використовуйте :func:`importlib."
"import_module`. ::"

msgid "Checking if a module can be imported"
msgstr "Перевірка можливості імпорту модуля"

msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"Якщо вам потрібно з’ясувати, чи можна імпортувати модуль без фактичного "
"імпортування, тоді вам слід скористатися :func:`importlib.util.find_spec`."

msgid ""
"Note that if ``name`` is a submodule (contains a dot), :func:`importlib.util."
"find_spec` will import the parent module. ::"
msgstr ""
"Зауважте, що якщо ``name`` є підмодулем (містить крапку), :func:`importlib."
"util.find_spec` імпортує батьківський модуль. ::"

msgid "Importing a source file directly"
msgstr "Пряме імпортування вихідного файлу"

msgid ""
"To import a Python source file directly, use the following recipe (Python "
"3.5 and newer only)::"
msgstr ""

msgid "Implementing lazy imports"
msgstr "Реалізація відкладеного імпорту"

msgid "The example below shows how to implement lazy imports::"
msgstr "У прикладі нижче показано, як реалізувати відкладений імпорт:"

msgid "Setting up an importer"
msgstr "Налаштування імпортера"

msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :attr:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :attr:`sys.path_hooks` "
"which works with :attr:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""
"Для глибоких налаштувань імпорту зазвичай потрібно застосувати :term:"
"`importer`. Це означає керування сторонами :term:`finder` і :term:`loader`. "
"Для шукачів є два варіанти на вибір залежно від ваших потреб: :term:`meta "
"path finder` або :term:`path entry finder`. Перше – це те, що ви б "
"розмістили на :attr:`sys.meta_path`, тоді як останнє – це те, що ви "
"створюєте за допомогою :term:`path entry finder` на :attr:`sys.path_hooks`, "
"який працює з :attr:`sys.path` для потенційного створення засобу пошуку. Цей "
"приклад покаже вам, як зареєструвати власні імпортери, щоб import "
"використовував їх (щоб створити імпортер для себе, прочитайте документацію "
"для відповідних класів, визначених у цьому пакеті):"

msgid "Approximating :func:`importlib.import_module`"
msgstr "Наближення :func:`importlib.import_module`"

msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module` (Python 3.4 "
"and newer for the importlib usage, Python 3.6 and newer for other parts of "
"the code). ::"
msgstr ""
