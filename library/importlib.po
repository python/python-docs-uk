# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- Реалізація :keyword:`!import`"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "вступ"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr ""

#: ../../library/importlib.rst:22
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and"
" thus, by extension, the :func:`__import__` function) in Python source code."
" This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier"
" to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"По-друге, компоненти для реалізації :keyword:`import` представлені в цьому "
"пакунку, що полегшує користувачам створення власних користувацьких об’єктів "
"(відомих загалом як :term:`importer`) для участі в процесі імпорту."

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr ""

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""

#: ../../library/importlib.rst:43
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr "Посилання на мову для оператора :keyword:`import`."

#: ../../library/importlib.rst:46
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""
"`Специфікація пакетів <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"Оригінальна специфікація пакетів. Деяка семантика змінилася з моменту "
"написання цього документа (наприклад, переспрямування на основі ``None`` у "
":data:`sys.modules`)."

#: ../../library/importlib.rst:51
msgid "The :func:`.__import__` function"
msgstr "Функція :func:`.__import__`"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr "Оператор :keyword:`import` є синтаксичним цукром для цієї функції."

#: ../../library/importlib.rst:54
msgid ":ref:`sys-path-init`"
msgstr ""

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr ""

#: ../../library/importlib.rst:57
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "Імпорт на платформи без урахування регістру"

#: ../../library/importlib.rst:60
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "Визначення кодувань вихідного коду Python"

#: ../../library/importlib.rst:63
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "Нові гачки імпорту"

#: ../../library/importlib.rst:66
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Імпорт: багаторядковий і абсолютний/відносний"

#: ../../library/importlib.rst:69
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "Явний відносний імпорт головного модуля"

#: ../../library/importlib.rst:72
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "Неявні пакети простору імен"

#: ../../library/importlib.rst:75
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "Тип ModuleSpec для системи імпорту"

#: ../../library/importlib.rst:78
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "Видалення файлів PYO"

#: ../../library/importlib.rst:81
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "Багатофазна ініціалізація модуля розширення"

#: ../../library/importlib.rst:84
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "Детерміновані фото"

#: ../../library/importlib.rst:87
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Використання UTF-8 як вихідного кодування за умовчанням"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "Каталоги репозиторіїв PYC"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "Функції"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "Реалізація вбудованої функції :func:`__import__`."

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"Програмне імпортування модулів має використовувати :func:`import_module` "
"замість цієї функції."

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set"
" to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Імпортувати модуль. Аргумент *name* визначає, який модуль імпортувати в "
"абсолютних чи відносних значеннях (наприклад, ``pkg.mod`` або ``..mod``). "
"Якщо ім’я вказано у відносних термінах, тоді в аргументі *package* має бути "
"встановлено ім’я пакета, який має діяти як прив’язка для визначення імені "
"пакета (наприклад, ``import_module('..mod', 'pkg' .subpkg')`` імпортує "
"``pkg.mod``)."

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"Функція :func:`import_module` діє як спрощена оболонка навколо "
":func:`importlib.__import__`. Це означає, що вся семантика функції походить "
"від :func:`importlib.__import__`. Найважливіша відмінність між цими двома "
"функціями полягає в тому, що :func:`import_module` повертає вказаний пакунок"
" або модуль (наприклад, ``pkg.mod``), а :func:`__import__` повертає пакунок "
"або модуль верхнього рівня (напр. ``пакет``)."

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Якщо ви динамічно імпортуєте модуль, який було створено після того, як "
"інтерпретатор почав виконання (наприклад, створив вихідний файл Python), вам"
" може знадобитися викликати :func:`invalidate_caches`, щоб система імпорту "
"помітила новий модуль."

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "Батьківські пакети імпортуються автоматично."

#: ../../library/importlib.rst:132
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are"
" created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Визнати недійсними внутрішні кеші засобів пошуку, які зберігаються в "
":data:`sys.meta_path`. Якщо засіб пошуку реалізує ``invalidate_caches()``, "
"тоді він буде викликаний для виконання недійсності. Цю функцію слід "
"викликати, якщо будь-які модулі створюються/встановлюються під час роботи "
"вашої програми, щоб гарантувати, що всі шукачі помітять існування нового "
"модуля."

#: ../../library/importlib.rst:140
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""

#: ../../library/importlib.rst:146
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Перезавантажте раніше імпортований *модуль*. Аргумент має бути об’єктом "
"модуля, тому він має бути успішно імпортований раніше. Це корисно, якщо ви "
"відредагували вихідний файл модуля за допомогою зовнішнього редактора і "
"хочете випробувати нову версію, не виходячи з інтерпретатора Python. "
"Поверненим значенням є об’єкт модуля (який може бути іншим, якщо повторне "
"імпортування спричиняє розміщення іншого об’єкта в :data:`sys.modules`)."

#: ../../library/importlib.rst:153
msgid "When :func:`reload` is executed:"
msgstr "Коли :func:`reload` виконується:"

#: ../../library/importlib.rst:155
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the module."
"  The ``init`` function of extension modules is not called a second time."
msgstr ""
"Код модуля Python перекомпілюється, а код рівня модуля повторно виконується,"
" визначаючи новий набір об’єктів, які прив’язуються до імен у словнику "
"модуля шляхом повторного використання :term:`loader`, який початково "
"завантажив модуль. Функція ``init`` модулів розширення не викликається "
"вдруге."

#: ../../library/importlib.rst:161
msgid ""
"As with all other objects in Python the old objects are only reclaimed after"
" their reference counts drop to zero."
msgstr ""
"Як і у випадку з усіма іншими об’єктами в Python, старі об’єкти "
"відновлюються лише після того, як їх кількість посилань зменшується до нуля."

#: ../../library/importlib.rst:164
msgid ""
"The names in the module namespace are updated to point to any new or changed"
" objects."
msgstr ""
"Імена в просторі імен модуля оновлюються, щоб вказувати на будь-які нові або"
" змінені об’єкти."

#: ../../library/importlib.rst:167
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Інші посилання на старі об’єкти (наприклад, імена, зовнішні по відношенню до"
" модуля) не повертаються до нових об’єктів і повинні бути оновлені в кожному"
" просторі імен, де вони зустрічаються, якщо це потрібно."

#: ../../library/importlib.rst:171
msgid "There are a number of other caveats:"
msgstr "Існує ряд інших застережень:"

#: ../../library/importlib.rst:173
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Коли модуль перезавантажується, його словник (що містить глобальні змінні "
"модуля) зберігається. Перевизначення імен замінить старі визначення, тому "
"це, як правило, не проблема. Якщо нова версія модуля не визначає назву, яка "
"була визначена старою версією, старе визначення залишається. Цю функцію "
"можна використовувати на користь модуля, якщо він підтримує глобальну "
"таблицю або кеш об’єктів --- за допомогою оператора :keyword:`try` він може "
"перевірити наявність таблиці та за бажанням пропустити її ініціалізацію::"

#: ../../library/importlib.rst:182
msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""

#: ../../library/importlib.rst:187
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Зазвичай не дуже корисно перезавантажувати вбудовані або динамічно "
"завантажувані модулі. Перезавантажувати :mod:`sys`, :mod:`__main__`, "
":mod:`builtins` та інші ключові модулі не рекомендується. У багатьох "
"випадках модулі розширення не призначені для ініціалізації більше одного "
"разу, і можуть виникати будь-які збої під час перезавантаження."

#: ../../library/importlib.rst:193
msgid ""
"If a module imports objects from another module using :keyword:`from` ... "
":keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import`"
" and qualified names (*module.name*) instead."
msgstr ""
"Якщо модуль імпортує об’єкти з іншого модуля за допомогою :keyword:`from` "
"... :keyword:`import` ..., виклик :func:`reload` для іншого модуля не "
"перевизначає об’єкти, імпортовані з нього --- один із способів обійти це — "
"повторно виконати оператор :keyword:`!from`, інший — використати замість "
"нього :keyword:`!import` і кваліфіковані імена (*module.name*)."

#: ../../library/importlib.rst:199
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Якщо модуль створює екземпляри класу, перезавантаження модуля, який визначає"
" клас, не впливає на визначення методів екземплярів --- вони продовжують "
"використовувати старе визначення класу. Те саме стосується похідних класів."

#: ../../library/importlib.rst:205
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a "
":class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` виникає, коли модуль, який перезавантажується, не"
" має :class:`~importlib.machinery.ModuleSpec`."

#: ../../library/importlib.rst:211
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- Абстрактні базові класи, пов'язані з імпортом"

#: ../../library/importlib.rst:216
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:221
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base"
" classes are also provided to help in implementing the core ABCs."
msgstr ""
"Модуль :mod:`importlib.abc` містить усі основні абстрактні базові класи, які"
" використовуються :keyword:`import`. Деякі підкласи основних абстрактних "
"базових класів також надаються для допомоги в реалізації основних ABC."

#: ../../library/importlib.rst:225
msgid "ABC hierarchy::"
msgstr "Ієрархія ABC::"

#: ../../library/importlib.rst:227
msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""

#: ../../library/importlib.rst:240
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "Абстрактний базовий клас, що представляє :term:`meta path finder`."

#: ../../library/importlib.rst:244 ../../library/importlib.rst:280
msgid "No longer a subclass of :class:`!Finder`."
msgstr ""

#: ../../library/importlib.rst:249
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`~module.__path__` from the parent package. If a spec "
"cannot be found, ``None`` is returned. When passed in, ``target`` is a "
"module object that the finder may use to make a more educated guess about "
"what spec to return. :func:`importlib.util.spec_from_loader` may be useful "
"for implementing concrete ``MetaPathFinders``."
msgstr ""

#: ../../library/importlib.rst:263
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"Додатковий метод, який під час виклику має зробити недійсним будь-який "
"внутрішній кеш, який використовує шукач. Використовується "
":func:`importlib.invalidate_caches` під час визнання недійсними кешів усіх "
"засобів пошуку на :data:`sys.meta_path`."

#: ../../library/importlib.rst:267
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr ""

#: ../../library/importlib.rst:273
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by "
":class:`importlib.machinery.PathFinder`."
msgstr ""
"Абстрактний базовий клас, що представляє :term:`path entry finder`. Хоча він"
" має певну схожість із :class:`MetaPathFinder`, ``PathEntryFinder`` "
"призначений для використання лише в підсистемі імпорту на основі шляху, яку "
"надає :class:`importlib.machinery.PathFinder`."

#: ../../library/importlib.rst:285
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. "
":func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"Абстрактний метод для пошуку :term:`spec <module spec>` для вказаного "
"модуля. Шукач шукатиме модуль лише в межах :term:`path entry`, якому він "
"призначений. Якщо специфікацію неможливо знайти, повертається ``None``. Коли"
" передано, ``target`` є об’єктом модуля, який шукач може використовувати, "
"щоб зробити більш освічене припущення про те, яку специфікацію потрібно "
"повернути. :func:`importlib.util.spec_from_loader` може бути корисним для "
"реалізації конкретних ``PathEntryFinders``."

#: ../../library/importlib.rst:297
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by "
":meth:`importlib.machinery.PathFinder.invalidate_caches` when invalidating "
"the caches of all cached finders."
msgstr ""
"Додатковий метод, який під час виклику має зробити недійсним будь-який "
"внутрішній кеш, який використовує шукач. Використовується "
":meth:`importlib.machinery.PathFinder.invalidate_caches` під час визнання "
"недійсними кешів усіх кешованих засобів пошуку."

#: ../../library/importlib.rst:305
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"Абстрактний базовий клас для :term:`loader`. Перегляньте :pep:`302` для "
"точного визначення завантажувача."

#: ../../library/importlib.rst:308
msgid ""
"Loaders that wish to support resource reading should implement a "
":meth:`get_resource_reader` method as specified by "
":class:`importlib.resources.abc.ResourceReader`."
msgstr ""

#: ../../library/importlib.rst:312
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr ""

#: ../../library/importlib.rst:317
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"Метод, який повертає об’єкт модуля для використання під час імпорту модуля. "
"Цей метод може повертати ``None``, вказуючи, що семантика створення модуля "
"за замовчуванням має мати місце."

#: ../../library/importlib.rst:323
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr ""

#: ../../library/importlib.rst:329
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, "
":meth:`create_module` must be defined."
msgstr ""

#: ../../library/importlib.rst:336
msgid ":meth:`create_module` must also be defined."
msgstr ""

#: ../../library/importlib.rst:341
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""

#: ../../library/importlib.rst:345
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module"
" and insert it into :data:`sys.modules` before any loading begins, to "
"prevent recursion from the import.  If the loader inserted a module and the "
"load fails, it must be removed by the loader from :data:`sys.modules`; "
"modules already in :data:`sys.modules` before the loader began execution "
"should be left alone."
msgstr ""

#: ../../library/importlib.rst:354
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""

#: ../../library/importlib.rst:358
msgid ":attr:`module.__name__`"
msgstr ""

#: ../../library/importlib.rst:359
msgid ":attr:`module.__file__`"
msgstr ""

#: ../../library/importlib.rst:360
msgid ":attr:`module.__cached__` *(deprecated)*"
msgstr ""

#: ../../library/importlib.rst:361
msgid ":attr:`module.__path__`"
msgstr ""

#: ../../library/importlib.rst:362
msgid ":attr:`module.__package__` *(deprecated)*"
msgstr ""

#: ../../library/importlib.rst:363
msgid ":attr:`module.__loader__` *(deprecated)*"
msgstr ""

#: ../../library/importlib.rst:365
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"Коли :meth:`exec_module` доступний, тоді надається функція зворотної "
"сумісності."

#: ../../library/importlib.rst:368
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`."
"  Functionality provided when :meth:`exec_module` is available."
msgstr ""

#: ../../library/importlib.rst:373
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
":meth:`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""

#: ../../library/importlib.rst:383
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loading arbitrary resources from the storage back-"
"end."
msgstr ""
"Абстрактний базовий клас для :term:`loader`, який реалізує необов’язковий "
"протокол :pep:`302` для завантаження довільних ресурсів із внутрішнього "
"сховища."

#: ../../library/importlib.rst:387
msgid ""
"This ABC is deprecated in favour of supporting resource loading through "
":class:`importlib.resources.abc.ResourceReader`."
msgstr ""

#: ../../library/importlib.rst:393
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary"
" data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's "
":attr:`~module.__file__` attribute or an item from a package's "
":attr:`~module.__path__`."
msgstr ""

#: ../../library/importlib.rst:402
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Викликає :exc:`OSError` замість :exc:`NotImplementedError`."

#: ../../library/importlib.rst:408
msgid ""
"An abstract base class for a :term:`loader` which implements the optional "
":pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Абстрактний базовий клас для :term:`loader`, який реалізує додатковий "
"протокол :pep:`302` для завантажувачів, які перевіряють модулі."

#: ../../library/importlib.rst:413
msgid ""
"Return the code object for a module, or ``None`` if the module does not have"
" a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Повертає об’єкт коду для модуля або ``None``, якщо модуль не має об’єкта "
"коду (як, наприклад, у випадку вбудованого модуля). Викликати "
":exc:`ImportError`, якщо завантажувач не може знайти запитуваний модуль."

#: ../../library/importlib.rst:419
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Хоча метод має реалізацію за замовчуванням, пропонується замінити його, якщо"
" це можливо для продуктивності."

#: ../../library/importlib.rst:425
msgid "No longer abstract and a concrete implementation is provided."
msgstr "Більше не абстрактне, а конкретна реалізація."

#: ../../library/importlib.rst:430
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is"
" available (e.g. a built-in module). Raises :exc:`ImportError` if the loader"
" cannot find the module specified."
msgstr ""
"Абстрактний метод для повернення вихідного коду модуля. Він повертається як "
"текстовий рядок з використанням :term:`universal newlines`, переводячи всі "
"розпізнані роздільники рядків у символи ``'\\n'``. Повертає ``None``, якщо "
"джерело недоступне (наприклад, вбудований модуль). Викликає "
":exc:`ImportError`, якщо завантажувач не може знайти вказаний модуль."

#: ../../library/importlib.rst:436 ../../library/importlib.rst:445
#: ../../library/importlib.rst:495
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Викликає :exc:`ImportError` замість :exc:`NotImplementedError`."

#: ../../library/importlib.rst:441
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"Додатковий метод для повернення істинного значення, якщо модуль є пакетом, і"
" хибного значення в іншому випадку. :exc:`ImportError` виникає, якщо "
":term:`loader` не може знайти модуль."

#: ../../library/importlib.rst:450
msgid "Create a code object from Python source."
msgstr "Створіть об’єкт коду з джерела Python."

#: ../../library/importlib.rst:452
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports "
"(i.e. string or bytes). The *path* argument should be the \"path\" to where "
"the source code originated from, which can be an abstract concept (e.g. "
"location in a zip file)."
msgstr ""
"Аргументом *data* може бути те, що підтримує функція :func:`compile` (тобто "
"рядок або байти). Аргумент *path* має бути \"шляхом\", звідки походить "
"вихідний код, що може бути абстрактним поняттям (наприклад, розташуванням у "
"файлі zip)."

#: ../../library/importlib.rst:457
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"З наступним об’єктом коду можна виконати його в модулі, запустивши "
"``exec(code, module.__dict__)``."

#: ../../library/importlib.rst:462
msgid "Made the method static."
msgstr "Зробив метод статичним."

#: ../../library/importlib.rst:467
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Реалізація :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:473
msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Реалізація :meth:`Loader.load_module`."

#: ../../library/importlib.rst:475
msgid "use :meth:`exec_module` instead."
msgstr "замість цього використовуйте :meth:`exec_module`."

#: ../../library/importlib.rst:481
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when"
" implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Абстрактний базовий клас, успадкований від :class:`InspectLoader`, який, "
"реалізований, допомагає модулю виконуватися як сценарій. ABC представляє "
"необов’язковий протокол :pep:`302`."

#: ../../library/importlib.rst:487
msgid ""
"An abstract method that is to return the value of :attr:`~module.__file__` "
"for the specified module. If no path is available, :exc:`ImportError` is "
"raised."
msgstr ""

#: ../../library/importlib.rst:491
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Якщо вихідний код доступний, тоді метод має повертати шлях до вихідного "
"файлу, незалежно від того, чи використовувався байт-код для завантаження "
"модуля."

#: ../../library/importlib.rst:501
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Абстрактний базовий клас, який успадковує :class:`ResourceLoader` і "
":class:`ExecutionLoader`, надаючи конкретні реалізації "
":meth:`ResourceLoader.get_data` і :meth:`ExecutionLoader.get_filename`."

#: ../../library/importlib.rst:505
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is"
" to handle. The *path* argument is the path to the file for the module."
msgstr ""
"Аргумент *повне ім’я* — це повністю визначене ім’я модуля, який має "
"обробляти завантажувач. Аргумент *path* — це шлях до файлу модуля."

#: ../../library/importlib.rst:512
msgid "The name of the module the loader can handle."
msgstr "Назва модуля, який може обробляти завантажувач."

#: ../../library/importlib.rst:516
msgid "Path to the file of the module."
msgstr "Шлях до файлу модуля."

#: ../../library/importlib.rst:520
msgid "Calls super's ``load_module()``."
msgstr "Викликає ``load_module()`` супер."

#: ../../library/importlib.rst:522
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Натомість використовуйте :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:527 ../../library/importlib.rst:1122
msgid "Returns :attr:`path`."
msgstr "Повертає :attr:`path`."

#: ../../library/importlib.rst:531
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Читає *шлях* як двійковий файл і повертає байти з нього."

#: ../../library/importlib.rst:536
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Абстрактний базовий клас для реалізації вихідного (і необов’язково байт-"
"коду) завантаження файлу. Клас успадковує як :class:`ResourceLoader`, так і "
":class:`ExecutionLoader`, що вимагає реалізації:"

#: ../../library/importlib.rst:540
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:541
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:542
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Має повертати лише шлях до вихідного файлу; завантаження без джерел не "
"підтримується."

#: ../../library/importlib.rst:545
msgid ""
"The abstract methods defined by this class are to add optional bytecode file"
" support. Not implementing these optional methods (or causing them to raise "
":exc:`NotImplementedError`) causes the loader to only work with source code."
" Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Абстрактні методи, визначені цим класом, призначені для додавання додаткової"
" підтримки файлу байт-коду. Нереалізація цих додаткових методів (або виклик "
"їх :exc:`NotImplementedError`) змушує завантажувач працювати лише з вихідним"
" кодом. Реалізація методів дозволяє завантажувачу працювати з вихідними *та*"
" файлами байт-коду; він не допускає *безджерельного* завантаження, де "
"надається лише байт-код. Файли байт-коду є оптимізацією для прискорення "
"завантаження шляхом видалення кроку синтаксичного аналізу компілятора "
"Python, тому API, специфічний для байт-коду, не розкривається."

#: ../../library/importlib.rst:556
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Додатковий абстрактний метод, який повертає :class:`dict`, що містить "
"метадані про вказаний шлях. Підтримувані ключі словника:"

#: ../../library/importlib.rst:559
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (обов'язковий): ціле число або число з плаваючою комою, що "
"представляє час модифікації вихідного коду;"

#: ../../library/importlib.rst:561
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (необов'язковий): розмір у байтах вихідного коду."

#: ../../library/importlib.rst:563
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Будь-які інші ключі в словнику ігноруються, щоб дозволити майбутні "
"розширення. Якщо шлях не можна обробити, виникає :exc:`OSError`."

#: ../../library/importlib.rst:568 ../../library/importlib.rst:581
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Викликати :exc:`OSError` замість :exc:`NotImplementedError`."

#: ../../library/importlib.rst:573
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Додатковий абстрактний метод, який повертає час модифікації для вказаного "
"шляху."

#: ../../library/importlib.rst:576
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. Raise"
" :exc:`OSError` if the path cannot be handled."
msgstr ""
"Цей метод застарів на користь :meth:`path_stats`. Вам не потрібно його "
"впроваджувати, але він все ще доступний для цілей сумісності. Викликати "
":exc:`OSError`, якщо шлях неможливо обробити."

#: ../../library/importlib.rst:586
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Додатковий абстрактний метод, який записує вказані байти в шлях до файлу. "
"Будь-які проміжні каталоги, яких не існує, створюються автоматично."

#: ../../library/importlib.rst:590
msgid ""
"When writing to the path fails because the path is read-only "
"(:const:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""

#: ../../library/importlib.rst:594
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Більше не викликає :exc:`NotImplementedError` під час виклику."

#: ../../library/importlib.rst:599
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Конкретна реалізація :meth:`InspectLoader.get_code`."

#: ../../library/importlib.rst:603
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Конкретна реалізація :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:609
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Конкретна реалізація :meth:`Loader.load_module`."

#: ../../library/importlib.rst:611
msgid "Use :meth:`exec_module` instead."
msgstr "Замість цього використовуйте :meth:`exec_module`."

#: ../../library/importlib.rst:616
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Конкретна реалізація :meth:`InspectLoader.get_source`."

#: ../../library/importlib.rst:620
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when the "
"file extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Конкретна реалізація :meth:`InspectLoader.is_package`. Модуль вважається "
"пакетом, якщо його шлях до файлу (як надано "
":meth:`ExecutionLoader.get_filename`) є файлом з назвою ``__init__``, коли "
"розширення файлу видалено **і** сама назва модуля не закінчується на "
"``__init__``."

#: ../../library/importlib.rst:629
msgid "*Superseded by TraversableResources*"
msgstr "*Замінено TraversableResources*"

#: ../../library/importlib.rst:631
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ":term:`abstract base class` для надання можливості читати *ресурси*."

#: ../../library/importlib.rst:634
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored e.g. in a zip"
" file versus on the file system."
msgstr ""

#: ../../library/importlib.rst:642
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a "
":term:`path-like object` which represents conceptually just a file name. "
"This means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names"
" is packages and resources, respectively. This is also why instances of this"
" class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"Для будь-якого методу цього класу очікується, що аргумент *resource* буде "
":term:`path-like object`, який концептуально представляє лише ім’я файлу. Це"
" означає, що шляхи підкаталогів не повинні включатися в аргумент *resource*."
" Це пояснюється тим, що місце розташування пакета, для якого призначений "
"зчитувач, діє як \"каталог\". Тому метафорою для каталогів і імен файлів є "
"пакети та ресурси відповідно. Ось чому очікується, що екземпляри цього класу"
" безпосередньо співвідносяться з певним пакетом (замість того, щоб "
"потенційно представляти кілька пакетів або модуль)."

#: ../../library/importlib.rst:653
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible"
" with this ABC should only be returned when the specified module is a "
"package."
msgstr ""
"Очікується, що завантажувачі, які бажають підтримувати читання ресурсів, "
"нададуть метод під назвою ``get_resource_reader(fullname)``, який повертає "
"об’єкт, що реалізує цей інтерфейс ABC. Якщо модуль, указаний повним іменем, "
"не є пакетом, цей метод має повернути :const:`None`. Об’єкт, сумісний із цим"
" ABC, слід повертати лише тоді, коли вказаний модуль є пакетом."

#: ../../library/importlib.rst:662 ../../library/importlib.rst:772
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr ""

#: ../../library/importlib.rst:667
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Повертає відкритий :term:`file-like object` для двійкового читання "
"*ресурсу*."

#: ../../library/importlib.rst:670
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "Якщо ресурс не знайдено, виникає :exc:`FileNotFoundError`."

#: ../../library/importlib.rst:675
msgid "Returns the file system path to the *resource*."
msgstr "Повертає шлях файлової системи до *ресурсу*."

#: ../../library/importlib.rst:677
msgid ""
"If the resource does not concretely exist on the file system, raise "
":exc:`FileNotFoundError`."
msgstr ""
"Якщо ресурс конкретно не існує у файловій системі, викликайте "
":exc:`FileNotFoundError`."

#: ../../library/importlib.rst:682
msgid ""
"Returns ``True`` if the named *name* is considered a resource. "
":exc:`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Повертає ``True``, якщо назване *ім’я* вважається ресурсом. "
":exc:`FileNotFoundError` виникає, якщо *name* не існує."

#: ../../library/importlib.rst:687
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which "
":meth:`is_resource` would be false."
msgstr ""
"Повертає :term:`iterable` рядків над вмістом пакета. Зауважте, що не "
"обов’язково, щоб усі імена, які повертає ітератор, були фактичними "
"ресурсами, наприклад. прийнятно повертати імена, для яких "
":meth:`is_resource` буде false."

#: ../../library/importlib.rst:693
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used "
"directly."
msgstr ""
"Дозволити повертати нересурсні імена, щоб дозволити ситуації, коли те, як "
"пакет і його ресурси зберігаються, відомі апріорі, і нересурсні імена будуть"
" корисними. Наприклад, дозволено повертати імена підкаталогів, щоб, якщо "
"відомо, що пакет і ресурси зберігаються у файловій системі, ці імена "
"підкаталогів можна було використовувати безпосередньо."

#: ../../library/importlib.rst:701
msgid "The abstract method returns an iterable of no items."
msgstr "Абстрактний метод повертає ітерацію без елементів."

#: ../../library/importlib.rst:706
msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr ""

#: ../../library/importlib.rst:709
msgid ""
"For a representation of the object on the file-system, use "
":meth:`importlib.resources.as_file`."
msgstr ""

#: ../../library/importlib.rst:714
msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr ""

#: ../../library/importlib.rst:719
msgid "Abstract. The base name of this object without any parent references."
msgstr ""

#: ../../library/importlib.rst:723
msgid "Yield ``Traversable`` objects in ``self``."
msgstr ""

#: ../../library/importlib.rst:727
msgid "Return ``True`` if ``self`` is a directory."
msgstr ""

#: ../../library/importlib.rst:731
msgid "Return ``True`` if ``self`` is a file."
msgstr ""

#: ../../library/importlib.rst:735
msgid "Return Traversable child in ``self``."
msgstr ""

#: ../../library/importlib.rst:739
msgid "Return ``Traversable`` child in ``self``."
msgstr ""

#: ../../library/importlib.rst:743
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* може бути \"r\" або \"rb\", щоб відкрити як текстовий або двійковий "
"файл. Повертає дескриптор, придатний для читання (те саме, що "
":attr:`pathlib.Path.open`)."

#: ../../library/importlib.rst:746
msgid ""
"When opening as text, accepts encoding parameters such as those accepted by "
":attr:`io.TextIOWrapper`."
msgstr ""
"Коли відкривається як текст, приймає параметри кодування, такі як ті, які "
"приймає :attr:`io.TextIOWrapper`."

#: ../../library/importlib.rst:751
msgid "Read contents of ``self`` as bytes."
msgstr ""

#: ../../library/importlib.rst:755
msgid "Read contents of ``self`` as text."
msgstr ""

#: ../../library/importlib.rst:760
msgid ""
"An abstract base class for resource readers capable of serving the "
":meth:`importlib.resources.files` interface. Subclasses "
":class:`importlib.resources.abc.ResourceReader` and provides concrete "
"implementations of the :class:`importlib.resources.abc.ResourceReader`'s "
"abstract methods. Therefore, any loader supplying "
":class:`importlib.abc.TraversableResources` also supplies ResourceReader."
msgstr ""

#: ../../library/importlib.rst:767
msgid ""
"Loaders that wish to support resource reading are expected to implement this"
" interface."
msgstr ""
"Очікується, що завантажувачі, які бажають підтримувати читання ресурсів, "
"реалізують цей інтерфейс."

#: ../../library/importlib.rst:777
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the loaded"
" package."
msgstr ""

#: ../../library/importlib.rst:783
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Імпортери та перехоплювачі шляху"

#: ../../library/importlib.rst:788
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:792
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Цей модуль містить різноманітні об’єкти, які допомагають :keyword:`import` "
"знаходити та завантажувати модулі."

#: ../../library/importlib.rst:797
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"Список рядків, що представляють розпізнані суфікси файлів для вихідних "
"модулів."

#: ../../library/importlib.rst:804
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"Список рядків, що представляють суфікси файлів для неоптимізованих модулів "
"байт-коду."

#: ../../library/importlib.rst:809 ../../library/importlib.rst:819
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "Натомість використовуйте :attr:`BYTECODE_SUFFIXES`."

#: ../../library/importlib.rst:814
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"Список рядків, що представляють суфікси файлів для оптимізованих модулів "
"байт-коду."

#: ../../library/importlib.rst:824
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"Список рядків, що представляють розпізнані суфікси файлів для модулів байт-"
"коду (включно з початковою крапкою)."

#: ../../library/importlib.rst:829
msgid "The value is no longer dependent on ``__debug__``."
msgstr "Значення більше не залежить від ``__debug__``."

#: ../../library/importlib.rst:834
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"Список рядків, що представляють розпізнані суфікси файлів для модулів "
"розширення."

#: ../../library/importlib.rst:841
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a"
" module without needing any details on the kind of module (for example, "
":func:`inspect.getmodulename`)."
msgstr ""
"Повертає комбінований список рядків, що представляють усі суфікси файлів для"
" модулів, розпізнаних стандартним механізмом імпорту. Це допоміжний засіб "
"для коду, якому просто потрібно знати, чи шлях до файлової системи "
"потенційно посилається на модуль, не потребуючи жодних деталей щодо типу "
"модуля (наприклад, :func:`inspect.getmodulename`)."

#: ../../library/importlib.rst:852
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
":term:`importer` для вбудованих модулів. Усі відомі вбудовані модулі "
"перераховані в :data:`sys.builtin_module_names`. Цей клас реалізує ABC "
":class:`importlib.abc.MetaPathFinder` і "
":class:`importlib.abc.InspectLoader`."

#: ../../library/importlib.rst:857 ../../library/importlib.rst:871
#: ../../library/importlib.rst:884 ../../library/importlib.rst:899
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"У цьому класі визначені лише методи класу, щоб полегшити потребу в створенні"
" екземплярів."

#: ../../library/importlib.rst:860
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Як частина :pep:`489`, вбудований імпортер тепер реалізує "
":meth:`Loader.create_module` і :meth:`Loader.exec_module`"

#: ../../library/importlib.rst:867
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
":term:`importer` для заморожених модулів. Цей клас реалізує ABC "
":class:`importlib.abc.MetaPathFinder` і "
":class:`importlib.abc.InspectLoader`."

#: ../../library/importlib.rst:874
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` "
"methods."
msgstr ""
"Отримано методи :meth:`~Loader.create_module` і :meth:`~Loader.exec_module`."

#: ../../library/importlib.rst:881
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` для модулів, оголошених у реєстрі Windows. Цей клас "
"реалізує :class:`importlib.abc.MetaPathFinder` ABC."

#: ../../library/importlib.rst:889
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Натомість використовуйте конфігурацію :mod:`site`. Майбутні версії Python "
"можуть не вмикати цей засіб пошуку за замовчуванням."

#: ../../library/importlib.rst:896
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"A :term:`Finder <finder>` для атрибутів :data:`sys.path` і пакета "
"``__path__``. Цей клас реалізує :class:`importlib.abc.MetaPathFinder` ABC."

#: ../../library/importlib.rst:904
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is found "
"then it is used as the :term:`path entry finder` to look for the module "
"being searched for. If no entry is found in :data:`sys.path_importer_cache`,"
" then :data:`sys.path_hooks` is searched for a finder for the path entry "
"and, if found, is stored in :data:`sys.path_importer_cache` along with being"
" queried about the module. If no finder is ever found then ``None`` is both "
"stored in the cache and returned."
msgstr ""
"Метод класу, який намагається знайти :term:`spec <module spec>` для модуля, "
"указаного *повним ім’ям* у :data:`sys.path` або, якщо визначено, у *path*. "
"Для кожного запису шляху, який шукається, перевіряється "
":data:`sys.path_importer_cache`. Якщо знайдено нефальшивий об’єкт, він "
"використовується як :term:`path entry finder` для пошуку модуля, який "
"шукається. Якщо в :data:`sys.path_importer_cache` не знайдено жодного "
"запису, тоді :data:`sys.path_hooks` шукає засіб пошуку для запису шляху та, "
"якщо знайдено, зберігається в :data:`sys.path_importer_cache` із запитанням "
"про модуль. Якщо жоден шукач не знайдено, тоді ``None`` зберігається в кеші "
"та повертається."

#: ../../library/importlib.rst:918
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"Якщо поточний робочий каталог, представлений порожнім рядком, більше не "
"дійсний, тоді повертається ``None``, але жодне значення не кешується в "
":data:`sys.path_importer_cache`."

#: ../../library/importlib.rst:925
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders"
" stored in :data:`sys.path_importer_cache` that define the method. Otherwise"
" entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Викликає :meth:`importlib.abc.PathEntryFinder.invalidate_caches` для всіх "
"засобів пошуку, збережених у :data:`sys.path_importer_cache`, які визначають"
" метод. Інакше записи в :data:`sys.path_importer_cache`, для яких "
"встановлено значення ``None``, видаляються."

#: ../../library/importlib.rst:930
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr "Записи ``None`` у :data:`sys.path_importer_cache` видаляються."

#: ../../library/importlib.rst:933
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Викликає об’єкти в :data:`sys.path_hooks` з поточним робочим каталогом для "
"``''`` (тобто порожній рядок)."

#: ../../library/importlib.rst:940
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.PathEntryFinder`, яка кешує "
"результати з файлової системи."

#: ../../library/importlib.rst:943
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "Аргумент *шлях* — це каталог, пошук якого відповідає за пошук."

#: ../../library/importlib.rst:946
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"Аргумент *loader_details* — це змінна кількість кортежів із 2 елементів, "
"кожен із яких містить завантажувач і послідовність суфіксів файлів, які "
"розпізнає завантажувач. Очікується, що завантажувачі будуть викликаними, які"
" приймають два аргументи імені модуля та шляху до знайденого файлу."

#: ../../library/importlib.rst:951
msgid ""
"The finder will cache the directory contents as necessary, making stat calls"
" for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure"
" to call :func:`importlib.invalidate_caches`."
msgstr ""
"Засіб пошуку кешуватиме вміст каталогу за потреби, виконуючи stat виклики "
"для кожного пошуку модуля, щоб переконатися, що кеш не застарів. Оскільки "
"нестабільність кешу залежить від деталізації інформації про стан операційної"
" системи файлової системи, існує потенційна конкуренція щодо пошуку модуля, "
"створення нового файлу, а потім пошуку модуля, який представляє новий файл. "
"Якщо операції відбуваються досить швидко, щоб відповідати деталізації "
"викликів stat, пошук модулів не вдасться. Щоб цього не сталося, під час "
"динамічного створення модуля обов’язково викликайте "
":func:`importlib.invalidate_caches`."

#: ../../library/importlib.rst:965
msgid "The path the finder will search in."
msgstr "Шлях, за яким шукач шукатиме."

#: ../../library/importlib.rst:969
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Спробуйте знайти специфікацію для обробки *повного імені* в :attr:`path`."

#: ../../library/importlib.rst:975
msgid "Clear out the internal cache."
msgstr "Очистіть внутрішній кеш."

#: ../../library/importlib.rst:979
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An"
" instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""

#: ../../library/importlib.rst:984
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr ""
"Якщо аргумент закриття не є існуючим каталогом, виникає :exc:`ImportError`."

#: ../../library/importlib.rst:990
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.SourceLoader` шляхом створення "
"підкласу :class:`importlib.abc.FileLoader` і надання деяких конкретних "
"реалізацій інших методів."

#: ../../library/importlib.rst:998
msgid "The name of the module that this loader will handle."
msgstr "Назва модуля, який оброблятиме цей завантажувач."

#: ../../library/importlib.rst:1002
msgid "The path to the source file."
msgstr "Шлях до вихідного файлу."

#: ../../library/importlib.rst:1006
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Повертає ``True``, якщо :attr:`path` є для пакета."

#: ../../library/importlib.rst:1010
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr "Конкретна реалізація :meth:`importlib.abc.SourceLoader.path_stats`."

#: ../../library/importlib.rst:1014
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "Конкретна реалізація :meth:`importlib.abc.SourceLoader.set_data`."

#: ../../library/importlib.rst:1018 ../../library/importlib.rst:1061
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Конкретна реалізація :meth:`importlib.abc.Loader.load_module`, де вказувати "
"назву модуля для завантаження необов’язково."

#: ../../library/importlib.rst:1023 ../../library/importlib.rst:1066
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr ""
"Замість цього використовуйте :meth:`importlib.abc.Loader.exec_module`."

#: ../../library/importlib.rst:1028
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.FileLoader`, яка може імпортувати"
" файли байт-коду (тобто файлів вихідного коду не існує)."

#: ../../library/importlib.rst:1031
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations"
" or new versions of Python which change the bytecode format."
msgstr ""
"Зауважте, що пряме використання файлів байт-коду (а отже, не файлів "
"вихідного коду) перешкоджає використанню ваших модулів усіма реалізаціями "
"Python або новими версіями Python, які змінюють формат байт-коду."

#: ../../library/importlib.rst:1040
msgid "The name of the module the loader will handle."
msgstr "Назва модуля, який оброблятиме завантажувач."

#: ../../library/importlib.rst:1044
msgid "The path to the bytecode file."
msgstr "Шлях до файлу байт-коду."

#: ../../library/importlib.rst:1048
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Визначає, чи є модуль пакетом на основі :attr:`path`."

#: ../../library/importlib.rst:1052
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr "Повертає об’єкт коду для :attr:`name`, створеного з :attr:`path`."

#: ../../library/importlib.rst:1056
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Повертає ``None``, оскільки файли байт-коду не мають джерела, коли "
"використовується цей завантажувач."

#: ../../library/importlib.rst:1071
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"Конкретна реалізація :class:`importlib.abc.ExecutionLoader` для модулів "
"розширення."

#: ../../library/importlib.rst:1074
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"Аргумент *fullname* вказує назву модуля, який має підтримувати завантажувач."
" Аргумент *path* — це шлях до файлу модуля розширення."

#: ../../library/importlib.rst:1077
msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see :pep:`489`), "
"even if it would otherwise import successfully."
msgstr ""

#: ../../library/importlib.rst:1083
msgid "Multi-phase init is now required for use in subinterpreters."
msgstr ""

#: ../../library/importlib.rst:1088 ../../library/importlib.rst:1274
msgid "Name of the module the loader supports."
msgstr "Назва модуля, який підтримує завантажувач."

#: ../../library/importlib.rst:1092
msgid "Path to the extension module."
msgstr "Шлях до модуля розширення."

#: ../../library/importlib.rst:1096
msgid ""
"Creates the module object from the given specification in accordance with "
":pep:`489`."
msgstr ""
"Створює об’єкт модуля з заданої специфікації відповідно до :pep:`489`."

#: ../../library/importlib.rst:1103
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Ініціалізує вказаний об’єкт модуля відповідно до :pep:`489`."

#: ../../library/importlib.rst:1109
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
"Повертає ``True``, якщо шлях до файлу вказує на модуль ``__init__`` пакета "
"на основі :attr:`EXTENSION_SUFFIXES`."

#: ../../library/importlib.rst:1114
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "Повертає ``None``, оскільки модулі розширення не мають об’єкта коду."

#: ../../library/importlib.rst:1118
msgid "Returns ``None`` as extension modules do not have source code."
msgstr ""
"Повертає ``None``, оскільки модулі розширення не мають вихідного коду."

#: ../../library/importlib.rst:1129
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace "
"packages::"
msgstr ""

#: ../../library/importlib.rst:1134
msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""

#: ../../library/importlib.rst:1147
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`~module.__spec__` attribute.  Many "
"of these attributes are also available directly on a module: for example, "
"``module.__spec__.origin == module.__file__``.  Note, however, that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`~module.__file__` at runtime and this will not be"
" automatically reflected in the module's :attr:`__spec__.origin "
"<ModuleSpec.origin>`, and vice versa."
msgstr ""

#: ../../library/importlib.rst:1161
msgid ""
"The module's fully qualified name (see :attr:`module.__name__`). The "
":term:`finder` should always set this attribute to a non-empty string."
msgstr ""

#: ../../library/importlib.rst:1166
msgid ""
"The :term:`loader` used to load the module (see :attr:`module.__loader__`). "
"The :term:`finder` should always set this attribute."
msgstr ""

#: ../../library/importlib.rst:1171
msgid ""
"The location the :term:`loader` should use to load the module (see "
":attr:`module.__file__`). For example, for modules loaded from a ``.py`` "
"file this is the filename. The :term:`finder` should always set this "
"attribute to a meaningful value for the :term:`loader` to use.  In the "
"uncommon case that there is not one (like for namespace packages), it should"
" be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1180
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations in "
"which a package's submodules will be found (see :attr:`module.__path__`). "
"Most of the time there will only be a single directory in this list."
msgstr ""

#: ../../library/importlib.rst:1185
msgid ""
"The :term:`finder` should set this attribute to a sequence, even an empty "
"one, to indicate to the import system that the module is a package.  It "
"should be set to ``None`` for non-package modules.  It is set automatically "
"later to a special object for namespace packages."
msgstr ""

#: ../../library/importlib.rst:1193
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1199
msgid ""
"The filename of a compiled version of the module's code (see "
":attr:`module.__cached__`). The :term:`finder` should always set this "
"attribute but it may be ``None`` for modules that do not need compiled code "
"stored."
msgstr ""

#: ../../library/importlib.rst:1206
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the"
" empty string for a top-level module). See :attr:`module.__package__`. If "
"the module is a package then this is the same as :attr:`name`."
msgstr ""

#: ../../library/importlib.rst:1213
msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`!origin` is interpreted "
"and how the module's :attr:`~module.__file__` is populated."
msgstr ""

#: ../../library/importlib.rst:1220
msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that is"
" able to load extension modules in Framework format."
msgstr ""

#: ../../library/importlib.rst:1223
msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS app"
" must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There can"
" be only a single binary per framework, and there can be no executable "
"binary material outside the Frameworks folder."
msgstr ""

#: ../../library/importlib.rst:1229
msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this loader "
"is be registered against the ``.fwork`` file extension, with a ``.fwork`` "
"file acting as a placeholder in the original location of the binary on "
"``sys.path``. The ``.fwork`` file contains the path of the actual binary in "
"the ``Frameworks`` folder, relative to the app bundle. To allow for "
"resolving a framework-packaged binary back to the original location, the "
"framework is expected to contain a ``.origin`` file that contains the "
"location of the ``.fwork`` file, relative to the app bundle."
msgstr ""

#: ../../library/importlib.rst:1240
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module "
"``sources/foo/bar/_whiz.abi3.so``, with ``sources`` being the location "
"registered on ``sys.path``, relative to the application bundle. This module "
"*must* be distributed as "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (creating the framework"
" name from the full import path of the module), with an ``Info.plist`` file "
"in the ``.framework`` directory identifying the binary as a framework. The "
"``foo.bar._whiz`` module would be represented in the original location with "
"a ``sources/foo/bar/_whiz.abi3.fwork`` marker file, containing the path "
"``Frameworks/foo.bar._whiz/foo.bar._whiz``. The framework would also contain"
" ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, containing the"
" path to the ``.fwork`` file."
msgstr ""

#: ../../library/importlib.rst:1254
msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module "
"will report as the location of the ``.fwork`` file. This allows code to use "
"the ``__file__`` of a  module as an anchor for file system traveral. "
"However, the spec origin will reference the location of the *actual* binary "
"in the ``.framework`` folder."
msgstr ""

#: ../../library/importlib.rst:1260
msgid ""
"The Xcode project building the app is responsible for converting any ``.so``"
" files from wherever they exist in the ``PYTHONPATH`` into frameworks in the"
" ``Frameworks`` folder (including stripping extensions from the module file,"
" the addition of framework metadata, and signing the resulting framework), "
"and creating the ``.fwork`` and ``.origin`` files. This will usually be done"
" with a build step in the Xcode project; see the iOS documentation for "
"details on how to construct this build step."
msgstr ""

#: ../../library/importlib.rst:1270
msgid "Availability"
msgstr ""

#: ../../library/importlib.rst:1278
msgid "Path to the ``.fwork`` file for the extension module."
msgstr ""

#: ../../library/importlib.rst:1282
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- Код утиліти для імпортерів"

#: ../../library/importlib.rst:1288
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Вихідний код:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1292
msgid ""
"This module contains the various objects that help in the construction of an"
" :term:`importer`."
msgstr ""
"Цей модуль містить різні об’єкти, які допомагають у створенні "
":term:`importer`."

#: ../../library/importlib.rst:1297
msgid ""
"The bytes which represent the bytecode version number. If you need help with"
" loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Байти, які представляють номер версії байт-коду. Якщо вам потрібна допомога "
"із завантаженням/записом байт-коду, скористайтеся "
":class:`importlib.abc.SourceLoader`."

#: ../../library/importlib.rst:1304
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python"
" 3.2. The ``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then"
" :exc:`NotImplementedError` will be raised)."
msgstr ""
"Поверніть шлях :pep:`3147`/:pep:`488` до скомпільованого файлу, пов’язаного "
"з вихідним *шляхом*. Наприклад, якщо *path* є ``/foo/bar/baz.py``, значення,"
" що повертається, буде ``/foo/bar/__pycache__/baz.cpython-32.pyc`` для "
"Python 3.2. Рядок ``cpython-32`` походить від поточного магічного тегу (див."
" :func:`get_tag`; якщо :attr:`sys.implementation.cache_tag` не визначено, "
"тоді буде викликана :exc:`NotImplementedError`)."

#: ../../library/importlib.rst:1311
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpreter's optimization level to be used. Any other value's "
"string representation is used, so ``/foo/bar/baz.py`` with an *optimization*"
" of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string representation"
" of *optimization* can only be alphanumeric, else :exc:`ValueError` is "
"raised."
msgstr ""
"Параметр *optimization* використовується для визначення рівня оптимізації "
"файлу байт-коду. Порожній рядок не означає оптимізації, тому "
"``/foo/bar/baz.py`` з *оптимізацією* ``''`` призведе до шляху байт-коду "
"``/foo/bar/__pycache__/baz. cpython-32.pyc``. ``None`` спричиняє "
"використання рівня оптимізації інтерпретатора. Використовується будь-яке "
"інше представлення рядка значення, тому ``/foo/bar/baz.py`` з *оптимізацією*"
" ``2`` призведе до шляху байт-коду ``/foo/bar/__pycache__/baz. "
"cpython-32.opt-2.pyc``. Рядкове представлення *оптимізації* може бути лише "
"буквено-цифровим, інакше виникає :exc:`ValueError`."

#: ../../library/importlib.rst:1321
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the"
" system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as"
" setting *optimization* to ``1``. If both *debug_override* an *optimization*"
" are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"Параметр *debug_override* є застарілим і може використовуватися для заміни "
"системного значення для ``__debug__``. Значення ``True`` є еквівалентом "
"налаштування *optimization* для порожнього рядка. Значення ``False`` те "
"саме, що встановити *optimization* на ``1``. Якщо *debug_override* і "
"*оптимізація* не мають значення ``None``, тоді виникає :exc:`TypeError`."

#: ../../library/importlib.rst:1329
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"Параметр *optimization* було додано, а параметр *debug_override* визнано "
"застарілим."

#: ../../library/importlib.rst:1333 ../../library/importlib.rst:1349
#: ../../library/importlib.rst:1438
msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

#: ../../library/importlib.rst:1339
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not conform "
"to :pep:`3147` or :pep:`488` format, a :exc:`ValueError` is raised. If "
":attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
"Враховуючи *шлях* до імені файлу :pep:`3147`, поверніть пов’язаний шлях до "
"файлу вихідного коду. Наприклад, якщо *шлях* є "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``, повернутий шлях буде "
"``/foo/bar/baz.py``. *path* не обов’язково існує, однак якщо він не "
"відповідає формату :pep:`3147` або :pep:`488`, виникає помилка "
":exc:`ValueError`. Якщо :attr:`sys.implementation.cache_tag` не визначено, "
"виникає :exc:`NotImplementedError`."

#: ../../library/importlib.rst:1354
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"Декодуйте задані байти, що представляють вихідний код, і поверніть його як "
"рядок із універсальними символами нового рядка (як вимагає "
":meth:`importlib.abc.InspectLoader.get_source`)."

#: ../../library/importlib.rst:1362
msgid "Resolve a relative module name to an absolute one."
msgstr "Розділіть відносну назву модуля на абсолютну."

#: ../../library/importlib.rst:1364
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` without doing a check to see if the **package** argument "
"is needed."
msgstr ""
"Якщо **ім’я** не має початкових крапок, то **ім’я** просто повертається. Це "
"дозволяє використовувати таке як ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` без виконання перевірки, щоб побачити, чи потрібен "
"аргумент **package**."

#: ../../library/importlib.rst:1369
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). "
":exc:`ImportError` is also raised if a relative name would escape its "
"containing package (e.g. requesting ``..bacon`` from within the ``spam`` "
"package)."
msgstr ""

#: ../../library/importlib.rst:1377
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"Щоб покращити узгодженість із операторами імпорту, підніміть "
":exc:`ImportError` замість :exc:`ValueError` для недійсних відносних спроб "
"імпорту."

#: ../../library/importlib.rst:1384
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the"
" specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned"
" if no spec is found."
msgstr ""

#: ../../library/importlib.rst:1391
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Якщо **назва** призначена для підмодуля (містить крапку), батьківський "
"модуль імпортується автоматично."

#: ../../library/importlib.rst:1394
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""
"**name** і **package** працюють так само, як і для :func:`import_module`."

#: ../../library/importlib.rst:1398
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`~module.__path__` "
"attribute)."
msgstr ""

#: ../../library/importlib.rst:1405
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Створіть новий модуль на основі **spec** і :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

#: ../../library/importlib.rst:1408
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Якщо :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"не повертає ``None``, тоді будь-які раніше існуючі атрибути не будуть "
"скинуті. Крім того, помилка :exc:`AttributeError` не буде викликана, якщо "
"вона буде активована під час доступу до **spec** або встановлення атрибута в"
" модулі."

#: ../../library/importlib.rst:1413
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Цій функції краще використовувати :class:`types.ModuleType` для створення "
"нового модуля, оскільки **spec** використовується для встановлення якомога "
"більшої кількості керованих імпортом атрибутів для модуля."

#: ../../library/importlib.rst:1421
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do"
" for ModuleSpec.  The function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"Фабрична функція для створення екземпляра "
":class:`~importlib.machinery.ModuleSpec` на основі завантажувача. Параметри "
"мають таке ж значення, як і для ModuleSpec. Функція використовує доступні "
"API :term:`loader`, такі як :meth:`InspectLoader.is_package`, щоб заповнити "
"будь-яку відсутню інформацію в специфікації."

#: ../../library/importlib.rst:1431
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in"
" on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"Фабрична функція для створення екземпляра "
":class:`~importlib.machinery.ModuleSpec` на основі шляху до файлу. Відсутню "
"інформацію буде заповнено в специфікації за допомогою API завантажувача та "
"через те, що модуль буде заснований на файлі."

#: ../../library/importlib.rst:1443
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Повертає хеш *source_bytes* як байти. Файл ``.pyc`` на основі хешу вставляє "
":func:`source_hash` вмісту відповідного вихідного файлу у свій заголовок."

#: ../../library/importlib.rst:1451
msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also fail "
"for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""

#: ../../library/importlib.rst:1458
msgid ""
"Note that this function is meant to accommodate an unusual case; one which "
"is likely to eventually go away.  There's is a pretty good chance this is "
"not what you were looking for."
msgstr ""

#: ../../library/importlib.rst:1462
msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr ""

#: ../../library/importlib.rst:1467
msgid ""
"Using this function to disable the check can lead to unexpected behavior and"
" even crashes.  It should only be used during extension module development."
msgstr ""

#: ../../library/importlib.rst:1475
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"Клас, який відкладає виконання завантажувача модуля, поки модуль не отримає "
"доступ до атрибута."

#: ../../library/importlib.rst:1478
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module type "
"is used for the module is required. For those same reasons, the loader's "
":meth:`~importlib.abc.Loader.create_module` method must return ``None`` or a"
" type for which its ``__class__`` attribute can be mutated along with not "
"using :term:`slots <__slots__>`. Finally, modules which substitute the "
"object placed into :data:`sys.modules` will not work as there is no way to "
"properly replace the module references throughout the interpreter safely; "
":exc:`ValueError` is raised if such a substitution is detected."
msgstr ""

#: ../../library/importlib.rst:1489
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For"
" projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"Для проектів, де час запуску є критичним, цей клас дозволяє потенційно "
"мінімізувати вартість завантаження модуля, якщо він ніколи не "
"використовується. Для проектів, де час запуску не є суттєвим, використання "
"цього класу **суворо** не рекомендується через те, що повідомлення про "
"помилки, створені під час завантаження, відкладаються та, таким чином, "
"виникають поза контекстом."

#: ../../library/importlib.rst:1497
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and "
":class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Почався виклик :meth:`~importlib.abc.Loader.create_module`, видаляючи "
"попередження про сумісність для :class:`importlib.machinery.BuiltinImporter`"
" і :class:`importlib.machinery.ExtensionFileLoader`."

#: ../../library/importlib.rst:1504
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""

#: ../../library/importlib.rst:1509
msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""

#: ../../library/importlib.rst:1517
msgid "Examples"
msgstr "Приклади"

#: ../../library/importlib.rst:1520
msgid "Importing programmatically"
msgstr "Програмний імпорт"

#: ../../library/importlib.rst:1522
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"Щоб програмно імпортувати модуль, використовуйте "
":func:`importlib.import_module`. ::"

#: ../../library/importlib.rst:1525
msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""

#: ../../library/importlib.rst:1531
msgid "Checking if a module can be imported"
msgstr "Перевірка можливості імпорту модуля"

#: ../../library/importlib.rst:1533
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"Якщо вам потрібно з’ясувати, чи можна імпортувати модуль без фактичного "
"імпортування, тоді вам слід скористатися :func:`importlib.util.find_spec`."

#: ../../library/importlib.rst:1536
msgid ""
"Note that if ``name`` is a submodule (contains a dot), "
":func:`importlib.util.find_spec` will import the parent module. ::"
msgstr ""
"Зауважте, що якщо ``name`` є підмодулем (містить крапку), "
":func:`importlib.util.find_spec` імпортує батьківський модуль. ::"

#: ../../library/importlib.rst:1540
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""

#: ../../library/importlib.rst:1559
msgid "Importing a source file directly"
msgstr "Пряме імпортування вихідного файлу"

#: ../../library/importlib.rst:1561
msgid ""
"This recipe should be used with caution: it is an approximation of an import"
" statement where the file path is specified directly, rather than "
":data:`sys.path` being searched. Alternatives should first be considered "
"first, such as modifying :data:`sys.path` when a proper module is required, "
"or using :func:`runpy.run_path` when the global namespace resulting from "
"running a Python file is appropriate."
msgstr ""

#: ../../library/importlib.rst:1568
msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr ""

#: ../../library/importlib.rst:1570
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""

#: ../../library/importlib.rst:1592
msgid "Implementing lazy imports"
msgstr "Реалізація відкладеного імпорту"

#: ../../library/importlib.rst:1594
msgid "The example below shows how to implement lazy imports::"
msgstr "У прикладі нижче показано, як реалізувати відкладений імпорт:"

#: ../../library/importlib.rst:1596
msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""

#: ../../library/importlib.rst:1615
msgid "Setting up an importer"
msgstr "Налаштування імпортера"

#: ../../library/importlib.rst:1617
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to choose "
"from depending on your needs: a :term:`meta path finder` or a :term:`path "
"entry finder`. The former is what you would put on :data:`sys.meta_path` "
"while the latter is what you create using a :term:`path entry hook` on "
":data:`sys.path_hooks` which works with :data:`sys.path` entries to "
"potentially create a finder. This example will show you how to register your"
" own importers so that import will use them (for creating an importer for "
"yourself, read the documentation for the appropriate classes defined within "
"this package)::"
msgstr ""

#: ../../library/importlib.rst:1628
msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""

#: ../../library/importlib.rst:1649
msgid "Approximating :func:`importlib.import_module`"
msgstr "Наближення :func:`importlib.import_module`"

#: ../../library/importlib.rst:1651
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""

#: ../../library/importlib.rst:1657
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""

#: ../../library/importlib.rst:422
msgid "universal newlines"
msgstr "універсальні символи нового рядка"

#: ../../library/importlib.rst:422
msgid "importlib.abc.InspectLoader.get_source method"
msgstr ""
