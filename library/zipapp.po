# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:18+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`zipapp` --- Manage executable Python zip archives"
msgstr ":mod:`zipapp` --- Керування виконуваними zip-архівами Python"

msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**Вихідний код:** :source:`Lib/zipapp.py`"

msgid ""
"This module provides tools to manage the creation of zip files containing "
"Python code, which can be  :ref:`executed directly by the Python interpreter "
"<using-on-interface-options>`.  The module provides both a :ref:`zipapp-"
"command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"Цей модуль надає інструменти для керування створенням zip-файлів, що містять "
"код Python, який можна :ref:`виконувати безпосередньо інтерпретатором Python "
"<using-on-interface-options>`. Модуль забезпечує як :ref:`zipapp-command-"
"line-interface`, так і :ref:`zipapp-python-api`."

msgid "Basic Example"
msgstr "Базовий приклад"

msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` can "
"be used to create an executable archive from a directory containing Python "
"code.  When run, the archive will execute the ``main`` function from the "
"module ``myapp`` in the archive."
msgstr ""
"У наступному прикладі показано, як :ref:`zipapp-command-line-interface` "
"можна використовувати для створення виконуваного архіву з каталогу, що "
"містить код Python. Під час запуску архів виконає функцію ``main`` з модуля "
"``myapp`` в архіві."

msgid "Command-Line Interface"
msgstr "Інтерфейс командного рядка"

msgid ""
"When called as a program from the command line, the following form is used:"
msgstr "При виклику програми з командного рядка використовується така форма:"

msgid ""
"If *source* is a directory, this will create an archive from the contents of "
"*source*.  If *source* is a file, it should be an archive, and it will be "
"copied to the target archive (or the contents of its shebang line will be "
"displayed if the --info option is specified)."
msgstr ""
"Якщо *source* є каталогом, буде створено архів із вмісту *source*. Якщо "
"*джерело* є файлом, це має бути архів, і його буде скопійовано до цільового "
"архіву (або буде показано вміст його рядка shebang, якщо вказано параметр --"
"info)."

msgid "The following options are understood:"
msgstr "Розуміються такі варіанти:"

msgid ""
"Write the output to a file named *output*.  If this option is not specified, "
"the output filename will be the same as the input *source*, with the "
"extension ``.pyz`` added.  If an explicit filename is given, it is used as "
"is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"Запишіть вихідні дані у файл з назвою *output*. Якщо цей параметр не "
"вказано, ім’я вихідного файлу буде таким самим, як і вхідне *джерело*, із "
"доданим розширенням ``.pyz``. Якщо вказано явне ім’я файлу, воно "
"використовується як є (тому за потреби слід включити розширення ``.pyz``)."

msgid ""
"An output filename must be specified if the *source* is an archive (and in "
"that case, *output* must not be the same as *source*)."
msgstr ""
"Необхідно вказати ім’я вихідного файлу, якщо *джерело* є архівом (і в такому "
"випадку *вихід* не має збігатися з *джерелом*)."

msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command to "
"run.  Also, on POSIX, make the archive executable.  The default is to write "
"no ``#!`` line, and not make the file executable."
msgstr ""
"Додайте рядок ``#!`` до архіву, вказавши *interpreter* як команду для "
"виконання. Крім того, на POSIX зробіть архів виконуваним. За замовчуванням "
"рядок ``#!`` не записується, і файл не робиться виконуваним."

msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is "
"a package/module in the archive, and \"fn\" is a callable in the given "
"module. The ``__main__.py`` file will execute that callable."
msgstr ""
"Запишіть файл ``__main__.py`` в архів, який виконує *mainfn*. Аргумент "
"*mainfn* повинен мати вигляд \"pkg.mod:fn\", де \"pkg.mod\" — це пакет/"
"модуль в архіві, а \"fn\" — це виклик у даному модулі. Файл ``__main__.py`` "
"виконає цей виклик."

msgid ":option:`--main` cannot be specified when copying an archive."
msgstr ":option:`--main` не можна вказати під час копіювання архіву."

msgid ""
"Compress files with the deflate method, reducing the size of the output "
"file. By default, files are stored uncompressed in the archive."
msgstr ""
"Стискайте файли за допомогою методу deflate, зменшуючи розмір вихідного "
"файлу. За замовчуванням файли зберігаються в архіві без стиснення."

msgid ":option:`--compress` has no effect when copying an archive."
msgstr ":option:`--compress` не діє під час копіювання архіву."

msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes.  "
"In this case, any other options are ignored and SOURCE must be an archive, "
"not a directory."
msgstr ""
"Відобразити інтерпретатор, вбудований в архів, для діагностичних цілей. У "
"цьому випадку будь-які інші параметри ігноруються, а SOURCE має бути "
"архівом, а не каталогом."

msgid "Print a short usage message and exit."
msgstr "Надрукуйте коротке повідомлення про використання та вийдіть."

msgid "Python API"
msgstr "API Python"

msgid "The module defines two convenience functions:"
msgstr "Модуль визначає дві функції зручності:"

msgid ""
"Create an application archive from *source*.  The source can be any of the "
"following:"
msgstr ""
"Створіть архів програми з *джерела*. Джерелом може бути будь-яке з "
"наступного:"

msgid ""
"The name of a directory, or a :term:`path-like object` referring to a "
"directory, in which case a new application archive will be created from the "
"content of that directory."
msgstr ""
"Ім’я каталогу або :term:`path-like object`, що посилається на каталог, у "
"цьому випадку новий архів програми буде створено з вмісту цього каталогу."

msgid ""
"The name of an existing application archive file, or a :term:`path-like "
"object` referring to such a file, in which case the file is copied to the "
"target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if required."
msgstr ""
"Ім’я існуючого архівного файлу програми або :term:`path-like object`, що "
"посилається на такий файл, у такому випадку файл копіюється в ціль (з його "
"зміною, щоб відобразити значення, задане для аргументу *interpreter* ). Якщо "
"потрібно, ім’я файлу має містити розширення ``.pyz``."

msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr ""
"Файловий об'єкт, відкритий для читання в байтовому режимі. Вмістом файлу має "
"бути архів програми, а об’єкт файлу має бути розташований на початку архіву."

msgid ""
"The *target* argument determines where the resulting archive will be written:"
msgstr "Аргумент *target* визначає, куди буде записаний отриманий архів:"

msgid ""
"If it is the name of a file, or a :term:`path-like object`, the archive will "
"be written to that file."
msgstr ""
"Якщо це ім’я файлу або :term:`path-like object`, архів буде записаний у цей "
"файл."

msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr ""
"Якщо це відкритий файловий об’єкт, архів буде записаний у цей файловий "
"об’єкт, який має бути відкритим для запису в байтовому режимі."

msgid ""
"If the target is omitted (or ``None``), the source must be a directory and "
"the target will be a file with the same name as the source, with a ``.pyz`` "
"extension added."
msgstr ""
"Якщо ціль пропущено (або ``None``), джерело має бути каталогом, а ціль буде "
"файлом із такою самою назвою, як і джерело, із доданим розширенням ``.pyz``."

msgid ""
"The *interpreter* argument specifies the name of the Python interpreter with "
"which the archive will be executed.  It is written as a \"shebang\" line at "
"the start of the archive.  On POSIX, this will be interpreted by the OS, and "
"on Windows it will be handled by the Python launcher.  Omitting the "
"*interpreter* results in no shebang line being written.  If an interpreter "
"is specified, and the target is a filename, the executable bit of the target "
"file will be set."
msgstr ""
"Аргумент *інтерпретатор* визначає ім'я інтерпретатора Python, за допомогою "
"якого буде виконуватися архів. Він записується як рядок \"shebang\" на "
"початку архіву. У POSIX це буде інтерпретовано ОС, а в Windows це "
"оброблятиметься програмою запуску Python. Пропуск *інтерпретатора* "
"призводить до того, що рядок shebang не записується. Якщо вказано "
"інтерпретатор, а метою є ім’я файлу, буде встановлено виконуваний біт "
"цільового файлу."

msgid ""
"The *main* argument specifies the name of a callable which will be used as "
"the main program for the archive.  It can only be specified if the source is "
"a directory, and the source does not already contain a ``__main__.py`` "
"file.  The *main* argument should take the form \"pkg.module:callable\" and "
"the archive will be run by importing \"pkg.module\" and executing the given "
"callable with no arguments.  It is an error to omit *main* if the source is "
"a directory and does not contain a ``__main__.py`` file, as otherwise the "
"resulting archive would not be executable."
msgstr ""
"Аргумент *main* вказує назву викликаної програми, яка буде використана як "
"основна програма для архіву. Його можна вказати, лише якщо джерелом є "
"каталог, і джерело ще не містить файл ``__main__.py``. Аргумент *main* має "
"мати вигляд \"pkg.module:callable\", і архів буде запущено шляхом імпорту "
"\"pkg.module\" і виконання заданого callable без аргументів. Пропускати "
"*main* буде помилкою, якщо джерело є каталогом і не містить файлу ``__main__."
"py``, інакше отриманий архів не буде виконуваним."

msgid ""
"The optional *filter* argument specifies a callback function that is passed "
"a Path object representing the path to the file being added (relative to the "
"source directory).  It should return ``True`` if the file is to be added."
msgstr ""
"Необов’язковий аргумент *filter* визначає функцію зворотного виклику, якій "
"передається об’єкт Path, що представляє шлях до доданого файлу (відносно "
"вихідного каталогу). Він має повернути ``True``, якщо файл потрібно додати."

msgid ""
"The optional *compressed* argument determines whether files are compressed.  "
"If set to ``True``, files in the archive are compressed with the deflate "
"method; otherwise, files are stored uncompressed. This argument has no "
"effect when copying an existing archive."
msgstr ""
"Додатковий аргумент *compressed* визначає, чи стискаються файли. Якщо "
"встановлено значення ``True``, файли в архіві стискаються за допомогою "
"методу deflate; інакше файли зберігаються нестисненими. Цей аргумент не діє "
"під час копіювання існуючого архіву."

msgid ""
"If a file object is specified for *source* or *target*, it is the caller's "
"responsibility to close it after calling create_archive."
msgstr ""
"Якщо для *source* або *target* указано файловий об’єкт, закрити його після "
"виклику create_archive несе абонент, що викликає."

msgid ""
"When copying an existing archive, file objects supplied only need ``read`` "
"and ``readline``, or ``write`` methods.  When creating an archive from a "
"directory, if the target is a file object it will be passed to the ``zipfile."
"ZipFile`` class, and must supply the methods needed by that class."
msgstr ""
"Під час копіювання існуючого архіву наданим файловим об’єктам потрібні лише "
"методи ``read`` і ``readline`` або ``write``. Під час створення архіву з "
"каталогу, якщо метою є файловий об’єкт, він буде переданий до класу "
"``zipfile.ZipFile`` і повинен надати методи, необхідні цьому класу."

msgid "Added the *filter* and *compressed* arguments."
msgstr "Додано аргументи *filter* і *compressed*."

msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive* "
"argument can be a filename or a file-like object open for reading in bytes "
"mode.  It is assumed to be at the start of the archive."
msgstr ""
"Повертає інтерпретатор, указаний у рядку ``#!`` на початку архіву. Якщо "
"рядка ``#!`` немає, поверніть :const:`None`. Аргументом *archive* може бути "
"назва файлу або файлоподібний об’єкт, відкритий для читання в байтовому "
"режимі. Передбачається, що він знаходиться на початку архіву."

msgid "Examples"
msgstr "Приклади"

msgid "Pack up a directory into an archive, and run it."
msgstr "Запакуйте каталог в архів і запустіть його."

msgid "The same can be done using the :func:`create_archive` function::"
msgstr "Те саме можна зробити за допомогою функції :func:`create_archive`::"

msgid ""
"To make the application directly executable on POSIX, specify an interpreter "
"to use."
msgstr ""
"Щоб зробити програму безпосередньо виконуваною на POSIX, вкажіть "
"інтерпретатор для використання."

msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr ""
"Щоб замінити рядок shebang в існуючому архіві, створіть модифікований архів "
"за допомогою функції :func:`create_archive`::"

msgid ""
"To update the file in place, do the replacement in memory using a :class:"
"`BytesIO` object, and then overwrite the source afterwards.  Note that there "
"is a risk when overwriting a file in place that an error will result in the "
"loss of the original file.  This code does not protect against such errors, "
"but production code should do so.  Also, this method will only work if the "
"archive fits in memory::"
msgstr ""
"Щоб оновити файл на місці, виконайте заміну в пам’яті за допомогою об’єкта :"
"class:`BytesIO`, а потім перезапишіть джерело. Зауважте, що під час "
"перезапису файлу на місці існує ризик того, що помилка призведе до втрати "
"вихідного файлу. Цей код не захищає від таких помилок, але робочий код "
"повинен це робити. Крім того, цей метод буде працювати тільки якщо архів "
"поміщається в пам'яті:"

msgid "Specifying the Interpreter"
msgstr "Вказівка Інтерпретатора"

msgid ""
"Note that if you specify an interpreter and then distribute your application "
"archive, you need to ensure that the interpreter used is portable.  The "
"Python launcher for Windows supports most common forms of POSIX ``#!`` line, "
"but there are other issues to consider:"
msgstr ""
"Зауважте, що якщо ви вказуєте інтерпретатор, а потім розповсюджуєте свій "
"архів програми, вам потрібно переконатися, що використовуваний інтерпретатор "
"є портативним. Засіб запуску Python для Windows підтримує більшість "
"поширених форм рядка POSIX ``#!``, але є інші проблеми, які слід враховувати:"

msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your users "
"may have either Python 2 or Python 3 as their default, and write your code "
"to work under both versions."
msgstr ""
"Якщо ви використовуєте \"/usr/bin/env python\" (або інші форми команди "
"\"python\", такі як \"/usr/bin/python\"), вам потрібно враховувати, що ваші "
"користувачі можуть мати або Python 2, або Python 3 за замовчуванням і "
"напишіть свій код для роботи в обох версіях."

msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your "
"application will not work for users who do not have that version.  (This may "
"be what you want if you have not made your code Python 2 compatible)."
msgstr ""
"Якщо ви використовуєте явну версію, наприклад \"/usr/bin/env python3\", ваша "
"програма не працюватиме для користувачів, які не мають цієї версії. (Це може "
"бути те, що вам потрібно, якщо ви не зробили свій код сумісним з Python 2)."

msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an "
"exact version like \"/usr/bin/env python3.4\" as you will need to change "
"your shebang line for users of Python 3.5, for example."
msgstr ""
"Немає способу сказати \"python X.Y або пізніша\", тому будьте обережні, "
"використовуючи точну версію, наприклад \"/usr/bin/env python3.4\", оскільки "
"вам потрібно буде змінити рядок shebang для користувачів Python 3.5, "
"наприклад ."

msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""
"Як правило, ви повинні використовувати \"/usr/bin/env python2\" або \"/usr/"
"bin/env python3\", залежно від того, чи ваш код написаний для Python 2 чи 3."

msgid "Creating Standalone Applications with zipapp"
msgstr "Створення автономних програм за допомогою zipap"

msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to have "
"a suitable version of Python installed on their system.  The key to doing "
"this is to bundle all of the application's dependencies into the archive, "
"along with the application code."
msgstr ""
"Використовуючи модуль :mod:`zipapp`, можна створювати самодостатні програми "
"Python, які можна розповсюджувати серед кінцевих користувачів, яким потрібно "
"лише встановити відповідну версію Python у своїй системі. Ключ до цього "
"полягає в тому, щоб об’єднати всі залежності програми в архів разом із кодом "
"програми."

msgid "The steps to create a standalone archive are as follows:"
msgstr "Щоб створити окремий архів, виконайте наведені нижче дії."

msgid ""
"Create your application in a directory as normal, so you have a ``myapp`` "
"directory containing a ``__main__.py`` file, and any supporting application "
"code."
msgstr ""
"Створіть свою програму в каталозі як зазвичай, щоб у вас був каталог "
"``myapp``, що містить файл ``__main__.py`` і будь-який допоміжний код "
"програми."

msgid ""
"Install all of your application's dependencies into the ``myapp`` directory, "
"using pip:"
msgstr ""
"Встановіть усі залежності вашої програми в каталог ``myapp`` за допомогою "
"pip:"

msgid ""
"(this assumes you have your project requirements in a ``requirements.txt`` "
"file - if not, you can just list the dependencies manually on the pip "
"command line)."
msgstr ""
"(це припускає, що у вас є вимоги до проекту у файлі ``requirements.txt`` - "
"якщо ні, ви можете просто вручну перерахувати залежності в командному рядку "
"pip)."

msgid ""
"Optionally, delete the ``.dist-info`` directories created by pip in the "
"``myapp`` directory. These hold metadata for pip to manage the packages, and "
"as you won't be making any further use of pip they aren't required - "
"although it won't do any harm if you leave them."
msgstr ""
"За бажанням видаліть каталоги ``.dist-info``, створені pip у каталозі "
"``myapp``. Вони зберігають метадані для pip для керування пакунками, і "
"оскільки ви більше не використовуватимете pip, вони не потрібні, хоча це не "
"зашкодить, якщо ви їх залишите."

msgid "Package the application using:"
msgstr "Упакуйте програму за допомогою:"

msgid ""
"This will produce a standalone executable, which can be run on any machine "
"with the appropriate interpreter available. See :ref:`zipapp-specifying-the-"
"interpreter` for details. It can be shipped to users as a single file."
msgstr ""
"Це створить окремий виконуваний файл, який можна буде запустити на будь-якій "
"машині з доступним відповідним інтерпретатором. Дивіться :ref:`zipapp-"
"specifying-the-interpreter` для деталей. Його можна надіслати користувачам "
"як один файл."

msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can rename "
"the file to remove the ``.pyz`` extension if you prefer a \"plain\" command "
"name.  On Windows, the ``myapp.pyz[w]`` file is executable by virtue of the "
"fact that the Python interpreter registers the ``.pyz`` and ``.pyzw`` file "
"extensions when installed."
msgstr ""
"В Unix файл ``myapp.pyz`` є виконуваним у тому вигляді, в якому він є. Ви "
"можете перейменувати файл, щоб видалити розширення ``.pyz``, якщо ви "
"віддаєте перевагу \"простій\" назві команди. У Windows файл ``myapp.pyz[w]`` "
"є виконуваним через те, що інтерпретатор Python реєструє розширення файлів "
"``.pyz`` і ``.pyzw`` під час встановлення."

msgid "Making a Windows executable"
msgstr "Створення виконуваного файлу Windows"

msgid ""
"On Windows, registration of the ``.pyz`` extension is optional, and "
"furthermore, there are certain places that don't recognise registered "
"extensions \"transparently\" (the simplest example is that ``subprocess."
"run(['myapp'])`` won't find your application - you need to explicitly "
"specify the extension)."
msgstr ""
"У Windows реєстрація розширення ``.pyz`` необов’язкова, і крім того, є певні "
"місця, які не розпізнають зареєстровані розширення \"прозоро\" (найпростішим "
"прикладом є ``subprocess.run(['myapp'] )`` не знайде вашу програму – вам "
"потрібно явно вказати розширення)."

msgid ""
"On Windows, therefore, it is often preferable to create an executable from "
"the zipapp.  This is relatively easy, although it does require a C "
"compiler.  The basic approach relies on the fact that zipfiles can have "
"arbitrary data prepended, and Windows exe files can have arbitrary data "
"appended.  So by creating a suitable launcher and tacking the ``.pyz`` file "
"onto the end of it, you end up with a single-file executable that runs your "
"application."
msgstr ""
"Тому в Windows часто краще створювати виконуваний файл із zip-програми. Це "
"відносно легко, хоча для цього потрібен компілятор C. Основний підхід "
"ґрунтується на тому факті, що файли zip можуть мати довільні дані, а файли "
"Windows exe можуть мати довільні дані. Отже, створивши відповідний засіб "
"запуску та прикріпивши файл ``.pyz`` до його кінця, ви отримаєте "
"однофайловий виконуваний файл, який запускає вашу програму."

msgid "A suitable launcher can be as simple as the following::"
msgstr "Відповідна програма запуску може бути такою простою:"

msgid ""
"If you define the ``WINDOWS`` preprocessor symbol, this will generate a GUI "
"executable, and without it, a console executable."
msgstr ""
"Якщо ви визначите символ препроцесора ``WINDOWS``, це створить виконуваний "
"файл GUI, а без нього — виконуваний файл консолі."

msgid ""
"To compile the executable, you can either just use the standard MSVC command "
"line tools, or you can take advantage of the fact that distutils knows how "
"to compile Python source::"
msgstr ""
"Щоб скомпілювати виконуваний файл, ви можете або просто скористатися "
"стандартними інструментами командного рядка MSVC, або ви можете скористатися "
"тим фактом, що distutils знає, як скомпілювати джерело Python::"

msgid ""
"The resulting launcher uses the \"Limited ABI\", so it will run unchanged "
"with any version of Python 3.x.  All it needs is for Python (``python3."
"dll``) to be on the user's ``PATH``."
msgstr ""
"Отриманий засіб запуску використовує \"Обмежений ABI\", тому він працюватиме "
"без змін з будь-якою версією Python 3.x. Все, що йому потрібно, це щоб "
"Python (``python3.dll``) знаходився на ``PATH`` користувача."

msgid ""
"For a fully standalone distribution, you can distribute the launcher with "
"your application appended, bundled with the Python \"embedded\" "
"distribution.  This will run on any PC with the appropriate architecture (32 "
"bit or 64 bit)."
msgstr ""
"Для повністю автономного дистрибутива ви можете розповсюджувати програму "
"запуску з доданою програмою разом із \"вбудованим\" дистрибутивом Python. "
"Він працюватиме на будь-якому ПК з відповідною архітектурою (32- або 64-"
"розрядною)."

msgid "Caveats"
msgstr "Застереження"

msgid ""
"There are some limitations to the process of bundling your application into "
"a single file.  In most, if not all, cases they can be addressed without "
"needing major changes to your application."
msgstr ""
"Існують певні обмеження щодо процесу об’єднання програми в один файл. У "
"більшості, якщо не у всіх, випадках їх можна вирішити без необхідності "
"серйозних змін у вашій заявці."

msgid ""
"If your application depends on a package that includes a C extension, that "
"package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to load "
"it). In this case, you can exclude that dependency from the zipfile, and "
"either require your users to have it installed, or ship it alongside your "
"zipfile and add code to your ``__main__.py`` to include the directory "
"containing the unzipped module in ``sys.path``. In this case, you will need "
"to make sure to ship appropriate binaries for your target architecture(s) "
"(and potentially pick the correct version to add to ``sys.path`` at runtime, "
"based on the user's machine)."
msgstr ""
"Якщо ваша програма залежить від пакета, який містить розширення C, цей пакет "
"не можна запустити з zip-файлу (це обмеження ОС, оскільки виконуваний код "
"має бути присутнім у файловій системі, щоб завантажувач ОС міг його "
"завантажити). У цьому випадку ви можете виключити цю залежність із zip-файлу "
"та вимагати, щоб ваші користувачі встановили його, або надіслати його разом "
"із zip-файлом і додати код до свого ``__main__.py``, щоб включити каталог, "
"що містить розархівований модуль, у ``sys.path``. У цьому випадку вам "
"потрібно буде переконатися, що надіслано відповідні двійкові файли для вашої "
"цільової архітектури (і, можливо, вибрати правильну версію для додавання до "
"``sys.path`` під час виконання, на основі комп’ютера користувача)."

msgid ""
"If you are shipping a Windows executable as described above, you either need "
"to ensure that your users have ``python3.dll`` on their PATH (which is not "
"the default behaviour of the installer) or you should bundle your "
"application with the embedded distribution."
msgstr ""
"Якщо ви надсилаєте виконуваний файл Windows, як описано вище, вам потрібно "
"переконатися, що ваші користувачі мають ``python3.dll`` у своєму ШЛЯХУ (що "
"не є поведінкою інсталятора за замовчуванням), або ви повинні об’єднати свою "
"програму з вбудованим розподіл."

msgid ""
"The suggested launcher above uses the Python embedding API.  This means that "
"in your application, ``sys.executable`` will be your application, and *not* "
"a conventional Python interpreter.  Your code and its dependencies need to "
"be prepared for this possibility.  For example, if your application uses "
"the :mod:`multiprocessing` module, it will need to call :func:"
"`multiprocessing.set_executable` to let the module know where to find the "
"standard Python interpreter."
msgstr ""
"Запропонований вище засіб запуску використовує API вбудовування Python. Це "
"означає, що у вашій програмі ``sys.executable`` буде вашою програмою, а *не* "
"звичайним інтерпретатором Python. Ваш код і його залежності мають бути "
"готові до такої можливості. Наприклад, якщо ваша програма використовує "
"модуль :mod:`multiprocessing`, їй потрібно буде викликати :func:"
"`multiprocessing.set_executable`, щоб повідомити модулю, де знайти "
"стандартний інтерпретатор Python."

msgid "The Python Zip Application Archive Format"
msgstr "Формат архіву програми Python Zip"

msgid ""
"Python has been able to execute zip files which contain a ``__main__.py`` "
"file since version 2.6.  In order to be executed by Python, an application "
"archive simply has to be a standard zip file containing a ``__main__.py`` "
"file which will be run as the entry point for the application.  As usual for "
"any Python script, the parent of the script (in this case the zip file) will "
"be placed on :data:`sys.path` and thus further modules can be imported from "
"the zip file."
msgstr ""
"З версії 2.6 Python може виконувати файли zip, які містять файл ``__main__."
"py``. Для виконання Python архів програми просто має бути стандартним zip-"
"файлом, що містить файл ``__main__.py``, який буде запущено як точка входу "
"для програми. Як зазвичай для будь-якого сценарію Python, батьківський "
"сценарій (у цьому випадку zip-файл) буде розміщено в :data:`sys.path` і, "
"таким чином, інші модулі можуть бути імпортовані з zip-файлу."

msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file.  "
"The zip application format uses this ability to prepend a standard POSIX "
"\"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""
"Формат файлу zip дозволяє додавати довільні дані до файлу zip. Формат "
"програми zip використовує цю можливість для додавання до файлу стандартного "
"рядка POSIX \"shebang\" (``#!/path/to/interpreter``)."

msgid "Formally, the Python zip application format is therefore:"
msgstr "Формально формат програми Python zip є таким:"

msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by an "
"interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be "
"encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding()` on "
"POSIX."
msgstr ""
"Додатковий рядок shebang, що містить символи ``b'#!'``, за якими йде ім'я "
"інтерпретатора, а потім символ нового рядка (``b'\\n'``). Ім’я "
"інтерпретатора може бути будь-яким, прийнятним для обробки \"shebang\" ОС "
"або засобу запуску Python у Windows. Інтерпретатор має бути закодований у "
"UTF-8 у Windows та у :func:`sys.getfilesystemencoding()` у POSIX."

msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must be "
"in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The "
"zipfile data can be compressed or uncompressed."
msgstr ""
"Стандартні дані файлу zip, згенеровані модулем :mod:`zipfile`. Вміст zip-"
"файлу *має* включати файл під назвою ``__main__.py`` (який має бути в "
"\"корені\" zip-файлу, тобто не може бути у підкаталозі). Дані файлу zip "
"можна стиснути або розпакувати."

msgid ""
"If an application archive has a shebang line, it may have the executable bit "
"set on POSIX systems, to allow it to be executed directly."
msgstr ""
"Якщо в архіві програми є рядок shebang, він може мати біт виконуваного "
"файлу, встановлений у системах POSIX, щоб дозволити його виконання "
"безпосередньо."

msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr ""
"Немає вимог, щоб інструменти в цьому модулі використовувалися для створення "
"архівів програми - модуль є зручним, але архіви у вищезазначеному форматі, "
"створені будь-якими засобами, прийнятні для Python."
