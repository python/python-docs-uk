# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 01:18+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/zipapp.rst:2
msgid ":mod:`!zipapp` --- Manage executable Python zip archives"
msgstr ""

#: ../../library/zipapp.rst:9
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**Вихідний код:** :source:`Lib/zipapp.py`"

#: ../../library/zipapp.rst:16
msgid ""
"This module provides tools to manage the creation of zip files containing "
"Python code, which can be  :ref:`executed directly by the Python interpreter"
" <using-on-interface-options>`.  The module provides both a :ref:`zipapp-"
"command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"Цей модуль надає інструменти для керування створенням zip-файлів, що містять"
" код Python, який можна :ref:`виконувати безпосередньо інтерпретатором "
"Python <using-on-interface-options>`. Модуль забезпечує як :ref:`zipapp-"
"command-line-interface`, так і :ref:`zipapp-python-api`."

#: ../../library/zipapp.rst:23
msgid "Basic Example"
msgstr "Базовий приклад"

#: ../../library/zipapp.rst:25
msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` can"
" be used to create an executable archive from a directory containing Python "
"code.  When run, the archive will execute the ``main`` function from the "
"module ``myapp`` in the archive."
msgstr ""
"У наступному прикладі показано, як :ref:`zipapp-command-line-interface` "
"можна використовувати для створення виконуваного архіву з каталогу, що "
"містить код Python. Під час запуску архів виконає функцію ``main`` з модуля "
"``myapp`` в архіві."

#: ../../library/zipapp.rst:30
msgid ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""

#: ../../library/zipapp.rst:40
msgid "Command-Line Interface"
msgstr "Інтерфейс командного рядка"

#: ../../library/zipapp.rst:42
msgid ""
"When called as a program from the command line, the following form is used:"
msgstr "При виклику програми з командного рядка використовується така форма:"

#: ../../library/zipapp.rst:44
msgid "$ python -m zipapp source [options]"
msgstr ""

#: ../../library/zipapp.rst:48
msgid ""
"If *source* is a directory, this will create an archive from the contents of"
" *source*.  If *source* is a file, it should be an archive, and it will be "
"copied to the target archive (or the contents of its shebang line will be "
"displayed if the --info option is specified)."
msgstr ""
"Якщо *source* є каталогом, буде створено архів із вмісту *source*. Якщо "
"*джерело* є файлом, це має бути архів, і його буде скопійовано до цільового "
"архіву (або буде показано вміст його рядка shebang, якщо вказано параметр "
"--info)."

#: ../../library/zipapp.rst:53
msgid "The following options are understood:"
msgstr "Розуміються такі варіанти:"

#: ../../library/zipapp.rst:59
msgid ""
"Write the output to a file named *output*.  If this option is not specified,"
" the output filename will be the same as the input *source*, with the "
"extension ``.pyz`` added.  If an explicit filename is given, it is used as "
"is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"Запишіть вихідні дані у файл з назвою *output*. Якщо цей параметр не "
"вказано, ім’я вихідного файлу буде таким самим, як і вхідне *джерело*, із "
"доданим розширенням ``.pyz``. Якщо вказано явне ім’я файлу, воно "
"використовується як є (тому за потреби слід включити розширення ``.pyz``)."

#: ../../library/zipapp.rst:64
msgid ""
"An output filename must be specified if the *source* is an archive (and in "
"that case, *output* must not be the same as *source*)."
msgstr ""
"Необхідно вказати ім’я вихідного файлу, якщо *джерело* є архівом (і в такому"
" випадку *вихід* не має збігатися з *джерелом*)."

#: ../../library/zipapp.rst:69
msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command to "
"run.  Also, on POSIX, make the archive executable.  The default is to write "
"no ``#!`` line, and not make the file executable."
msgstr ""
"Додайте рядок ``#!`` до архіву, вказавши *interpreter* як команду для "
"виконання. Крім того, на POSIX зробіть архів виконуваним. За замовчуванням "
"рядок ``#!`` не записується, і файл не робиться виконуваним."

#: ../../library/zipapp.rst:75
msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is "
"a package/module in the archive, and \"fn\" is a callable in the given "
"module. The ``__main__.py`` file will execute that callable."
msgstr ""
"Запишіть файл ``__main__.py`` в архів, який виконує *mainfn*. Аргумент "
"*mainfn* повинен мати вигляд \"pkg.mod:fn\", де \"pkg.mod\" — це "
"пакет/модуль в архіві, а \"fn\" — це виклик у даному модулі. Файл "
"``__main__.py`` виконає цей виклик."

#: ../../library/zipapp.rst:80
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr ":option:`--main` не можна вказати під час копіювання архіву."

#: ../../library/zipapp.rst:84
msgid ""
"Compress files with the deflate method, reducing the size of the output "
"file. By default, files are stored uncompressed in the archive."
msgstr ""
"Стискайте файли за допомогою методу deflate, зменшуючи розмір вихідного "
"файлу. За замовчуванням файли зберігаються в архіві без стиснення."

#: ../../library/zipapp.rst:87
msgid ":option:`--compress` has no effect when copying an archive."
msgstr ":option:`--compress` не діє під час копіювання архіву."

#: ../../library/zipapp.rst:93
msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes.  "
"In this case, any other options are ignored and SOURCE must be an archive, "
"not a directory."
msgstr ""
"Відобразити інтерпретатор, вбудований в архів, для діагностичних цілей. У "
"цьому випадку будь-які інші параметри ігноруються, а SOURCE має бути "
"архівом, а не каталогом."

#: ../../library/zipapp.rst:99
msgid "Print a short usage message and exit."
msgstr "Надрукуйте коротке повідомлення про використання та вийдіть."

#: ../../library/zipapp.rst:105
msgid "Python API"
msgstr "API Python"

#: ../../library/zipapp.rst:107
msgid "The module defines two convenience functions:"
msgstr "Модуль визначає дві функції зручності:"

#: ../../library/zipapp.rst:112
msgid ""
"Create an application archive from *source*.  The source can be any of the "
"following:"
msgstr ""
"Створіть архів програми з *джерела*. Джерелом може бути будь-яке з "
"наступного:"

#: ../../library/zipapp.rst:115
msgid ""
"The name of a directory, or a :term:`path-like object` referring to a "
"directory, in which case a new application archive will be created from the "
"content of that directory."
msgstr ""
"Ім’я каталогу або :term:`path-like object`, що посилається на каталог, у "
"цьому випадку новий архів програми буде створено з вмісту цього каталогу."

#: ../../library/zipapp.rst:118
msgid ""
"The name of an existing application archive file, or a :term:`path-like "
"object` referring to such a file, in which case the file is copied to the "
"target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if "
"required."
msgstr ""
"Ім’я існуючого архівного файлу програми або :term:`path-like object`, що "
"посилається на такий файл, у такому випадку файл копіюється в ціль (з його "
"зміною, щоб відобразити значення, задане для аргументу *interpreter* ). Якщо"
" потрібно, ім’я файлу має містити розширення ``.pyz``."

#: ../../library/zipapp.rst:122
msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr ""
"Файловий об'єкт, відкритий для читання в байтовому режимі. Вмістом файлу має"
" бути архів програми, а об’єкт файлу має бути розташований на початку "
"архіву."

#: ../../library/zipapp.rst:126
msgid ""
"The *target* argument determines where the resulting archive will be "
"written:"
msgstr "Аргумент *target* визначає, куди буде записаний отриманий архів:"

#: ../../library/zipapp.rst:129
msgid ""
"If it is the name of a file, or a :term:`path-like object`, the archive will"
" be written to that file."
msgstr ""
"Якщо це ім’я файлу або :term:`path-like object`, архів буде записаний у цей "
"файл."

#: ../../library/zipapp.rst:131
msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr ""
"Якщо це відкритий файловий об’єкт, архів буде записаний у цей файловий "
"об’єкт, який має бути відкритим для запису в байтовому режимі."

#: ../../library/zipapp.rst:133
msgid ""
"If the target is omitted (or ``None``), the source must be a directory and "
"the target will be a file with the same name as the source, with a ``.pyz`` "
"extension added."
msgstr ""
"Якщо ціль пропущено (або ``None``), джерело має бути каталогом, а ціль буде "
"файлом із такою самою назвою, як і джерело, із доданим розширенням ``.pyz``."

#: ../../library/zipapp.rst:137
msgid ""
"The *interpreter* argument specifies the name of the Python interpreter with"
" which the archive will be executed.  It is written as a \"shebang\" line at"
" the start of the archive.  On POSIX, this will be interpreted by the OS, "
"and on Windows it will be handled by the Python launcher.  Omitting the "
"*interpreter* results in no shebang line being written.  If an interpreter "
"is specified, and the target is a filename, the executable bit of the target"
" file will be set."
msgstr ""
"Аргумент *інтерпретатор* визначає ім'я інтерпретатора Python, за допомогою "
"якого буде виконуватися архів. Він записується як рядок \"shebang\" на "
"початку архіву. У POSIX це буде інтерпретовано ОС, а в Windows це "
"оброблятиметься програмою запуску Python. Пропуск *інтерпретатора* "
"призводить до того, що рядок shebang не записується. Якщо вказано "
"інтерпретатор, а метою є ім’я файлу, буде встановлено виконуваний біт "
"цільового файлу."

#: ../../library/zipapp.rst:145
msgid ""
"The *main* argument specifies the name of a callable which will be used as "
"the main program for the archive.  It can only be specified if the source is"
" a directory, and the source does not already contain a ``__main__.py`` "
"file.  The *main* argument should take the form \"pkg.module:callable\" and "
"the archive will be run by importing \"pkg.module\" and executing the given "
"callable with no arguments.  It is an error to omit *main* if the source is "
"a directory and does not contain a ``__main__.py`` file, as otherwise the "
"resulting archive would not be executable."
msgstr ""
"Аргумент *main* вказує назву викликаної програми, яка буде використана як "
"основна програма для архіву. Його можна вказати, лише якщо джерелом є "
"каталог, і джерело ще не містить файл ``__main__.py``. Аргумент *main* має "
"мати вигляд \"pkg.module:callable\", і архів буде запущено шляхом імпорту "
"\"pkg.module\" і виконання заданого callable без аргументів. Пропускати "
"*main* буде помилкою, якщо джерело є каталогом і не містить файлу "
"``__main__.py``, інакше отриманий архів не буде виконуваним."

#: ../../library/zipapp.rst:155
msgid ""
"The optional *filter* argument specifies a callback function that is passed "
"a Path object representing the path to the file being added (relative to the"
" source directory).  It should return ``True`` if the file is to be added."
msgstr ""
"Необов’язковий аргумент *filter* визначає функцію зворотного виклику, якій "
"передається об’єкт Path, що представляє шлях до доданого файлу (відносно "
"вихідного каталогу). Він має повернути ``True``, якщо файл потрібно додати."

#: ../../library/zipapp.rst:160
msgid ""
"The optional *compressed* argument determines whether files are compressed."
"  If set to ``True``, files in the archive are compressed with the deflate "
"method; otherwise, files are stored uncompressed. This argument has no "
"effect when copying an existing archive."
msgstr ""
"Додатковий аргумент *compressed* визначає, чи стискаються файли. Якщо "
"встановлено значення ``True``, файли в архіві стискаються за допомогою "
"методу deflate; інакше файли зберігаються нестисненими. Цей аргумент не діє "
"під час копіювання існуючого архіву."

#: ../../library/zipapp.rst:165
msgid ""
"If a file object is specified for *source* or *target*, it is the caller's "
"responsibility to close it after calling create_archive."
msgstr ""
"Якщо для *source* або *target* указано файловий об’єкт, закрити його після "
"виклику create_archive несе абонент, що викликає."

#: ../../library/zipapp.rst:168
msgid ""
"When copying an existing archive, file objects supplied only need ``read`` "
"and ``readline``, or ``write`` methods.  When creating an archive from a "
"directory, if the target is a file object it will be passed to the "
"``zipfile.ZipFile`` class, and must supply the methods needed by that class."
msgstr ""
"Під час копіювання існуючого архіву наданим файловим об’єктам потрібні лише "
"методи ``read`` і ``readline`` або ``write``. Під час створення архіву з "
"каталогу, якщо метою є файловий об’єкт, він буде переданий до класу "
"``zipfile.ZipFile`` і повинен надати методи, необхідні цьому класу."

#: ../../library/zipapp.rst:174
msgid "Added the *filter* and *compressed* parameters."
msgstr ""

#: ../../library/zipapp.rst:179
msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive* "
"argument can be a filename or a file-like object open for reading in bytes "
"mode.  It is assumed to be at the start of the archive."
msgstr ""
"Повертає інтерпретатор, указаний у рядку ``#!`` на початку архіву. Якщо "
"рядка ``#!`` немає, поверніть :const:`None`. Аргументом *archive* може бути "
"назва файлу або файлоподібний об’єкт, відкритий для читання в байтовому "
"режимі. Передбачається, що він знаходиться на початку архіву."

#: ../../library/zipapp.rst:188
msgid "Examples"
msgstr "Приклади"

#: ../../library/zipapp.rst:190
msgid "Pack up a directory into an archive, and run it."
msgstr "Запакуйте каталог в архів і запустіть його."

#: ../../library/zipapp.rst:192
msgid ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""

#: ../../library/zipapp.rst:198
msgid "The same can be done using the :func:`create_archive` function::"
msgstr "Те саме можна зробити за допомогою функції :func:`create_archive`::"

#: ../../library/zipapp.rst:200
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"
msgstr ""

#: ../../library/zipapp.rst:203
msgid ""
"To make the application directly executable on POSIX, specify an interpreter"
" to use."
msgstr ""
"Щоб зробити програму безпосередньо виконуваною на POSIX, вкажіть "
"інтерпретатор для використання."

#: ../../library/zipapp.rst:206
msgid ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"
msgstr ""

#: ../../library/zipapp.rst:212
msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr ""
"Щоб замінити рядок shebang в існуючому архіві, створіть модифікований архів "
"за допомогою функції :func:`create_archive`::"

#: ../../library/zipapp.rst:215
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', '/usr/bin/python3')"
msgstr ""

#: ../../library/zipapp.rst:218
msgid ""
"To update the file in place, do the replacement in memory using a "
":class:`~io.BytesIO` object, and then overwrite the source afterwards.  Note"
" that there is a risk when overwriting a file in place that an error will "
"result in the loss of the original file.  This code does not protect against"
" such errors, but production code should do so.  Also, this method will only"
" work if the archive fits in memory::"
msgstr ""

#: ../../library/zipapp.rst:225
msgid ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"
msgstr ""

#: ../../library/zipapp.rst:236
msgid "Specifying the Interpreter"
msgstr "Вказівка Інтерпретатора"

#: ../../library/zipapp.rst:238
msgid ""
"Note that if you specify an interpreter and then distribute your application"
" archive, you need to ensure that the interpreter used is portable.  The "
"Python launcher for Windows supports most common forms of POSIX ``#!`` line,"
" but there are other issues to consider:"
msgstr ""
"Зауважте, що якщо ви вказуєте інтерпретатор, а потім розповсюджуєте свій "
"архів програми, вам потрібно переконатися, що використовуваний інтерпретатор"
" є портативним. Засіб запуску Python для Windows підтримує більшість "
"поширених форм рядка POSIX ``#!``, але є інші проблеми, які слід "
"враховувати:"

#: ../../library/zipapp.rst:243
msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your users "
"may have either Python 2 or Python 3 as their default, and write your code "
"to work under both versions."
msgstr ""
"Якщо ви використовуєте \"/usr/bin/env python\" (або інші форми команди "
"\"python\", такі як \"/usr/bin/python\"), вам потрібно враховувати, що ваші "
"користувачі можуть мати або Python 2, або Python 3 за замовчуванням і "
"напишіть свій код для роботи в обох версіях."

#: ../../library/zipapp.rst:247
msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your "
"application will not work for users who do not have that version.  (This may"
" be what you want if you have not made your code Python 2 compatible)."
msgstr ""
"Якщо ви використовуєте явну версію, наприклад \"/usr/bin/env python3\", ваша"
" програма не працюватиме для користувачів, які не мають цієї версії. (Це "
"може бути те, що вам потрібно, якщо ви не зробили свій код сумісним з Python"
" 2)."

#: ../../library/zipapp.rst:250
msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an "
"exact version like \"/usr/bin/env python3.4\" as you will need to change "
"your shebang line for users of Python 3.5, for example."
msgstr ""
"Немає способу сказати \"python X.Y або пізніша\", тому будьте обережні, "
"використовуючи точну версію, наприклад \"/usr/bin/env python3.4\", оскільки "
"вам потрібно буде змінити рядок shebang для користувачів Python 3.5, "
"наприклад ."

#: ../../library/zipapp.rst:254
msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""
"Як правило, ви повинні використовувати \"/usr/bin/env python2\" або "
"\"/usr/bin/env python3\", залежно від того, чи ваш код написаний для Python "
"2 чи 3."

#: ../../library/zipapp.rst:259
msgid "Creating Standalone Applications with zipapp"
msgstr "Створення автономних програм за допомогою zipap"

#: ../../library/zipapp.rst:261
msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to have"
" a suitable version of Python installed on their system.  The key to doing "
"this is to bundle all of the application's dependencies into the archive, "
"along with the application code."
msgstr ""
"Використовуючи модуль :mod:`zipapp`, можна створювати самодостатні програми "
"Python, які можна розповсюджувати серед кінцевих користувачів, яким потрібно"
" лише встановити відповідну версію Python у своїй системі. Ключ до цього "
"полягає в тому, щоб об’єднати всі залежності програми в архів разом із кодом"
" програми."

#: ../../library/zipapp.rst:267
msgid "The steps to create a standalone archive are as follows:"
msgstr "Щоб створити окремий архів, виконайте наведені нижче дії."

#: ../../library/zipapp.rst:269
msgid ""
"Create your application in a directory as normal, so you have a ``myapp`` "
"directory containing a ``__main__.py`` file, and any supporting application "
"code."
msgstr ""
"Створіть свою програму в каталозі як зазвичай, щоб у вас був каталог "
"``myapp``, що містить файл ``__main__.py`` і будь-який допоміжний код "
"програми."

#: ../../library/zipapp.rst:273
msgid ""
"Install all of your application's dependencies into the ``myapp`` directory,"
" using pip:"
msgstr ""
"Встановіть усі залежності вашої програми в каталог ``myapp`` за допомогою "
"pip:"

#: ../../library/zipapp.rst:276
msgid "$ python -m pip install -r requirements.txt --target myapp"
msgstr ""

#: ../../library/zipapp.rst:280
msgid ""
"(this assumes you have your project requirements in a ``requirements.txt`` "
"file - if not, you can just list the dependencies manually on the pip "
"command line)."
msgstr ""
"(це припускає, що у вас є вимоги до проекту у файлі ``requirements.txt`` - "
"якщо ні, ви можете просто вручну перерахувати залежності в командному рядку "
"pip)."

#: ../../library/zipapp.rst:284
msgid "Package the application using:"
msgstr "Упакуйте програму за допомогою:"

#: ../../library/zipapp.rst:286
msgid "$ python -m zipapp -p \"interpreter\" myapp"
msgstr ""

#: ../../library/zipapp.rst:290
msgid ""
"This will produce a standalone executable, which can be run on any machine "
"with the appropriate interpreter available. See :ref:`zipapp-specifying-the-"
"interpreter` for details. It can be shipped to users as a single file."
msgstr ""
"Це створить окремий виконуваний файл, який можна буде запустити на будь-якій"
" машині з доступним відповідним інтерпретатором. Дивіться :ref:`zipapp-"
"specifying-the-interpreter` для деталей. Його можна надіслати користувачам "
"як один файл."

#: ../../library/zipapp.rst:294
msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can rename "
"the file to remove the ``.pyz`` extension if you prefer a \"plain\" command "
"name.  On Windows, the ``myapp.pyz[w]`` file is executable by virtue of the "
"fact that the Python interpreter registers the ``.pyz`` and ``.pyzw`` file "
"extensions when installed."
msgstr ""
"В Unix файл ``myapp.pyz`` є виконуваним у тому вигляді, в якому він є. Ви "
"можете перейменувати файл, щоб видалити розширення ``.pyz``, якщо ви "
"віддаєте перевагу \"простій\" назві команди. У Windows файл ``myapp.pyz[w]``"
" є виконуваним через те, що інтерпретатор Python реєструє розширення файлів "
"``.pyz`` і ``.pyzw`` під час встановлення."

#: ../../library/zipapp.rst:302
msgid "Caveats"
msgstr "Застереження"

#: ../../library/zipapp.rst:304
msgid ""
"If your application depends on a package that includes a C extension, that "
"package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to load "
"it). In this case, you can exclude that dependency from the zipfile, and "
"either require your users to have it installed, or ship it alongside your "
"zipfile and add code to your ``__main__.py`` to include the directory "
"containing the unzipped module in ``sys.path``. In this case, you will need "
"to make sure to ship appropriate binaries for your target architecture(s) "
"(and potentially pick the correct version to add to ``sys.path`` at runtime,"
" based on the user's machine)."
msgstr ""
"Якщо ваша програма залежить від пакета, який містить розширення C, цей пакет"
" не можна запустити з zip-файлу (це обмеження ОС, оскільки виконуваний код "
"має бути присутнім у файловій системі, щоб завантажувач ОС міг його "
"завантажити). У цьому випадку ви можете виключити цю залежність із zip-файлу"
" та вимагати, щоб ваші користувачі встановили його, або надіслати його разом"
" із zip-файлом і додати код до свого ``__main__.py``, щоб включити каталог, "
"що містить розархівований модуль, у ``sys.path``. У цьому випадку вам "
"потрібно буде переконатися, що надіслано відповідні двійкові файли для вашої"
" цільової архітектури (і, можливо, вибрати правильну версію для додавання до"
" ``sys.path`` під час виконання, на основі комп’ютера користувача)."

#: ../../library/zipapp.rst:316
msgid "The Python Zip Application Archive Format"
msgstr "Формат архіву програми Python Zip"

#: ../../library/zipapp.rst:318
msgid ""
"Python has been able to execute zip files which contain a ``__main__.py`` "
"file since version 2.6.  In order to be executed by Python, an application "
"archive simply has to be a standard zip file containing a ``__main__.py`` "
"file which will be run as the entry point for the application.  As usual for"
" any Python script, the parent of the script (in this case the zip file) "
"will be placed on :data:`sys.path` and thus further modules can be imported "
"from the zip file."
msgstr ""
"З версії 2.6 Python може виконувати файли zip, які містять файл "
"``__main__.py``. Для виконання Python архів програми просто має бути "
"стандартним zip-файлом, що містить файл ``__main__.py``, який буде запущено "
"як точка входу для програми. Як зазвичай для будь-якого сценарію Python, "
"батьківський сценарій (у цьому випадку zip-файл) буде розміщено в "
":data:`sys.path` і, таким чином, інші модулі можуть бути імпортовані з zip-"
"файлу."

#: ../../library/zipapp.rst:325
msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file.  "
"The zip application format uses this ability to prepend a standard POSIX "
"\"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""
"Формат файлу zip дозволяє додавати довільні дані до файлу zip. Формат "
"програми zip використовує цю можливість для додавання до файлу стандартного "
"рядка POSIX \"shebang\" (``#!/path/to/interpreter``)."

#: ../../library/zipapp.rst:329
msgid "Formally, the Python zip application format is therefore:"
msgstr "Формально формат програми Python zip є таким:"

#: ../../library/zipapp.rst:331
msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by an"
" interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be "
"encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding` on "
"POSIX."
msgstr ""

#: ../../library/zipapp.rst:336
msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must be "
"in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The"
" zipfile data can be compressed or uncompressed."
msgstr ""
"Стандартні дані файлу zip, згенеровані модулем :mod:`zipfile`. Вміст zip-"
"файлу *має* включати файл під назвою ``__main__.py`` (який має бути в "
"\"корені\" zip-файлу, тобто не може бути у підкаталозі). Дані файлу zip "
"можна стиснути або розпакувати."

#: ../../library/zipapp.rst:341
msgid ""
"If an application archive has a shebang line, it may have the executable bit"
" set on POSIX systems, to allow it to be executed directly."
msgstr ""
"Якщо в архіві програми є рядок shebang, він може мати біт виконуваного "
"файлу, встановлений у системах POSIX, щоб дозволити його виконання "
"безпосередньо."

#: ../../library/zipapp.rst:344
msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr ""
"Немає вимог, щоб інструменти в цьому модулі використовувалися для створення "
"архівів програми - модуль є зручним, але архіви у вищезазначеному форматі, "
"створені будь-якими засобами, прийнятні для Python."

#: ../../library/zipapp.rst:11
msgid "Executable Zip Files"
msgstr ""
