# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-04 14:18+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/unittest.rst:2
msgid ":mod:`!unittest` --- Unit testing framework"
msgstr ""

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Вихідний код:** :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Якщо ви вже знайомі з основними концепціями тестування, ви можете перейти "
"до :ref:`списку методів assert <assert-methods>`.)"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"Фреймворк модульного тестування :mod:`unittest` спочатку був натхненний "
"JUnit і має подібний смак, як основні фреймворки модульного тестування "
"іншими мовами. Він підтримує автоматизацію тестування, спільне використання "
"коду налаштування та завершення тестів, об’єднання тестів у колекції та "
"незалежність тестів від структури звітування."

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Щоб досягти цього, :mod:`unittest` підтримує деякі важливі концепції в "
"об’єктно-орієнтований спосіб:"

#: ../../library/unittest.rst:28
msgid "test fixture"
msgstr "тестове пристосування"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
":dfn:`test fixture` представляє підготовку, необхідну для виконання одного "
"або кількох тестів і будь-яких пов’язаних дій очищення. Це може включати, "
"наприклад, створення тимчасових або проксі-баз даних, каталогів або запуск "
"серверного процесу."

#: ../../library/unittest.rst:34
msgid "test case"
msgstr "тестовий випадок"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a"
" base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
":dfn:`test case` — це окрема одиниця тестування. Він перевіряє конкретну "
"відповідь на певний набір вхідних даних. :mod:`unittest` надає базовий клас,"
" :class:`TestCase`, який можна використовувати для створення нових тестів."

#: ../../library/unittest.rst:39
msgid "test suite"
msgstr "набір тестів"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It"
" is used to aggregate tests that should be executed together."
msgstr ""
":dfn:`test suite` — це набір тестів, наборів тестів або обох. Він "
"використовується для агрегування тестів, які слід виконувати разом."

#: ../../library/unittest.rst:43
msgid "test runner"
msgstr "тестовий бігун"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
":dfn:`test runner` — це компонент, який керує виконанням тестів і надає "
"результат користувачеві. Виконувач може використовувати графічний інтерфейс,"
" текстовий інтерфейс або повертати спеціальне значення для вказівки "
"результатів виконання тестів."

#: ../../library/unittest.rst:52
msgid "Module :mod:`doctest`"
msgstr "Модуль :mod:`doctest`"

#: ../../library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "Ще один модуль підтримки тестування з зовсім іншим смаком."

#: ../../library/unittest.rst:55
msgid ""
"`Simple Smalltalk Testing: With Patterns "
"<https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Просте тестування Smalltalk: із шаблонами "
"<https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared by"
" :mod:`unittest`."
msgstr ""
"Оригінальна стаття Кента Бека про тестування фреймворків за шаблоном, яким "
"поділився :mod:`unittest`."

#: ../../library/unittest.rst:59
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Фреймворк модульного тестування третьої сторони зі спрощеним синтаксисом для"
" написання тестів. Наприклад, ``assert func(10) == 42``."

#: ../../library/unittest.rst:63
msgid ""
"`The Python Testing Tools Taxonomy "
"<https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"
msgstr ""
"`Таксономія інструментів тестування Python "
"<https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Широкий список інструментів тестування Python, включаючи фреймворки "
"функціонального тестування та бібліотеки макетів об’єктів."

#: ../../library/unittest.rst:67
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Тестування в списку розсилки Python "
"<http://lists.idyll.org/listinfo/testing-in-python>`_"

#: ../../library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"Група спеціальних інтересів для обговорення тестування та інструментів "
"тестування на Python."

#: ../../library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://www.jenkins.io/>`_, `GitHub Actions "
"<https://github.com/features/actions>`_, or `AppVeyor "
"<https://www.appveyor.com/>`_."
msgstr ""

#: ../../library/unittest.rst:83
msgid "Basic example"
msgstr "Базовий приклад"

#: ../../library/unittest.rst:85
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and"
" running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Модуль :mod:`unittest` надає багатий набір інструментів для побудови та "
"виконання тестів. У цьому розділі показано, що невеликого набору "
"інструментів достатньо для задоволення потреб більшості користувачів."

#: ../../library/unittest.rst:89
msgid "Here is a short script to test three string methods::"
msgstr "Ось короткий скрипт для перевірки трьох методів рядків:"

#: ../../library/unittest.rst:91
msgid ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""

#: ../../library/unittest.rst:113
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters"
" ``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Тестовий приклад створюється підкласом :class:`unittest.TestCase`. Три "
"окремі тести визначаються методами, назви яких починаються з літер ``test``."
" Ця домовленість про найменування інформує виконавця тестів про те, які "
"методи представляють тести."

#: ../../library/unittest.rst:118
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or "
":meth:`~TestCase.assertFalse` to verify a condition; or "
":meth:`~TestCase.assertRaises` to verify that a specific exception gets "
"raised.  These methods are used instead of the :keyword:`assert` statement "
"so the test runner can accumulate all test results and produce a report."
msgstr ""
"Суть кожного тесту полягає у виклику :meth:`~TestCase.assertEqual` для "
"перевірки очікуваного результату; :meth:`~TestCase.assertTrue` або "
":meth:`~TestCase.assertFalse` для перевірки умови; або "
":meth:`~TestCase.assertRaises`, щоб перевірити, чи виникає певний виняток. "
"Ці методи використовуються замість оператора :keyword:`assert`, щоб "
"виконавець тесту міг накопичувати всі результати тестування та створювати "
"звіт."

#: ../../library/unittest.rst:125
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you"
" to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Методи :meth:`~TestCase.setUp` і :meth:`~TestCase.tearDown` дозволяють "
"визначати інструкції, які виконуватимуться до і після кожного методу "
"тестування. Більш детально вони описані в розділі :ref:`organizing-tests`."

#: ../../library/unittest.rst:129
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Останній блок показує простий спосіб виконання тестів. :func:`unittest.main`"
" надає інтерфейс командного рядка для тестового сценарію. Під час запуску з "
"командного рядка наведений вище сценарій створює вихідні дані, які "
"виглядають так:"

#: ../../library/unittest.rst:133
msgid ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"
msgstr ""

#: ../../library/unittest.rst:139
msgid ""
"Passing the ``-v`` option to your test script will instruct "
":func:`unittest.main` to enable a higher level of verbosity, and produce the"
" following output::"
msgstr ""
"Передача параметра ``-v`` у ваш тестовий сценарій вказує "
":func:`unittest.main` увімкнути вищий рівень докладності та створить такий "
"вихід:"

#: ../../library/unittest.rst:142
msgid ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"
msgstr ""

#: ../../library/unittest.rst:151
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Наведені вище приклади показують найпоширеніші функції :mod:`unittest`, яких"
" достатньо для задоволення багатьох щоденних потреб тестування. У решті "
"документації розглядається повний набір функцій із перших принципів."

#: ../../library/unittest.rst:155
msgid ""
"The behavior of returning a value from a test method (other than the default"
" ``None`` value), is now deprecated."
msgstr ""

#: ../../library/unittest.rst:163
msgid "Command-Line Interface"
msgstr "Інтерфейс командного рядка"

#: ../../library/unittest.rst:165
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Модуль unittest можна використовувати з командного рядка для запуску тестів "
"із модулів, класів або навіть окремих методів тестування:"

#: ../../library/unittest.rst:168
msgid ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"
msgstr ""

#: ../../library/unittest.rst:172
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Ви можете передати список із будь-якою комбінацією імен модулів і повних "
"імен класів або методів."

#: ../../library/unittest.rst:175
msgid "Test modules can be specified by file path as well::"
msgstr "Тестові модулі також можна вказати шляхом до файлу:"

#: ../../library/unittest.rst:177
msgid "python -m unittest tests/test_something.py"
msgstr ""

#: ../../library/unittest.rst:179
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is"
" converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Це дозволяє використовувати завершення назви файлу оболонки для визначення "
"тестового модуля. Зазначений файл усе ще має бути імпортованим як модуль. "
"Шлях перетворюється на назву модуля шляхом видалення \".py\" та перетворення"
" роздільників шляху на \".\". Якщо ви хочете виконати тестовий файл, який не"
" можна імпортувати як модуль, вам слід виконати цей файл безпосередньо."

#: ../../library/unittest.rst:185
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Ви можете запустити тести з більшою деталізацією (вищою детальністю), "
"передавши прапор -v::"

#: ../../library/unittest.rst:187
msgid "python -m unittest -v test_module"
msgstr ""

#: ../../library/unittest.rst:189
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"При виконанні без аргументів :ref:`unittest-test-discovery` запускається::"

#: ../../library/unittest.rst:191
msgid "python -m unittest"
msgstr ""

#: ../../library/unittest.rst:193
msgid "For a list of all the command-line options::"
msgstr "Список усіх параметрів командного рядка:"

#: ../../library/unittest.rst:195
msgid "python -m unittest -h"
msgstr ""

#: ../../library/unittest.rst:197
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"У попередніх версіях було можливо запускати лише окремі методи тестування, а"
" не модулі чи класи."

#: ../../library/unittest.rst:203
msgid "Command-line options"
msgstr "Параметри командного рядка"

#: ../../library/unittest.rst:205
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` підтримує такі параметри командного рядка:"

#: ../../library/unittest.rst:211
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on"
" test fail or error and is added to the failure messages."
msgstr ""
"Стандартний вихід і стандартні потоки помилок буферизуються під час "
"виконання тесту. Вихідні дані під час проходження тесту відкидаються. "
"Вихідні дані зазвичай відтворюються у разі невдачі тесту або помилки та "
"додаються до повідомлень про помилки."

#: ../../library/unittest.rst:217
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` під час тестового запуску чекає завершення поточного тесту,"
" а потім повідомляє всі результати. Другий :kbd:`Control-C` викликає "
"звичайний виняток :exc:`KeyboardInterrupt`."

#: ../../library/unittest.rst:221
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Перегляньте Обробка сигналів (`Signal Handling`_) для функцій, які "
"забезпечують цю функціональність."

#: ../../library/unittest.rst:225
msgid "Stop the test run on the first error or failure."
msgstr "Зупиніть тестовий запуск при першій помилці або невдачі."

#: ../../library/unittest.rst:229
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Запускайте лише тестові методи та класи, які відповідають шаблону або "
"підрядку. Цю опцію можна використовувати кілька разів, і в цьому випадку "
"будуть включені всі тестові випадки, які відповідають будь-якому із заданих "
"шаблонів."

#: ../../library/unittest.rst:233
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive"
" substring matching is used."
msgstr ""
"Шаблони, які містять символ підстановки (``*``), зіставляються з назвою "
"тесту за допомогою :meth:`fnmatch.fnmatchcase`; інакше використовується "
"просте зіставлення підрядка з урахуванням регістру."

#: ../../library/unittest.rst:237
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Шаблони зіставляються з повною назвою методу тестування, імпортованою "
"завантажувачем тестів."

#: ../../library/unittest.rst:240
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not "
"``bar_tests.FooTest.test_something``."
msgstr ""
"Наприклад, ``-k foo`` відповідає ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_something``, але не "
"``bar_tests.FooTest.test_something``."

#: ../../library/unittest.rst:245
msgid "Show local variables in tracebacks."
msgstr "Показати локальні змінні в трасуваннях."

#: ../../library/unittest.rst:249
msgid "Show the N slowest test cases (N=0 for all)."
msgstr ""

#: ../../library/unittest.rst:251
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Додано параметри командного рядка ``-b``, ``-c`` і ``-f``."

#: ../../library/unittest.rst:254
msgid "The command-line option ``--locals``."
msgstr "Параметр командного рядка ``--locals``."

#: ../../library/unittest.rst:257
msgid "The command-line option ``-k``."
msgstr "Параметр командного рядка ``-k``."

#: ../../library/unittest.rst:260
msgid "The command-line option ``--durations``."
msgstr ""

#: ../../library/unittest.rst:263
msgid ""
"The command line can also be used for test discovery, for running all of the"
" tests in a project or just a subset."
msgstr ""
"Командний рядок також можна використовувати для виявлення тестів, для "
"запуску всіх тестів у проекті або лише підмножини."

#: ../../library/unittest.rst:269
msgid "Test Discovery"
msgstr "Тестове відкриття"

#: ../../library/unittest.rst:273
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test"
" discovery, all of the test files must be :ref:`modules <tut-modules>` or "
":ref:`packages <tut-packages>` importable from the top-level directory of "
"the project (this means that their filenames must be valid :ref:`identifiers"
" <identifiers>`)."
msgstr ""

#: ../../library/unittest.rst:279
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"Виявлення тесту реалізовано в :meth:`TestLoader.discover`, але його також "
"можна використовувати з командного рядка. Основне використання командного "
"рядка:"

#: ../../library/unittest.rst:282
msgid ""
"cd project_directory\n"
"python -m unittest discover"
msgstr ""

#: ../../library/unittest.rst:287
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Як скорочення, ``python -m unittest`` є еквівалентом ``python -m unittest "
"discover``. Якщо ви хочете передати аргументи для перевірки виявлення, "
"підкоманду ``discover`` слід використовувати явно."

#: ../../library/unittest.rst:291
msgid "The ``discover`` sub-command has the following options:"
msgstr "Підкоманда ``discover`` має такі параметри:"

#: ../../library/unittest.rst:297
msgid "Verbose output"
msgstr "Детальний висновок"

#: ../../library/unittest.rst:301
msgid "Directory to start discovery (``.`` default)"
msgstr "Каталог для початку виявлення (``.`` за замовчуванням)"

#: ../../library/unittest.rst:305
msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""
"Шаблон для відповідності тестовим файлам (``test*.py`` за замовчуванням)"

#: ../../library/unittest.rst:309
msgid "Top level directory of project (defaults to start directory)"
msgstr ""
"Каталог верхнього рівня проекту (за замовчуванням це початковий каталог)"

#: ../../library/unittest.rst:311
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as"
" positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Параметри :option:`-s`, :option:`-p` і :option:`-t` можна передати як "
"позиційні аргументи в такому порядку. Наступні два командні рядки "
"еквівалентні:"

#: ../../library/unittest.rst:315
msgid ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""
msgstr ""

#: ../../library/unittest.rst:318
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used"
" as the start directory."
msgstr ""
"Окрім шляху, можна передати назву пакета, наприклад "
"``myproject.subpackage.test``, як початковий каталог. Указане вами ім’я "
"пакета буде імпортовано, а його розташування у файловій системі "
"використовуватиметься як початковий каталог."

#: ../../library/unittest.rst:325
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Відкриття тестів завантажує тести, імпортуючи їх. Після того як тестове "
"виявлення знайде всі тестові файли з початкового каталогу, який ви вкажете, "
"воно перетворює шляхи на імена пакетів для імпорту. Наприклад, "
":file:`foo/bar/baz.py` буде імпортовано як ``foo.bar.baz``."

#: ../../library/unittest.rst:330
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Якщо у вас глобально встановлено пакет, і ви намагаєтеся виявити тест на "
"іншій копії пакета, то імпорт *може* відбутися не з того місця. Якщо це "
"станеться, тестове виявлення попередить вас і вийде."

#: ../../library/unittest.rst:334
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Якщо ви вказуєте початковий каталог як назву пакета, а не як шлях до "
"каталогу, тоді виявлення припускає, що будь-яке місце, з якого він імпортує,"
" є тим розташуванням, яке ви хотіли, тому ви не отримаєте попередження."

#: ../../library/unittest.rst:339
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Тестові модулі та пакети можуть налаштувати тестове завантаження та "
"виявлення за допомогою `load_tests protocol`_."

#: ../../library/unittest.rst:342
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""
"Тестове виявлення підтримує :term:`пакети простору імен <namespace package>`"
" для початкового каталогу. Зауважте, що вам також потрібно вказати каталог "
"верхнього рівня (наприклад, ``python -m unittest discover -s root/namespace "
"-t root``)."

#: ../../library/unittest.rst:348
msgid ""
":mod:`unittest` dropped the :term:`namespace packages <namespace package>` "
"support in Python 3.11. It has been broken since Python 3.7. Start directory"
" and subdirectories containing tests must be regular package that have "
"``__init__.py`` file."
msgstr ""

#: ../../library/unittest.rst:354
msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr ""

#: ../../library/unittest.rst:358
msgid ""
"# proj/  <-- current directory\n"
"#   namespace/\n"
"#     mypkg/\n"
"#       __init__.py\n"
"#       test_mypkg.py\n"
"\n"
"python -m unittest discover -s namespace.mypkg -t ."
msgstr ""

#: ../../library/unittest.rst:370
msgid "Organizing test code"
msgstr "Організація тестового коду"

#: ../../library/unittest.rst:372
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In "
":mod:`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of "
":class:`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Основними будівельними блоками модульного тестування є :dfn:`test cases` ---"
" окремі сценарії, які необхідно налаштувати та перевірити на правильність. У"
" :mod:`unittest` тестові випадки представлені екземплярами "
":class:`unittest.TestCase`. Щоб створити власні тестові випадки, ви повинні "
"написати підкласи :class:`TestCase` або використати "
":class:`FunctionTestCase`."

#: ../../library/unittest.rst:378
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Тестовий код екземпляра :class:`TestCase` має бути повністю самостійним, щоб"
" його можна було запускати окремо або в довільній комбінації з будь-якою "
"кількістю інших тестів."

#: ../../library/unittest.rst:382
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific"
" testing code::"
msgstr ""
"Найпростіший підклас :class:`TestCase` просто реалізує тестовий метод (тобто"
" метод, назва якого починається з ``test``), щоб виконати певний код "
"тестування:"

#: ../../library/unittest.rst:386
msgid ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"
msgstr ""

#: ../../library/unittest.rst:393
msgid ""
"Note that in order to test something, we use one of the :ref:`assert\\* "
"methods <assert-methods>` provided by the :class:`TestCase` base class.  If "
"the test fails, an exception will be raised with an explanatory message, and"
" :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any other"
" exceptions will be treated as :dfn:`errors`."
msgstr ""

#: ../../library/unittest.rst:399
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called "
":meth:`~TestCase.setUp`, which the testing framework will automatically call"
" for every single test we run::"
msgstr ""
"Тестів може бути багато, а їх налаштування можуть повторюватися. На щастя, "
"ми можемо виключити код налаштування, реалізувавши метод під назвою "
":meth:`~TestCase.setUp`, який система тестування автоматично викличе для "
"кожного тесту, який ми виконуємо:"

#: ../../library/unittest.rst:404
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""

#: ../../library/unittest.rst:420
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"Порядок, у якому виконуватимуться різні тести, визначається сортуванням назв"
" методів тестування відповідно до вбудованого порядку для рядків."

#: ../../library/unittest.rst:424
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and"
" the test method will not be executed."
msgstr ""
"Якщо метод :meth:`~TestCase.setUp` викликає виняток під час виконання тесту,"
" фреймворк вважатиме, що тест зазнав помилки, і метод тесту не буде "
"виконано."

#: ../../library/unittest.rst:428
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up"
" after the test method has been run::"
msgstr ""
"Подібним чином ми можемо надати метод :meth:`~TestCase.tearDown`, який "
"наводить порядок після виконання тестового методу:"

#: ../../library/unittest.rst:431
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"
msgstr ""

#: ../../library/unittest.rst:440
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run"
" whether the test method succeeded or not."
msgstr ""
"Якщо :meth:`~TestCase.setUp` виконано успішно, :meth:`~TestCase.tearDown` "
"буде запущено незалежно від того, чи вдався метод тестування."

#: ../../library/unittest.rst:443
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, "
":meth:`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called "
"once per test."
msgstr ""
"Таке робоче середовище для коду тестування називається :dfn:`test fixture`. "
"Новий екземпляр TestCase створюється як унікальний тестовий прилад, який "
"використовується для виконання кожного окремого методу тестування. Таким "
"чином, :meth:`~TestCase.setUp`, :meth:`~TestCase.tearDown` і "
":meth:`~TestCase.__init__` буде викликано один раз на тест."

#: ../../library/unittest.rst:449
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s "
":class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will"
" do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Рекомендується використовувати реалізації TestCase для групування тестів "
"відповідно до функцій, які вони тестують. :mod:`unittest` забезпечує "
"механізм для цього: :dfn:`test suite`, представлений :mod:`unittest` класом "
":class:`TestSuite`. У більшості випадків виклик :func:`unittest.main` "
"зробить правильну річ і збере для вас усі тестові приклади модуля та виконає"
" їх."

#: ../../library/unittest.rst:456
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Однак, якщо ви хочете налаштувати збірку свого набору тестів, ви можете "
"зробити це самостійно:"

#: ../../library/unittest.rst:459
msgid ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"
msgstr ""

#: ../../library/unittest.rst:469
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Ви можете розмістити визначення тестів і наборів тестів у тих самих модулях,"
" що й код, який вони мають тестувати (наприклад, :file:`widget.py`), але є "
"кілька переваг розміщення тестового коду в окремому модулі, наприклад "
":file:`test_widget.py`:"

#: ../../library/unittest.rst:474
msgid "The test module can be run standalone from the command line."
msgstr "Тестовий модуль можна запускати автономно з командного рядка."

#: ../../library/unittest.rst:476
msgid "The test code can more easily be separated from shipped code."
msgstr "Тестовий код можна легше відокремити від надісланого коду."

#: ../../library/unittest.rst:478
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Менше спокуси змінити тестовий код, щоб відповідати коду, який він тестує, "
"без вагомої причини."

#: ../../library/unittest.rst:481
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "Тестовий код слід змінювати набагато рідше, ніж код, який він тестує."

#: ../../library/unittest.rst:483
msgid "Tested code can be refactored more easily."
msgstr "Перевірений код можна легше рефакторингувати."

#: ../../library/unittest.rst:485
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Тести для модулів, написаних мовою C, у будь-якому разі повинні бути "
"окремими модулями, то чому б не бути послідовними?"

#: ../../library/unittest.rst:488
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Якщо стратегія тестування змінюється, немає необхідності змінювати вихідний "
"код."

#: ../../library/unittest.rst:494
msgid "Re-using old test code"
msgstr "Повторне використання старого тестового коду"

#: ../../library/unittest.rst:496
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to a"
" :class:`TestCase` subclass."
msgstr ""
"Деякі користувачі виявлять, що у них є тестовий код, який вони хотіли б "
"запустити з :mod:`unittest`, не перетворюючи кожну стару тестову функцію на "
"підклас :class:`TestCase`."

#: ../../library/unittest.rst:500
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class."
" This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"З цієї причини :mod:`unittest` надає клас :class:`FunctionTestCase`. Цей "
"підклас :class:`TestCase` можна використовувати для обгортання існуючої "
"тестової функції. Також можуть бути передбачені функції налаштування та "
"демонтажу."

#: ../../library/unittest.rst:504
msgid "Given the following test function::"
msgstr "Дано таку тестову функцію:"

#: ../../library/unittest.rst:506
msgid ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."
msgstr ""

#: ../../library/unittest.rst:511
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"можна створити еквівалентний екземпляр тестового сценарію наступним чином із"
" додатковими методами налаштування та демонтажу:"

#: ../../library/unittest.rst:514
msgid ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"
msgstr ""

#: ../../library/unittest.rst:520
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Незважаючи на те, що :class:`FunctionTestCase` можна використовувати для "
"швидкого перетворення наявної тестової бази на систему на основі "
":mod:`unittest`\\, цей підхід не рекомендується. Витративши час на "
"налаштування належних підкласів :class:`TestCase`, ви значно спростите "
"рефакторинг майбутніх тестів."

#: ../../library/unittest.rst:525
msgid ""
"In some cases, the existing tests may have been written using the "
":mod:`doctest` module.  If so, :mod:`doctest` provides a "
":class:`DocTestSuite` class that can automatically build "
":class:`unittest.TestSuite` instances from the existing :mod:`doctest`\\ "
"-based tests."
msgstr ""
"У деяких випадках існуючі тести могли бути написані за допомогою модуля "
":mod:`doctest`. Якщо так, :mod:`doctest` надає клас :class:`DocTestSuite`, "
"який може автоматично створювати екземпляри :class:`unittest.TestSuite` з "
"існуючих тестів на основі :mod:`doctest`\\."

#: ../../library/unittest.rst:534
msgid "Skipping tests and expected failures"
msgstr "Пропуск тестів і очікувані невдачі"

#: ../../library/unittest.rst:538
msgid ""
"Unittest supports skipping individual test methods and even whole classes of"
" tests.  In addition, it supports marking a test as an \"expected failure,\""
" a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest підтримує пропуски окремих методів тестування і навіть цілих класів"
" тестів. Крім того, він підтримує позначення тесту як \"очікуваної "
"помилки\", тобто тесту, який зламано і буде невдалим, але його не слід "
"вважати помилкою в :class:`TestResult`."

#: ../../library/unittest.rst:543
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` "
":term:`decorator` or one of its conditional variants, calling "
":meth:`TestCase.skipTest` within a :meth:`~TestCase.setUp` or test method, "
"or raising :exc:`SkipTest` directly."
msgstr ""
"Пропуск тесту – це просто використання :func:`skip` :term:`decorator` або "
"одного з його умовних варіантів, виклик :meth:`TestCase.skipTest` у "
":meth:`~TestCase.setUp` або тестовий метод або безпосередньо підняти "
":exc:`SkipTest`."

#: ../../library/unittest.rst:547
msgid "Basic skipping looks like this::"
msgstr "Базовий пропуск виглядає так::"

#: ../../library/unittest.rst:549
msgid ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"
msgstr ""

#: ../../library/unittest.rst:572
msgid "This is the output of running the example above in verbose mode::"
msgstr "Це результат виконання наведеного вище прикладу в докладному режимі:"

#: ../../library/unittest.rst:574
msgid ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped 'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped 'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"
msgstr ""

#: ../../library/unittest.rst:584
msgid "Classes can be skipped just like methods::"
msgstr "Класи можна пропускати, як і методи:"

#: ../../library/unittest.rst:586
msgid ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"
msgstr ""

#: ../../library/unittest.rst:591
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` також може пропустити тест. Це корисно, коли ресурс, "
"який потрібно налаштувати, недоступний."

#: ../../library/unittest.rst:594
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr ""
"Очікувані помилки використовують декоратор :func:`expectedFailure`. ::"

#: ../../library/unittest.rst:596
msgid ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"
msgstr ""

#: ../../library/unittest.rst:601
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Легко запустити власні декоратори пропуску, створивши декоратор, який "
"викликає :func:`skip` у тесті, коли хоче, щоб його було пропущено. Цей "
"декоратор пропускає перевірку, якщо переданий об’єкт не має певного "
"атрибута::"

#: ../../library/unittest.rst:605
msgid ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"
msgstr ""

#: ../../library/unittest.rst:610
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Наступні декоратори та винятки реалізують пропуск тесту та очікувані "
"помилки:"

#: ../../library/unittest.rst:614
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Беззастережно пропустіть оформлений тест. *причина* має описувати, чому тест"
" пропускається."

#: ../../library/unittest.rst:619
msgid "Skip the decorated test if *condition* is true."
msgstr "Пропустіть декорований тест, якщо *умова* істинна."

#: ../../library/unittest.rst:623
msgid "Skip the decorated test unless *condition* is true."
msgstr "Пропустіть оформлений тест, якщо *умова* не виконується."

#: ../../library/unittest.rst:627
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Позначте тест як очікувану невдачу або помилку. Якщо тест зазнає невдачі або"
" помилки в самій тестовій функції (а не в одному з методів :dfn:`test "
"fixture`), тоді він вважатиметься успішним. Якщо тест буде пройдений, він "
"буде вважатися невдалим."

#: ../../library/unittest.rst:634
msgid "This exception is raised to skip a test."
msgstr "Цей виняток створюється, щоб пропустити тест."

#: ../../library/unittest.rst:636
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Зазвичай ви можете використовувати :meth:`TestCase.skipTest` або один із "
"декораторів пропуску замість того, щоб піднімати це безпосередньо."

#: ../../library/unittest.rst:639
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or "
":meth:`~TestCase.tearDown` run around them. Skipped classes will not have "
":meth:`~TestCase.setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped"
" modules will not have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Пропущені тести не запускатимуть :meth:`~TestCase.setUp` або "
":meth:`~TestCase.tearDown`. Пропущені класи не виконуватимуться "
":meth:`~TestCase.setUpClass` або :meth:`~TestCase.tearDownClass`. Пропущені "
"модулі не запускатимуть :func:`setUpModule` або :func:`tearDownModule`."

#: ../../library/unittest.rst:647
msgid "Distinguishing test iterations using subtests"
msgstr "Розрізнення тестових ітерацій за допомогою субтестів"

#: ../../library/unittest.rst:651
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Якщо між вашими тестами є дуже невеликі відмінності, наприклад деякі "
"параметри, unittest дозволяє розрізняти їх у тілі тестового методу за "
"допомогою контекстного менеджера :meth:`~TestCase.subTest`."

#: ../../library/unittest.rst:655
msgid "For example, the following test::"
msgstr "Наприклад, такий тест:"

#: ../../library/unittest.rst:657
msgid ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"
msgstr ""

#: ../../library/unittest.rst:667
msgid "will produce the following output::"
msgstr "виведе наступний вихід:"

#: ../../library/unittest.rst:669
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"
msgstr ""

#: ../../library/unittest.rst:699
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't"
" be displayed::"
msgstr ""
"Без використання підтесту виконання зупинилося б після першої помилки, а "
"помилку було б важче діагностувати, оскільки значення ``i`` не відображалося"
" б::"

#: ../../library/unittest.rst:703
msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"
msgstr ""

#: ../../library/unittest.rst:715
msgid "Classes and functions"
msgstr "Класи та функції"

#: ../../library/unittest.rst:717
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "У цьому розділі докладно описано API :mod:`unittest`."

#: ../../library/unittest.rst:723
msgid "Test cases"
msgstr "Тестові випадки"

#: ../../library/unittest.rst:727
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in"
" the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Екземпляри класу :class:`TestCase` представляють логічні тестові одиниці у "
"всесвіті :mod:`unittest`. Цей клас призначений для використання в якості "
"базового класу з конкретними тестами, реалізованими конкретними підкласами. "
"Цей клас реалізує інтерфейс, необхідний виконавцю тестів, щоб дозволити йому"
" керувати тестами, і методи, які тестовий код може використовувати для "
"перевірки та звітування про різні види помилок."

#: ../../library/unittest.rst:734
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method"
" named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Кожен екземпляр :class:`TestCase` запускатиме один базовий метод: метод під "
"назвою *methodName*. У більшості випадків використання :class:`TestCase` ви "
"не змінюєте *methodName* і не реалізуєте метод за замовчуванням "
"``runTest()``."

#: ../../library/unittest.rst:739
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from"
" the interactive interpreter."
msgstr ""
":class:`TestCase` можна успішно створити без надання *methodName*. Це "
"полегшує експерименти з :class:`TestCase` з інтерактивного інтерпретатора."

#: ../../library/unittest.rst:744
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions"
" and report failures, and some inquiry methods allowing information about "
"the test itself to be gathered."
msgstr ""
"Екземпляри :class:`TestCase` забезпечують три групи методів: одна група "
"використовується для запуску тесту, інша використовується реалізацією тесту "
"для перевірки умов і звітування про помилки, а також деякі методи запиту, "
"які дозволяють збирати інформацію про сам тест."

#: ../../library/unittest.rst:749
msgid "Methods in the first group (running the test) are:"
msgstr "Методи першої групи (проведення тесту) це:"

#: ../../library/unittest.rst:753
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or "
":exc:`SkipTest`, any exception raised by this method will be considered an "
"error rather than a test failure. The default implementation does nothing."
msgstr ""
"Метод, який називається для підготовки випробувального матеріалу. Це "
"викликається безпосередньо перед викликом тестового методу; крім "
":exc:`AssertionError` або :exc:`SkipTest`, будь-який виняток, викликаний цим"
" методом, вважатиметься помилкою, а не помилкою тесту. Стандартна реалізація"
" нічого не робить."

#: ../../library/unittest.rst:761
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than "
":exc:`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if the"
" :meth:`setUp` succeeds, regardless of the outcome of the test method. The "
"default implementation does nothing."
msgstr ""
"Метод викликається відразу після виклику тестового методу та запису "
"результату. Це викликається, навіть якщо метод тестування викликав виняток, "
"тому реалізація в підкласах може потребувати особливої обережності щодо "
"перевірки внутрішнього стану. Будь-які винятки, окрім :exc:`AssertionError` "
"або :exc:`SkipTest`, викликані цим методом, вважатимуться додатковою "
"помилкою, а не помилкою тесту (таким чином збільшуючи загальну кількість "
"повідомлених помилок). Цей метод буде викликано, лише якщо :meth:`setUp` "
"завершиться успішно, незалежно від результату тестового методу. Стандартна "
"реалізація нічого не робить."

#: ../../library/unittest.rst:774
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"Метод класу, який викликається перед виконанням тестів в окремому класі. "
"``setUpClass`` викликається з класом як єдиним аргументом і має бути "
"оформлений як :func:`classmethod`::"

#: ../../library/unittest.rst:778
msgid ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."
msgstr ""

#: ../../library/unittest.rst:782 ../../library/unittest.rst:797
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Додаткову інформацію див. у розділі `Class and Module Fixtures`_."

#: ../../library/unittest.rst:789
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Метод класу, який викликається після виконання тестів в окремому класі. "
"``tearDownClass`` викликається з класом як єдиним аргументом і має бути "
"оформлений як :meth:`classmethod`::"

#: ../../library/unittest.rst:793
msgid ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."
msgstr ""

#: ../../library/unittest.rst:804
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Запустіть тест, зібравши результат в об’єкт :class:`TestResult`, переданий "
"як *result*. Якщо *результат* пропущено або ``None``, створюється та "
"використовується тимчасовий об’єкт результату (викликом методу "
":meth:`defaultTestResult`). Об’єкт результату повертається до виклику "
":meth:`run`."

#: ../../library/unittest.rst:810
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Такого ж ефекту можна отримати, просто викликавши екземпляр "
":class:`TestCase`."

#: ../../library/unittest.rst:813
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Попередні версії ``run`` не повертали результат. Також не викликав "
"інстанції."

#: ../../library/unittest.rst:819
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Виклик цього під час тестового методу або :meth:`setUp` пропускає поточний "
"тест. Перегляньте :ref:`unittest-skipping` для отримання додаткової "
"інформації."

#: ../../library/unittest.rst:827
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Повертає контекстний менеджер, який виконує вкладений блок коду як підтест. "
"*msg* і *params* є необов’язковими, довільними значеннями, які "
"відображаються щоразу, коли субтест проходить невдало, що дозволяє їх чітко "
"ідентифікувати."

#: ../../library/unittest.rst:832
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Тестовий приклад може містити будь-яку кількість оголошень субтесту, і вони "
"можуть бути довільно вкладеними."

#: ../../library/unittest.rst:835
msgid "See :ref:`subtests` for more information."
msgstr "Перегляньте :ref:`subtests` для отримання додаткової інформації."

#: ../../library/unittest.rst:842
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Виконайте тест без отримання результату. Це дозволяє поширювати винятки, "
"викликані тестом, до викликаючого, і може бути використано для підтримки "
"запуску тестів під налагоджувачем."

#: ../../library/unittest.rst:848
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and"
" report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"Клас :class:`TestCase` надає кілька методів підтвердження для перевірки "
"помилок і звітування про них. У наведеній нижче таблиці перераховано "
"найпоширеніші методи (перегляньте таблиці нижче, щоб отримати більше методів"
" підтвердження):"

#: ../../library/unittest.rst:853 ../../library/unittest.rst:974
#: ../../library/unittest.rst:1188 ../../library/unittest.rst:1312
msgid "Method"
msgstr "метод"

#: ../../library/unittest.rst:853 ../../library/unittest.rst:974
#: ../../library/unittest.rst:1188
msgid "Checks that"
msgstr "Перевіряє це"

#: ../../library/unittest.rst:853 ../../library/unittest.rst:974
#: ../../library/unittest.rst:1188 ../../library/unittest.rst:1312
msgid "New in"
msgstr "Нове в"

#: ../../library/unittest.rst:855
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:855
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/unittest.rst:858
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:858
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:861
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:861
msgid "``bool(x) is True``"
msgstr "``bool(x) має значення True``"

#: ../../library/unittest.rst:864
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:864
msgid "``bool(x) is False``"
msgstr "``bool(x) є False``"

#: ../../library/unittest.rst:867
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:867
msgid "``a is b``"
msgstr "``a є b``"

#: ../../library/unittest.rst:867 ../../library/unittest.rst:870
#: ../../library/unittest.rst:873 ../../library/unittest.rst:876
#: ../../library/unittest.rst:879 ../../library/unittest.rst:882
#: ../../library/unittest.rst:979 ../../library/unittest.rst:1196
#: ../../library/unittest.rst:1199 ../../library/unittest.rst:1202
#: ../../library/unittest.rst:1205 ../../library/unittest.rst:1208
#: ../../library/unittest.rst:1314 ../../library/unittest.rst:1317
#: ../../library/unittest.rst:1320 ../../library/unittest.rst:1323
#: ../../library/unittest.rst:1326 ../../library/unittest.rst:1329
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:870
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:870
msgid "``a is not b``"
msgstr "``a не є b``"

#: ../../library/unittest.rst:873
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:873
msgid "``x is None``"
msgstr "``x не має значення``"

#: ../../library/unittest.rst:876
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:876
msgid "``x is not None``"
msgstr "``x не є None``"

#: ../../library/unittest.rst:879
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:879
msgid "``a in b``"
msgstr "``a в b``"

#: ../../library/unittest.rst:882
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:882
msgid "``a not in b``"
msgstr "``a не в b``"

#: ../../library/unittest.rst:885
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:885
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:885 ../../library/unittest.rst:888
#: ../../library/unittest.rst:982 ../../library/unittest.rst:985
#: ../../library/unittest.rst:1211 ../../library/unittest.rst:1214
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:888
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:888
msgid "``not isinstance(a, b)``"
msgstr "``не екземпляр(a, b)``"

#: ../../library/unittest.rst:892
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, "
":meth:`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` "
"only when they are used as a context manager."
msgstr ""
"Усі методи assert приймають аргумент *msg*, який, якщо вказано, "
"використовується як повідомлення про помилку у разі помилки (див. також "
":data:`longMessage`). Зауважте, що аргумент ключового слова *msg* можна "
"передати до :meth:`assertRaises`, :meth:`assertRaisesRegex`, "
":meth:`assertWarns`, :meth:`assertWarnsRegex` лише тоді, коли вони "
"використовуються як менеджер контексту."

#: ../../library/unittest.rst:900
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Перевірте, що *перше* і *друге* рівні. Якщо порівняльні значення не "
"однакові, тест буде невдалим."

#: ../../library/unittest.rst:903
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Крім того, якщо *first* і *second* мають той самий тип і один із list, "
"tuple, dict, set, frozenset або str або будь-який тип, який підклас реєструє"
" за допомогою :meth:`addTypeEqualityFunc`, специфічна для типу функція "
"рівності буде викликано, щоб створити більш корисне повідомлення про помилку"
" за замовчуванням (див. також :ref:`список специфічних для типу методів "
"<type-specific-methods>`)."

#: ../../library/unittest.rst:910
msgid "Added the automatic calling of type-specific equality function."
msgstr "Додано автоматичний виклик функції рівності для певного типу."

#: ../../library/unittest.rst:913
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for"
" comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` додано як функцію рівності типів за умовчанням "
"для порівняння рядків."

#: ../../library/unittest.rst:920
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Перевірте, що *перше* і *друге* не рівні. Якщо порівняльні значення "
"однакові, тест буде невдалим."

#: ../../library/unittest.rst:926
msgid "Test that *expr* is true (or false)."
msgstr "Перевірте, що *expr* є істинним (або хибним)."

#: ../../library/unittest.rst:928
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Зауважте, що це еквівалентно ``bool(expr) is True``, а не ``expr is True`` "
"(використовуйте ``assertIs(expr, True)`` для останнього). Також слід уникати"
" цього методу, якщо доступні більш специфічні методи (наприклад, "
"``assertEqual(a, b)`` замість ``assertTrue(a == b)``), тому що вони надають "
"краще повідомлення про помилку в разі невдачі ."

#: ../../library/unittest.rst:938
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr ""
"Перевірте, чи *перший* і *другий* є (чи не є) одним і тим же об’єктом."

#: ../../library/unittest.rst:946
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Перевірте, що *expr* є (чи не є) ``None``."

#: ../../library/unittest.rst:954
msgid "Test that *member* is (or is not) in *container*."
msgstr "Перевірте, чи *член* є (чи ні) у *контейнері*."

#: ../../library/unittest.rst:962
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or"
" a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Перевірте, що *obj* є (або не є) екземпляром *cls* (який може бути класом "
"або кортежем класів, як підтримується :func:`isinstance`). Щоб перевірити "
"точний тип, використовуйте :func:`assertIs(type(obj), cls) <assertIs>`."

#: ../../library/unittest.rst:970
msgid ""
"It is also possible to check the production of exceptions, warnings, and log"
" messages using the following methods:"
msgstr ""
"Також можна перевірити створення винятків, попереджень і повідомлень журналу"
" за допомогою таких методів:"

#: ../../library/unittest.rst:976
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:976
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` підвищує *exc*"

#: ../../library/unittest.rst:979
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) "
"<TestCase.assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) "
"<TestCase.assertRaisesRegex>`"

#: ../../library/unittest.rst:979
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` викликає *exc* і повідомлення відповідає регулярному "
"виразу *r*"

#: ../../library/unittest.rst:982
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:982
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` викликає *попередження*"

#: ../../library/unittest.rst:985
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) "
"<TestCase.assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) "
"<TestCase.assertWarnsRegex>`"

#: ../../library/unittest.rst:985
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` викликає *warn* і повідомлення відповідає регулярному"
" виразу *r*"

#: ../../library/unittest.rst:988
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(реєстратор, рівень) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:988
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "Блок ``with`` реєструє *реєстратор* з мінімальним *рівнем*"

#: ../../library/unittest.rst:988
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:991
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(реєстратор, рівень) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:991
msgid "The ``with`` block does not log on"
msgstr "Блок ``with`` не входить в систему"

#: ../../library/unittest.rst:992
msgid "*logger* with minimum *level*"
msgstr "*логгер* з мінімальним *рівнем*"

#: ../../library/unittest.rst:991
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:998
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to "
":meth:`assertRaises`.  The test passes if *exception* is raised, is an error"
" if another exception is raised, or fails if no exception is raised. To "
"catch any of a group of exceptions, a tuple containing the exception classes"
" may be passed as *exception*."
msgstr ""
"Перевірте, чи виникає виняток, коли *callable* викликається з будь-якими "
"позиційними або ключовими аргументами, які також передаються в "
":meth:`assertRaises`. Перевірка проходить, якщо виникає *виняток*, "
"вважається помилкою, якщо викликається інший виняток, або не виконується, "
"якщо винятку не виникає. Щоб перехопити будь-яку групу винятків, кортеж, що "
"містить класи винятків, можна передати як *виняток*."

#: ../../library/unittest.rst:1005
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a"
" context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Якщо подано лише аргументи *exception* і, можливо, *msg*, поверніть "
"диспетчер контексту, щоб тестований код можна було записати вбудовано, а не "
"як функцію::"

#: ../../library/unittest.rst:1009
msgid ""
"with self.assertRaises(SomeException):\n"
"    do_something()"
msgstr ""

#: ../../library/unittest.rst:1012
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"У разі використання як менеджера контексту :meth:`assertRaises` приймає "
"додатковий аргумент ключового слова *msg*."

#: ../../library/unittest.rst:1015
msgid ""
"The context manager will store the caught exception object in its "
":attr:`exception` attribute.  This can be useful if the intention is to "
"perform additional checks on the exception raised::"
msgstr ""
"Менеджер контексту збереже спійманий об’єкт винятку в своєму атрибуті "
":attr:`exception`. Це може бути корисним, якщо планується виконати додаткові"
" перевірки викликаного винятку:"

#: ../../library/unittest.rst:1019
msgid ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"
msgstr ""

#: ../../library/unittest.rst:1025
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Додано можливість використовувати :meth:`assertRaises` як контекстний "
"менеджер."

#: ../../library/unittest.rst:1028
msgid "Added the :attr:`exception` attribute."
msgstr "Додано атрибут :attr:`exception`."

#: ../../library/unittest.rst:1031 ../../library/unittest.rst:1057
#: ../../library/unittest.rst:1098 ../../library/unittest.rst:1121
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Додано аргумент ключового слова *msg*, коли він використовується як менеджер"
" контексту."

#: ../../library/unittest.rst:1038
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression"
" object or a string containing a regular expression suitable for use by "
":func:`re.search`.  Examples::"
msgstr ""
"Подібно до :meth:`assertRaises`, але також перевіряє, що *regex* відповідає "
"рядковому представленню викликаного винятку. *regex* може бути об’єктом "
"регулярного виразу або рядком, що містить регулярний вираз, придатний для "
"використання :func:`re.search`. Приклади::"

#: ../../library/unittest.rst:1043
msgid ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"
msgstr ""

#: ../../library/unittest.rst:1046 ../../library/unittest.rst:1114
msgid "or::"
msgstr "або::"

#: ../../library/unittest.rst:1048
msgid ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"
msgstr ""

#: ../../library/unittest.rst:1051
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Додано під назвою ``assertRaisesRegexp``."

#: ../../library/unittest.rst:1054
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Перейменовано на :meth:`assertRaisesRegex`."

#: ../../library/unittest.rst:1064
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:`assertWarns`."
"  The test passes if *warning* is triggered and fails if it isn't.  Any "
"exception is an error. To catch any of a group of warnings, a tuple "
"containing the warning classes may be passed as *warnings*."
msgstr ""
"Перевірте, чи спрацьовує попередження, коли *callable* викликається з будь-"
"якими позиційними або ключовими аргументами, які також передаються до "
":meth:`assertWarns`. Тест проходить, якщо спрацьовує *попередження*, і не "
"виконується, якщо ні. Будь-який виняток є помилкою. Щоб перехопити будь-яку "
"групу попереджень, кортеж, що містить класи попереджень, можна передати як "
"*попередження*."

#: ../../library/unittest.rst:1071
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Якщо надано лише аргументи *попередження* і, можливо, *повідомлення*, "
"поверніть диспетчер контексту, щоб тестований код можна було записати "
"вбудовано, а не як функцію::"

#: ../../library/unittest.rst:1075
msgid ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"
msgstr ""

#: ../../library/unittest.rst:1078
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"У разі використання як менеджера контексту :meth:`assertWarns` приймає "
"додатковий аргумент ключового слова *msg*."

#: ../../library/unittest.rst:1081
msgid ""
"The context manager will store the caught warning object in its "
":attr:`warning` attribute, and the source line which triggered the warnings "
"in the :attr:`filename` and :attr:`lineno` attributes. This can be useful if"
" the intention is to perform additional checks on the warning caught::"
msgstr ""
"Менеджер контексту збереже спійманий об’єкт попередження в атрибуті "
":attr:`warning`, а вихідний рядок, який викликав попередження, в атрибутах "
":attr:`filename` і :attr:`lineno`. Це може бути корисним, якщо планується "
"виконати додаткові перевірки виявленого попередження:"

#: ../../library/unittest.rst:1087
msgid ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"
msgstr ""

#: ../../library/unittest.rst:1093
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Цей метод працює незалежно від фільтрів попереджень під час його виклику."

#: ../../library/unittest.rst:1105
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by "
":func:`re.search`.  Example::"
msgstr ""
"Подібно до :meth:`assertWarns`, але також перевіряє відповідність *regex* у "
"повідомленні викликаного попередження. *regex* може бути об’єктом "
"регулярного виразу або рядком, що містить регулярний вираз, придатний для "
"використання :func:`re.search`. Приклад::"

#: ../../library/unittest.rst:1110
msgid ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"
msgstr ""

#: ../../library/unittest.rst:1116
msgid ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"
msgstr ""

#: ../../library/unittest.rst:1126
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"Менеджер контексту для перевірки того, що принаймні одне повідомлення "
"зареєстровано в *реєстраторі* або одному з його дочірніх елементів, "
"принаймні з заданим *рівнем*."

#: ../../library/unittest.rst:1130
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a "
":class:`str` giving the name of a logger.  The default is the root logger, "
"which will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Якщо задано, *logger* має бути об’єктом :class:`logging.Logger` або "
":class:`str`, що вказує назву реєстратора. За замовчуванням використовується"
" кореневий реєстратор, який фіксуватиме всі повідомлення, які не були "
"заблоковані нащадковим реєстратором без розповсюдження."

#: ../../library/unittest.rst:1135 ../../library/unittest.rst:1176
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :const:`logging.ERROR`).  "
"The default is :const:`logging.INFO`."
msgstr ""

#: ../../library/unittest.rst:1139
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"Тест проходить, якщо принаймні одне повідомлення, видане всередині блоку "
"``with``, відповідає умовам *logger* і *level*, в іншому випадку він не "
"виконується."

#: ../../library/unittest.rst:1142
msgid ""
"The object returned by the context manager is a recording helper which keeps"
" tracks of the matching log messages.  It has two attributes:"
msgstr ""
"Об’єкт, який повертає менеджер контексту, є помічником запису, який "
"відстежує відповідні повідомлення журналу. Він має два атрибути:"

#: ../../library/unittest.rst:1148
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"Список об’єктів :class:`logging.LogRecord` відповідних повідомлень журналу."

#: ../../library/unittest.rst:1153
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"Список об’єктів :class:`str` із відформатованим виведенням відповідних "
"повідомлень."

#: ../../library/unittest.rst:1156
msgid "Example::"
msgstr "Приклад::"

#: ../../library/unittest.rst:1158
msgid ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"
msgstr ""

#: ../../library/unittest.rst:1168
msgid ""
"A context manager to test that no messages are logged on the *logger* or one"
" of its children, with at least the given *level*."
msgstr ""
"Менеджер контексту для перевірки того, що жодні повідомлення не реєструються"
" в *реєстраторі* або одному з його дочірніх елементів, принаймні з заданим "
"*рівнем*."

#: ../../library/unittest.rst:1172
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a "
":class:`str` giving the name of a logger.  The default is the root logger, "
"which will catch all messages."
msgstr ""
"Якщо задано, *logger* має бути об’єктом :class:`logging.Logger` або "
":class:`str`, що вказує назву реєстратора. Типовим є кореневий реєстратор, "
"який фіксуватиме всі повідомлення."

#: ../../library/unittest.rst:1180
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"На відміну від :meth:`assertLogs`, контекстний менеджер нічого не "
"повертатиме."

#: ../../library/unittest.rst:1185
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Існують також інші методи, які використовуються для виконання більш "
"конкретних перевірок, наприклад:"

#: ../../library/unittest.rst:1190
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1190
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1193
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1193
msgid "``round(a-b, 7) != 0``"
msgstr "``округлення(a-b, 7) != 0``"

#: ../../library/unittest.rst:1196
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1196
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1199
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1199
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/unittest.rst:1202
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1202
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/unittest.rst:1205
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1205
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/unittest.rst:1208
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1208
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../../library/unittest.rst:1211
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1211
msgid "``not r.search(s)``"
msgstr "``не r.search(s)``"

#: ../../library/unittest.rst:1214
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1214
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* і *b* містять однакові елементи в однаковій кількості, незалежно від їх "
"порядку."

#: ../../library/unittest.rst:1223
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the "
":func:`round` function) and not *significant digits*."
msgstr ""
"Перевірте, що *перший* і *другий* приблизно (чи не приблизно) рівні, "
"обчислюючи різницю, округляючи до вказаної кількості десяткових *розрядів* "
"(за замовчуванням 7) і порівнюючи з нулем. Зауважте, що ці методи округлюють"
" значення до заданої кількості *десяткових знаків* (тобто як функція "
":func:`round`), а не до *значущих цифр*."

#: ../../library/unittest.rst:1229
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Якщо замість *розрядів* вказано *delta*, тоді різниця між *першим* і "
"*другим* має бути менше або дорівнювати (або більше) *delta*."

#: ../../library/unittest.rst:1232
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "Надання *delta* і *places* викликає :exc:`TypeError`."

#: ../../library/unittest.rst:1234
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` автоматично вважає майже рівні об’єкти, які "
"порівнюються рівними. :meth:`assertNotAlmostEqual` автоматично не "
"виконується, якщо об’єкти порівнюються. Додано аргумент ключового слова "
"*дельта*."

#: ../../library/unittest.rst:1245
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Перевірте, що *first* відповідно >, >=, < або <= ніж *second* залежно від "
"назви методу. Якщо ні, тест не пройде:"

#: ../../library/unittest.rst:1248
msgid ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""
msgstr ""

#: ../../library/unittest.rst:1257
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a"
" regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Перевірте, чи *регулярний вираз* пошуку відповідає (або не відповідає) "
"*тексту*. У разі помилки повідомлення про помилку міститиме шаблон і *текст*"
" (або шаблон і частину *тексту*, які неочікувано збіглися). *regex* може "
"бути об’єктом регулярного виразу або рядком, що містить регулярний вираз, "
"придатний для використання :func:`re.search`."

#: ../../library/unittest.rst:1263
msgid "Added under the name ``assertRegexpMatches``."
msgstr "Додано під назвою ``assertRegexpMatches``."

#: ../../library/unittest.rst:1265
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to "
":meth:`.assertRegex`."
msgstr ""
"Метод ``assertRegexpMatches()`` було перейменовано на :meth:`.assertRegex`."

#: ../../library/unittest.rst:1268
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../../library/unittest.rst:1274
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Перевірте, чи послідовність *first* містить ті самі елементи, що й *second*,"
" незалежно від їх порядку. Якщо цього не зробити, буде згенеровано "
"повідомлення про помилку з переліком відмінностей між послідовностями."

#: ../../library/unittest.rst:1278
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It"
" verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Повторювані елементи *не* ігноруються під час порівняння *першого* та "
"*другого*. Він перевіряє, чи кожен елемент має однакову кількість в обох "
"послідовностях. Еквівалент: ``assertEqual(Counter(list(first)), "
"Counter(list(second)))``, але також працює з послідовностями нехешованих "
"об’єктів."

#: ../../library/unittest.rst:1289
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already"
" implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"Метод :meth:`assertEqual` надсилає перевірку рівності для об’єктів одного "
"типу до різних методів, що залежать від типу. Ці методи вже реалізовано для "
"більшості вбудованих типів, але також можна зареєструвати нові методи за "
"допомогою :meth:`addTypeEqualityFunc`:"

#: ../../library/unittest.rst:1296
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise "
":data:`self.failureException(msg) <failureException>` when inequality "
"between the first two parameters is detected -- possibly providing useful "
"information and explaining the inequalities in details in the error message."
msgstr ""
"Реєструє специфічний для типу метод, викликаний :meth:`assertEqual`, щоб "
"перевірити, чи порівнюються два об’єкти абсолютно однакового *typeobj* (не "
"підкласи). *функція* має приймати два позиційних аргументи та третій "
"аргумент ключового слова msg=None так само, як це робить "
":meth:`assertEqual`. Він повинен викликати :data:`self.failureException(msg)"
" <failureException>`, коли виявлено нерівність між першими двома параметрами"
" — можливо, надаючи корисну інформацію та докладно пояснюючи нерівності в "
"повідомленні про помилку."

#: ../../library/unittest.rst:1307
msgid ""
"The list of type-specific methods automatically used by "
":meth:`~TestCase.assertEqual` are summarized in the following table.  Note "
"that it's usually not necessary to invoke these methods directly."
msgstr ""
"Список специфічних для типу методів, які автоматично використовує "
":meth:`~TestCase.assertEqual`, підсумовано в наступній таблиці. Зауважте, що"
" зазвичай не потрібно безпосередньо викликати ці методи."

#: ../../library/unittest.rst:1312
msgid "Used to compare"
msgstr "Використовується для порівняння"

#: ../../library/unittest.rst:1314
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1314
msgid "strings"
msgstr "рядки"

#: ../../library/unittest.rst:1317
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1317
msgid "sequences"
msgstr "послідовності"

#: ../../library/unittest.rst:1320
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1320
msgid "lists"
msgstr "списки"

#: ../../library/unittest.rst:1323
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1323
msgid "tuples"
msgstr "кортежі"

#: ../../library/unittest.rst:1326
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1326
msgid "sets or frozensets"
msgstr "набори або заморожені набори"

#: ../../library/unittest.rst:1329
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1329
msgid "dicts"
msgstr "дикт"

#: ../../library/unittest.rst:1337
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When"
" not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing"
" strings with :meth:`assertEqual`."
msgstr ""
"Перевірте, чи багаторядковий рядок *перший* дорівнює рядку *другий*. Якщо "
"відмінність двох рядків не дорівнює, у повідомленні про помилку буде "
"включено виділення відмінностей. Цей метод використовується за замовчуванням"
" під час порівняння рядків із :meth:`assertEqual`."

#: ../../library/unittest.rst:1347
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that"
" shows the difference between the two."
msgstr ""
"Перевіряє рівність двох послідовностей. Якщо вказано *seq_type*, і *first*, "
"і *second* мають бути екземплярами *seq_type*, інакше виникне помилка. Якщо "
"послідовності відрізняються, створюється повідомлення про помилку, яке "
"показує різницю між ними."

#: ../../library/unittest.rst:1352
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Цей метод не викликається безпосередньо :meth:`assertEqual`, але він "
"використовується для реалізації :meth:`assertListEqual` і "
":meth:`assertTupleEqual`."

#: ../../library/unittest.rst:1362
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods"
" are used by default when comparing lists or tuples with "
":meth:`assertEqual`."
msgstr ""
"Перевіряє рівність двох списків або кортежів. Якщо ні, створюється "
"повідомлення про помилку, яке показує лише відмінності між ними. Помилка "
"також виникає, якщо один із параметрів має неправильний тип. Ці методи "
"використовуються за замовчуванням під час порівняння списків або кортежів із"
" :meth:`assertEqual`."

#: ../../library/unittest.rst:1373
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that"
" lists the differences between the sets.  This method is used by default "
"when comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Перевіряє рівність двох наборів. Якщо ні, створюється повідомлення про "
"помилку, яке містить перелік відмінностей між наборами. Цей метод "
"використовується за замовчуванням під час порівняння наборів або заморожених"
" наборів за допомогою :meth:`assertEqual`."

#: ../../library/unittest.rst:1377
msgid ""
"Fails if either of *first* or *second* does not have a "
":meth:`set.difference` method."
msgstr ""
"Помилка, якщо *first* або *second* не має методу :meth:`set.difference`."

#: ../../library/unittest.rst:1385
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will"
" be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Перевірте рівність двох словників. Якщо ні, створюється повідомлення про "
"помилку, яке показує відмінності в словниках. Цей метод "
"використовуватиметься за умовчанням для порівняння словників у викликах "
":meth:`assertEqual`."

#: ../../library/unittest.rst:1396
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr "Нарешті, :class:`TestCase` надає такі методи та атрибути:"

#: ../../library/unittest.rst:1401
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error"
" message."
msgstr ""
"Безумовно сигналізує про помилку тесту за допомогою *msg* або ``None`` для "
"повідомлення про помилку."

#: ../../library/unittest.rst:1407
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is "
":exc:`AssertionError`."
msgstr ""
"Цей атрибут класу дає виняток, викликаний методом тестування. Якщо тестова "
"структура потребує використання спеціалізованого винятку, можливо, для "
"передачі додаткової інформації, вона повинна створити підклас цього винятку,"
" щоб \"грати чесно\" з структурою. Початковим значенням цього атрибута є "
":exc:`AssertionError`."

#: ../../library/unittest.rst:1416
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Цей атрибут класу визначає, що відбувається, коли настроюване повідомлення "
"про помилку передається як аргумент msg для виклику assertXYY, який "
"завершується помилкою. ``True`` - значення за умовчанням. У цьому випадку "
"спеціальне повідомлення додається в кінець стандартного повідомлення про "
"помилку. Якщо встановлено значення ``False``, спеціальне повідомлення "
"замінює стандартне повідомлення."

#: ../../library/unittest.rst:1422
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"Налаштування класу можна перевизначити в окремих методах тестування, "
"призначивши атрибуту екземпляра self.longMessage значення ``True`` або "
"``False`` перед викликом методів assert."

#: ../../library/unittest.rst:1426
msgid "The class setting gets reset before each test call."
msgstr "Налаштування класу скидається перед кожним тестовим викликом."

#: ../../library/unittest.rst:1433
msgid ""
"This attribute controls the maximum length of diffs output by assert methods"
" that report diffs on failure. It defaults to 80*8 characters. Assert "
"methods affected by this attribute are :meth:`assertSequenceEqual` "
"(including all the sequence comparison methods that delegate to it), "
":meth:`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Цей атрибут контролює максимальну довжину виведення відмінностей методами "
"assert, які повідомляють про відмінності у разі помилки. За замовчуванням "
"80*8 символів. Методи підтвердження, на які впливає цей атрибут: "
":meth:`assertSequenceEqual` (включно з усіма методами порівняння "
"послідовностей, які йому делегують), :meth:`assertDictEqual` і "
":meth:`assertMultiLineEqual`."

#: ../../library/unittest.rst:1440
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Встановлення ``maxDiff`` на ``None`` означає, що не існує максимальної "
"довжини відмінностей."

#: ../../library/unittest.rst:1446
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Платформи тестування можуть використовувати такі методи для збору інформації"
" про тест:"

#: ../../library/unittest.rst:1452
msgid ""
"Return the number of tests represented by this test object.  For "
":class:`TestCase` instances, this will always be ``1``."
msgstr ""
"Повертає кількість тестів, представлених цим тестовим об’єктом. Для "
"екземплярів :class:`TestCase` це завжди буде ``1``."

#: ../../library/unittest.rst:1458
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Повертає екземпляр класу результатів тесту, який слід використовувати для "
"цього класу тестів (якщо для методу :meth:`run` не надано інший екземпляр "
"результату)."

#: ../../library/unittest.rst:1462
msgid ""
"For :class:`TestCase` instances, this will always be an instance of "
":class:`TestResult`; subclasses of :class:`TestCase` should override this as"
" necessary."
msgstr ""
"Для екземплярів :class:`TestCase` це завжди буде екземпляр "
":class:`TestResult`; підкласи :class:`TestCase` мають замінити це, якщо "
"необхідно."

#: ../../library/unittest.rst:1469
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Повертає рядок, що ідентифікує конкретний тест. Зазвичай це повна назва "
"тестового методу, включаючи назву модуля та класу."

#: ../../library/unittest.rst:1475
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Повертає опис тесту або ``None``, якщо опис не надано. Реалізація цього "
"методу за замовчуванням повертає перший рядок документації тестового методу,"
" якщо доступний, або ``None``."

#: ../../library/unittest.rst:1480
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the "
":class:`TextTestResult` in Python 3.2."
msgstr ""
"У 3.1 це було змінено, щоб додати назву тесту до короткого опису навіть за "
"наявності рядка документації. Це викликало проблеми сумісності з "
"розширеннями unittest, і додавання назви тесту було перенесено до "
":class:`TextTestResult` у Python 3.2."

#: ../../library/unittest.rst:1489
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used"
" during the test. Functions will be called in reverse order to the order "
"they are added (:abbr:`LIFO (last-in, first-out)`).  They are called with "
"any arguments and keyword arguments passed into :meth:`addCleanup` when they"
" are added."
msgstr ""
"Додайте функцію, яка буде викликатися після :meth:`tearDown` для очищення "
"ресурсів, використаних під час тесту. Функції будуть викликані в порядку, "
"зворотному порядку їх додавання (:abbr:`LIFO (останній прийшов, перший "
"вийшов)`). Вони викликаються з будь-якими аргументами та ключовими "
"аргументами, які передаються в :meth:`addCleanup` під час їх додавання."

#: ../../library/unittest.rst:1495
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Якщо :meth:`setUp` не вдається, тобто :meth:`tearDown` не викликається, тоді"
" будь-які додані функції очищення все одно будуть викликані."

#: ../../library/unittest.rst:1503
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its "
":meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""

#: ../../library/unittest.rst:1513
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after "
":meth:`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Цей метод викликається безумовно після :meth:`tearDown` або після "
":meth:`setUp`, якщо :meth:`setUp` викликає виняткову ситуацію."

#: ../../library/unittest.rst:1516
msgid ""
"It is responsible for calling all the cleanup functions added by "
":meth:`addCleanup`. If you need cleanup functions to be called *prior* to "
":meth:`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Він відповідає за виклик усіх функцій очищення, доданих :meth:`addCleanup`. "
"Якщо вам потрібно, щоб функції очищення викликалися *перед* "
":meth:`tearDown`, ви можете викликати :meth:`doCleanups` самостійно."

#: ../../library/unittest.rst:1521
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` витягує методи зі стеку функцій очищення по одному, тому "
"їх можна викликати будь-коли."

#: ../../library/unittest.rst:1529
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources"
" used during the test class. Functions will be called in reverse order to "
"the order they are added (:abbr:`LIFO (last-in, first-out)`). They are "
"called with any arguments and keyword arguments passed into "
":meth:`addClassCleanup` when they are added."
msgstr ""
"Додайте функцію, яка буде викликатися після :meth:`tearDownClass` до "
"ресурсів очищення, використаних під час тестового класу. Функції будуть "
"викликані в порядку, зворотному порядку їх додавання (:abbr:`LIFO (останній "
"прийшов, перший вийшов)`). Вони викликаються з будь-якими аргументами та "
"ключовими аргументами, які передаються в :meth:`addClassCleanup` під час їх "
"додавання."

#: ../../library/unittest.rst:1535
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Якщо :meth:`setUpClass` не вдається, тобто :meth:`tearDownClass` не "
"викликається, тоді будь-які додані функції очищення все одно будуть "
"викликані."

#: ../../library/unittest.rst:1543
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its "
":meth:`~object.__exit__` method as a cleanup function by "
":meth:`addClassCleanup` and return the result of the "
":meth:`~object.__enter__` method."
msgstr ""

#: ../../library/unittest.rst:1553
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after "
":meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Цей метод викликається безумовно після :meth:`tearDownClass` або після "
":meth:`setUpClass`, якщо :meth:`setUpClass` викликає виняток."

#: ../../library/unittest.rst:1556
msgid ""
"It is responsible for calling all the cleanup functions added by "
":meth:`addClassCleanup`. If you need cleanup functions to be called *prior* "
"to :meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"Він відповідає за виклик усіх функцій очищення, доданих "
":meth:`addClassCleanup`. Якщо вам потрібно, щоб функції очищення викликалися"
" *перед* :meth:`tearDownClass`, ви можете викликати :meth:`doClassCleanups` "
"самостійно."

#: ../../library/unittest.rst:1561
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` витягує методи зі стеку функцій очищення по одному, "
"тому їх можна викликати будь-коли."

#: ../../library/unittest.rst:1569
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Цей клас надає API, подібний до :class:`TestCase`, а також приймає "
"співпрограми як тестові функції."

#: ../../library/unittest.rst:1576
msgid ""
"The *loop_factory* passed to :class:`asyncio.Runner`. Override in subclasses"
" with :class:`asyncio.EventLoop` to avoid using the asyncio policy system."
msgstr ""

#: ../../library/unittest.rst:1585
msgid ""
"Method called to prepare the test fixture. This is called after "
":meth:`setUp`. This is called immediately before calling the test method; "
"other than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by"
" this method will be considered an error rather than a test failure. The "
"default implementation does nothing."
msgstr ""
"Метод, який називається для підготовки випробувального матеріалу. Це "
"викликається після :meth:`setUp`. Це викликається безпосередньо перед "
"викликом тестового методу; крім :exc:`AssertionError` або :exc:`SkipTest`, "
"будь-який виняток, викликаний цим методом, вважатиметься помилкою, а не "
"помилкою тесту. Стандартна реалізація нічого не робить."

#: ../../library/unittest.rst:1594
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of"
" the outcome of the test method. The default implementation does nothing."
msgstr ""
"Метод викликається відразу після виклику тестового методу та запису "
"результату. Це викликається перед :meth:`tearDown`. Це викликається, навіть "
"якщо метод тестування викликав виняток, тому реалізація в підкласах може "
"потребувати особливої обережності щодо перевірки внутрішнього стану. Будь-"
"які винятки, окрім :exc:`AssertionError` або :exc:`SkipTest`, викликані цим "
"методом, вважатимуться додатковою помилкою, а не помилкою тесту (таким чином"
" збільшуючи загальну кількість повідомлених помилок). Цей метод буде "
"викликано, лише якщо :meth:`asyncSetUp` завершиться успішно, незалежно від "
"результату тестового методу. Стандартна реалізація нічого не робить."

#: ../../library/unittest.rst:1606
msgid ""
"This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Цей метод приймає співпрограму, яку можна використовувати як функцію "
"очищення."

#: ../../library/unittest.rst:1611
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by "
":meth:`addAsyncCleanup` and return the result of the "
":meth:`~object.__aenter__` method."
msgstr ""

#: ../../library/unittest.rst:1621
msgid ""
"Sets up a new event loop to run the test, collecting the result into the "
":class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the "
":meth:`defaultTestResult` method) and used. The result object is returned to"
" :meth:`run`'s caller. At the end of the test all the tasks in the event "
"loop are cancelled."
msgstr ""
"Встановлює новий цикл подій для запуску тесту, збираючи результат в об’єкт "
":class:`TestResult`, переданий як *результат*. Якщо *результат* пропущено "
"або ``None``, створюється та використовується тимчасовий об’єкт результату "
"(викликом методу :meth:`defaultTestResult`). Об’єкт результату повертається "
"до виклику :meth:`run`. Після закінчення тесту всі завдання в циклі подій "
"скасовуються."

#: ../../library/unittest.rst:1629
msgid "An example illustrating the order::"
msgstr "Приклад, що ілюструє порядок::"

#: ../../library/unittest.rst:1631
msgid ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example.com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"
msgstr ""

#: ../../library/unittest.rst:1665
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"Після виконання тесту ``події`` міститимуть ``[\"setUp\", \"asyncSetUp\", "
"\"test_response\", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``."

#: ../../library/unittest.rst:1670
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a "
":mod:`unittest`-based test framework."
msgstr ""
"Цей клас реалізує частину інтерфейсу :class:`TestCase`, яка дозволяє "
"виконавцю тесту управляти тестом, але не надає методів, які тестовий код "
"може використовувати для перевірки та звітування про помилки. Це "
"використовується для створення тестів із використанням застарілого тестового"
" коду, що дозволяє інтегрувати його в тестову структуру на основі "
":mod:`unittest`."

#: ../../library/unittest.rst:1680
msgid "Grouping tests"
msgstr "Групування тестів"

#: ../../library/unittest.rst:1684
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Цей клас представляє сукупність окремих тестових випадків і наборів тестів. "
"Клас представляє інтерфейс, необхідний виконавцю тесту, щоб дозволити йому "
"запускатися як будь-який інший тестовий приклад. Запуск екземпляра "
":class:`TestSuite` — це те саме, що ітерація по набору, запускаючи кожен "
"тест окремо."

#: ../../library/unittest.rst:1689
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional"
" methods are provided to add test cases and suites to the collection later "
"on."
msgstr ""
"Якщо надано *тести*, це має бути ітерація окремих тестових випадків або "
"інших наборів тестів, які будуть використані для створення набору спочатку. "
"Додаткові методи надаються для додавання тестів і пакетів до колекції "
"пізніше."

#: ../../library/unittest.rst:1693
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
"Об’єкти :class:`TestSuite` поводяться так само, як об’єкти "
":class:`TestCase`, за винятком того, що вони насправді не реалізують тест. "
"Натомість вони використовуються для агрегування тестів у групи тестів, які "
"слід виконувати разом. Деякі додаткові методи доступні для додавання тестів "
"до екземплярів :class:`TestSuite`:"

#: ../../library/unittest.rst:1701
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Додайте :class:`TestCase` або :class:`TestSuite` до набору."

#: ../../library/unittest.rst:1706
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and "
":class:`TestSuite` instances to this test suite."
msgstr ""
"Додайте всі тести з ітерації екземплярів :class:`TestCase` і "
":class:`TestSuite` до цього набору тестів."

#: ../../library/unittest.rst:1709
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Це еквівалентно повторенню *тестів*, виклику :meth:`addTest` для кожного "
"елемента."

#: ../../library/unittest.rst:1712
msgid ""
":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""
":class:`TestSuite` використовує такі методи спільно з :class:`TestCase`:"

#: ../../library/unittest.rst:1717
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike "
":meth:`TestCase.run`, :meth:`TestSuite.run` requires the result object to be"
" passed in."
msgstr ""
"Запустіть тести, пов’язані з цим набором, зібравши результат в об’єкт "
"результату тесту, переданий як *результат*. Зауважте, що на відміну від "
":meth:`TestCase.run`, :meth:`TestSuite.run` вимагає передачі об’єкта "
"результату."

#: ../../library/unittest.rst:1725
msgid ""
"Run the tests associated with this suite without collecting the result. This"
" allows exceptions raised by the test to be propagated to the caller and can"
" be used to support running tests under a debugger."
msgstr ""
"Виконуйте тести, пов’язані з цим пакетом, без збору результатів. Це дозволяє"
" поширювати винятки, викликані тестом, до абонента та може використовуватися"
" для підтримки запуску тестів під налагоджувачем."

#: ../../library/unittest.rst:1732
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Повертає кількість тестів, представлених цим тестовим об’єктом, включаючи "
"всі окремі тести та піднабори."

#: ../../library/unittest.rst:1738
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`!__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""

#: ../../library/unittest.rst:1748
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`!__iter__` wasn't sufficient "
"for providing tests."
msgstr ""

#: ../../library/unittest.rst:1753
msgid ""
"In earlier versions the :class:`TestSuite` held references to each "
":class:`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that "
"behavior by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"У попередніх версіях :class:`TestSuite` містив посилання на кожен "
":class:`TestCase` після :meth:`TestSuite.run`. Підкласи можуть відновити цю "
"поведінку, замінивши :meth:`TestSuite._removeTestAtIndex`."

#: ../../library/unittest.rst:1758
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test "
"harness."
msgstr ""
"У типовому використанні об’єкта :class:`TestSuite` метод :meth:`run` "
"викликається :class:`TestRunner`, а не тестовим пакетом кінцевого "
"користувача."

#: ../../library/unittest.rst:1763
msgid "Loading and running tests"
msgstr "Завантаження та виконання тестів"

#: ../../library/unittest.rst:1767
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and"
" modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as "
":data:`unittest.defaultTestLoader`.  Using a subclass or instance, however, "
"allows customization of some configurable properties."
msgstr ""
"Клас :class:`TestLoader` використовується для створення наборів тестів із "
"класів і модулів. Зазвичай немає необхідності створювати екземпляр цього "
"класу; модуль :mod:`unittest` надає екземпляр, який можна використовувати як"
" :data:`unittest.defaultTestLoader`. Однак використання підкласу або "
"екземпляра дозволяє налаштувати деякі настроювані властивості."

#: ../../library/unittest.rst:1773
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader` об’єкти мають такі атрибути:"

#: ../../library/unittest.rst:1778
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by"
" the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a"
" synthetic test that will raise the original error when run."
msgstr ""

#: ../../library/unittest.rst:1787
msgid ":class:`TestLoader` objects have the following methods:"
msgstr "Об’єкти :class:`TestLoader` мають такі методи:"

#: ../../library/unittest.rst:1792
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ "
"-derived :class:`testCaseClass`."
msgstr ""
"Повертає набір усіх тестів, що містяться в :class:`TestCase`\\ -похідному "
":class:`testCaseClass`."

#: ../../library/unittest.rst:1795
msgid ""
"A test case instance is created for each method named by "
":meth:`getTestCaseNames`. By default these are the method names beginning "
"with ``test``. If :meth:`getTestCaseNames` returns no methods, but the "
":meth:`runTest` method is implemented, a single test case is created for "
"that method instead."
msgstr ""
"Екземпляр тестового випадку створюється для кожного методу, названого "
":meth:`getTestCaseNames`. За замовчуванням це імена методів, які починаються"
" з ``test``. Якщо :meth:`getTestCaseNames` не повертає жодних методів, але "
"реалізовано метод :meth:`runTest`, натомість для цього методу створюється "
"один тестовий приклад."

#: ../../library/unittest.rst:1804
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Повертає набір усіх тестів, що містяться в даному модулі. Цей метод шукає в "
"*module* класи, похідні від :class:`TestCase`, і створює екземпляр класу для"
" кожного тестового методу, визначеного для класу."

#: ../../library/unittest.rst:1811
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Хоча використання ієрархії похідних класів :class:`TestCase`\\ може бути "
"зручним для спільного використання фікстур і допоміжних функцій, визначення "
"методів тестування на базових класах, які не призначені для безпосереднього "
"створення екземплярів, не підходить для цього методу. Однак це може бути "
"корисним, коли прилади різні та визначені в підкласах."

#: ../../library/unittest.rst:1817
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the"
" tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Якщо модуль надає функцію ``load_tests``, її буде викликано для завантаження"
" тестів. Це дозволяє модулям налаштовувати тестове завантаження. Це протокол"
" `load_tests`_. Аргумент *pattern* передається як третій аргумент у "
"``load_tests``."

#: ../../library/unittest.rst:1822
msgid "Support for ``load_tests`` added."
msgstr "Додано підтримку ``load_tests``."

#: ../../library/unittest.rst:1825
msgid "Support for a keyword-only argument *pattern* has been added."
msgstr ""

#: ../../library/unittest.rst:1828
msgid ""
"The undocumented and unofficial *use_load_tests* parameter has been removed."
msgstr ""

#: ../../library/unittest.rst:1835
msgid "Return a suite of all test cases given a string specifier."
msgstr "Повертає набір усіх тестів із специфікатором рядка."

#: ../../library/unittest.rst:1837
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a "
":class:`TestSuite` instance, or a callable object which returns a "
":class:`TestCase` or :class:`TestSuite` instance.  These checks are applied "
"in the order listed here; that is, a method on a possible test case class "
"will be picked up as \"a test method within a test case class\", rather than"
" \"a callable object\"."
msgstr ""
"Специфікатор *name* — це \"ім’я з крапками\", яке може перетворюватися на "
"модуль, клас тестового прикладу, метод тестування в класі тестового випадку,"
" екземпляр :class:`TestSuite` або викликаний об’єкт, який повертає: "
"екземпляр :class:`TestCase` або :class:`TestSuite`. Ці перевірки "
"застосовуються в зазначеному тут порядку; тобто метод у можливому класі "
"тестового випадку буде вибрано як \"метод тестування в класі тестового "
"випадку\", а не як \"об'єкт, який можна викликати\"."

#: ../../library/unittest.rst:1845
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a "
":class:`TestCase`\\ -derived class :class:`SampleTestCase` with three test "
"methods (:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the "
"specifier ``'SampleTests.SampleTestCase'`` would cause this method to return"
" a suite which will run all three test methods. Using the specifier "
"``'SampleTests.SampleTestCase.test_two'`` would cause it to return a test "
"suite which will run only the :meth:`test_two` test method. The specifier "
"can refer to modules and packages which have not been imported; they will be"
" imported as a side-effect."
msgstr ""
"Наприклад, якщо у вас є модуль :mod:`SampleTests`, який містить "
":class:`TestCase`\\ -похідний клас :class:`SampleTestCase` із трьома "
"методами тестування (:meth:`test_one`, :meth:`test_two` і "
":meth:`test_three`), специфікатор ``'SampleTests.SampleTestCase'`` призведе "
"до того, що цей метод повертатиме набір, який виконуватиме всі три методи "
"тестування. Використання специфікатора "
"``'SampleTests.SampleTestCase.test_two`` призведе до повернення набору "
"тестів, який запускатиме лише метод тестування :meth:`test_two`. "
"Специфікатор може посилатися на модулі та пакунки, які не були імпортовані; "
"вони будуть імпортовані як побічний ефект."

#: ../../library/unittest.rst:1855
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "Метод необов’язково розпізнає *ім’я* відносно даного *модуля*."

#: ../../library/unittest.rst:1857
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by "
"self.errors."
msgstr ""
"Якщо :exc:`ImportError` або :exc:`AttributeError` виникає під час обходу "
"*name*, тоді буде повернено синтетичний тест, який викликає цю помилку під "
"час запуску. Ці помилки включено до помилок, накопичених self.errors."

#: ../../library/unittest.rst:1866
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the"
" tests defined for each name."
msgstr ""
"Подібно до :meth:`loadTestsFromName`, але приймає послідовність імен, а не "
"одне ім’я. Повернене значення — це набір тестів, який підтримує всі тести, "
"визначені для кожного імені."

#: ../../library/unittest.rst:1873
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Повертає відсортовану послідовність імен методів, знайдених у "
"*testCaseClass*; це має бути підклас :class:`TestCase`."

#: ../../library/unittest.rst:1879
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Знайдіть усі тестові модулі, перейшовши до підкаталогів із зазначеного "
"початкового каталогу, і поверніть об’єкт TestSuite, що містить їх. Будуть "
"завантажені лише тестові файли, які відповідають *шаблону*. (Використовуючи "
"зіставлення шаблону стилю оболонки.) Завантажуватимуться лише імена модулів,"
" які можна імпортувати (тобто є дійсними ідентифікаторами Python)."

#: ../../library/unittest.rst:1885
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then *top_level_dir* must"
" be specified separately."
msgstr ""

#: ../../library/unittest.rst:1889
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Якщо імпортувати модуль не вдалося, наприклад, через синтаксичну помилку, це"
" буде записано як одну помилку, і виявлення продовжиться. Якщо помилка "
"імпорту спричинена викликом :exc:`SkipTest`, це буде записано як пропуск "
"замість помилки."

#: ../../library/unittest.rst:1894
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function"
" itself calls ``loader.discover``."
msgstr ""
"Якщо пакунок (каталог, що містить файл із назвою :file:`__init__.py`) "
"знайдено, пакунок буде перевірено на наявність функції ``load_tests``. Якщо "
"він існує, він називатиметься ``package.load_tests(loader, tests, "
"pattern)``. Тестове виявлення піклується про те, щоб пакет перевірявся на "
"наявність тестів лише один раз під час виклику, навіть якщо сама функція "
"load_tests викликає ``loader.discover``."

#: ../../library/unittest.rst:1902
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package,"
" ``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Якщо ``load_tests`` існує, виявлення *не* рекурсує в пакунок, ``load_tests``"
" відповідає за завантаження всіх тестів у пакунок."

#: ../../library/unittest.rst:1906
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves."
msgstr ""

#: ../../library/unittest.rst:1909
msgid ""
"*top_level_dir* is stored internally, and used as a default to any nested "
"calls to ``discover()``. That is, if a package's ``load_tests`` calls "
"``loader.discover()``, it does not need to pass this argument."
msgstr ""

#: ../../library/unittest.rst:1913
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* може бути назвою модуля з крапками, а також каталогом."

#: ../../library/unittest.rst:1917
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Модулі, які викликають :exc:`SkipTest` під час імпорту, записуються як "
"пропуски, а не як помилки."

#: ../../library/unittest.rst:1921
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir* може бути :term:`пакети простору імен <namespace package>`."

#: ../../library/unittest.rst:1924
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Шляхи сортуються перед імпортом, щоб порядок виконання був однаковим, навіть"
" якщо порядок базової файлової системи не залежить від імені файлу."

#: ../../library/unittest.rst:1929
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to"
" match the default pattern."
msgstr ""
"Знайдені пакунки тепер перевіряються на ``load_tests`` незалежно від того, "
"чи відповідає їхній шлях *шаблону*, оскільки назва пакета не може "
"відповідати шаблону за замовчуванням."

#: ../../library/unittest.rst:1934
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""

#: ../../library/unittest.rst:1938
msgid "*top_level_dir* is only stored for the duration of *discover* call."
msgstr ""

#: ../../library/unittest.rst:1942
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Наступні атрибути :class:`TestLoader` можуть бути налаштовані за допомогою "
"підкласу або призначення для екземпляра:"

#: ../../library/unittest.rst:1948
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Рядок із префіксом імен методів, які будуть інтерпретуватися як тестові "
"методи. Значення за замовчуванням - ``'test'``."

#: ../../library/unittest.rst:1951
msgid ""
"This affects :meth:`getTestCaseNames` and all the ``loadTestsFrom*`` "
"methods."
msgstr ""

#: ../../library/unittest.rst:1957
msgid ""
"Function to be used to compare method names when sorting them in "
":meth:`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""

#: ../../library/unittest.rst:1963
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the "
":class:`TestSuite` class."
msgstr ""
"Викликаний об’єкт, який створює набір тестів зі списку тестів. Жодних "
"методів для отриманого об’єкта не потрібно. Стандартним значенням є клас "
":class:`TestSuite`."

#: ../../library/unittest.rst:1967 ../../library/unittest.rst:1980
msgid "This affects all the ``loadTestsFrom*`` methods."
msgstr ""

#: ../../library/unittest.rst:1971
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr ""

#: ../../library/unittest.rst:1974
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""

#: ../../library/unittest.rst:1987
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Цей клас використовується для компіляції інформації про те, які тести були "
"успішними, а які невдалими."

#: ../../library/unittest.rst:1990
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The "
":class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Об’єкт :class:`TestResult` зберігає результати набору тестів. Класи "
":class:`TestCase` і :class:`TestSuite` забезпечують належний запис "
"результатів; авторам тестів не потрібно турбуватися про запис результатів "
"тестів."

#: ../../library/unittest.rst:1995
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the "
":class:`TestResult` object generated by running a set of tests for reporting"
" purposes; a :class:`TestResult` instance is returned by the "
":meth:`TestRunner.run` method for this purpose."
msgstr ""
"Фреймворки тестування, створені на основі :mod:`unittest`, можуть "
"потребувати доступу до об’єкта :class:`TestResult`, згенерованого за "
"допомогою виконання набору тестів для цілей звітування; екземпляр "
":class:`TestResult` повертається методом :meth:`TestRunner.run` для цієї "
"мети."

#: ../../library/unittest.rst:2000
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
"Екземпляри :class:`TestResult` мають такі атрибути, які будуть цікавими під "
"час перевірки результатів виконання набору тестів:"

#: ../../library/unittest.rst:2006
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки, що "
"містять відформатовані відстеження. Кожен кортеж представляє тест, який "
"викликав несподіваний виняток."

#: ../../library/unittest.rst:2012
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :ref:`assert\\* methods <assert-"
"methods>`."
msgstr ""

#: ../../library/unittest.rst:2018
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки з "
"причиною пропуску тесту."

#: ../../library/unittest.rst:2025
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки, що "
"містять відформатовані відстеження. Кожен кортеж представляє очікуваний збій"
" або помилку тестового випадку."

#: ../../library/unittest.rst:2031
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"Список, що містить екземпляри :class:`TestCase`, які були позначені як "
"очікувані помилки, але були успішними."

#: ../../library/unittest.rst:2036
msgid ""
"A list containing 2-tuples of test case names and floats representing the "
"elapsed time of each test which was run."
msgstr ""

#: ../../library/unittest.rst:2043
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""
"Установіть значення ``True``, коли виконання тестів має зупинятися на "
":meth:`stop`."

#: ../../library/unittest.rst:2047
msgid "The total number of tests run so far."
msgstr "Загальна кількість проведених тестів."

#: ../../library/unittest.rst:2051
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Якщо встановлено значення true, ``sys.stdout`` і ``sys.stderr`` будуть "
"буферизовані між викликами :meth:`startTest` і :meth:`stopTest`. Зібраний "
"вихід буде відображено на справжній ``sys.stdout`` і ``sys.stderr`` лише у "
"разі невдачі тесту або помилок. Будь-який вихід також додається до "
"повідомлення про збій/помилку."

#: ../../library/unittest.rst:2060
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Якщо встановлено значення true, :meth:`stop` буде викликано при першій "
"невдачі або помилці, зупиняючи тестовий запуск."

#: ../../library/unittest.rst:2067
msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""
"Якщо встановлено значення true, то локальні змінні відображатимуться у "
"відстеженнях."

#: ../../library/unittest.rst:2073
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Повертає ``True``, якщо всі тести, запущені до цього моменту, пройдено, "
"інакше повертає ``False``."

#: ../../library/unittest.rst:2076
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Повертає ``False``, якщо були будь-які :attr:`unexpectedSuccesses` від "
"тестів, позначених декоратором :func:`expectedFailure`."

#: ../../library/unittest.rst:2082
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. "
":class:`TestRunner` objects should respect this flag and return without "
"running any additional tests."
msgstr ""
"Цей метод можна викликати, щоб повідомити про те, що набір запущених тестів "
"має бути перервано, встановивши атрибут :attr:`shouldStop` на ``True``. "
"Об’єкти :class:`TestRunner` мають поважати цей прапор і повертатися без "
"виконання додаткових тестів."

#: ../../library/unittest.rst:2087
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Наприклад, ця функція використовується класом :class:`TextTestRunner`, щоб "
"зупинити тестову структуру, коли користувач сигналізує про переривання з "
"клавіатури. Інтерактивні інструменти, які забезпечують реалізації "
":class:`TestRunner`, можуть використовувати це подібним чином."

#: ../../library/unittest.rst:2092
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Наступні методи класу :class:`TestResult` використовуються для підтримки "
"внутрішніх структур даних і можуть бути розширені в підкласах для підтримки "
"додаткових вимог до звітності. Це особливо корисно для створення "
"інструментів, які підтримують інтерактивне звітування під час виконання "
"тестів."

#: ../../library/unittest.rst:2100
msgid "Called when the test case *test* is about to be run."
msgstr "Викликається, коли тестовий приклад *test* збирається запустити."

#: ../../library/unittest.rst:2104
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "Викликається після виконання тесту *test*, незалежно від результату."

#: ../../library/unittest.rst:2109
msgid "Called once before any tests are executed."
msgstr "Викликається один раз перед виконанням будь-яких тестів."

#: ../../library/unittest.rst:2116
msgid "Called once after all tests are executed."
msgstr "Викликається один раз після виконання всіх тестів."

#: ../../library/unittest.rst:2123
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Викликається, коли тестовий приклад *test* викликає несподіваний виняток. "
"*err* — це кортеж у формі, яку повертає :func:`sys.exc_info`: ``(тип, "
"значення, відстеження)``."

#: ../../library/unittest.rst:2127
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, formatted_err)`` до "
"атрибута екземпляра :attr:`errors`, де *formatted_err* є відформатованим "
"зворотним трасуванням, отриманим від *err*."

#: ../../library/unittest.rst:2134
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Викликається, коли тестовий приклад *test* сигналізує про помилку. *err* — "
"це кортеж у формі, яку повертає :func:`sys.exc_info`: ``(тип, значення, "
"відстеження)``."

#: ../../library/unittest.rst:2137
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, formatted_err)`` до "
"атрибута екземпляра :attr:`failures`, де *formatted_err* є відформатованим "
"зворотним трасуванням, отриманим від *err*."

#: ../../library/unittest.rst:2144
msgid "Called when the test case *test* succeeds."
msgstr "Викликається, коли тестовий приклад *test* виконується успішно."

#: ../../library/unittest.rst:2146
msgid "The default implementation does nothing."
msgstr "Стандартна реалізація нічого не робить."

#: ../../library/unittest.rst:2151
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Викликається, коли тестовий приклад *test* пропускається. *причина* — "
"причина пропуску тесту."

#: ../../library/unittest.rst:2154
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, reason)`` до атрибута "
"екземпляра :attr:`skipped`."

#: ../../library/unittest.rst:2160
msgid ""
"Called when the test case *test* fails or errors, but was marked with the "
":func:`expectedFailure` decorator."
msgstr ""
"Викликається, коли тестовий приклад *test* зазнає невдачі або помилки, але "
"його позначено декоратором :func:`expectedFailure`."

#: ../../library/unittest.rst:2163
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, formatted_err)`` до "
"атрибута екземпляра :attr:`expectedFailures`, де *formatted_err* є "
"відформатованим зворотним трасуванням, отриманим від *err*."

#: ../../library/unittest.rst:2170
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure`"
" decorator, but succeeded."
msgstr ""
"Викликається, коли тестовий приклад *test* був позначений декоратором "
":func:`expectedFailure`, але завершився успішно."

#: ../../library/unittest.rst:2173
msgid ""
"The default implementation appends the test to the instance's "
":attr:`unexpectedSuccesses` attribute."
msgstr ""
"Стандартна реалізація додає тест до атрибута екземпляра "
":attr:`unexpectedSuccesses`."

#: ../../library/unittest.rst:2179
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Викликається після завершення підтесту. *test* — тестовий приклад, що "
"відповідає методу тестування. *subtest* — це спеціальний екземпляр "
":class:`TestCase`, який описує субтест."

#: ../../library/unittest.rst:2183
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by "
":func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Якщо *результат* :const:`None`, субтест пройшов успішно. В іншому випадку це"
" не вдалося за винятком, коли *результат* є кортежем форми, яку повертає "
":func:`sys.exc_info`: ``(тип, значення, відстеження)``."

#: ../../library/unittest.rst:2187
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"Реалізація за замовчуванням не робить нічого, якщо результат є успішним, і "
"записує помилки підтесту як звичайні помилки."

#: ../../library/unittest.rst:2194
msgid ""
"Called when the test case finishes.  *elapsed* is the time represented in "
"seconds, and it includes the execution of cleanup functions."
msgstr ""

#: ../../library/unittest.rst:2201
msgid ""
"A concrete implementation of :class:`TestResult` used by the "
":class:`TextTestRunner`. Subclasses should accept ``**kwargs`` to ensure "
"compatibility as the interface changes."
msgstr ""

#: ../../library/unittest.rst:2207
msgid "Added the *durations* keyword parameter."
msgstr ""

#: ../../library/unittest.rst:2212
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Примірник класу :class:`TestLoader` призначений для спільного використання. "
"Якщо налаштування :class:`TestLoader` не потрібні, цей екземпляр можна "
"використовувати замість повторного створення нових екземплярів."

#: ../../library/unittest.rst:2221
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"Базова реалізація програми виконання тестів, яка виводить результати в "
"потік. Якщо *stream* має значення ``None``, стандартний :data:`sys.stderr` "
"використовується як вихідний потік. Цей клас має декілька настроюваних "
"параметрів, але по суті дуже простий. Графічні програми, які запускають "
"набори тестів, повинні надавати альтернативні реалізації. Такі реалізації "
"повинні приймати ``**kwargs``, оскільки інтерфейс для створення бігунів "
"змінюється, коли функції додаються до unittest."

#: ../../library/unittest.rst:2228
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, "
":exc:`PendingDeprecationWarning`, :exc:`ResourceWarning` and "
":exc:`ImportWarning` even if they are :ref:`ignored by default <warning-"
"ignored>`.  This behavior can be overridden using Python's :option:`!-Wd` or"
" :option:`!-Wa` options (see :ref:`Warning control <using-on-warnings>`) and"
" leaving *warnings* to ``None``."
msgstr ""

#: ../../library/unittest.rst:2236
msgid "Added the *warnings* parameter."
msgstr ""

#: ../../library/unittest.rst:2239
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather"
" than import time."
msgstr ""
"Потік за замовчуванням встановлено на :data:`sys.stderr` під час створення "
"екземпляра, а не під час імпорту."

#: ../../library/unittest.rst:2243
msgid "Added the *tb_locals* parameter."
msgstr ""

#: ../../library/unittest.rst:2246
msgid "Added the *durations* parameter."
msgstr ""

#: ../../library/unittest.rst:2251
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Цей метод повертає екземпляр ``TestResult``, який використовується "
":meth:`run`. Він не призначений для безпосереднього виклику, але може бути "
"замінений у підкласах, щоб надати спеціальний ``TestResult``."

#: ../../library/unittest.rst:2255
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` створює екземпляр класу або виклику, переданого в "
"конструкторі ``TextTestRunner`` як аргумент ``resultclass``. За "
"замовчуванням :class:`TextTestResult`, якщо не надано ``resultclass``. Клас "
"результату створюється з такими аргументами:"

#: ../../library/unittest.rst:2260
msgid "stream, descriptions, verbosity"
msgstr ""

#: ../../library/unittest.rst:2264
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A "
":class:`TestResult` is created by calling :func:`_makeResult` and the "
"test(s) are run and the results printed to stdout."
msgstr ""
"Цей метод є основним публічним інтерфейсом для ``TextTestRunner``. Цей метод"
" приймає екземпляр :class:`TestSuite` або :class:`TestCase`. "
":class:`TestResult` створюється шляхом виклику :func:`_makeResult`, і "
"тест(и) запускаються, а результати виводяться на stdout."

#: ../../library/unittest.rst:2275
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The"
" simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Програма командного рядка, яка завантажує набір тестів із *модуля* та "
"запускає їх; це насамперед для того, щоб зробити тестові модулі зручними для"
" виконання. Найпростішим використанням цієї функції є додавання такого рядка"
" в кінці тестового сценарію::"

#: ../../library/unittest.rst:2280
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""

#: ../../library/unittest.rst:2283
msgid ""
"You can run tests with more detailed information by passing in the verbosity"
" argument::"
msgstr ""
"Ви можете запустити тести з більш детальною інформацією, передавши аргумент "
"verbosity::"

#: ../../library/unittest.rst:2286
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"
msgstr ""

#: ../../library/unittest.rst:2289
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If"
" not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"Аргумент *defaultTest* — це або назва окремого тесту, або ітерація імен "
"тестів для запуску, якщо жодні імена тестів не вказані через *argv*. Якщо не"
" вказано або ``None``, а імена тестів не надаються через *argv*, "
"запускаються всі тести, знайдені в *module*."

#: ../../library/unittest.rst:2294
msgid ""
"The *argv* argument can be a list of options passed to the program, with the"
" first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"Аргумент *argv* може бути списком параметрів, переданих програмі, з першим "
"елементом, який є назвою програми. Якщо не вказано або ``None``, "
"використовуються значення :data:`sys.argv`."

#: ../../library/unittest.rst:2298
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success (0) or failure (1) of the tests run. An exit "
"code of 5 indicates that no tests were run or skipped."
msgstr ""

#: ../../library/unittest.rst:2303
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"Аргумент *testLoader* має бути екземпляром :class:`TestLoader` і за "
"умовчанням має значення :data:`defaultTestLoader`."

#: ../../library/unittest.rst:2306
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` підтримує використання з інтерактивного інтерпретатора шляхом "
"передачі аргументу ``exit=False``. Це відображає результат у стандартному "
"виводі без виклику :func:`sys.exit`::"

#: ../../library/unittest.rst:2310
msgid ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"
msgstr ""

#: ../../library/unittest.rst:2313
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as"
" the same-name `command-line options`_."
msgstr ""
"Параметри *failfast*, *catchbreak* і *buffer* мають той самий ефект, що й "
"одноіменні параметри командного рядка (`command-line options`_)."

#: ../../library/unittest.rst:2316
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>`"
" that should be used while running the tests.  If it's not specified, it "
"will remain ``None`` if a :option:`!-W` option is passed to "
":program:`python` (see :ref:`Warning control <using-on-warnings>`), "
"otherwise it will be set to ``'default'``."
msgstr ""
"Аргумент *попередження* вказує :ref:`фільтр попереджень <warning-filter>`, "
"який слід використовувати під час виконання тестів. Якщо його не вказано, "
"він залишатиметься ``None``, якщо параметр :option:`!-W` передано "
":program:`python` (див. :ref:`Контроль попередження <using-on-warnings>`), "
"інакше він буде встановлений на ``'за замовчуванням``."

#: ../../library/unittest.rst:2322
msgid ""
"Calling ``main`` returns an object with the ``result`` attribute that "
"contains the result of the tests run as a :class:`unittest.TestResult`."
msgstr ""

#: ../../library/unittest.rst:2325
msgid "The *exit* parameter was added."
msgstr "Додано параметр *exit*."

#: ../../library/unittest.rst:2328
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Додано параметри *verbosity*, *failfast*, *catchbreak*, *buffer* і "
"*warnings*."

#: ../../library/unittest.rst:2332
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"Параметр *defaultTest* було змінено, щоб також приймати ітерацію імен "
"тестів."

#: ../../library/unittest.rst:2340
msgid "load_tests Protocol"
msgstr "протокол load_tests"

#: ../../library/unittest.rst:2344
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Модулі або пакунки можуть налаштувати спосіб завантаження тестів з них під "
"час звичайних тестових прогонів або виявлення тестів, реалізувавши функцію "
"під назвою ``load_tests``."

#: ../../library/unittest.rst:2347
msgid ""
"If a test module defines ``load_tests`` it will be called by "
":meth:`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Якщо тестовий модуль визначає ``load_tests``, він буде викликаний "
":meth:`TestLoader.loadTestsFromModule` з такими аргументами::"

#: ../../library/unittest.rst:2350 ../../library/unittest.rst:2382
msgid "load_tests(loader, standard_tests, pattern)"
msgstr ""

#: ../../library/unittest.rst:2352
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It"
" defaults to ``None``."
msgstr ""
"де *шаблон* передається безпосередньо з ``loadTestsFromModule``. За "
"замовчуванням ``None``."

#: ../../library/unittest.rst:2355
msgid "It should return a :class:`TestSuite`."
msgstr "Він має повернути :class:`TestSuite`."

#: ../../library/unittest.rst:2357
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* — це екземпляр :class:`TestLoader`, який виконує завантаження. "
"*standard_tests* — це тести, які за замовчуванням завантажуватимуться з "
"модуля. Зазвичай тестові модулі хочуть лише додавати або видаляти тести зі "
"стандартного набору тестів. Третій аргумент використовується під час "
"завантаження пакетів у рамках виявлення тесту."

#: ../../library/unittest.rst:2363
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of "
":class:`TestCase` classes may look like::"
msgstr ""
"Типова функція ``load_tests``, яка завантажує тести з певного набору класів "
":class:`TestCase`, може виглядати так:"

#: ../../library/unittest.rst:2366
msgid ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"
msgstr ""

#: ../../library/unittest.rst:2375
msgid ""
"If discovery is started in a directory containing a package, either from the"
" command line or by calling :meth:`TestLoader.discover`, then the package "
":file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be"
" left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Якщо відкриття розпочато в каталозі, що містить пакет, або з командного "
"рядка, або викликом :meth:`TestLoader.discover`, тоді пакет "
":file:`__init__.py` буде перевірено на ``load_tests``. Якщо ця функція не "
"існує, виявлення повториться в пакунку так, ніби це просто інший каталог. В "
"іншому випадку виявлення тестів пакета буде залишено до ``load_tests``, який"
" викликається з такими аргументами::"

#: ../../library/unittest.rst:2384
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from "
":file:`__init__.py`.)"
msgstr ""
"Це має повернути :class:`TestSuite`, що представляє всі тести з пакета. "
"(``standard_tests`` міститиме лише тести, зібрані з :file:`__init__.py`.)"

#: ../../library/unittest.rst:2388
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Оскільки шаблон передається в ``load_tests``, пакунок може продовжувати (і "
"потенційно змінювати) пошук тестів. Функція ``load_tests`` 'нічого не "
"робити' для тестового пакета виглядатиме так:"

#: ../../library/unittest.rst:2392
msgid ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"
msgstr ""

#: ../../library/unittest.rst:2399
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"Discovery більше не перевіряє назви пакетів на відповідність *шаблону* через"
" те, що назви пакетів не відповідають шаблону за замовчуванням."

#: ../../library/unittest.rst:2406
msgid "Class and Module Fixtures"
msgstr "Фікстури класів і модулів"

#: ../../library/unittest.rst:2408
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass`"
" from the previous class (if there is one) is called, followed by "
":meth:`setUpClass` from the new class."
msgstr ""
"Фікстури рівня класу та модуля реалізовано в :class:`TestSuite`. Коли набір "
"тестів зустрічає тест з нового класу, викликається :meth:`tearDownClass` з "
"попереднього класу (якщо він є), а потім :meth:`setUpClass` з нового класу."

#: ../../library/unittest.rst:2413
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"Подібним чином, якщо тест виконується з модуля, відмінного від попереднього,"
" тоді запускається ``tearDownModule`` з попереднього модуля, а потім "
"``setUpModule`` з нового модуля."

#: ../../library/unittest.rst:2417
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Після виконання всіх тестів запускаються остаточні ``tearDownClass`` і "
"``tearDownModule``."

#: ../../library/unittest.rst:2420
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with"
" care."
msgstr ""
"Зауважте, що спільні прилади погано працюють із [потенційними] функціями, "
"такими як розпаралелювання тестів, і вони порушують ізоляцію тестів. Їх слід"
" використовувати обережно."

#: ../../library/unittest.rst:2423
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"Стандартний порядок тестів, створених завантажувачами тестів unittest, "
"полягає в тому, щоб групувати всі тести з однакових модулів і класів разом. "
"Це призведе до виклику ``setUpClass`` / ``setUpModule`` (і т.д.) рівно один "
"раз для кожного класу та модуля. Якщо ви рандомізуєте порядок, щоб тести з "
"різних модулів і класів були суміжними один з одним, тоді ці спільні функції"
" фікстури можуть викликатися кілька разів під час одного запуску тесту."

#: ../../library/unittest.rst:2430
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to"
" support shared fixtures."
msgstr ""
"Спільні світильники не призначені для роботи з комплектами з нестандартним "
"упорядкуванням. ``BaseTestSuite`` все ще існує для фреймворків, які не "
"хочуть підтримувати спільні фікстури."

#: ../../library/unittest.rst:2434
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Якщо є будь-які винятки, викликані під час однієї зі спільних функцій "
"приладу, тест повідомляється як помилка. Оскільки немає відповідного "
"екземпляра тесту, для представлення помилки створюється об’єкт "
"``_ErrorHolder`` (який має той самий інтерфейс, що й :class:`TestCase`). "
"Якщо ви просто використовуєте стандартний модуль тестування, ця деталь не "
"має значення, але якщо ви є автором фреймворку, вона може бути актуальною."

#: ../../library/unittest.rst:2443
msgid "setUpClass and tearDownClass"
msgstr "setUpClass і tearDownClass"

#: ../../library/unittest.rst:2445
msgid "These must be implemented as class methods::"
msgstr "Вони повинні бути реалізовані як методи класу:"

#: ../../library/unittest.rst:2447
msgid ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"
msgstr ""

#: ../../library/unittest.rst:2458
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in "
":class:`TestCase` are empty."
msgstr ""
"Якщо ви хочете викликати ``setUpClass`` і ``tearDownClass`` базових класів, "
"ви повинні викликати їх самостійно. Реалізації в :class:`TestCase` порожні."

#: ../../library/unittest.rst:2462
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will"
" not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a "
":exc:`SkipTest` exception then the class will be reported as having been "
"skipped instead of as an error."
msgstr ""
"Якщо під час ``setUpClass`` виникає виняток, то тести в класі не "
"запускаються, а ``tearDownClass`` не запускається. Пропущені класи не "
"запускатимуть ``setUpClass`` або ``tearDownClass``. Якщо виняток є винятком "
":exc:`SkipTest`, тоді клас буде повідомлено як пропущений, а не як помилку."

#: ../../library/unittest.rst:2470
msgid "setUpModule and tearDownModule"
msgstr "setUpModule і tearDownModule"

#: ../../library/unittest.rst:2472
msgid "These should be implemented as functions::"
msgstr "Вони повинні бути реалізовані як функції:"

#: ../../library/unittest.rst:2474
msgid ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"
msgstr ""

#: ../../library/unittest.rst:2480
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the"
" module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as"
" having been skipped instead of as an error."
msgstr ""
"Якщо в ``setUpModule`` виникає виняток, тоді жоден із тестів у модулі не "
"буде запущено, а ``tearDownModule`` не буде запущено. Якщо виняток є "
"винятком :exc:`SkipTest`, тоді модуль буде повідомлено як пропущений, а не "
"як помилку."

#: ../../library/unittest.rst:2485
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Щоб додати код очищення, який потрібно запускати навіть у випадку винятку, "
"використовуйте ``addModuleCleanup``:"

#: ../../library/unittest.rst:2491
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into "
":meth:`addModuleCleanup` when they are added."
msgstr ""
"Додайте функцію, яка буде викликатися після :func:`tearDownModule` для "
"очищення ресурсів, використаних під час тестового класу. Функції будуть "
"викликані в порядку, зворотному порядку їх додавання (:abbr:`LIFO (останній "
"прийшов, перший вийшов)`). Вони викликаються з будь-якими аргументами та "
"ключовими аргументами, які передаються в :meth:`addModuleCleanup` під час їх"
" додавання."

#: ../../library/unittest.rst:2497
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Якщо :meth:`setUpModule` не вдається, тобто :func:`tearDownModule` не "
"викликається, тоді будь-які додані функції очищення все одно будуть "
"викликані."

#: ../../library/unittest.rst:2505
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its "
":meth:`~object.__exit__` method as a cleanup function by "
":func:`addModuleCleanup` and return the result of the "
":meth:`~object.__enter__` method."
msgstr ""

#: ../../library/unittest.rst:2515
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Ця функція викликається безумовно після :func:`tearDownModule` або після "
":func:`setUpModule`, якщо :func:`setUpModule` викликає виняткову ситуацію."

#: ../../library/unittest.rst:2518
msgid ""
"It is responsible for calling all the cleanup functions added by "
":func:`addModuleCleanup`. If you need cleanup functions to be called *prior*"
" to :func:`tearDownModule` then you can call :func:`doModuleCleanups` "
"yourself."
msgstr ""
"Він відповідає за виклик усіх функцій очищення, доданих "
":func:`addModuleCleanup`. Якщо вам потрібно, щоб функції очищення "
"викликалися *перед* :func:`tearDownModule`, ви можете викликати "
":func:`doModuleCleanups` самостійно."

#: ../../library/unittest.rst:2523
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one"
" at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` витягує методи зі стеку функцій очищення по одному,"
" тому їх можна викликати будь-коли."

#: ../../library/unittest.rst:2530
msgid "Signal Handling"
msgstr "Обробка сигналів"

#: ../../library/unittest.rst:2534
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""

#: ../../library/unittest.rst:2541
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed "
":const:`signal.SIGINT` handler, i.e. it has been replaced by the system "
"under test and delegated to, then it calls the default handler. This will "
"normally be the expected behavior by code that replaces an installed handler"
" and delegates to it. For individual tests that need ``unittest`` control-c "
"handling disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"Обробник сигналів обробки control-c намагається залишатися сумісним із кодом"
" або тестами, які встановлюють власний обробник :const:`signal.SIGINT`. Якщо"
" обробник ``unittest`` викликається, але *не* встановлений обробник "
":const:`signal.SIGINT`, тобто він був замінений тестованою системою та "
"делегований, тоді він викликає обробник за замовчуванням. Зазвичай це буде "
"очікувана поведінка коду, який замінює встановлений обробник і делегує йому."
" Для окремих тестів, які потребують вимкнення обробки ``unittest`` "
"control-c, можна використовувати декоратор :func:`removeHandler`."

#: ../../library/unittest.rst:2550
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Існує кілька службових функцій для авторів фреймворків, щоб увімкнути "
"функціональність обробки control-c у тестових фреймворках."

#: ../../library/unittest.rst:2555
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Встановіть обробник control-c. Коли отримано :const:`signal.SIGINT` "
"(зазвичай у відповідь на натискання користувачем control-c), усі "
"зареєстровані результати викликають :meth:`~TestResult.stop`."

#: ../../library/unittest.rst:2562
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Зареєструйте об’єкт :class:`TestResult` для обробки control-c. Реєстрація "
"результату зберігає слабке посилання на нього, тому це не запобігає збиранню"
" сміття результату."

#: ../../library/unittest.rst:2566
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all"
" results they create independently of whether or not handling is enabled."
msgstr ""
"Реєстрація об’єкта :class:`TestResult` не має побічних ефектів, якщо обробку"
" control-c не ввімкнено, тому тестові фреймворки можуть беззастережно "
"реєструвати всі створені ними результати незалежно від того, увімкнено "
"обробку чи ні."

#: ../../library/unittest.rst:2573
msgid ""
"Remove a registered result. Once a result has been removed then "
":meth:`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Видалити зареєстрований результат. Після видалення результату "
":meth:`~TestResult.stop` більше не викликатиметься для цього об’єкта "
"результату у відповідь на control-c."

#: ../../library/unittest.rst:2580
msgid ""
"When called without arguments this function removes the control-c handler if"
" it has been installed. This function can also be used as a test decorator "
"to temporarily remove the handler while the test is being executed::"
msgstr ""
"При виклику без аргументів ця функція видаляє обробник control-c, якщо він "
"був встановлений. Цю функцію також можна використовувати як декоратор тесту "
"для тимчасового видалення обробника під час виконання тесту:"

#: ../../library/unittest.rst:2584
msgid ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
msgstr ""
