# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-22 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:07+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/hashlib.rst:2
msgid ":mod:`!hashlib` --- Secure hashes and message digests"
msgstr ""

#: ../../library/hashlib.rst:10
msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Вихідний код:** :source:`Lib/hashlib.py`"

#: ../../library/hashlib.rst:23
msgid ""
"This module implements a common interface to many different secure hash and "
"message digest algorithms.  Included are the FIPS secure hash algorithms "
"SHA1, SHA224, SHA256, SHA384, SHA512, (defined in `the FIPS 180-4 "
"standard`_), the SHA-3 series (defined in `the FIPS 202 standard`_) as well "
"as RSA's MD5 algorithm (defined in internet :rfc:`1321`).  The terms "
"\"secure hash\" and \"message digest\" are interchangeable.  Older "
"algorithms were called message digests.  The modern term is secure hash."
msgstr ""

#: ../../library/hashlib.rst:33
msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the "
":mod:`zlib` module."
msgstr ""
"Якщо вам потрібні хеш-функції adler32 або crc32, вони доступні в модулі "
":mod:`zlib`."

#: ../../library/hashlib.rst:40
msgid "Hash algorithms"
msgstr "Хеш-алгоритми"

#: ../../library/hashlib.rst:42
msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use "
":func:`sha256` to create a SHA-256 hash object. You can now feed this object"
" with :term:`bytes-like objects <bytes-like object>` (normally "
":class:`bytes`) using the :meth:`update<hash.update>` method.  At any point "
"you can ask it for the :dfn:`digest` of the concatenation of the data fed to"
" it so far using the :meth:`digest()<hash.digest>` or "
":meth:`hexdigest()<hash.hexdigest>` methods."
msgstr ""

#: ../../library/hashlib.rst:50
msgid ""
"To allow multithreading, the Python :term:`GIL` is released while computing "
"a hash supplied more than 2047 bytes of data at once in its constructor or "
":meth:`.update<hash.update>` method."
msgstr ""

#: ../../library/hashlib.rst:57
msgid ""
"Constructors for hash algorithms that are always present in this module are "
":func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, "
":func:`sha512`, :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, "
":func:`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:`blake2b`, and"
" :func:`blake2s`. :func:`md5` is normally available as well, though it may "
"be missing or blocked if you are using a rare \"FIPS compliant\" build of "
"Python. These correspond to :data:`algorithms_guaranteed`."
msgstr ""

#: ../../library/hashlib.rst:65
msgid ""
"Additional algorithms may also be available if your Python distribution's "
":mod:`hashlib` was linked against a build of OpenSSL that provides others. "
"Others *are not guaranteed available* on all installations and will only be "
"accessible by name via :func:`new`.  See :data:`algorithms_available`."
msgstr ""

#: ../../library/hashlib.rst:72
msgid ""
"Some algorithms have known hash collision weaknesses (including MD5 and "
"SHA1). Refer to `Attacks on cryptographic hash algorithms`_ and the "
"`hashlib-seealso`_ section at the end of this document."
msgstr ""

#: ../../library/hashlib.rst:76
msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, "
":func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` "
"were added. :func:`blake2b` and :func:`blake2s` were added."
msgstr ""

#: ../../library/hashlib.rst:84
msgid ""
"All hashlib constructors take a keyword-only argument *usedforsecurity* with"
" default value ``True``. A false value allows the use of insecure and "
"blocked hashing algorithms in restricted environments. ``False`` indicates "
"that the hashing algorithm is not used in a security context, e.g. as a non-"
"cryptographic one-way compression function."
msgstr ""
"Усі конструктори хешлібів приймають лише ключовий аргумент *usedforsecurity*"
" зі значенням за замовчуванням ``True``. Помилкове значення дозволяє "
"використовувати небезпечні та заблоковані алгоритми хешування в обмежених "
"середовищах. ``False`` вказує на те, що алгоритм хешування не "
"використовується в контексті безпеки, напр. як некриптографічна функція "
"одностороннього стиснення."

#: ../../library/hashlib.rst:91
msgid "Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it."
msgstr ""

#: ../../library/hashlib.rst:94
msgid ""
"For any of the MD5, SHA1, SHA2, or SHA3 algorithms that the linked OpenSSL "
"does not provide we fall back to a verified implementation from the `HACL\\*"
" project`_."
msgstr ""

#: ../../library/hashlib.rst:100
msgid "Usage"
msgstr "Використання"

#: ../../library/hashlib.rst:102
msgid ""
"To obtain the digest of the byte string ``b\"Nobody inspects the spammish "
"repetition\"``::"
msgstr ""

#: ../../library/hashlib.rst:105
msgid ""
">>> import hashlib\n"
">>> m = hashlib.sha256()\n"
">>> m.update(b\"Nobody inspects\")\n"
">>> m.update(b\" the spammish repetition\")\n"
">>> m.digest()\n"
"b'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\n"
">>> m.hexdigest()\n"
"'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'"
msgstr ""

#: ../../library/hashlib.rst:114
msgid "More condensed:"
msgstr "Більш стисло:"

#: ../../library/hashlib.rst:120
msgid "Constructors"
msgstr ""

#: ../../library/hashlib.rst:124
msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer."
msgstr ""

#: ../../library/hashlib.rst:129
msgid "Using :func:`new` with an algorithm name:"
msgstr ""

#: ../../library/hashlib.rst:148
msgid ""
"Named constructors such as these are faster than passing an algorithm name "
"to :func:`new`."
msgstr ""

#: ../../library/hashlib.rst:152
msgid "Attributes"
msgstr "Атрибути"

#: ../../library/hashlib.rst:154
msgid "Hashlib provides the following constant module attributes:"
msgstr ""

#: ../../library/hashlib.rst:158
msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported"
" by this module on all platforms.  Note that 'md5' is in this list despite "
"some upstream vendors offering an odd \"FIPS compliant\" Python build that "
"excludes it."
msgstr ""
"Набір, що містить назви геш-алгоритмів, які гарантовано підтримуватимуться "
"цим модулем на всіх платформах. Зауважте, що \"md5\" є в цьому списку, "
"незважаючи на те, що деякі постачальники вищого рівня пропонують дивну "
"\"FIPS-сумісну\" збірку Python, яка виключає його."

#: ../../library/hashlib.rst:167
msgid ""
"A set containing the names of the hash algorithms that are available in the "
"running Python interpreter.  These names will be recognized when passed to "
":func:`new`.  :attr:`algorithms_guaranteed` will always be a subset.  The "
"same algorithm may appear multiple times in this set under different names "
"(thanks to OpenSSL)."
msgstr ""
"Набір, що містить імена геш-алгоритмів, доступних у запущеному "
"інтерпретаторі Python. Ці назви буде розпізнано, коли передано :func:`new`. "
":attr:`algorithms_guaranteed` завжди буде підмножиною. Той самий алгоритм "
"може з’являтися кілька разів у цьому наборі під різними назвами (завдяки "
"OpenSSL)."

#: ../../library/hashlib.rst:176
msgid "Hash Objects"
msgstr ""

#: ../../library/hashlib.rst:178
msgid ""
"The following values are provided as constant attributes of the hash objects"
" returned by the constructors:"
msgstr ""
"Наступні значення надаються як постійні атрибути хеш-об’єктів, які "
"повертаються конструкторами:"

#: ../../library/hashlib.rst:183
msgid "The size of the resulting hash in bytes."
msgstr "Розмір отриманого хешу в байтах."

#: ../../library/hashlib.rst:187
msgid "The internal block size of the hash algorithm in bytes."
msgstr "Розмір внутрішнього блоку хеш-алгоритму в байтах."

#: ../../library/hashlib.rst:189
msgid "A hash object has the following attributes:"
msgstr "Хеш-об’єкт має такі атрибути:"

#: ../../library/hashlib.rst:193
msgid ""
"The canonical name of this hash, always lowercase and always suitable as a "
"parameter to :func:`new` to create another hash of this type."
msgstr ""
"Канонічна назва цього хешу, завжди в нижньому регістрі та завжди підходить "
"як параметр для :func:`new` для створення іншого хешу цього типу."

#: ../../library/hashlib.rst:196
msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"Атрибут name був присутній у CPython з моменту його створення, але до Python"
" 3.4 не було офіційно визначено, тому може не існувати на деяких платформах."

#: ../../library/hashlib.rst:201
msgid "A hash object has the following methods:"
msgstr "Хеш-об’єкт має такі методи:"

#: ../../library/hashlib.rst:206
msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls "
"are equivalent to a single call with the concatenation of all the arguments:"
" ``m.update(a); m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Оновіть хеш-об’єкт за допомогою :term:`bytes-like object`. Повторні виклики "
"еквівалентні одному виклику з конкатенацією всіх аргументів: ``m.update(a); "
"m.update(b)`` еквівалентно ``m.update(a+b)``."

#: ../../library/hashlib.rst:214
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size :attr:`digest_size` which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"Повертає дайджест даних, переданих до цього моменту методу :meth:`update`. "
"Це байтовий об’єкт розміром :attr:`digest_size`, який може містити байти в "
"усьому діапазоні від 0 до 255."

#: ../../library/hashlib.rst:221
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
"Подібно до :meth:`digest`, за винятком того, що дайджест повертається як "
"рядковий об’єкт подвійної довжини, що містить лише шістнадцяткові цифри. Це "
"можна використовувати для безпечного обміну значенням в електронній пошті чи"
" в інших небінарних середовищах."

#: ../../library/hashlib.rst:228
msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial substring."
msgstr ""
"Повертає копію (\"клон\") хеш-об'єкта. Це можна використовувати для "
"ефективного обчислення дайджестів даних, які спільно використовують "
"загальний початковий підрядок."

#: ../../library/hashlib.rst:233
msgid "SHAKE variable length digests"
msgstr "Дайджести змінної довжини SHAKE"

#: ../../library/hashlib.rst:238
msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. As "
"such, their digest methods require a length. Maximum length is not limited "
"by the SHAKE algorithm."
msgstr ""
"Алгоритми :func:`shake_128` і :func:`shake_256` забезпечують дайджести "
"змінної довжини з length_in_bits//2 до 128 або 256 біт безпеки. Таким чином,"
" їх методи дайджесту вимагають довжини. Максимальна довжина не обмежена "
"алгоритмом SHAKE."

#: ../../library/hashlib.rst:245
msgid ""
"Return the digest of the data passed to the :meth:`~hash.update` method so "
"far. This is a bytes object of size *length* which may contain bytes in the "
"whole range from 0 to 255."
msgstr ""

#: ../../library/hashlib.rst:252
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value in email or other non-binary environments."
msgstr ""

#: ../../library/hashlib.rst:256
msgid "Example use:"
msgstr ""

#: ../../library/hashlib.rst:263
msgid "File hashing"
msgstr ""

#: ../../library/hashlib.rst:265
msgid ""
"The hashlib module provides a helper function for efficient hashing of a "
"file or file-like object."
msgstr ""

#: ../../library/hashlib.rst:270
msgid ""
"Return a digest object that has been updated with contents of file object."
msgstr ""

#: ../../library/hashlib.rst:272
msgid ""
"*fileobj* must be a file-like object opened for reading in binary mode. It "
"accepts file objects from  builtin :func:`open`, :class:`~io.BytesIO` "
"instances, SocketIO objects from :meth:`socket.socket.makefile`, and "
"similar. The function may bypass Python's I/O and use the file descriptor "
"from :meth:`~io.IOBase.fileno` directly. *fileobj* must be assumed to be in "
"an unknown state after this function returns or raises. It is up to the "
"caller to close *fileobj*."
msgstr ""

#: ../../library/hashlib.rst:280
msgid ""
"*digest* must either be a hash algorithm name as a *str*, a hash "
"constructor, or a callable that returns a hash object."
msgstr ""

#: ../../library/hashlib.rst:283
msgid "Example:"
msgstr "приклад:"

#: ../../library/hashlib.rst:306
msgid "Key derivation"
msgstr "Виведення ключів"

#: ../../library/hashlib.rst:308
msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function must"
" be tunable, slow, and include a `salt "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_."
msgstr ""
"Алгоритми виведення та розтягування ключа створені для безпечного хешування "
"паролів. Наївні алгоритми, такі як ``sha1(password)``, не стійкі до атак "
"грубої сили. Хороша функція хешування пароля має бути настроюваною, "
"повільною та містити `salt "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_."

#: ../../library/hashlib.rst:316
msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It "
"uses HMAC as pseudorandom function."
msgstr ""
"Ця функція забезпечує функцію виведення ключа на основі пароля PKCS#5 2. "
"Вона використовує HMAC як псевдовипадкову функцію."

#: ../../library/hashlib.rst:319
msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for "
"HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted as "
"buffers of bytes. Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024). *salt* should be about 16 or more bytes from a "
"proper source, e.g. :func:`os.urandom`."
msgstr ""
"Рядок *hash_name* є бажаною назвою алгоритму хеш-дайджесту для HMAC, "
"наприклад. \"sha1\" або \"sha256\". *password* і *salt* інтерпретуються як "
"буфери байтів. Програми та бібліотеки мають обмежувати *пароль* розумною "
"довжиною (наприклад, 1024). *salt* має бути приблизно 16 або більше байтів "
"із належного джерела, напр. :func:`os.urandom`."

#: ../../library/hashlib.rst:325
msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and "
"computing power. As of 2022, hundreds of thousands of iterations of SHA-256 "
"are suggested. For rationale as to why and how to choose what is best for "
"your application, read *Appendix A.2.2* of NIST-SP-800-132_. The answers on "
"the `stackexchange pbkdf2 iterations question`_ explain in detail."
msgstr ""
"Кількість *ітерацій* слід вибирати, виходячи з алгоритму хешування та "
"обчислювальної потужності. Станом на 2022 рік пропонуються сотні тисяч "
"ітерацій SHA-256. Для обґрунтування того, чому та як вибрати те, що найкраще"
" підходить для вашої програми, прочитайте *Додаток A.2.2* NIST-SP-800-132_. "
"Відповіді на `stackexchange pbkdf2 iterations question`_ пояснюють детально."

#: ../../library/hashlib.rst:331
msgid ""
"*dklen* is the length of the derived key in bytes. If *dklen* is ``None`` "
"then the digest size of the hash algorithm *hash_name* is used, e.g. 64 for "
"SHA-512."
msgstr ""

#: ../../library/hashlib.rst:340
msgid "Function only available when Python is compiled with OpenSSL."
msgstr ""

#: ../../library/hashlib.rst:344
msgid ""
"Function now only available when Python is built with OpenSSL. The slow pure"
" Python implementation has been removed."
msgstr ""

#: ../../library/hashlib.rst:350
msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr ""
"Функція забезпечує функцію виведення ключа на основі пароля scrypt, як "
"визначено в :rfc:`7914`."

#: ../../library/hashlib.rst:353
msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a sensible "
"length (e.g. 1024).  *salt* should be about 16 or more bytes from a proper "
"source, e.g. :func:`os.urandom`."
msgstr ""
"*пароль* і *соль* мають бути :term:`байтоподібними об’єктами <bytes-like "
"object>`. Програми та бібліотеки повинні обмежувати *пароль* розумною "
"довжиною (наприклад, 1024). *salt* має бути приблизно 16 або більше байтів "
"із належного джерела, напр. :func:`os.urandom`."

#: ../../library/hashlib.rst:358
msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization "
"factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). "
"*dklen* is the length of the derived key in bytes."
msgstr ""

#: ../../library/hashlib.rst:368
msgid "BLAKE2"
msgstr "БЛЕЙК2"

#: ../../library/hashlib.rst:375
msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes "
"in two flavors:"
msgstr ""
"BLAKE2_ — це криптографічна хеш-функція, визначена в :rfc:`7693`, яка має "
"два варіанти:"

#: ../../library/hashlib.rst:378
msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size"
" between 1 and 64 bytes,"
msgstr ""
"**BLAKE2b**, оптимізований для 64-розрядних платформ і створює дайджести "
"будь-якого розміру від 1 до 64 байтів,"

#: ../../library/hashlib.rst:381
msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of "
"any size between 1 and 32 bytes."
msgstr ""
"**BLAKE2s**, оптимізований для платформ від 8 до 32 біт і створює дайджести "
"будь-якого розміру від 1 до 32 байтів."

#: ../../library/hashlib.rst:384
msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_),"
" **salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 підтримує **ключовий режим** (швидша та простіша заміна HMAC_), "
"**солі хешування**, **персоналізацію** та **хешування дерева**."

#: ../../library/hashlib.rst:387
msgid ""
"Hash objects from this module follow the API of standard library's "
":mod:`hashlib` objects."
msgstr ""
"Хеш-об’єкти з цього модуля відповідають API об’єктів :mod:`hashlib` "
"стандартної бібліотеки."

#: ../../library/hashlib.rst:392
msgid "Creating hash objects"
msgstr "Створення хеш-об'єктів"

#: ../../library/hashlib.rst:394
msgid "New hash objects are created by calling constructor functions:"
msgstr "Нові хеш-об’єкти створюються шляхом виклику функцій конструктора:"

#: ../../library/hashlib.rst:408
msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Ці функції повертають відповідні хеш-об’єкти для обчислення BLAKE2b або "
"BLAKE2s. Вони необов'язково приймають такі загальні параметри:"

#: ../../library/hashlib.rst:411
msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data*: початкова частина даних для хешування, яка має бути :term:`bytes-"
"like object`. Його можна передати лише як позиційний аргумент."

#: ../../library/hashlib.rst:414
msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: розмір вихідного дайджесту в байтах."

#: ../../library/hashlib.rst:416
msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for"
" BLAKE2s)."
msgstr ""
"*key*: ключ для хешування з ключем (до 64 байтів для BLAKE2b, до 32 байтів "
"для BLAKE2s)."

#: ../../library/hashlib.rst:419
msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr ""
"*salt*: сіль для рандомізованого хешування (до 16 байт для BLAKE2b, до 8 "
"байт для BLAKE2s)."

#: ../../library/hashlib.rst:422
msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes "
"for BLAKE2s)."
msgstr ""
"*особа*: рядок персоналізації (до 16 байт для BLAKE2b, до 8 байт для "
"BLAKE2s)."

#: ../../library/hashlib.rst:425
msgid "The following table shows limits for general parameters (in bytes):"
msgstr ""
"У наступній таблиці показано обмеження для загальних параметрів (у байтах):"

#: ../../library/hashlib.rst:428
msgid "Hash"
msgstr "Хеш"

#: ../../library/hashlib.rst:428
msgid "digest_size"
msgstr "digest_size"

#: ../../library/hashlib.rst:428
msgid "len(key)"
msgstr "len (ключ)"

#: ../../library/hashlib.rst:428
msgid "len(salt)"
msgstr "лен (сіль)"

#: ../../library/hashlib.rst:428
msgid "len(person)"
msgstr "len (особа)"

#: ../../library/hashlib.rst:430
msgid "BLAKE2b"
msgstr "BLAKE2b"

#: ../../library/hashlib.rst:430
msgid "64"
msgstr "64"

#: ../../library/hashlib.rst:430
msgid "16"
msgstr "16"

#: ../../library/hashlib.rst:431
msgid "BLAKE2s"
msgstr "BLAKE2s"

#: ../../library/hashlib.rst:431
msgid "32"
msgstr "32"

#: ../../library/hashlib.rst:431
msgid "8"
msgstr "8"

#: ../../library/hashlib.rst:436
msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization "
"parameters, however, for convenience, this implementation accepts byte "
"strings of any size up to the specified length. If the length of the "
"parameter is less than specified, it is padded with zeros, thus, for "
"example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. (This is not "
"the case for *key*.)"
msgstr ""
"Специфікація BLAKE2 визначає постійну довжину параметрів солі та "
"персоналізації, однак для зручності ця реалізація приймає рядки байтів будь-"
"якого розміру до вказаної довжини. Якщо довжина параметра менша за вказану, "
"вона доповнюється нулями, таким чином, наприклад, ``b'salt`` і "
"``b'salt\\x00`` є однаковими значеннями. (Це не стосується *ключа*.)"

#: ../../library/hashlib.rst:443
msgid "These sizes are available as module `constants`_ described below."
msgstr "Ці розміри доступні як `constants`_ модуля, описані нижче."

#: ../../library/hashlib.rst:445
msgid ""
"Constructor functions also accept the following tree hashing parameters:"
msgstr "Функції конструктора також приймають такі параметри хешування дерева:"

#: ../../library/hashlib.rst:447
msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr ""
"*fanout*: розхід (від 0 до 255, 0, якщо необмежений, 1 у послідовному "
"режимі)."

#: ../../library/hashlib.rst:449
msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential "
"mode)."
msgstr ""
"*depth*: максимальна глибина дерева (від 1 до 255, 255, якщо необмежено, 1 у"
" послідовному режимі)."

#: ../../library/hashlib.rst:452
msgid ""
"*leaf_size*: maximal byte length of leaf (0 to ``2**32-1``, 0 if unlimited "
"or in sequential mode)."
msgstr ""
"*leaf_size*: максимальна довжина листа в байтах (від 0 до ``2**32-1``, 0, "
"якщо необмежений або в послідовному режимі)."

#: ../../library/hashlib.rst:455
msgid ""
"*node_offset*: node offset (0 to ``2**64-1`` for BLAKE2b, 0 to ``2**48-1`` "
"for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset*: зміщення вузла (від 0 до ``2**64-1`` для BLAKE2b, від 0 до "
"``2**48-1`` для BLAKE2s, 0 для першого, крайнього лівого листа, або в "
"послідовному режимі )."

#: ../../library/hashlib.rst:458
msgid ""
"*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_depth*: глибина вузла (від 0 до 255, 0 для листів або в послідовному "
"режимі)."

#: ../../library/hashlib.rst:460
msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0"
" in sequential mode)."
msgstr ""
"*inner_size*: розмір внутрішнього дайджесту (від 0 до 64 для BLAKE2b, від 0 "
"до 32 для BLAKE2s, 0 у послідовному режимі)."

#: ../../library/hashlib.rst:463
msgid ""
"*last_node*: boolean indicating whether the processed node is the last one "
"(``False`` for sequential mode)."
msgstr ""

#: ../../library/hashlib.rst:466
msgid "Explanation of tree mode parameters."
msgstr ""

#: ../../library/hashlib.rst:470
msgid ""
"See section 2.10 in `BLAKE2 specification "
"<https://www.blake2.net/blake2_20130129.pdf>`_ for comprehensive review of "
"tree hashing."
msgstr ""

#: ../../library/hashlib.rst:476
msgid "Constants"
msgstr "Константи"

#: ../../library/hashlib.rst:481
msgid "Salt length (maximum length accepted by constructors)."
msgstr "Довжина солі (максимальна довжина, прийнята конструкторами)."

#: ../../library/hashlib.rst:487
msgid ""
"Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Довжина рядка персоналізації (максимальна довжина, прийнята конструкторами)."

#: ../../library/hashlib.rst:493
msgid "Maximum key size."
msgstr "Максимальний розмір ключа."

#: ../../library/hashlib.rst:499
msgid "Maximum digest size that the hash function can output."
msgstr "Максимальний розмір дайджесту, який може вивести хеш-функція."

#: ../../library/hashlib.rst:503
msgid "Examples"
msgstr "Приклади"

#: ../../library/hashlib.rst:506
msgid "Simple hashing"
msgstr "Просте хешування"

#: ../../library/hashlib.rst:508
msgid ""
"To calculate hash of some data, you should first construct a hash object by "
"calling the appropriate constructor function (:func:`blake2b` or "
":func:`blake2s`), then update it with the data by calling "
":meth:`~hash.update` on the object, and, finally, get the digest out of the "
"object by calling :meth:`~hash.digest` (or :meth:`~hash.hexdigest` for hex-"
"encoded string)."
msgstr ""

#: ../../library/hashlib.rst:521
msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to "
"the constructor as the positional argument:"
msgstr ""
"Як ярлик, ви можете передати перший фрагмент даних для оновлення "
"безпосередньо в конструктор як позиційний аргумент:"

#: ../../library/hashlib.rst:528
msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively "
"update the hash:"
msgstr ""
"Ви можете викликати :meth:`hash.update` стільки разів, скільки потрібно для "
"повторного оновлення хешу:"

#: ../../library/hashlib.rst:542
msgid "Using different digest sizes"
msgstr "Використання різних розмірів дайджесту"

#: ../../library/hashlib.rst:544
msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to"
" 32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without "
"changing the size of output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 має настроюваний розмір дайджестів до 64 байтів для BLAKE2b і до 32 "
"байтів для BLAKE2s. Наприклад, щоб замінити SHA-1 на BLAKE2b без зміни "
"розміру виведення, ми можемо наказати BLAKE2b створювати 20-байтові "
"дайджести:"

#: ../../library/hashlib.rst:558
msgid ""
"Hash objects with different digest sizes have completely different outputs "
"(shorter hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s "
"produce different outputs even if the output length is the same:"
msgstr ""
"Хеш-об’єкти з різними розмірами дайджестів мають абсолютно різні результати "
"(коротші хеші *не* є префіксами більш довгих хешів); BLAKE2b і BLAKE2s "
"створюють різні результати, навіть якщо довжина виводу однакова:"

#: ../../library/hashlib.rst:574
msgid "Keyed hashing"
msgstr "Ключове хешування"

#: ../../library/hashlib.rst:576
msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code "
"<https://en.wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 can be securely used "
"in prefix-MAC mode thanks to the indifferentiability property inherited from"
" BLAKE."
msgstr ""
"Хешування з ключем можна використовувати для автентифікації як швидшу та "
"простішу заміну `коду автентифікації повідомлення на основі хешу "
"<https://en.wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 можна безпечно "
"використовувати в режимі prefix-MAC завдяки властивості "
"індиференційованості, успадкованій від BLAKE."

#: ../../library/hashlib.rst:582
msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code "
"for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"У цьому прикладі показано, як отримати (в шістнадцятковому кодуванні) "
"128-бітний код автентифікації для повідомлення ``b'message data`` з ключем "
"``b'pseudorandom key``::"

#: ../../library/hashlib.rst:585
msgid ""
">>> from hashlib import blake2b\n"
">>> h = blake2b(key=b'pseudorandom key', digest_size=16)\n"
">>> h.update(b'message data')\n"
">>> h.hexdigest()\n"
"'3d363ff7401e02026f4a4687d4863ced'"
msgstr ""

#: ../../library/hashlib.rst:592
msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered "
"with::"
msgstr ""
"Як практичний приклад, веб-додаток може симетрично підписувати файли cookie,"
" надіслані користувачам, а потім перевіряти їх, щоб переконатися, що вони не"
" були змінені:"

#: ../../library/hashlib.rst:595
msgid ""
">>> from hashlib import blake2b\n"
">>> from hmac import compare_digest\n"
">>>\n"
">>> SECRET_KEY = b'pseudorandomly generated server secret key'\n"
">>> AUTH_SIZE = 16\n"
">>>\n"
">>> def sign(cookie):\n"
"...     h = blake2b(digest_size=AUTH_SIZE, key=SECRET_KEY)\n"
"...     h.update(cookie)\n"
"...     return h.hexdigest().encode('utf-8')\n"
">>>\n"
">>> def verify(cookie, sig):\n"
"...     good_sig = sign(cookie)\n"
"...     return compare_digest(good_sig, sig)\n"
">>>\n"
">>> cookie = b'user-alice'\n"
">>> sig = sign(cookie)\n"
">>> print(\"{0},{1}\".format(cookie.decode('utf-8'), sig))\n"
"user-alice,b'43b3c982cf697e0c5ab22172d1ca7421'\n"
">>> verify(cookie, sig)\n"
"True\n"
">>> verify(b'user-bob', sig)\n"
"False\n"
">>> verify(cookie, b'0102030405060708090a0b0c0d0e0f00')\n"
"False"
msgstr ""

#: ../../library/hashlib.rst:621
msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be "
"used in HMAC construction with :mod:`hmac` module::"
msgstr ""
"Незважаючи на те, що існує режим хешування з рідним ключем, BLAKE2, "
"звичайно, можна використовувати в конструкції HMAC за допомогою модуля "
":mod:`hmac`::"

#: ../../library/hashlib.rst:624
msgid ""
">>> import hmac, hashlib\n"
">>> m = hmac.new(b'secret key', digestmod=hashlib.blake2s)\n"
">>> m.update(b'message')\n"
">>> m.hexdigest()\n"
"'e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142'"
msgstr ""

#: ../../library/hashlib.rst:632
msgid "Randomized hashing"
msgstr "Рандомізоване хешування"

#: ../../library/hashlib.rst:634
msgid ""
"By setting *salt* parameter users can introduce randomization to the hash "
"function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"Установивши параметр *salt*, користувачі можуть запровадити рандомізацію "
"хеш-функції. Рандомізоване хешування корисне для захисту від колізійних атак"
" на хеш-функцію, яка використовується в цифрових підписах."

#: ../../library/hashlib.rst:638
msgid ""
"Randomized hashing is designed for situations where one party, the message "
"preparer, generates all or part of a message to be signed by a second party,"
" the message signer. If the message preparer is able to find cryptographic "
"hash function collisions (i.e., two messages producing the same hash value),"
" then they might prepare meaningful versions of the message that would "
"produce the same hash value and digital signature, but with different "
"results (e.g., transferring $1,000,000 to an account, rather than $10). "
"Cryptographic hash functions have been designed with collision resistance as"
" a major goal, but the current concentration on attacking cryptographic hash"
" functions may result in a given cryptographic hash function providing less "
"collision resistance than expected. Randomized hashing offers the signer "
"additional protection by reducing the likelihood that a preparer can "
"generate two or more messages that ultimately yield the same hash value "
"during the digital signature generation process --- even if it is practical "
"to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature "
"when all portions of the message are prepared by the signer."
msgstr ""
"Рандомізоване хешування призначене для ситуацій, коли одна сторона, яка "
"готує повідомлення, створює все або частину повідомлення для підпису другою "
"стороною, особою, яка підписує повідомлення. Якщо готувач повідомлення може "
"знайти колізії криптографічної хеш-функції (тобто два повідомлення, що "
"створюють однакове хеш-значення), тоді він може підготувати значущі версії "
"повідомлення, які створять те саме хеш-значення та цифровий підпис, але з "
"різними результатами (наприклад, , переказуючи на рахунок 1 000 000 доларів "
"США, а не 10 доларів США). Основною метою криптографічних хеш-функцій було "
"розроблено стійкість до зіткнень, але поточна концентрація на атакуючих "
"криптографічних хеш-функціях може призвести до того, що дана криптографічна "
"хеш-функція забезпечить меншу стійкість до зіткнень, ніж очікувалося. "
"Рандомізоване хешування пропонує підписувачу додатковий захист, зменшуючи "
"ймовірність того, що підготовник зможе згенерувати два або більше "
"повідомлень, які в кінцевому підсумку дають однакове хеш-значення під час "
"процесу генерації цифрового підпису --- навіть якщо практично знайти колізії"
" для хеш-функції. Однак використання рандомізованого хешування може знизити "
"рівень безпеки, який забезпечує цифровий підпис, коли всі частини "
"повідомлення готуються підписувачем."

#: ../../library/hashlib.rst:657
msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" "
"<https://csrc.nist.gov/pubs/sp/800/106/final>`_)"
msgstr ""

#: ../../library/hashlib.rst:660
msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression function."
msgstr ""
"У BLAKE2 сіль обробляється як одноразовий вхід до хеш-функції під час "
"ініціалізації, а не як вхід для кожної функції стиснення."

#: ../../library/hashlib.rst:665
msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing "
"passwords.  See `BLAKE2 FAQ <https://www.blake2.net/#qa>`_ for more "
"information."
msgstr ""

#: ../../library/hashlib.rst:688
msgid "Personalization"
msgstr "Персоналізація"

#: ../../library/hashlib.rst:690
msgid ""
"Sometimes it is useful to force hash function to produce different digests "
"for the same input for different purposes. Quoting the authors of the Skein "
"hash function:"
msgstr ""
"Іноді корисно змусити хеш-функцію виробляти різні дайджести для одного "
"введення для різних цілей. Цитую авторів хеш-функції Skein:"

#: ../../library/hashlib.rst:694
msgid ""
"We recommend that all application designers seriously consider doing this; "
"we have seen many protocols where a hash that is computed in one part of the"
" protocol can be used in an entirely different part because two hash "
"computations were done on similar or related data, and the attacker can "
"force the application to make the hash inputs the same. Personalizing each "
"hash function used in the protocol summarily stops this type of attack."
msgstr ""
"Ми рекомендуємо всім розробникам додатків серйозно подумати про це; ми "
"бачили багато протоколів, де хеш, який обчислюється в одній частині "
"протоколу, може використовуватися в зовсім іншій частині, оскільки два хеш-"
"обчислення були виконані на подібних або пов’язаних даних, і зловмисник може"
" змусити програму зробити вхідні дані хешу те саме. Персоналізація кожної "
"хеш-функції, яка використовується в протоколі, швидко зупиняє цей тип атаки."

#: ../../library/hashlib.rst:701
msgid ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-"
"content/uploads/2016/02/skein.pdf>`_, p. 21)"
msgstr ""

#: ../../library/hashlib.rst:705
msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2 можна персоналізувати, передаючи байти в аргумент *person*::"

#: ../../library/hashlib.rst:707
msgid ""
">>> from hashlib import blake2b\n"
">>> FILES_HASH_PERSON = b'MyApp Files Hash'\n"
">>> BLOCK_HASH_PERSON = b'MyApp Block Hash'\n"
">>> h = blake2b(digest_size=32, person=FILES_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'\n"
">>> h = blake2b(digest_size=32, person=BLOCK_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'"
msgstr ""

#: ../../library/hashlib.rst:719
msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr ""
"Персоналізацію разом із режимом ключа також можна використовувати для "
"отримання різних ключів з одного."

#: ../../library/hashlib.rst:733
msgid "Tree mode"
msgstr "Режим дерева"

#: ../../library/hashlib.rst:735
msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr "Ось приклад хешування мінімального дерева з двома листовими вузлами:"

#: ../../library/hashlib.rst:737
msgid ""
"  10\n"
" /  \\\n"
"00  01"
msgstr ""

#: ../../library/hashlib.rst:741
msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final "
"digest::"
msgstr ""
"У цьому прикладі використовуються 64-байтові внутрішні дайджести та "
"повертається 32-байтовий остаточний дайджест:"

#: ../../library/hashlib.rst:744
msgid ""
">>> from hashlib import blake2b\n"
">>>\n"
">>> FANOUT = 2\n"
">>> DEPTH = 2\n"
">>> LEAF_SIZE = 4096\n"
">>> INNER_SIZE = 64\n"
">>>\n"
">>> buf = bytearray(6000)\n"
">>>\n"
">>> # Left leaf\n"
"... h00 = blake2b(buf[0:LEAF_SIZE], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=0, last_node=False)\n"
">>> # Right leaf\n"
"... h01 = blake2b(buf[LEAF_SIZE:], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=1, node_depth=0, last_node=True)\n"
">>> # Root node\n"
"... h10 = blake2b(digest_size=32, fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=1, last_node=True)\n"
">>> h10.update(h00.digest())\n"
">>> h10.update(h01.digest())\n"
">>> h10.hexdigest()\n"
"'3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa'"
msgstr ""

#: ../../library/hashlib.rst:771
msgid "Credits"
msgstr "Кредити"

#: ../../library/hashlib.rst:773
msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ "
"created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and "
"*Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ був розроблений *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn* і *Christian Winnerlein* на основі фіналіста SHA-3_ BLAKE_, "
"створеного *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier* і*Raphael "
"C.-W. Phan*."

#: ../../library/hashlib.rst:778
msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr ""
"Він використовує основний алгоритм із шифру ChaCha_, розробленого *Daniel J."
" Bernstein*."

#: ../../library/hashlib.rst:780
msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by "
"*Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. The "
"documentation was copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"Реалізація stdlib базується на модулі pyblake2_. Його написав *Dmitry "
"Chestnykh* на основі реалізації C, написаної *Samuel Neves*. Документація "
"була скопійована з pyblake2_ і написана *Дмитром Честних*."

#: ../../library/hashlib.rst:784
msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr "Код C був частково переписаний для Python *Christian Heimes*."

#: ../../library/hashlib.rst:786
msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr ""
"Наведені нижче правила загальнодоступного домену застосовуються до "
"реалізації хеш-функції C, коду розширення та цієї документації:"

#: ../../library/hashlib.rst:789
msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright"
" and related and neighboring rights to this software to the public domain "
"worldwide. This software is distributed without any warranty."
msgstr ""
"Наскільки це можливо згідно із законодавством, автор(и) передали всі "
"авторські права, суміжні та суміжні права на це програмне забезпечення у "
"суспільне надбання в усьому світі. Це програмне забезпечення "
"розповсюджується без будь-яких гарантій."

#: ../../library/hashlib.rst:793
msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along "
"with this software. If not, see "
"https://creativecommons.org/publicdomain/zero/1.0/."
msgstr ""
"Ви повинні були отримати копію CC0 Public Domain Dedication разом із цим "
"програмним забезпеченням. Якщо ні, перегляньте "
"https://creativecommons.org/publicdomain/zero/1.0/."

#: ../../library/hashlib.rst:797
msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"Наступні люди допомогли з розробкою або внесли свої зміни до проекту та "
"суспільного надбання відповідно до Creative Commons Public Domain Dedication"
" 1.0 Universal:"

#: ../../library/hashlib.rst:801
msgid "*Alexandr Sokolovskiy*"
msgstr "*Олександр Соколовський*"

#: ../../library/hashlib.rst:821
msgid "Module :mod:`hmac`"
msgstr "Модуль :mod:`hmac`"

#: ../../library/hashlib.rst:822
msgid "A module to generate message authentication codes using hashes."
msgstr ""
"Модуль для створення кодів автентифікації повідомлень за допомогою хешів."

#: ../../library/hashlib.rst:824
msgid "Module :mod:`base64`"
msgstr "Модуль :mod:`base64`"

#: ../../library/hashlib.rst:825
msgid "Another way to encode binary hashes for non-binary environments."
msgstr "Інший спосіб кодування двійкових хешів для небінарних середовищ."

#: ../../library/hashlib.rst:827
msgid "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"
msgstr ""

#: ../../library/hashlib.rst:828
msgid "The FIPS 180-4 publication on Secure Hash Algorithms."
msgstr ""

#: ../../library/hashlib.rst:830
msgid "https://csrc.nist.gov/pubs/fips/202/final"
msgstr ""

#: ../../library/hashlib.rst:831
msgid "The FIPS 202 publication on the SHA-3 Standard."
msgstr ""

#: ../../library/hashlib.rst:833
msgid "https://www.blake2.net/"
msgstr ""

#: ../../library/hashlib.rst:834
msgid "Official BLAKE2 website."
msgstr "Офіційний сайт BLAKE2."

#: ../../library/hashlib.rst:836
msgid "https://en.wikipedia.org/wiki/Cryptographic_hash_function"
msgstr ""

#: ../../library/hashlib.rst:837
msgid ""
"Wikipedia article with information on which algorithms have known issues and"
" what that means regarding their use."
msgstr ""
"Стаття у Вікіпедії з інформацією про те, які алгоритми мають відомі проблеми"
" та що це означає щодо їх використання."

#: ../../library/hashlib.rst:840
msgid "https://www.ietf.org/rfc/rfc8018.txt"
msgstr "https://www.ietf.org/rfc/rfc8018.txt"

#: ../../library/hashlib.rst:841
msgid "PKCS #5: Password-Based Cryptography Specification Version 2.1"
msgstr "PKCS #5: Специфікація криптографії на основі пароля, версія 2.1"

#: ../../library/hashlib.rst:843
msgid ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"
msgstr ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"

#: ../../library/hashlib.rst:844
msgid "NIST Recommendation for Password-Based Key Derivation."
msgstr "Рекомендації NIST щодо виведення ключів на основі пароля."

#: ../../library/hashlib.rst:12
msgid "message digest, MD5"
msgstr ""

#: ../../library/hashlib.rst:12
msgid ""
"secure hash algorithm, SHA1, SHA2, SHA224, SHA256, SHA384, SHA512, SHA3, "
"Shake, Blake2"
msgstr ""

#: ../../library/hashlib.rst:55
msgid "OpenSSL"
msgstr "OpenSSL"

#: ../../library/hashlib.rst:55
msgid "(use in module hashlib)"
msgstr ""

#: ../../library/hashlib.rst:372
msgid "blake2b, blake2s"
msgstr ""
