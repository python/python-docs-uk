# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:07+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`heapq` --- Heap queue algorithm"
msgstr ":mod:`heapq` --- Алгоритм черги купи"

msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**Вихідний код:** :source:`Lib/heapq.py`"

msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr ""
"Цей модуль забезпечує реалізацію алгоритму черги купи, також відомого як "
"алгоритм пріоритетної черги."

msgid ""
"Heaps are binary trees for which every parent node has a value less than or "
"equal to any of its children.  This implementation uses arrays for which "
"``heap[k] <= heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k*, "
"counting elements from zero.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that its smallest element is always the root, ``heap[0]``."
msgstr ""
"Купи — це бінарні дерева, для яких кожен батьківський вузол має значення, "
"менше або рівне будь-якому з його дочірніх вузлів. Ця реалізація "
"використовує масиви, для яких ``heap[k] <= heap[2*k+1]`` і ``heap[k] <= "
"heap[2*k+2]`` для всіх *k*, підраховуючи елементи з нуля. Для порівняння, "
"неіснуючі елементи вважаються нескінченними. Цікавою властивістю купи є те, "
"що її найменший елемент завжди є коренем, ``heap[0]``."

msgid ""
"The API below differs from textbook heap algorithms in two aspects: (a) We "
"use zero-based indexing.  This makes the relationship between the index for "
"a node and the indexes for its children slightly less obvious, but is more "
"suitable since Python uses zero-based indexing. (b) Our pop method returns "
"the smallest item, not the largest (called a \"min heap\" in textbooks; a "
"\"max heap\" is more common in texts because of its suitability for in-place "
"sorting)."
msgstr ""
"Наведений нижче API відрізняється від алгоритмів купи підручників двома "
"аспектами: (a) ми використовуємо індексування на основі нуля. Це робить "
"зв’язок між індексом для вузла та індексами для його дочірніх елементів дещо "
"менш очевидним, але є більш придатним, оскільки Python використовує "
"індексування від нуля. (b) Наш метод pop повертає найменший елемент, а не "
"найбільший (у підручниках називається \"мінімальна купа\"; \"максимальна "
"купа\" більш поширена в текстах через її придатність для сортування на "
"місці)."

msgid ""
"These two make it possible to view the heap as a regular Python list without "
"surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` maintains "
"the heap invariant!"
msgstr ""
"Ці два параметри дають змогу переглядати купу як звичайний список Python без "
"сюрпризів: ``heap[0]`` є найменшим елементом, а ``heap.sort()`` підтримує "
"незмінність купи!"

msgid ""
"To create a heap, use a list initialized to ``[]``, or you can transform a "
"populated list into a heap via function :func:`heapify`."
msgstr ""
"Щоб створити купу, використовуйте список, ініціалізований ``[]``, або ви "
"можете перетворити заповнений список на купу за допомогою функції :func:"
"`heapify`."

msgid "The following functions are provided:"
msgstr "Передбачені такі функції:"

msgid "Push the value *item* onto the *heap*, maintaining the heap invariant."
msgstr "Перемістіть значення *item* у *купу*, зберігаючи незмінність купи."

msgid ""
"Pop and return the smallest item from the *heap*, maintaining the heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr ""
"Витягніть і поверніть найменший елемент із *купи*, зберігаючи незмінність "
"купи. Якщо купа порожня, виникає :exc:`IndexError`. Щоб отримати доступ до "
"найменшого елемента, не відкриваючи його, використовуйте ``heap[0]``."

msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"Натисніть *item* на купу, а потім витягніть і поверніть найменший елемент із "
"*купи*. Комбінована дія працює ефективніше, ніж :func:`heappush`, після "
"якого слід окремий виклик :func:`heappop`."

msgid "Transform list *x* into a heap, in-place, in linear time."
msgstr "Перетворення списку *x* на купу, на місці, за лінійний час."

msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Витягніть і поверніть найменший предмет із *купи*, а також натисніть новий "
"*предмет*. Розмір купи не змінюється. Якщо купа порожня, виникає :exc:"
"`IndexError`."

msgid ""
"This one step operation is more efficient than a :func:`heappop` followed "
"by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr ""
"Ця одноетапна операція є ефективнішою, ніж :func:`heappop`, за якою слідує :"
"func:`heappush`, і може бути більш доцільною, якщо використовується купа "
"фіксованого розміру. Комбінація pop/push завжди повертає елемент із купи та "
"замінює його на *item*."

msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr ""
"Повернене значення може бути більшим за доданий *елемент*. Якщо це небажано, "
"подумайте про використання замість цього :func:`heappushpop`. Його "
"комбінація push/pop повертає менше з двох значень, залишаючи більше значення "
"в купі."

msgid "The module also offers three general purpose functions based on heaps."
msgstr ""
"Модуль також пропонує три функції загального призначення, засновані на купах."

msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge "
"timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr ""
"Об’єднайте кілька відсортованих вхідних даних в один відсортований вихід "
"(наприклад, об’єднайте записи з мітками часу з кількох файлів журналу). "
"Повертає :term:`iterator` над відсортованими значеннями."

msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the "
"input streams is already sorted (smallest to largest)."
msgstr ""
"Подібно до ``sorted(itertools.chain(*iterables))``, але повертає iterable, "
"не затягує дані в пам’ять усі одночасно та передбачає, що кожен із вхідних "
"потоків уже відсортовано (від найменшого до найбільшого)."

msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""
"Має два необов’язкові аргументи, які необхідно вказати як аргументи "
"ключового слова."

msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key* визначає :term:`key function` одного аргументу, який використовується "
"для отримання ключа порівняння з кожного вхідного елемента. Значення за "
"замовчуванням – ``None`` (пряме порівняння елементів)."

msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input elements "
"are merged as if each comparison were reversed. To achieve behavior similar "
"to ``sorted(itertools.chain(*iterables), reverse=True)``, all iterables must "
"be sorted from largest to smallest."
msgstr ""
"*reverse* — це логічне значення. Якщо встановлено значення ``True``, то "
"вхідні елементи об’єднуються так, ніби кожне порівняння було зворотним. Щоб "
"досягти поведінки, подібної до ``sorted(itertools.chain(*iterables), "
"reverse=True)``, усі ітератори мають бути відсортовані від найбільшого до "
"найменшого."

msgid "Added the optional *key* and *reverse* parameters."
msgstr "Додано додаткові параметри *key* і *reverse*."

msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``."
msgstr ""
"Повертає список із *n* найбільшими елементами з набору даних, визначеного "
"*iterable*. *key*, якщо надається, визначає функцію одного аргументу, який "
"використовується для отримання ключа порівняння з кожного елемента в "
"*iterable* (наприклад, ``key=str.lower``). Еквівалент: ``sorted(iterable, "
"key=key, reverse=True)[:n]``."

msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key)[:"
"n]``."
msgstr ""
"Повертає список із *n* найменшими елементами з набору даних, визначеного "
"*iterable*. *key*, якщо надається, визначає функцію одного аргументу, який "
"використовується для отримання ключа порівняння з кожного елемента в "
"*iterable* (наприклад, ``key=str.lower``). Еквівалент: ``sorted(iterable, "
"key=key)[:n]``."

msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger "
"values, it is more efficient to use the :func:`sorted` function.  Also, when "
"``n==1``, it is more efficient to use the built-in :func:`min` and :func:"
"`max` functions.  If repeated usage of these functions is required, consider "
"turning the iterable into an actual heap."
msgstr ""
"Дві останні функції працюють найкраще для менших значень *n*. Для більших "
"значень ефективніше використовувати функцію :func:`sorted`. Крім того, коли "
"``n==1``, ефективніше використовувати вбудовані функції :func:`min` і :func:"
"`max`. Якщо потрібне повторне використання цих функцій, подумайте про те, "
"щоб перетворити iterable на справжню купу."

msgid "Basic Examples"
msgstr "Основні приклади"

msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by "
"pushing all values onto a heap and then popping off the smallest values one "
"at a time::"
msgstr ""
"`heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ може бути реалізовано "
"шляхом переміщення всіх значень у купу, а потім вилучення найменших значень "
"по одному:"

msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"Це схоже на ``sorted(iterable)``, але на відміну від :func:`sorted`, ця "
"реалізація не є стабільною."

msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values "
"(such as task priorities) alongside the main record being tracked::"
msgstr ""
"Елементи купи можуть бути кортежами. Це корисно для призначення порівняльних "
"значень (наприклад, пріоритетів завдань) поряд із основним записом, який "
"відстежується:"

msgid "Priority Queue Implementation Notes"
msgstr "Примітки щодо реалізації пріоритетної черги"

msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common "
"use for a heap, and it presents several implementation challenges:"
msgstr ""
"`Пріоритетна черга <https://en.wikipedia.org/wiki/Priority_queue>`_ зазвичай "
"використовується для купи, і це створює кілька проблем реалізації:"

msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr ""
"Стабільність сортування: як повернути два завдання з однаковими пріоритетами "
"в тому порядку, в якому вони були спочатку додані?"

msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr ""
"Порівняння кортежу розривається для пар (пріоритет, завдання), якщо "
"пріоритети рівні, а завдання не мають порядку порівняння за замовчуванням."

msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr ""
"Якщо пріоритет завдання змінюється, як перемістити його на нове місце в купі?"

msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr ""
"Або якщо завдання, що очікує на виконання, потрібно видалити, як його знайти "
"та видалити з черги?"

msgid ""
"A solution to the first two challenges is to store entries as 3-element list "
"including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the "
"same, the tuple comparison will never attempt to directly compare two tasks."
msgstr ""
"Рішенням перших двох проблем є збереження записів у вигляді списку з 3 "
"елементів, включаючи пріоритет, кількість записів і завдання. Підрахунок "
"записів служить вирішальним, щоб два завдання з однаковим пріоритетом "
"поверталися в порядку їх додавання. А оскільки немає двох однакових "
"підрахунків записів, порівняння кортежів ніколи не намагатиметься "
"безпосередньо порівняти два завдання."

msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr ""
"Іншим вирішенням проблеми непорівнюваних завдань є створення класу-оболонки, "
"який ігнорує елемент завдання та порівнює лише поле пріоритету:"

msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done "
"with a dictionary pointing to an entry in the queue."
msgstr ""
"Проблеми, що залишилися, пов’язані з пошуком незавершеного завдання та "
"внесенням змін до його пріоритету або його повним видаленням. Знайти "
"завдання можна за допомогою словника, який вказує на запис у черзі."

msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the entry as removed and add a new entry with the revised priority::"
msgstr ""
"Видалити запис або змінити його пріоритет складніше, оскільки це порушить "
"інваріанти структури купи. Отже, можливим рішенням є позначення запису як "
"видаленого та додавання нового запису зі зміненим пріоритетом::"

msgid "Theory"
msgstr "Теорія"

msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for "
"all *k*, counting elements from 0.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that ``a[0]`` is always its smallest element."
msgstr ""
"Купи — це масиви, для яких ``a[k] <= a[2*k+1]`` і ``a[k] <= a[2*k+2]`` для "
"всіх *k*, підрахунок елементів від 0. Для порівняння, неіснуючі елементи "
"вважаються нескінченними. Цікавою властивістю купи є те, що ``a[0]`` завжди "
"є її найменшим елементом."

msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr ""
"Дивний інваріант вище призначений для ефективного представлення пам’яті для "
"турніру. Цифри нижче *k*, а не ``a[k]``::"

msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr ""
"У наведеному вище дереві кожна комірка *k* є вершиною ``2*k+1`` і ``2*k+2``. "
"У звичайному бінарному турнірі, який ми бачимо у спорті, кожна клітина є "
"переможцем над двома клітинками, які вона очолює, і ми можемо відстежити "
"переможця вниз по дереву, щоб побачити всіх суперників, які він/вона мали. "
"Однак у багатьох комп’ютерних програмах таких турнірів нам не потрібно "
"відстежувати історію переможця. Щоб підвищити ефективність пам’яті, коли "
"переможець підвищується, ми намагаємося замінити його чимось іншим на "
"нижчому рівні, і правило стає таким, що клітинка та дві верхні клітинки "
"містять три різні елементи, але верхня клітинка \"перемагає\". над двома "
"верхніми клітинами."

msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an O(n log n) sort."
msgstr ""
"Якщо цей інваріант купи захищений весь час, індекс 0 явно є загальним "
"переможцем. Найпростіший алгоритмічний спосіб видалити його та знайти "
"\"наступного\" переможця — перемістити якийсь програш (скажімо, комірку 30 "
"на діаграмі вище) у позицію 0, а потім перемістити цей новий 0 униз по "
"дереву, обмінюючи значеннями, доки інваріант не стане відновлюється. Це явно "
"логарифмічно від загальної кількості елементів у дереві. Перебираючи всі "
"елементи, ви отримуєте O(n log n) сортування."

msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not "
"\"better\" than the last 0'th element you extracted.  This is especially "
"useful in simulation contexts, where the tree holds all incoming events, and "
"the \"win\" condition means the smallest scheduled time.  When an event "
"schedules other events for execution, they are scheduled into the future, so "
"they can easily go into the heap.  So, a heap is a good structure for "
"implementing schedulers (this is what I used for my MIDI sequencer :-)."
msgstr ""
"Приємною особливістю цього сортування є те, що ви можете ефективно вставляти "
"нові елементи під час сортування, за умови, що вставлені елементи не "
"\"кращі\", ніж останній нульовий елемент, який ви витягли. Це особливо "
"корисно в контекстах симуляції, де дерево містить усі вхідні події, а умова "
"\"виграш\" означає найменший запланований час. Коли подія планує інші події "
"для виконання, вони плануються в майбутньому, тому їх можна легко "
"перемістити в купу. Отже, купа є хорошою структурою для реалізації "
"планувальників (це те, що я використовував для свого MIDI-секвенсора :-)."

msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr ""
"Різноманітні структури для реалізації планувальників були ретельно вивчені, "
"і для цього добре підійдуть купи, оскільки вони досить швидкі, швидкість "
"майже постійна, а найгірший випадок не сильно відрізняється від середнього "
"випадку. Однак існують інші представлення, які в цілому є більш ефективними, "
"але найгірші випадки можуть бути жахливими."

msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for "
"input fuzzily ordered."
msgstr ""
"Купи також дуже корисні для сортування великих дисків. Напевно, ви всі "
"знаєте, що велике сортування передбачає створення \"запусків\" (це "
"попередньо відсортовані послідовності, розмір яких зазвичай пов’язаний з "
"обсягом пам’яті процесора), після чого слід об’єднання проходів для цих "
"запусків, яке часто є дуже спритним. організовано [#]_. Дуже важливо, щоб "
"початкове сортування створювало якнайдовші серії. Хорошим способом досягти "
"цього є турніри. Якщо, використовуючи всю пам’ять, доступну для проведення "
"турніру, ви замінюєте та просочуєте елементи, які випадково відповідають "
"поточному циклу, ви створите цикли, які вдвічі перевищують розмір пам’яті "
"для випадкового введення, і набагато краще для нечітко впорядкованого "
"введення."

msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not "
"fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same rate "
"the first heap is melting.  When the first heap completely vanishes, you "
"switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"Більше того, якщо ви виведете 0-й елемент на диску та отримаєте вхідні дані, "
"які можуть не відповідати поточному турніру (оскільки значення \"перемагає\" "
"над останнім вихідним значенням), воно не може поміститися у купу, тому "
"розмір купа зменшується. Звільнену пам’ять можна негайно використати "
"повторно для поступового створення другої купи, яка росте з тією ж "
"швидкістю, що й перша купа тане. Коли перша купа повністю зникає, ви "
"змінюєте купи та починаєте новий запуск. Розумно і досить ефективно!"

msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr ""
"Одним словом, купи - це корисні структури пам'яті, які слід знати. Я "
"використовую їх у кількох програмах, і я вважаю, що добре тримати модуль "
"\"купи\". :-)"

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying "
"than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr ""
"Сучасні алгоритми балансування дисків радше дратують, ніж розумні, і це є "
"наслідком можливостей пошуку дисків. На пристроях, які не можуть шукати, як-"
"от великі стрічкові накопичувачі, історія була зовсім іншою, і потрібно було "
"бути дуже кмітливим, щоб переконатися (заздалегідь), що кожен рух стрічки "
"буде максимально ефективним (тобто найкраще братиме участь у \" "
"просувається\" злиття). Деякі стрічки навіть могли читати назад, і це також "
"використовувалося, щоб уникнути перемотування часу. Повірте, дивитися "
"справді гарні стрічки було дуже вражаюче! З усіх часів сортування завжди "
"було Великим Мистецтвом! :-)"
