# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Developing with asyncio"
msgstr "Розробка з asyncio"

msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr ""
"Асинхронне програмування відрізняється від класичного \"послідовного\" "
"програмування."

msgid ""
"This page lists common mistakes and traps and explains how to avoid them."
msgstr ""
"На цій сторінці наведено типові помилки та пастки та пояснено, як їх "
"уникнути."

msgid "Debug Mode"
msgstr "Режим налагодження"

msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr ""
"За замовчуванням asyncio працює у робочому режимі. Щоб полегшити розробку, "
"asyncio має *режим налагодження*."

msgid "There are several ways to enable asyncio debug mode:"
msgstr "Є кілька способів увімкнути асинхронний режим налагодження:"

msgid "Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr "Встановлення змінної середовища :envvar:`PYTHONASYNCIODEBUG` на ``1``."

msgid "Using the :ref:`Python Development Mode <devmode>`."
msgstr "Використання :ref:`режиму розробки Python <devmode>`."

msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr "Передача ``debug=True`` до :func:`asyncio.run`."

msgid "Calling :meth:`loop.set_debug`."
msgstr "Виклик :meth:`loop.set_debug`."

msgid "In addition to enabling the debug mode, consider also:"
msgstr "Окрім увімкнення режиму налагодження, враховуйте також:"

msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to :py:"
"data:`logging.DEBUG`, for example the following snippet of code can be run "
"at startup of the application::"
msgstr ""
"встановлення рівня журналу :ref:`asyncio logger <asyncio-logger>` на :py:"
"data:`logging.DEBUG`, наприклад, наступний фрагмент коду можна запустити під "
"час запуску програми::"

msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default`` "
"command line option."
msgstr ""
"налаштування модуля :mod:`warnings` для відображення попереджень :exc:"
"`ResourceWarning`. Один із способів зробити це — скористатися параметром "
"командного рядка :option:`-W` ``default``."

msgid "When the debug mode is enabled:"
msgstr "Коли ввімкнено режим налагодження:"

msgid ""
"asyncio checks for :ref:`coroutines that were not awaited <asyncio-coroutine-"
"not-scheduled>` and logs them; this mitigates the \"forgotten await\" "
"pitfall."
msgstr ""
"asyncio перевіряє :ref:`співпрограми, які не були очікувані <asyncio-"
"coroutine-not-scheduled>`, і записує їх у журнал; це пом'якшує помилку "
"\"забутого очікування\"."

msgid ""
"Many non-threadsafe asyncio APIs (such as :meth:`loop.call_soon` and :meth:"
"`loop.call_at` methods) raise an exception if they are called from a wrong "
"thread."
msgstr ""
"Багато небезпечних для потоків асинхронних API (таких як методи :meth:`loop."
"call_soon` і :meth:`loop.call_at`) викликають виняток, якщо вони "
"викликаються з неправильного потоку."

msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr ""
"Час виконання селектора введення-виведення реєструється, якщо виконання "
"операції введення-виведення займає надто багато часу."

msgid ""
"Callbacks taking longer than 100ms are logged.  The :attr:`loop."
"slow_callback_duration` attribute can be used to set the minimum execution "
"duration in seconds that is considered \"slow\"."
msgstr ""

msgid "Concurrency and Multithreading"
msgstr "Паралельність і багатопотоковість"

msgid ""
"An event loop runs in a thread (typically the main thread) and executes all "
"callbacks and Tasks in its thread.  While a Task is running in the event "
"loop, no other Tasks can run in the same thread.  When a Task executes an "
"``await`` expression, the running Task gets suspended, and the event loop "
"executes the next Task."
msgstr ""
"Цикл подій виконується в потоці (зазвичай головному) і виконує всі зворотні "
"виклики та завдання у своєму потоці. Поки Завдання виконується в циклі "
"подій, жодні інші Завдання не можуть виконуватися в тому самому потоці. Коли "
"Завдання виконує вираз ``очікування``, запущене Завдання призупиняється, а "
"цикл подій виконує наступне Завдання."

msgid ""
"To schedule a :term:`callback` from another OS thread, the :meth:`loop."
"call_soon_threadsafe` method should be used. Example::"
msgstr ""
"Щоб запланувати :term:`callback` з іншого потоку ОС, слід використовувати "
"метод :meth:`loop.call_soon_threadsafe`. Приклад::"

msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task or "
"a callback.  If there's a need for such code to call a low-level asyncio "
"API, the :meth:`loop.call_soon_threadsafe` method should be used, e.g.::"
msgstr ""
"Майже всі асинхронні об’єкти не є потокобезпечними, що зазвичай не є "
"проблемою, якщо немає коду, який працює з ними поза Завданням або зворотним "
"викликом. Якщо існує потреба в такому коді для виклику низькорівневого "
"асинхронного API, слід використовувати метод :meth:`loop."
"call_soon_threadsafe`, наприклад::"

msgid ""
"To schedule a coroutine object from a different OS thread, the :func:"
"`run_coroutine_threadsafe` function should be used. It returns a :class:"
"`concurrent.futures.Future` to access the result::"
msgstr ""
"Щоб запланувати об’єкт співпрограми з іншого потоку ОС, слід використати "
"функцію :func:`run_coroutine_threadsafe`. Він повертає :class:`concurrent."
"futures.Future` для доступу до результату::"

msgid ""
"To handle signals and to execute subprocesses, the event loop must be run in "
"the main thread."
msgstr ""
"Для обробки сигналів і виконання підпроцесів цикл подій повинен запускатися "
"в основному потоці."

msgid ""
"The :meth:`loop.run_in_executor` method can be used with a :class:"
"`concurrent.futures.ThreadPoolExecutor` to execute blocking code in a "
"different OS thread without blocking the OS thread that the event loop runs "
"in."
msgstr ""
"Метод :meth:`loop.run_in_executor` можна використовувати з :class:"
"`concurrent.futures.ThreadPoolExecutor` для виконання коду блокування в "
"іншому потоці ОС, не блокуючи потік ОС, у якому виконується цикл подій."

msgid ""
"There is currently no way to schedule coroutines or callbacks directly from "
"a different process (such as one started with :mod:`multiprocessing`). The :"
"ref:`Event Loop Methods <asyncio-event-loop>` section lists APIs that can "
"read from pipes and watch file descriptors without blocking the event loop. "
"In addition, asyncio's :ref:`Subprocess <asyncio-subprocess>` APIs provide a "
"way to start a process and communicate with it from the event loop. Lastly, "
"the aforementioned :meth:`loop.run_in_executor` method can also be used with "
"a :class:`concurrent.futures.ProcessPoolExecutor` to execute code in a "
"different process."
msgstr ""
"Наразі немає способу запланувати співпрограми або зворотні виклики "
"безпосередньо з іншого процесу (наприклад, розпочатого з :mod:"
"`multiprocessing`). У розділі :ref:`Методи циклу подій <asyncio-event-loop>` "
"перераховано API, які можуть читати з каналів і переглядати дескриптори "
"файлів, не блокуючи цикл подій. Крім того, API :ref:`Subprocess <asyncio-"
"subprocess>` asyncio надають можливість запускати процес і спілкуватися з "
"ним із циклу подій. Нарешті, вищезгаданий метод :meth:`loop.run_in_executor` "
"також можна використовувати з :class:`concurrent.futures."
"ProcessPoolExecutor` для виконання коду в іншому процесі."

msgid "Running Blocking Code"
msgstr "Запуск коду блокування"

msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if a "
"function performs a CPU-intensive calculation for 1 second, all concurrent "
"asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""
"Код блокування (прив’язаний до процесора) не слід викликати безпосередньо. "
"Наприклад, якщо функція виконує інтенсивне обчислення ЦП протягом 1 секунди, "
"усі одночасні асинхронні завдання та операції введення-виведення будуть "
"відкладені на 1 секунду."

msgid ""
"An executor can be used to run a task in a different thread or even in a "
"different process to avoid blocking the OS thread with the event loop.  See "
"the :meth:`loop.run_in_executor` method for more details."
msgstr ""
"Виконавець можна використовувати для запуску завдання в іншому потоці або "
"навіть в іншому процесі, щоб уникнути блокування потоку ОС за допомогою "
"циклу подій. Додаткову інформацію див. у методі :meth:`loop.run_in_executor`."

msgid "Logging"
msgstr "Лісозаготівля"

msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via the "
"``\"asyncio\"`` logger."
msgstr ""
"asyncio використовує модуль :mod:`logging`, і все журналювання виконується "
"через ``\"asyncio\"`` реєстратор."

msgid ""
"The default log level is :py:data:`logging.INFO`, which can be easily "
"adjusted::"
msgstr ""
"Типовим рівнем журналу є :py:data:`logging.INFO`, який можна легко "
"налаштувати:"

msgid "Detect never-awaited coroutines"
msgstr "Виявляти ніколи не очікувані співпрограми"

msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with :meth:"
"`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""
"Коли функція співпрограми викликається, але не очікується (наприклад, "
"``coro()`` замість ``await coro()``) або співпрограма не запланована за "
"допомогою :meth:`asyncio.create_task`, asyncio видасть :exc:"
"`RuntimeWarning`::"

msgid "Output::"
msgstr "Вихід::"

msgid "Output in debug mode::"
msgstr "Вивід у режимі налагодження::"

msgid ""
"The usual fix is to either await the coroutine or call the :meth:`asyncio."
"create_task` function::"
msgstr ""
"Звичайним виправленням є або очікування співпрограми, або виклик функції :"
"meth:`asyncio.create_task`::"

msgid "Detect never-retrieved exceptions"
msgstr "Виявлення ніколи не отриманих винятків"

msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is never "
"awaited on, the exception would never be propagated to the user code.  In "
"this case, asyncio would emit a log message when the Future object is "
"garbage collected."
msgstr ""
"Якщо викликається :meth:`Future.set_exception`, але об’єкт Future ніколи не "
"очікується, виняток ніколи не поширюватиметься на код користувача. У цьому "
"випадку asyncio створюватиме повідомлення журналу, коли об’єкт Future "
"збиратиме сміття."

msgid "Example of an unhandled exception::"
msgstr "Приклад необробленого винятку::"

msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback where "
"the task was created::"
msgstr ""
":ref:`Увімкніть режим налагодження <asyncio-debug-mode>`, щоб отримати "
"відстеження місця створення завдання:"
