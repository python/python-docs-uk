# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:09+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`math` --- Mathematical functions"
msgstr ":mod:`math` --- Математичні функції"

msgid ""
"This module provides access to the mathematical functions defined by the C "
"standard."
msgstr ""
"Цей модуль забезпечує доступ до математичних функцій, визначених стандартом "
"C."

msgid ""
"These functions cannot be used with complex numbers; use the functions of "
"the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex "
"numbers and those which don't is made since most users do not want to learn "
"quite as much mathematics as required to understand complex numbers.  "
"Receiving an exception instead of a complex result allows earlier detection "
"of the unexpected complex number used as a parameter, so that the programmer "
"can determine how and why it was generated in the first place."
msgstr ""
"Ці функції не можна використовувати з комплексними числами; використовуйте "
"однойменні функції з модуля :mod:`cmath`, якщо вам потрібна підтримка "
"комплексних чисел. Розрізнення між функціями, які підтримують комплексні "
"числа, і тими, які не підтримують, зроблено, оскільки більшість користувачів "
"не хочуть вивчати стільки математики, скільки потрібно для розуміння "
"комплексних чисел. Отримання винятку замість комплексного результату "
"дозволяє раніше виявити неочікуване комплексне число, яке використовується "
"як параметр, щоб програміст міг визначити, як і чому воно взагалі було "
"згенероване."

msgid ""
"The following functions are provided by this module.  Except when explicitly "
"noted otherwise, all return values are floats."
msgstr ""
"Цей модуль забезпечує такі функції. За винятком випадків, коли явно "
"зазначено інше, усі повернуті значення є числами з плаваючою точкою."

msgid "Number-theoretic and representation functions"
msgstr "Теоретико-числові функції та функції представлення"

msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to :meth:`x.__ceil__ <object."
"__ceil__>`, which should return an :class:`~numbers.Integral` value."
msgstr ""
"Повертає максимальне значення *x*, найменше ціле число, більше або рівне "
"*x*. Якщо *x* не є числом з плаваючою точкою, делегує :meth:`x.__ceil__ "
"<object.__ceil__>`, який має повернути значення :class:`~numbers.Integral`."

msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and without order."
msgstr ""
"Повертає кількість способів вибору *k* елементів з *n* елементів без "
"повторення та без порядку."

msgid ""
"Evaluates to ``n! / (k! * (n - k)!)`` when ``k <= n`` and evaluates to zero "
"when ``k > n``."
msgstr ""
"Оцінюється як ``n! / (k! * (n - k)!)`` коли ``k <= n`` and evaluates to zero "
"when ``k > n``."

msgid ""
"Also called the binomial coefficient because it is equivalent to the "
"coefficient of k-th term in polynomial expansion of the expression ``(1 + x) "
"** n``."
msgstr ""
"Також називається біноміальним коефіцієнтом, тому що він еквівалентний "
"коефіцієнту k-го члена в поліноміальному розкладі виразу ``(1 + x) ** n``."

msgid ""
"Raises :exc:`TypeError` if either of the arguments are not integers. Raises :"
"exc:`ValueError` if either of the arguments are negative."
msgstr ""
"Викликає :exc:`TypeError`, якщо один із аргументів не є цілим числом. "
"Викликає :exc:`ValueError`, якщо будь-який з аргументів негативний."

msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of "
"*y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"Повертає число з плаваючою точкою з величиною (абсолютним значенням) *x*, "
"але зі знаком *y*. На платформах, які підтримують нулі зі знаком, "
"``copysign(1.0, -0.0)`` повертає *-1.0*."

msgid "Return the absolute value of *x*."
msgstr "Повертає абсолютне значення *x*."

msgid ""
"Return *x* factorial as an integer.  Raises :exc:`ValueError` if *x* is not "
"integral or is negative."
msgstr ""

msgid "Accepting floats with integral values (like ``5.0``) is deprecated."
msgstr ""
"Прийняття числа з плаваючою точкою з цілими значеннями (наприклад, ``5.0``) "
"застаріло."

msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*.  If "
"*x* is not a float, delegates to :meth:`x.__floor__ <object.__floor__>`, "
"which should return an :class:`~numbers.Integral` value."
msgstr ""
"Повертає нижню частину *x*, найбільше ціле число, менше або дорівнює *x*. "
"Якщо *x* не є числом з плаваючою точкою, делегує :meth:`x.__floor__ <object."
"__floor__>`, який має повернути значення :class:`~numbers.Integral`."

msgid ""
"Return ``fmod(x, y)``, as defined by the platform C library. Note that the "
"Python expression ``x % y`` may not return the same result.  The intent of "
"the C standard is that ``fmod(x, y)`` be exactly (mathematically; to "
"infinite precision) equal to ``x - n*y`` for some integer *n* such that the "
"result has the same sign as *x* and magnitude less than ``abs(y)``.  "
"Python's ``x % y`` returns a result with the sign of *y* instead, and may "
"not be exactly computable for float arguments. For example, ``fmod(-1e-100, "
"1e100)`` is ``-1e-100``, but the result of Python's ``-1e-100 % 1e100`` is "
"``1e100-1e-100``, which cannot be represented exactly as a float, and rounds "
"to the surprising ``1e100``.  For this reason, function :func:`fmod` is "
"generally preferred when working with floats, while Python's ``x % y`` is "
"preferred when working with integers."
msgstr ""
"Повертає ``fmod(x, y)``, як визначено бібліотекою платформи C. Зверніть "
"увагу, що вираз Python ``x % y`` може не повернути той самий результат. "
"Метою стандарту C є те, що ``fmod(x, y)`` точно (математично; з нескінченною "
"точністю) дорівнює ``x - n*y`` для деякого цілого числа *n*, щоб результат "
"мав той самий знак, що й *x*, і величина менша за ``abs(y)``. ``x % y`` "
"Python замість цього повертає результат зі знаком *y* і може бути неточно "
"обчислюваним для аргументів з плаваючою точкою. Наприклад, ``fmod(-1e-100, "
"1e100)`` є ``-1e-100``, але результатом ``-1e-100 % 1e100`` Python є "
"``1e100-1e-100``, який не може бути точно представлений як число з плаваючою "
"точкою, і округлюється до несподіваного ``1e100``. З цієї причини функція :"
"func:`fmod` зазвичай є кращою під час роботи з числами з плаваючою точкою, "
"тоді як ``x % y`` Python є кращою під час роботи з цілими числами."

msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a "
"float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* is "
"zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is used "
"to \"pick apart\" the internal representation of a float in a portable way."
msgstr ""
"Повертає мантису та експонент *x* як пару ``(m, e)``. *m* є числом з "
"плаваючою точкою, а *e* є цілим числом таким чином, що ``x == m * 2**e`` "
"точно. Якщо *x* дорівнює нулю, повертає ``(0,0, 0)``, інакше ``0,5 <= abs(m) "
"< 1``. Це використовується, щоб \"розібрати\" внутрішнє представлення float "
"переносним способом."

msgid ""
"Return an accurate floating point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums::"
msgstr ""
"Повертає точну суму значень із плаваючою комою в ітеруючому. Уникає втрати "
"точності шляхом відстеження кількох проміжних часткових сум:"

msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and the "
"typical case where the rounding mode is half-even.  On some non-Windows "
"builds, the underlying C library uses extended precision addition and may "
"occasionally double-round an intermediate sum causing it to be off in its "
"least significant bit."
msgstr ""
"Точність алгоритму залежить від арифметичних гарантій IEEE-754 і типового "
"випадку, коли режим округлення є напівпарним. У деяких збірках, відмінних "
"від Windows, базова бібліотека C використовує розширену точність додавання "
"та іноді може подвоїти округлення проміжної суми, спричиняючи її вимкнення у "
"своєму молодшому розряді."

msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating point summation <https://code."
"activestate.com/recipes/393090/>`_\\."
msgstr ""
"Для подальшого обговорення та двох альтернативних підходів див. `Рецепти "
"ASPN кулінарної книги для точного підсумовування з плаваючою комою <https://"
"code.activestate.com/recipes/393090/>`_\\."

msgid ""
"Return the greatest common divisor of the specified integer arguments. If "
"any of the arguments is nonzero, then the returned value is the largest "
"positive integer that is a divisor of all arguments.  If all arguments are "
"zero, then the returned value is ``0``.  ``gcd()`` without arguments returns "
"``0``."
msgstr ""
"Повертає найбільший спільний дільник указаних цілих аргументів. Якщо будь-"
"який з аргументів не дорівнює нулю, то повернуте значення є найбільшим "
"натуральним числом, яке є дільником усіх аргументів. Якщо всі аргументи "
"дорівнюють нулю, то повертається значення ``0``. ``gcd()`` без аргументів "
"повертає ``0``."

msgid ""
"Added support for an arbitrary number of arguments. Formerly, only two "
"arguments were supported."
msgstr ""
"Додано підтримку довільної кількості аргументів. Раніше підтримувалися лише "
"два аргументи."

msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо значення *a* і *b* близькі одне до одного, і "
"``False`` в іншому випадку."

msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances."
msgstr ""
"Чи вважаються два значення близькими чи ні, визначається відповідно до "
"заданих абсолютних і відносних допусків."

msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be greater than zero."
msgstr ""
"*rel_tol* — це відносний допуск — це максимально допустима різниця між *a* і "
"*b* відносно більшого абсолютного значення *a* або *b*. Наприклад, щоб "
"встановити допуск 5%, передайте ``rel_tol=0,05``. Допуск за замовчуванням — "
"``1e-09``, який гарантує, що два значення збігаються в межах приблизно 9 "
"десяткових цифр. *rel_tol* має бути більше нуля."

msgid ""
"*abs_tol* is the minimum absolute tolerance -- useful for comparisons near "
"zero. *abs_tol* must be at least zero."
msgstr ""
"*abs_tol* — це мінімальний абсолютний допуск — корисний для порівнянь біля "
"нуля. *abs_tol* має бути не менше нуля."

msgid ""
"If no errors occur, the result will be: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Якщо помилок не буде, результатом буде: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."

msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"Спеціальні значення IEEE 754 ``NaN``, ``inf`` і ``-inf`` оброблятимуться "
"відповідно до правил IEEE. Зокрема, ``NaN`` не вважається близьким до будь-"
"якого іншого значення, включаючи ``NaN``. ``inf`` і ``-inf`` вважаються лише "
"близькими до самих себе."

msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- Функція для перевірки приблизної рівності"

msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"Повертає ``True``, якщо *x* не є ні нескінченністю, ні NaN, і ``False`` в "
"іншому випадку. (Зверніть увагу, що ``0.0`` *вважається* кінцевим.)"

msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr ""
"Повертає ``True``, якщо *x* є додатною або від’ємною нескінченністю, і "
"``False`` в іншому випадку."

msgid ""
"Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо *x* є NaN (а не число), і ``False`` в іншому випадку."

msgid ""
"Return the integer square root of the nonnegative integer *n*. This is the "
"floor of the exact square root of *n*, or equivalently the greatest integer "
"*a* such that *a*\\ ² |nbsp| ≤ |nbsp| *n*."
msgstr ""
"Повертає цілий квадратний корінь із цілого невід’ємного числа *n*. Це нижня "
"частина точного квадратного кореня з *n* або, що еквівалентно, найбільше "
"ціле число *a* таке, що *a*\\ ² |nbsp| ≤ |nbsp| *n*."

msgid ""
"For some applications, it may be more convenient to have the least integer "
"*a* such that *n* |nbsp| ≤ |nbsp| *a*\\ ², or in other words the ceiling of "
"the exact square root of *n*. For positive *n*, this can be computed using "
"``a = 1 + isqrt(n - 1)``."
msgstr ""
"Для деяких програм може бути зручніше мати найменше ціле *a* таке, що *n* |"
"nbsp| ≤ |nbsp| *a*\\ ², або іншими словами, стеля точного квадратного кореня "
"з *n*. Для позитивного *n* це можна обчислити за допомогою ``a = 1 + isqrt(n "
"- 1)``."

msgid ""
"Return the least common multiple of the specified integer arguments. If all "
"arguments are nonzero, then the returned value is the smallest positive "
"integer that is a multiple of all arguments.  If any of the arguments is "
"zero, then the returned value is ``0``.  ``lcm()`` without arguments returns "
"``1``."
msgstr ""
"Повертає найменше спільне кратне вказаних цілих аргументів. Якщо всі "
"аргументи відмінні від нуля, тоді повертається найменше натуральне число, "
"кратне всім аргументам. Якщо будь-який з аргументів дорівнює нулю, то "
"повертається значення ``0``. ``lcm()`` без аргументів повертає ``1``."

msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function :func:"
"`frexp`."
msgstr "Повернути ``x * (2**i)``. По суті, це зворотна функція :func:`frexp`."

msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the sign "
"of *x* and are floats."
msgstr ""
"Повертає дробову та цілу частини *x*. Обидва результати мають знак *x* і є "
"числами з плаваючою точкою."

msgid "Return the next floating-point value after *x* towards *y*."
msgstr "Повертає наступне значення з плаваючою комою після *x* до *y*."

msgid "If *x* is equal to *y*, return *y*."
msgstr "Якщо *x* дорівнює *y*, поверніть *y*."

msgid "Examples:"
msgstr "приклади:"

msgid "``math.nextafter(x, math.inf)`` goes up: towards positive infinity."
msgstr ""
"``math.nextafter(x, math.inf)`` йде вгору: до позитивної нескінченності."

msgid "``math.nextafter(x, -math.inf)`` goes down: towards minus infinity."
msgstr "``math.nextafter(x, -math.inf)`` йде вниз: до мінус нескінченності."

msgid "``math.nextafter(x, 0.0)`` goes towards zero."
msgstr "``math.nextafter(x, 0.0)`` рухається до нуля."

msgid "``math.nextafter(x, math.copysign(math.inf, x))`` goes away from zero."
msgstr "``math.nextafter(x, math.copysign(math.inf, x))`` відходить від нуля."

msgid "See also :func:`math.ulp`."
msgstr "Дивіться також :func:`math.ulp`."

msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and with order."
msgstr ""
"Повернути кількість способів вибору *k* елементів з *n* елементів без "
"повторення та з порядком."

msgid ""
"Evaluates to ``n! / (n - k)!`` when ``k <= n`` and evaluates to zero when "
"``k > n``."
msgstr ""
"Оцінюється як ``n! / (n - k)!`` коли ``k <= n`` and evaluates to zero when "
"``k > n``."

msgid ""
"If *k* is not specified or is None, then *k* defaults to *n* and the "
"function returns ``n!``."
msgstr ""
"Якщо *k* не вказано або має значення None, тоді *k* за замовчуванням має "
"*n*, а функція повертає ``n!``."

msgid ""
"Calculate the product of all the elements in the input *iterable*. The "
"default *start* value for the product is ``1``."
msgstr ""
"Обчислити добуток усіх елементів у вхідному *iterable*. Типовим *початковим* "
"значенням для продукту є \"1\"."

msgid ""
"When the iterable is empty, return the start value.  This function is "
"intended specifically for use with numeric values and may reject non-numeric "
"types."
msgstr ""
"Коли iterable порожній, поверніть початкове значення. Ця функція призначена "
"спеціально для використання з числовими значеннями та може відхиляти "
"нечислові типи."

msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For finite "
"*x* and finite nonzero *y*, this is the difference ``x - n*y``, where ``n`` "
"is the closest integer to the exact value of the quotient ``x / y``.  If "
"``x / y`` is exactly halfway between two consecutive integers, the nearest "
"*even* integer is used for ``n``.  The remainder ``r = remainder(x, y)`` "
"thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"Повертає залишок *x* у стилі IEEE 754 відносно *y*. Для кінцевого *x* і "
"кінцевого ненульового *y* це різниця ``x - n*y``, де ``n`` є найближчим "
"цілим числом до точного значення частки ``x / y`` . Якщо ``x / y`` "
"знаходиться точно посередині між двома послідовними цілими числами, для "
"``n`` використовується найближче *парне* ціле число. Таким чином, залишок "
"``r = залишок(x, y)`` завжди задовольняє ``abs(r) <= 0,5 * abs(y)``."

msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` is "
"*x* for any finite *x*, and ``remainder(x, 0)`` and ``remainder(math.inf, "
"x)`` raise :exc:`ValueError` for any non-NaN *x*. If the result of the "
"remainder operation is zero, that zero will have the same sign as *x*."
msgstr ""
"Спеціальні випадки відповідають стандарту IEEE 754: зокрема, ``remainder(x, "
"math.inf)`` є *x* для будь-якого кінцевого *x*, а ``remainder(x, 0)`` і "
"``remainder(math.inf). inf, x)`` підняти :exc:`ValueError` для будь-якого не-"
"NaN *x*. Якщо результатом операції залишку є нуль, цей нуль матиме той самий "
"знак, що й *x*."

msgid ""
"On platforms using IEEE 754 binary floating-point, the result of this "
"operation is always exactly representable: no rounding error is introduced."
msgstr ""
"На платформах, які використовують двійкові числа з плаваючою точкою IEEE "
"754, результат цієї операції завжди можна точно представити: помилка "
"округлення не виникає."

msgid ""
"Return *x* with the fractional part removed, leaving the integer part.  This "
"rounds toward 0: ``trunc()`` is equivalent to :func:`floor` for positive "
"*x*, and equivalent to :func:`ceil` for negative *x*. If *x* is not a float, "
"delegates to :meth:`x.__trunc__ <object.__trunc__>`, which should return an :"
"class:`~numbers.Integral` value."
msgstr ""
"Поверніть *x* із видаленням дробової частини, залишаючи цілу частину. Це "
"округляє до 0: ``trunc()`` еквівалентно :func:`floor` для додатного *x* та "
"еквівалентно :func:`ceil` для від’ємного *x*. Якщо *x* не є числом з "
"плаваючою точкою, делегує :meth:`x.__trunc__ <object.__trunc__>`, який має "
"повернути значення :class:`~numbers.Integral`."

msgid "Return the value of the least significant bit of the float *x*:"
msgstr "Повертає значення молодшого біта числа з плаваючою точкою *x*:"

msgid "If *x* is a NaN (not a number), return *x*."
msgstr "Якщо *x* є NaN (а не числом), поверніть *x*."

msgid "If *x* is negative, return ``ulp(-x)``."
msgstr "Якщо *x* від’ємне, поверніть ``ulp(-x)``."

msgid "If *x* is a positive infinity, return *x*."
msgstr "Якщо *x* є позитивною нескінченністю, поверніть *x*."

msgid ""
"If *x* is equal to zero, return the smallest positive *denormalized* "
"representable float (smaller than the minimum positive *normalized* float, :"
"data:`sys.float_info.min <sys.float_info>`)."
msgstr ""
"Якщо *x* дорівнює нулю, поверніть найменше додатне *деноралізоване* число з "
"плаваючою точкою (менше ніж мінімальне позитивне *нормалізоване* число з "
"плаваючою точкою, :data:`sys.float_info.min <sys.float_info>`)."

msgid ""
"If *x* is equal to the largest positive representable float, return the "
"value of the least significant bit of *x*, such that the first float smaller "
"than *x* is ``x - ulp(x)``."
msgstr ""
"Якщо *x* дорівнює найбільшому додатному репрезентативному float, поверніть "
"значення молодшого значущого біта *x*, щоб перше число з плаваючою точкою, "
"менше за *x*, було ``x - ulp(x)``."

msgid ""
"Otherwise (*x* is a positive finite number), return the value of the least "
"significant bit of *x*, such that the first float bigger than *x* is ``x + "
"ulp(x)``."
msgstr ""
"В іншому випадку (*x* — додатне скінченне число) поверніть значення "
"молодшого біта *x*, щоб перше число з плаваючою речовиною, більше за *x*, "
"було ``x + ulp(x)``."

msgid "ULP stands for \"Unit in the Last Place\"."
msgstr "ULP розшифровується як \"Unit in the Last Place\"."

msgid ""
"See also :func:`math.nextafter` and :data:`sys.float_info.epsilon <sys."
"float_info>`."
msgstr ""
"Дивіться також :func:`math.nextafter` і :data:`sys.float_info.epsilon <sys."
"float_info>`."

msgid ""
"Note that :func:`frexp` and :func:`modf` have a different call/return "
"pattern than their C equivalents: they take a single argument and return a "
"pair of values, rather than returning their second return value through an "
"'output parameter' (there is no such thing in Python)."
msgstr ""
"Зауважте, що :func:`frexp` і :func:`modf` мають інший шаблон виклику/"
"повернення, ніж їхні еквіваленти на C: вони беруть один аргумент і "
"повертають пару значень, замість того, щоб повертати друге значення, що "
"повертається через 'вихід параметр\" (у Python такого немає)."

msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note that "
"*all* floating-point numbers of sufficiently large magnitude are exact "
"integers. Python floats typically carry no more than 53 bits of precision "
"(the same as the platform C double type), in which case any float *x* with "
"``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""
"Для функцій :func:`ceil`, :func:`floor` і :func:`modf` зауважте, що *всі* "
"числа з плаваючою комою досить великої величини є точними цілими числами. "
"Python зазвичай містить не більше 53 бітів точності (так само, як і "
"подвійний тип платформи C), у цьому випадку будь-яке число з плаваючою "
"речовиною *x* із ``abs(x) >= 2**52`` обов’язково не має дробових бітів. ."

msgid "Power and logarithmic functions"
msgstr "Степеневі та логарифмічні функції"

msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base of "
"natural logarithms.  This is usually more accurate than ``math.e ** x`` or "
"``pow(math.e, x)``."
msgstr ""
"Поверніть *e* у степені *x*, де *e* = 2,718281... є основою натуральних "
"логарифмів. Зазвичай це точніше, ніж ``math.e ** x`` або ``pow(math.e, x)``."

msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - 1`` "
"can result in a `significant loss of precision <https://en.wikipedia.org/"
"wiki/Loss_of_significance>`_\\; the :func:`expm1` function provides a way to "
"compute this quantity to full precision::"
msgstr ""
"Поверніть *e* у степені *x*, мінус 1. Тут *e* — основа натуральних "
"логарифмів. Для малих чисел *x* віднімання в ``exp(x) - 1`` може призвести "
"до `значної втрати точності <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\; функція :func:`expm1` забезпечує спосіб "
"обчислення цієї величини з повною точністю::"

msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr "З одним аргументом повертає натуральний логарифм *x* (за основою *e*)."

msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""
"З двома аргументами повертає логарифм від *x* до заданої *основи*, "
"обчислений як ``log(x)/log(основа)``."

msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is calculated "
"in a way which is accurate for *x* near zero."
msgstr ""
"Повертає натуральний логарифм *1+x* (за основою *e*). Результат обчислюється "
"таким чином, що є точним для *x* біля нуля."

msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr ""
"Повертає логарифм *x* за основою 2. Зазвичай це точніше, ніж ``log(x, 2)``."

msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent an "
"integer in binary, excluding the sign and leading zeros."
msgstr ""
":meth:`int.bit_length` повертає кількість бітів, необхідну для представлення "
"цілого числа в двійковій формі, за винятком знака та нулів на початку."

msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr ""
"Повертає логарифм *x* за основою 10. Зазвичай це точніше, ніж ``log(x, 10)``."

msgid ""
"Return ``x`` raised to the power ``y``.  Exceptional cases follow Annex 'F' "
"of the C99 standard as far as possible.  In particular, ``pow(1.0, x)`` and "
"``pow(x, 0.0)`` always return ``1.0``, even when ``x`` is a zero or a NaN.  "
"If both ``x`` and ``y`` are finite, ``x`` is negative, and ``y`` is not an "
"integer then ``pow(x, y)`` is undefined, and raises :exc:`ValueError`."
msgstr ""

msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow` "
"function for computing exact integer powers."
msgstr ""
"На відміну від вбудованого оператора ``**``, :func:`math.pow` перетворює "
"обидва свої аргументи на тип :class:`float`. Використовуйте ``**`` або "
"вбудовану функцію :func:`pow` для обчислення точних цілих степенів."

msgid "Return the square root of *x*."
msgstr "Повертає квадратний корінь з *x*."

msgid "Trigonometric functions"
msgstr "Тригонометричні функції"

msgid ""
"Return the arc cosine of *x*, in radians. The result is between ``0`` and "
"``pi``."
msgstr "Повертає арккосинус *x* у радіанах. Результат між ``0`` і ``pi``."

msgid ""
"Return the arc sine of *x*, in radians. The result is between ``-pi/2`` and "
"``pi/2``."
msgstr ""
"Повертає арксинус *x* у радіанах. Результат знаходиться між ``-pi/2`` і "
"``pi/2``."

msgid ""
"Return the arc tangent of *x*, in radians. The result is between ``-pi/2`` "
"and ``pi/2``."
msgstr ""
"Повертає арктангенс *x* у радіанах. Результат знаходиться між ``-pi/2`` і "
"``pi/2``."

msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes "
"this angle with the positive X axis. The point of :func:`atan2` is that the "
"signs of both inputs are known to it, so it can compute the correct quadrant "
"for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are both "
"``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""
"Повертає ``atan(y / x)``, у радіанах. Результат знаходиться між ``-pi`` і "
"``pi``. Вектор у площині від початку координат до точки \"(x, y)\" утворює "
"цей кут із додатною віссю X. Суть :func:`atan2` полягає в тому, що йому "
"відомі знаки обох вхідних даних, тому він може обчислити правильний квадрант "
"для кута. Наприклад, ``atan(1)`` і ``atan2(1, 1)`` обидва є ``pi/4``, але "
"``atan2(-1, -1)`` є ``-3*pi/4``."

msgid "Return the cosine of *x* radians."
msgstr "Повертає косинус *x* радіан."

msgid ""
"Return the Euclidean distance between two points *p* and *q*, each given as "
"a sequence (or iterable) of coordinates.  The two points must have the same "
"dimension."
msgstr ""
"Повертає евклідову відстань між двома точками *p* і *q*, кожна з яких задана "
"як послідовність (або повторювана) координат. Дві точки повинні мати "
"однаковий розмір."

msgid "Roughly equivalent to::"
msgstr "Приблизно еквівалентно::"

msgid ""
"Return the Euclidean norm, ``sqrt(sum(x**2 for x in coordinates))``. This is "
"the length of the vector from the origin to the point given by the "
"coordinates."
msgstr ""
"Повертає евклідову норму, ``sqrt(sum(x**2 для x у координатах))``. Це "
"довжина вектора від початку координат до точки, заданої координатами."

msgid ""
"For a two dimensional point ``(x, y)``, this is equivalent to computing the "
"hypotenuse of a right triangle using the Pythagorean theorem, ``sqrt(x*x + "
"y*y)``."
msgstr ""
"Для двовимірної точки ``(x, y)`` це еквівалентно обчисленню гіпотенузи "
"прямокутного трикутника за допомогою теореми Піфагора ``sqrt(x*x + y*y)``."

msgid ""
"Added support for n-dimensional points. Formerly, only the two dimensional "
"case was supported."
msgstr ""
"Додано підтримку n-вимірних точок. Раніше підтримувався лише двовимірний "
"випадок."

msgid ""
"Improved the algorithm's accuracy so that the maximum error is under 1 ulp "
"(unit in the last place).  More typically, the result is almost always "
"correctly rounded to within 1/2 ulp."
msgstr ""
"Покращено точність алгоритму, щоб максимальна помилка була менше 1 ulp "
"(одиниця на останньому місці). Як правило, результат майже завжди правильно "
"округлюється з точністю до 1/2 ulp."

msgid "Return the sine of *x* radians."
msgstr "Повернути синус *x* радіан."

msgid "Return the tangent of *x* radians."
msgstr "Повертає тангенс *x* радіан."

msgid "Angular conversion"
msgstr "Кутове перетворення"

msgid "Convert angle *x* from radians to degrees."
msgstr "Перетворіть кут *x* з радіан на градуси."

msgid "Convert angle *x* from degrees to radians."
msgstr "Переведіть кут *x* із градусів у радіани."

msgid "Hyperbolic functions"
msgstr "Гіперболічні функції"

msgid ""
"`Hyperbolic functions <https://en.wikipedia.org/wiki/Hyperbolic_function>`_ "
"are analogs of trigonometric functions that are based on hyperbolas instead "
"of circles."
msgstr ""
"`Гіперболічні функції <https://en.wikipedia.org/wiki/Hyperbolic_function>`_ "
"є аналогами тригонометричних функцій, які засновані на гіперболах замість "
"кіл."

msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "Повертає арккосинус *x*."

msgid "Return the inverse hyperbolic sine of *x*."
msgstr "Повертає гіперболічний арксинус *x*."

msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "Повертає гіперболічний обернений тангенс *x*."

msgid "Return the hyperbolic cosine of *x*."
msgstr "Повертає гіперболічний косинус *x*."

msgid "Return the hyperbolic sine of *x*."
msgstr "Повернути гіперболічний синус *x*."

msgid "Return the hyperbolic tangent of *x*."
msgstr "Поверніть гіперболічний тангенс *x*."

msgid "Special functions"
msgstr "Спеціальні функції"

msgid ""
"Return the `error function <https://en.wikipedia.org/wiki/Error_function>`_ "
"at *x*."
msgstr ""
"Повертає `функцію помилки <https://en.wikipedia.org/wiki/Error_function>`_ у "
"*x*."

msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution <https://en."
"wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function>`_::"
msgstr ""

msgid ""
"Return the complementary error function at *x*.  The `complementary error "
"function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction "
"from one would cause a `loss of significance <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."
msgstr ""
"Повертає функцію додаткової помилки в *x*. `Додаткова функція помилок "
"<https://en.wikipedia.org/wiki/Error_function>`_ визначається як ``1.0 - "
"erf(x)``. Він використовується для великих значень *x*, де віднімання від "
"одиниці спричинило б `втрату значущості <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."

msgid ""
"Return the `Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ "
"at *x*."
msgstr ""
"Повертає `Гамма-функцію <https://en.wikipedia.org/wiki/Gamma_function>`_ у "
"*x*."

msgid ""
"Return the natural logarithm of the absolute value of the Gamma function at "
"*x*."
msgstr ""
"Повертає натуральний логарифм абсолютного значення гамма-функції при *x*."

msgid "Constants"
msgstr "Константи"

msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr "Математична константа *π* = 3,141592... з доступною точністю."

msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr "Математична константа *e* = 2,718281... з доступною точністю."

msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau is "
"a circle constant equal to 2\\ *π*, the ratio of a circle's circumference to "
"its radius. To learn more about Tau, check out Vi Hart's video `Pi is "
"(still) Wrong <https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, and start "
"celebrating `Tau day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""
"Математична константа *τ* = 6,283185... з доступною точністю. Tau — постійна "
"величина кола, що дорівнює 2\\ *π*, відношенню довжини кола до його радіуса. "
"Щоб дізнатися більше про Тау, перегляньте відео Ві Харт `Пі (все ще) "
"неправильне <https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, і почніть "
"святкувати `День Тау <https://tauday.com/>`_, з’ївши вдвічі більше пирога!"

msgid ""
"A floating-point positive infinity.  (For negative infinity, use ``-math."
"inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""
"Додатна нескінченність із плаваючою комою. (Для негативної нескінченності "
"використовуйте ``-math.inf``.) Еквівалент виведення ``float('inf')``."

msgid ""
"A floating-point \"not a number\" (NaN) value. Equivalent to the output of "
"``float('nan')``. Due to the requirements of the `IEEE-754 standard <https://"
"en.wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` and ``float('nan')`` are not "
"considered to equal to any other numeric value, including themselves. To "
"check whether a number is a NaN, use the :func:`isnan` function to test for "
"NaNs instead of ``is`` or ``==``. Example::"
msgstr ""
"Значення з плаваючою комою \"не число\" (NaN). Еквівалент виведення "
"``float('nan')``. Відповідно до вимог стандарту `IEEE-754 <https://en."
"wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` і ``float('nan')`` не "
"вважаються рівними будь-якому іншому числовому значенню, включно з ними "
"самими. Щоб перевірити, чи є число NaN, використовуйте функцію :func:`isnan` "
"для перевірки NaN замість ``is`` або ``==``. Приклад::"

msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the platform "
"C math library functions.  Behavior in exceptional cases follows Annex F of "
"the C99 standard where appropriate.  The current implementation will raise :"
"exc:`ValueError` for invalid operations like ``sqrt(-1.0)`` or ``log(0.0)`` "
"(where C99 Annex F recommends signaling invalid operation or divide-by-"
"zero), and :exc:`OverflowError` for results that overflow (for example, "
"``exp(1000.0)``).  A NaN will not be returned from any of the functions "
"above unless one or more of the input arguments was a NaN; in that case, "
"most functions will return a NaN, but (again following C99 Annex F) there "
"are some exceptions to this rule, for example ``pow(float('nan'), 0.0)`` or "
"``hypot(float('nan'), float('inf'))``."
msgstr ""
"Модуль :mod:`math` складається здебільшого з тонких обгорток навколо функцій "
"математичної бібліотеки платформи C. Поведінка у виняткових випадках "
"відповідає додатку F стандарту C99, де це необхідно. Поточна реалізація "
"викличе :exc:`ValueError` для недійсних операцій, таких як ``sqrt(-1.0)`` "
"або ``log(0.0)`` (де C99 Додаток F рекомендує сигналізувати про недійсну "
"операцію або ділення на нуль), і :exc:`OverflowError` для результатів, які "
"переповнюються (наприклад, ``exp(1000.0)``). NaN не буде повернено жодною з "
"наведених вище функцій, якщо один або більше вхідних аргументів не були NaN; "
"у цьому випадку більшість функцій повертатиме NaN, але (знову ж таки "
"відповідно до Додатку F C99) є деякі винятки з цього правила, наприклад "
"``pow(float('nan'), 0.0)`` або ``hypot(float ('nan'), float('inf'))``."

msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet "
"NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior "
"is to treat all NaNs as though they were quiet."
msgstr ""
"Зауважте, що Python не робить жодних зусиль, щоб відрізнити сигнальні NaN "
"від тихих NaN, і поведінка для сигнальних NaN залишається невизначеною. "
"Типовою поведінкою є ставлення до всіх NaN так, ніби вони тихі."

msgid "Module :mod:`cmath`"
msgstr "Модуль :mod:`cmath`"

msgid "Complex number versions of many of these functions."
msgstr "Версії комплексних чисел багатьох із цих функцій."
