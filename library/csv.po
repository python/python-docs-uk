# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`csv` --- CSV File Reading and Writing"
msgstr ":mod:`csv` --- Читання та запис файлу CSV"

msgid "**Source code:** :source:`Lib/csv.py`"
msgstr "**Вихідний код:** :source:`Lib/csv.py`"

msgid ""
"The so-called CSV (Comma Separated Values) format is the most common import "
"and export format for spreadsheets and databases.  CSV format was used for "
"many years prior to attempts to describe the format in a standardized way "
"in :rfc:`4180`.  The lack of a well-defined standard means that subtle "
"differences often exist in the data produced and consumed by different "
"applications.  These differences can make it annoying to process CSV files "
"from multiple sources. Still, while the delimiters and quoting characters "
"vary, the overall format is similar enough that it is possible to write a "
"single module which can efficiently manipulate such data, hiding the details "
"of reading and writing the data from the programmer."
msgstr ""
"Так званий формат CSV (значення, розділені комами) є найпоширенішим форматом "
"імпорту та експорту для електронних таблиць і баз даних. Формат CSV "
"використовувався протягом багатьох років до того, як його спробували описати "
"стандартизованим способом у :rfc:`4180`. Відсутність чітко визначеного "
"стандарту означає, що часто існують тонкі відмінності в даних, які "
"створюються та споживаються різними програмами. Ці відмінності можуть "
"дратувати обробку файлів CSV із кількох джерел. Тим не менш, хоча "
"розділювачі та символи лапок відрізняються, загальний формат досить схожий, "
"щоб можна було написати один модуль, який може ефективно маніпулювати такими "
"даними, приховуючи деталі читання та запису даних від програміста."

msgid ""
"The :mod:`csv` module implements classes to read and write tabular data in "
"CSV format.  It allows programmers to say, \"write this data in the format "
"preferred by Excel,\" or \"read data from this file which was generated by "
"Excel,\" without knowing the precise details of the CSV format used by "
"Excel.  Programmers can also describe the CSV formats understood by other "
"applications or define their own special-purpose CSV formats."
msgstr ""
"Модуль :mod:`csv` реалізує класи для читання та запису табличних даних у "
"форматі CSV. Це дозволяє програмістам сказати: \"записати ці дані у форматі, "
"який віддає перевагу Excel\" або \"прочитати дані з цього файлу, створеного "
"Excel\", не знаючи точних деталей формату CSV, який використовує Excel. "
"Програмісти також можуть описувати формати CSV, які розуміють інші програми, "
"або визначати власні формати CSV спеціального призначення."

msgid ""
"The :mod:`csv` module's :class:`reader` and :class:`writer` objects read and "
"write sequences.  Programmers can also read and write data in dictionary "
"form using the :class:`DictReader` and :class:`DictWriter` classes."
msgstr ""
"Об’єкти :class:`reader` і :class:`writer` модуля :mod:`csv` читають і "
"записують послідовності. Програмісти також можуть читати та записувати дані "
"у формі словника за допомогою класів :class:`DictReader` і :class:"
"`DictWriter`."

msgid ":pep:`305` - CSV File API"
msgstr ":pep:`305` - API файлів CSV"

msgid "The Python Enhancement Proposal which proposed this addition to Python."
msgstr "Пропозиція вдосконалення Python, яка пропонує це доповнення до Python."

msgid "Module Contents"
msgstr "Зміст модуля"

msgid "The :mod:`csv` module defines the following functions:"
msgstr "Модуль :mod:`csv` визначає такі функції:"

msgid ""
"Return a reader object which will iterate over lines in the given *csvfile*. "
"*csvfile* can be any object which supports the :term:`iterator` protocol and "
"returns a string each time its :meth:`!__next__` method is called --- :term:"
"`file objects <file object>` and list objects are both suitable.   If "
"*csvfile* is a file object, it should be opened with ``newline=''``. [1]_  "
"An optional *dialect* parameter can be given which is used to define a set "
"of parameters specific to a particular CSV dialect.  It may be an instance "
"of a subclass of the :class:`Dialect` class or one of the strings returned "
"by the :func:`list_dialects` function.  The other optional *fmtparams* "
"keyword arguments can be given to override individual formatting parameters "
"in the current dialect.  For full details about the dialect and formatting "
"parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Повертає об’єкт читання, який буде виконувати ітерацію по рядках у заданому "
"*csv-файлі*. *csvfile* може бути будь-яким об’єктом, який підтримує "
"протокол :term:`iterator` і повертає рядок кожного разу, коли викликається "
"його метод :meth:`!__next__` --- :term:`файлові об’єкти <file object>` і "
"об’єкти списку є обома підходить. Якщо *csvfile* є файловим об’єктом, його "
"слід відкрити за допомогою ``newline=''``. [1]_ Можна вказати необов’язковий "
"параметр *dialect*, який використовується для визначення набору параметрів, "
"специфічних для конкретного діалекту CSV. Це може бути екземпляр підкласу "
"класу :class:`Dialect` або один із рядків, які повертає функція :func:"
"`list_dialects`. Інші необов’язкові аргументи ключового слова *fmtparams* "
"можна надати для перевизначення окремих параметрів форматування в поточному "
"діалекті. Щоб отримати повну інформацію про діалект і параметри "
"форматування, перегляньте розділ :ref:`csv-fmt-params`."

msgid ""
"Each row read from the csv file is returned as a list of strings.  No "
"automatic data type conversion is performed unless the ``QUOTE_NONNUMERIC`` "
"format option is specified (in which case unquoted fields are transformed "
"into floats)."
msgstr ""
"Кожен рядок, прочитаний із файлу csv, повертається як список рядків. "
"Автоматичне перетворення типу даних не виконується, якщо не вказано параметр "
"формату ``QUOTE_NONNUMERIC`` (у цьому випадку поля без лапок перетворюються "
"на числа з плаваючою точкою)."

msgid "A short usage example::"
msgstr "Короткий приклад використання::"

msgid ""
"Return a writer object responsible for converting the user's data into "
"delimited strings on the given file-like object.  *csvfile* can be any "
"object with a :func:`write` method.  If *csvfile* is a file object, it "
"should be opened with ``newline=''`` [1]_.  An optional *dialect* parameter "
"can be given which is used to define a set of parameters specific to a "
"particular CSV dialect.  It may be an instance of a subclass of the :class:"
"`Dialect` class or one of the strings returned by the :func:`list_dialects` "
"function.  The other optional *fmtparams* keyword arguments can be given to "
"override individual formatting parameters in the current dialect.  For full "
"details about dialects and formatting parameters, see the :ref:`csv-fmt-"
"params` section. To make it as easy as possible to interface with modules "
"which implement the DB API, the value :const:`None` is written as the empty "
"string.  While this isn't a reversible transformation, it makes it easier to "
"dump SQL NULL data values to CSV files without preprocessing the data "
"returned from a ``cursor.fetch*`` call. All other non-string data are "
"stringified with :func:`str` before being written."
msgstr ""
"Повертає об’єкт запису, відповідальний за перетворення даних користувача в "
"рядки з роздільниками на даному файлоподібному об’єкті. *csvfile* може бути "
"будь-яким об’єктом із методом :func:`write`. Якщо *csvfile* є файловим "
"об’єктом, його слід відкрити за допомогою ``newline=''`` [1]_. Можна вказати "
"необов’язковий параметр *dialect*, який використовується для визначення "
"набору параметрів, специфічних для конкретного діалекту CSV. Це може бути "
"екземпляр підкласу класу :class:`Dialect` або один із рядків, які повертає "
"функція :func:`list_dialects`. Інші необов’язкові аргументи ключового слова "
"*fmtparams* можна надати для перевизначення окремих параметрів форматування "
"в поточному діалекті. Щоб отримати повну інформацію про діалекти та "
"параметри форматування, перегляньте розділ :ref:`csv-fmt-params`. Щоб "
"якомога легше взаємодіяти з модулями, які реалізують API БД, значення :const:"
"`None` записується як порожній рядок. Хоча це не є оборотним перетворенням, "
"воно спрощує скидання значень даних SQL NULL у файли CSV без попередньої "
"обробки даних, отриманих із виклику ``cursor.fetch*``. Усі інші нерядкові "
"дані перед записом утворюються в рядки за допомогою :func:`str`."

msgid ""
"Associate *dialect* with *name*.  *name* must be a string. The dialect can "
"be specified either by passing a sub-class of :class:`Dialect`, or by "
"*fmtparams* keyword arguments, or both, with keyword arguments overriding "
"parameters of the dialect. For full details about dialects and formatting "
"parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Пов’яжіть *діалект* з *ім’ям*. *ім’я* має бути рядком. Діалект можна вказати "
"або шляхом передачі підкласу :class:`Dialect`, або за допомогою аргументів "
"ключового слова *fmtparams*, або обох, причому аргументи ключового слова "
"замінюють параметри діалекту. Щоб отримати повну інформацію про діалекти та "
"параметри форматування, перегляньте розділ :ref:`csv-fmt-params`."

msgid ""
"Delete the dialect associated with *name* from the dialect registry.  An :"
"exc:`Error` is raised if *name* is not a registered dialect name."
msgstr ""
"Видаліть діалект, пов’язаний з *name*, із реєстру діалектів. Якщо *name* не "
"є зареєстрованою назвою діалекту, виникає помилка :exc:`Error`."

msgid ""
"Return the dialect associated with *name*.  An :exc:`Error` is raised if "
"*name* is not a registered dialect name.  This function returns an "
"immutable :class:`Dialect`."
msgstr ""
"Повертає діалект, пов’язаний з *ім’ям*. Якщо *name* не є зареєстрованою "
"назвою діалекту, виникає помилка :exc:`Error`. Ця функція повертає "
"незмінний :class:`Dialect`."

msgid "Return the names of all registered dialects."
msgstr "Повернути назви всіх зареєстрованих діалектів."

msgid ""
"Returns the current maximum field size allowed by the parser. If *new_limit* "
"is given, this becomes the new limit."
msgstr ""
"Повертає поточний максимальний розмір поля, дозволений аналізатором. Якщо "
"задано *new_limit*, це стає новим лімітом."

msgid "The :mod:`csv` module defines the following classes:"
msgstr "Модуль :mod:`csv` визначає такі класи:"

msgid ""
"Create an object that operates like a regular reader but maps the "
"information in each row to a :class:`dict` whose keys are given by the "
"optional *fieldnames* parameter."
msgstr ""
"Створіть об’єкт, який працює як звичайний читач, але зіставляє інформацію в "
"кожному рядку з :class:`dict`, ключі якого надаються необов’язковим "
"параметром *fieldnames*."

msgid ""
"The *fieldnames* parameter is a :term:`sequence`.  If *fieldnames* is "
"omitted, the values in the first row of file *f* will be used as the "
"fieldnames.  Regardless of how the fieldnames are determined, the dictionary "
"preserves their original ordering."
msgstr ""
"Параметр *fieldnames* є :term:`sequence`. Якщо *fieldnames* пропущено, "
"значення в першому рядку файлу *f* використовуватимуться як імена полів. "
"Незалежно від того, як визначено назви полів, словник зберігає їх початковий "
"порядок."

msgid ""
"If a row has more fields than fieldnames, the remaining data is put in a "
"list and stored with the fieldname specified by *restkey* (which defaults to "
"``None``).  If a non-blank row has fewer fields than fieldnames, the missing "
"values are filled-in with the value of *restval* (which defaults to "
"``None``)."
msgstr ""
"Якщо рядок містить більше полів, ніж назв полів, дані, що залишилися, "
"поміщаються в список і зберігаються з іменем поля, визначеним *restkey* (за "
"замовчуванням значення \"Немає\"). Якщо непорожній рядок містить менше "
"полів, ніж імена полів, відсутні значення заповнюються значенням *restval* "
"(яке за замовчуванням ``None``)."

msgid ""
"All other optional or keyword arguments are passed to the underlying :class:"
"`reader` instance."
msgstr ""
"Усі інші необов’язкові або ключові аргументи передаються базовому "
"екземпляру :class:`reader`."

msgid "Returned rows are now of type :class:`OrderedDict`."
msgstr "Повернені рядки тепер мають тип :class:`OrderedDict`."

msgid "Returned rows are now of type :class:`dict`."
msgstr "Повернені рядки тепер мають тип :class:`dict`."

msgid ""
"Create an object which operates like a regular writer but maps dictionaries "
"onto output rows.  The *fieldnames* parameter is a :mod:`sequence "
"<collections.abc>` of keys that identify the order in which values in the "
"dictionary passed to the :meth:`writerow` method are written to file *f*.  "
"The optional *restval* parameter specifies the value to be written if the "
"dictionary is missing a key in *fieldnames*.  If the dictionary passed to "
"the :meth:`writerow` method contains a key not found in *fieldnames*, the "
"optional *extrasaction* parameter indicates what action to take. If it is "
"set to ``'raise'``, the default value, a :exc:`ValueError` is raised. If it "
"is set to ``'ignore'``, extra values in the dictionary are ignored. Any "
"other optional or keyword arguments are passed to the underlying :class:"
"`writer` instance."
msgstr ""
"Створіть об’єкт, який працює як звичайний записувач, але зіставляє словники "
"з вихідними рядками. Параметр *fieldnames* — це :mod:`послідовність "
"<collections.abc>` ключів, які визначають порядок, у якому значення зі "
"словника, переданого в метод :meth:`writerow`, записуються у файл *f*. "
"Додатковий параметр *restval* визначає значення, яке буде записане, якщо в "
"словнику відсутній ключ у *полях*. Якщо словник, переданий до методу :meth:"
"`writerow`, містить ключ, якого немає в *fieldnames*, необов’язковий "
"параметр *extrasaction* вказує, яку дію потрібно виконати. Якщо встановлено "
"``'raise'``, значення за замовчуванням, викликається :exc:`ValueError`. Якщо "
"встановлено значення ``'ignore''``, додаткові значення в словнику "
"ігноруються. Будь-які інші додаткові або ключові аргументи передаються "
"базовому екземпляру :class:`writer`."

msgid ""
"Note that unlike the :class:`DictReader` class, the *fieldnames* parameter "
"of the :class:`DictWriter` class is not optional."
msgstr ""
"Зауважте, що на відміну від класу :class:`DictReader`, параметр *fieldnames* "
"класу :class:`DictWriter` необов’язковий."

msgid ""
"The :class:`Dialect` class is a container class whose attributes contain "
"information for how to handle doublequotes, whitespace, delimiters, etc. Due "
"to the lack of a strict CSV specification, different applications produce "
"subtly different CSV data.  :class:`Dialect` instances define how :class:"
"`reader` and :class:`writer` instances behave."
msgstr ""
"Клас :class:`Dialect` — це клас-контейнер, атрибути якого містять інформацію "
"про те, як обробляти подвійні лапки, пробіли, розділювачі тощо. Через "
"відсутність суворої специфікації CSV різні програми створюють дещо різні "
"дані CSV. Екземпляри :class:`Dialect` визначають, як поводитимуться "
"екземпляри :class:`reader` і :class:`writer`."

msgid ""
"All available :class:`Dialect` names are returned by :func:`list_dialects`, "
"and they can be registered with specific :class:`reader` and :class:`writer` "
"classes through their initializer (``__init__``) functions like this::"
msgstr ""
"Усі доступні назви :class:`Dialect` повертаються :func:`list_dialects`, і їх "
"можна зареєструвати в певних класах :class:`reader` і :class:`writer` через "
"їх ініціалізатор (``__init__``) функціонує так::"

msgid ""
"The :class:`excel` class defines the usual properties of an Excel-generated "
"CSV file.  It is registered with the dialect name ``'excel'``."
msgstr ""
"Клас :class:`excel` визначає звичайні властивості файлу CSV, створеного "
"Excel. Його зареєстровано з діалектною назвою ``'excel``."

msgid ""
"The :class:`excel_tab` class defines the usual properties of an Excel-"
"generated TAB-delimited file.  It is registered with the dialect name "
"``'excel-tab'``."
msgstr ""
"Клас :class:`excel_tab` визначає звичайні властивості створеного Excel файлу "
"з роздільниками TAB. Його зареєстровано з діалектною назвою ``'excel-tab``."

msgid ""
"The :class:`unix_dialect` class defines the usual properties of a CSV file "
"generated on UNIX systems, i.e. using ``'\\n'`` as line terminator and "
"quoting all fields.  It is registered with the dialect name ``'unix'``."
msgstr ""
"Клас :class:`unix_dialect` визначає звичайні властивості файлу CSV, "
"створеного в системах UNIX, тобто використання ``'\\n'`` як символ "
"закінчення рядка та взяття всіх полів у лапки. Він зареєстрований під "
"діалектною назвою ``'unix``."

msgid "The :class:`Sniffer` class is used to deduce the format of a CSV file."
msgstr ""
"Клас :class:`Sniffer` використовується для визначення формату файлу CSV."

msgid "The :class:`Sniffer` class provides two methods:"
msgstr "Клас :class:`Sniffer` надає два методи:"

msgid ""
"Analyze the given *sample* and return a :class:`Dialect` subclass reflecting "
"the parameters found.  If the optional *delimiters* parameter is given, it "
"is interpreted as a string containing possible valid delimiter characters."
msgstr ""
"Проаналізуйте поданий *зразок* і поверніть підклас :class:`Dialect`, що "
"відображає знайдені параметри. Якщо вказано необов’язковий параметр "
"*роздільники*, він інтерпретується як рядок, що містить можливі дійсні "
"символи роздільників."

msgid ""
"Analyze the sample text (presumed to be in CSV format) and return :const:"
"`True` if the first row appears to be a series of column headers. Inspecting "
"each column, one of two key criteria will be considered to estimate if the "
"sample contains a header:"
msgstr ""
"Проаналізуйте зразок тексту (імовірно у форматі CSV) і поверніть :const:"
"`True`, якщо перший рядок виглядає як ряд заголовків стовпців. Перевіряючи "
"кожен стовпець, буде розглянуто один із двох ключових критеріїв, щоб "
"оцінити, чи містить вибірка заголовок:"

msgid "the second through n-th rows contain numeric values"
msgstr "з другого по n-й рядки містять числові значення"

msgid ""
"the second through n-th rows contain strings where at least one value's "
"length differs from that of the putative header of that column."
msgstr ""
"рядки з другого по n-й містять рядки, у яких довжина принаймні одного "
"значення відрізняється від довжини передбачуваного заголовка цього стовпця."

msgid ""
"Twenty rows after the first row are sampled; if more than half of columns + "
"rows meet the criteria, :const:`True` is returned."
msgstr ""
"Через двадцять рядів після першого ряду проводиться вибірка; якщо більше "
"половини стовпців + рядків відповідають критеріям, повертається :const:"
"`True`."

msgid ""
"This method is a rough heuristic and may produce both false positives and "
"negatives."
msgstr ""
"Цей метод є грубим евристичним і може давати як помилкові позитивні, так і "
"негативні результати."

msgid "An example for :class:`Sniffer` use::"
msgstr "Приклад використання :class:`Sniffer`::"

msgid "The :mod:`csv` module defines the following constants:"
msgstr "Модуль :mod:`csv` визначає такі константи:"

msgid "Instructs :class:`writer` objects to quote all fields."
msgstr "Вказує об’єктам :class:`writer` взяти всі поля в лапки."

msgid ""
"Instructs :class:`writer` objects to only quote those fields which contain "
"special characters such as *delimiter*, *quotechar* or any of the characters "
"in *lineterminator*."
msgstr ""
"Вказує об’єктам :class:`writer` брати в лапки лише ті поля, які містять "
"спеціальні символи, такі як *роздільник*, *quotechar* або будь-які символи в "
"*lineterminator*."

msgid "Instructs :class:`writer` objects to quote all non-numeric fields."
msgstr "Вказує об’єктам :class:`writer` взяти в лапки всі нечислові поля."

msgid "Instructs the reader to convert all non-quoted fields to type *float*."
msgstr "Вказує читачеві перетворити всі поля без лапок на тип *float*."

msgid ""
"Instructs :class:`writer` objects to never quote fields.  When the current "
"*delimiter* occurs in output data it is preceded by the current *escapechar* "
"character.  If *escapechar* is not set, the writer will raise :exc:`Error` "
"if any characters that require escaping are encountered."
msgstr ""
"Наказує об’єктам :class:`writer` ніколи не брати поля в лапки. Коли поточний "
"*роздільник* зустрічається у вихідних даних, йому передує поточний символ "
"*escapechar*. Якщо *escapechar* не встановлено, запис викличе :exc:`Error`, "
"якщо зустрінеться будь-який символ, який потребує екранування."

msgid ""
"Instructs :class:`reader` to perform no special processing of quote "
"characters."
msgstr ""
"Вказує :class:`reader` не виконувати спеціальної обробки символів лапок."

msgid "The :mod:`csv` module defines the following exception:"
msgstr "Модуль :mod:`csv` визначає такий виняток:"

msgid "Raised by any of the functions when an error is detected."
msgstr "Викликається будь-якою з функцій у разі виявлення помилки."

msgid "Dialects and Formatting Parameters"
msgstr "Діалекти та параметри форматування"

msgid ""
"To make it easier to specify the format of input and output records, "
"specific formatting parameters are grouped together into dialects.  A "
"dialect is a subclass of the :class:`Dialect` class having a set of specific "
"methods and a single :meth:`validate` method.  When creating :class:`reader` "
"or :class:`writer` objects, the programmer can specify a string or a "
"subclass of the :class:`Dialect` class as the dialect parameter.  In "
"addition to, or instead of, the *dialect* parameter, the programmer can also "
"specify individual formatting parameters, which have the same names as the "
"attributes defined below for the :class:`Dialect` class."
msgstr ""
"Щоб спростити визначення формату вхідних і вихідних записів, окремі "
"параметри форматування згруповані разом у діалекти. Діалект — це підклас "
"класу :class:`Dialect`, який має набір специфічних методів і єдиний метод :"
"meth:`validate`. Під час створення об’єктів :class:`reader` або :class:"
"`writer` програміст може вказати рядок або підклас класу :class:`Dialect` як "
"параметр діалекту. На додаток до параметра *dialect* або замість нього "
"програміст також може вказати окремі параметри форматування, які мають ті "
"самі імена, що й атрибути, визначені нижче для класу :class:`Dialect`."

msgid "Dialects support the following attributes:"
msgstr "Діалекти підтримують такі атрибути:"

msgid ""
"A one-character string used to separate fields.  It defaults to ``','``."
msgstr ""
"Односимвольний рядок, який використовується для розділення полів. За "
"замовчуванням ``',''``."

msgid ""
"Controls how instances of *quotechar* appearing inside a field should "
"themselves be quoted.  When :const:`True`, the character is doubled. When :"
"const:`False`, the *escapechar* is used as a prefix to the *quotechar*.  It "
"defaults to :const:`True`."
msgstr ""
"Керує тим, як екземпляри *quotechar*, що з’являються всередині поля, повинні "
"братися в лапки. Коли :const:`True`, символ подвоюється. Коли :const:"
"`False`, *escapechar* використовується як префікс до *quotechar*. За "
"замовчуванням :const:`True`."

msgid ""
"On output, if *doublequote* is :const:`False` and no *escapechar* is set, :"
"exc:`Error` is raised if a *quotechar* is found in a field."
msgstr ""
"Під час виведення, якщо *doublequote* має значення :const:`False` і "
"*escapechar* не встановлено, виникає повідомлення :exc:`Error`, якщо "
"*quotechar* знайдено в полі."

msgid ""
"A one-character string used by the writer to escape the *delimiter* if "
"*quoting* is set to :const:`QUOTE_NONE` and the *quotechar* if *doublequote* "
"is :const:`False`. On reading, the *escapechar* removes any special meaning "
"from the following character. It defaults to :const:`None`, which disables "
"escaping."
msgstr ""
"Односимвольний рядок, який використовується автором для екранування "
"*роздільника*, якщо *quoting* встановлено як :const:`QUOTE_NONE`, і "
"*quotechar*, якщо *doublequote* має значення :const:`False`. Під час читання "
"*escapechar* видаляє будь-яке спеціальне значення наступного символу. За "
"замовчуванням :const:`None`, що вимикає екранування."

msgid ""
"The string used to terminate lines produced by the :class:`writer`. It "
"defaults to ``'\\r\\n'``."
msgstr ""
"Рядок, який використовується для завершення рядків, створених :class:"
"`writer`. За замовчуванням ``'\\r\\n'``."

msgid ""
"The :class:`reader` is hard-coded to recognise either ``'\\r'`` or ``'\\n'`` "
"as end-of-line, and ignores *lineterminator*. This behavior may change in "
"the future."
msgstr ""
":class:`reader` жорстко розпізнає ``'\\r'`` або ``'\\n'`` як кінець рядка та "
"ігнорує *lineterminator*. Така поведінка може змінитися в майбутньому."

msgid ""
"A one-character string used to quote fields containing special characters, "
"such as the *delimiter* or *quotechar*, or which contain new-line "
"characters.  It defaults to ``'\"'``."
msgstr ""
"Односимвольний рядок, який використовується для взяття в лапки полів, що "
"містять спеціальні символи, такі як *роздільник* або *quotechar*, або які "
"містять символи нового рядка. За замовчуванням ``'\"'``."

msgid ""
"Controls when quotes should be generated by the writer and recognised by the "
"reader.  It can take on any of the :const:`QUOTE_\\*` constants (see "
"section :ref:`csv-contents`) and defaults to :const:`QUOTE_MINIMAL`."
msgstr ""
"Контролює, коли цитати мають бути створені автором і розпізнані читачем. Він "
"може приймати будь-які константи :const:`QUOTE_\\*` (див. розділ :ref:`csv-"
"contents`) і за замовчуванням має значення :const:`QUOTE_MINIMAL`."

msgid ""
"When :const:`True`, whitespace immediately following the *delimiter* is "
"ignored. The default is :const:`False`."
msgstr ""
"Коли :const:`True`, пробіли відразу після *роздільника* ігноруються. Типовим "
"є :const:`False`."

msgid ""
"When ``True``, raise exception :exc:`Error` on bad CSV input. The default is "
"``False``."
msgstr ""
"Якщо ``True``, викликати виняток :exc:`Error` на неправильному введенні CSV. "
"Типовим значенням є ``False``."

msgid "Reader Objects"
msgstr "Об’єкти Reader"

msgid ""
"Reader objects (:class:`DictReader` instances and objects returned by the :"
"func:`reader` function) have the following public methods:"
msgstr ""
"Об’єкти Reader (екземпляри :class:`DictReader` та об’єкти, повернуті "
"функцією :func:`reader`) мають такі публічні методи:"

msgid ""
"Return the next row of the reader's iterable object as a list (if the object "
"was returned from :func:`reader`) or a dict (if it is a :class:`DictReader` "
"instance), parsed according to the current :class:`Dialect`.  Usually you "
"should call this as ``next(reader)``."
msgstr ""
"Повертає наступний рядок повторюваного об’єкта читача як список (якщо об’єкт "
"повернуто з :func:`reader`) або dict (якщо це екземпляр :class:"
"`DictReader`), проаналізований відповідно до поточного :class:`Dialect`. "
"Зазвичай ви повинні називати це як ``next(reader)``."

msgid "Reader objects have the following public attributes:"
msgstr "Об’єкти Reader мають такі публічні атрибути:"

msgid "A read-only description of the dialect in use by the parser."
msgstr ""
"Доступний лише для читання опис діалекту, який використовує аналізатор."

msgid ""
"The number of lines read from the source iterator. This is not the same as "
"the number of records returned, as records can span multiple lines."
msgstr ""
"Кількість рядків, прочитаних із вихідного ітератора. Це не те саме, що "
"кількість повернутих записів, оскільки записи можуть займати кілька рядків."

msgid "DictReader objects have the following public attribute:"
msgstr "Об’єкти DictReader мають такий публічний атрибут:"

msgid ""
"If not passed as a parameter when creating the object, this attribute is "
"initialized upon first access or when the first record is read from the file."
msgstr ""
"Якщо не передано як параметр під час створення об’єкта, цей атрибут "
"ініціалізується під час першого доступу або коли перший запис зчитується з "
"файлу."

msgid "Writer Objects"
msgstr "Об'єкти Writer"

msgid ""
":class:`Writer` objects (:class:`DictWriter` instances and objects returned "
"by the :func:`writer` function) have the following public methods.  A *row* "
"must be an iterable of strings or numbers for :class:`Writer` objects and a "
"dictionary mapping fieldnames to strings or numbers (by passing them "
"through :func:`str` first) for :class:`DictWriter` objects.  Note that "
"complex numbers are written out surrounded by parens. This may cause some "
"problems for other programs which read CSV files (assuming they support "
"complex numbers at all)."
msgstr ""
"Об’єкти :class:`Writer` (екземпляри :class:`DictWriter` та об’єкти, "
"повернуті функцією :func:`writer`) мають такі публічні методи. *Рядок* має "
"бути ітерацією рядків або чисел для об’єктів :class:`Writer` і словником, "
"який зіставляє назви полів із рядками або числами (спочатку передаючи їх "
"через :func:`str`) для об’єктів :class:`DictWriter` . Зверніть увагу, що "
"комплексні числа записуються в дужках. Це може спричинити деякі проблеми для "
"інших програм, які читають файли CSV (якщо вони взагалі підтримують "
"комплексні числа)."

msgid ""
"Write the *row* parameter to the writer's file object, formatted according "
"to the current :class:`Dialect`. Return the return value of the call to the "
"*write* method of the underlying file object."
msgstr ""
"Запишіть параметр *row* в об’єкт файлу записувача, відформатований "
"відповідно до поточного :class:`Dialect`. Повертає значення, що повертається "
"викликом методу *write* основного файлового об’єкта."

msgid "Added support of arbitrary iterables."
msgstr "Додано підтримку довільних ітерацій."

msgid ""
"Write all elements in *rows* (an iterable of *row* objects as described "
"above) to the writer's file object, formatted according to the current "
"dialect."
msgstr ""
"Запишіть усі елементи в *рядки* (ітерація об’єктів *рядок*, як описано вище) "
"до об’єкта файлу записувача, відформатованого відповідно до поточного "
"діалекту."

msgid "Writer objects have the following public attribute:"
msgstr "Об’єкти Writer мають такий публічний атрибут:"

msgid "A read-only description of the dialect in use by the writer."
msgstr "Доступний лише для читання опис діалекту, який використовує автор."

msgid "DictWriter objects have the following public method:"
msgstr "Об’єкти DictWriter мають такий відкритий метод:"

msgid ""
"Write a row with the field names (as specified in the constructor) to the "
"writer's file object, formatted according to the current dialect. Return the "
"return value of the :meth:`csvwriter.writerow` call used internally."
msgstr ""
"Запишіть рядок із іменами полів (як зазначено в конструкторі) до об’єкта "
"файлу записувача, відформатованого відповідно до поточного діалекту. "
"Повертає значення, що повертається внутрішнім викликом :meth:`csvwriter."
"writerow`."

msgid ""
":meth:`writeheader` now also returns the value returned by the :meth:"
"`csvwriter.writerow` method it uses internally."
msgstr ""
":meth:`writeheader` тепер також повертає значення, повернуте методом :meth:"
"`csvwriter.writerow`, який він використовує внутрішньо."

msgid "Examples"
msgstr "Приклади"

msgid "The simplest example of reading a CSV file::"
msgstr "Найпростіший приклад читання файлу CSV:"

msgid "Reading a file with an alternate format::"
msgstr "Читання файлу в альтернативному форматі::"

msgid "The corresponding simplest possible writing example is::"
msgstr "Відповідний найпростіший можливий приклад написання:"

msgid ""
"Since :func:`open` is used to open a CSV file for reading, the file will by "
"default be decoded into unicode using the system default encoding (see :func:"
"`locale.getpreferredencoding`).  To decode a file using a different "
"encoding, use the ``encoding`` argument of open::"
msgstr ""

msgid ""
"The same applies to writing in something other than the system default "
"encoding: specify the encoding argument when opening the output file."
msgstr ""
"Те саме стосується кодування, відмінного від стандартного системного "
"кодування: укажіть аргумент кодування під час відкриття вихідного файлу."

msgid "Registering a new dialect::"
msgstr "Реєстрація нового діалекту::"

msgid ""
"A slightly more advanced use of the reader --- catching and reporting "
"errors::"
msgstr ""
"Трохи розширеніше використання читача --- виявлення та повідомлення про "
"помилки::"

msgid ""
"And while the module doesn't directly support parsing strings, it can easily "
"be done::"
msgstr ""
"І хоча модуль безпосередньо не підтримує розбір рядків, це легко зробити:"

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"If ``newline=''`` is not specified, newlines embedded inside quoted fields "
"will not be interpreted correctly, and on platforms that use ``\\r\\n`` "
"linendings on write an extra ``\\r`` will be added.  It should always be "
"safe to specify ``newline=''``, since the csv module does its own (:term:"
"`universal <universal newlines>`) newline handling."
msgstr ""
"Якщо ``newline=''`` не вказано, нові рядки, вбудовані в поля в лапках, не "
"будуть інтерпретовані належним чином, а на платформах, які використовують "
"``\\r\\n`` розрядки під час запису, буде додатковий ``\\r`` додано. Завжди "
"має бути безпечно вказувати ``newline=''``, оскільки модуль csv виконує "
"власну (:term:`universal <universal newlines>`) обробку нового рядка."
