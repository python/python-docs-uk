# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`_thread` --- Low-level threading API"
msgstr ":mod:`_thread` --- API потоків низького рівня"

msgid ""
"This module provides low-level primitives for working with multiple threads "
"(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple "
"threads of control sharing their global data space.  For synchronization, "
"simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are "
"provided. The :mod:`threading` module provides an easier to use and higher-"
"level threading API built on top of this module."
msgstr ""
"Цей модуль надає низькорівневі примітиви для роботи з кількома потоками "
"(також званими :dfn:`light-weight processes` або :dfn:`tasks`) --- кілька "
"потоків управління спільно використовують свій глобальний простір даних. Для "
"синхронізації передбачені прості блокування (також звані :dfn:`mutexes` або :"
"dfn:`binary semaphores`). Модуль :mod:`threading` надає більш простий у "
"використанні та високорівневий потоковий API, побудований на основі цього "
"модуля."

msgid "This module used to be optional, it is now always available."
msgstr "Раніше цей модуль був необов’язковим, тепер він доступний завжди."

msgid "This module defines the following constants and functions:"
msgstr "Цей модуль визначає такі константи та функції:"

msgid "Raised on thread-specific errors."
msgstr "Виникає через помилки потоку."

msgid "This is now a synonym of the built-in :exc:`RuntimeError`."
msgstr "Тепер це синонім вбудованої :exc:`RuntimeError`."

msgid "This is the type of lock objects."
msgstr "Це тип об'єктів блокування."

msgid ""
"Start a new thread and return its identifier.  The thread executes the "
"function *function* with the argument list *args* (which must be a tuple). "
"The optional *kwargs* argument specifies a dictionary of keyword arguments."
msgstr ""
"Створіть новий потік і поверніть його ідентифікатор. Потік виконує функцію "
"*function* зі списком аргументів *args* (який має бути кортежем). "
"Необов'язковий аргумент *kwargs* визначає словник ключових аргументів."

msgid "When the function returns, the thread silently exits."
msgstr "Коли функція повертається, потік мовчки виходить."

msgid ""
"When the function terminates with an unhandled exception, :func:`sys."
"unraisablehook` is called to handle the exception. The *object* attribute of "
"the hook argument is *function*. By default, a stack trace is printed and "
"then the thread exits (but other threads continue to run)."
msgstr ""
"Коли функція завершується з необробленим винятком, :func:`sys."
"unraisablehook` викликається для обробки винятку. Атрибутом *object* "
"аргументу hook є *function*. За замовчуванням трасування стека друкується, а "
"потім потік завершується (але інші потоки продовжують працювати)."

msgid ""
"When the function raises a :exc:`SystemExit` exception, it is silently "
"ignored."
msgstr ""
"Коли функція викликає виняткову ситуацію :exc:`SystemExit`, вона мовчки "
"ігнорується."

msgid ":func:`sys.unraisablehook` is now used to handle unhandled exceptions."
msgstr ""
":func:`sys.unraisablehook` тепер використовується для обробки необроблених "
"винятків."

msgid ""
"Simulate the effect of a signal arriving in the main thread. A thread can "
"use this function to interrupt the main thread, though there is no guarantee "
"that the interruption will happen immediately."
msgstr ""
"Імітуйте ефект сигналу, що надходить у головний потік. Потік може "
"використовувати цю функцію для переривання основного потоку, хоча немає "
"гарантії, що переривання відбудеться негайно."

msgid ""
"If given, *signum* is the number of the signal to simulate. If *signum* is "
"not given, :data:`signal.SIGINT` is simulated."
msgstr ""
"Якщо задано, *signum* є номером сигналу для імітації. Якщо *signum* не "
"вказано, симулюється :data:`signal.SIGINT`."

msgid ""
"If the given signal isn't handled by Python (it was set to :data:`signal."
"SIG_DFL` or :data:`signal.SIG_IGN`), this function does nothing."
msgstr ""
"Якщо заданий сигнал не обробляється Python (для нього встановлено :data:"
"`signal.SIG_DFL` або :data:`signal.SIG_IGN`), ця функція нічого не робить."

msgid "The *signum* argument is added to customize the signal number."
msgstr "Аргумент *signum* додається для налаштування номера сигналу."

msgid ""
"This does not emit the corresponding signal but schedules a call to the "
"associated handler (if it exists). If you want to truly emit the signal, "
"use :func:`signal.raise_signal`."
msgstr ""
"Це не випромінює відповідний сигнал, але планує виклик пов’язаного обробника "
"(якщо він існує). Якщо ви хочете справді випромінювати сигнал, "
"використовуйте :func:`signal.raise_signal`."

msgid ""
"Raise the :exc:`SystemExit` exception.  When not caught, this will cause the "
"thread to exit silently."
msgstr ""
"Підніміть виняток :exc:`SystemExit`. Якщо не буде спіймано, це призведе до "
"тихого виходу потоку."

msgid ""
"Return a new lock object.  Methods of locks are described below.  The lock "
"is initially unlocked."
msgstr ""
"Повернути новий об’єкт блокування. Способи блокування описані нижче. Замок "
"спочатку розблокований."

msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Повертає \"ідентифікатор потоку\" поточного потоку. Це ненульове ціле число. "
"Його значення не має прямого значення; воно призначене як магічне печиво, "
"яке можна використовувати, наприклад. щоб індексувати словник даних, що "
"стосуються потоку. Ідентифікатори потоку можуть бути перероблені, коли потік "
"завершується та створюється інший."

msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Повертає власний інтегральний ідентифікатор потоку поточного потоку, "
"призначеного ядром. Це невід’ємне ціле число. Його значення може "
"використовуватися для однозначної ідентифікації цього конкретного потоку в "
"системі (до завершення роботи потоку, після чого значення може бути повторно "
"використано ОС)."

msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX."
msgstr ""
":ref:`Наявність <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX."

msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Повертає розмір стека потоків, який використовувався під час створення нових "
"потоків. Необов’язковий аргумент *size* визначає розмір стека, який буде "
"використовуватися для згодом створених потоків, і має дорівнювати 0 "
"(використовувати платформу або налаштоване за замовчуванням) або додатне "
"ціле значення принаймні 32 768 (32 КіБ). Якщо *size* не вказано, "
"використовується 0. Якщо зміна розміру стека потоку не підтримується, "
"виникає :exc:`RuntimeError`. Якщо вказаний розмір стека недійсний, виникає "
"помилка :exc:`ValueError` і розмір стека не змінюється. 32 КіБ наразі є "
"мінімальним підтримуваним значенням розміру стеку, щоб гарантувати достатній "
"простір стеку для самого інтерпретатора. Зауважте, що деякі платформи можуть "
"мати певні обмеження щодо значень розміру стека, як-от вимагати мінімальний "
"розмір стека > 32 КБ або вимагати виділення кратного розміру сторінки "
"системної пам’яті – для отримання додаткової інформації слід звернутися до "
"документації платформи (сторінки 4 КБ є поширеними; використання кратних "
"4096 для розміру стека є запропонованим підходом за відсутності більш "
"конкретної інформації)."

msgid ""
":ref:`Availability <availability>`: Windows, systems with POSIX threads."
msgstr ":ref:`Доступність <availability>`: Windows, системи з потоками POSIX."

msgid ""
"The maximum value allowed for the *timeout* parameter of :meth:`Lock."
"acquire`. Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"Максимальне дозволене значення для параметра *timeout* для :meth:`Lock."
"acquire`. Якщо вказати час очікування, більший за це значення, виникне :exc:"
"`OverflowError`."

msgid "Lock objects have the following methods:"
msgstr "Об’єкти блокування мають такі методи:"

msgid ""
"Without any optional argument, this method acquires the lock "
"unconditionally, if necessary waiting until it is released by another thread "
"(only one thread at a time can acquire a lock --- that's their reason for "
"existence)."
msgstr ""
"Без будь-яких необов’язкових аргументів цей метод отримує блокування "
"безумовно, за необхідності чекаючи, поки його не буде звільнено іншим "
"потоком (лише один потік за раз може отримати блокування --- це причина "
"їхнього існування)."

msgid ""
"If the integer *waitflag* argument is present, the action depends on its "
"value: if it is zero, the lock is only acquired if it can be acquired "
"immediately without waiting, while if it is nonzero, the lock is acquired "
"unconditionally as above."
msgstr ""
"Якщо присутній цілочисельний аргумент *waitflag*, дія залежить від його "
"значення: якщо воно дорівнює нулю, блокування здійснюється лише тоді, коли "
"його можна отримати негайно без очікування, тоді як якщо він ненульовий, "
"блокування отримується безумовно, як описано вище."

msgid ""
"If the floating-point *timeout* argument is present and positive, it "
"specifies the maximum wait time in seconds before returning.  A negative "
"*timeout* argument specifies an unbounded wait.  You cannot specify a "
"*timeout* if *waitflag* is zero."
msgstr ""
"Якщо аргумент *timeout* із плаваючою комою присутній і додатний, він "
"визначає максимальний час очікування в секундах перед поверненням. "
"Негативний аргумент *тайм-аут* визначає необмежену очікування. Ви не можете "
"вказати *тайм-аут*, якщо *waitflag* дорівнює нулю."

msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not."
msgstr ""
"Поверненим значенням є ``True``, якщо блокування отримано успішно, "
"``False``, якщо ні."

msgid "The *timeout* parameter is new."
msgstr "Параметр *timeout* є новим."

msgid "Lock acquires can now be interrupted by signals on POSIX."
msgstr "Отримання блокування тепер може бути перервано сигналами на POSIX."

msgid ""
"Releases the lock.  The lock must have been acquired earlier, but not "
"necessarily by the same thread."
msgstr ""
"Звільняє замок. Замок повинен бути придбаний раніше, але не обов'язково за "
"тією ж ниткою."

msgid ""
"Return the status of the lock: ``True`` if it has been acquired by some "
"thread, ``False`` if not."
msgstr ""
"Повертає статус блокування: ``True``, якщо його було отримано якимось "
"потоком, ``False``, якщо ні."

msgid ""
"In addition to these methods, lock objects can also be used via the :keyword:"
"`with` statement, e.g.::"
msgstr ""
"Окрім цих методів, об’єкти блокування також можна використовувати за "
"допомогою оператора :keyword:`with`, наприклад::"

msgid "**Caveats:**"
msgstr "**Застереження:**"

msgid ""
"Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt` "
"exception will be received by an arbitrary thread.  (When the :mod:`signal` "
"module is available, interrupts always go to the main thread.)"
msgstr ""
"Потоки дивно взаємодіють із перериваннями: виняткова ситуація :exc:"
"`KeyboardInterrupt` буде отримана довільним потоком. (Коли доступний модуль :"
"mod:`signal`, переривання завжди спрямовуються до основного потоку.)"

msgid ""
"Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is "
"equivalent to calling :func:`_thread.exit`."
msgstr ""
"Виклик :func:`sys.exit` або підвищення винятку :exc:`SystemExit` "
"еквівалентний виклику :func:`_thread.exit`."

msgid ""
"It is not possible to interrupt the :meth:`acquire` method on a lock --- "
"the :exc:`KeyboardInterrupt` exception will happen after the lock has been "
"acquired."
msgstr ""
"Неможливо перервати метод :meth:`acquire` під час блокування --- виняток :"
"exc:`KeyboardInterrupt` станеться після отримання блокування."

msgid ""
"When the main thread exits, it is system defined whether the other threads "
"survive.  On most systems, they are killed without executing :keyword:"
"`try` ... :keyword:`finally` clauses or executing object destructors."
msgstr ""
"Коли основний потік виходить, система визначає, чи виживуть інші потоки. У "
"більшості систем вони припиняються без виконання пропозицій :keyword:"
"`try` ... :keyword:`finally` або виконання деструкторів об’єктів."

msgid ""
"When the main thread exits, it does not do any of its usual cleanup (except "
"that :keyword:`try` ... :keyword:`finally` clauses are honored), and the "
"standard I/O files are not flushed."
msgstr ""
"Коли основний потік завершується, він не виконує жодного звичайного очищення "
"(окрім того, що враховуються пропозиції :keyword:`try` ... :keyword:"
"`finally`), а стандартні файли вводу/виводу не очищуються."
