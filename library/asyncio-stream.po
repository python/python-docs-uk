# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Streams"
msgstr "Потоки"

msgid "**Source code:** :source:`Lib/asyncio/streams.py`"
msgstr "**Вихідний код:** :source:`Lib/asyncio/streams.py`"

msgid ""
"Streams are high-level async/await-ready primitives to work with network "
"connections.  Streams allow sending and receiving data without using "
"callbacks or low-level protocols and transports."
msgstr ""
"Потоки — це високорівневі асинхронні/готові до очікування примітиви для "
"роботи з мережевими підключеннями. Потоки дозволяють надсилати й отримувати "
"дані без використання зворотних викликів або низькорівневих протоколів і "
"транспортів."

msgid "Here is an example of a TCP echo client written using asyncio streams::"
msgstr ""
"Ось приклад клієнта відлуння TCP, написаного з використанням асинхронних "
"потоків::"

msgid "See also the `Examples`_ section below."
msgstr "Дивіться також розділ `Examples`_ нижче."

msgid "Stream Functions"
msgstr "Потокові функції"

msgid ""
"The following top-level asyncio functions can be used to create and work "
"with streams:"
msgstr ""
"Наступні асинхронні функції верхнього рівня можна використовувати для "
"створення та роботи з потоками:"

msgid ""
"Establish a network connection and return a pair of ``(reader, writer)`` "
"objects."
msgstr ""
"Встановіть мережеве з’єднання та поверніть пару об’єктів ``(reader, "
"writer)``."

msgid ""
"The returned *reader* and *writer* objects are instances of :class:"
"`StreamReader` and :class:`StreamWriter` classes."
msgstr ""
"Повернені об’єкти *reader* і *writer* є екземплярами класів :class:"
"`StreamReader` і :class:`StreamWriter`."

msgid ""
"*limit* determines the buffer size limit used by the returned :class:"
"`StreamReader` instance.  By default the *limit* is set to 64 KiB."
msgstr ""
"*limit* визначає обмеження розміру буфера, який використовується повернутим "
"екземпляром :class:`StreamReader`. За замовчуванням *обмеження* встановлено "
"на 64 КБ."

msgid ""
"The rest of the arguments are passed directly to :meth:`loop."
"create_connection`."
msgstr ""
"Решта аргументів передаються безпосередньо до :meth:`loop.create_connection`."

msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Додано параметр *ssl_handshake_timeout*."

msgid "Added *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Додано параметри *happy_eyeballs_delay* і *interleave*."

msgid "Removed the *loop* parameter."
msgstr "Видалено параметр *loop*."

msgid "Start a socket server."
msgstr "Запустіть сервер сокетів."

msgid ""
"The *client_connected_cb* callback is called whenever a new client "
"connection is established.  It receives a ``(reader, writer)`` pair as two "
"arguments, instances of the :class:`StreamReader` and :class:`StreamWriter` "
"classes."
msgstr ""
"Зворотний виклик *client_connected_cb* викликається щоразу, коли "
"встановлюється нове підключення клієнта. Він отримує пару ``(reader, "
"writer)`` як два аргументи, екземпляри класів :class:`StreamReader` і :class:"
"`StreamWriter`."

msgid ""
"*client_connected_cb* can be a plain callable or a :ref:`coroutine function "
"<coroutine>`; if it is a coroutine function, it will be automatically "
"scheduled as a :class:`Task`."
msgstr ""
"*client_connected_cb* може бути простим викликом або :ref:`функцією "
"співпрограми <coroutine>`; якщо це функція співпрограми, вона буде "
"автоматично запланована як :class:`Task`."

msgid ""
"The rest of the arguments are passed directly to :meth:`loop.create_server`."
msgstr ""
"Решта аргументів передаються безпосередньо до :meth:`loop.create_server`."

msgid "Added the *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "Додано параметри *ssl_handshake_timeout* і *start_serving*."

msgid "Unix Sockets"
msgstr "Unix-сокети"

msgid ""
"Establish a Unix socket connection and return a pair of ``(reader, writer)``."
msgstr ""
"Встановіть з’єднання через сокет Unix і поверніть пару ``(reader, writer)``."

msgid "Similar to :func:`open_connection` but operates on Unix sockets."
msgstr "Подібно до :func:`open_connection`, але працює на сокетах Unix."

msgid "See also the documentation of :meth:`loop.create_unix_connection`."
msgstr "Дивіться також документацію :meth:`loop.create_unix_connection`."

msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Наявність <availability>`: Unix."

msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`"
msgstr ""
"Додано параметр *ssl_handshake_timeout*. Параметр *path* тепер може бути :"
"term:`path-like object`"

msgid "Start a Unix socket server."
msgstr "Запустіть сокет-сервер Unix."

msgid "Similar to :func:`start_server` but works with Unix sockets."
msgstr "Подібно до :func:`start_server`, але працює з сокетами Unix."

msgid "See also the documentation of :meth:`loop.create_unix_server`."
msgstr "Дивіться також документацію :meth:`loop.create_unix_server`."

msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :term:`path-like object`."
msgstr ""
"Додано параметри *ssl_handshake_timeout* і *start_serving*. Параметр *path* "
"тепер може бути :term:`path-like object`."

msgid "StreamReader"
msgstr "StreamReader"

msgid ""
"Represents a reader object that provides APIs to read data from the IO "
"stream."
msgstr ""
"Представляє об’єкт читача, який надає API для читання даних із потоку вводу-"
"виводу."

msgid ""
"It is not recommended to instantiate *StreamReader* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"Не рекомендується безпосередньо створювати екземпляри об’єктів "
"*StreamReader*; замість цього використовуйте :func:`open_connection` і :func:"
"`start_server`."

msgid ""
"Read up to *n* bytes.  If *n* is not provided, or set to ``-1``, read until "
"EOF and return all read bytes."
msgstr ""
"Прочитати до *n* байт. Якщо *n* не вказано або встановлено як ``-1``, читати "
"до EOF і повертати всі прочитані байти."

msgid ""
"If EOF was received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""
"Якщо було отримано EOF, а внутрішній буфер порожній, поверніть порожній "
"об’єкт ``bytes``."

msgid ""
"Read one line, where \"line\" is a sequence of bytes ending with ``\\n``."
msgstr ""
"Прочитати один рядок, де \"рядок\" — це послідовність байтів, що "
"закінчуються на ``\\n``."

msgid ""
"If EOF is received and ``\\n`` was not found, the method returns partially "
"read data."
msgstr ""
"Якщо EOF отримано, а ``\\n`` не знайдено, метод повертає частково прочитані "
"дані."

msgid ""
"If EOF is received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""
"Якщо EOF отримано, а внутрішній буфер порожній, поверніть порожній об’єкт "
"``bytes``."

msgid "Read exactly *n* bytes."
msgstr "Прочитайте рівно *n* байт."

msgid ""
"Raise an :exc:`IncompleteReadError` if EOF is reached before *n* can be "
"read.  Use the :attr:`IncompleteReadError.partial` attribute to get the "
"partially read data."
msgstr ""
"Викликати :exc:`IncompleteReadError`, якщо EOF досягнуто до того, як *n* "
"можна буде прочитати. Використовуйте атрибут :attr:`IncompleteReadError."
"partial`, щоб отримати частково прочитані дані."

msgid "Read data from the stream until *separator* is found."
msgstr "Читати дані з потоку, доки не буде знайдено *роздільник*."

msgid ""
"On success, the data and separator will be removed from the internal buffer "
"(consumed). Returned data will include the separator at the end."
msgstr ""
"У разі успіху дані та роздільник буде видалено з внутрішнього буфера "
"(використано). Повернуті дані включатимуть роздільник у кінці."

msgid ""
"If the amount of data read exceeds the configured stream limit, a :exc:"
"`LimitOverrunError` exception is raised, and the data is left in the "
"internal buffer and can be read again."
msgstr ""
"Якщо обсяг зчитаних даних перевищує налаштований ліміт потоку, виникає "
"виняток :exc:`LimitOverrunError`, і дані залишаються у внутрішньому буфері "
"та можуть бути прочитані знову."

msgid ""
"If EOF is reached before the complete separator is found, an :exc:"
"`IncompleteReadError` exception is raised, and the internal buffer is "
"reset.  The :attr:`IncompleteReadError.partial` attribute may contain a "
"portion of the separator."
msgstr ""
"Якщо EOF досягнуто до того, як знайдено повний роздільник, виникає виняток :"
"exc:`IncompleteReadError`, і внутрішній буфер скидається. Атрибут :attr:"
"`IncompleteReadError.partial` може містити частину роздільника."

msgid "Return ``True`` if the buffer is empty and :meth:`feed_eof` was called."
msgstr ""
"Повертає ``True``, якщо буфер порожній і було викликано :meth:`feed_eof`."

msgid "StreamWriter"
msgstr "StreamWriter"

msgid ""
"Represents a writer object that provides APIs to write data to the IO stream."
msgstr ""
"Представляє об’єкт запису, який надає API для запису даних у потік вводу-"
"виводу."

msgid ""
"It is not recommended to instantiate *StreamWriter* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"Не рекомендується безпосередньо створювати екземпляри об’єктів "
"*StreamWriter*; замість цього використовуйте :func:`open_connection` і :func:"
"`start_server`."

msgid ""
"The method attempts to write the *data* to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"Метод намагається негайно записати *дані* в основний сокет. Якщо це не "
"вдається, дані ставляться в чергу у внутрішній буфер запису, доки їх не буде "
"надіслано."

msgid "The method should be used along with the ``drain()`` method::"
msgstr "Цей метод слід використовувати разом із методом ``drain()``:"

msgid ""
"The method writes a list (or any iterable) of bytes to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"Метод негайно записує список (або будь-яку ітерацію) байтів у базовий сокет. "
"Якщо це не вдається, дані ставляться в чергу у внутрішній буфер запису, доки "
"їх не буде надіслано."

msgid "The method closes the stream and the underlying socket."
msgstr "Метод закриває потік і базовий сокет."

msgid "The method should be used along with the ``wait_closed()`` method::"
msgstr "Цей метод слід використовувати разом із методом ``wait_closed()``:"

msgid ""
"Return ``True`` if the underlying transport supports the :meth:`write_eof` "
"method, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо основний транспорт підтримує метод :meth:"
"`write_eof`, ``False`` інакше."

msgid ""
"Close the write end of the stream after the buffered write data is flushed."
msgstr ""
"Закрийте кінець запису потоку після очищення буферизованих даних запису."

msgid "Return the underlying asyncio transport."
msgstr "Повернути базовий асинхронний транспорт."

msgid ""
"Access optional transport information; see :meth:`BaseTransport."
"get_extra_info` for details."
msgstr ""
"Доступ до додаткової транспортної інформації; подробиці див. :meth:"
"`BaseTransport.get_extra_info`."

msgid "Wait until it is appropriate to resume writing to the stream. Example::"
msgstr "Зачекайте, доки буде прийнятно продовжити запис у потік. Приклад::"

msgid ""
"This is a flow control method that interacts with the underlying IO write "
"buffer.  When the size of the buffer reaches the high watermark, *drain()* "
"blocks until the size of the buffer is drained down to the low watermark and "
"writing can be resumed.  When there is nothing to wait for, the :meth:"
"`drain` returns immediately."
msgstr ""
"Це метод керування потоком, який взаємодіє з базовим буфером запису вводу-"
"виводу. Коли розмір буфера досягає верхнього водяного знака, *drain()* "
"блокує, доки розмір буфера не зменшиться до низького водяного знака, і запис "
"можна буде відновити. Коли нема чого чекати, :meth:`drain` повертається "
"негайно."

msgid ""
"Return ``True`` if the stream is closed or in the process of being closed."
msgstr ""
"Повертає ``True``, якщо потік закрито або знаходиться в процесі закриття."

msgid "Wait until the stream is closed."
msgstr "Зачекайте, поки потік закриється."

msgid ""
"Should be called after :meth:`close` to wait until the underlying connection "
"is closed."
msgstr ""
"Має викликатися після :meth:`close`, щоб дочекатися, поки базове з’єднання "
"буде закрито."

msgid "Examples"
msgstr "Приклади"

msgid "TCP echo client using streams"
msgstr "TCP echo client використовує потоки"

msgid "TCP echo client using the :func:`asyncio.open_connection` function::"
msgstr ""
"TCP-клієнт відлуння за допомогою функції :func:`asyncio.open_connection`::"

msgid ""
"The :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` example uses the low-level :meth:"
"`loop.create_connection` method."
msgstr ""
"У прикладі :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` використовується метод низького "
"рівня :meth:`loop.create_connection`."

msgid "TCP echo server using streams"
msgstr "Сервер відлуння TCP з використанням потоків"

msgid "TCP echo server using the :func:`asyncio.start_server` function::"
msgstr ""
"Сервер відлуння TCP за допомогою функції :func:`asyncio.start_server`::"

msgid ""
"The :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` example uses the :meth:`loop."
"create_server` method."
msgstr ""
"У прикладі :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` використовується метод :meth:"
"`loop.create_server`."

msgid "Get HTTP headers"
msgstr "Отримайте заголовки HTTP"

msgid ""
"Simple example querying HTTP headers of the URL passed on the command line::"
msgstr ""
"Простий приклад запиту HTTP-заголовків URL-адреси, переданої в командному "
"рядку::"

msgid "Usage::"
msgstr "Використання::"

msgid "or with HTTPS::"
msgstr "або з HTTPS::"

msgid "Register an open socket to wait for data using streams"
msgstr "Зареєструйте відкритий сокет для очікування даних за допомогою потоків"

msgid ""
"Coroutine waiting until a socket receives data using the :func:"
"`open_connection` function::"
msgstr ""
"Співпрограма очікує, доки сокет не отримає дані за допомогою функції :func:"
"`open_connection`::"

msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` example uses a low-level protocol and "
"the :meth:`loop.create_connection` method."
msgstr ""
"У прикладі :ref:`реєструвати відкритий сокет для очікування даних за "
"допомогою протоколу <asyncio_example_create_connection>` використовується "
"протокол низького рівня та метод :meth:`loop.create_connection`."

msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to watch a file descriptor."
msgstr ""
"У прикладі :ref:`спостерігати за подіями читання файлового дескриптора "
"<asyncio_example_watch_fd>` використовується низькорівневий метод :meth:"
"`loop.add_reader` для спостереження за файловим дескриптором."
