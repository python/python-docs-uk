# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`operator` --- Standard operators as functions"
msgstr ":mod:`operator` --- Стандартні оператори як функції"

msgid "**Source code:** :source:`Lib/operator.py`"
msgstr "**Вихідний код:** :source:`Lib/operator.py`"

msgid ""
"The :mod:`operator` module exports a set of efficient functions "
"corresponding to the intrinsic operators of Python.  For example, ``operator."
"add(x, y)`` is equivalent to the expression ``x+y``. Many function names are "
"those used for special methods, without the double underscores.  For "
"backward compatibility, many of these have a variant with the double "
"underscores kept. The variants without the double underscores are preferred "
"for clarity."
msgstr ""
"Модуль :mod:`operator` експортує набір ефективних функцій, що відповідають "
"внутрішнім операторам Python. Наприклад, ``operator.add(x, y)`` "
"еквівалентний виразу ``x+y``. Багато назв функцій використовуються для "
"спеціальних методів без подвійного підкреслення. Для зворотної сумісності "
"багато з них мають варіант із збереженням подвійного підкреслення. Варіанти "
"без подвійного підкреслення є кращими для ясності."

msgid ""
"The functions fall into categories that perform object comparisons, logical "
"operations, mathematical operations and sequence operations."
msgstr ""
"Функції поділяються на категорії, які виконують порівняння об’єктів, логічні "
"операції, математичні операції та операції послідовності."

msgid ""
"The object comparison functions are useful for all objects, and are named "
"after the rich comparison operators they support:"
msgstr ""
"Функції порівняння об’єктів корисні для всіх об’єктів і названі на честь "
"розширених операторів порівняння, які вони підтримують:"

msgid ""
"Perform \"rich comparisons\" between *a* and *b*. Specifically, ``lt(a, b)`` "
"is equivalent to ``a < b``, ``le(a, b)`` is equivalent to ``a <= b``, "
"``eq(a, b)`` is equivalent to ``a == b``, ``ne(a, b)`` is equivalent to ``a !"
"= b``, ``gt(a, b)`` is equivalent to ``a > b`` and ``ge(a, b)`` is "
"equivalent to ``a >= b``.  Note that these functions can return any value, "
"which may or may not be interpretable as a Boolean value.  See :ref:"
"`comparisons` for more information about rich comparisons."
msgstr ""
"Виконайте \"багаті порівняння\" між *a* і *b*. Зокрема, ``lt(a, b)`` "
"еквівалентно ``a < b``, ``le(a, b)`` is equivalent to ``a <= b``, ``eq(a, "
"b)`` is equivalent to ``a == b``, ``ne(a, b)`` is equivalent to ``a != b``, "
"``gt(a, b)`` is equivalent to ``a > b``, а ``ge(a, b)`` еквівалентно ``a >= "
"b``. Зауважте, що ці функції можуть повертати будь-яке значення, яке може "
"інтерпретуватися як логічне значення. Перегляньте :ref:`comparisons` для "
"отримання додаткової інформації про розширені порівняння."

msgid ""
"The logical operations are also generally applicable to all objects, and "
"support truth tests, identity tests, and boolean operations:"
msgstr ""
"Логічні операції також зазвичай застосовуються до всіх об’єктів і "
"підтримують тести істинності, перевірки ідентичності та логічні операції:"

msgid ""
"Return the outcome of :keyword:`not` *obj*.  (Note that there is no :meth:"
"`__not__` method for object instances; only the interpreter core defines "
"this operation.  The result is affected by the :meth:`__bool__` and :meth:"
"`__len__` methods.)"
msgstr ""
"Повертає результат :keyword:`not` *obj*. (Зверніть увагу, що немає методу :"
"meth:`__not__` для екземплярів об’єктів; лише ядро інтерпретатора визначає "
"цю операцію. На результат впливають методи :meth:`__bool__` і :meth:"
"`__len__`.)"

msgid ""
"Return :const:`True` if *obj* is true, and :const:`False` otherwise.  This "
"is equivalent to using the :class:`bool` constructor."
msgstr ""
"Повертає :const:`True`, якщо *obj* має значення true, і :const:`False` в "
"іншому випадку. Це еквівалентно використанню конструктора :class:`bool`."

msgid "Return ``a is b``.  Tests object identity."
msgstr "Повернути ``a is b``. Перевіряє ідентичність об'єкта."

msgid "Return ``a is not b``.  Tests object identity."
msgstr "Повернути ``a не є b``. Перевіряє ідентичність об'єкта."

msgid "The mathematical and bitwise operations are the most numerous:"
msgstr "Найбільш численні математичні та порозрядні операції:"

msgid "Return the absolute value of *obj*."
msgstr "Повертає абсолютне значення *obj*."

msgid "Return ``a + b``, for *a* and *b* numbers."
msgstr "Повертає ``a + b`` для чисел *a* і *b*."

msgid "Return the bitwise and of *a* and *b*."
msgstr "Повертає побітове і для *a* і *b*."

msgid "Return ``a // b``."
msgstr "Повернути ``a // b``."

msgid "Return *a* converted to an integer.  Equivalent to ``a.__index__()``."
msgstr ""
"Повернути *a*, перетворене на ціле число. Еквівалент ``a.__index__()``."

msgid ""
"The result always has exact type :class:`int`.  Previously, the result could "
"have been an instance of a subclass of ``int``."
msgstr ""
"Результат завжди має точний тип :class:`int`. Раніше результат міг бути "
"екземпляром підкласу ``int``."

msgid ""
"Return the bitwise inverse of the number *obj*.  This is equivalent to "
"``~obj``."
msgstr "Повертає побітове обернення числа *obj*. Це еквівалентно ``~obj``."

msgid "Return *a* shifted left by *b*."
msgstr "Повернути *a* зі зсувом вліво на *b*."

msgid "Return ``a % b``."
msgstr "Повернути ``a % b``."

msgid "Return ``a * b``, for *a* and *b* numbers."
msgstr "Повертає ``a * b`` для чисел *a* і *b*."

msgid "Return ``a @ b``."
msgstr "Повернути ``a @ b``."

msgid "Return *obj* negated (``-obj``)."
msgstr "Повернути *obj* відхилено (``-obj``)."

msgid "Return the bitwise or of *a* and *b*."
msgstr "Повертає побітове або *a* і *b*."

msgid "Return *obj* positive (``+obj``)."
msgstr "Повертає *obj* позитивний (``+obj``)."

msgid "Return ``a ** b``, for *a* and *b* numbers."
msgstr "Повертає ``a ** b`` для чисел *a* і *b*."

msgid "Return *a* shifted right by *b*."
msgstr "Повернути *a* зі зсувом вправо на *b*."

msgid "Return ``a - b``."
msgstr "Повернути ``a - b``."

msgid ""
"Return ``a / b`` where 2/3 is .66 rather than 0.  This is also known as "
"\"true\" division."
msgstr ""
"Повертає ``a / b``, де 2/3 дорівнює 0,66, а не 0. Це також відоме як "
"\"справжнє\" ділення."

msgid "Return the bitwise exclusive or of *a* and *b*."
msgstr "Повертає порозрядне виключне або *a* і *b*."

msgid ""
"Operations which work with sequences (some of them with mappings too) "
"include:"
msgstr ""
"Операції, які працюють із послідовностями (деякі з них також із "
"відображеннями), включають:"

msgid "Return ``a + b`` for *a* and *b* sequences."
msgstr "Повертає ``a + b`` для послідовностей *a* і *b*."

msgid "Return the outcome of the test ``b in a``. Note the reversed operands."
msgstr ""
"Повертає результат тесту ``b в a``. Зверніть увагу на зворотні операнди."

msgid "Return the number of occurrences of *b* in *a*."
msgstr "Повертає кількість входжень *b* у *a*."

msgid "Remove the value of *a* at index *b*."
msgstr "Видалити значення *a* в індексі *b*."

msgid "Return the value of *a* at index *b*."
msgstr "Повертає значення *a* за індексом *b*."

msgid "Return the index of the first of occurrence of *b* in *a*."
msgstr "Повертає індекс першого входження *b* в *a*."

msgid "Set the value of *a* at index *b* to *c*."
msgstr "Установіть значення *a* в індексі *b* на *c*."

msgid ""
"Return an estimated length for the object *o*. First try to return its "
"actual length, then an estimate using :meth:`object.__length_hint__`, and "
"finally return the default value."
msgstr ""
"Повертає приблизну довжину об’єкта *o*. Спочатку спробуйте повернути його "
"фактичну довжину, потім оцінку за допомогою :meth:`object.__length_hint__` "
"і, нарешті, поверніть значення за замовчуванням."

msgid ""
"The :mod:`operator` module also defines tools for generalized attribute and "
"item lookups.  These are useful for making fast field extractors as "
"arguments for :func:`map`, :func:`sorted`, :meth:`itertools.groupby`, or "
"other functions that expect a function argument."
msgstr ""
"Модуль :mod:`operator` також визначає інструменти для узагальненого пошуку "
"атрибутів і елементів. Вони корисні для створення швидких екстракторів полів "
"як аргументів для :func:`map`, :func:`sorted`, :meth:`itertools.groupby` або "
"інших функцій, які очікують аргумент функції."

msgid ""
"Return a callable object that fetches *attr* from its operand. If more than "
"one attribute is requested, returns a tuple of attributes. The attribute "
"names can also contain dots. For example:"
msgstr ""
"Повертає викликаний об’єкт, який отримує *attr* зі свого операнда. Якщо "
"запитується більше ніж один атрибут, повертає кортеж атрибутів. Назви "
"атрибутів також можуть містити крапки. Наприклад:"

msgid "After ``f = attrgetter('name')``, the call ``f(b)`` returns ``b.name``."
msgstr "Після ``f = attrgetter('name')`` виклик ``f(b)`` повертає ``b.name``."

msgid ""
"After ``f = attrgetter('name', 'date')``, the call ``f(b)`` returns ``(b."
"name, b.date)``."
msgstr ""
"Після ``f = attrgetter('name', 'date')`` виклик ``f(b)`` повертає ``(b.name, "
"b.date)``."

msgid ""
"After ``f = attrgetter('name.first', 'name.last')``, the call ``f(b)`` "
"returns ``(b.name.first, b.name.last)``."
msgstr ""
"Після ``f = attrgetter('name.first', 'name.last')`` виклик ``f(b)`` повертає "
"``(b.name.first, b.name.last)`` ."

msgid "Equivalent to::"
msgstr "Дорівнює::"

msgid ""
"Return a callable object that fetches *item* from its operand using the "
"operand's :meth:`__getitem__` method.  If multiple items are specified, "
"returns a tuple of lookup values.  For example:"
msgstr ""
"Повертає викликаний об’єкт, який отримує *item* зі свого операнда за "
"допомогою методу :meth:`__getitem__` операнда. Якщо вказано кілька "
"елементів, повертає кортеж значень пошуку. Наприклад:"

msgid "After ``f = itemgetter(2)``, the call ``f(r)`` returns ``r[2]``."
msgstr "Після ``f = itemgetter(2)`` виклик ``f(r)`` повертає ``r[2]``."

msgid ""
"After ``g = itemgetter(2, 5, 3)``, the call ``g(r)`` returns ``(r[2], r[5], "
"r[3])``."
msgstr ""
"Після ``g = itemgetter(2, 5, 3)`` виклик ``g(r)`` повертає ``(r[2], r[5], "
"r[3])``."

msgid ""
"The items can be any type accepted by the operand's :meth:`__getitem__` "
"method.  Dictionaries accept any hashable value.  Lists, tuples, and strings "
"accept an index or a slice:"
msgstr ""
"Елементи можуть бути будь-якого типу, прийнятного методом :meth:"
"`__getitem__` операнда. Словники приймають будь-які хешовані значення. "
"Списки, кортежі та рядки приймають індекс або зріз:"

msgid ""
"Example of using :func:`itemgetter` to retrieve specific fields from a tuple "
"record:"
msgstr ""
"Приклад використання :func:`itemgetter` для отримання певних полів із запису "
"кортежу:"

msgid ""
"Return a callable object that calls the method *name* on its operand.  If "
"additional arguments and/or keyword arguments are given, they will be given "
"to the method as well.  For example:"
msgstr ""
"Повертає викликаний об’єкт, який викликає метод *ім’я* свого операнда. Якщо "
"надано додаткові аргументи та/або ключові аргументи, вони також будуть "
"надані методу. Наприклад:"

msgid ""
"After ``f = methodcaller('name')``, the call ``f(b)`` returns ``b.name()``."
msgstr ""
"Після ``f = methodcaller('name')`` виклик ``f(b)`` повертає ``b.name()``."

msgid ""
"After ``f = methodcaller('name', 'foo', bar=1)``, the call ``f(b)`` returns "
"``b.name('foo', bar=1)``."
msgstr ""
"Після ``f = methodcaller('name', 'foo', bar=1)`` виклик ``f(b)`` повертає "
"``b.name('foo', bar=1)``."

msgid "Mapping Operators to Functions"
msgstr "Відображення операторів у функції"

msgid ""
"This table shows how abstract operations correspond to operator symbols in "
"the Python syntax and the functions in the :mod:`operator` module."
msgstr ""
"У цій таблиці показано, як абстрактні операції відповідають символам "
"операторів у синтаксисі Python і функціям у модулі :mod:`operator`."

msgid "Operation"
msgstr "Операція"

msgid "Syntax"
msgstr "Синтаксис"

msgid "Function"
msgstr "функція"

msgid "Addition"
msgstr "Доповнення"

msgid "``a + b``"
msgstr "``a + b``"

msgid "``add(a, b)``"
msgstr "``add(a, b)``"

msgid "Concatenation"
msgstr "Конкатенація"

msgid "``seq1 + seq2``"
msgstr "``seq1 + seq2``"

msgid "``concat(seq1, seq2)``"
msgstr "``concat(seq1, seq2)``"

msgid "Containment Test"
msgstr "Тест на утримання"

msgid "``obj in seq``"
msgstr "``obj in seq``"

msgid "``contains(seq, obj)``"
msgstr "``contains(seq, obj)``"

msgid "Division"
msgstr "Поділ"

msgid "``a / b``"
msgstr "``a / b``"

msgid "``truediv(a, b)``"
msgstr "``truediv(a, b)``"

msgid "``a // b``"
msgstr "``a // b``"

msgid "``floordiv(a, b)``"
msgstr "``floordiv(a, b)``"

msgid "Bitwise And"
msgstr "Порозрядне І"

msgid "``a & b``"
msgstr "``а і б``"

msgid "``and_(a, b)``"
msgstr "``і_(a, b)``"

msgid "Bitwise Exclusive Or"
msgstr "Порозрядне виняткове або"

msgid "``a ^ b``"
msgstr "``a ^ b``"

msgid "``xor(a, b)``"
msgstr "``xor(a, b)``"

msgid "Bitwise Inversion"
msgstr "Побітова інверсія"

msgid "``~ a``"
msgstr "``~ a``"

msgid "``invert(a)``"
msgstr "``invert(a)``"

msgid "Bitwise Or"
msgstr "Побітове або"

msgid "``a | b``"
msgstr "``a | b``"

msgid "``or_(a, b)``"
msgstr "``або_(a, b)``"

msgid "Exponentiation"
msgstr "Піднесення до степеня"

msgid "``a ** b``"
msgstr "``a ** b``"

msgid "``pow(a, b)``"
msgstr "``pow(a, b)``"

msgid "Identity"
msgstr "Ідентичність"

msgid "``a is b``"
msgstr "``a є b``"

msgid "``is_(a, b)``"
msgstr "``is_(a, b)``"

msgid "``a is not b``"
msgstr "``a не є b``"

msgid "``is_not(a, b)``"
msgstr "``is_not(a, b)``"

msgid "Indexed Assignment"
msgstr "Індексоване призначення"

msgid "``obj[k] = v``"
msgstr "``obj[k] = v``"

msgid "``setitem(obj, k, v)``"
msgstr "``setitem(obj, k, v)``"

msgid "Indexed Deletion"
msgstr "Індексоване видалення"

msgid "``del obj[k]``"
msgstr "``del obj[k]``"

msgid "``delitem(obj, k)``"
msgstr "``виділення(obj, k)``"

msgid "Indexing"
msgstr "Індексація"

msgid "``obj[k]``"
msgstr "``obj[k]``"

msgid "``getitem(obj, k)``"
msgstr "``getitem(obj, k)``"

msgid "Left Shift"
msgstr "Ліворуч"

msgid "``a << b``"
msgstr "``a << b``"

msgid "``lshift(a, b)``"
msgstr "``lshift(a, b)``"

msgid "Modulo"
msgstr "Модуло"

msgid "``a % b``"
msgstr "``a % b``"

msgid "``mod(a, b)``"
msgstr "``mod(a, b)``"

msgid "Multiplication"
msgstr "Множення"

msgid "``a * b``"
msgstr "``a * b``"

msgid "``mul(a, b)``"
msgstr "``mul(a, b)``"

msgid "Matrix Multiplication"
msgstr "Множення матриць"

msgid "``a @ b``"
msgstr "``a @ b``"

msgid "``matmul(a, b)``"
msgstr "``matmul(a, b)``"

msgid "Negation (Arithmetic)"
msgstr "Заперечення (арифметика)"

msgid "``- a``"
msgstr "``- a``"

msgid "``neg(a)``"
msgstr "``neg(a)``"

msgid "Negation (Logical)"
msgstr "Заперечення (логічне)"

msgid "``not a``"
msgstr "``не``"

msgid "``not_(a)``"
msgstr "``not_(a)``"

msgid "Positive"
msgstr "Позитивний"

msgid "``+ a``"
msgstr "``+ a``"

msgid "``pos(a)``"
msgstr "``pos(a)``"

msgid "Right Shift"
msgstr "Правий Shift"

msgid "``a >> b``"
msgstr "``a >> b``"

msgid "``rshift(a, b)``"
msgstr "``rshift(a, b)``"

msgid "Slice Assignment"
msgstr "Призначення фрагмента"

msgid "``seq[i:j] = values``"
msgstr "``seq[i:j] = значення``"

msgid "``setitem(seq, slice(i, j), values)``"
msgstr "``setitem(seq, slice(i, j), values)``"

msgid "Slice Deletion"
msgstr "Видалення фрагмента"

msgid "``del seq[i:j]``"
msgstr "``del seq[i:j]``"

msgid "``delitem(seq, slice(i, j))``"
msgstr "``delitem(seq, slice(i, j))``"

msgid "Slicing"
msgstr "Нарізка"

msgid "``seq[i:j]``"
msgstr "``seq[i:j]``"

msgid "``getitem(seq, slice(i, j))``"
msgstr "``getitem(seq, slice(i, j))``"

msgid "String Formatting"
msgstr "Форматування рядка"

msgid "``s % obj``"
msgstr "``s % obj``"

msgid "``mod(s, obj)``"
msgstr "``mod(s, obj)``"

msgid "Subtraction"
msgstr "Віднімання"

msgid "``a - b``"
msgstr "``а - б``"

msgid "``sub(a, b)``"
msgstr "``під(a, b)``"

msgid "Truth Test"
msgstr "Тест на правду"

msgid "``obj``"
msgstr "``obj``"

msgid "``truth(obj)``"
msgstr "``truth(obj)``"

msgid "Ordering"
msgstr "Замовлення"

msgid "``a < b``"
msgstr "``a < b``"

msgid "``lt(a, b)``"
msgstr "``lt(a, b)``"

msgid "``a <= b``"
msgstr "``a <= b``"

msgid "``le(a, b)``"
msgstr "``le(a, b)``"

msgid "Equality"
msgstr "Рівність"

msgid "``a == b``"
msgstr "``a == b``"

msgid "``eq(a, b)``"
msgstr "``eq(a, b)``"

msgid "Difference"
msgstr "Різниця"

msgid "``a != b``"
msgstr "``a != b``"

msgid "``ne(a, b)``"
msgstr "``ne(a, b)``"

msgid "``a >= b``"
msgstr "``a >= b``"

msgid "``ge(a, b)``"
msgstr "``ge(a, b)``"

msgid "``a > b``"
msgstr "``a > b``"

msgid "``gt(a, b)``"
msgstr "``gt(a, b)``"

msgid "In-place Operators"
msgstr "Оператори на місці"

msgid ""
"Many operations have an \"in-place\" version.  Listed below are functions "
"providing a more primitive access to in-place operators than the usual "
"syntax does; for example, the :term:`statement` ``x += y`` is equivalent to "
"``x = operator.iadd(x, y)``.  Another way to put it is to say that ``z = "
"operator.iadd(x, y)`` is equivalent to the compound statement ``z = x; z += "
"y``."
msgstr ""
"Багато операцій мають версію \"на місці\". Нижче наведено функції, які "
"забезпечують примітивніший доступ до операторів на місці, ніж звичайний "
"синтаксис; наприклад, раз (:term:`statement`) ``x += y`` еквівалентний ``x = "
"operator.iadd(x, y)``. Інший спосіб сказати, що ``z = operator.iadd(x, y)`` "
"еквівалентно складеному оператору ``z = x; z += y``."

msgid ""
"In those examples, note that when an in-place method is called, the "
"computation and assignment are performed in two separate steps.  The in-"
"place functions listed below only do the first step, calling the in-place "
"method.  The second step, assignment, is not handled."
msgstr ""
"У цих прикладах зауважте, що під час виклику методу на місці обчислення та "
"призначення виконуються у два окремі кроки. Перелічені нижче функції на "
"місці виконують лише перший крок, викликаючи метод на місці. Другий крок, "
"призначення, не обробляється."

msgid ""
"For immutable targets such as strings, numbers, and tuples, the updated "
"value is computed, but not assigned back to the input variable:"
msgstr ""
"Для незмінних цілей, таких як рядки, числа та кортежі, оновлене значення "
"обчислюється, але не призначається назад вхідній змінній:"

msgid ""
"For mutable targets such as lists and dictionaries, the in-place method will "
"perform the update, so no subsequent assignment is necessary:"
msgstr ""
"Для змінних цілей, таких як списки та словники, метод на місці виконає "
"оновлення, тому подальше призначення не потрібне:"

msgid "``a = iadd(a, b)`` is equivalent to ``a += b``."
msgstr "``a = iadd(a, b)`` еквівалентно ``a += b``."

msgid "``a = iand(a, b)`` is equivalent to ``a &= b``."
msgstr "``a = iand(a, b)`` еквівалентно ``a &= b``."

msgid ""
"``a = iconcat(a, b)`` is equivalent to ``a += b`` for *a* and *b* sequences."
msgstr ""
"``a = iconcat(a, b)`` еквівалентно ``a += b`` для послідовностей *a* і *b*."

msgid "``a = ifloordiv(a, b)`` is equivalent to ``a //= b``."
msgstr "``a = ifloordiv(a, b)`` еквівалентно ``a //= b``."

msgid "``a = ilshift(a, b)`` is equivalent to ``a <<= b``."
msgstr "``a = ilshift(a, b)`` еквівалентно ``a <<= b``."

msgid "``a = imod(a, b)`` is equivalent to ``a %= b``."
msgstr "``a = imod(a, b)`` еквівалентно ``a %= b``."

msgid "``a = imul(a, b)`` is equivalent to ``a *= b``."
msgstr "``a = imul(a, b)`` еквівалентно ``a *= b``."

msgid "``a = imatmul(a, b)`` is equivalent to ``a @= b``."
msgstr "``a = imatmul(a, b)`` еквівалентно ``a @= b``."

msgid "``a = ior(a, b)`` is equivalent to ``a |= b``."
msgstr "``a = ior(a, b)`` еквівалентно ``a |= b``."

msgid "``a = ipow(a, b)`` is equivalent to ``a **= b``."
msgstr "``a = ipow(a, b)`` еквівалентно ``a **= b``."

msgid "``a = irshift(a, b)`` is equivalent to ``a >>= b``."
msgstr "``a = irshift(a, b)`` еквівалентно ``a >>= b``."

msgid "``a = isub(a, b)`` is equivalent to ``a -= b``."
msgstr "``a = isub(a, b)`` еквівалентно ``a -= b``."

msgid "``a = itruediv(a, b)`` is equivalent to ``a /= b``."
msgstr "``a = itruediv(a, b)`` еквівалентно ``a /= b``."

msgid "``a = ixor(a, b)`` is equivalent to ``a ^= b``."
msgstr "``a = ixor(a, b)`` еквівалентно ``a ^= b``."
