# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`collections` --- Container datatypes"
msgstr ":mod:`collections` --- Контейнерні типи даних"

msgid "**Source code:** :source:`Lib/collections/__init__.py`"
msgstr "**Вихідний код:** :source:`Lib/collections/__init__.py`"

msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:"
"`dict`, :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"Цей модуль реалізує спеціалізовані типи даних контейнерів, що є "
"альтернативою вбудованим контейнерам загального призначення Python, :class:"
"`dict`, :class:`list`, :class:`set` і :class:`tuple`."

msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

msgid "factory function for creating tuple subclasses with named fields"
msgstr "функція фабрики для створення підкласів кортежів з іменованими полями"

msgid ":class:`deque`"
msgstr ":class:`deque`"

msgid "list-like container with fast appends and pops on either end"
msgstr ""
"контейнер, схожий на список, із швидким додаванням і вискакуванням на обох "
"кінцях"

msgid ":class:`ChainMap`"
msgstr ":class:`ChainMap`"

msgid "dict-like class for creating a single view of multiple mappings"
msgstr "dict-подібний клас для створення єдиного перегляду кількох відображень"

msgid ":class:`Counter`"
msgstr ":class:`Counter`"

msgid "dict subclass for counting hashable objects"
msgstr "підклас dict для підрахунку хешованих об’єктів"

msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

msgid "dict subclass that remembers the order entries were added"
msgstr "підклас dict, який запам’ятовує додані записи порядку"

msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

msgid "dict subclass that calls a factory function to supply missing values"
msgstr ""
"підклас dict, який викликає фабричну функцію для надання відсутніх значень"

msgid ":class:`UserDict`"
msgstr ":class:`UserDict`"

msgid "wrapper around dictionary objects for easier dict subclassing"
msgstr ""
"обгортка навколо об’єктів словника для легшого створення підкласів dict"

msgid ":class:`UserList`"
msgstr ":class:`UserList`"

msgid "wrapper around list objects for easier list subclassing"
msgstr ""
"обгортка навколо об'єктів списку для легшого створення підкласів списку"

msgid ":class:`UserString`"
msgstr ":class:`UserString`"

msgid "wrapper around string objects for easier string subclassing"
msgstr ""
"обгортка навколо рядкових об'єктів для легшого створення підкласів рядків"

msgid ":class:`ChainMap` objects"
msgstr ":class:`ChainMap` об'єкти"

msgid ""
"A :class:`ChainMap` class is provided for quickly linking a number of "
"mappings so they can be treated as a single unit.  It is often much faster "
"than creating a new dictionary and running multiple :meth:`~dict.update` "
"calls."
msgstr ""
"Клас :class:`ChainMap` надається для швидкого зв’язування кількох "
"відображень, щоб їх можна було розглядати як єдине ціле. Часто це набагато "
"швидше, ніж створення нового словника та виконання кількох викликів :meth:"
"`~dict.update`."

msgid ""
"The class can be used to simulate nested scopes and is useful in templating."
msgstr ""
"Клас можна використовувати для імітації вкладених областей і корисний у "
"створенні шаблонів."

msgid ""
"A :class:`ChainMap` groups multiple dicts or other mappings together to "
"create a single, updateable view.  If no *maps* are specified, a single "
"empty dictionary is provided so that a new chain always has at least one "
"mapping."
msgstr ""
":class:`ChainMap` групує кілька dicts або інших відображень разом, щоб "
"створити єдине оновлюване подання. Якщо *maps* не вказано, надається єдиний "
"порожній словник, щоб новий ланцюжок завжди мав принаймні одне відображення."

msgid ""
"The underlying mappings are stored in a list.  That list is public and can "
"be accessed or updated using the *maps* attribute.  There is no other state."
msgstr ""
"Базові відображення зберігаються в списку. Цей список є загальнодоступним, і "
"до нього можна отримати доступ або оновити за допомогою атрибута *maps*. "
"Іншої держави немає."

msgid ""
"Lookups search the underlying mappings successively until a key is found.  "
"In contrast, writes, updates, and deletions only operate on the first "
"mapping."
msgstr ""
"Пошуки послідовно шукають базові відображення, доки не буде знайдено ключ. "
"Навпаки, записи, оновлення та видалення діють лише на першому відображенні."

msgid ""
"A :class:`ChainMap` incorporates the underlying mappings by reference.  So, "
"if one of the underlying mappings gets updated, those changes will be "
"reflected in :class:`ChainMap`."
msgstr ""
":class:`ChainMap` включає базові відображення за посиланням. Отже, якщо одне "
"з базових відображень буде оновлено, ці зміни буде відображено в :class:"
"`ChainMap`."

msgid ""
"All of the usual dictionary methods are supported.  In addition, there is a "
"*maps* attribute, a method for creating new subcontexts, and a property for "
"accessing all but the first mapping:"
msgstr ""
"Підтримуються всі звичайні словникові методи. Крім того, існує атрибут "
"*maps*, метод для створення нових підконтекстів і властивість для доступу до "
"всіх відображень, крім першого:"

msgid ""
"A user updateable list of mappings.  The list is ordered from first-searched "
"to last-searched.  It is the only stored state and can be modified to change "
"which mappings are searched.  The list should always contain at least one "
"mapping."
msgstr ""
"Список відображень, який можна оновлювати користувачем. Список упорядковано "
"від першого до останнього. Це єдиний стан, який зберігається, і його можна "
"змінити, щоб змінити зіставлення, які шукаються. Список завжди повинен "
"містити принаймні одне зіставлення."

msgid ""
"Returns a new :class:`ChainMap` containing a new map followed by all of the "
"maps in the current instance.  If ``m`` is specified, it becomes the new map "
"at the front of the list of mappings; if not specified, an empty dict is "
"used, so that a call to ``d.new_child()`` is equivalent to: ``ChainMap({}, "
"*d.maps)``. If any keyword arguments are specified, they update passed map "
"or new empty dict. This method is used for creating subcontexts that can be "
"updated without altering values in any of the parent mappings."
msgstr ""
"Повертає новий :class:`ChainMap`, який містить нову карту, за якою слідують "
"усі карти в поточному екземплярі. Якщо вказано ``m``, воно стає новою картою "
"на початку списку зіставлень; якщо не вказано, використовується порожній "
"dict, так що виклик ``d.new_child()`` еквівалентний: ``ChainMap({}, *d."
"maps)``. Якщо вказано будь-які аргументи ключового слова, вони оновлюють "
"передану карту або новий порожній dict. Цей метод використовується для "
"створення підконтекстів, які можна оновлювати без зміни значень у будь-якому "
"з батьківських відображень."

msgid "The optional ``m`` parameter was added."
msgstr "Додано необов’язковий параметр ``m``."

msgid "Keyword arguments support was added."
msgstr "Додано підтримку аргументів ключових слів."

msgid ""
"Property returning a new :class:`ChainMap` containing all of the maps in the "
"current instance except the first one.  This is useful for skipping the "
"first map in the search.  Use cases are similar to those for the :keyword:"
"`nonlocal` keyword used in :term:`nested scopes <nested scope>`.  The use "
"cases also parallel those for the built-in :func:`super` function.  A "
"reference to ``d.parents`` is equivalent to: ``ChainMap(*d.maps[1:])``."
msgstr ""
"Властивість, що повертає новий :class:`ChainMap`, що містить усі карти в "
"поточному екземплярі, крім першої. Це корисно для пропуску першої карти в "
"пошуку. Випадки використання схожі на випадки використання ключового слова :"
"keyword:`nonlocal`, що використовується у :term:`вкладених областях <nested "
"scope>`. Випадки використання також аналогічні використанню вбудованої "
"функції :func:`super`. Посилання на ``d.parents`` еквівалентне: "
"``ChainMap(*d.maps[1:])``."

msgid ""
"Note, the iteration order of a :class:`ChainMap()` is determined by scanning "
"the mappings last to first::"
msgstr ""
"Зауважте, що порядок ітерацій :class:`ChainMap()` визначається скануванням "
"зіставлення від останнього до першого::"

msgid ""
"This gives the same ordering as a series of :meth:`dict.update` calls "
"starting with the last mapping::"
msgstr ""
"Це дає такий самий порядок, як і серія викликів :meth:`dict.update`, "
"починаючи з останнього відображення::"

msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr "Додано підтримку операторів ``|`` і ``|=``, указаних у :pep:`584`."

msgid ""
"The `MultiContext class <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ in the Enthought `CodeTools package "
"<https://github.com/enthought/codetools>`_ has options to support writing to "
"any mapping in the chain."
msgstr ""
"`MultiContext class <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ у пакеті Enthought `CodeTools "
"<https://github.com/enthought/codetools>`_ має опції для підтримки запису в "
"будь-яке відображення в ланцюжку."

msgid ""
"Django's `Context class <https://github.com/django/django/blob/main/django/"
"template/context.py>`_ for templating is a read-only chain of mappings.  It "
"also features pushing and popping of contexts similar to the :meth:"
"`~collections.ChainMap.new_child` method and the :attr:`~collections."
"ChainMap.parents` property."
msgstr ""
"`Клас контексту Django <https://github.com/django/django/blob/main/django/"
"template/context.py>`_ для створення шаблонів — це ланцюжок відображень лише "
"для читання. Він також має функцію надсилання та витягування контекстів, "
"подібних до методу :meth:`~collections.ChainMap.new_child` і властивості :"
"attr:`~collections.ChainMap.parents`."

msgid ""
"The `Nested Contexts recipe <https://code.activestate.com/recipes/577434/>`_ "
"has options to control whether writes and other mutations apply only to the "
"first mapping or to any mapping in the chain."
msgstr ""
"`Рецепт вкладених контекстів <https://code.activestate.com/recipes/577434/"
">`_ має параметри для контролю того, чи застосовуються записи та інші зміни "
"лише до першого відображення чи до будь-якого відображення в ланцюжку."

msgid ""
"A `greatly simplified read-only version of Chainmap <https://code."
"activestate.com/recipes/305268/>`_."
msgstr ""
"`Значно спрощена версія Chainmap тільки для читання <https://code."
"activestate.com/recipes/305268/>`_."

msgid ":class:`ChainMap` Examples and Recipes"
msgstr ":class:`ChainMap` Приклади та рецепти"

msgid "This section shows various approaches to working with chained maps."
msgstr ""
"У цьому розділі показано різні підходи до роботи з ланцюжковими картами."

msgid "Example of simulating Python's internal lookup chain::"
msgstr "Приклад симуляції внутрішнього ланцюжка пошуку Python::"

msgid ""
"Example of letting user specified command-line arguments take precedence "
"over environment variables which in turn take precedence over default "
"values::"
msgstr ""
"Приклад надання переваги заданим користувачем аргументам командного рядка "
"над змінними середовища, які, у свою чергу, мають пріоритет над значеннями "
"за замовчуванням::"

msgid ""
"Example patterns for using the :class:`ChainMap` class to simulate nested "
"contexts::"
msgstr ""
"Приклади шаблонів використання класу :class:`ChainMap` для імітації "
"вкладених контекстів::"

msgid ""
"The :class:`ChainMap` class only makes updates (writes and deletions) to the "
"first mapping in the chain while lookups will search the full chain.  "
"However, if deep writes and deletions are desired, it is easy to make a "
"subclass that updates keys found deeper in the chain::"
msgstr ""
"Клас :class:`ChainMap` лише оновлює (записує та видаляє) перше відображення "
"в ланцюжку, тоді як пошук шукатиме повний ланцюжок. Однак, якщо потрібні "
"глибокі записи та видалення, легко створити підклас, який оновлює ключі, "
"знайдені глибше в ланцюжку:"

msgid ":class:`Counter` objects"
msgstr ":class:`Counter` об'єкти"

msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr ""
"Надається інструмент лічильника для зручного та швидкого підрахунку. "
"Наприклад::"

msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting hashable "
"objects. It is a collection where elements are stored as dictionary keys and "
"their counts are stored as dictionary values.  Counts are allowed to be any "
"integer value including zero or negative counts.  The :class:`Counter` class "
"is similar to bags or multisets in other languages."
msgstr ""
":class:`Counter` є підкласом :class:`dict` для підрахунку хешованих "
"об’єктів. Це колекція, де елементи зберігаються як словникові ключі, а їх "
"підрахунки зберігаються як словникові значення. Підрахунки можуть бути будь-"
"якими цілими значеннями, включаючи нульові чи від’ємні значення. Клас :class:"
"`Counter` схожий на сумки або мультимножини в інших мовах."

msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr ""
"Елементи підраховуються з *iterable* або ініціалізуються з іншого *mapping* "
"(або лічильника):"

msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"Об’єкти лічильників мають інтерфейс словника, за винятком того, що вони "
"повертають нульову кількість для відсутніх елементів замість того, щоб "
"викликати :exc:`KeyError`:"

msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr ""
"Встановлення лічильника на нуль не видаляє елемент із лічильника. "
"Використовуйте ``del``, щоб видалити його повністю:"

msgid ""
"As a :class:`dict` subclass, :class:`Counter` inherited the capability to "
"remember insertion order.  Math operations on *Counter* objects also "
"preserve order.  Results are ordered according to when an element is first "
"encountered in the left operand and then by the order encountered in the "
"right operand."
msgstr ""
"Як підклас :class:`dict`, :class:`Counter` успадкував можливість "
"запам’ятовувати порядок вставки. Математичні операції над об’єктами "
"*Counter* також зберігають порядок. Результати впорядковуються відповідно до "
"того, коли елемент вперше зустрічається в лівому операнді, а потім у порядку "
"зустрічі в правому операнді."

msgid ""
"Counter objects support additional methods beyond those available for all "
"dictionaries:"
msgstr ""
"Об’єкти лічильників підтримують додаткові методи, окрім тих, що доступні для "
"всіх словників:"

msgid ""
"Return an iterator over elements repeating each as many times as its count.  "
"Elements are returned in the order first encountered. If an element's count "
"is less than one, :meth:`elements` will ignore it."
msgstr ""
"Повертає ітератор над елементами, повторюючи кожен стільки разів, скільки "
"його кількість. Елементи повертаються в тому порядку, в якому вони "
"зустрічаються першими. Якщо кількість елемента менше одиниці, :meth:"
"`elements` проігнорує його."

msgid ""
"Return a list of the *n* most common elements and their counts from the most "
"common to the least.  If *n* is omitted or ``None``, :meth:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered in the order first encountered:"
msgstr ""
"Повертає список з *n* найпоширеніших елементів і їх підрахунок від найбільш "
"поширених до найменших. Якщо *n* пропущено або ``None``, :meth:`most_common` "
"повертає *всі* елементи в лічильнику. Елементи з рівною кількістю "
"впорядковуються в порядку, коли вони зустрічаються першими:"

msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"Елементи віднімаються з *iterable* або з іншого *mapping* (або лічильника). "
"Подібно до :meth:`dict.update`, але кількість віднімає, а не замінює. І "
"входи, і виходи можуть бути нульовими або негативними."

msgid "Compute the sum of the counts."
msgstr "Обчисліть суму підрахунків."

msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr ""
"Звичайні методи словника доступні для об’єктів :class:`Counter`, за винятком "
"двох, які працюють по-різному для лічильників."

msgid "This class method is not implemented for :class:`Counter` objects."
msgstr "Цей метод класу не реалізований для об’єктів :class:`Counter`."

msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing "
"them.  Also, the *iterable* is expected to be a sequence of elements, not a "
"sequence of ``(key, value)`` pairs."
msgstr ""
"Елементи підраховуються від *iterable* або add-in від іншого *mapping* (або "
"лічильника). Як :meth:`dict.update`, але додає лічильники замість їх заміни. "
"Крім того, очікується, що *iterable* буде послідовністю елементів, а не "
"послідовністю пар ``(ключ, значення)``."

msgid ""
"Counters support rich comparison operators for equality, subset, and "
"superset relationships: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. All of "
"those tests treat missing elements as having zero counts so that "
"``Counter(a=1) == Counter(a=1, b=0)`` returns true."
msgstr ""
"Лічильники підтримують розширені оператори порівняння для зв’язків рівності, "
"підмножини та надмножини: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. Усі "
"ці тести розглядають відсутні елементи як такі, що мають нульову кількість, "
"тому ``Counter(a=1) == Counter(a=1, b=0)`` повертає true."

msgid "Rich comparison operations were added."
msgstr "Додано розширені операції порівняння."

msgid ""
"In equality tests, missing elements are treated as having zero counts. "
"Formerly, ``Counter(a=3)`` and ``Counter(a=3, b=0)`` were considered "
"distinct."
msgstr ""
"У тестах на рівність відсутні елементи розглядаються як такі, що мають "
"нульову кількість. Раніше ``Counter(a=3)`` і ``Counter(a=3, b=0)`` вважалися "
"різними."

msgid "Common patterns for working with :class:`Counter` objects::"
msgstr "Загальні шаблони для роботи з об'єктами :class:`Counter`::"

msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum "
"and maximum of corresponding counts.  Equality and inclusion compare "
"corresponding counts.  Each operation can accept inputs with signed counts, "
"but the output will exclude results with counts of zero or less."
msgstr ""
"Передбачено кілька математичних операцій для об’єднання об’єктів :class:"
"`Counter` для створення мультимножин (лічильників, які мають кількість, "
"більшу за нуль). Додавання та віднімання поєднують лічильники шляхом "
"додавання або віднімання підрахунків відповідних елементів. Перетин і "
"об’єднання повертають мінімальне та максимальне значення відповідних "
"підрахунків. Рівність і включення порівнюють відповідні підрахунки. Кожна "
"операція може приймати вхідні дані зі знаком підрахунків, але вихід "
"виключатиме результати з нульовими чи меншими значеннями."

msgid ""
"Unary addition and subtraction are shortcuts for adding an empty counter or "
"subtracting from an empty counter."
msgstr ""
"Унарне додавання та віднімання — це ярлики для додавання порожнього "
"лічильника або віднімання з порожнього лічильника."

msgid ""
"Added support for unary plus, unary minus, and in-place multiset operations."
msgstr ""
"Додано підтримку унарних операцій плюс, унарний мінус і мультимножинних "
"операцій на місці."

msgid ""
"Counters were primarily designed to work with positive integers to represent "
"running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases, "
"this section documents the minimum range and type restrictions."
msgstr ""
"Лічильники були в основному розроблені для роботи з позитивними цілими "
"числами для представлення поточних підрахунків; однак було вжито заходів для "
"того, щоб без потреби не виключити випадки використання, які потребують "
"інших типів або від’ємних значень. Щоб допомогти з цими випадками "
"використання, у цьому розділі описані мінімальні обмеження діапазону та типу."

msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ""
"Сам клас :class:`Counter` є підкласом словника без обмежень щодо його ключів "
"і значень. Значення мають бути числами, що представляють кількість, але ви "
"*можете* зберігати будь-що в полі значення."

msgid ""
"The :meth:`~Counter.most_common` method requires only that the values be "
"orderable."
msgstr ""
"Метод :meth:`~Counter.most_common` вимагає лише того, щоб значення можна "
"було впорядкувати."

msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for :meth:"
"`~Counter.update` and :meth:`~Counter.subtract` which allow negative and "
"zero values for both inputs and outputs."
msgstr ""
"Для операцій на місці, таких як ``c[key] += 1``, тип значення потребує лише "
"підтримки додавання та віднімання. Отже, дроби, числа з плаваючою точкою та "
"десяткові дроби працюватимуть, а від’ємні значення підтримуються. Те ж саме "
"вірно для :meth:`~Counter.update` і :meth:`~Counter.subtract`, які "
"дозволяють від’ємні та нульові значення як для входів, так і для виходів."

msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr ""
"Мультимножинні методи призначені лише для випадків використання з "
"позитивними значеннями. Вхідні дані можуть бути від’ємними або нульовими, "
"але створюються лише виходи з позитивними значеннями. Немає обмежень щодо "
"типів, але тип значення має підтримувати додавання, віднімання та порівняння."

msgid ""
"The :meth:`~Counter.elements` method requires integer counts.  It ignores "
"zero and negative counts."
msgstr ""
"Метод :meth:`~Counter.elements` вимагає підрахунку цілих чисел. Він ігнорує "
"нульові та негативні значення."

msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag."
"html>`_ in Smalltalk."
msgstr ""
"`Клас сумки <https://www.gnu.org/software/smalltalk/manual-base/html_node/"
"Bag.html>`_ у Smalltalk."

msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr ""
"Запис у Вікіпедії для `Мультимножини <https://en.wikipedia.org/wiki/"
"Multiset>`_."

msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ посібник із прикладами."

msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr ""
"Про математичні операції над мультимножинами та випадки їх використання див. "
"*Knuth, Donald. Мистецтво комп’ютерного програмування, том II, розділ 4.6.3, "
"вправа 19*."

msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`::"
msgstr ""
"Щоб перерахувати всі різні мультимножини заданого розміру над заданим "
"набором елементів, перегляньте :func:`itertools."
"combinations_with_replacement`::"

msgid ":class:`deque` objects"
msgstr ":class:`deque` об'єкти"

msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""
"Повертає новий об’єкт deque, ініціалізований зліва направо (за допомогою :"
"meth:`append`) з даними з *iterable*. Якщо *iterable* не вказано, нова "
"двочерга порожня."

msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same O(1) performance in either direction."
msgstr ""
"Deques — це узагальнення стеків і черг (назва вимовляється як \"колода\" і є "
"скороченням від \"черга з двома кінцями\"). Deques підтримують "
"потокобезпечне, ефективне додавання та видалення з пам’яті з будь-якої "
"сторони deque з приблизно однаковою продуктивністю O(1) у будь-якому "
"напрямку."

msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur O(n) memory movement costs for "
"``pop(0)`` and ``insert(0, v)`` operations which change both the size and "
"position of the underlying data representation."
msgstr ""
"Хоча об’єкти :class:`list` підтримують подібні операції, вони оптимізовані "
"для швидких операцій із фіксованою довжиною та несуть O(n) витрат на "
"переміщення пам’яті для ``pop(0)`` та ``insert(0, v)`` операції, які "
"змінюють як розмір, так і положення основного представлення даних."

msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""
"Якщо *maxlen* не вказано або має значення ``None``, дві версії можуть "
"зростати до довільної довжини. В іншому випадку двочерга обмежена до "
"вказаної максимальної довжини. Коли двочерга обмеженої довжини заповнюється, "
"коли додаються нові елементи, відповідна кількість елементів відкидається з "
"протилежного кінця. Обмежена довжина двох рядків забезпечує "
"функціональність, подібну до фільтра ``tail`` в Unix. Вони також корисні для "
"відстеження транзакцій та інших наборів даних, де цікаві лише останні дії."

msgid "Deque objects support the following methods:"
msgstr "Об’єкти Deque підтримують такі методи:"

msgid "Add *x* to the right side of the deque."
msgstr "Додайте *x* до правої сторони дека."

msgid "Add *x* to the left side of the deque."
msgstr "Додайте *x* до лівої сторони дека."

msgid "Remove all elements from the deque leaving it with length 0."
msgstr "Видаліть усі елементи з двоканального ряду, залишивши його довжиною 0."

msgid "Create a shallow copy of the deque."
msgstr "Створіть поверхневу копію deque."

msgid "Count the number of deque elements equal to *x*."
msgstr "Підрахуйте кількість елементів deque, що дорівнює *x*."

msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""
"Розширте праву частину двоканального ряду, додавши елементи з ітерованого "
"аргументу."

msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""
"Розширте ліву сторону двостороннього коду, додавши елементи з *iterable*. "
"Зауважте, що серія лівих додань призводить до зміни порядку елементів у "
"повторюваному аргументі."

msgid ""
"Return the position of *x* in the deque (at or after index *start* and "
"before index *stop*).  Returns the first match or raises :exc:`ValueError` "
"if not found."
msgstr ""
"Повертає позицію *x* у черзі (за індексом *start* і перед індексом *stop*). "
"Повертає перший збіг або викликає :exc:`ValueError`, якщо не знайдено."

msgid "Insert *x* into the deque at position *i*."
msgstr "Вставте *x* у рядок у позицію *i*."

msgid ""
"If the insertion would cause a bounded deque to grow beyond *maxlen*, an :"
"exc:`IndexError` is raised."
msgstr ""
"Якщо вставка призведе до того, що обмежена двочерга виросте за межі "
"*maxlen*, виникає :exc:`IndexError`."

msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""
"Видаліть і поверніть елемент з правого боку двоканальної таблиці. Якщо немає "
"елементів, викликає :exc:`IndexError`."

msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""
"Видаліть і поверніть елемент з лівої сторони двосторонньої версії. Якщо "
"немає елементів, викликає :exc:`IndexError`."

msgid ""
"Remove the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""
"Видаліть перше входження *значення*. Якщо не знайдено, викликає :exc:"
"`ValueError`."

msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "Перевернути елементи дек-версії на місці, а потім повернути ``None``."

msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left."
msgstr ""
"Поверніть двічі *n* кроків праворуч. Якщо *n* від’ємне, поверніть ліворуч."

msgid ""
"When the deque is not empty, rotating one step to the right is equivalent to "
"``d.appendleft(d.pop())``, and rotating one step to the left is equivalent "
"to ``d.append(d.popleft())``."
msgstr ""
"Якщо двочерга не порожня, поворот на один крок праворуч еквівалентний d."
"appendleft(d.pop()) , а поворот на один крок ліворуч еквівалентний d."
"append(d.popleft ())``."

msgid "Deque objects also provide one read-only attribute:"
msgstr "Об’єкти Deque також надають один атрибут лише для читання:"

msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "Максимальний розмір двочергового рядка або ``None``, якщо необмежений."

msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as ``d[0]`` "
"to access the first element.  Indexed access is O(1) at both ends but slows "
"to O(n) in the middle.  For fast random access, use lists instead."
msgstr ""
"На додаток до вищезазначеного, deques підтримують ітерацію, травлення, "
"``len(d)``, ``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, "
"тестування членства за допомогою оператора :keyword:`in` і посилань на "
"підрядковий індекс, наприклад ``d[0]`` для доступу до першого елемента. "
"Індексований доступ становить O(1) на обох кінцях, але сповільнюється до "
"O(n) посередині. Для швидкого довільного доступу використовуйте натомість "
"списки."

msgid ""
"Starting in version 3.5, deques support ``__add__()``, ``__mul__()``, and "
"``__imul__()``."
msgstr ""
"Починаючи з версії 3.5, deques підтримують ``__add__()``, ``__mul__()`` і "
"``__imul__()``."

msgid "Example:"
msgstr "приклад:"

msgid ":class:`deque` Recipes"
msgstr ":class:`deque` Рецепти"

msgid "This section shows various approaches to working with deques."
msgstr "У цьому розділі показано різні підходи до роботи з deque."

msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""
"Обмежена довжина двостороннього ряду забезпечує функціональність, подібну до "
"фільтра ``tail`` в Unix::"

msgid ""
"Another approach to using deques is to maintain a sequence of recently added "
"elements by appending to the right and popping to the left::"
msgstr ""
"Інший підхід до використання двох блоків полягає в підтримці послідовності "
"нещодавно доданих елементів шляхом додавання праворуч і висування ліворуч:"

msgid ""
"A `round-robin scheduler <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ can be implemented with input iterators stored in a :"
"class:`deque`.  Values are yielded from the active iterator in position "
"zero.  If that iterator is exhausted, it can be removed with :meth:`~deque."
"popleft`; otherwise, it can be cycled back to the end with the :meth:`~deque."
"rotate` method::"
msgstr ""
"`Циклічний планувальник <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ може бути реалізований за допомогою ітераторів введення, "
"що зберігаються в :class:`deque`. Значення виводяться з активного ітератора "
"в нульовій позиції. Якщо цей ітератор вичерпано, його можна видалити за "
"допомогою :meth:`~deque.popleft`; інакше його можна повернути до кінця за "
"допомогою методу :meth:`~deque.rotate`::"

msgid ""
"The :meth:`~deque.rotate` method provides a way to implement :class:`deque` "
"slicing and deletion.  For example, a pure Python implementation of ``del "
"d[n]`` relies on the ``rotate()`` method to position elements to be popped::"
msgstr ""
"Метод :meth:`~deque.rotate` забезпечує спосіб реалізації :class:`deque` "
"нарізки та видалення. Наприклад, чиста реалізація ``del d[n]`` на Python "
"покладається на метод ``rotate()`` для позиціонування елементів, які "
"потрібно відкрити:"

msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`~deque.rotate` to bring a target element to the left side of the deque. "
"Remove old entries with :meth:`~deque.popleft`, add new entries with :meth:"
"`~deque.extend`, and then reverse the rotation. With minor variations on "
"that approach, it is easy to implement Forth style stack manipulations such "
"as ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""
"Щоб реалізувати нарізку :class:`deque`, скористайтеся подібним підходом, "
"застосовуючи :meth:`~deque.rotate`, щоб перемістити цільовий елемент у ліву "
"сторону від deque. Видаліть старі записи за допомогою :meth:`~deque."
"popleft`, додайте нові за допомогою :meth:`~deque.extend`, а потім змініть "
"чергування. З незначними варіаціями цього підходу легко реалізувати "
"маніпуляції стеком у стилі Forth, такі як ``dup``, ``drop``, ``swap``, "
"``over``, ``pick``, ``rot`` і ``roll``."

msgid ":class:`defaultdict` objects"
msgstr ":class:`defaultdict` об’єкти"

msgid ""
"Return a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""
"Повернути новий об’єкт, схожий на словник. :class:`defaultdict` є підкласом "
"вбудованого класу :class:`dict`. Він замінює один метод і додає одну змінну "
"екземпляра, доступну для запису. Інші функції такі ж, як і для класу :class:"
"`dict`, і тут не описані."

msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""
"Перший аргумент надає початкове значення для атрибута :attr:"
"`default_factory`; за замовчуванням ``None``. Усі решта аргументів "
"обробляються так само, як якщо б вони були передані конструктору :class:"
"`dict`, включаючи аргументи ключових слів."

msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""
"Об’єкти :class:`defaultdict` підтримують наступний метод на додаток до "
"стандартних операцій :class:`dict`:"

msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""
"Якщо атрибут :attr:`default_factory` має значення ``None``, це викликає "
"виключення :exc:`KeyError` з *key* як аргументом."

msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""
"Якщо :attr:`default_factory` не є ``None``, він викликається без аргументів, "
"щоб надати значення за замовчуванням для даного *ключа*, це значення "
"вставляється в словник для *ключа* та повертається."

msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""
"Якщо виклик :attr:`default_factory` викликає виняток, цей виняток "
"поширюється без змін."

msgid ""
"This method is called by the :meth:`__getitem__` method of the :class:`dict` "
"class when the requested key is not found; whatever it returns or raises is "
"then returned or raised by :meth:`__getitem__`."
msgstr ""
"Цей метод викликається методом :meth:`__getitem__` класу :class:`dict`, коли "
"запитуваний ключ не знайдено; все, що він повертає або викликає, потім "
"повертається або піднімається :meth:`__getitem__`."

msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides :"
"meth:`__getitem__`. This means that :meth:`get` will, like normal "
"dictionaries, return ``None`` as a default rather than using :attr:"
"`default_factory`."
msgstr ""
"Зауважте, що :meth:`__missing__` *не* викликається для будь-яких операцій, "
"крім :meth:`__getitem__`. Це означає, що :meth:`get`, як і звичайні "
"словники, повертатиме ``None`` за замовчуванням замість використання :attr:"
"`default_factory`."

msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr "Об’єкти :class:`defaultdict` підтримують таку змінну екземпляра:"

msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""
"Цей атрибут використовується методом :meth:`__missing__`; він "
"ініціалізується від першого аргументу до конструктора, якщо він присутній, "
"або до ``None``, якщо його немає."

msgid ""
"Added merge (``|``) and update (``|=``) operators, specified in :pep:`584`."
msgstr ""
"Додано оператори злиття (``|``) і оновлення (``|=``), указані в :pep:`584`."

msgid ":class:`defaultdict` Examples"
msgstr ":class:`defaultdict` Приклади"

msgid ""
"Using :class:`list` as the :attr:`~defaultdict.default_factory`, it is easy "
"to group a sequence of key-value pairs into a dictionary of lists:"
msgstr ""
"Використовуючи :class:`list` як :attr:`~defaultdict.default_factory`, можна "
"легко згрупувати послідовність пар ключ-значення в словник списків:"

msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:`~defaultdict."
"default_factory` function which returns an empty :class:`list`.  The :meth:"
"`list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""
"Коли кожен ключ зустрічається вперше, його ще немає у відображенні; тому "
"запис створюється автоматично за допомогою функції :attr:`~defaultdict."
"default_factory`, яка повертає порожній :class:`list`. Потім операція :meth:"
"`list.append` додає значення до нового списку. Коли ключі зустрічаються "
"знову, пошук триває нормально (повертається список для цього ключа), а "
"операція :meth:`list.append` додає інше значення до списку. Ця техніка "
"простіша та швидша, ніж еквівалентна техніка з використанням :meth:`dict."
"setdefault`:"

msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`int` makes the :"
"class:`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""
"Встановлення :attr:`~defaultdict.default_factory` на :class:`int` робить :"
"class:`defaultdict` корисним для підрахунку (як сумка або мультинабір в "
"інших мовах):"

msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`~defaultdict.default_factory` function calls :func:`int` to supply a "
"default count of zero.  The increment operation then builds up the count for "
"each letter."
msgstr ""
"Коли буква зустрічається вперше, вона відсутня у відображенні, тому функція :"
"attr:`~defaultdict.default_factory` викликає :func:`int`, щоб надати нульову "
"кількість за умовчанням. Потім операція збільшення створює кількість для "
"кожної літери."

msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use a lambda function which can supply any constant value "
"(not just zero):"
msgstr ""
"Функція :func:`int`, яка завжди повертає нуль, є лише окремим випадком "
"постійних функцій. Швидший і більш гнучкий спосіб створення постійних "
"функцій полягає у використанні лямбда-функції, яка може надати будь-яке "
"постійне значення (не лише нуль):"

msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`set` makes the :"
"class:`defaultdict` useful for building a dictionary of sets:"
msgstr ""
"Встановлення :attr:`~defaultdict.default_factory` на :class:`set` робить :"
"class:`defaultdict` корисним для створення словника наборів:"

msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ":func:`namedtuple` Фабрична функція для кортежів з іменованими полями"

msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""
"Іменовані кортежі призначають значення кожній позиції в кортежі та "
"забезпечують більш читабельний самодокументований код. Їх можна "
"використовувати скрізь, де використовуються звичайні кортежі, і вони додають "
"можливість доступу до полів за назвою замість індексу позиції."

msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with typename and field_names) and a helpful :meth:"
"`__repr__` method which lists the tuple contents in a ``name=value`` format."
msgstr ""
"Повертає новий підклас кортежу з назвою *typename*. Новий підклас "
"використовується для створення кортежних об’єктів, які мають поля, доступні "
"за допомогою пошуку атрибутів, а також які можна індексувати та повторювати. "
"Екземпляри підкласу також мають корисний рядок документації (з назвою типу "
"та іменами полів) і корисний метод :meth:`__repr__`, який перераховує вміст "
"кортежу у форматі ``ім'я=значення``."

msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr ""
"*Імена_полів* — це послідовність рядків, наприклад ``['x', 'y']``. Крім "
"того, *назви_полів* можуть бути одним рядком із назвою кожного поля, "
"розділеного пробілами та/або комами, наприклад ``'x y'`` або ``'x, y'``."

msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, or *raise*."
msgstr ""
"Для імені поля можна використовувати будь-який дійсний ідентифікатор Python, "
"за винятком імен, що починаються з підкреслення. Дійсні ідентифікатори "
"складаються з літер, цифр і підкреслення, але не починаються з цифри або "
"підкреслення і не можуть бути :mod:`keyword`, таким як *клас*, *для*, "
"*повернення*, *глобальний*, *перехід* , або *підняти*."

msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def`` "
"and the duplicate fieldname ``abc``."
msgstr ""
"Якщо *rename* має значення true, недійсні назви полів автоматично "
"замінюються позиційними іменами. Наприклад, ``['abc', 'def', 'ghi', 'abc']`` "
"перетворюється на ``['abc', '_1', 'ghi', '_3']``, усуваючи ключове слово "
"``def`` і повторюване ім’я поля ``abc``."

msgid ""
"*defaults* can be ``None`` or an :term:`iterable` of default values. Since "
"fields with a default value must come after any fields without a default, "
"the *defaults* are applied to the rightmost parameters.  For example, if the "
"fieldnames are ``['x', 'y', 'z']`` and the defaults are ``(1, 2)``, then "
"``x`` will be a required argument, ``y`` will default to ``1``, and ``z`` "
"will default to ``2``."
msgstr ""
"*defaults* може бути ``None`` або :term:`iterable` значень за замовчуванням. "
"Оскільки поля зі значенням за замовчуванням мають бути після будь-яких полів "
"без значення за замовчуванням, *за замовчуванням* застосовуються до крайніх "
"правих параметрів. Наприклад, якщо імена полів ``['x', 'y', 'z']``, а "
"значення за умовчанням ``(1, 2)``, тоді ``x`` буде обов'язковим аргументом, "
"``y`` за замовчуванням буде ``1``, а ``z`` буде ``2``."

msgid ""
"If *module* is defined, the ``__module__`` attribute of the named tuple is "
"set to that value."
msgstr ""
"Якщо визначено *module*, атрибут ``__module__`` названого кортежу "
"встановлюється на це значення."

msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""
"Іменовані екземпляри кортежу не мають словників для кожного екземпляра, тому "
"вони легкі та не вимагають більше пам’яті, ніж звичайні кортежі."

msgid ""
"To support pickling, the named tuple class should be assigned to a variable "
"that matches *typename*."
msgstr ""
"Щоб підтримувати маринування, іменований клас кортежу має бути призначений "
"змінній, яка відповідає *typename*."

msgid "Added support for *rename*."
msgstr "Додано підтримку *перейменування*."

msgid ""
"The *verbose* and *rename* parameters became :ref:`keyword-only arguments "
"<keyword-only_parameter>`."
msgstr ""
"Параметри *verbose* і *rename* стали :ref:`аргументами лише для ключових "
"слів <keyword-only_parameter>`."

msgid "Added the *module* parameter."
msgstr "Додано параметр *module*."

msgid "Removed the *verbose* parameter and the :attr:`_source` attribute."
msgstr "Видалено параметр *verbose* і атрибут :attr:`_source`."

msgid ""
"Added the *defaults* parameter and the :attr:`_field_defaults` attribute."
msgstr "Додано параметр *defaults* і атрибут :attr:`_field_defaults`."

msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""
"Іменовані кортежі особливо корисні для призначення імен полів кортежам "
"результатів, які повертаються модулями :mod:`csv` або :mod:`sqlite3`::"

msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and two attributes.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""
"На додаток до методів, успадкованих від кортежів, іменовані кортежі "
"підтримують три додаткові методи та два атрибути. Щоб запобігти конфліктам "
"імен полів, імена методів і атрибутів починаються зі знака підкреслення."

msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""
"Метод класу, який створює новий екземпляр із існуючої послідовності або "
"повторюється."

msgid ""
"Return a new :class:`dict` which maps field names to their corresponding "
"values:"
msgstr ""
"Повертає новий :class:`dict`, який зіставляє назви полів з відповідними "
"значеннями:"

msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr "Повертає :class:`OrderedDict` замість звичайного :class:`dict`."

msgid ""
"Returns a regular :class:`dict` instead of an :class:`OrderedDict`. As of "
"Python 3.7, regular dicts are guaranteed to be ordered.  If the extra "
"features of :class:`OrderedDict` are required, the suggested remediation is "
"to cast the result to the desired type: ``OrderedDict(nt._asdict())``."
msgstr ""
"Повертає звичайний :class:`dict` замість :class:`OrderedDict`. Починаючи з "
"Python 3.7, звичайні dicts гарантовано будуть упорядковані. Якщо потрібні "
"додаткові функції :class:`OrderedDict`, запропонованим виправленням є "
"приведення результату до потрібного типу: ``OrderedDict(nt._asdict())``."

msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values::"
msgstr ""
"Повертає новий екземпляр іменованого кортежу, замінюючи вказані поля новими "
"значеннями::"

msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""
"Кортеж рядків із переліком імен полів. Корисно для самоаналізу та для "
"створення нових іменованих типів кортежів із існуючих іменованих кортежів."

msgid "Dictionary mapping field names to default values."
msgstr "Словник зіставляє назви полів зі значеннями за замовчуванням."

msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""
"Щоб отримати поле, ім’я якого зберігається в рядку, використовуйте функцію :"
"func:`getattr`:"

msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""
"Щоб перетворити словник на іменований кортеж, використовуйте оператор "
"подвійної зірочки (як описано в :ref:`tut-unpacking-arguments`):"

msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""
"Оскільки іменований кортеж є звичайним класом Python, його легко додати або "
"змінити функціональність за допомогою підкласу. Ось як додати обчислюване "
"поле та формат друку з фіксованою шириною:"

msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""
"Показаний вище підклас встановлює ``__slots__`` на порожній кортеж. Це "
"допомагає підтримувати низькі вимоги до пам’яті, запобігаючи створенню "
"словників примірників."

msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`~somenamedtuple._fields` "
"attribute:"
msgstr ""
"Підкласи не корисні для додавання нових збережених полів. Замість цього "
"просто створіть новий іменований тип кортежу з атрибута :attr:"
"`~somenamedtuple._fields`:"

msgid ""
"Docstrings can be customized by making direct assignments to the ``__doc__`` "
"fields:"
msgstr ""
"Рядки документів можна налаштувати шляхом прямого призначення полів "
"``__doc__``:"

msgid "Property docstrings became writeable."
msgstr "Документаційні рядки властивостей стали доступними для запису."

msgid ""
"See :class:`typing.NamedTuple` for a way to add type hints for named "
"tuples.  It also provides an elegant notation using the :keyword:`class` "
"keyword::"
msgstr ""
"Дивіться :class:`typing.NamedTuple`, щоб дізнатися, як додати підказки типу "
"для іменованих кортежів. Він також забезпечує елегантну нотацію за допомогою "
"ключового слова :keyword:`class`::"

msgid ""
"See :meth:`types.SimpleNamespace` for a mutable namespace based on an "
"underlying dictionary instead of a tuple."
msgstr ""
"Перегляньте :meth:`types.SimpleNamespace` для змінного простору імен, "
"заснованого на базовому словнику замість кортежу."

msgid ""
"The :mod:`dataclasses` module provides a decorator and functions for "
"automatically adding generated special methods to user-defined classes."
msgstr ""
"Модуль :mod:`dataclasses` надає декоратор і функції для автоматичного "
"додавання згенерованих спеціальних методів до визначених користувачем класів."

msgid ":class:`OrderedDict` objects"
msgstr ":class:`OrderedDict` об’єкти"

msgid ""
"Ordered dictionaries are just like regular dictionaries but have some extra "
"capabilities relating to ordering operations.  They have become less "
"important now that the built-in :class:`dict` class gained the ability to "
"remember insertion order (this new behavior became guaranteed in Python 3.7)."
msgstr ""
"Упорядковані словники схожі на звичайні словники, але мають деякі додаткові "
"можливості, пов’язані з операціями впорядкування. Тепер вони стали менш "
"важливими, оскільки вбудований клас :class:`dict` отримав можливість "
"запам’ятовувати порядок вставки (ця нова поведінка стала гарантованою в "
"Python 3.7)."

msgid "Some differences from :class:`dict` still remain:"
msgstr "Деякі відмінності від :class:`dict` все ще залишаються:"

msgid ""
"The regular :class:`dict` was designed to be very good at mapping "
"operations.  Tracking insertion order was secondary."
msgstr ""
"Звичайний :class:`dict` був розроблений, щоб дуже добре виконувати операції "
"відображення. Відстеження порядку вставки було другорядним."

msgid ""
"The :class:`OrderedDict` was designed to be good at reordering operations. "
"Space efficiency, iteration speed, and the performance of update operations "
"were secondary."
msgstr ""
":class:`OrderedDict` був розроблений, щоб добре справлятися з операціями "
"зміни порядку. Ефективність простору, швидкість ітерації та продуктивність "
"операцій оновлення були другорядними."

msgid ""
"The :class:`OrderedDict` algorithm can handle frequent reordering operations "
"better than :class:`dict`.  As shown in the recipes below, this makes it "
"suitable for implementing various kinds of LRU caches."
msgstr ""
"Алгоритм :class:`OrderedDict` може виконувати часті операції зміни порядку "
"краще, ніж :class:`dict`. Як показано в наведених нижче рецептах, це робить "
"його придатним для реалізації різних видів кешів LRU."

msgid ""
"The equality operation for :class:`OrderedDict` checks for matching order."
msgstr ""
"Операція рівності для :class:`OrderedDict` перевіряє відповідність порядку."

msgid ""
"A regular :class:`dict` can emulate the order sensitive equality test with "
"``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."
msgstr ""
"Звичайний :class:`dict` може емулювати чутливий до порядку тест рівності з "
"``p == q і all(k1 == k2 для k1, k2 в zip(p, q))``."

msgid ""
"The :meth:`popitem` method of :class:`OrderedDict` has a different "
"signature.  It accepts an optional argument to specify which item is popped."
msgstr ""
"Метод :meth:`popitem` :class:`OrderedDict` має інший підпис. Він приймає "
"необов'язковий аргумент, щоб вказати, який елемент витягується."

msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=True)`` "
"with ``d.popitem()`` which is guaranteed to pop the rightmost (last) item."
msgstr ""
"Звичайний :class:`dict` може емулювати OrderedDict ``od.popitem(last=True)`` "
"за допомогою ``d.popitem()``, який гарантовано відкриває крайній правий "
"(останній) елемент."

msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=False)`` "
"with ``(k := next(iter(d)), d.pop(k))`` which will return and remove the "
"leftmost (first) item if it exists."
msgstr ""
"Звичайний :class:`dict` може емулювати OrderedDict ``od."
"popitem(last=False)`` з ``(k := next(iter(d)), d.pop(k))``, який повертатиме "
"і видаліть крайній лівий (перший) елемент, якщо він існує."

msgid ""
":class:`OrderedDict` has a :meth:`move_to_end` method to efficiently "
"reposition an element to an endpoint."
msgstr ""
":class:`OrderedDict` має метод :meth:`move_to_end` для ефективного "
"переміщення елемента в кінцеву точку."

msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.move_to_end(k, "
"last=True)`` with ``d[k] = d.pop(k)`` which will move the key and its "
"associated value to the rightmost (last) position."
msgstr ""
"Звичайний :class:`dict` може емулювати OrderedDict ``od.move_to_end(k, "
"last=True)`` з ``d[k] = d.pop(k)``, який переміщуватиме ключ і його "
"пов’язане значення до крайньої правої (останньої) позиції."

msgid ""
"A regular :class:`dict` does not have an efficient equivalent for "
"OrderedDict's ``od.move_to_end(k, last=False)`` which moves the key and its "
"associated value to the leftmost (first) position."
msgstr ""
"Звичайний :class:`dict` не має ефективного еквівалента для OrderedDict ``od."
"move_to_end(k, last=False)``, який переміщує ключ і пов’язане з ним значення "
"в крайню ліву (першу) позицію."

msgid "Until Python 3.8, :class:`dict` lacked a :meth:`__reversed__` method."
msgstr "До Python 3.8 :class:`dict` не мав методу :meth:`__reversed__`."

msgid ""
"Return an instance of a :class:`dict` subclass that has methods specialized "
"for rearranging dictionary order."
msgstr ""
"Повертає екземпляр підкласу :class:`dict`, який має спеціалізовані методи "
"для зміни порядку словника."

msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in :abbr:`LIFO (last-in, first-"
"out)` order if *last* is true or :abbr:`FIFO (first-in, first-out)` order if "
"false."
msgstr ""
"Метод :meth:`popitem` для впорядкованих словників повертає та видаляє пару "
"(ключ, значення). Пари повертаються в порядку :abbr:`LIFO (останній прийшов, "
"перший вийшов)`, якщо *останній* має значення true, або :abbr:`FIFO (перший "
"прийшов, перший вийшов)`, якщо значення false."

msgid ""
"Move an existing *key* to either end of an ordered dictionary.  The item is "
"moved to the right end if *last* is true (the default) or to the beginning "
"if *last* is false.  Raises :exc:`KeyError` if the *key* does not exist:"
msgstr ""
"Перемістіть наявний *ключ* у будь-який кінець упорядкованого словника. "
"Елемент переміщується в правий кінець, якщо *last* має значення true (за "
"замовчуванням), або на початок, якщо *last* має значення false. Викликає :"
"exc:`KeyError`, якщо *ключ* не існує:"

msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr ""
"На додаток до звичайних методів відображення, упорядковані словники також "
"підтримують зворотну ітерацію за допомогою :func:`reversed`."

msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are implemented as ``list(od1.items())==list(od2.items())``. Equality tests "
"between :class:`OrderedDict` objects and other :class:`~collections.abc."
"Mapping` objects are order-insensitive like regular dictionaries.  This "
"allows :class:`OrderedDict` objects to be substituted anywhere a regular "
"dictionary is used."
msgstr ""
"Перевірки рівності між об’єктами :class:`OrderedDict` чутливі до порядку та "
"реалізовані як ``list(od1.items())==list(od2.items())``. Перевірки рівності "
"між об’єктами :class:`OrderedDict` та іншими об’єктами :class:`~collections."
"abc.Mapping` не залежать від порядку, як і звичайні словники. Це дозволяє "
"замінювати об’єкти :class:`OrderedDict` будь-де, де використовується "
"звичайний словник."

msgid ""
"The items, keys, and values :term:`views <dictionary view>` of :class:"
"`OrderedDict` now support reverse iteration using :func:`reversed`."
msgstr ""
"Елементи, ключі та значення :term:`views <dictionary view>` :class:"
"`OrderedDict` тепер підтримують зворотну ітерацію за допомогою :func:"
"`reversed`."

msgid ""
"With the acceptance of :pep:`468`, order is retained for keyword arguments "
"passed to the :class:`OrderedDict` constructor and its :meth:`update` method."
msgstr ""
"З прийняттям :pep:`468` зберігається порядок для аргументів ключових слів, "
"які передаються конструктору :class:`OrderedDict` і його методу :meth:"
"`update`."

msgid ":class:`OrderedDict` Examples and Recipes"
msgstr ":class:`OrderedDict` Приклади та рецепти"

msgid ""
"It is straightforward to create an ordered dictionary variant that remembers "
"the order the keys were *last* inserted. If a new entry overwrites an "
"existing entry, the original insertion position is changed and moved to the "
"end::"
msgstr ""
"Легко створити впорядкований варіант словника, який запам’ятовує порядок "
"*останнього* введення ключів. Якщо новий запис перезаписує існуючий запис, "
"початкова позиція вставки змінюється та переміщується в кінець::"

msgid ""
"An :class:`OrderedDict` would also be useful for implementing variants of :"
"func:`functools.lru_cache`:"
msgstr ""
":class:`OrderedDict` також буде корисним для реалізації варіантів :func:"
"`functools.lru_cache`:"

msgid ":class:`UserDict` objects"
msgstr ":class:`UserDict` об'єкти"

msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier to "
"work with because the underlying dictionary is accessible as an attribute."
msgstr ""
"Клас :class:`UserDict` діє як оболонка навколо об’єктів словника. Потреба в "
"цьому класі була частково витіснена можливістю створювати підклас "
"безпосередньо з :class:`dict`; однак з цим класом може бути легше працювати, "
"оскільки базовий словник доступний як атрибут."

msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a "
"regular dictionary, which is accessible via the :attr:`data` attribute of :"
"class:`UserDict` instances.  If *initialdata* is provided, :attr:`data` is "
"initialized with its contents; note that a reference to *initialdata* will "
"not be kept, allowing it to be used for other purposes."
msgstr ""
"Клас, який імітує словник. Вміст екземпляра зберігається у звичайному "
"словнику, який доступний через атрибут :attr:`data` екземплярів :class:"
"`UserDict`. Якщо надано *initialdata*, :attr:`data` ініціалізується його "
"вмістом; зауважте, що посилання на *ініціальні дані* не буде збережено, що "
"дозволить використовувати його для інших цілей."

msgid ""
"In addition to supporting the methods and operations of mappings, :class:"
"`UserDict` instances provide the following attribute:"
msgstr ""
"На додаток до підтримки методів і операцій зіставлення, екземпляри :class:"
"`UserDict` забезпечують такий атрибут:"

msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` class."
msgstr ""
"Справжній словник, який використовується для зберігання вмісту класу :class:"
"`UserDict`."

msgid ":class:`UserList` objects"
msgstr ":class:`UserList` об’єкти"

msgid ""
"This class acts as a wrapper around list objects.  It is a useful base class "
"for your own list-like classes which can inherit from them and override "
"existing methods or add new ones.  In this way, one can add new behaviors to "
"lists."
msgstr ""
"Цей клас діє як оболонка навколо об’єктів списку. Це корисний базовий клас "
"для ваших власних спископодібних класів, які можуть успадковувати їх і "
"перевизначати існуючі методи або додавати нові. Таким чином можна додавати "
"нові моделі поведінки до списків."

msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier to "
"work with because the underlying list is accessible as an attribute."
msgstr ""
"Потреба в цьому класі була частково витіснена можливістю створювати підкласи "
"безпосередньо з :class:`list`; однак з цим класом може бути легше працювати, "
"оскільки базовий список доступний як атрибут."

msgid ""
"Class that simulates a list.  The instance's contents are kept in a regular "
"list, which is accessible via the :attr:`data` attribute of :class:"
"`UserList` instances.  The instance's contents are initially set to a copy "
"of *list*, defaulting to the empty list ``[]``.  *list* can be any iterable, "
"for example a real Python list or a :class:`UserList` object."
msgstr ""
"Клас, що імітує список. Вміст екземпляра зберігається у звичайному списку, "
"який доступний через атрибут :attr:`data` екземплярів :class:`UserList`. "
"Вміст екземпляра спочатку встановлено як копія *списку*, за замовчуванням — "
"порожній список ``[]``. *list* може бути будь-яким ітерованим, наприклад "
"справжнім списком Python або об’єктом :class:`UserList`."

msgid ""
"In addition to supporting the methods and operations of mutable sequences, :"
"class:`UserList` instances provide the following attribute:"
msgstr ""
"На додаток до підтримки методів і операцій змінних послідовностей, "
"екземпляри :class:`UserList` забезпечують такий атрибут:"

msgid ""
"A real :class:`list` object used to store the contents of the :class:"
"`UserList` class."
msgstr ""
"Справжній об’єкт :class:`list`, який використовується для зберігання вмісту "
"класу :class:`UserList`."

msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are expected "
"to offer a constructor which can be called with either no arguments or one "
"argument.  List operations which return a new sequence attempt to create an "
"instance of the actual implementation class.  To do so, it assumes that the "
"constructor can be called with a single parameter, which is a sequence "
"object used as a data source."
msgstr ""
"**Вимоги до підкласів:** Очікується, що підкласи :class:`UserList` "
"пропонуватимуть конструктор, який можна викликати без аргументів або з одним "
"аргументом. Список операцій, які повертають нову послідовність, намагається "
"створити екземпляр фактичного класу реалізації. Для цього передбачається, що "
"конструктор можна викликати за допомогою одного параметра, який є об’єктом "
"послідовності, що використовується як джерело даних."

msgid ""
"If a derived class does not wish to comply with this requirement, all of the "
"special methods supported by this class will need to be overridden; please "
"consult the sources for information about the methods which need to be "
"provided in that case."
msgstr ""
"Якщо похідний клас не бажає відповідати цій вимозі, всі спеціальні методи, "
"підтримувані цим класом, повинні бути перевизначені; будь ласка, зверніться "
"до джерел для отримання інформації про методи, які необхідно надати в такому "
"випадку."

msgid ":class:`UserString` objects"
msgstr ":class:`UserString` об’єкти"

msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. The "
"need for this class has been partially supplanted by the ability to subclass "
"directly from :class:`str`; however, this class can be easier to work with "
"because the underlying string is accessible as an attribute."
msgstr ""
"Клас :class:`UserString` діє як оболонка навколо рядкових об’єктів. Потреба "
"в цьому класі була частково витіснена можливістю створювати підклас "
"безпосередньо з :class:`str`; однак з цим класом може бути легше працювати, "
"оскільки базовий рядок доступний як атрибут."

msgid ""
"Class that simulates a string object.  The instance's content is kept in a "
"regular string object, which is accessible via the :attr:`data` attribute "
"of :class:`UserString` instances.  The instance's contents are initially set "
"to a copy of *seq*.  The *seq* argument can be any object which can be "
"converted into a string using the built-in :func:`str` function."
msgstr ""
"Клас, який імітує рядковий об'єкт. Вміст екземпляра зберігається у "
"звичайному рядковому об’єкті, який доступний через атрибут :attr:`data` "
"екземплярів :class:`UserString`. Для вмісту екземпляра спочатку встановлено "
"копію *seq*. Аргументом *seq* може бути будь-який об’єкт, який можна "
"перетворити на рядок за допомогою вбудованої функції :func:`str`."

msgid ""
"In addition to supporting the methods and operations of strings, :class:"
"`UserString` instances provide the following attribute:"
msgstr ""
"На додаток до підтримки методів і операцій із рядками, екземпляри :class:"
"`UserString` надають такий атрибут:"

msgid ""
"A real :class:`str` object used to store the contents of the :class:"
"`UserString` class."
msgstr ""
"Справжній об’єкт :class:`str`, який використовується для зберігання вмісту "
"класу :class:`UserString`."

msgid ""
"New methods ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable``, and ``maketrans``."
msgstr ""
"Нові методи ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable`` і ``maketrans``."
