# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:18+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`zlib` --- Compression compatible with :program:`gzip`"
msgstr ":mod:`zlib` --- Стиснення сумісне з :program:`gzip`"

msgid ""
"For applications that require data compression, the functions in this module "
"allow compression and decompression, using the zlib library. The zlib "
"library has its own home page at https://www.zlib.net.   There are known "
"incompatibilities between the Python module and versions of the zlib library "
"earlier than 1.1.3; 1.1.3 has a `security vulnerability <https://zlib.net/"
"zlib_faq.html#faq33>`_, so we recommend using 1.1.4 or later."
msgstr ""
"Для програм, які вимагають стиснення даних, функції цього модуля дозволяють "
"стискати та розпаковувати за допомогою бібліотеки zlib. Бібліотека zlib має "
"власну домашню сторінку за адресою https://www.zlib.net. Відомі несумісності "
"між модулем Python і версіями бібліотеки zlib, ранішими за 1.1.3; 1.1.3 має "
"`вразливість безпеки <https://zlib.net/zlib_faq.html#faq33>`_, тому ми "
"рекомендуємо використовувати 1.1.4 або новішу версію."

msgid ""
"zlib's functions have many options and often need to be used in a particular "
"order.  This documentation doesn't attempt to cover all of the permutations; "
"consult the zlib manual at http://www.zlib.net/manual.html for authoritative "
"information."
msgstr ""
"Функції zlib мають багато параметрів і часто їх потрібно використовувати в "
"певному порядку. Ця документація не намагається охопити всі перестановки; "
"зверніться до посібника з zlib на http://www.zlib.net/manual.html для "
"отримання достовірної інформації."

msgid "For reading and writing ``.gz`` files see the :mod:`gzip` module."
msgstr "Для читання та запису файлів ``.gz`` перегляньте модуль :mod:`gzip`."

msgid "The available exception and functions in this module are:"
msgstr "Доступні винятки та функції в цьому модулі:"

msgid "Exception raised on compression and decompression errors."
msgstr "Винятком є помилки стиснення та декомпресії."

msgid ""
"Computes an Adler-32 checksum of *data*.  (An Adler-32 checksum is almost as "
"reliable as a CRC32 but can be computed much more quickly.)  The result is "
"an unsigned 32-bit integer.  If *value* is present, it is used as the "
"starting value of the checksum; otherwise, a default value of 1 is used.  "
"Passing in *value* allows computing a running checksum over the "
"concatenation of several inputs.  The algorithm is not cryptographically "
"strong, and should not be used for authentication or digital signatures.  "
"Since the algorithm is designed for use as a checksum algorithm, it is not "
"suitable for use as a general hash algorithm."
msgstr ""
"Обчислює контрольну суму Adler-32 для *даних*. (Контрольна сума Adler-32 "
"майже така ж надійна, як CRC32, але її можна обчислити набагато швидше.) "
"Результатом є 32-розрядне ціле число без знаку. Якщо присутнє *значення*, "
"воно використовується як початкове значення контрольної суми; інакше "
"використовується значення за замовчуванням 1. Передача *value* дозволяє "
"обчислити поточну контрольну суму для конкатенації кількох вхідних даних. "
"Алгоритм не є криптографічно надійним, тому його не слід використовувати для "
"автентифікації чи цифрових підписів. Оскільки алгоритм розроблено для "
"використання як алгоритм контрольної суми, він не підходить для використання "
"як загальний алгоритм хешування."

msgid ""
"The result is always unsigned. To generate the same numeric value when using "
"Python 2 or earlier, use ``adler32(data) & 0xffffffff``."
msgstr ""

msgid ""
"Compresses the bytes in *data*, returning a bytes object containing "
"compressed data. *level* is an integer from ``0`` to ``9`` or ``-1`` "
"controlling the level of compression; ``1`` (Z_BEST_SPEED) is fastest and "
"produces the least compression, ``9`` (Z_BEST_COMPRESSION) is slowest and "
"produces the most.  ``0`` (Z_NO_COMPRESSION) is no compression. The default "
"value is ``-1`` (Z_DEFAULT_COMPRESSION).  Z_DEFAULT_COMPRESSION represents a "
"default compromise between speed and compression (currently equivalent to "
"level 6). Raises the :exc:`error` exception if any error occurs."
msgstr ""

msgid "*level* can now be used as a keyword parameter."
msgstr "*level* тепер можна використовувати як параметр ключового слова."

msgid ""
"Returns a compression object, to be used for compressing data streams that "
"won't fit into memory at once."
msgstr ""
"Повертає об’єкт стиснення для стиснення потоків даних, які не вміщаються в "
"пам’ять одразу."

msgid ""
"*level* is the compression level -- an integer from ``0`` to ``9`` or "
"``-1``. A value of ``1`` (Z_BEST_SPEED) is fastest and produces the least "
"compression, while a value of ``9`` (Z_BEST_COMPRESSION) is slowest and "
"produces the most. ``0`` (Z_NO_COMPRESSION) is no compression.  The default "
"value is ``-1`` (Z_DEFAULT_COMPRESSION). Z_DEFAULT_COMPRESSION represents a "
"default compromise between speed and compression (currently equivalent to "
"level 6)."
msgstr ""
"*level* — це рівень стиснення -- ціле число від ``0`` до ``9`` або ``-1``. "
"Значення \"1\" (Z_BEST_SPEED) є найшвидшим і забезпечує найменше стиснення, "
"тоді як значення \"9\" (Z_BEST_COMPRESSION) є найповільнішим і забезпечує "
"найбільше. ``0`` (Z_NO_COMPRESSION) не стискає. Значення за замовчуванням – "
"``-1`` (Z_DEFAULT_COMPRESSION). Z_DEFAULT_COMPRESSION представляє "
"стандартний компроміс між швидкістю та стисненням (на даний момент "
"еквівалентно рівню 6)."

msgid ""
"*method* is the compression algorithm. Currently, the only supported value "
"is :const:`DEFLATED`."
msgstr ""
"*метод* — це алгоритм стиснення. Наразі єдиним підтримуваним значенням є :"
"const:`DEFLATED`."

msgid ""
"The *wbits* argument controls the size of the history buffer (or the "
"\"window size\") used when compressing data, and whether a header and "
"trailer is included in the output.  It can take several ranges of values, "
"defaulting to ``15`` (MAX_WBITS):"
msgstr ""
"Аргумент *wbits* контролює розмір буфера історії (або \"розмір вікна\"), "
"який використовується під час стиснення даних, а також те, чи включено "
"заголовок і трейлер у вивід. Він може приймати кілька діапазонів значень, за "
"замовчуванням ``15`` (MAX_WBITS):"

msgid ""
"+9 to +15: The base-two logarithm of the window size, which therefore ranges "
"between 512 and 32768.  Larger values produce better compression at the "
"expense of greater memory usage.  The resulting output will include a zlib-"
"specific header and trailer."
msgstr ""
"Від +9 до +15: логарифм розміру вікна за основою два, який коливається між "
"512 і 32768. Більші значення забезпечують краще стиснення за рахунок "
"більшого використання пам’яті. Отриманий результат включатиме специфічний "
"для zlib заголовок і трейлер."

msgid ""
"−9 to −15: Uses the absolute value of *wbits* as the window size logarithm, "
"while producing a raw output stream with no header or trailing checksum."
msgstr ""
"Від −9 до −15: використовує абсолютне значення *wbits* як логарифм розміру "
"вікна, водночас створюючи необроблений вихідний потік без заголовка чи "
"контрольної суми в кінці."

msgid ""
"+25 to +31 = 16 + (9 to 15): Uses the low 4 bits of the value as the window "
"size logarithm, while including a basic :program:`gzip` header and trailing "
"checksum in the output."
msgstr ""
"Від +25 до +31 = 16 + (від 9 до 15): використовує молодші 4 біти значення як "
"логарифм розміру вікна, в той час як базовий заголовок :program:`gzip` і "
"контрольну суму в кінці виводяться."

msgid ""
"The *memLevel* argument controls the amount of memory used for the internal "
"compression state. Valid values range from ``1`` to ``9``. Higher values use "
"more memory, but are faster and produce smaller output."
msgstr ""
"Аргумент *memLevel* контролює обсяг пам’яті, який використовується для стану "
"внутрішнього стиснення. Діапазон допустимих значень від \"1\" до \"9\". Вищі "
"значення використовують більше пам’яті, але є швидшими та дають менший "
"результат."

msgid ""
"*strategy* is used to tune the compression algorithm. Possible values are :"
"const:`Z_DEFAULT_STRATEGY`, :const:`Z_FILTERED`, :const:`Z_HUFFMAN_ONLY`, :"
"const:`Z_RLE` (zlib 1.2.0.1) and :const:`Z_FIXED` (zlib 1.2.2.2)."
msgstr ""
"*стратегія* використовується для налаштування алгоритму стиснення. Можливі "
"значення: :const:`Z_DEFAULT_STRATEGY`, :const:`Z_FILTERED`, :const:"
"`Z_HUFFMAN_ONLY`, :const:`Z_RLE` (zlib 1.2.0.1) і :const:`Z_FIXED` (zlib "
"1.2.2.2)."

msgid ""
"*zdict* is a predefined compression dictionary. This is a sequence of bytes "
"(such as a :class:`bytes` object) containing subsequences that are expected "
"to occur frequently in the data that is to be compressed. Those subsequences "
"that are expected to be most common should come at the end of the dictionary."
msgstr ""
"*zdict* — це попередньо визначений словник стиснення. Це послідовність "
"байтів (наприклад, об’єкт :class:`bytes`), що містить підпослідовності, які, "
"як очікується, часто траплятимуться в даних, які потрібно стиснути. Ті "
"підпослідовності, які, як очікується, будуть найбільш поширеними, повинні "
"бути в кінці словника."

msgid "Added the *zdict* parameter and keyword argument support."
msgstr "Додано підтримку параметра *zdict* і ключового слова."

msgid ""
"Computes a CRC (Cyclic Redundancy Check) checksum of *data*. The result is "
"an unsigned 32-bit integer. If *value* is present, it is used as the "
"starting value of the checksum; otherwise, a default value of 0 is used.  "
"Passing in *value* allows computing a running checksum over the "
"concatenation of several inputs.  The algorithm is not cryptographically "
"strong, and should not be used for authentication or digital signatures.  "
"Since the algorithm is designed for use as a checksum algorithm, it is not "
"suitable for use as a general hash algorithm."
msgstr ""
"Обчислює контрольну суму CRC (перевірка циклічної надлишковості) *даних*. "
"Результатом є 32-розрядне ціле число без знаку. Якщо присутнє *значення*, "
"воно використовується як початкове значення контрольної суми; інакше "
"використовується значення за замовчуванням 0. Передача *value* дозволяє "
"обчислити поточну контрольну суму для конкатенації кількох вхідних даних. "
"Алгоритм не є криптографічно надійним, тому його не слід використовувати для "
"автентифікації чи цифрових підписів. Оскільки алгоритм розроблено для "
"використання як алгоритм контрольної суми, він не підходить для використання "
"як загальний алгоритм хешування."

msgid ""
"The result is always unsigned. To generate the same numeric value when using "
"Python 2 or earlier, use ``crc32(data) & 0xffffffff``."
msgstr ""

msgid ""
"Decompresses the bytes in *data*, returning a bytes object containing the "
"uncompressed data.  The *wbits* parameter depends on the format of *data*, "
"and is discussed further below. If *bufsize* is given, it is used as the "
"initial size of the output buffer.  Raises the :exc:`error` exception if any "
"error occurs."
msgstr ""
"Розпаковує байти в *data*, повертаючи об’єкт bytes, що містить нестиснуті "
"дані. Параметр *wbits* залежить від формату *data* і обговорюється нижче. "
"Якщо вказано *bufsize*, він використовується як початковий розмір вихідного "
"буфера. Викликає виняток :exc:`error`, якщо виникає будь-яка помилка."

msgid ""
"The *wbits* parameter controls the size of the history buffer (or \"window "
"size\"), and what header and trailer format is expected. It is similar to "
"the parameter for :func:`compressobj`, but accepts more ranges of values:"
msgstr ""
"Параметр *wbits* керує розміром буфера історії (або \"розміром вікна\"), а "
"також очікуваним форматом заголовка та трейлера. Він схожий на параметр для :"
"func:`compressobj`, але приймає більше діапазонів значень:"

msgid ""
"+8 to +15: The base-two logarithm of the window size.  The input must "
"include a zlib header and trailer."
msgstr ""
"Від +8 до +15: два логарифми розміру вікна. Вхідні дані повинні містити "
"заголовок і трейлер zlib."

msgid ""
"0: Automatically determine the window size from the zlib header. Only "
"supported since zlib 1.2.3.5."
msgstr ""
"0: Автоматично визначати розмір вікна із заголовка zlib. Підтримується лише "
"з zlib 1.2.3.5."

msgid ""
"−8 to −15: Uses the absolute value of *wbits* as the window size logarithm.  "
"The input must be a raw stream with no header or trailer."
msgstr ""
"Від −8 до −15: використовує абсолютне значення *wbits* як логарифм розміру "
"вікна. Вхід має бути необробленим потоком без заголовка чи трейлера."

msgid ""
"+24 to +31 = 16 + (8 to 15): Uses the low 4 bits of the value as the window "
"size logarithm.  The input must include a gzip header and trailer."
msgstr ""
"Від +24 до +31 = 16 + (від 8 до 15): використовуються молодші 4 біти "
"значення як логарифм розміру вікна. Вхідні дані мають містити заголовок gzip "
"і трейлер."

msgid ""
"+40 to +47 = 32 + (8 to 15): Uses the low 4 bits of the value as the window "
"size logarithm, and automatically accepts either the zlib or gzip format."
msgstr ""
"Від +40 до +47 = 32 + (від 8 до 15): використовує молодші 4 біти значення як "
"логарифм розміру вікна та автоматично приймає формат zlib або gzip."

msgid ""
"When decompressing a stream, the window size must not be smaller than the "
"size originally used to compress the stream; using a too-small value may "
"result in an :exc:`error` exception. The default *wbits* value corresponds "
"to the largest window size and requires a zlib header and trailer to be "
"included."
msgstr ""
"Під час декомпресії потоку розмір вікна не повинен бути меншим за розмір, "
"який спочатку використовувався для стиснення потоку; використання занадто "
"малого значення може призвести до виключення :exc:`error`. Значення *wbits* "
"за замовчуванням відповідає найбільшому розміру вікна та вимагає включення "
"заголовка та трейлера zlib."

msgid ""
"*bufsize* is the initial size of the buffer used to hold decompressed data.  "
"If more space is required, the buffer size will be increased as needed, so "
"you don't have to get this value exactly right; tuning it will only save a "
"few calls to :c:func:`malloc`."
msgstr ""
"*bufsize* — початковий розмір буфера, який використовується для зберігання "
"розпакованих даних. Якщо потрібно більше місця, розмір буфера буде збільшено "
"за потреби, тому вам не потрібно отримувати це значення точно; його "
"налаштування заощадить лише кілька викликів :c:func:`malloc`."

msgid "*wbits* and *bufsize* can be used as keyword arguments."
msgstr "*wbits* і *bufsize* можна використовувати як ключові аргументи."

msgid ""
"Returns a decompression object, to be used for decompressing data streams "
"that won't fit into memory at once."
msgstr ""
"Повертає об’єкт декомпресії, який буде використано для декомпресії потоків "
"даних, які не вміщуються в пам’ять одразу."

msgid ""
"The *wbits* parameter controls the size of the history buffer (or the "
"\"window size\"), and what header and trailer format is expected.  It has "
"the same meaning as `described for decompress() <#decompress-wbits>`__."
msgstr ""
"Параметр *wbits* керує розміром буфера історії (або \"розміром вікна\"), а "
"також очікуваним форматом заголовка та трейлера. Він має те саме значення, "
"що й `описане для decompress() <#decompress-wbits>`__."

msgid ""
"The *zdict* parameter specifies a predefined compression dictionary. If "
"provided, this must be the same dictionary as was used by the compressor "
"that produced the data that is to be decompressed."
msgstr ""
"Параметр *zdict* визначає попередньо визначений словник стиснення. Якщо "
"надано, це має бути той самий словник, який використовувався компресором, "
"який створив дані, які потрібно розпакувати."

msgid ""
"If *zdict* is a mutable object (such as a :class:`bytearray`), you must not "
"modify its contents between the call to :func:`decompressobj` and the first "
"call to the decompressor's ``decompress()`` method."
msgstr ""
"Якщо *zdict* є змінним об’єктом (наприклад, :class:`bytearray`), ви не "
"повинні змінювати його вміст між викликом :func:`decompressobj` і першим "
"викликом ``decompress()`` декомпресора. метод."

msgid "Added the *zdict* parameter."
msgstr "Додано параметр *zdict*."

msgid "Compression objects support the following methods:"
msgstr "Об’єкти стиснення підтримують такі методи:"

msgid ""
"Compress *data*, returning a bytes object containing compressed data for at "
"least part of the data in *data*.  This data should be concatenated to the "
"output produced by any preceding calls to the :meth:`compress` method.  Some "
"input may be kept in internal buffers for later processing."
msgstr ""
"Стискати *data*, повертаючи об’єкт bytes, що містить стислі дані принаймні "
"для частини даних у *data*. Ці дані мають бути об’єднані з виводом, "
"створеним будь-якими попередніми викликами методу :meth:`compress`. Деякі "
"вхідні дані можуть зберігатися у внутрішніх буферах для подальшої обробки."

msgid ""
"All pending input is processed, and a bytes object containing the remaining "
"compressed output is returned.  *mode* can be selected from the constants :"
"const:`Z_NO_FLUSH`, :const:`Z_PARTIAL_FLUSH`, :const:`Z_SYNC_FLUSH`, :const:"
"`Z_FULL_FLUSH`, :const:`Z_BLOCK` (zlib 1.2.3.4), or :const:`Z_FINISH`, "
"defaulting to :const:`Z_FINISH`.  Except :const:`Z_FINISH`, all constants "
"allow compressing further bytestrings of data, while :const:`Z_FINISH` "
"finishes the compressed stream and prevents compressing any more data.  "
"After calling :meth:`flush` with *mode* set to :const:`Z_FINISH`, the :meth:"
"`compress` method cannot be called again; the only realistic action is to "
"delete the object."
msgstr ""
"Усі вхідні дані, що очікують на розгляд, обробляються, і повертається об’єкт "
"bytes, що містить залишковий стиснутий вихід. *режим* можна вибрати з "
"констант :const:`Z_NO_FLUSH`, :const:`Z_PARTIAL_FLUSH`, :const:"
"`Z_SYNC_FLUSH`, :const:`Z_FULL_FLUSH`, :const:`Z_BLOCK` (zlib 1.2.3.4), або :"
"const:`Z_FINISH`, за умовчанням :const:`Z_FINISH`. Крім :const:`Z_FINISH`, "
"усі константи дозволяють стискати подальші байтові рядки даних, тоді як :"
"const:`Z_FINISH` завершує стиснутий потік і запобігає подальшому стисненню "
"даних. Після виклику :meth:`flush` з *mode*, встановленим на :const:"
"`Z_FINISH`, метод :meth:`compress` не можна викликати повторно; єдина "
"реалістична дія - це видалити об'єкт."

msgid ""
"Returns a copy of the compression object.  This can be used to efficiently "
"compress a set of data that share a common initial prefix."
msgstr ""
"Повертає копію об’єкта стиснення. Це можна використовувати для ефективного "
"стиснення набору даних, які мають спільний початковий префікс."

msgid ""
"Added :func:`copy.copy` and :func:`copy.deepcopy` support to compression "
"objects."
msgstr ""
"Додано підтримку :func:`copy.copy` і :func:`copy.deepcopy` для об’єктів "
"стиснення."

msgid "Decompression objects support the following methods and attributes:"
msgstr "Об’єкти декомпресії підтримують такі методи та атрибути:"

msgid ""
"A bytes object which contains any bytes past the end of the compressed data. "
"That is, this remains ``b\"\"`` until the last byte that contains "
"compression data is available.  If the whole bytestring turned out to "
"contain compressed data, this is ``b\"\"``, an empty bytes object."
msgstr ""
"Об’єкт bytes, який містить будь-які байти після кінця стиснутих даних. Тобто "
"це залишається ``b\"\"``, поки не стане доступним останній байт, який "
"містить дані стиснення. Якщо виявилося, що весь байтовий рядок містить "
"стислі дані, це ``b\"\"``, порожній об'єкт байтів."

msgid ""
"A bytes object that contains any data that was not consumed by the last :"
"meth:`decompress` call because it exceeded the limit for the uncompressed "
"data buffer.  This data has not yet been seen by the zlib machinery, so you "
"must feed it (possibly with further data concatenated to it) back to a "
"subsequent :meth:`decompress` method call in order to get correct output."
msgstr ""
"Об’єкт bytes, який містить будь-які дані, які не були використані останнім "
"викликом :meth:`decompress`, оскільки він перевищив обмеження для буфера "
"нестиснутих даних. Ці дані ще не були розглянуті механізмом zlib, тому ви "
"повинні передати їх (можливо, з додатковими даними, об’єднаними з ними) до "
"наступного виклику методу :meth:`decompress`, щоб отримати правильний "
"результат."

msgid ""
"A boolean indicating whether the end of the compressed data stream has been "
"reached."
msgstr ""
"Логічне значення, яке вказує, чи досягнуто кінця стисненого потоку даних."

msgid ""
"This makes it possible to distinguish between a properly-formed compressed "
"stream, and an incomplete or truncated one."
msgstr ""
"Це дозволяє відрізнити правильно сформований стислий потік від неповного або "
"усіченого."

msgid ""
"Decompress *data*, returning a bytes object containing the uncompressed data "
"corresponding to at least part of the data in *string*.  This data should be "
"concatenated to the output produced by any preceding calls to the :meth:"
"`decompress` method.  Some of the input data may be preserved in internal "
"buffers for later processing."
msgstr ""
"Розпакуйте *data*, повертаючи об’єкт bytes, що містить нестиснуті дані, що "
"відповідають принаймні частині даних у *string*. Ці дані мають бути "
"об’єднані з виводом, створеним будь-якими попередніми викликами методу :meth:"
"`decompress`. Деякі вхідні дані можуть бути збережені у внутрішніх буферах "
"для подальшої обробки."

msgid ""
"If the optional parameter *max_length* is non-zero then the return value "
"will be no longer than *max_length*. This may mean that not all of the "
"compressed input can be processed; and unconsumed data will be stored in the "
"attribute :attr:`unconsumed_tail`. This bytestring must be passed to a "
"subsequent call to :meth:`decompress` if decompression is to continue.  If "
"*max_length* is zero then the whole input is decompressed, and :attr:"
"`unconsumed_tail` is empty."
msgstr ""
"Якщо необов’язковий параметр *max_length* відмінний від нуля, тоді повернуте "
"значення не буде довшим за *max_length*. Це може означати, що не весь "
"стиснутий вхід може бути оброблений; а неспожиті дані зберігатимуться в "
"атрибуті :attr:`unconsumed_tail`. Цей байтовий рядок необхідно передати "
"наступному виклику :meth:`decompress`, якщо розпакування має продовжуватися. "
"Якщо *max_length* дорівнює нулю, то весь вхід розпаковується, а :attr:"
"`unconsumed_tail` порожній."

msgid "*max_length* can be used as a keyword argument."
msgstr "*max_length* можна використовувати як аргумент ключового слова."

msgid ""
"All pending input is processed, and a bytes object containing the remaining "
"uncompressed output is returned.  After calling :meth:`flush`, the :meth:"
"`decompress` method cannot be called again; the only realistic action is to "
"delete the object."
msgstr ""
"Усі вхідні дані, що очікують на розгляд, обробляються, і повертається об’єкт "
"bytes, що містить залишковий нестиснутий вихід. Після виклику :meth:`flush` "
"метод :meth:`decompress` не можна викликати знову; єдина реалістична дія - "
"це видалити об'єкт."

msgid ""
"The optional parameter *length* sets the initial size of the output buffer."
msgstr ""
"Додатковий параметр *length* встановлює початковий розмір вихідного буфера."

msgid ""
"Returns a copy of the decompression object.  This can be used to save the "
"state of the decompressor midway through the data stream in order to speed "
"up random seeks into the stream at a future point."
msgstr ""
"Повертає копію розпакованого об’єкта. Це можна використовувати для "
"збереження стану декомпресора в середині потоку даних, щоб пришвидшити "
"випадковий пошук у потоці в майбутньому."

msgid ""
"Added :func:`copy.copy` and :func:`copy.deepcopy` support to decompression "
"objects."
msgstr ""
"Додано підтримку :func:`copy.copy` і :func:`copy.deepcopy` для об’єктів "
"декомпресії."

msgid ""
"Information about the version of the zlib library in use is available "
"through the following constants:"
msgstr ""
"Інформація про версію використовуваної бібліотеки zlib доступна через такі "
"константи:"

msgid ""
"The version string of the zlib library that was used for building the "
"module. This may be different from the zlib library actually used at "
"runtime, which is available as :const:`ZLIB_RUNTIME_VERSION`."
msgstr ""
"Рядок версії бібліотеки zlib, який використовувався для створення модуля. Це "
"може відрізнятися від бібліотеки zlib, яка фактично використовується під час "
"виконання, яка доступна як :const:`ZLIB_RUNTIME_VERSION`."

msgid ""
"The version string of the zlib library actually loaded by the interpreter."
msgstr "Рядок версії бібліотеки zlib, фактично завантажений інтерпретатором."

msgid "Module :mod:`gzip`"
msgstr "Модуль :mod:`gzip`"

msgid "Reading and writing :program:`gzip`\\ -format files."
msgstr "Читання та запис файлів у форматі :program:`gzip`\\."

msgid "http://www.zlib.net"
msgstr "http://www.zlib.net"

msgid "The zlib library home page."
msgstr "Домашня сторінка бібліотеки zlib."

msgid "http://www.zlib.net/manual.html"
msgstr "http://www.zlib.net/manual.html"

msgid ""
"The zlib manual explains  the semantics and usage of the library's many "
"functions."
msgstr ""
"У посібнику з zlib пояснюється семантика та використання багатьох функцій "
"бібліотеки."
