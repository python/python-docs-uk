# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- інтерфейс DB-API 2.0 для баз даних SQLite"

msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Вихідний код:** :source:`Lib/sqlite3/`"

msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite — це бібліотека C, яка надає легку дискову базу даних, яка не "
"потребує окремого серверного процесу та дозволяє отримувати доступ до бази "
"даних за допомогою нестандартного варіанту мови запитів SQL. Деякі програми "
"можуть використовувати SQLite для внутрішнього зберігання даних. Також можна "
"створити прототип програми за допомогою SQLite, а потім перенести код у "
"більшу базу даних, таку як PostgreSQL або Oracle."

msgid ""
"The sqlite3 module was written by Gerhard Häring.  It provides an SQL "
"interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.7.15 or newer."
msgstr ""
"Модуль sqlite3 був написаний Герхардом Херінгом. Він забезпечує інтерфейс "
"SQL, сумісний зі специфікацією DB-API 2.0, описаною :pep:`249`, і вимагає "
"SQLite 3.7.15 або новішої версії."

msgid ""
"To use the module, start by creating a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the :file:`example."
"db` file::"
msgstr ""
"Щоб використовувати модуль, почніть із створення об’єкта :class:"
"`Connection`, який представлятиме базу даних. Тут дані зберігатимуться у "
"файлі :file:`example.db`::"

msgid ""
"The special path name ``:memory:`` can be provided to create a temporary "
"database in RAM."
msgstr ""
"Для створення тимчасової бази даних у оперативній пам’яті можна вказати "
"спеціальне ім’я шляху ``:memory:``."

msgid ""
"Once a :class:`Connection` has been established, create a :class:`Cursor` "
"object and call its :meth:`~Cursor.execute` method to perform SQL commands::"
msgstr ""
"Після встановлення :class:`Connection` створіть об’єкт :class:`Cursor` і "
"викличте його метод :meth:`~Cursor.execute` для виконання команд SQL::"

msgid ""
"The saved data is persistent: it can be reloaded in a subsequent session "
"even after restarting the Python interpreter::"
msgstr ""
"Збережені дані є постійними: їх можна перезавантажити в наступному сеансі "
"навіть після перезапуску інтерпретатора Python::"

msgid ""
"To retrieve data after executing a SELECT statement, either treat the cursor "
"as an :term:`iterator`, call the cursor's :meth:`~Cursor.fetchone` method to "
"retrieve a single matching row, or call :meth:`~Cursor.fetchall` to get a "
"list of the matching rows."
msgstr ""
"Щоб отримати дані після виконання оператора SELECT, обробляйте курсор як :"
"term:`iterator`, викличте метод курсора :meth:`~Cursor.fetchone`, щоб "
"отримати один відповідний рядок, або викликайте :meth:`~Cursor .fetchall`, "
"щоб отримати список відповідних рядків."

msgid "This example uses the iterator form::"
msgstr "У цьому прикладі використовується форма ітератора::"

msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to SQL injection attacks (see the `xkcd webcomic <https://xkcd."
"com/327/>`_ for a humorous example of what can go wrong)::"
msgstr ""
"Для операцій SQL зазвичай потрібно використовувати значення зі змінних "
"Python. Однак остерігайтеся використання рядкових операцій Python для "
"збирання запитів, оскільки вони вразливі до атак SQL-ін’єкцій (дивіться "
"`xkcd webcomic <https://xkcd.com/327/>`_ для жартівливого прикладу того, що "
"може піти не так):"

msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method. An SQL "
"statement may use one of two kinds of placeholders: question marks (qmark "
"style) or named placeholders (named style). For the qmark style, "
"``parameters`` must be a :term:`sequence <sequence>`. For the named style, "
"it can be either a :term:`sequence <sequence>` or :class:`dict` instance. "
"The length of the :term:`sequence <sequence>` must match the number of "
"placeholders, or a :exc:`ProgrammingError` is raised. If a :class:`dict` is "
"given, it must contain keys for all named parameters. Any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"Замість цього використовуйте підстановку параметрів DB-API. Щоб вставити "
"змінну в рядок запиту, використовуйте заповнювач у рядку та підставте "
"фактичні значення в запит, надавши їх як :class:`tuple` значень у другому "
"аргументі :meth:`~курсора курсора .execute` метод. Інструкція SQL може "
"використовувати один із двох видів заповнювачів: знаки питання (стиль qmark) "
"або іменовані заповнювачі (іменований стиль). Для стилю qmark ``параметри`` "
"мають бути :term:`послідовністю <sequence>`. Для названого стилю це може "
"бути екземпляр :term:`sequence <sequence>` або :class:`dict`. Довжина :term:"
"`послідовності <sequence>` має збігатися з кількістю заповнювачів, інакше "
"виникне :exc:`ProgrammingError`. Якщо вказано :class:`dict`, він повинен "
"містити ключі для всіх названих параметрів. Будь-які додаткові елементи "
"ігноруються. Ось приклад обох стилів:"

msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"Веб-сторінка SQLite; документація описує синтаксис і доступні типи даних для "
"підтримуваного діалекту SQL."

msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Підручник, довідник і приклади для вивчення синтаксису SQL."

msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Специфікація API бази даних 2.0"

msgid "PEP written by Marc-André Lemburg."
msgstr "PEP, написаний Марком-Андре Лембургом."

msgid "Module functions and constants"
msgstr "Функції модуля та константи"

msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Рядкова константа, що вказує підтримуваний рівень DB-API. Потрібний для DB-"
"API. Жорстко закодований на ``\"2.0\"``."

msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Рядкова константа, що вказує тип форматування маркера параметра, який очікує "
"модуль :mod:`sqlite3`. Потрібний для DB-API. Жорстко закодований на "
"``\"qmark\"``."

msgid ""
"The :mod:`sqlite3` module supports both ``qmark`` and ``numeric`` DB-API "
"parameter styles, because that is what the underlying SQLite library "
"supports. However, the DB-API does not allow multiple values for the "
"``paramstyle`` attribute."
msgstr ""
"Модуль :mod:`sqlite3` підтримує як стилі параметрів ``qmark``, так і "
"``numeric`` DB-API, тому що це те, що підтримує базова бібліотека SQLite. "
"Однак DB-API не допускає кількох значень для атрибута ``paramstyle``."

msgid ""
"The version number of this module, as a string. This is not the version of "
"the SQLite library."
msgstr ""
"Номер версії цього модуля у вигляді рядка. Це не версія бібліотеки SQLite."

msgid ""
"The version number of this module, as a tuple of integers. This is not the "
"version of the SQLite library."
msgstr ""
"Номер версії цього модуля у вигляді кортежу цілих чисел. Це не версія "
"бібліотеки SQLite."

msgid "The version number of the run-time SQLite library, as a string."
msgstr "Номер версії бібліотеки SQLite під час виконання у вигляді рядка."

msgid ""
"The version number of the run-time SQLite library, as a tuple of integers."
msgstr ""
"Номер версії бібліотеки SQLite під час виконання у вигляді кортежу цілих "
"чисел."

msgid ""
"Integer constant required by the DB-API, stating the level of thread safety "
"the :mod:`sqlite3` module supports. Currently hard-coded to ``1``, meaning "
"*\"Threads may share the module, but not connections.\"* However, this may "
"not always be true. You can check the underlying SQLite library's compile-"
"time threaded mode using the following query::"
msgstr ""

msgid ""
"Note that the `SQLITE_THREADSAFE levels <https://sqlite.org/compile."
"html#threadsafe>`_ do not match the DB-API 2.0 ``threadsafety`` levels."
msgstr ""

msgid ""
"This constant is meant to be used with the *detect_types* parameter of the :"
"func:`connect` function."
msgstr ""

msgid ""
"Setting it makes the :mod:`sqlite3` module parse the declared type for each "
"column it returns.  It will parse out the first word of the declared type, "
"i. e.  for \"integer primary key\", it will parse out \"integer\", or for "
"\"number(10)\" it will parse out \"number\". Then for that column, it will "
"look into the converters dictionary and use the converter function "
"registered for that type there."
msgstr ""

msgid ""
"Setting this makes the SQLite interface parse the column name for each "
"column it returns.  It will look for a string formed [mytype] in there, and "
"then decide that 'mytype' is the type of the column. It will try to find an "
"entry of 'mytype' in the converters dictionary and then use the converter "
"function found there to return the value. The column name found in :attr:"
"`Cursor.description` does not include the type, i. e. if you use something "
"like ``'as \"Expiration date [datetime]\"'`` in your SQL, then we will parse "
"out everything until the first ``'['`` for the column name and strip the "
"preceding space: the column name would simply be \"Expiration date\"."
msgstr ""

msgid ""
"Opens a connection to the SQLite database file *database*. By default "
"returns a :class:`Connection` object, unless a custom *factory* is given."
msgstr ""
"Відкриває підключення до файлу бази даних SQLite *database*. За "
"замовчуванням повертає об’єкт :class:`Connection`, якщо не вказано "
"спеціальну *фабрику*."

msgid ""
"*database* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current  working directory) of the database file to be "
"opened. You can use ``\":memory:\"`` to open a database connection to a "
"database that resides in RAM instead of on disk."
msgstr ""
"*database* — це :term:`path-like object`, який надає шлях (абсолютний або "
"відносний до поточного робочого каталогу) до файлу бази даних, який потрібно "
"відкрити. Ви можете використовувати ``\":memory:\"``, щоб відкрити "
"підключення до бази даних, яка знаходиться в оперативній пам’яті, а не на "
"диску."

msgid ""
"When a database is accessed by multiple connections, and one of the "
"processes modifies the database, the SQLite database is locked until that "
"transaction is committed. The *timeout* parameter specifies how long the "
"connection should wait for the lock to go away until raising an exception. "
"The default for the timeout parameter is 5.0 (five seconds)."
msgstr ""
"Коли доступ до бази даних здійснюється через кілька з’єднань, і один із "
"процесів змінює базу даних, база даних SQLite блокується, доки ця транзакція "
"не буде зафіксована. Параметр *timeout* визначає, як довго з’єднання має "
"чекати, поки блокування зникне, доки не буде створено виняток. За "
"замовчуванням параметр часу очікування становить 5,0 (п’ять секунд)."

msgid ""
"For the *isolation_level* parameter, please see the :attr:`~Connection."
"isolation_level` property of :class:`Connection` objects."
msgstr ""
"Для параметра *isolation_level* див. властивість :attr:`~Connection."
"isolation_level` об’єктів :class:`Connection`."

msgid ""
"SQLite natively supports only the types TEXT, INTEGER, REAL, BLOB and NULL. "
"If you want to use other types you must add support for them yourself. The "
"*detect_types* parameter and the using custom **converters** registered with "
"the module-level :func:`register_converter` function allow you to easily do "
"that."
msgstr ""

msgid ""
"*detect_types* defaults to 0 (i. e. off, no type detection), you can set it "
"to any combination of :const:`PARSE_DECLTYPES` and :const:`PARSE_COLNAMES` "
"to turn type detection on. Due to SQLite behaviour, types can't be detected "
"for generated fields (for example ``max(data)``), even when *detect_types* "
"parameter is set. In such case, the returned type is :class:`str`."
msgstr ""

msgid ""
"By default, *check_same_thread* is :const:`True` and only the creating "
"thread may use the connection. If set :const:`False`, the returned "
"connection may be shared across multiple threads. When using multiple "
"threads with the same connection writing operations should be serialized by "
"the user to avoid data corruption."
msgstr ""
"За замовчуванням *check_same_thread* має значення :const:`True`, і лише "
"потік, який створює, може використовувати з’єднання. Якщо встановлено :const:"
"`False`, повернуте з’єднання може використовуватися кількома потоками. У "
"разі використання кількох потоків з однаковим з’єднанням операції запису "
"повинні бути серіалізовані користувачем, щоб уникнути пошкодження даних."

msgid ""
"By default, the :mod:`sqlite3` module uses its :class:`Connection` class for "
"the connect call.  You can, however, subclass the :class:`Connection` class "
"and make :func:`connect` use your class instead by providing your class for "
"the *factory* parameter."
msgstr ""
"За замовчуванням модуль :mod:`sqlite3` використовує свій клас :class:"
"`Connection` для виклику підключення. Однак ви можете створити підклас "
"класу :class:`Connection` і змусити :func:`connect` використовувати ваш клас "
"замість цього, надавши ваш клас для параметра *factory*."

msgid "Consult the section :ref:`sqlite3-types` of this manual for details."
msgstr ""
"Зверніться до розділу :ref:`sqlite3-types` цього посібника, щоб дізнатися "
"більше."

msgid ""
"The :mod:`sqlite3` module internally uses a statement cache to avoid SQL "
"parsing overhead. If you want to explicitly set the number of statements "
"that are cached for the connection, you can set the *cached_statements* "
"parameter. The currently implemented default is to cache 100 statements."
msgstr ""

msgid ""
"If *uri* is :const:`True`, *database* is interpreted as a :abbr:`URI "
"(Uniform Resource Identifier)` with a file path and an optional query "
"string.  The scheme part *must* be ``\"file:\"``.  The path can be a "
"relative or absolute file path.  The query string allows us to pass "
"parameters to SQLite. Some useful URI tricks include::"
msgstr ""
"Якщо *uri* має значення :const:`True`, *база даних* інтерпретується як :abbr:"
"`URI (уніфікований ідентифікатор ресурсу)` із шляхом до файлу та "
"необов’язковим рядком запиту. Частина схеми *має* бути ``\"file:\"``. Шлях "
"може бути відносним або абсолютним шляхом до файлу. Рядок запиту дозволяє "
"нам передавати параметри в SQLite. Деякі корисні прийоми URI включають:"

msgid ""
"More information about this feature, including a list of recognized "
"parameters, can be found in the `SQLite URI documentation <https://www."
"sqlite.org/uri.html>`_."
msgstr ""
"Додаткову інформацію про цю функцію, включаючи список розпізнаних "
"параметрів, можна знайти в `документації SQLite URI <https://www.sqlite.org/"
"uri.html>`_."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``sqlite3.connect`` з аргументом "
"``база даних``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``sqlite3.connect/handle`` з "
"аргументом ``connection_handle``."

msgid "Added the *uri* parameter."
msgstr "Додано параметр *uri*."

msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* тепер також може бути :term:`path-like object`, а не лише рядком."

msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr "Додано подію аудиту ``sqlite3.connect/handle``."

msgid ""
"Registers a callable to convert a bytestring from the database into a custom "
"Python type. The callable will be invoked for all database values that are "
"of the type *typename*. Confer the parameter *detect_types* of the :func:"
"`connect` function for how the type detection works. Note that *typename* "
"and the name of the type in your query are matched in case-insensitive "
"manner."
msgstr ""

msgid ""
"Registers a callable to convert the custom Python type *type* into one of "
"SQLite's supported types. The callable *callable* accepts as single "
"parameter the Python value, and must return a value of the following types: "
"int, float, str or bytes."
msgstr ""

msgid ""
"Returns :const:`True` if the string *statement* contains one or more "
"complete SQL statements terminated by semicolons. It does not verify that "
"the SQL is syntactically correct, only that there are no unclosed string "
"literals and the statement is terminated by a semicolon."
msgstr ""
"Повертає :const:`True`, якщо рядок *оператор* містить один або кілька повних "
"операторів SQL, закінчених крапкою з комою. Він не перевіряє, що SQL є "
"синтаксично правильним, лише те, що немає незакритих рядкових літералів і "
"оператор завершується крапкою з комою."

msgid ""
"This can be used to build a shell for SQLite, as in the following example:"
msgstr ""
"Це можна використовувати для створення оболонки для SQLite, як у наступному "
"прикладі:"

msgid ""
"By default you will not get any tracebacks in user-defined functions, "
"aggregates, converters, authorizer callbacks etc. If you want to debug them, "
"you can call this function with *flag* set to ``True``. Afterwards, you will "
"get tracebacks from callbacks on ``sys.stderr``. Use :const:`False` to "
"disable the feature again."
msgstr ""

msgid "Connection Objects"
msgstr "Об'єкти підключення"

msgid "An SQLite database connection has the following attributes and methods:"
msgstr "Підключення до бази даних SQLite має такі атрибути та методи:"

msgid ""
"Get or set the current default isolation level. :const:`None` for autocommit "
"mode or one of \"DEFERRED\", \"IMMEDIATE\" or \"EXCLUSIVE\". See section :"
"ref:`sqlite3-controlling-transactions` for a more detailed explanation."
msgstr ""
"Отримати або встановити поточний рівень ізоляції за замовчуванням. :const:"
"`None` для режиму автозакріплення або одного з \"ВІДкладено\", \"НЕГАЙНО\" "
"чи \"ВИКЛЮЧНО\". Перегляньте розділ :ref:`sqlite3-controlling-transactions` "
"для більш детального пояснення."

msgid ""
":const:`True` if a transaction is active (there are uncommitted changes), :"
"const:`False` otherwise.  Read-only attribute."
msgstr ""
":const:`True`, якщо транзакція активна (є незафіксовані зміни), :const:"
"`False` інакше. Атрибут лише для читання."

msgid ""
"The cursor method accepts a single optional parameter *factory*. If "
"supplied, this must be a callable returning an instance of :class:`Cursor` "
"or its subclasses."
msgstr ""
"Метод cursor приймає один необов’язковий параметр *factory*. Якщо вказано, "
"це має бути виклик, що повертає екземпляр :class:`Cursor` або його підкласів."

msgid ""
"This method commits the current transaction. If you don't call this method, "
"anything you did since the last call to ``commit()`` is not visible from "
"other database connections. If you wonder why you don't see the data you've "
"written to the database, please check you didn't forget to call this method."
msgstr ""

msgid ""
"This method rolls back any changes to the database since the last call to :"
"meth:`commit`."
msgstr ""

msgid ""
"This closes the database connection. Note that this does not automatically "
"call :meth:`commit`. If you just close your database connection without "
"calling :meth:`commit` first, your changes will be lost!"
msgstr ""

msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.execute` для "
"нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.executemany` "
"для нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor."
"executescript` для нього за допомогою заданого *sql_script*. Повернути новий "
"об’єкт курсору."

msgid ""
"Creates a user-defined function that you can later use from within SQL "
"statements under the function name *name*. *narg* is the number of "
"parameters the function accepts (if *narg* is -1, the function may take any "
"number of arguments), and *func* is a Python callable that is called as the "
"SQL function. If *deterministic* is true, the created function is marked as "
"`deterministic <https://sqlite.org/deterministic.html>`_, which allows "
"SQLite to perform additional optimizations. This flag is supported by SQLite "
"3.8.3 or higher, :exc:`NotSupportedError` will be raised if used with older "
"versions."
msgstr ""
"Створює визначену користувачем функцію, яку можна пізніше використовувати в "
"інструкціях SQL під назвою функції *name*. *narg* — це кількість параметрів, "
"які приймає функція (якщо *narg* дорівнює -1, функція може приймати будь-яку "
"кількість аргументів), а *func* — це функція Python, яка викликається як "
"функція SQL. Якщо *deterministic* має значення true, створена функція "
"позначається як `deterministic <https://sqlite.org/deterministic.html>`_, що "
"дозволяє SQLite виконувати додаткові оптимізації. Цей прапорець "
"підтримується SQLite 3.8.3 або новішою версією, :exc:`NotSupportedError` "
"буде піднято, якщо використовується зі старішими версіями."

msgid ""
"The function can return any of the types supported by SQLite: bytes, str, "
"int, float and ``None``."
msgstr ""
"Функція може повертати будь-які типи, які підтримує SQLite: bytes, str, int, "
"float і ``None``."

msgid "The *deterministic* parameter was added."
msgstr "Додано параметр *детермінований*."

msgid "Example:"
msgstr "приклад:"

msgid "Creates a user-defined aggregate function."
msgstr "Створює визначену користувачем агрегатну функцію."

msgid ""
"The aggregate class must implement a ``step`` method, which accepts the "
"number of parameters *n_arg* (if *n_arg* is -1, the function may take any "
"number of arguments), and a ``finalize`` method which will return the final "
"result of the aggregate."
msgstr ""
"Агрегатний клас повинен реалізовувати метод \"step\", який приймає кількість "
"параметрів *n_arg* (якщо *n_arg* дорівнює -1, функція може приймати будь-яку "
"кількість аргументів), і метод \"finalize\", який поверне кінцевий результат "
"агрегату."

msgid ""
"The ``finalize`` method can return any of the types supported by SQLite: "
"bytes, str, int, float and ``None``."
msgstr ""
"Метод ``finalize`` може повертати будь-які типи, які підтримує SQLite: "
"bytes, str, int, float і ``None``."

msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"Створіть зіставлення під назвою *name* за допомогою функції зіставлення "
"*callable*. *callable* передається два аргументи :class:`string <str>`, і "
"він має повернути :class:`ціле число <int>`:"

msgid "``1`` if the first is ordered higher than the second"
msgstr "``1``, якщо перший впорядкований вище за другий"

msgid "``-1`` if the first is ordered lower than the second"
msgstr "``-1``, якщо перший впорядкований нижче другого"

msgid "``0`` if they are ordered equal"
msgstr "``0``, якщо вони в порядку рівності"

msgid "The following example shows a reverse sorting collation:"
msgstr "У наступному прикладі показано порівняння зворотного сортування:"

msgid "Remove a collation function by setting *callable* to :const:`None`."
msgstr ""
"Видаліть функцію порівняння, встановивши для *callable* значення :const:"
"`None`."

msgid ""
"You can call this method from a different thread to abort any queries that "
"might be executing on the connection. The query will then abort and the "
"caller will get an exception."
msgstr ""
"Ви можете викликати цей метод з іншого потоку, щоб скасувати будь-які "
"запити, які можуть виконуватися на з’єднанні. Після цього запит буде "
"перервано, а абонент отримає виняток."

msgid ""
"This routine registers a callback. The callback is invoked for each attempt "
"to access a column of a table in the database. The callback should return :"
"const:`SQLITE_OK` if access is allowed, :const:`SQLITE_DENY` if the entire "
"SQL statement should be aborted with an error and :const:`SQLITE_IGNORE` if "
"the column should be treated as a NULL value. These constants are available "
"in the :mod:`sqlite3` module."
msgstr ""
"Ця процедура реєструє зворотний виклик. Зворотний виклик викликається для "
"кожної спроби отримати доступ до стовпця таблиці в базі даних. Зворотний "
"виклик має повернути :const:`SQLITE_OK`, якщо доступ дозволено, :const:"
"`SQLITE_DENY`, якщо весь оператор SQL має бути перервано з помилкою, і :"
"const:`SQLITE_IGNORE`, якщо стовпець має розглядатися як значення NULL. Ці "
"константи доступні в модулі :mod:`sqlite3`."

msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or :const:`None` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or :const:`None` if this access attempt is directly from input SQL "
"code."
msgstr ""
"Перший аргумент зворотного виклику вказує, яку операцію потрібно "
"авторизувати. Другий і третій аргументи будуть аргументами або :const:`None` "
"залежно від першого аргументу. Четвертий аргумент — це ім’я бази даних "
"(\"main\", \"temp\" тощо), якщо це можливо. 5-й аргумент — це ім’я самого "
"внутрішнього тригера або перегляду, який відповідає за спробу доступу, або :"
"const:`None`, якщо ця спроба доступу здійснюється безпосередньо з вхідного "
"коду SQL."

msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`sqlite3` "
"module."
msgstr ""
"Зверніться до документації SQLite щодо можливих значень для першого "
"аргументу та значення другого та третього аргументів залежно від першого. "
"Усі необхідні константи доступні в модулі :mod:`sqlite3`."

msgid ""
"This routine registers a callback. The callback is invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"Ця процедура реєструє зворотний виклик. Зворотний виклик викликається для "
"кожних *n* інструкцій віртуальної машини SQLite. Це корисно, якщо ви хочете "
"отримати виклик із SQLite під час тривалих операцій, наприклад, щоб оновити "
"графічний інтерфейс."

msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with :const:`None` for *progress_handler*."
msgstr ""
"Якщо ви хочете очистити будь-який раніше встановлений обробник прогресу, "
"викличте метод за допомогою :const:`None` для *progress_handler*."

msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr ""
"Повернення ненульового значення з функції обробника призведе до завершення "
"запиту, що виконується, і викликання виключення :exc:`OperationalError`."

msgid ""
"Registers *trace_callback* to be called for each SQL statement that is "
"actually executed by the SQLite backend."
msgstr ""
"Реєструє *trace_callback* для кожного оператора SQL, який фактично "
"виконується серверною частиною SQLite."

msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the sqlite3 module and the execution "
"of triggers defined in the current database."
msgstr ""
"Єдиним аргументом, який передається зворотному виклику, є оператор (як :"
"class:`str`), який виконується. Повернене значення зворотного виклику "
"ігнорується. Зауважте, що бекенд виконує не лише оператори, передані "
"методам :meth:`Cursor.execute`. Інші джерела включають :ref:`керування "
"транзакціями <sqlite3-controlling-transactions>` модуля sqlite3 і виконання "
"тригерів, визначених у поточній базі даних."

msgid ""
"Passing :const:`None` as *trace_callback* will disable the trace callback."
msgstr ""
"Передача :const:`None` як *trace_callback* вимкне зворотний виклик "
"трасування."

msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Винятки, викликані зворотним викликом трасування, не поширюються. Як "
"допомога при розробці та налагодженні використовуйте :meth:`~sqlite3."
"enable_callback_tracebacks`, щоб увімкнути друк трасування з винятків, "
"викликаних у зворотному виклику трасування."

msgid ""
"This routine allows/disallows the SQLite engine to load SQLite extensions "
"from shared libraries.  SQLite extensions can define new functions, "
"aggregates or whole new virtual table implementations.  One well-known "
"extension is the fulltext-search extension distributed with SQLite."
msgstr ""
"Ця процедура дозволяє/забороняє механізму SQLite завантажувати розширення "
"SQLite зі спільних бібліотек. Розширення SQLite можуть визначати нові "
"функції, агрегати або зовсім нові реалізації віртуальних таблиць. Одним із "
"відомих розширень є розширення повнотекстового пошуку, що поширюється разом "
"із SQLite."

msgid "Loadable extensions are disabled by default. See [#f1]_."
msgstr "Завантажувані розширення вимкнено за умовчанням. Див. [#f1]_."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``sqlite3.enable_load_extension`` з "
"аргументами ``connection``, ``enabled``."

msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "Додано подію аудиту sqlite3.enable_load_extension."

msgid ""
"This routine loads an SQLite extension from a shared library.  You have to "
"enable extension loading with :meth:`enable_load_extension` before you can "
"use this routine."
msgstr ""
"Ця процедура завантажує розширення SQLite із спільної бібліотеки. Ви повинні "
"ввімкнути завантаження розширення за допомогою :meth:"
"`enable_load_extension`, перш ніж ви зможете використовувати цю процедуру."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``sqlite3.load_extension`` з "
"аргументами ``connection``, ``path``."

msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "Додано подію аудиту ``sqlite3.load_extension``."

msgid ""
"You can change this attribute to a callable that accepts the cursor and the "
"original row as a tuple and will return the real result row.  This way, you "
"can implement more advanced ways of returning results, such  as returning an "
"object that can also access columns by name."
msgstr ""
"Ви можете змінити цей атрибут на виклик, який приймає курсор і оригінальний "
"рядок як кортеж і повертатиме справжній рядок результату. Таким чином ви "
"можете реалізувати більш просунуті способи повернення результатів, наприклад "
"повернення об’єкта, який також може отримати доступ до стовпців за назвою."

msgid ""
"If returning a tuple doesn't suffice and you want name-based access to "
"columns, you should consider setting :attr:`row_factory` to the highly-"
"optimized :class:`sqlite3.Row` type. :class:`Row` provides both index-based "
"and case-insensitive name-based access to columns with almost no memory "
"overhead. It will probably be better than your own custom dictionary-based "
"approach or even a db_row based solution."
msgstr ""
"Якщо повернення кортежу недостатньо, і ви бажаєте отримати доступ до "
"стовпців на основі імен, вам слід розглянути можливість налаштування :attr:"
"`row_factory` високооптимізованого типу :class:`sqlite3.Row`. :class:`Row` "
"забезпечує доступ до стовпців як на основі індексу, так і на основі імен без "
"урахування регістру майже без витрат пам’яті. Ймовірно, це буде краще, ніж "
"ваш власний підхід на основі словника або навіть рішення на основі db_row."

msgid ""
"Using this attribute you can control what objects are returned for the "
"``TEXT`` data type. By default, this attribute is set to :class:`str` and "
"the :mod:`sqlite3` module will return :class:`str` objects for ``TEXT``. If "
"you want to return :class:`bytes` instead, you can set it to :class:`bytes`."
msgstr ""
"Використовуючи цей атрибут, ви можете контролювати, які об’єкти повертаються "
"для типу даних ``ТЕКСТ``. За замовчуванням цей атрибут має значення :class:"
"`str`, а модуль :mod:`sqlite3` повертатиме об’єкти :class:`str` для "
"``TEXT``. Якщо замість цього ви хочете повернути :class:`bytes`, ви можете "
"встановити значення :class:`bytes`."

msgid ""
"You can also set it to any other callable that accepts a single bytestring "
"parameter and returns the resulting object."
msgstr ""
"Ви також можете встановити для нього будь-який інший виклик, який приймає "
"один параметр bytestring і повертає результуючий об’єкт."

msgid "See the following example code for illustration:"
msgstr "Перегляньте наведений нижче приклад коду для ілюстрації:"

msgid ""
"Returns the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Повертає загальну кількість рядків бази даних, які було змінено, вставлено "
"або видалено з моменту відкриття підключення до бази даних."

msgid ""
"Returns an iterator to dump the database in an SQL text format.  Useful when "
"saving an in-memory database for later restoration.  This function provides "
"the same capabilities as the :kbd:`.dump` command in the :program:`sqlite3` "
"shell."
msgstr ""
"Повертає ітератор для створення дампу бази даних у текстовому форматі SQL. "
"Корисно під час збереження бази даних у пам’яті для подальшого відновлення. "
"Ця функція надає ті самі можливості, що й команда :kbd:`.dump` в оболонці :"
"program:`sqlite3`."

msgid "Example::"
msgstr "Приклад::"

msgid ""
"This method makes a backup of an SQLite database even while it's being "
"accessed by other clients, or concurrently by the same connection.  The copy "
"will be written into the mandatory argument *target*, that must be another :"
"class:`Connection` instance."
msgstr ""
"Цей метод створює резервну копію бази даних SQLite, навіть коли до неї "
"звертаються інші клієнти або одночасно через те саме з’єднання. Копія буде "
"записана в обов’язковий аргумент *target*, який має бути іншим екземпляром :"
"class:`Connection`."

msgid ""
"By default, or when *pages* is either ``0`` or a negative integer, the "
"entire database is copied in a single step; otherwise the method performs a "
"loop copying up to *pages* pages at a time."
msgstr ""
"За замовчуванням або коли *pages* має значення ``0`` або ціле від’ємне "
"число, вся база даних копіюється за один крок; інакше метод виконує цикл, "
"копіюючи до *pages* сторінок за раз."

msgid ""
"If *progress* is specified, it must either be ``None`` or a callable object "
"that will be executed at each iteration with three integer arguments, "
"respectively the *status* of the last iteration, the *remaining* number of "
"pages still to be copied and the *total* number of pages."
msgstr ""
"Якщо вказано *прогрес*, він має бути ``None`` або об’єктом, що викликається, "
"який виконуватиметься на кожній ітерації з трьома цілими аргументами, "
"відповідно *статусом* останньої ітерації, *кількістю сторінок, що "
"залишилася* для копіювання та *загальна* кількість сторінок."

msgid ""
"The *name* argument specifies the database name that will be copied: it must "
"be a string containing either ``\"main\"``, the default, to indicate the "
"main database, ``\"temp\"`` to indicate the temporary database or the name "
"specified after the ``AS`` keyword in an ``ATTACH DATABASE`` statement for "
"an attached database."
msgstr ""
"Аргумент *name* визначає назву бази даних, яку буде скопійовано: це має бути "
"рядок, що містить або ``\"main\"``, за замовчуванням, для позначення "
"основної бази даних, ``\"temp\"`` для позначення тимчасової бази даних або "
"ім’я, указане після ключового слова ``AS`` в операторі ``ATTACH DATABASE`` "
"для приєднаної бази даних."

msgid ""
"The *sleep* argument specifies the number of seconds to sleep by between "
"successive attempts to backup remaining pages, can be specified either as an "
"integer or a floating point value."
msgstr ""
"Аргумент *sleep* визначає кількість секунд для сну між послідовними спробами "
"резервного копіювання сторінок, що залишилися, і може бути вказаний у "
"вигляді цілого числа або значення з плаваючою комою."

msgid "Example 1, copy an existing database into another::"
msgstr "Приклад 1, копіювання існуючої бази даних в іншу::"

msgid "Example 2, copy an existing database into a transient copy::"
msgstr "Приклад 2, копіювання існуючої бази даних у тимчасову копію::"

msgid "Cursor Objects"
msgstr "Об'єкти курсора"

msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "Екземпляр :class:`Cursor` має такі атрибути та методи."

msgid ""
"Executes an SQL statement. Values may be bound to the statement using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""
"Виконує оператор SQL. Значення можуть бути прив’язані до оператора за "
"допомогою :ref:`placeholders <sqlite3-placeholders>`."

msgid ""
":meth:`execute` will only execute a single SQL statement. If you try to "
"execute more than one statement with it, it will raise a :exc:`Warning`. "
"Use :meth:`executescript` if you want to execute multiple SQL statements "
"with one call."
msgstr ""

msgid ""
"Executes a :ref:`parameterized <sqlite3-placeholders>` SQL command against "
"all parameter sequences or mappings found in the sequence "
"*seq_of_parameters*. The :mod:`sqlite3` module also allows using an :term:"
"`iterator` yielding parameters instead of a sequence."
msgstr ""
"Виконує :ref:`параметризовану <sqlite3-placeholders>` команду SQL проти всіх "
"послідовностей параметрів або зіставлень, знайдених у послідовності "
"*seq_of_parameters*. Модуль :mod:`sqlite3` також дозволяє використовувати :"
"term:`iterator` вихідні параметри замість послідовності."

msgid "Here's a shorter example using a :term:`generator`:"
msgstr "Ось коротший приклад використання :term:`generator`:"

msgid ""
"This is a nonstandard convenience method for executing multiple SQL "
"statements at once. It issues a ``COMMIT`` statement first, then executes "
"the SQL script it gets as a parameter.  This method disregards :attr:"
"`isolation_level`; any transaction control must be added to *sql_script*."
msgstr ""
"Це нестандартний зручний метод для одночасного виконання кількох операторів "
"SQL. Спочатку він видає оператор ``COMMIT``, а потім виконує сценарій SQL, "
"який отримує як параметр. Цей метод ігнорує :attr:`isolation_level`; будь-"
"який контроль транзакцій має бути доданий до *sql_script*."

msgid "*sql_script* can be an instance of :class:`str`."
msgstr "*sql_script* може бути екземпляром :class:`str`."

msgid ""
"Fetches the next row of a query result set, returning a single sequence, or :"
"const:`None` when no more data is available."
msgstr ""
"Отримує наступний рядок із набору результатів запиту, повертаючи одну "
"послідовність або :const:`None`, якщо більше немає даних."

msgid ""
"Fetches the next set of rows of a query result, returning a list.  An empty "
"list is returned when no more rows are available."
msgstr ""
"Отримує наступний набір рядків результату запиту, повертаючи список. "
"Порожній список повертається, якщо більше немає рядків."

msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If it is not given, the cursor's arraysize determines the number of rows to "
"be fetched. The method should try to fetch as many rows as indicated by the "
"size parameter. If this is not possible due to the specified number of rows "
"not being available, fewer rows may be returned."
msgstr ""
"Кількість рядків, які потрібно отримати за виклик, визначається параметром "
"*size*. Якщо його не вказано, розмір масиву курсору визначає кількість "
"рядків, які потрібно отримати. Метод повинен спробувати отримати стільки "
"рядків, скільки вказано параметром size. Якщо це неможливо через відсутність "
"зазначеної кількості рядків, може бути повернуто менше рядків."

msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Зауважте, що з параметром *size* пов’язані міркування щодо продуктивності. "
"Для оптимальної продуктивності зазвичай найкраще використовувати атрибут "
"arraysize. Якщо використовується параметр *size*, то найкраще, щоб він "
"зберігав те саме значення від одного виклику :meth:`fetchmany` до наступного."

msgid ""
"Fetches all (remaining) rows of a query result, returning a list.  Note that "
"the cursor's arraysize attribute can affect the performance of this "
"operation. An empty list is returned when no rows are available."
msgstr ""
"Отримує всі (решту) рядки результату запиту, повертаючи список. Зауважте, що "
"атрибут arraysize курсора може вплинути на продуктивність цієї операції. "
"Якщо немає доступних рядків, повертається порожній список."

msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Закрийте курсор зараз (а не під час кожного виклику ``__del__``)."

msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"Курсор стане непридатним для використання з цього моменту; виняток :exc:"
"`ProgrammingError` буде викликано, якщо будь-яка операція буде виконана з "
"курсором."

msgid "Required by the DB-API. Does nothing in :mod:`sqlite3`."
msgstr "Потрібний для DB-API. Нічого не робить у :mod:`sqlite3`."

msgid ""
"Although the :class:`Cursor` class of the :mod:`sqlite3` module implements "
"this attribute, the database engine's own support for the determination of "
"\"rows affected\"/\"rows selected\" is quirky."
msgstr ""
"Незважаючи на те, що клас :class:`Cursor` модуля :mod:`sqlite3` реалізує цей "
"атрибут, власна підтримка механізмом бази даних для визначення \"рядків, які "
"постраждали\"/\"рядків, які вибрано\", є дивною."

msgid ""
"For :meth:`executemany` statements, the number of modifications are summed "
"up into :attr:`rowcount`."
msgstr ""
"Для операторів :meth:`executemany` кількість модифікацій підсумовується в :"
"attr:`rowcount`."

msgid ""
"As required by the Python DB API Spec, the :attr:`rowcount` attribute \"is "
"-1 in case no ``executeXX()`` has been performed on the cursor or the "
"rowcount of the last operation is not determinable by the interface\". This "
"includes ``SELECT`` statements because we cannot determine the number of "
"rows a query produced until all rows were fetched."
msgstr ""
"Згідно зі специфікацією Python DB API, атрибут :attr:`rowcount` дорівнює -1, "
"якщо над курсором не було виконано ``executeXX()`` або кількість рядків "
"останньої операції не визначається інтерфейсом \". Це включає оператори "
"``SELECT``, оскільки ми не можемо визначити кількість рядків, створених "
"запитом, доки не буде вилучено всі рядки."

msgid ""
"This read-only attribute provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is :"
"const:`None`."
msgstr ""
"Цей атрибут лише для читання надає ідентифікатор останнього вставленого "
"рядка. Він оновлюється лише після успішних операторів ``INSERT`` або "
"``REPLACE`` за допомогою методу :meth:`execute`. Для інших операторів після :"
"meth:`executemany` або :meth:`executescript`, або якщо вставка не вдалася, "
"значення ``lastrowid`` залишається незмінним. Початкове значення "
"``lastrowid``: :const:`None`."

msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Вставки в таблиці ``БЕЗ ROWID`` не записуються."

msgid "Added support for the ``REPLACE`` statement."
msgstr "Додано підтримку оператора REPLACE."

msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Атрибут читання/запису, який контролює кількість рядків, які повертає :meth:"
"`fetchmany`. Значення за замовчуванням дорівнює 1, що означає, що за виклик "
"буде отримано один рядок."

msgid ""
"This read-only attribute provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are :const:`None`."
msgstr ""
"Цей атрибут лише для читання надає назви стовпців останнього запиту. Щоб "
"залишатися сумісним з API Python DB, він повертає 7-кортеж для кожного "
"стовпця, де останні шість елементів кожного кортежу є :const:`None`."

msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Він також встановлений для операторів ``SELECT`` без будь-яких відповідних "
"рядків."

msgid ""
"This read-only attribute provides the SQLite database :class:`Connection` "
"used by the :class:`Cursor` object.  A :class:`Cursor` object created by "
"calling :meth:`con.cursor() <Connection.cursor>` will have a :attr:"
"`connection` attribute that refers to *con*::"
msgstr ""
"Цей атрибут лише для читання надає базу даних SQLite :class:`Connection`, "
"яку використовує об’єкт :class:`Cursor`. Об’єкт :class:`Cursor`, створений "
"викликом :meth:`con.cursor() <Connection.cursor>`, матиме атрибут :attr:"
"`connection`, який посилається на *con*::"

msgid "Row Objects"
msgstr "Об'єкти рядка"

msgid ""
"A :class:`Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It tries to mimic a tuple in "
"most of its features."
msgstr ""
"Екземпляр :class:`Row` служить високооптимізованою :attr:`~Connection."
"row_factory` для об’єктів :class:`Connection`. Він намагається імітувати "
"кортеж у більшості своїх функцій."

msgid ""
"It supports mapping access by column name and index, iteration, "
"representation, equality testing and :func:`len`."
msgstr ""
"Він підтримує відображення доступу за назвою та індексом стовпця, ітерацією, "
"представленням, перевіркою рівності та :func:`len`."

msgid ""
"If two :class:`Row` objects have exactly the same columns and their members "
"are equal, they compare equal."
msgstr ""
"Якщо два об’єкти :class:`Row` мають однакові стовпці, а їхні члени рівні, "
"вони порівнюються."

msgid ""
"This method returns a list of column names. Immediately after a query, it is "
"the first member of each tuple in :attr:`Cursor.description`."
msgstr ""
"Цей метод повертає список імен стовпців. Одразу після запиту він є першим "
"членом кожного кортежу в :attr:`Cursor.description`."

msgid "Added support of slicing."
msgstr "Додана підтримка нарізки."

msgid "Let's assume we initialize a table as in the example given above::"
msgstr ""
"Припустімо, що ми ініціалізуємо таблицю, як у наведеному вище прикладі:"

msgid "Now we plug :class:`Row` in::"
msgstr "Тепер ми підключаємо :class:`Row` до::"

msgid "Exceptions"
msgstr "Винятки"

msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "Ієрархія винятків визначається DB-API 2.0 (:pep:`249`)."

msgid ""
"This exception is raised by ``sqlite3`` if an SQL query is not a :class:"
"`string <str>`, or if multiple statements are passed to :meth:`~Cursor."
"execute` or :meth:`~Cursor.executemany`. ``Warning`` is a subclass of :exc:"
"`Exception`."
msgstr ""

msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Базовий клас інших винятків у цьому модулі. Використовуйте це, щоб "
"перехопити всі помилки за допомогою одного оператора :keyword:`except`. "
"``Error`` є підкласом :exc:`Exception`."

msgid ""
"This exception is raised by ``sqlite3`` for fetch across rollback, or if "
"``sqlite3`` is unable to bind parameters. ``InterfaceError`` is a subclass "
"of :exc:`Error`."
msgstr ""

msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"Виняток створено для помилок, пов’язаних із базою даних. Це служить базовим "
"винятком для кількох типів помилок бази даних. Він виникає лише неявно через "
"спеціалізовані підкласи. ``DatabaseError`` є підкласом :exc:`Error`."

msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток створено для помилок, спричинених проблемами з обробленими даними, "
"як-от числові значення поза межами діапазону та надто довгі рядки. "
"``DataError`` є підкласом :exc:`DatabaseError`."

msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток створено для помилок, які пов’язані з роботою бази даних і не "
"обов’язково знаходяться під контролем програміста. Наприклад, шлях до бази "
"даних не знайдено або транзакцію не вдалося обробити. ``OperationalError`` є "
"підкласом :exc:`DatabaseError`."

msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли порушується реляційна цілісність бази даних, "
"наприклад. не вдається перевірити зовнішній ключ. Це підклас :exc:"
"`DatabaseError`."

msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли SQLite стикається з внутрішньою помилкою. Якщо це "
"виникає, це може означати, що існує проблема з бібліотекою SQLite під час "
"виконання. ``InternalError`` є підкласом :exc:`DatabaseError`."

msgid ""
"Exception raised for ``sqlite3`` API programming errors, for example trying "
"to operate on a closed :class:`Connection`, or trying to execute non-DML "
"statements with :meth:`~Cursor.executemany`. ``ProgrammingError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""

msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to :const:"
"`True` in :meth:`~Connection.create_function`, if the underlying SQLite "
"library does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, якщо метод або API бази даних не підтримується базовою "
"бібліотекою SQLite. Наприклад, встановлення *deterministic* на :const:`True` "
"у :meth:`~Connection.create_function`, якщо базова бібліотека SQLite не "
"підтримує детерміновані функції. ``NotSupportedError`` є підкласом :exc:"
"`DatabaseError`."

msgid "SQLite and Python types"
msgstr "Типи SQLite і Python"

msgid "Introduction"
msgstr "вступ"

msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite спочатку підтримує такі типи: ``NULL``, ``INTEGER``, ``REAL``, "
"``TEXT``, ``BLOB``."

msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""
"Таким чином, такі типи Python можна без будь-яких проблем надсилати до "
"SQLite:"

msgid "Python type"
msgstr "Тип Python"

msgid "SQLite type"
msgstr "Тип SQLite"

msgid ":const:`None`"
msgstr ":const:`None`"

msgid "``NULL``"
msgstr "``NULL``"

msgid ":class:`int`"
msgstr ":class:`int`"

msgid "``INTEGER``"
msgstr "``ЦІЛЕ ЧИСЛО``"

msgid ":class:`float`"
msgstr ":class:`float`"

msgid "``REAL``"
msgstr "``РЕАЛЬНИЙ``"

msgid ":class:`str`"
msgstr ":class:`str`"

msgid "``TEXT``"
msgstr "``ТЕКСТ``"

msgid ":class:`bytes`"
msgstr ":class:`bytes`"

msgid "``BLOB``"
msgstr "``BLOB``"

msgid "This is how SQLite types are converted to Python types by default:"
msgstr "Ось як типи SQLite перетворюються на типи Python за замовчуванням:"

msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
"залежить від :attr:`~Connection.text_factory`, :class:`str` за замовчуванням"

msgid ""
"The type system of the :mod:`sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via object "
"adaptation, and you can let the :mod:`sqlite3` module convert SQLite types "
"to different Python types via converters."
msgstr ""
"Система типів модуля :mod:`sqlite3` розширюється двома способами: ви можете "
"зберігати додаткові типи Python у базі даних SQLite за допомогою адаптації "
"об’єктів, і ви можете дозволити модулю :mod:`sqlite3` перетворювати типи "
"SQLite на інший Python. типів через конвертери."

msgid "Using adapters to store additional Python types in SQLite databases"
msgstr ""

msgid ""
"As described before, SQLite supports only a limited set of types natively. "
"To use other Python types with SQLite, you must **adapt** them to one of the "
"sqlite3 module's supported types for SQLite: one of NoneType, int, float, "
"str, bytes."
msgstr ""

msgid ""
"There are two ways to enable the :mod:`sqlite3` module to adapt a custom "
"Python type to one of the supported ones."
msgstr ""

msgid "Letting your object adapt itself"
msgstr "Дозвольте своєму об’єкту адаптуватися"

msgid ""
"This is a good approach if you write the class yourself. Let's suppose you "
"have a class like this::"
msgstr ""

msgid ""
"Now you want to store the point in a single SQLite column.  First you'll "
"have to choose one of the supported types to be used for representing the "
"point. Let's just use str and separate the coordinates using a semicolon. "
"Then you need to give your class a method ``__conform__(self, protocol)`` "
"which must return the converted value. The parameter *protocol* will be :"
"class:`PrepareProtocol`."
msgstr ""

msgid "Registering an adapter callable"
msgstr "Реєстрація адаптера, що викликається"

msgid ""
"The other possibility is to create a function that converts the type to the "
"string representation and register the function with :meth:"
"`register_adapter`."
msgstr ""

msgid ""
"The :mod:`sqlite3` module has two default adapters for Python's built-in :"
"class:`datetime.date` and :class:`datetime.datetime` types.  Now let's "
"suppose we want to store :class:`datetime.datetime` objects not in ISO "
"representation, but as a Unix timestamp."
msgstr ""

msgid "Converting SQLite values to custom Python types"
msgstr "Перетворення значень SQLite на спеціальні типи Python"

msgid ""
"Writing an adapter lets you send custom Python types to SQLite. But to make "
"it really useful we need to make the Python to SQLite to Python roundtrip "
"work."
msgstr ""

msgid "Enter converters."
msgstr ""

msgid ""
"Let's go back to the :class:`Point` class. We stored the x and y coordinates "
"separated via semicolons as strings in SQLite."
msgstr ""
"Повернемося до класу :class:`Point`. Ми зберігали координати x і y, "
"розділені крапкою з комою, як рядки в SQLite."

msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`Point` object from it."
msgstr ""
"Спочатку ми визначимо функцію конвертера, яка приймає рядок як параметр і "
"створює з нього об’єкт :class:`Point`."

msgid ""
"Converter functions **always** get called with a :class:`bytes` object, no "
"matter under which data type you sent the value to SQLite."
msgstr ""

msgid ""
"Now you need to make the :mod:`sqlite3` module know that what you select "
"from the database is actually a point. There are two ways of doing this:"
msgstr ""

msgid "Implicitly via the declared type"
msgstr ""

msgid "Explicitly via the column name"
msgstr ""

msgid ""
"Both ways are described in section :ref:`sqlite3-module-contents`, in the "
"entries for the constants :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES`."
msgstr ""

msgid "The following example illustrates both approaches."
msgstr ""

msgid "Default adapters and converters"
msgstr "Стандартні адаптери та конвертери"

msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""
"У модулі datetime є стандартні адаптери для типів date і datetime. Вони "
"будуть надіслані як дати ISO/мітки часу ISO до SQLite."

msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr ""
"Перетворювачі за замовчуванням зареєстровані під назвою \"date\" для :class:"
"`datetime.date` і під назвою \"timestamp\" для :class:`datetime.datetime`."

msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""
"Таким чином, у більшості випадків ви можете використовувати мітки дати/часу "
"з Python без будь-яких додаткових маніпуляцій. Формат адаптерів також "
"сумісний з експериментальними функціями дати/часу SQLite."

msgid "The following example demonstrates this."
msgstr "Наступний приклад демонструє це."

msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""
"Якщо мітка часу, що зберігається в SQLite, має дробову частину, яка "
"перевищує 6 чисел, її значення буде скорочено до мікросекундної точності "
"конвертером міток часу."

msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"Конвертер \"міток часу\" за замовчуванням ігнорує зміщення UTC у базі даних "
"і завжди повертає простий об’єкт :class:`datetime.datetime`. Щоб зберегти "
"зміщення UTC у мітках часу, залиште конвертери вимкненими або зареєструйте "
"конвертер із зсувом за допомогою :func:`register_converter`."

msgid "Controlling Transactions"
msgstr "Контроль транзакцій"

msgid ""
"The underlying ``sqlite3`` library operates in ``autocommit`` mode by "
"default, but the Python :mod:`sqlite3` module by default does not."
msgstr ""
"Базова бібліотека ``sqlite3`` працює в режимі ``autocommit`` за "
"замовчуванням, але модуль Python :mod:`sqlite3` за замовчуванням не працює."

msgid ""
"``autocommit`` mode means that statements that modify the database take "
"effect immediately.  A ``BEGIN`` or ``SAVEPOINT`` statement disables "
"``autocommit`` mode, and a ``COMMIT``, a ``ROLLBACK``, or a ``RELEASE`` that "
"ends the outermost transaction, turns ``autocommit`` mode back on."
msgstr ""
"Режим ``autocommit`` означає, що оператори, які змінюють базу даних, "
"набувають чинності негайно. Оператор ``BEGIN`` або ``SAVEPOINT`` вимикає "
"режим ``autocommit``, а ``COMMIT``, ``ROLLBACK`` або ``RELEASE``, які "
"завершують крайню транзакцію, повертає режим ``автокомітату`` знову "
"ввімкнено."

msgid ""
"The Python :mod:`sqlite3` module by default issues a ``BEGIN`` statement "
"implicitly before a Data Modification Language (DML) statement (i.e. "
"``INSERT``/``UPDATE``/``DELETE``/``REPLACE``)."
msgstr ""
"Модуль Python :mod:`sqlite3` за замовчуванням видає оператор ``BEGIN`` "
"неявно перед оператором мови модифікації даних (DML) (тобто ``INSERT``/"
"``UPDATE``/``DELETE``/``REPLACE``)."

msgid ""
"You can control which kind of ``BEGIN`` statements :mod:`sqlite3` implicitly "
"executes via the *isolation_level* parameter to the :func:`connect` call, or "
"via the :attr:`isolation_level` property of connections. If you specify no "
"*isolation_level*, a plain ``BEGIN`` is used, which is equivalent to "
"specifying ``DEFERRED``.  Other possible values are ``IMMEDIATE`` and "
"``EXCLUSIVE``."
msgstr ""
"Ви можете керувати тим, який тип операторів ``BEGIN`` :mod:`sqlite3` неявно "
"виконується через параметр *isolation_level* виклику :func:`connect` або "
"через властивість :attr:`isolation_level` підключень. Якщо ви не вкажете "
"*рівень_ізоляції*, використовується звичайний ``BEGIN``, що еквівалентно "
"вказуванню ``DEFERRED``. Інші можливі значення: ``IMMEDIATE`` і "
"``EXCLUSIVE``."

msgid ""
"You can disable the :mod:`sqlite3` module's implicit transaction management "
"by setting :attr:`isolation_level` to ``None``.  This will leave the "
"underlying ``sqlite3`` library operating in ``autocommit`` mode.  You can "
"then completely control the transaction state by explicitly issuing "
"``BEGIN``, ``ROLLBACK``, ``SAVEPOINT``, and ``RELEASE`` statements in your "
"code."
msgstr ""
"Ви можете вимкнути неявне керування транзакціями модуля :mod:`sqlite3`, "
"встановивши для :attr:`isolation_level` значення ``None``. Це залишить "
"базову бібліотеку ``sqlite3`` працювати в режимі ``autocommit``. Потім ви "
"можете повністю контролювати стан транзакції, явно видаючи оператори "
"``BEGIN``, ``ROLLBACK``, ``SAVEPOINT`` і ``RELEASE`` у вашому коді."

msgid ""
"Note that :meth:`~Cursor.executescript` disregards :attr:`isolation_level`; "
"any transaction control must be added explicitly."
msgstr ""
"Зауважте, що :meth:`~Cursor.executescript` не враховує :attr:"
"`isolation_level`; будь-який контроль транзакцій має бути доданий явно."

msgid ""
":mod:`sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`sqlite3` використовується для неявної фіксації відкритої транзакції "
"перед операторами DDL. Це вже не так."

msgid "Using :mod:`sqlite3` efficiently"
msgstr "Ефективне використання :mod:`sqlite3`"

msgid "Using shortcut methods"
msgstr "Використання методів швидкого доступу"

msgid ""
"Using the nonstandard :meth:`execute`, :meth:`executemany` and :meth:"
"`executescript` methods of the :class:`Connection` object, your code can be "
"written more concisely because you don't have to create the (often "
"superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Використовуючи нестандартні методи :meth:`execute`, :meth:`executemany` і :"
"meth:`executescript` об’єкта :class:`Connection`, ваш код можна написати "
"стисло, оскільки вам не потрібно створювати (часто зайве) :class:`Cursor` "
"об’єкти явно. Натомість об’єкти :class:`Cursor` створюються неявно, і ці "
"методи швидкого доступу повертають об’єкти курсору. Таким чином, ви можете "
"виконати оператор ``SELECT`` і перейти до нього безпосередньо, "
"використовуючи лише один виклик об’єкта :class:`Connection`."

msgid "Accessing columns by name instead of by index"
msgstr "Доступ до стовпців за назвою, а не за індексом"

msgid ""
"One useful feature of the :mod:`sqlite3` module is the built-in :class:"
"`sqlite3.Row` class designed to be used as a row factory."
msgstr ""
"Однією з корисних функцій модуля :mod:`sqlite3` є вбудований клас :class:"
"`sqlite3.Row`, призначений для використання як фабрики рядків."

msgid ""
"Rows wrapped with this class can be accessed both by index (like tuples) and "
"case-insensitively by name:"
msgstr ""
"Доступ до рядків, обернутих цим класом, можна отримати як за індексом (як "
"кортежі), так і за назвою без урахування регістру:"

msgid "Using the connection as a context manager"
msgstr "Використання підключення як контекстного менеджера"

msgid ""
"Connection objects can be used as context managers that automatically commit "
"or rollback transactions.  In the event of an exception, the transaction is "
"rolled back; otherwise, the transaction is committed:"
msgstr ""

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"The sqlite3 module is not built with loadable extension support by default, "
"because some platforms (notably macOS) have SQLite libraries which are "
"compiled without this feature. To get loadable extension support, you must "
"pass the :option:`--enable-loadable-sqlite-extensions` option to configure."
msgstr ""
"Модуль sqlite3 не створено з підтримкою завантажуваних розширень за "
"замовчуванням, оскільки деякі платформи (зокрема macOS) мають бібліотеки "
"SQLite, які скомпільовані без цієї функції. Щоб отримати підтримку "
"завантажуваних розширень, ви повинні передати параметр :option:`--enable-"
"loadable-sqlite-extensions` для налаштування."
