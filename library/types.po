# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`types` --- Dynamic type creation and names for built-in types"
msgstr ""
":mod:`types` --- Динамічне створення типів і назви для вбудованих типів"

msgid "**Source code:** :source:`Lib/types.py`"
msgstr "**Вихідний код:** :source:`Lib/types.py`"

msgid ""
"This module defines utility functions to assist in dynamic creation of new "
"types."
msgstr ""
"Цей модуль визначає службові функції, які допомагають у динамічному "
"створенні нових типів."

msgid ""
"It also defines names for some object types that are used by the standard "
"Python interpreter, but not exposed as builtins like :class:`int` or :class:"
"`str` are."
msgstr ""
"Він також визначає імена для деяких типів об’єктів, які використовуються "
"стандартним інтерпретатором Python, але не представлені у вигляді вбудованих "
"елементів, таких як :class:`int` або :class:`str`."

msgid ""
"Finally, it provides some additional type-related utility classes and "
"functions that are not fundamental enough to be builtins."
msgstr ""
"Нарешті, він надає деякі додаткові пов’язані з типами службові класи та "
"функції, які недостатньо фундаментальні, щоб бути вбудованими."

msgid "Dynamic Type Creation"
msgstr "Динамічне створення типів"

msgid "Creates a class object dynamically using the appropriate metaclass."
msgstr "Динамічно створює об’єкт класу за допомогою відповідного метакласу."

msgid ""
"The first three arguments are the components that make up a class definition "
"header: the class name, the base classes (in order), the keyword arguments "
"(such as ``metaclass``)."
msgstr ""
"Перші три аргументи є компонентами, які складають заголовок визначення "
"класу: ім’я класу, базові класи (по порядку), ключові аргументи (такі як "
"``метаклас``)."

msgid ""
"The *exec_body* argument is a callback that is used to populate the freshly "
"created class namespace. It should accept the class namespace as its sole "
"argument and update the namespace directly with the class contents. If no "
"callback is provided, it has the same effect as passing in ``lambda ns: "
"None``."
msgstr ""
"Аргумент *exec_body* є зворотним викликом, який використовується для "
"заповнення щойно створеного простору імен класу. Він повинен приймати "
"простір імен класу як єдиний аргумент і оновлювати простір імен "
"безпосередньо вмістом класу. Якщо зворотний виклик не надано, це матиме той "
"самий ефект, що й передача ``lambda ns: None``."

msgid "Calculates the appropriate metaclass and creates the class namespace."
msgstr "Обчислює відповідний метаклас і створює простір імен класу."

msgid ""
"The arguments are the components that make up a class definition header: the "
"class name, the base classes (in order) and the keyword arguments (such as "
"``metaclass``)."
msgstr ""
"Аргументи — це компоненти, які складають заголовок визначення класу: ім’я "
"класу, базові класи (по порядку) і ключові аргументи (такі як ``метаклас``)."

msgid "The return value is a 3-tuple: ``metaclass, namespace, kwds``"
msgstr "Повернене значення є кортежем із трьох: ``metaclass, namespace, kwds``"

msgid ""
"*metaclass* is the appropriate metaclass, *namespace* is the prepared class "
"namespace and *kwds* is an updated copy of the passed in *kwds* argument "
"with any ``'metaclass'`` entry removed. If no *kwds* argument is passed in, "
"this will be an empty dict."
msgstr ""
"*metaclass* — відповідний метаклас, *namespace* — це підготовлений простір "
"імен класу, а *kwds* — це оновлена копія переданого аргументу *kwds* із "
"видаленням будь-якого запису ``'metaclass'``. Якщо аргумент *kwds* не "
"передано, це буде порожній dict."

msgid ""
"The default value for the ``namespace`` element of the returned tuple has "
"changed.  Now an insertion-order-preserving mapping is used when the "
"metaclass does not have a ``__prepare__`` method."
msgstr ""
"Значення за замовчуванням для елемента ``простір імен`` повернутого кортежу "
"змінено. Тепер відображення збереження порядку вставки використовується, "
"коли метаклас не має методу ``__prepare__``."

msgid ":ref:`metaclasses`"
msgstr ":ref:`metaclasses`"

msgid "Full details of the class creation process supported by these functions"
msgstr "Повні відомості про процес створення класу, який підтримує ці функції"

msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метакласи в Python 3000"

msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Представлено хук простору імен ``__prepare__``"

msgid "Resolve MRO entries dynamically as specified by :pep:`560`."
msgstr "Динамічно вирішувати записи MRO, як зазначено :pep:`560`."

msgid ""
"This function looks for items in *bases* that are not instances of :class:"
"`type`, and returns a tuple where each such object that has an "
"``__mro_entries__`` method is replaced with an unpacked result of calling "
"this method.  If a *bases* item is an instance of :class:`type`, or it "
"doesn't have an ``__mro_entries__`` method, then it is included in the "
"return tuple unchanged."
msgstr ""
"Ця функція шукає елементи в *базах*, які не є екземплярами :class:`type`, і "
"повертає кортеж, у якому кожен такий об’єкт, що має метод "
"``__mro_entries__``, замінюється розпакованим результатом виклику цього "
"методу. Якщо елемент *bases* є екземпляром :class:`type` або він не має "
"методу ``__mro_entries__``, тоді він включається в кортеж повернення без "
"змін."

msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` - Основна підтримка модуля введення та загальних типів"

msgid "Standard Interpreter Types"
msgstr "Типи стандартних інтерпретаторів"

msgid ""
"This module provides names for many of the types that are required to "
"implement a Python interpreter. It deliberately avoids including some of the "
"types that arise only incidentally during processing such as the "
"``listiterator`` type."
msgstr ""
"Цей модуль надає назви для багатьох типів, необхідних для реалізації "
"інтерпретатора Python. Він навмисно уникає включення деяких типів, які "
"виникають лише випадково під час обробки, таких як тип ``listiterator``."

msgid ""
"Typical use of these names is for :func:`isinstance` or :func:`issubclass` "
"checks."
msgstr ""
"Зазвичай ці імена використовуються для перевірок :func:`isinstance` або :"
"func:`issubclass`."

msgid ""
"If you instantiate any of these types, note that signatures may vary between "
"Python versions."
msgstr ""
"Якщо ви створюєте екземпляр будь-якого з цих типів, зауважте, що підписи "
"можуть відрізнятися в різних версіях Python."

msgid "Standard names are defined for the following types:"
msgstr "Стандартні імена визначені для таких типів:"

msgid "The type of :data:`None`."
msgstr "Тип :data:`None`."

msgid ""
"The type of user-defined functions and functions created by :keyword:"
"`lambda`  expressions."
msgstr ""
"Тип визначених користувачем функцій і функцій, створених виразами :keyword:"
"`lambda`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``function.__new__`` with "
"argument ``code``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``function.__new__`` з аргументом "
"``code``."

msgid ""
"The audit event only occurs for direct instantiation of function objects, "
"and is not raised for normal compilation."
msgstr ""
"Подія аудиту виникає лише для прямого створення екземплярів функціональних "
"об’єктів і не виникає для звичайної компіляції."

msgid ""
"The type of :term:`generator`-iterator objects, created by generator "
"functions."
msgstr ""
"Тип об’єктів :term:`generator`-iterator, створених функціями генератора."

msgid ""
"The type of :term:`coroutine` objects, created by :keyword:`async def` "
"functions."
msgstr ""
"Тип об’єктів :term:`coroutine`, створених функціями :keyword:`async def`."

msgid ""
"The type of :term:`asynchronous generator`-iterator objects, created by "
"asynchronous generator functions."
msgstr ""
"Тип об’єктів :term:`asynchronous generator`-iterator, створених функціями "
"асинхронного генератора."

msgid "The type for code objects such as returned by :func:`compile`."
msgstr "Тип для об’єктів коду, таких як повернутий :func:`compile`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``code.__new__`` with arguments "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount``, "
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``code.__new__`` з аргументами "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount``,"
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."

msgid ""
"Note that the audited arguments may not match the names or positions "
"required by the initializer.  The audit event only occurs for direct "
"instantiation of code objects, and is not raised for normal compilation."
msgstr ""
"Зауважте, що перевірені аргументи можуть не відповідати іменам або позиціям, "
"які вимагає ініціалізатор. Подія аудиту виникає лише для прямого створення "
"екземпляра об’єктів коду та не виникає для звичайної компіляції."

msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr "Повернути копію об’єкта коду з новими значеннями для вказаних полів."

msgid ""
"The type for cell objects: such objects are used as containers for a "
"function's free variables."
msgstr ""
"Тип для об’єктів комірки: такі об’єкти використовуються як контейнери для "
"вільних змінних функції."

msgid "The type of methods of user-defined class instances."
msgstr "Тип методів екземплярів класу, визначеного користувачем."

msgid ""
"The type of built-in functions like :func:`len` or :func:`sys.exit`, and "
"methods of built-in classes.  (Here, the term \"built-in\" means \"written "
"in C\".)"
msgstr ""
"Тип вбудованих функцій, таких як :func:`len` або :func:`sys.exit`, і методи "
"вбудованих класів. (Тут термін \"вбудований\" означає \"написаний на C\".)"

msgid ""
"The type of methods of some built-in data types and base classes such as :"
"meth:`object.__init__` or :meth:`object.__lt__`."
msgstr ""
"Тип методів деяких вбудованих типів даних і базових класів, таких як :meth:"
"`object.__init__` або :meth:`object.__lt__`."

msgid ""
"The type of *bound* methods of some built-in data types and base classes. "
"For example it is the type of :code:`object().__str__`."
msgstr ""
"Тип *зв'язаних* методів деяких вбудованих типів даних і базових класів. "
"Наприклад, це тип :code:`object().__str__`."

msgid "The type of :data:`NotImplemented`."
msgstr "Тип :data:`NotImplemented`."

msgid ""
"The type of methods of some built-in data types such as :meth:`str.join`."
msgstr "Тип методів деяких вбудованих типів даних, таких як :meth:`str.join`."

msgid ""
"The type of *unbound* class methods of some built-in data types such as "
"``dict.__dict__['fromkeys']``."
msgstr ""
"Тип *незв’язаних* методів класу деяких вбудованих типів даних, таких як "
"``dict.__dict__['fromkeys']``."

msgid ""
"The type of :term:`modules <module>`. The constructor takes the name of the "
"module to be created and optionally its :term:`docstring`."
msgstr ""
"Тип :term:`modules <module>`. Конструктор приймає назву модуля, який буде "
"створено, і, за бажанням, його :term:`docstring`."

msgid ""
"Use :func:`importlib.util.module_from_spec` to create a new module if you "
"wish to set the various import-controlled attributes."
msgstr ""
"Використовуйте :func:`importlib.util.module_from_spec`, щоб створити новий "
"модуль, якщо ви бажаєте встановити різні атрибути, керовані імпортом."

msgid "The :term:`docstring` of the module. Defaults to ``None``."
msgstr ":term:`docstring` модуля. За замовчуванням ``None``."

msgid "The :term:`loader` which loaded the module. Defaults to ``None``."
msgstr ":term:`loader`, який завантажив модуль. За замовчуванням ``None``."

msgid ""
"This attribute is to match :attr:`importlib.machinery.ModuleSpec.loader` as "
"stored in the attr:`__spec__` object."
msgstr ""
"Цей атрибут має відповідати :attr:`importlib.machinery.ModuleSpec.loader`, "
"який зберігається в об’єкті attr:`__spec__`."

msgid ""
"A future version of Python may stop setting this attribute by default. To "
"guard against this potential change, preferably read from the :attr:"
"`__spec__` attribute instead or use ``getattr(module, \"__loader__\", "
"None)`` if you explicitly need to use this attribute."
msgstr ""
"Майбутня версія Python може припинити встановлення цього атрибута за "
"замовчуванням. Щоб захиститися від цієї потенційної зміни, бажано читати з "
"атрибута :attr:`__spec__` або використовувати ``getattr(module, "
"\"__loader__\", None)``, якщо вам явно потрібно використовувати цей атрибут."

msgid "Defaults to ``None``. Previously the attribute was optional."
msgstr "За замовчуванням ``None``. Раніше атрибут був необов’язковим."

msgid ""
"The name of the module. Expected to match :attr:`importlib.machinery."
"ModuleSpec.name`."
msgstr ""
"Назва модуля. Очікується відповідність :attr:`importlib.machinery.ModuleSpec."
"name`."

msgid ""
"Which :term:`package` a module belongs to. If the module is top-level (i.e. "
"not a part of any specific package) then the attribute should be set to "
"``''``, else it should be set to the name of the package (which can be :attr:"
"`__name__` if the module is a package itself). Defaults to ``None``."
msgstr ""
"До якого :term:`package` належить модуль. Якщо модуль верхнього рівня (тобто "
"не є частиною будь-якого конкретного пакета), тоді для атрибута має бути "
"встановлено значення ``''``, інакше для нього має бути встановлено назву "
"пакета (яке може бути :attr:`__name__`, якщо модуль сам є пакетом). За "
"замовчуванням ``None``."

msgid ""
"This attribute is to match :attr:`importlib.machinery.ModuleSpec.parent` as "
"stored in the attr:`__spec__` object."
msgstr ""
"Цей атрибут має відповідати :attr:`importlib.machinery.ModuleSpec.parent`, "
"який зберігається в об’єкті attr:`__spec__`."

msgid ""
"A future version of Python may stop setting this attribute by default. To "
"guard against this potential change, preferably read from the :attr:"
"`__spec__` attribute instead or use ``getattr(module, \"__package__\", "
"None)`` if you explicitly need to use this attribute."
msgstr ""
"Майбутня версія Python може припинити встановлення цього атрибута за "
"замовчуванням. Щоб захиститися від цієї потенційної зміни, бажано читати з "
"атрибута :attr:`__spec__` або використовувати ``getattr(module, "
"\"__package__\", None)``, якщо вам явно потрібно використовувати цей атрибут."

msgid ""
"A record of the module's import-system-related state. Expected to be an "
"instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"Запис стану модуля, пов’язаного з системою імпорту. Очікується, що це буде "
"екземпляр :class:`importlib.machinery.ModuleSpec`."

msgid "The type of :data:`Ellipsis`."
msgstr "Тип :data:`Ellipsis`."

msgid ""
"The type of :ref:`parameterized generics <types-genericalias>` such as "
"``list[int]``."
msgstr ""
"Тип :ref:`параметризованих генериків <types-genericalias>`, наприклад "
"``list[int]``."

msgid ""
"``t_origin`` should be a non-parameterized generic class, such as ``list``, "
"``tuple`` or ``dict``.  ``t_args`` should be a :class:`tuple` (possibly of "
"length 1) of types which parameterize ``t_origin``::"
msgstr ""
"``t_origin`` має бути непараметризованим загальним класом, таким як "
"``list``, ``tuple`` або ``dict``. ``t_args`` має бути :class:`tuple` "
"(можливо, довжиною 1) типів, які параметризують ``t_origin``::"

msgid "This type can now be subclassed."
msgstr "Цей тип тепер може бути підкласом."

msgid "The type of :ref:`union type expressions<types-union>`."
msgstr "Тип :ref:`виразів типу union <types-union>`."

msgid "The type of traceback objects such as found in ``sys.exc_info()[2]``."
msgstr "Тип об’єктів трасування, таких як знайдені в ``sys.exc_info()[2]``."

msgid ""
"See :ref:`the language reference <traceback-objects>` for details of the "
"available attributes and operations, and guidance on creating tracebacks "
"dynamically."
msgstr ""
"Перегляньте :ref:`мовну довідку <traceback-objects>`, щоб отримати детальну "
"інформацію про доступні атрибути та операції, а також вказівки щодо "
"динамічного створення трасування."

msgid ""
"The type of frame objects such as found in ``tb.tb_frame`` if ``tb`` is a "
"traceback object."
msgstr ""
"Тип об’єктів фрейму, таких як знайдені в ``tb.tb_frame``, якщо ``tb`` є "
"об’єктом трасування."

msgid ""
"See :ref:`the language reference <frame-objects>` for details of the "
"available attributes and operations."
msgstr ""
"Перегляньте :ref:`мовну довідку <frame-objects>`, щоб дізнатися більше про "
"доступні атрибути та операції."

msgid ""
"The type of objects defined in extension modules with ``PyGetSetDef``, such "
"as ``FrameType.f_locals`` or ``array.array.typecode``.  This type is used as "
"descriptor for object attributes; it has the same purpose as the :class:"
"`property` type, but for classes defined in extension modules."
msgstr ""
"Тип об’єктів, визначених у модулях розширення за допомогою ``PyGetSetDef``, "
"наприклад ``FrameType.f_locals`` або ``array.array.typecode``. Цей тип "
"використовується як дескриптор для атрибутів об'єкта; він має те саме "
"призначення, що й тип :class:`property`, але для класів, визначених у "
"модулях розширення."

msgid ""
"The type of objects defined in extension modules with ``PyMemberDef``, such "
"as ``datetime.timedelta.days``.  This type is used as descriptor for simple "
"C data members which use standard conversion functions; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"Тип об’єктів, визначених у модулях розширення за допомогою ``PyMemberDef``, "
"наприклад ``datetime.timedelta.days``. Цей тип використовується як "
"дескриптор для простих елементів даних C, які використовують стандартні "
"функції перетворення; він має те саме призначення, що й тип :class:"
"`property`, але для класів, визначених у модулях розширення."

msgid ""
"In other implementations of Python, this type may be identical to "
"``GetSetDescriptorType``."
msgstr ""
"В інших реалізаціях Python цей тип може бути ідентичним "
"``GetSetDescriptorType``."

msgid ""
"Read-only proxy of a mapping. It provides a dynamic view on the mapping's "
"entries, which means that when the mapping changes, the view reflects these "
"changes."
msgstr ""
"Проксі зіставлення лише для читання. Він забезпечує динамічний перегляд "
"записів відображення, що означає, що коли відображення змінюється, подання "
"відображає ці зміни."

msgid ""
"Updated to support the new union (``|``) operator from :pep:`584`, which "
"simply delegates to the underlying mapping."
msgstr ""
"Оновлено для підтримки нового оператора об’єднання (``|``) з :pep:`584`, "
"який просто делегує базове відображення."

msgid ""
"Return ``True`` if the underlying mapping has a key *key*, else ``False``."
msgstr ""
"Повертає ``True``, якщо базове зіставлення має ключ *key*, інакше ``False``."

msgid ""
"Return the item of the underlying mapping with key *key*.  Raises a :exc:"
"`KeyError` if *key* is not in the underlying mapping."
msgstr ""
"Поверніть елемент основного відображення за допомогою ключа *key*. Викликає :"
"exc:`KeyError`, якщо *key* не в базовому відображенні."

msgid ""
"Return an iterator over the keys of the underlying mapping.  This is a "
"shortcut for ``iter(proxy.keys())``."
msgstr ""
"Повертає ітератор над ключами основного відображення. Це ярлик для "
"``iter(proxy.keys())``."

msgid "Return the number of items in the underlying mapping."
msgstr "Повертає кількість елементів у базовому відображенні."

msgid "Return a shallow copy of the underlying mapping."
msgstr "Повернути поверхневу копію основного відображення."

msgid ""
"Return the value for *key* if *key* is in the underlying mapping, else "
"*default*.  If *default* is not given, it defaults to ``None``, so that this "
"method never raises a :exc:`KeyError`."
msgstr ""
"Повертає значення для *key*, якщо *key* є в базовому відображенні, інакше "
"*за замовчуванням*. Якщо *default* не вказано, за замовчуванням буде "
"``None``, тому цей метод ніколи не викликає :exc:`KeyError`."

msgid ""
"Return a new view of the underlying mapping's items (``(key, value)`` pairs)."
msgstr ""
"Повертає нове подання базових елементів зіставлення (пар \"(ключ, "
"значення)\")."

msgid "Return a new view of the underlying mapping's keys."
msgstr "Повернути нове подання ключів основного зіставлення."

msgid "Return a new view of the underlying mapping's values."
msgstr "Повернути нове подання значень основного зіставлення."

msgid "Return a reverse iterator over the keys of the underlying mapping."
msgstr "Повертає зворотний ітератор над ключами основного відображення."

msgid "Additional Utility Classes and Functions"
msgstr "Додаткові корисні класи та функції"

msgid ""
"A simple :class:`object` subclass that provides attribute access to its "
"namespace, as well as a meaningful repr."
msgstr ""
"Простий підклас :class:`object`, який забезпечує доступ атрибутів до свого "
"простору імен, а також значуще відображення."

msgid ""
"Unlike :class:`object`, with ``SimpleNamespace`` you can add and remove "
"attributes.  If a ``SimpleNamespace`` object is initialized with keyword "
"arguments, those are directly added to the underlying namespace."
msgstr ""
"На відміну від :class:`object`, за допомогою ``SimpleNamespace`` ви можете "
"додавати та видаляти атрибути. Якщо об’єкт ``SimpleNamespace`` "
"ініціалізовано ключовими аргументами, вони безпосередньо додаються до "
"основного простору імен."

msgid "The type is roughly equivalent to the following code::"
msgstr "Тип приблизно еквівалентний такому коду::"

msgid ""
"``SimpleNamespace`` may be useful as a replacement for ``class NS: pass``. "
"However, for a structured record type use :func:`~collections.namedtuple` "
"instead."
msgstr ""
"``SimpleNamespace`` може бути корисним як заміна ``class NS: pass``. Однак "
"для структурованого типу запису замість цього використовуйте :func:"
"`~collections.namedtuple`."

msgid ""
"Attribute order in the repr changed from alphabetical to insertion (like "
"``dict``)."
msgstr ""
"Порядок атрибутів у відображенні змінено з алфавітного на вставлення "
"(наприклад, ``dict``)."

msgid "Route attribute access on a class to __getattr__."
msgstr "Направте доступ до атрибутів класу до __getattr__."

msgid ""
"This is a descriptor, used to define attributes that act differently when "
"accessed through an instance and through a class.  Instance access remains "
"normal, but access to an attribute through a class will be routed to the "
"class's __getattr__ method; this is done by raising AttributeError."
msgstr ""
"Це дескриптор, який використовується для визначення атрибутів, які діють по-"
"різному при доступі через примірник і через клас. Доступ до екземпляра "
"залишається звичайним, але доступ до атрибута через клас буде направлено до "
"методу __getattr__ класу; це робиться шляхом виклику AttributeError."

msgid ""
"This allows one to have properties active on an instance, and have virtual "
"attributes on the class with the same name (see :class:`enum.Enum` for an "
"example)."
msgstr ""
"Це дозволяє мати активні властивості в екземплярі та мати віртуальні "
"атрибути в класі з таким же іменем (див. :class:`enum.Enum` для прикладу)."

msgid "Coroutine Utility Functions"
msgstr "Корисні функції співпрограми"

msgid ""
"This function transforms a :term:`generator` function into a :term:"
"`coroutine function` which returns a generator-based coroutine. The "
"generator-based coroutine is still a :term:`generator iterator`, but is also "
"considered to be a :term:`coroutine` object and is :term:`awaitable`.  "
"However, it may not necessarily implement the :meth:`__await__` method."
msgstr ""
"Ця функція перетворює функцію :term:`generator` на функцію :term:"
"`coroutine`, яка повертає співпрограму на основі генератора. Співпрограма на "
"основі генератора все ще є генераторним ітератором (:term:`generator "
"iterator`), але також вважається об’єктом :term:`coroutine` і :term:"
"`awaitable`. Однак він не обов’язково може реалізовувати метод :meth:"
"`__await__`."

msgid "If *gen_func* is a generator function, it will be modified in-place."
msgstr "Якщо *gen_func* є функцією генератора, її буде змінено на місці."

msgid ""
"If *gen_func* is not a generator function, it will be wrapped. If it returns "
"an instance of :class:`collections.abc.Generator`, the instance will be "
"wrapped in an *awaitable* proxy object.  All other types of objects will be "
"returned as is."
msgstr ""
"Якщо *gen_func* не є функцією генератора, її буде загорнуто. Якщо він "
"повертає екземпляр :class:`collections.abc.Generator`, екземпляр буде "
"загорнутий в *очікуваний* проксі-об’єкт. Усі інші типи об’єктів буде "
"повернено як є."
