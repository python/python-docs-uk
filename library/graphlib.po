# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`graphlib` --- Functionality to operate with graph-like structures"
msgstr ""
":mod:`graphlib` --- Функціональні можливості для роботи з графоподібними "
"структурами"

msgid "**Source code:** :source:`Lib/graphlib.py`"
msgstr "**Вихідний код:** :source:`Lib/graphlib.py`"

msgid "Provides functionality to topologically sort a graph of hashable nodes."
msgstr ""
"Надає функціональні можливості для топологічного сортування графа хешованих "
"вузлів."

msgid ""
"A topological order is a linear ordering of the vertices in a graph such "
"that for every directed edge u -> v from vertex u to vertex v, vertex u "
"comes before vertex v in the ordering. For instance, the vertices of the "
"graph may represent tasks to be performed, and the edges may represent "
"constraints that one task must be performed before another; in this example, "
"a topological ordering is just a valid sequence for the tasks. A complete "
"topological ordering is possible if and only if the graph has no directed "
"cycles, that is, if it is a directed acyclic graph."
msgstr ""
"Топологічний порядок — це лінійне впорядкування вершин графа таким чином, що "
"для кожного спрямованого ребра u -> v від вершини u до вершини v вершина u "
"стоїть перед вершиною v у порядку. Наприклад, вершини графа можуть "
"представляти завдання, які потрібно виконати, а ребра можуть представляти "
"обмеження, згідно з якими одне завдання має бути виконане раніше іншого; у "
"цьому прикладі топологічне впорядкування – це лише дійсна послідовність для "
"завдань. Повний топологічний порядок можливий тоді і тільки тоді, коли граф "
"не має орієнтованих циклів, тобто якщо він є орієнтованим ациклічним графом."

msgid ""
"If the optional *graph* argument is provided it must be a dictionary "
"representing a directed acyclic graph where the keys are nodes and the "
"values are iterables of all predecessors of that node in the graph (the "
"nodes that have edges that point to the value in the key). Additional nodes "
"can be added to the graph using the :meth:`~TopologicalSorter.add` method."
msgstr ""
"Якщо надається необов’язковий аргумент *graph*, це має бути словник, що "
"представляє спрямований ациклічний граф, де ключі є вузлами, а значення є "
"ітерованими для всіх попередників цього вузла в графі (вузли, які мають "
"ребра, які вказують на значення в ключ). Додаткові вузли можна додати до "
"графіка за допомогою методу :meth:`~TopologicalSorter.add`."

msgid ""
"In the general case, the steps required to perform the sorting of a given "
"graph are as follows:"
msgstr ""
"У загальному випадку кроки, необхідні для виконання сортування даного графа, "
"такі:"

msgid ""
"Create an instance of the :class:`TopologicalSorter` with an optional "
"initial graph."
msgstr ""
"Створіть екземпляр :class:`TopologicalSorter` із необов’язковим початковим "
"графом."

msgid "Add additional nodes to the graph."
msgstr "Додайте додаткові вузли на графік."

msgid "Call :meth:`~TopologicalSorter.prepare` on the graph."
msgstr "Викличте :meth:`~TopologicalSorter.prepare` на графіку."

msgid ""
"While :meth:`~TopologicalSorter.is_active` is ``True``, iterate over the "
"nodes returned by :meth:`~TopologicalSorter.get_ready` and process them. "
"Call :meth:`~TopologicalSorter.done` on each node as it finishes processing."
msgstr ""
"Поки :meth:`~TopologicalSorter.is_active` має значення ``True``, перебирайте "
"вузли, повернуті :meth:`~TopologicalSorter.get_ready`, і обробіть їх. "
"Викликайте :meth:`~TopologicalSorter.done` на кожному вузлі після завершення "
"обробки."

msgid ""
"In case just an immediate sorting of the nodes in the graph is required and "
"no parallelism is involved, the convenience method :meth:`TopologicalSorter."
"static_order` can be used directly:"
msgstr ""
"Якщо потрібне лише негайне сортування вузлів у графі, а паралелізм не "
"задіяний, допоміжний метод :meth:`TopologicalSorter.static_order` можна "
"використати безпосередньо:"

msgid ""
"The class is designed to easily support parallel processing of the nodes as "
"they become ready. For instance::"
msgstr ""
"Клас розроблений для легкої підтримки паралельної обробки вузлів, коли вони "
"стають готовими. Наприклад::"

msgid ""
"Add a new node and its predecessors to the graph. Both the *node* and all "
"elements in *predecessors* must be hashable."
msgstr ""
"Додайте новий вузол і його попередників до графіка. Як *вузол*, так і всі "
"елементи в *попередниках* мають бути хешованими."

msgid ""
"If called multiple times with the same node argument, the set of "
"dependencies will be the union of all dependencies passed in."
msgstr ""
"Якщо викликати кілька разів з тим самим аргументом node, набір залежностей "
"буде об’єднанням усіх переданих залежностей."

msgid ""
"It is possible to add a node with no dependencies (*predecessors* is not "
"provided) or to provide a dependency twice. If a node that has not been "
"provided before is included among *predecessors* it will be automatically "
"added to the graph with no predecessors of its own."
msgstr ""
"Можна додати вузол без залежностей (*попередники* не надаються) або надати "
"залежність двічі. Якщо вузол, який не було надано раніше, включено до "
"*попередників*, він буде автоматично доданий до графу без власних "
"попередників."

msgid ""
"Raises :exc:`ValueError` if called after :meth:`~TopologicalSorter.prepare`."
msgstr ""
"Викликає :exc:`ValueError`, якщо викликається після :meth:"
"`~TopologicalSorter.prepare`."

msgid ""
"Mark the graph as finished and check for cycles in the graph. If any cycle "
"is detected, :exc:`CycleError` will be raised, but :meth:`~TopologicalSorter."
"get_ready` can still be used to obtain as many nodes as possible until "
"cycles block more progress. After a call to this function, the graph cannot "
"be modified, and therefore no more nodes can be added using :meth:"
"`~TopologicalSorter.add`."
msgstr ""
"Позначте графік як готовий і перевірте наявність циклів у ньому. Якщо буде "
"виявлено будь-який цикл, :exc:`CycleError` буде викликано, але :meth:"
"`~TopologicalSorter.get_ready` все ще можна використовувати для отримання "
"якомога більшої кількості вузлів, доки цикли не заблокують подальший "
"прогрес. Після виклику цієї функції граф не можна змінити, і тому більше "
"вузлів не можна додавати за допомогою :meth:`~TopologicalSorter.add`."

msgid ""
"Returns ``True`` if more progress can be made and ``False`` otherwise. "
"Progress can be made if cycles do not block the resolution and either there "
"are still nodes ready that haven't yet been returned by :meth:"
"`TopologicalSorter.get_ready` or the number of nodes marked :meth:"
"`TopologicalSorter.done` is less than the number that have been returned by :"
"meth:`TopologicalSorter.get_ready`."
msgstr ""
"Повертає ``True``, якщо можна досягти більшого прогресу, і ``False`` в "
"іншому випадку. Прогрес може бути досягнутий, якщо цикли не блокують "
"розв’язку та або ще є готові вузли, які ще не повернув :meth:"
"`TopologicalSorter.get_ready`, або кількість вузлів, позначених :meth:"
"`TopologicalSorter.done`, менша ніж число, яке повернув :meth:"
"`TopologicalSorter.get_ready`."

msgid ""
"The :meth:`~TopologicalSorter.__bool__` method of this class defers to this "
"function, so instead of::"
msgstr ""
"Метод :meth:`~TopologicalSorter.__bool__` цього класу відноситься до цієї "
"функції, тому замість:"

msgid "it is possible to simply do::"
msgstr "можна просто зробити::"

msgid ""
"Raises :exc:`ValueError` if called without calling :meth:`~TopologicalSorter."
"prepare` previously."
msgstr ""
"Викликає :exc:`ValueError`, якщо викликається без попереднього виклику :meth:"
"`~TopologicalSorter.prepare`."

msgid ""
"Marks a set of nodes returned by :meth:`TopologicalSorter.get_ready` as "
"processed, unblocking any successor of each node in *nodes* for being "
"returned in the future by a call to :meth:`TopologicalSorter.get_ready`."
msgstr ""
"Позначає набір вузлів, повернутий :meth:`TopologicalSorter.get_ready`, як "
"оброблений, розблоковуючи будь-якого наступника кожного вузла в *nodes* для "
"повернення в майбутньому за допомогою виклику :meth:`TopologicalSorter."
"get_ready`."

msgid ""
"Raises :exc:`ValueError` if any node in *nodes* has already been marked as "
"processed by a previous call to this method or if a node was not added to "
"the graph by using :meth:`TopologicalSorter.add`, if called without calling :"
"meth:`~TopologicalSorter.prepare` or if node has not yet been returned by :"
"meth:`~TopologicalSorter.get_ready`."
msgstr ""
"Викликає :exc:`ValueError`, якщо будь-який вузол у *nodes* вже було "
"позначено як оброблений попереднім викликом цього методу або якщо вузол не "
"було додано до графіка за допомогою :meth:`TopologicalSorter.add`, якщо він "
"викликається без виклику :meth:`~TopologicalSorter.prepare` або якщо вузол "
"ще не повернуто :meth:`~TopologicalSorter.get_ready`."

msgid ""
"Returns a ``tuple`` with all the nodes that are ready. Initially it returns "
"all nodes with no predecessors, and once those are marked as processed by "
"calling :meth:`TopologicalSorter.done`, further calls will return all new "
"nodes that have all their predecessors already processed. Once no more "
"progress can be made, empty tuples are returned."
msgstr ""
"Повертає ``кортеж`` з усіма готовими вузлами. Спочатку він повертає всі "
"вузли без попередників, і коли вони позначаються як оброблені за допомогою "
"виклику :meth:`TopologicalSorter.done`, подальші виклики повертатимуть усі "
"нові вузли, усі їхні попередники вже оброблені. Якщо неможливо більше "
"досягти прогресу, повертаються порожні кортежі."

msgid ""
"Returns an iterator object which will iterate over nodes in a topological "
"order. When using this method, :meth:`~TopologicalSorter.prepare` and :meth:"
"`~TopologicalSorter.done` should not be called. This method is equivalent "
"to::"
msgstr ""
"Повертає об’єкт-ітератор, який виконуватиме ітерацію по вузлах у "
"топологічному порядку. Під час використання цього методу не слід викликати :"
"meth:`~TopologicalSorter.prepare` і :meth:`~TopologicalSorter.done`. Цей "
"метод еквівалентний:"

msgid ""
"The particular order that is returned may depend on the specific order in "
"which the items were inserted in the graph. For example:"
msgstr ""
"Конкретний порядок, який повертається, може залежати від конкретного "
"порядку, у якому елементи були вставлені в графік. Наприклад:"

msgid ""
"This is due to the fact that \"0\" and \"2\" are in the same level in the "
"graph (they would have been returned in the same call to :meth:"
"`~TopologicalSorter.get_ready`) and the order between them is determined by "
"the order of insertion."
msgstr ""
"Це пов’язано з тим, що \"0\" і \"2\" знаходяться на одному рівні графіка "
"(вони були б повернені під час того самого виклику :meth:`~TopologicalSorter."
"get_ready`), і порядок між ними визначається за порядком вставлення."

msgid "If any cycle is detected, :exc:`CycleError` will be raised."
msgstr "Якщо буде виявлено будь-який цикл, буде викликано :exc:`CycleError`."

msgid "Exceptions"
msgstr "Винятки"

msgid "The :mod:`graphlib` module defines the following exception classes:"
msgstr "Модуль :mod:`graphlib` визначає такі класи винятків:"

msgid ""
"Subclass of :exc:`ValueError` raised by :meth:`TopologicalSorter.prepare` if "
"cycles exist in the working graph. If multiple cycles exist, only one "
"undefined choice among them will be reported and included in the exception."
msgstr ""
"Підклас :exc:`ValueError`, створений :meth:`TopologicalSorter.prepare`, якщо "
"в робочому графі існують цикли. Якщо існує кілька циклів, лише один "
"невизначений вибір серед них буде повідомлено та включено до винятку."

msgid ""
"The detected cycle can be accessed via the second element in the :attr:"
"`~CycleError.args` attribute of the exception instance and consists in a "
"list of nodes, such that each node is, in the graph, an immediate "
"predecessor of the next node in the list. In the reported list, the first "
"and the last node will be the same, to make it clear that it is cyclic."
msgstr ""
"Доступ до виявленого циклу можна отримати через другий елемент в атрибуті :"
"attr:`~CycleError.args` екземпляра винятку, і він складається зі списку "
"вузлів, таким чином, що кожен вузол на графі є безпосереднім попередником "
"наступного вузол у списку. У звітному списку перший і останній вузол будуть "
"однаковими, щоб було зрозуміло, що він циклічний."
