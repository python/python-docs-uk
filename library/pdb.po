# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Налагоджувач Python"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**Вихідний код:** :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python"
" programs.  It supports setting (conditional) breakpoints and single "
"stepping at the source line level, inspection of stack frames, source code "
"listing, and evaluation of arbitrary Python code in the context of any stack"
" frame.  It also supports post-mortem debugging and can be called under "
"program control."
msgstr ""
"Модуль :mod:`pdb` визначає інтерактивний налагоджувач вихідного коду для "
"програм Python. Він підтримує встановлення (умовних) точок зупину та один "
"крок на рівні вихідного рядка, перевірку фреймів стеку, перелік вихідного "
"коду та оцінку довільного коду Python у контексті будь-якого фрейму стеку. "
"Він також підтримує посмертне налагодження та може бути викликаний під "
"керуванням програми."

#: ../../library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the class "
":class:`Pdb`. This is currently undocumented but easily understood by "
"reading the source.  The extension interface uses the modules :mod:`bdb` and"
" :mod:`cmd`."
msgstr ""
"Налагоджувач є розширюваним - він фактично визначений як клас :class:`Pdb`. "
"Наразі це незадокументовано, але легко зрозуміти, прочитавши джерело. "
"Інтерфейс розширення використовує модулі :mod:`bdb` і :mod:`cmd`."

#: ../../library/pdb.rst:32
msgid "Module :mod:`faulthandler`"
msgstr ""

#: ../../library/pdb.rst:33
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr ""

#: ../../library/pdb.rst:36
msgid "Module :mod:`traceback`"
msgstr ""

#: ../../library/pdb.rst:37
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""

#: ../../library/pdb.rst:39
msgid "The typical usage to break into the debugger is to insert::"
msgstr "Типовим використанням для проникнення в налагоджувач є вставка::"

#: ../../library/pdb.rst:41
msgid "import pdb; pdb.set_trace()"
msgstr ""

#: ../../library/pdb.rst:43
msgid "Or::"
msgstr ""

#: ../../library/pdb.rst:45
msgid "breakpoint()"
msgstr ""

#: ../../library/pdb.rst:47
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"у місці, куди потрібно зламати налагоджувач, а потім запустіть програму. "
"Потім ви можете покроково виконувати код, який слідує за цією інструкцією, і"
" продовжити роботу без відладчика за допомогою команди :pdbcmd:`continue`."

#: ../../library/pdb.rst:51
msgid ""
"The built-in :func:`breakpoint`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""

#: ../../library/pdb.rst:57
msgid ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"
msgstr ""

#: ../../library/pdb.rst:63
msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr ""

#: ../../library/pdb.rst:65
msgid ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"
msgstr ""

#: ../../library/pdb.rst:72
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"Завершення табуляції через модуль :mod:`readline` доступне для команд і "
"аргументів команд, напр. поточні глобальні та локальні імена пропонуються як"
" аргументи команди ``p``."

#: ../../library/pdb.rst:78
msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other scripts."
"  For example::"
msgstr ""

#: ../../library/pdb.rst:81
msgid "python -m pdb myscript.py"
msgstr ""

#: ../../library/pdb.rst:83
msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging"
" if the program being debugged exits abnormally.  After post-mortem "
"debugging (or after normal exit of the program), pdb will restart the "
"program.  Automatic restarting preserves pdb's state (such as breakpoints) "
"and in most cases is more useful than quitting the debugger upon program's "
"exit."
msgstr ""

#: ../../library/pdb.rst:89
msgid ""
"Added the ``-c`` option to execute commands as if given in a :file:`.pdbrc` "
"file; see :ref:`debugger-commands`."
msgstr ""

#: ../../library/pdb.rst:93
msgid ""
"Added the ``-m`` option to execute modules similar to the way ``python -m`` "
"does. As with a script, the debugger will pause execution just before the "
"first line of the module."
msgstr ""

#: ../../library/pdb.rst:98
msgid ""
"Typical usage to execute a statement under control of the debugger is::"
msgstr ""

#: ../../library/pdb.rst:100
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"
msgstr ""

#: ../../library/pdb.rst:109
msgid "The typical usage to inspect a crashed program is::"
msgstr "Типове використання для перевірки збійної програми:"

#: ../../library/pdb.rst:111
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"
msgstr ""

#: ../../library/pdb.rst:126
msgid ""
"The implementation of :pep:`667` means that name assignments made via "
"``pdb`` will immediately affect the active scope, even when running inside "
"an :term:`optimized scope`."
msgstr ""

#: ../../library/pdb.rst:132
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr ""
"Модуль визначає такі функції; кожен входить до відладчика дещо іншим "
"способом:"

#: ../../library/pdb.rst:137
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the"
" environment in which the code is executed; by default the dictionary of the"
" module :mod:`__main__` is used.  (See the explanation of the built-in "
":func:`exec` or :func:`eval` functions.)"
msgstr ""
"Виконайте *інструкцію* (у вигляді рядка або об’єкта коду) під керуванням "
"налагоджувача. Підказка налагоджувача з'являється перед виконанням будь-"
"якого коду; ви можете встановити точки зупинки та ввести :pdbcmd:`continue` "
"або ви можете покроково виконувати оператор за допомогою :pdbcmd:`step` або "
":pdbcmd:`next` (усі ці команди пояснюються нижче). Необов'язкові аргументи "
"*globals* і *locals* визначають середовище, в якому виконується код; за "
"замовчуванням використовується словник модуля :mod:`__main__`. (Див. "
"пояснення вбудованих функцій :func:`exec` або :func:`eval`.)"

#: ../../library/pdb.rst:149
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the"
" *expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""

#: ../../library/pdb.rst:156
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function"
" is entered."
msgstr ""
"Викличте *функцію* (об’єкт функції чи методу, а не рядок) із заданими "
"аргументами. Коли :func:`runcall` повертає, він повертає те, що повернув "
"виклик функції. Підказка налагоджувача з’являється, щойно вводиться функція."

#: ../../library/pdb.rst:164
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header*"
" is printed to the console just before debugging begins."
msgstr ""
"Введіть налагоджувач у кадрі стека викликів. Це корисно для жорсткого "
"кодування точки зупину в певній точці програми, навіть якщо код іншим чином "
"не налагоджується (наприклад, коли твердження не виконується). Якщо задано, "
"*заголовок* друкується на консолі безпосередньо перед початком налагодження."

#: ../../library/pdb.rst:169
msgid "The keyword-only argument *header*."
msgstr "Лише ключовий аргумент *header*."

#: ../../library/pdb.rst:172
msgid ""
":func:`set_trace` will enter the debugger immediately, rather than on the "
"next line of code to be executed."
msgstr ""

#: ../../library/pdb.rst:178
msgid ""
"Enter post-mortem debugging of the given *traceback* object.  If no "
"*traceback* is given, it uses the one of the exception that is currently "
"being handled (an exception must be being handled if the default is to be "
"used)."
msgstr ""
"Введіть посмертне налагодження даного об’єкта *traceback*. Якщо *traceback* "
"не надано, використовується виняткова ситуація, яка зараз обробляється "
"(виняток має оброблятися, якщо має використовуватись типове значення)."

#: ../../library/pdb.rst:186
msgid ""
"Enter post-mortem debugging of the exception found in :data:`sys.last_exc`."
msgstr ""

#: ../../library/pdb.rst:190
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want"
" to access further features, you have to do this yourself:"
msgstr ""
"Функції ``run*`` і :func:`set_trace` є псевдонімами для створення екземпляра"
" класу :class:`Pdb` і виклику однойменного методу. Якщо ви хочете отримати "
"доступ до інших функцій, ви повинні зробити це самостійно:"

#: ../../library/pdb.rst:197
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` — це клас налагоджувача."

#: ../../library/pdb.rst:199
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"Аргументи *completekey*, *stdin* і *stdout* передаються базовому класу "
":class:`cmd.Cmd`; дивіться опис там."

#: ../../library/pdb.rst:202
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name"
" patterns.  The debugger will not step into frames that originate in a "
"module that matches one of these patterns. [1]_"
msgstr ""
"Аргумент *skip*, якщо він наданий, має бути повторюваним шаблоном імен "
"модулів у стилі glob. Налагоджувач не ввійде в кадри, які походять із "
"модуля, який відповідає одному з цих шаблонів. [1]_"

#: ../../library/pdb.rst:206
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the"
" user presses :kbd:`Ctrl-C` on the console) when you give a "
":pdbcmd:`continue` command. This allows you to break into the debugger again"
" by pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT "
"handler, set *nosigint* to true."
msgstr ""

#: ../../library/pdb.rst:211
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load "
".pdbrc files from the filesystem."
msgstr ""
"Аргумент *readrc* за замовчуванням має значення true та визначає, чи буде "
"Pdb завантажувати файли .pdbrc із файлової системи."

#: ../../library/pdb.rst:214
msgid "Example call to enable tracing with *skip*::"
msgstr "Приклад виклику для ввімкнення трасування за допомогою *skip*::"

#: ../../library/pdb.rst:216
msgid "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"
msgstr ""

#: ../../library/pdb.rst:218
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr "Викликає :ref:`подію аудиту <auditing>` ``pdb.Pdb`` без аргументів."

#: ../../library/pdb.rst:220
msgid "Added the *skip* parameter."
msgstr ""

#: ../../library/pdb.rst:223
msgid ""
"Added the *nosigint* parameter. Previously, a SIGINT handler was never set "
"by Pdb."
msgstr ""

#: ../../library/pdb.rst:227
msgid "The *readrc* argument."
msgstr "Аргумент *readrc*."

#: ../../library/pdb.rst:235
msgid "See the documentation for the functions explained above."
msgstr "Дивіться документацію щодо функцій, описаних вище."

#: ../../library/pdb.rst:241
msgid "Debugger Commands"
msgstr "Команди налагоджувача"

#: ../../library/pdb.rst:243
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can"
" be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not"
" ``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"Нижче наведено команди, які розпізнає налагоджувач. Більшість команд можна "
"скоротити до однієї або двох букв, як зазначено; напр. ``h(elp)`` означає, "
"що ``h`` або ``help`` можна використовувати для введення команди довідки "
"(але не ``he`` або ``hel``, ані ``H`` або ``Довідка`` або ``ДОПОМОГА``). "
"Аргументи команд повинні бути розділені пробілами (пробілами або "
"табуляцією). Необов’язкові аргументи в синтаксисі команди беруться у "
"квадратні дужки (``[]``); квадратні дужки не можна вводити. Альтернативи в "
"синтаксисі команди розділені вертикальною рискою (``|``)."

#: ../../library/pdb.rst:252
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"Введення порожнього рядка повторює останню введену команду. Виняток: якщо "
"останньою командою була команда :pdbcmd:`list`, буде показано наступні 11 "
"рядків."

#: ../../library/pdb.rst:255
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"Команди, які не розпізнає налагоджувач, вважаються операторами Python і "
"виконуються в контексті програми, що налагоджується. Інструкції Python також"
" можуть мати префікс знаком оклику (``!``). Це потужний спосіб перевірити "
"програму, яка налагоджується; можна навіть змінити змінну або викликати "
"функцію. Коли в такому операторі виникає виняток, ім’я виключення "
"друкується, але стан налагоджувача не змінюється."

#: ../../library/pdb.rst:263
msgid ""
"Expressions/Statements whose prefix is a pdb command are now correctly "
"identified and executed."
msgstr ""

#: ../../library/pdb.rst:267
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"Налагоджувач підтримує :ref:`псевдоніми <debugger-aliases>`. Псевдоніми "
"можуть мати параметри, які дозволяють певний рівень адаптації до "
"досліджуваного контексту."

#: ../../library/pdb.rst:271
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or "
"``\";\"\";\"``."
msgstr ""
"Кілька команд можна ввести в одному рядку, розділених символом ``;;``. (Один"
" символ ``;`` не використовується, оскільки він є роздільником для кількох "
"команд у рядку, який передається синтаксичному аналізатору Python.) Для "
"розділення команд не застосовано жодного розуму; вхідні дані розбиваються на"
" першу пару ``;;``, навіть якщо вона знаходиться в середині рядка в лапках. "
"Обхідним шляхом для рядків із подвійною крапкою з комою є використання "
"неявної конкатенації рядків ``';'';''`` або ``\";\"\";\"``."

#: ../../library/pdb.rst:278
msgid ""
"To set a temporary global variable, use a *convenience variable*. A "
"*convenience variable* is a variable whose name starts with ``$``.  For "
"example, ``$foo = 1`` sets a global variable ``$foo`` which you can use in "
"the debugger session.  The *convenience variables* are cleared when the "
"program resumes execution so it's less likely to interfere with your program"
" compared to using normal variables like ``foo = 1``."
msgstr ""

#: ../../library/pdb.rst:285
msgid "There are three preset *convenience variables*:"
msgstr ""

#: ../../library/pdb.rst:287
msgid "``$_frame``: the current frame you are debugging"
msgstr ""

#: ../../library/pdb.rst:288
msgid "``$_retval``: the return value if the frame is returning"
msgstr ""

#: ../../library/pdb.rst:289
msgid "``$_exception``: the exception if the frame is raising an exception"
msgstr ""

#: ../../library/pdb.rst:293
msgid "Added the *convenience variable* feature."
msgstr ""

#: ../../library/pdb.rst:299
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt, with the exception that empty "
"lines and lines starting with ``#`` are ignored.  This is particularly "
"useful for aliases.  If both files exist, the one in the home directory is "
"read first and aliases defined there can be overridden by the local file."
msgstr ""

#: ../../library/pdb.rst:306
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as "
":pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` тепер може містити команди, які продовжують налагодження, "
"наприклад :pdbcmd:`continue` або :pdbcmd:`next`. Раніше ці команди не діяли."

#: ../../library/pdb.rst:311
msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ""

#: ../../library/pdb.rst:318
msgid ""
"Without argument, print the list of available commands.  With a *command* as"
" argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command*"
" argument must be an identifier, ``help exec`` must be entered to get help "
"on the ``!`` command."
msgstr ""
"Без аргументів вивести список доступних команд. З *командою* як аргументом "
"надрукуйте довідку про цю команду. ``help pdb`` відображає повну "
"документацію (рядок документації модуля :mod:`pdb`). Оскільки аргумент "
"*command* має бути ідентифікатором, необхідно ввести ``help exec``, щоб "
"отримати довідку щодо команди ``!``."

#: ../../library/pdb.rst:326
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"(``>``) indicates the current frame, which determines the context of most "
"commands."
msgstr ""

#: ../../library/pdb.rst:331
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"Перемістіть поточний кадр *кількість* (за замовчуванням) на рівні трасування"
" стека (до нового кадру)."

#: ../../library/pdb.rst:336
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"Перемістити поточний кадр *кількість* (за замовчуванням) вгору в трасуванні "
"стека (до старішого кадру)."

#: ../../library/pdb.rst:341
msgid ""
"With a *lineno* argument, set a break at line *lineno* in the current file. "
"The line number may be prefixed with a *filename* and a colon, to specify a "
"breakpoint in another file (possibly one that hasn't been loaded yet).  The "
"file is searched on :data:`sys.path`.  Accepatable forms of *filename* are "
"``/abspath/to/file.py``, ``relpath/file.py``, ``module`` and "
"``package.module``."
msgstr ""

#: ../../library/pdb.rst:348
msgid ""
"With a *function* argument, set a break at the first executable statement "
"within that function. *function* can be any expression that evaluates to a "
"function in the current namespace."
msgstr ""

#: ../../library/pdb.rst:352
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr ""
"Якщо присутній другий аргумент, це вираз, який повинен отримати значення "
"true перед тим, як буде враховано точку зупину."

#: ../../library/pdb.rst:355
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number"
" of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"Без аргументів, перерахуйте всі розриви, включно з кожною точкою зупину, "
"кількість разів, коли ця точка зупину було досягнуто, поточну кількість "
"ігнорування та пов’язану умову, якщо така є."

#: ../../library/pdb.rst:359
msgid ""
"Each breakpoint is assigned a number to which all the other breakpoint "
"commands refer."
msgstr ""

#: ../../library/pdb.rst:364
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"Тимчасова контрольна точка, яка видаляється автоматично при першому "
"попаданні. Аргументи такі ж, як і для :pdbcmd:`break`."

#: ../../library/pdb.rst:369
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"За допомогою аргументу *filename:lineno* очистіть усі точки зупину в цьому "
"рядку. За допомогою списку номерів точок зупину, розділених пробілами, "
"очистіть ці точки зупину. Без суперечок очистіть усі розриви (але спочатку "
"запитайте підтвердження)."

#: ../../library/pdb.rst:375
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"Вимкніть точки зупину, надані як список номерів точок зупину, розділених "
"пробілами. Вимкнення точки зупину означає, що це не може призвести до "
"зупинки виконання програми, але на відміну від очищення точки зупину, вона "
"залишається в списку точок зупину та може бути (знову) увімкнена."

#: ../../library/pdb.rst:382
msgid "Enable the breakpoints specified."
msgstr "Увімкніть вказані точки зупину."

#: ../../library/pdb.rst:386
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the"
" ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""

#: ../../library/pdb.rst:394
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"Встановіть нову *умову* для точки зупину, вираз, який повинен мати значення "
"true, перш ніж точка зупину буде виконана. Якщо *умова* відсутня, усі наявні"
" умови видаляються; тобто точка зупину стає безумовною."

#: ../../library/pdb.rst:400
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"Укажіть список команд для точки зупину з номером *bpnumber*. Самі команди "
"відображаються в наступних рядках. Введіть рядок, що містить лише ``end``, "
"щоб завершити команди. Приклад::"

#: ../../library/pdb.rst:404
msgid ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"
msgstr ""

#: ../../library/pdb.rst:409
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"Щоб видалити всі команди з точки зупину, введіть ``commands`` і негайно "
"введіть ``end``; тобто не давати команд."

#: ../../library/pdb.rst:412
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr ""
"Без аргументу *bpnumber* ``commands`` посилається на останній набір точок "
"зупину."

#: ../../library/pdb.rst:414
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that"
" resumes execution."
msgstr ""
"Ви можете використовувати команди точки зупинки, щоб знову запустити "
"програму. Просто скористайтеся командою :pdbcmd:`continue` або "
":pdbcmd:`step` або будь-якою іншою командою, яка відновлює виконання."

#: ../../library/pdb.rst:418
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, "
":pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, "
":pdbcmd:`quit` and their abbreviations) terminates the command list (as if "
"that command was immediately followed by end). This is because any time you "
"resume execution (even with a simple next or step), you may encounter "
"another breakpoint—which could have its own command list, leading to "
"ambiguities about which list to execute."
msgstr ""
"Вказівка будь-якої команди, яка продовжує виконання (наразі "
":pdbcmd:`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, "
":pdbcmd:`jump`, :pdbcmd:`quit` та їхні абревіатури) завершує список команд "
"(так, ніби за цією командою відразу йде end). Це пояснюється тим, що кожного"
" разу, коли ви відновлюєте виконання (навіть із простим наступним або "
"кроком), ви можете зустріти іншу точку зупину, яка може мати власний список "
"команд, що призводить до неоднозначності щодо того, який список виконати."

#: ../../library/pdb.rst:427
msgid ""
"If you use the ``silent`` command in the command list, the usual message "
"about stopping at a breakpoint is not printed.  This may be desirable for "
"breakpoints that are to print a specific message and then continue.  If none"
" of the other commands print anything, you see no sign that the breakpoint "
"was reached."
msgstr ""

#: ../../library/pdb.rst:434
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"Виконати поточний рядок, зупинитися при першому можливому випадку (або у "
"функції, яка викликається, або на наступному рядку в поточній функції)."

#: ../../library/pdb.rst:439
msgid ""
"Continue execution until the next line in the current function is reached or"
" it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"Продовжуйте виконання, доки не буде досягнуто наступного рядка в поточній "
"функції або вона не повернеться. (Різниця між :pdbcmd:`next` і "
":pdbcmd:`step` полягає в тому, що :pdbcmd:`step` зупиняється всередині "
"викликаної функції, тоді як :pdbcmd:`next` виконує викликані функції на "
"(майже) повній швидкості, лише зупиняючись у наступному рядку поточної "
"функції.)"

#: ../../library/pdb.rst:447
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr ""
"Без аргументів продовжувати виконання, доки не буде досягнуто рядок з "
"номером, більшим за поточний."

#: ../../library/pdb.rst:450
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""

#: ../../library/pdb.rst:454
msgid "Allow giving an explicit line number."
msgstr "Дозволяє вказувати явний номер рядка."

#: ../../library/pdb.rst:459
msgid "Continue execution until the current function returns."
msgstr "Продовжуйте виконання, доки поточна функція не повернеться."

#: ../../library/pdb.rst:463
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr ""
"Продовжувати виконання, зупинятися лише тоді, коли зустрічається точка "
"зупину."

#: ../../library/pdb.rst:467
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"Встановіть наступний рядок, який буде виконано. Доступно лише в нижній "
"рамці. Це дає змогу повернутися назад і виконати код знову або перейти "
"вперед, щоб пропустити код, який ви не хочете запускати."

#: ../../library/pdb.rst:471
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a "
":keyword:`finally` clause."
msgstr ""
"Слід зазначити, що не всі переходи дозволені - наприклад, неможливо перейти "
"в середину циклу :keyword:`for` або з пункту :keyword:`finally`."

#: ../../library/pdb.rst:477
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11"
" lines around at that line.  With two arguments, list the given range; if "
"the second argument is less than the first, it is interpreted as a count."
msgstr ""
"Список вихідного коду для поточного файлу. Без аргументів перелічити 11 "
"рядків навколо поточного рядка або продовжити попередній список. З "
"аргументом ``.`` перелічити 11 рядків навколо поточного рядка. З одним "
"аргументом перелічіть 11 рядків навколо цього рядка. З двома аргументами "
"перелічіть заданий діапазон; якщо другий аргумент менший за перший, він "
"інтерпретується як підрахунок."

#: ../../library/pdb.rst:483
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"Поточний рядок у поточному кадрі позначається ``->``. Якщо виняток "
"налагоджується, рядок, де виняток було спочатку викликано або поширено, "
"позначається ``>>``, якщо він відрізняється від поточного рядка."

#: ../../library/pdb.rst:488
msgid "Added the ``>>`` marker."
msgstr ""

#: ../../library/pdb.rst:493
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"Перерахувати весь вихідний код для поточної функції або кадру. Цікаві рядки "
"позначені як для :pdbcmd:`list`."

#: ../../library/pdb.rst:500
msgid "Print the arguments of the current function and their current values."
msgstr ""

#: ../../library/pdb.rst:504
msgid "Evaluate *expression* in the current context and print its value."
msgstr ""

#: ../../library/pdb.rst:508
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"``print()`` також можна використовувати, але це не команда відладчика --- "
"вона виконує функцію :func:`print` Python."

#: ../../library/pdb.rst:514
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""

#: ../../library/pdb.rst:519
msgid "Print the type of *expression*."
msgstr ""

#: ../../library/pdb.rst:523
msgid "Try to get source code of *expression* and display it."
msgstr ""

#: ../../library/pdb.rst:529
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr ""

#: ../../library/pdb.rst:532
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr ""

#: ../../library/pdb.rst:536
msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr ""

#: ../../library/pdb.rst:540 ../../library/pdb.rst:690
msgid "Example::"
msgstr "Приклад::"

#: ../../library/pdb.rst:542
msgid ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"
msgstr ""

#: ../../library/pdb.rst:548
msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr ""

#: ../../library/pdb.rst:551
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"
msgstr ""

#: ../../library/pdb.rst:563
msgid "You can do some tricks with copy mechanism to make it work::"
msgstr ""

#: ../../library/pdb.rst:565
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"
msgstr ""

#: ../../library/pdb.rst:582
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr ""

#: ../../library/pdb.rst:589
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) in a new "
"global namespace initialised from the local and global namespaces for the "
"current scope. Use ``exit()`` or ``quit()`` to exit the interpreter and "
"return to the debugger."
msgstr ""

#: ../../library/pdb.rst:596
msgid ""
"As ``interact`` creates a new dedicated namespace for code execution, "
"assignments to variables will not affect the original namespaces. However, "
"modifications to any referenced mutable objects will be reflected in the "
"original namespaces as usual."
msgstr ""

#: ../../library/pdb.rst:603
msgid ""
"``exit()`` and ``quit()`` can be used to exit the :pdbcmd:`interact` "
"command."
msgstr ""

#: ../../library/pdb.rst:607
msgid ""
":pdbcmd:`interact` directs its output to the debugger's output channel "
"rather than :data:`sys.stderr`."
msgstr ""

#: ../../library/pdb.rst:615
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, ... and ``%9``, while ``%*`` is replaced by all the "
"parameters. If *command* is omitted, the current alias for *name* is shown. "
"If no arguments are given, all aliases are listed."
msgstr ""

#: ../../library/pdb.rst:621
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"Псевдоніми можуть бути вкладеними та можуть містити будь-що, що можна "
"легально ввести в підказці pdb. Зауважте, що внутрішні команди pdb *можна* "
"замінити псевдонімами. Потім така команда приховується, доки псевдонім не "
"буде видалено. Псевдоніми рекурсивно застосовуються до першого слова "
"командного рядка; всі інші слова в рядку залишаються окремо."

#: ../../library/pdb.rst:627
msgid ""
"As an example, here are two useful aliases (especially when placed in the "
":file:`.pdbrc` file)::"
msgstr ""
"Як приклад, ось два корисні псевдоніми (особливо якщо їх розміщено у файлі "
":file:`.pdbrc`):"

#: ../../library/pdb.rst:630
msgid ""
"# Print instance variables (usage \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Print instance variables in self\n"
"alias ps pi self"
msgstr ""

#: ../../library/pdb.rst:637
msgid "Delete the specified alias *name*."
msgstr ""

#: ../../library/pdb.rst:641
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command, e.g.:"
msgstr ""

#: ../../library/pdb.rst:645
msgid ""
"(Pdb) ! n=42\n"
"(Pdb)"
msgstr ""

#: ../../library/pdb.rst:650
msgid ""
"To set a global variable, you can prefix the assignment command with a "
":keyword:`global` statement on the same line, e.g.:"
msgstr ""

#: ../../library/pdb.rst:653
msgid ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"
msgstr ""

#: ../../library/pdb.rst:661
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. "
":pdbcmd:`restart` is an alias for :pdbcmd:`run`."
msgstr ""

#: ../../library/pdb.rst:668
msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "Вийти з налагоджувача. Програма, що виконується, переривається."

#: ../../library/pdb.rst:672
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr ""

#: ../../library/pdb.rst:678
msgid "Print the return value for the last return of the current function."
msgstr ""

#: ../../library/pdb.rst:682
msgid "List or jump between chained exceptions."
msgstr ""

#: ../../library/pdb.rst:684
msgid ""
"When using ``pdb.pm()``  or ``Pdb.post_mortem(...)`` with a chained "
"exception instead of a traceback, it allows the user to move between the "
"chained exceptions using ``exceptions`` command to list exceptions, and "
"``exception <number>`` to switch to that exception."
msgstr ""

#: ../../library/pdb.rst:692
msgid ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"
msgstr ""

#: ../../library/pdb.rst:709
msgid "calling ``pdb.pm()`` will allow to move between exceptions::"
msgstr ""

#: ../../library/pdb.rst:711
msgid ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"
msgstr ""

#: ../../library/pdb.rst:730
msgid "Footnotes"
msgstr "Виноски"

#: ../../library/pdb.rst:731
msgid ""
"Whether a frame is considered to originate in a certain module is determined"
" by the ``__name__`` in the frame globals."
msgstr ""
"Чи вважається, що фрейм походить із певного модуля, визначається "
"``__name__`` у глобальних параметрах фрейму."

#: ../../library/pdb.rst:11
msgid "debugging"
msgstr ""

#: ../../library/pdb.rst:21
msgid "Pdb (class in pdb)"
msgstr ""

#: ../../library/pdb.rst:21
msgid "module"
msgstr "модуль"

#: ../../library/pdb.rst:21
msgid "bdb"
msgstr "bdb"

#: ../../library/pdb.rst:21
msgid "cmd"
msgstr ""

#: ../../library/pdb.rst:295
msgid ".pdbrc"
msgstr ""

#: ../../library/pdb.rst:295
msgid "file"
msgstr ""

#: ../../library/pdb.rst:295
msgid "debugger"
msgstr ""

#: ../../library/pdb.rst:295
msgid "configuration"
msgstr ""
