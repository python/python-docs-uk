# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Налагоджувач Python"

msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**Вихідний код:** :source:`Lib/pdb.py`"

msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
"Модуль :mod:`pdb` визначає інтерактивний налагоджувач вихідного коду для "
"програм Python. Він підтримує встановлення (умовних) точок зупину та один "
"крок на рівні вихідного рядка, перевірку фреймів стеку, перелік вихідного "
"коду та оцінку довільного коду Python у контексті будь-якого фрейму стеку. "
"Він також підтримує посмертне налагодження та може бути викликаний під "
"керуванням програми."

msgid ""
"The debugger is extensible -- it is actually defined as the class :class:"
"`Pdb`. This is currently undocumented but easily understood by reading the "
"source.  The extension interface uses the modules :mod:`bdb` and :mod:`cmd`."
msgstr ""
"Налагоджувач є розширюваним - він фактично визначений як клас :class:`Pdb`. "
"Наразі це незадокументовано, але легко зрозуміти, прочитавши джерело. "
"Інтерфейс розширення використовує модулі :mod:`bdb` і :mod:`cmd`."

msgid ""
"The debugger's prompt is ``(Pdb)``. Typical usage to run a program under "
"control of the debugger is::"
msgstr ""
"Підказка налагоджувача: ``(Pdb)``. Типове використання для запуску програми "
"під керуванням відладчика:"

msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"Завершення табуляції через модуль :mod:`readline` доступне для команд і "
"аргументів команд, напр. поточні глобальні та локальні імена пропонуються як "
"аргументи команди ``p``."

msgid ""
":file:`pdb.py` can also be invoked as a script to debug other scripts.  For "
"example::"
msgstr ""
":file:`pdb.py` також можна викликати як сценарій для налагодження інших "
"сценаріїв. Наприклад::"

msgid ""
"When invoked as a script, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""
"Під час виклику як сценарію pdb автоматично ввійде до посмертного "
"налагодження, якщо програма, яка налагоджується, закривається ненормально. "
"Після посмертного налагодження (або після звичайного виходу з програми) pdb "
"перезапустить програму. Автоматичний перезапуск зберігає стан pdb "
"(наприклад, точки зупину) і в більшості випадків є більш корисним, ніж вихід "
"з налагоджувача після виходу з програми."

msgid ""
":file:`pdb.py` now accepts a ``-c`` option that executes commands as if "
"given in a :file:`.pdbrc` file, see :ref:`debugger-commands`."
msgstr ""
":file:`pdb.py` тепер приймає опцію ``-c``, яка виконує команди так, ніби "
"вони подані у файлі :file:`.pdbrc`, див. :ref:`debugger-commands`."

msgid ""
":file:`pdb.py` now accepts a ``-m`` option that execute modules similar to "
"the way ``python3 -m`` does. As with a script, the debugger will pause "
"execution just before the first line of the module."
msgstr ""
":file:`pdb.py` тепер приймає параметр ``-m``, який виконує модулі подібно до "
"того, як це робить ``python3 -m``. Як і у випадку зі сценарієм, налагоджувач "
"призупинить виконання безпосередньо перед першим рядком модуля."

msgid "The typical usage to break into the debugger is to insert::"
msgstr "Типовим використанням для проникнення в налагоджувач є вставка::"

msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"у місці, куди потрібно зламати налагоджувач, а потім запустіть програму. "
"Потім ви можете покроково виконувати код, який слідує за цією інструкцією, і "
"продовжити роботу без відладчика за допомогою команди :pdbcmd:`continue`."

msgid ""
"The built-in :func:`breakpoint()`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"Вбудований :func:`breakpoint()`, коли викликається із значеннями за "
"замовчуванням, можна використовувати замість ``import pdb; pdb.set_trace()``."

msgid "The typical usage to inspect a crashed program is::"
msgstr "Типове використання для перевірки збійної програми:"

msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr ""
"Модуль визначає такі функції; кожен входить до відладчика дещо іншим "
"способом:"

msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-in :func:"
"`exec` or :func:`eval` functions.)"
msgstr ""
"Виконайте *інструкцію* (у вигляді рядка або об’єкта коду) під керуванням "
"налагоджувача. Підказка налагоджувача з'являється перед виконанням будь-"
"якого коду; ви можете встановити точки зупинки та ввести :pdbcmd:`continue` "
"або ви можете покроково виконувати оператор за допомогою :pdbcmd:`step` або :"
"pdbcmd:`next` (усі ці команди пояснюються нижче). Необов'язкові аргументи "
"*globals* і *locals* визначають середовище, в якому виконується код; за "
"замовчуванням використовується словник модуля :mod:`__main__`. (Див. "
"пояснення вбудованих функцій :func:`exec` або :func:`eval`.)"

msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"expression.  Otherwise this function is similar to :func:`run`."
msgstr ""
"Оцініть *вираз* (у вигляді рядка або об’єкта коду) під керуванням "
"налагоджувача. Коли :func:`runeval` повертає значення виразу. В іншому ця "
"функція схожа на :func:`run`."

msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"Викличте *функцію* (об’єкт функції чи методу, а не рядок) із заданими "
"аргументами. Коли :func:`runcall` повертає, він повертає те, що повернув "
"виклик функції. Підказка налагоджувача з’являється, щойно вводиться функція."

msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins."
msgstr ""
"Введіть налагоджувач у кадрі стека викликів. Це корисно для жорсткого "
"кодування точки зупину в певній точці програми, навіть якщо код іншим чином "
"не налагоджується (наприклад, коли твердження не виконується). Якщо задано, "
"*заголовок* друкується на консолі безпосередньо перед початком налагодження."

msgid "The keyword-only argument *header*."
msgstr "Лише ключовий аргумент *header*."

msgid ""
"Enter post-mortem debugging of the given *traceback* object.  If no "
"*traceback* is given, it uses the one of the exception that is currently "
"being handled (an exception must be being handled if the default is to be "
"used)."
msgstr ""
"Введіть посмертне налагодження даного об’єкта *traceback*. Якщо *traceback* "
"не надано, використовується виняткова ситуація, яка зараз обробляється "
"(виняток має оброблятися, якщо має використовуватись типове значення)."

msgid ""
"Enter post-mortem debugging of the traceback found in :data:`sys."
"last_traceback`."
msgstr ""
"Введіть посмертне налагодження зворотного відстеження, знайденого в :data:"
"`sys.last_traceback`."

msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"Функції ``run*`` і :func:`set_trace` є псевдонімами для створення екземпляра "
"класу :class:`Pdb` і виклику однойменного методу. Якщо ви хочете отримати "
"доступ до інших функцій, ви повинні зробити це самостійно:"

msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` — це клас налагоджувача."

msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"Аргументи *completekey*, *stdin* і *stdout* передаються базовому класу :"
"class:`cmd.Cmd`; дивіться опис там."

msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr ""
"Аргумент *skip*, якщо він наданий, має бути повторюваним шаблоном імен "
"модулів у стилі glob. Налагоджувач не ввійде в кадри, які походять із "
"модуля, який відповідає одному з цих шаблонів. [1]_"

msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give a ``continue`` "
"command. This allows you to break into the debugger again by pressing :kbd:"
"`Ctrl-C`.  If you want Pdb not to touch the SIGINT handler, set *nosigint* "
"to true."
msgstr ""
"За замовчуванням Pdb встановлює обробник для сигналу SIGINT (який "
"надсилається, коли користувач натискає :kbd:`Ctrl-C` на консолі), коли ви "
"даєте команду ``продовжити``. Це дозволить вам знову увійти в налагоджувач, "
"натиснувши :kbd:`Ctrl-C`. Якщо ви хочете, щоб Pdb не торкався обробника "
"SIGINT, установіть для *nosigint* значення true."

msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load ."
"pdbrc files from the filesystem."
msgstr ""
"Аргумент *readrc* за замовчуванням має значення true та визначає, чи буде "
"Pdb завантажувати файли .pdbrc із файлової системи."

msgid "Example call to enable tracing with *skip*::"
msgstr "Приклад виклику для ввімкнення трасування за допомогою *skip*::"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr "Викликає :ref:`подію аудиту <auditing>` ``pdb.Pdb`` без аргументів."

msgid "The *skip* argument."
msgstr "Аргумент *пропустити*."

msgid ""
"The *nosigint* argument.  Previously, a SIGINT handler was never set by Pdb."
msgstr ""
"Аргумент *nosigint*. Раніше обробник SIGINT ніколи не встановлювався Pdb."

msgid "The *readrc* argument."
msgstr "Аргумент *readrc*."

msgid "See the documentation for the functions explained above."
msgstr "Дивіться документацію щодо функцій, описаних вище."

msgid "Debugger Commands"
msgstr "Команди налагоджувача"

msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"Нижче наведено команди, які розпізнає налагоджувач. Більшість команд можна "
"скоротити до однієї або двох букв, як зазначено; напр. ``h(elp)`` означає, "
"що ``h`` або ``help`` можна використовувати для введення команди довідки "
"(але не ``he`` або ``hel``, ані ``H`` або ``Довідка`` або ``ДОПОМОГА``). "
"Аргументи команд повинні бути розділені пробілами (пробілами або "
"табуляцією). Необов’язкові аргументи в синтаксисі команди беруться у "
"квадратні дужки (``[]``); квадратні дужки не можна вводити. Альтернативи в "
"синтаксисі команди розділені вертикальною рискою (``|``)."

msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"Введення порожнього рядка повторює останню введену команду. Виняток: якщо "
"останньою командою була команда :pdbcmd:`list`, буде показано наступні 11 "
"рядків."

msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"Команди, які не розпізнає налагоджувач, вважаються операторами Python і "
"виконуються в контексті програми, що налагоджується. Інструкції Python також "
"можуть мати префікс знаком оклику (``!``). Це потужний спосіб перевірити "
"програму, яка налагоджується; можна навіть змінити змінну або викликати "
"функцію. Коли в такому операторі виникає виняток, ім’я виключення "
"друкується, але стан налагоджувача не змінюється."

msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"Налагоджувач підтримує :ref:`псевдоніми <debugger-aliases>`. Псевдоніми "
"можуть мати параметри, які дозволяють певний рівень адаптації до "
"досліджуваного контексту."

msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"Кілька команд можна ввести в одному рядку, розділених символом ``;;``. (Один "
"символ ``;`` не використовується, оскільки він є роздільником для кількох "
"команд у рядку, який передається синтаксичному аналізатору Python.) Для "
"розділення команд не застосовано жодного розуму; вхідні дані розбиваються на "
"першу пару ``;;``, навіть якщо вона знаходиться в середині рядка в лапках. "
"Обхідним шляхом для рядків із подвійною крапкою з комою є використання "
"неявної конкатенації рядків ``';'';''`` або ``\";\"\";\"``."

msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read in and executed as if it had been typed at the "
"debugger prompt.  This is particularly useful for aliases.  If both files "
"exist, the one in the home directory is read first and aliases defined there "
"can be overridden by the local file."
msgstr ""

msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as :"
"pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` тепер може містити команди, які продовжують налагодження, "
"наприклад :pdbcmd:`continue` або :pdbcmd:`next`. Раніше ці команди не діяли."

msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"Без аргументів вивести список доступних команд. З *командою* як аргументом "
"надрукуйте довідку про цю команду. ``help pdb`` відображає повну "
"документацію (рядок документації модуля :mod:`pdb`). Оскільки аргумент "
"*command* має бути ідентифікатором, необхідно ввести ``help exec``, щоб "
"отримати довідку щодо команди ``!``."

msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"indicates the current frame, which determines the context of most commands."
msgstr ""
"Надрукуйте трасування стека з останнім кадром унизу. Стрілка вказує на "
"поточний кадр, який визначає контекст більшості команд."

msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"Перемістіть поточний кадр *кількість* (за замовчуванням) на рівні трасування "
"стека (до нового кадру)."

msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"Перемістити поточний кадр *кількість* (за замовчуванням) вгору в трасуванні "
"стека (до старішого кадру)."

msgid ""
"With a *lineno* argument, set a break there in the current file.  With a "
"*function* argument, set a break at the first executable statement within "
"that function.  The line number may be prefixed with a filename and a colon, "
"to specify a breakpoint in another file (probably one that hasn't been "
"loaded yet).  The file is searched on :data:`sys.path`.  Note that each "
"breakpoint is assigned a number to which all the other breakpoint commands "
"refer."
msgstr ""
"За допомогою аргументу *lineno* встановіть розрив у поточному файлі. За "
"допомогою аргументу *function* установіть перерву в першому виконуваному "
"операторі в цій функції. Номер рядка може мати префікс назви файлу та "
"двокрапки, щоб вказати точку зупину в іншому файлі (ймовірно, ще не "
"завантаженому). Файл шукається за :data:`sys.path`. Зауважте, що кожній "
"точці зупину присвоєно номер, на який посилаються всі інші команди точки "
"зупину."

msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr ""
"Якщо присутній другий аргумент, це вираз, який повинен отримати значення "
"true перед тим, як буде враховано точку зупину."

msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"Без аргументів, перерахуйте всі розриви, включно з кожною точкою зупину, "
"кількість разів, коли ця точка зупину було досягнуто, поточну кількість "
"ігнорування та пов’язану умову, якщо така є."

msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"Тимчасова контрольна точка, яка видаляється автоматично при першому "
"попаданні. Аргументи такі ж, як і для :pdbcmd:`break`."

msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"За допомогою аргументу *filename:lineno* очистіть усі точки зупину в цьому "
"рядку. За допомогою списку номерів точок зупину, розділених пробілами, "
"очистіть ці точки зупину. Без суперечок очистіть усі розриви (але спочатку "
"запитайте підтвердження)."

msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"Вимкніть точки зупину, надані як список номерів точок зупину, розділених "
"пробілами. Вимкнення точки зупину означає, що це не може призвести до "
"зупинки виконання програми, але на відміну від очищення точки зупину, вона "
"залишається в списку точок зупину та може бути (знову) увімкнена."

msgid "Enable the breakpoints specified."
msgstr "Увімкніть вказані точки зупину."

msgid ""
"Set the ignore count for the given breakpoint number.  If count is omitted, "
"the ignore count is set to 0.  A breakpoint becomes active when the ignore "
"count is zero.  When non-zero, the count is decremented each time the "
"breakpoint is reached and the breakpoint is not disabled and any associated "
"condition evaluates to true."
msgstr ""
"Встановіть кількість ігнорувань для заданого номера контрольної точки. Якщо "
"лічильник опущено, для лічильника ігнорування встановлюється значення 0. "
"Точка зупину стає активною, коли лічильник ігнорування дорівнює нулю. Якщо "
"значення відмінне від нуля, кількість зменшується щоразу, коли досягається "
"точка зупину, і точка зупину не вимикається, а будь-яка пов’язана умова "
"оцінюється як істинна."

msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"Встановіть нову *умову* для точки зупину, вираз, який повинен мати значення "
"true, перш ніж точка зупину буде виконана. Якщо *умова* відсутня, усі наявні "
"умови видаляються; тобто точка зупину стає безумовною."

msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"Укажіть список команд для точки зупину з номером *bpnumber*. Самі команди "
"відображаються в наступних рядках. Введіть рядок, що містить лише ``end``, "
"щоб завершити команди. Приклад::"

msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"Щоб видалити всі команди з точки зупину, введіть ``commands`` і негайно "
"введіть ``end``; тобто не давати команд."

msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr ""
"Без аргументу *bpnumber* ``commands`` посилається на останній набір точок "
"зупину."

msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"Ви можете використовувати команди точки зупинки, щоб знову запустити "
"програму. Просто скористайтеся командою :pdbcmd:`continue` або :pdbcmd:"
"`step` або будь-якою іншою командою, яка відновлює виконання."

msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, :"
"pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, :pdbcmd:"
"`quit` and their abbreviations) terminates the command list (as if that "
"command was immediately followed by end). This is because any time you "
"resume execution (even with a simple next or step), you may encounter "
"another breakpoint—which could have its own command list, leading to "
"ambiguities about which list to execute."
msgstr ""
"Вказівка будь-якої команди, яка продовжує виконання (наразі :pdbcmd:"
"`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:"
"`jump`, :pdbcmd:`quit` та їхні абревіатури) завершує список команд (так, "
"ніби за цією командою відразу йде end). Це пояснюється тим, що кожного разу, "
"коли ви відновлюєте виконання (навіть із простим наступним або кроком), ви "
"можете зустріти іншу точку зупину, яка може мати власний список команд, що "
"призводить до неоднозначності щодо того, який список виконати."

msgid ""
"If you use the 'silent' command in the command list, the usual message about "
"stopping at a breakpoint is not printed.  This may be desirable for "
"breakpoints that are to print a specific message and then continue.  If none "
"of the other commands print anything, you see no sign that the breakpoint "
"was reached."
msgstr ""
"Якщо ви використовуєте команду \"silent\" у списку команд, звичайне "
"повідомлення про зупинку на точці зупинки не друкується. Це може бути "
"бажаним для точок зупину, які повинні надрукувати певне повідомлення, а "
"потім продовжити. Якщо жодна з інших команд нічого не друкує, ви не побачите "
"ознак того, що точка зупину досягнута."

msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"Виконати поточний рядок, зупинитися при першому можливому випадку (або у "
"функції, яка викликається, або на наступному рядку в поточній функції)."

msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"Продовжуйте виконання, доки не буде досягнуто наступного рядка в поточній "
"функції або вона не повернеться. (Різниця між :pdbcmd:`next` і :pdbcmd:"
"`step` полягає в тому, що :pdbcmd:`step` зупиняється всередині викликаної "
"функції, тоді як :pdbcmd:`next` виконує викликані функції на (майже) повній "
"швидкості, лише зупиняючись у наступному рядку поточної функції.)"

msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr ""
"Без аргументів продовжувати виконання, доки не буде досягнуто рядок з "
"номером, більшим за поточний."

msgid ""
"With a line number, continue execution until a line with a number greater or "
"equal to that is reached.  In both cases, also stop when the current frame "
"returns."
msgstr ""
"З номером рядка продовжуйте виконання, доки не буде досягнуто рядок з "
"номером, більшим або рівним цьому. В обох випадках також зупиніться, коли "
"повернеться поточний кадр."

msgid "Allow giving an explicit line number."
msgstr "Дозволяє вказувати явний номер рядка."

msgid "Continue execution until the current function returns."
msgstr "Продовжуйте виконання, доки поточна функція не повернеться."

msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr ""
"Продовжувати виконання, зупинятися лише тоді, коли зустрічається точка "
"зупину."

msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"Встановіть наступний рядок, який буде виконано. Доступно лише в нижній "
"рамці. Це дає змогу повернутися назад і виконати код знову або перейти "
"вперед, щоб пропустити код, який ви не хочете запускати."

msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a :"
"keyword:`finally` clause."
msgstr ""
"Слід зазначити, що не всі переходи дозволені - наприклад, неможливо перейти "
"в середину циклу :keyword:`for` або з пункту :keyword:`finally`."

msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"Список вихідного коду для поточного файлу. Без аргументів перелічити 11 "
"рядків навколо поточного рядка або продовжити попередній список. З "
"аргументом ``.`` перелічити 11 рядків навколо поточного рядка. З одним "
"аргументом перелічіть 11 рядків навколо цього рядка. З двома аргументами "
"перелічіть заданий діапазон; якщо другий аргумент менший за перший, він "
"інтерпретується як підрахунок."

msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"Поточний рядок у поточному кадрі позначається ``->``. Якщо виняток "
"налагоджується, рядок, де виняток було спочатку викликано або поширено, "
"позначається ``>>``, якщо він відрізняється від поточного рядка."

msgid "The ``>>`` marker."
msgstr "Маркер ``>>``."

msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"Перерахувати весь вихідний код для поточної функції або кадру. Цікаві рядки "
"позначені як для :pdbcmd:`list`."

msgid "Print the argument list of the current function."
msgstr "Вивести список аргументів поточної функції."

msgid "Evaluate the *expression* in the current context and print its value."
msgstr "Оцініть *вираз* у поточному контексті та надрукуйте його значення."

msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"``print()`` також можна використовувати, але це не команда відладчика --- "
"вона виконує функцію :func:`print` Python."

msgid ""
"Like the :pdbcmd:`p` command, except the value of the expression is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""
"Подібно до команди :pdbcmd:`p`, за винятком того, що значення виразу "
"надруковано за допомогою модуля :mod:`pprint`."

msgid "Print the type of the *expression*."
msgstr "Виведіть тип *виразу*."

msgid "Try to get source code for the given object and display it."
msgstr "Спробуйте отримати вихідний код даного об'єкта та відобразити його."

msgid ""
"Display the value of the expression if it changed, each time execution stops "
"in the current frame."
msgstr ""
"Відображати значення виразу, якщо воно змінилося, кожного разу, коли "
"виконання зупиняється в поточному кадрі."

msgid "Without expression, list all display expressions for the current frame."
msgstr "Без виразу, список усіх виразів відображення для поточного кадру."

msgid ""
"Do not display the expression any more in the current frame.  Without "
"expression, clear all display expressions for the current frame."
msgstr ""
"Більше не відображати вираз у поточному кадрі. Без виразу, очистити всі "
"вирази відображення для поточного кадру."

msgid ""
"Start an interactive interpreter (using the :mod:`code` module) whose global "
"namespace contains all the (global and local) names found in the current "
"scope."
msgstr ""
"Запустіть інтерактивний інтерпретатор (за допомогою модуля :mod:`code`), "
"глобальний простір імен якого містить усі (глобальні та локальні) імена, "
"знайдені в поточній області."

msgid ""
"Create an alias called *name* that executes *command*.  The command must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, and so on, while ``%*`` is replaced by all the parameters. "
"If no command is given, the current alias for *name* is shown. If no "
"arguments are given, all aliases are listed."
msgstr ""
"Створіть псевдонім під назвою *name*, який виконує *command*. Команда *не* "
"повинна бути взята в лапки. Параметри, які можна замінити, можуть "
"позначатися символами \"%1\", \"%2\" тощо, тоді як \"%*\" замінюється всіма "
"параметрами. Якщо жодної команди не надано, відображається поточний "
"псевдонім для *name*. Якщо аргументи не вказано, перераховуються всі "
"псевдоніми."

msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"Псевдоніми можуть бути вкладеними та можуть містити будь-що, що можна "
"легально ввести в підказці pdb. Зауважте, що внутрішні команди pdb *можна* "
"замінити псевдонімами. Потім така команда приховується, доки псевдонім не "
"буде видалено. Псевдоніми рекурсивно застосовуються до першого слова "
"командного рядка; всі інші слова в рядку залишаються окремо."

msgid ""
"As an example, here are two useful aliases (especially when placed in the :"
"file:`.pdbrc` file)::"
msgstr ""
"Як приклад, ось два корисні псевдоніми (особливо якщо їх розміщено у файлі :"
"file:`.pdbrc`):"

msgid "Delete the specified alias."
msgstr "Видалити вказаний псевдонім."

msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command.  To set a global variable, you can "
"prefix the assignment command with a :keyword:`global` statement on the same "
"line, e.g.::"
msgstr ""
"Виконайте (однорядковий) *інструкцію* в контексті поточного кадру стека. "
"Знак оклику можна опустити, якщо перше слово оператора не нагадує команду "
"відладчика. Щоб встановити глобальну змінну, ви можете додати до команди "
"призначення оператор :keyword:`global` у тому самому рядку, наприклад::"

msgid ""
"Restart the debugged Python program.  If an argument is supplied, it is "
"split with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. :pdbcmd:"
"`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"Перезапустіть налагоджену програму Python. Якщо вказано аргумент, він "
"розділяється за допомогою :mod:`shlex`, а результат використовується як "
"новий :data:`sys.argv`. Історія, точки зупинки, дії та параметри "
"налагоджувача зберігаються. :pdbcmd:`restart` — це псевдонім для :pdbcmd:"
"`run`."

msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "Вийти з налагоджувача. Програма, що виконується, переривається."

msgid ""
"Enter a recursive debugger that steps through the code argument (which is an "
"arbitrary expression or statement to be executed in the current environment)."
msgstr ""
"Введіть рекурсивний налагоджувач, який покроково виконує аргумент коду (який "
"є довільним виразом або інструкцією, що виконується в поточному середовищі)."

msgid "Print the return value for the last return of a function."
msgstr ""
"Надрукувати значення, що повертається для останнього повернення функції."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr ""
"Чи вважається, що фрейм походить із певного модуля, визначається "
"``__name__`` у глобальних параметрах фрейму."
