# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`os` --- Miscellaneous operating system interfaces"
msgstr ":mod:`os` --- Різні інтерфейси операційної системи"

msgid "**Source code:** :source:`Lib/os.py`"
msgstr "**Вихідний код:** :source:`Lib/os.py`"

msgid ""
"This module provides a portable way of using operating system dependent "
"functionality.  If you just want to read or write a file see :func:`open`, "
"if you want to manipulate paths, see the :mod:`os.path` module, and if you "
"want to read all the lines in all the files on the command line see the :mod:"
"`fileinput` module.  For creating temporary files and directories see the :"
"mod:`tempfile` module, and for high-level file and directory handling see "
"the :mod:`shutil` module."
msgstr ""
"Цей модуль забезпечує портативний спосіб використання залежних від "
"операційної системи функцій. Якщо ви хочете просто прочитати або записати "
"файл, дивіться :func:`open`, якщо ви хочете маніпулювати шляхами, "
"перегляньте модуль :mod:`os.path`, а якщо ви хочете прочитати всі рядки в "
"усіх файлах у командному рядку перегляньте модуль :mod:`fileinput`. Для "
"створення тимчасових файлів і каталогів перегляньте модуль :mod:`tempfile`, "
"а для високорівневої обробки файлів і каталогів дивіться модуль :mod:"
"`shutil`."

msgid "Notes on the availability of these functions:"
msgstr "Примітки щодо доступності цих функцій:"

msgid ""
"The design of all built-in operating system dependent modules of Python is "
"such that as long as the same functionality is available, it uses the same "
"interface; for example, the function ``os.stat(path)`` returns stat "
"information about *path* in the same format (which happens to have "
"originated with the POSIX interface)."
msgstr ""
"Конструкція всіх вбудованих залежних від операційної системи модулів Python "
"така, що, поки доступна та сама функціональність, він використовує той самий "
"інтерфейс; наприклад, функція ``os.stat(path)`` повертає статистичну "
"інформацію про *path* у тому самому форматі (який, як виявилося, походить з "
"інтерфейсу POSIX)."

msgid ""
"Extensions peculiar to a particular operating system are also available "
"through the :mod:`os` module, but using them is of course a threat to "
"portability."
msgstr ""
"Розширення, властиві певній операційній системі, також доступні через "
"модуль :mod:`os`, але їх використання, звичайно, є загрозою для "
"переносимості."

msgid ""
"All functions accepting path or file names accept both bytes and string "
"objects, and result in an object of the same type, if a path or file name is "
"returned."
msgstr ""
"Усі функції, які приймають імена шляхів або файлів, приймають як байти, так "
"і рядкові об’єкти, і в результаті повертають об’єкт того самого типу, якщо "
"повертається шлях або ім’я файлу."

msgid ""
"On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported."
msgstr "У VxWorks os.popen, os.fork, os.execv і os.spawn*p* не підтримуються."

msgid ""
"All functions in this module raise :exc:`OSError` (or subclasses thereof) in "
"the case of invalid or inaccessible file names and paths, or other arguments "
"that have the correct type, but are not accepted by the operating system."
msgstr ""
"Усі функції в цьому модулі викликають :exc:`OSError` (або його підкласи) у "
"разі недійсних або недоступних імен файлів і шляхів або інших аргументів, "
"які мають правильний тип, але не приймаються операційною системою."

msgid "An alias for the built-in :exc:`OSError` exception."
msgstr "Псевдонім для вбудованого винятку :exc:`OSError`."

msgid ""
"The name of the operating system dependent module imported.  The following "
"names have currently been registered: ``'posix'``, ``'nt'``, ``'java'``."
msgstr ""
"Назва імпортованого модуля, залежного від операційної системи. Наразі "
"зареєстровано такі назви: ``'posix'``, ``'nt'``, ``'java'``."

msgid ""
":attr:`sys.platform` has a finer granularity.  :func:`os.uname` gives system-"
"dependent version information."
msgstr ""
":attr:`sys.platform` має дрібнішу деталізацію. :func:`os.uname` надає "
"інформацію про версію, що залежить від системи."

msgid ""
"The :mod:`platform` module provides detailed checks for the system's "
"identity."
msgstr ""
"Модуль :mod:`platform` забезпечує детальну перевірку ідентичності системи."

msgid "File Names, Command Line Arguments, and Environment Variables"
msgstr "Імена файлів, аргументи командного рядка та змінні середовища"

msgid ""
"In Python, file names, command line arguments, and environment variables are "
"represented using the string type. On some systems, decoding these strings "
"to and from bytes is necessary before passing them to the operating system. "
"Python uses the :term:`filesystem encoding and error handler` to perform "
"this conversion (see :func:`sys.getfilesystemencoding`)."
msgstr ""
"У Python імена файлів, аргументи командного рядка та змінні середовища "
"представлені за допомогою рядкового типу. У деяких системах декодування цих "
"рядків у та з байтів є необхідним перед передачею їх в операційну систему. "
"Python використовує :term:`filesystem encoding and error handler` для "
"виконання цього перетворення (див. :func:`sys.getfilesystemencoding`)."

msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` налаштовуються під час запуску "
"Python за допомогою функції :c:func:`PyConfig_Read`: див. :c:member:"
"`~PyConfig.filesystem_encoding` і :c:member:`~PyConfig. filesystem_errors` "
"члени :c:type:`PyConfig`."

msgid ""
"On some systems, conversion using the file system encoding may fail. In this "
"case, Python uses the :ref:`surrogateescape encoding error handler "
"<surrogateescape>`, which means that undecodable bytes are replaced by a "
"Unicode character U+DCxx on decoding, and these are again translated to the "
"original byte on encoding."
msgstr ""
"У деяких системах перетворення за допомогою кодування файлової системи може "
"завершитися помилкою. У цьому випадку Python використовує :ref:`обробник "
"помилок кодування surrogateescape <surrogateescape>`, що означає, що "
"некодовані байти замінюються символом Unicode U+DCxx під час декодування, і "
"вони знову перетворюються на вихідний байт під час кодування."

msgid ""
"The :term:`file system encoding <filesystem encoding and error handler>` "
"must guarantee to successfully decode all bytes below 128. If the file "
"system encoding fails to provide this guarantee, API functions can raise :"
"exc:`UnicodeError`."
msgstr ""
":term:`кодування файлової системи <filesystem encoding and error handler>` "
"має гарантувати успішне декодування всіх байтів нижче 128. Якщо кодування "
"файлової системи не забезпечує цю гарантію, функції API можуть викликати :"
"exc:`UnicodeError`."

msgid "See also the :term:`locale encoding`."
msgstr "Дивіться також :term:`locale encoding`."

msgid "Python UTF-8 Mode"
msgstr "Режим Python UTF-8"

msgid "See :pep:`540` for more details."
msgstr "Дивіться :pep:`540` для більш детальної інформації."

msgid ""
"The Python UTF-8 Mode ignores the :term:`locale encoding` and forces the "
"usage of the UTF-8 encoding:"
msgstr ""
"Режим Python UTF-8 ігнорує кодування :term:`locale encoding` і змушує "
"використовувати кодування UTF-8:"

msgid ""
"Use UTF-8 as the :term:`filesystem encoding <filesystem encoding and error "
"handler>`."
msgstr ""
"Використовуйте UTF-8 як :term:`кодування файлової системи <filesystem "
"encoding and error handler>`."

msgid ":func:`sys.getfilesystemencoding()` returns ``'UTF-8'``."
msgstr ""

msgid ""
":func:`locale.getpreferredencoding()` returns ``'UTF-8'`` (the "
"*do_setlocale* argument has no effect)."
msgstr ""

msgid ""
":data:`sys.stdin`, :data:`sys.stdout`, and :data:`sys.stderr` all use UTF-8 "
"as their text encoding, with the ``surrogateescape`` :ref:`error handler "
"<error-handlers>` being enabled for :data:`sys.stdin` and :data:`sys.stdout` "
"(:data:`sys.stderr` continues to use ``backslashreplace`` as it does in the "
"default locale-aware mode)"
msgstr ""
":data:`sys.stdin`, :data:`sys.stdout` і :data:`sys.stderr` використовують "
"UTF-8 як кодування тексту з ``surrogateescape`` :ref:`обробником помилок "
"<error-handlers>` увімкнено для :data:`sys.stdin` і :data:`sys.stdout` (:"
"data:`sys.stderr` продовжує використовувати ``backslashreplace``, як це "
"робиться в режимі з урахуванням локалі за замовчуванням)"

msgid ""
"On Unix, :func:`os.device_encoding` returns ``'UTF-8'`` rather than the "
"device encoding."
msgstr ""

msgid ""
"Note that the standard stream settings in UTF-8 mode can be overridden by :"
"envvar:`PYTHONIOENCODING` (just as they can be in the default locale-aware "
"mode)."
msgstr ""
"Зауважте, що стандартні параметри потоку в режимі UTF-8 можна замінити :"
"envvar:`PYTHONIOENCODING` (так само, як вони можуть бути в режимі з "
"урахуванням локалі за замовчуванням)."

msgid ""
"As a consequence of the changes in those lower level APIs, other higher "
"level APIs also exhibit different default behaviours:"
msgstr ""
"Як наслідок змін у цих API нижчого рівня, інші API вищого рівня також "
"демонструють іншу поведінку за замовчуванням:"

msgid ""
"Command line arguments, environment variables and filenames are decoded to "
"text using the UTF-8 encoding."
msgstr ""
"Аргументи командного рядка, змінні середовища та імена файлів декодуються в "
"текст за допомогою кодування UTF-8."

msgid ":func:`os.fsdecode()` and :func:`os.fsencode()` use the UTF-8 encoding."
msgstr ""
":func:`os.fsdecode()` і :func:`os.fsencode()` використовують кодування UTF-8."

msgid ""
":func:`open()`, :func:`io.open()`, and :func:`codecs.open()` use the UTF-8 "
"encoding by default. However, they still use the strict error handler by "
"default so that attempting to open a binary file in text mode is likely to "
"raise an exception rather than producing nonsense data."
msgstr ""
":func:`open()`, :func:`io.open()` і :func:`codecs.open()` використовують "
"кодування UTF-8 за умовчанням. Однак вони все ще використовують строгий "
"обробник помилок за замовчуванням, тому спроба відкрити двійковий файл у "
"текстовому режимі швидше за все призведе до виключення, а не до безглуздих "
"даних."

msgid ""
"The :ref:`Python UTF-8 Mode <utf8-mode>` is enabled if the LC_CTYPE locale "
"is ``C`` or ``POSIX`` at Python startup (see the :c:func:`PyConfig_Read` "
"function)."
msgstr ""
":ref:`Режим Python UTF-8 <utf8-mode>` увімкнено, якщо під час запуску Python "
"локаль LC_CTYPE є ``C`` або ``POSIX`` (див. функцію :c:func:`PyConfig_Read`)."

msgid ""
"It can be enabled or disabled using the :option:`-X utf8 <-X>` command line "
"option and the :envvar:`PYTHONUTF8` environment variable."
msgstr ""
"Його можна ввімкнути або вимкнути за допомогою параметра командного рядка :"
"option:`-X utf8 <-X>` і змінної середовища :envvar:`PYTHONUTF8`."

msgid ""
"If the :envvar:`PYTHONUTF8` environment variable is not set at all, then the "
"interpreter defaults to using the current locale settings, *unless* the "
"current locale is identified as a legacy ASCII-based locale (as described "
"for :envvar:`PYTHONCOERCECLOCALE`), and locale coercion is either disabled "
"or fails. In such legacy locales, the interpreter will default to enabling "
"UTF-8 mode unless explicitly instructed not to do so."
msgstr ""
"Якщо змінна середовища :envvar:`PYTHONUTF8` не встановлена взагалі, "
"інтерпретатор за замовчуванням використовує поточні параметри локалі, *якщо* "
"поточна локаль не визначена як застаріла локаль на основі ASCII (як описано "
"для :envvar:`PYTHONCOERCECLOCALE`), а примусове налаштування локалі вимкнено "
"або не працює. У таких застарілих локалях інтерпретатор за замовчуванням "
"увімкне режим UTF-8, якщо немає явних вказівок не робити цього."

msgid ""
"The Python UTF-8 Mode can only be enabled at the Python startup. Its value "
"can be read from :data:`sys.flags.utf8_mode <sys.flags>`."
msgstr ""
"Режим Python UTF-8 можна ввімкнути лише під час запуску Python. Його "
"значення можна прочитати з :data:`sys.flags.utf8_mode <sys.flags>`."

msgid ""
"See also the :ref:`UTF-8 mode on Windows <win-utf8-mode>` and the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Дивіться також режим :ref:`UTF-8 у Windows <win-utf8-mode>` і :term:"
"`filesystem encoding and error handler`."

msgid "Process Parameters"
msgstr "Параметри процесу"

msgid ""
"These functions and data items provide information and operate on the "
"current process and user."
msgstr ""
"Ці функції та елементи даних надають інформацію та діють щодо поточного "
"процесу та користувача."

msgid ""
"Return the filename corresponding to the controlling terminal of the process."
msgstr "Повертає ім'я файлу, що відповідає керуючому терміналу процесу."

msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Наявність <availability>`: Unix."

msgid ""
"A :term:`mapping` object where keys and values are strings that represent "
"the process environment.  For example, ``environ['HOME']`` is the pathname "
"of your home directory (on some platforms), and is equivalent to "
"``getenv(\"HOME\")`` in C."
msgstr ""
"Об’єкт :term:`mapping`, де ключі та значення є рядками, які представляють "
"середовище процесу. Наприклад, ``environ['HOME']`` є шляхом до вашого "
"домашнього каталогу (на деяких платформах) і еквівалентний "
"``getenv(\"HOME\")`` в C."

msgid ""
"This mapping is captured the first time the :mod:`os` module is imported, "
"typically during Python startup as part of processing :file:`site.py`.  "
"Changes to the environment made after this time are not reflected in :data:"
"`os.environ`, except for changes made by modifying :data:`os.environ` "
"directly."
msgstr ""
"Це зіставлення фіксується під час першого імпорту модуля :mod:`os`, зазвичай "
"під час запуску Python як частина обробки :file:`site.py`. Зміни в "
"середовищі, внесені після цього часу, не відображаються в :data:`os."
"environ`, за винятком змін, внесених безпосередньо шляхом модифікації :data:"
"`os.environ`."

msgid ""
"This mapping may be used to modify the environment as well as query the "
"environment.  :func:`putenv` will be called automatically when the mapping "
"is modified."
msgstr ""
"Це відображення можна використовувати для зміни середовища, а також запиту "
"середовища. :func:`putenv` буде викликано автоматично, коли відображення "
"буде змінено."

msgid ""
"On Unix, keys and values use :func:`sys.getfilesystemencoding` and "
"``'surrogateescape'`` error handler. Use :data:`environb` if you would like "
"to use a different encoding."
msgstr ""
"В Unix ключі та значення використовують :func:`sys.getfilesystemencoding` і "
"``'surrogateescape'`` обробник помилок. Використовуйте :data:`environb`, "
"якщо ви хочете використати інше кодування."

msgid ""
"Calling :func:`putenv` directly does not change :data:`os.environ`, so it's "
"better to modify :data:`os.environ`."
msgstr ""
"Безпосередній виклик :func:`putenv` не змінює :data:`os.environ`, тому краще "
"змінити :data:`os.environ`."

msgid ""
"On some platforms, including FreeBSD and macOS, setting ``environ`` may "
"cause memory leaks.  Refer to the system documentation for :c:func:`putenv`."
msgstr ""
"На деяких платформах, включаючи FreeBSD і macOS, налаштування ``environ`` "
"може спричинити витік пам’яті. Зверніться до системної документації для :c:"
"func:`putenv`."

msgid ""
"You can delete items in this mapping to unset environment variables. :func:"
"`unsetenv` will be called automatically when an item is deleted from :data:"
"`os.environ`, and when one of the :meth:`pop` or :meth:`clear` methods is "
"called."
msgstr ""
"Ви можете видалити елементи в цьому відображенні, щоб скасувати налаштування "
"змінних середовища. :func:`unsetenv` буде викликано автоматично, коли "
"елемент буде видалено з :data:`os.environ`, а також під час виклику одного з "
"методів :meth:`pop` або :meth:`clear`."

msgid ""
"Updated to support :pep:`584`'s merge (``|``) and update (``|=``) operators."
msgstr ""
"Оновлено для підтримки операторів злиття (``|``) і оновлення (``|=``) :pep:"
"`584`."

msgid ""
"Bytes version of :data:`environ`: a :term:`mapping` object where both keys "
"and values are :class:`bytes` objects representing the process environment. :"
"data:`environ` and :data:`environb` are synchronized (modifying :data:"
"`environb` updates :data:`environ`, and vice versa)."
msgstr ""
"Байтова версія :data:`environ`: об’єкт :term:`mapping`, де і ключі, і "
"значення є об’єктами :class:`bytes`, що представляють середовище процесу. :"
"data:`environ` і :data:`environb` синхронізуються (модифікація :data:"
"`environb` оновлює :data:`environ`, і навпаки)."

msgid ""
":data:`environb` is only available if :data:`supports_bytes_environ` is "
"``True``."
msgstr ""
":data:`environb` доступний лише якщо :data:`supports_bytes_environ` має "
"значення ``True``."

msgid "These functions are described in :ref:`os-file-dir`."
msgstr "Ці функції описані в :ref:`os-file-dir`."

msgid ""
"Encode :term:`path-like <path-like object>` *filename* to the :term:"
"`filesystem encoding and error handler`; return :class:`bytes` unchanged."
msgstr ""
"Закодуйте :term:`path-like <path-like object>` *ім’я файлу* до :term:"
"`filesystem encoding and error handler`; повертає :class:`bytes` без змін."

msgid ":func:`fsdecode` is the reverse function."
msgstr ":func:`fsdecode` є зворотною функцією."

msgid ""
"Support added to accept objects implementing the :class:`os.PathLike` "
"interface."
msgstr ""
"Додано підтримку прийому об’єктів, що реалізують інтерфейс :class:`os."
"PathLike`."

msgid ""
"Decode the :term:`path-like <path-like object>` *filename* from the :term:"
"`filesystem encoding and error handler`; return :class:`str` unchanged."
msgstr ""
"Декодуйте :term:`path-like <path-like object>` *filename* з :term:"
"`filesystem encoding and error handler`; повертає :class:`str` без змін."

msgid ":func:`fsencode` is the reverse function."
msgstr ":func:`fsencode` є зворотною функцією."

msgid "Return the file system representation of the path."
msgstr "Повертає представлення файлової системи шляху."

msgid ""
"If :class:`str` or :class:`bytes` is passed in, it is returned unchanged. "
"Otherwise :meth:`~os.PathLike.__fspath__` is called and its value is "
"returned as long as it is a :class:`str` or :class:`bytes` object. In all "
"other cases, :exc:`TypeError` is raised."
msgstr ""
"Якщо передано :class:`str` або :class:`bytes`, воно повертається без змін. В "
"іншому випадку викликається :meth:`~os.PathLike.__fspath__` і повертається "
"його значення, якщо це об’єкт :class:`str` або :class:`bytes`. У всіх інших "
"випадках виникає :exc:`TypeError`."

msgid ""
"An :term:`abstract base class` for objects representing a file system path, "
"e.g. :class:`pathlib.PurePath`."
msgstr ""
":term:`abstract base class` для об’єктів, що представляють шлях файлової "
"системи, напр. :class:`pathlib.PurePath`."

msgid "Return the file system path representation of the object."
msgstr "Повертає представлення шляху файлової системи до об’єкта."

msgid ""
"The method should only return a :class:`str` or :class:`bytes` object, with "
"the preference being for :class:`str`."
msgstr ""
"Метод має повертати лише об’єкт :class:`str` або :class:`bytes`, з перевагою "
"для :class:`str`."

msgid ""
"Return the value of the environment variable *key* if it exists, or "
"*default* if it doesn't. *key*, *default* and the result are str. Note that "
"since :func:`getenv` uses :data:`os.environ`, the mapping of :func:`getenv` "
"is similarly also captured on import, and the function may not reflect "
"future environment changes."
msgstr ""
"Повертає значення змінної середовища *key*, якщо вона існує, або *default*, "
"якщо її немає. *key*, *default* і результат – str. Зауважте, що, оскільки :"
"func:`getenv` використовує :data:`os.environ`, відображення :func:`getenv` "
"також фіксується під час імпорту, і функція може не відображати майбутні "
"зміни середовища."

msgid ""
"On Unix, keys and values are decoded with :func:`sys.getfilesystemencoding` "
"and ``'surrogateescape'`` error handler. Use :func:`os.getenvb` if you would "
"like to use a different encoding."
msgstr ""
"В Unix ключі та значення декодуються за допомогою :func:`sys."
"getfilesystemencoding` і ``'surrogateescape'`` обробника помилок. "
"Використовуйте :func:`os.getenvb`, якщо ви хочете використати інше кодування."

msgid ":ref:`Availability <availability>`: most flavors of Unix, Windows."
msgstr ":ref:`Доступність <availability>`: більшість варіантів Unix, Windows."

msgid ""
"Return the value of the environment variable *key* if it exists, or "
"*default* if it doesn't. *key*, *default* and the result are bytes. Note "
"that since :func:`getenvb` uses :data:`os.environb`, the mapping of :func:"
"`getenvb` is similarly also captured on import, and the function may not "
"reflect future environment changes."
msgstr ""
"Повертає значення змінної середовища *key*, якщо вона існує, або *default*, "
"якщо її немає. *ключ*, *за замовчуванням* і результатом є байти. Зауважте, "
"що оскільки :func:`getenvb` використовує :data:`os.environb`, відображення :"
"func:`getenvb` також фіксується під час імпорту, і функція може не "
"відображати майбутні зміни середовища."

msgid ""
":func:`getenvb` is only available if :data:`supports_bytes_environ` is "
"``True``."
msgstr ""
":func:`getenvb` доступний лише якщо :data:`supports_bytes_environ` має "
"значення ``True``."

msgid ":ref:`Availability <availability>`: most flavors of Unix."
msgstr ":ref:`Доступність <availability>`: більшість різновидів Unix."

msgid ""
"Returns the list of directories that will be searched for a named "
"executable, similar to a shell, when launching a process. *env*, when "
"specified, should be an environment variable dictionary to lookup the PATH "
"in. By default, when *env* is ``None``, :data:`environ` is used."
msgstr ""
"Повертає список каталогів, у яких здійснюватиметься пошук іменованого "
"виконуваного файлу, схожого на оболонку, під час запуску процесу. *env*, "
"якщо вказано, має бути словником змінної середовища для пошуку ШЛЯХУ. За "
"умовчанням, коли *env* має значення ``None``, використовується :data:"
"`environ`."

msgid ""
"Return the effective group id of the current process.  This corresponds to "
"the \"set id\" bit on the file being executed in the current process."
msgstr ""
"Повертає ефективний ідентифікатор групи поточного процесу. Це відповідає "
"біту \"set id\" у файлі, який виконується в поточному процесі."

msgid "Return the current process's effective user id."
msgstr "Повернути ефективний ідентифікатор користувача поточного процесу."

msgid "Return the real group id of the current process."
msgstr "Повертає справжній ідентифікатор групи поточного процесу."

msgid ""
"Return list of group ids that *user* belongs to. If *group* is not in the "
"list, it is included; typically, *group* is specified as the group ID field "
"from the password record for *user*."
msgstr ""

msgid ""
"Return list of supplemental group ids associated with the current process."
msgstr ""
"Повернути список ідентифікаторів додаткових груп, пов’язаних із поточним "
"процесом."

msgid ""
"On macOS, :func:`getgroups` behavior differs somewhat from other Unix "
"platforms. If the Python interpreter was built with a deployment target of :"
"const:`10.5` or earlier, :func:`getgroups` returns the list of effective "
"group ids associated with the current user process; this list is limited to "
"a system-defined number of entries, typically 16, and may be modified by "
"calls to :func:`setgroups` if suitably privileged. If built with a "
"deployment target greater than :const:`10.5`, :func:`getgroups` returns the "
"current group access list for the user associated with the effective user id "
"of the process; the group access list may change over the lifetime of the "
"process, it is not affected by calls to :func:`setgroups`, and its length is "
"not limited to 16.  The deployment target value, :const:"
"`MACOSX_DEPLOYMENT_TARGET`, can be obtained with :func:`sysconfig."
"get_config_var`."
msgstr ""
"У macOS поведінка :func:`getgroups` дещо відрізняється від інших платформ "
"Unix. Якщо інтерпретатор Python було створено з метою розгортання :const:"
"`10.5` або раніше, :func:`getgroups` повертає список ефективних "
"ідентифікаторів груп, пов’язаних із поточним процесом користувача; цей "
"список обмежується визначеною системою кількістю записів, як правило, 16, і "
"може бути змінений викликами :func:`setgroups`, якщо відповідні привілеї. "
"Якщо створено з метою розгортання, більшою за :const:`10.5`, :func:"
"`getgroups` повертає поточний список доступу групи для користувача, "
"пов’язаного з ефективним ідентифікатором користувача процесу; список доступу "
"групи може змінюватися протягом життя процесу, на нього не впливають "
"виклики :func:`setgroups`, і його довжина не обмежена 16. Цільове значення "
"розгортання, :const:`MACOSX_DEPLOYMENT_TARGET`, може бути отримано за "
"допомогою :func:`sysconfig.get_config_var`."

msgid ""
"Return the name of the user logged in on the controlling terminal of the "
"process.  For most purposes, it is more useful to use :func:`getpass."
"getuser` since the latter checks the environment variables :envvar:`LOGNAME` "
"or :envvar:`USERNAME` to find out who the user is, and falls back to ``pwd."
"getpwuid(os.getuid())[0]`` to get the login name of the current real user id."
msgstr ""
"Повертає ім’я користувача, який увійшов у систему на керуючому терміналі "
"процесу. Для більшості цілей корисніше використовувати :func:`getpass."
"getuser`, оскільки останній перевіряє змінні середовища :envvar:`LOGNAME` "
"або :envvar:`USERNAME`, щоб дізнатися, хто є користувачем, і повертається до "
"``pwd.getpwuid(os.getuid())[0]``, щоб отримати ім’я для входу поточного "
"реального ідентифікатора користувача."

msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Наявність <availability>`: Unix, Windows."

msgid ""
"Return the process group id of the process with process id *pid*. If *pid* "
"is 0, the process group id of the current process is returned."
msgstr ""
"Повертає ідентифікатор групи процесу з ідентифікатором процесу *pid*. Якщо "
"*pid* дорівнює 0, повертається ідентифікатор групи поточного процесу."

msgid "Return the id of the current process group."
msgstr "Повертає ідентифікатор поточної групи процесів."

msgid "Return the current process id."
msgstr "Повернути ідентифікатор поточного процесу."

msgid ""
"Return the parent's process id.  When the parent process has exited, on Unix "
"the id returned is the one of the init process (1), on Windows it is still "
"the same id, which may be already reused by another process."
msgstr ""
"Повертає ідентифікатор батьківського процесу. Коли батьківський процес "
"завершив роботу, в Unix повертається ідентифікатор процесу ініціалізації "
"(1), у Windows це все ще той самий ідентифікатор, який може вже повторно "
"використовуватися іншим процесом."

msgid "Added support for Windows."
msgstr "Додана підтримка Windows."

msgid ""
"Get program scheduling priority.  The value *which* is one of :const:"
"`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and *who* is "
"interpreted relative to *which* (a process identifier for :const:"
"`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, and a user "
"ID for :const:`PRIO_USER`).  A zero value for *who* denotes (respectively) "
"the calling process, the process group of the calling process, or the real "
"user ID of the calling process."
msgstr ""
"Отримати пріоритет планування програми. Значення *which* є одним із :const:"
"`PRIO_PROCESS`, :const:`PRIO_PGRP` або :const:`PRIO_USER`, і *who* "
"інтерпретується відносно *which* (ідентифікатор процесу для :const:"
"`PRIO_PROCESS`, ідентифікатор групи процесів для :const:`PRIO_PGRP` та "
"ідентифікатор користувача для :const:`PRIO_USER`). Нульове значення для "
"*who* позначає (відповідно) викликаючий процес, групу процесів викликаючого "
"процесу або справжній ідентифікатор користувача викликаючого процесу."

msgid ""
"Parameters for the :func:`getpriority` and :func:`setpriority` functions."
msgstr "Параметри для функцій :func:`getpriority` і :func:`setpriority`."

msgid ""
"Return a tuple (ruid, euid, suid) denoting the current process's real, "
"effective, and saved user ids."
msgstr ""
"Повертає кортеж (ruid, euid, suid), що позначає справжні, ефективні та "
"збережені ідентифікатори користувачів поточного процесу."

msgid ""
"Return a tuple (rgid, egid, sgid) denoting the current process's real, "
"effective, and saved group ids."
msgstr ""
"Повертає кортеж (rgid, egid, sgid), що позначає справжні, ефективні та "
"збережені ідентифікатори груп поточного процесу."

msgid "Return the current process's real user id."
msgstr "Повертає справжній ідентифікатор користувача поточного процесу."

msgid ""
"Call the system initgroups() to initialize the group access list with all of "
"the groups of which the specified username is a member, plus the specified "
"group id."
msgstr ""
"Викличте системний initgroups(), щоб ініціалізувати список доступу групи з "
"усіма групами, членом яких є вказане ім’я користувача, а також ідентифікатор "
"зазначеної групи."

msgid ""
"Set the environment variable named *key* to the string *value*.  Such "
"changes to the environment affect subprocesses started with :func:`os."
"system`, :func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"Встановіть змінну середовища з назвою *key* на рядкове *значення*. Такі "
"зміни в середовищі впливають на підпроцеси, запущені з :func:`os.system`, :"
"func:`popen` або :func:`fork` і :func:`execv`."

msgid ""
"Assignments to items in :data:`os.environ` are automatically translated into "
"corresponding calls to :func:`putenv`; however, calls to :func:`putenv` "
"don't update :data:`os.environ`, so it is actually preferable to assign to "
"items of :data:`os.environ`. This also applies to :func:`getenv` and :func:"
"`getenvb`, which respectively use :data:`os.environ` and :data:`os.environb` "
"in their implementations."
msgstr ""
"Призначення елементів у :data:`os.environ` автоматично перетворюються на "
"відповідні виклики :func:`putenv`; однак виклики :func:`putenv` не "
"оновлюють :data:`os.environ`, тому насправді краще призначати елементам :"
"data:`os.environ`. Це також стосується :func:`getenv` і :func:`getenvb`, які "
"відповідно використовують :data:`os.environ` і :data:`os.environb` у своїх "
"реалізаціях."

msgid ""
"On some platforms, including FreeBSD and macOS, setting ``environ`` may "
"cause memory leaks. Refer to the system documentation for :c:func:`putenv`."
msgstr ""
"На деяких платформах, включаючи FreeBSD і macOS, налаштування ``environ`` "
"може спричинити витік пам’яті. Зверніться до системної документації для :c:"
"func:`putenv`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.putenv`` with arguments "
"``key``, ``value``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.putenv`` з аргументами ``key``, "
"``value``."

msgid "The function is now always available."
msgstr "Тепер функція доступна завжди."

msgid "Set the current process's effective group id."
msgstr "Установіть ефективний ідентифікатор групи поточного процесу."

msgid "Set the current process's effective user id."
msgstr "Встановити ефективний ідентифікатор користувача поточного процесу."

msgid "Set the current process' group id."
msgstr "Встановіть ідентифікатор групи поточного процесу."

msgid ""
"Set the list of supplemental group ids associated with the current process "
"to *groups*. *groups* must be a sequence, and each element must be an "
"integer identifying a group. This operation is typically available only to "
"the superuser."
msgstr ""
"Установіть для списку ідентифікаторів додаткових груп, пов’язаних із "
"поточним процесом, значення *groups*. *групи* мають бути послідовністю, а "
"кожен елемент має бути цілим числом, що ідентифікує групу. Зазвичай ця "
"операція доступна лише суперкористувачу."

msgid ""
"On macOS, the length of *groups* may not exceed the system-defined maximum "
"number of effective group ids, typically 16. See the documentation for :func:"
"`getgroups` for cases where it may not return the same group list set by "
"calling setgroups()."
msgstr ""
"У macOS довжина *groups* не може перевищувати визначену системою максимальну "
"кількість ефективних ідентифікаторів груп, як правило, 16. Перегляньте "
"документацію для :func:`getgroups`, щоб дізнатися про випадки, коли він може "
"не повернути той самий список груп, встановлений за допомогою виклику "
"setgroups()."

msgid ""
"Call the system call :c:func:`setpgrp` or ``setpgrp(0, 0)`` depending on "
"which version is implemented (if any).  See the Unix manual for the "
"semantics."
msgstr ""
"Викличте системний виклик :c:func:`setpgrp` або ``setpgrp(0, 0)`` залежно "
"від того, яка версія реалізована (якщо така є). Перегляньте посібник з Unix "
"для семантики."

msgid ""
"Call the system call :c:func:`setpgid` to set the process group id of the "
"process with id *pid* to the process group with id *pgrp*.  See the Unix "
"manual for the semantics."
msgstr ""
"Викличте системний виклик :c:func:`setpgid`, щоб встановити ідентифікатор "
"групи процесів процесу з ідентифікатором *pid* на групу процесів з "
"ідентифікатором *pgrp*. Перегляньте посібник з Unix для семантики."

msgid ""
"Set program scheduling priority. The value *which* is one of :const:"
"`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and *who* is "
"interpreted relative to *which* (a process identifier for :const:"
"`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, and a user "
"ID for :const:`PRIO_USER`). A zero value for *who* denotes (respectively) "
"the calling process, the process group of the calling process, or the real "
"user ID of the calling process. *priority* is a value in the range -20 to "
"19. The default priority is 0; lower priorities cause more favorable "
"scheduling."
msgstr ""
"Встановити пріоритет планування програми. Значення *which* є одним із :const:"
"`PRIO_PROCESS`, :const:`PRIO_PGRP` або :const:`PRIO_USER` і *who* "
"інтерпретується відносно *which* (ідентифікатор процесу для :const:"
"`PRIO_PROCESS`, ідентифікатор групи процесів для :const:`PRIO_PGRP` та "
"ідентифікатор користувача для :const:`PRIO_USER`). Нульове значення для "
"*who* позначає (відповідно) викликаючий процес, групу процесів викликаючого "
"процесу або справжній ідентифікатор користувача викликаючого процесу. "
"*пріоритет* — це значення в діапазоні від -20 до 19. Пріоритет за "
"замовчуванням — 0; нижчі пріоритети викликають більш сприятливе планування."

msgid "Set the current process's real and effective group ids."
msgstr ""
"Встановіть справжні та ефективні ідентифікатори груп поточного процесу."

msgid "Set the current process's real, effective, and saved group ids."
msgstr ""
"Встановіть реальні, ефективні та збережені ідентифікатори груп поточного "
"процесу."

msgid "Set the current process's real, effective, and saved user ids."
msgstr ""
"Встановіть справжні, ефективні та збережені ідентифікатори користувачів "
"поточного процесу."

msgid "Set the current process's real and effective user ids."
msgstr ""
"Встановіть справжні та ефективні ідентифікатори користувачів поточного "
"процесу."

msgid ""
"Call the system call :c:func:`getsid`.  See the Unix manual for the "
"semantics."
msgstr ""
"Викличте системний виклик :c:func:`getsid`. Перегляньте посібник з Unix для "
"семантики."

msgid ""
"Call the system call :c:func:`setsid`.  See the Unix manual for the "
"semantics."
msgstr ""
"Викличте системний виклик :c:func:`setsid`. Перегляньте посібник з Unix для "
"семантики."

msgid "Set the current process's user id."
msgstr "Встановіть ідентифікатор користувача поточного процесу."

msgid ""
"Return the error message corresponding to the error code in *code*. On "
"platforms where :c:func:`strerror` returns ``NULL`` when given an unknown "
"error number, :exc:`ValueError` is raised."
msgstr ""
"Повернути повідомлення про помилку, що відповідає коду помилки в *code*. На "
"платформах, де :c:func:`strerror` повертає ``NULL``, коли отримує невідомий "
"номер помилки, виникає :exc:`ValueError`."

msgid ""
"``True`` if the native OS type of the environment is bytes (eg. ``False`` on "
"Windows)."
msgstr ""
"``True``, якщо рідний тип ОС середовища - байти (наприклад, ``False`` у "
"Windows)."

msgid "Set the current numeric umask and return the previous umask."
msgstr "Установіть поточну цифрову umask і поверніть попередню umask."

msgid ""
"Returns information identifying the current operating system. The return "
"value is an object with five attributes:"
msgstr ""
"Повертає інформацію про поточну операційну систему. Значення, що "
"повертається, є об’єктом із п’ятьма атрибутами:"

msgid ":attr:`sysname` - operating system name"
msgstr ":attr:`sysname` - назва операційної системи"

msgid ":attr:`nodename` - name of machine on network (implementation-defined)"
msgstr ":attr:`nodename` - ім'я машини в мережі (визначено реалізацією)"

msgid ":attr:`release` - operating system release"
msgstr ":attr:`release` - випуск операційної системи"

msgid ":attr:`version` - operating system version"
msgstr ":attr:`version` - версія операційної системи"

msgid ":attr:`machine` - hardware identifier"
msgstr ":attr:`machine` - ідентифікатор обладнання"

msgid ""
"For backwards compatibility, this object is also iterable, behaving like a "
"five-tuple containing :attr:`sysname`, :attr:`nodename`, :attr:`release`, :"
"attr:`version`, and :attr:`machine` in that order."
msgstr ""
"Для зворотної сумісності цей об’єкт також можна ітерувати, ведучи себе як "
"п’ять кортежів, що містять :attr:`sysname`, :attr:`nodename`, :attr:"
"`release`, :attr:`version` і :attr:`machine` в такому порядку."

msgid ""
"Some systems truncate :attr:`nodename` to 8 characters or to the leading "
"component; a better way to get the hostname is :func:`socket.gethostname`  "
"or even ``socket.gethostbyaddr(socket.gethostname())``."
msgstr ""
"Деякі системи скорочують :attr:`nodename` до 8 символів або до початкового "
"компонента; кращий спосіб отримати ім’я хоста – :func:`socket.gethostname` "
"або навіть ``socket.gethostbyaddr(socket.gethostname())``."

msgid ":ref:`Availability <availability>`: recent flavors of Unix."
msgstr ":ref:`Доступність <availability>`: останні версії Unix."

msgid ""
"Return type changed from a tuple to a tuple-like object with named "
"attributes."
msgstr ""
"Тип повернення змінено з кортежу на кортежний об’єкт з іменованими "
"атрибутами."

msgid ""
"Unset (delete) the environment variable named *key*. Such changes to the "
"environment affect subprocesses started with :func:`os.system`, :func:"
"`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"Скасувати (видалити) змінну середовища з назвою *key*. Такі зміни в "
"середовищі впливають на підпроцеси, запущені з :func:`os.system`, :func:"
"`popen` або :func:`fork` і :func:`execv`."

msgid ""
"Deletion of items in :data:`os.environ` is automatically translated into a "
"corresponding call to :func:`unsetenv`; however, calls to :func:`unsetenv` "
"don't update :data:`os.environ`, so it is actually preferable to delete "
"items of :data:`os.environ`."
msgstr ""
"Видалення елементів у :data:`os.environ` автоматично перетворюється на "
"відповідний виклик :func:`unsetenv`; однак виклики :func:`unsetenv` не "
"оновлюють :data:`os.environ`, тому насправді краще видалити елементи :data:"
"`os.environ`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.unsetenv`` with argument "
"``key``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.unsetenv`` з аргументом ``key``."

msgid "The function is now always available and is also available on Windows."
msgstr "Функція тепер доступна завжди і також доступна в Windows."

msgid "File Object Creation"
msgstr "Створення файлового об’єкта"

msgid ""
"These functions create new :term:`file objects <file object>`.  (See also :"
"func:`~os.open` for opening file descriptors.)"
msgstr ""
"Ці функції створюють нові :term:`файлові об’єкти <file object>`. (Див. "
"також :func:`~os.open` для відкриття дескрипторів файлів.)"

msgid ""
"Return an open file object connected to the file descriptor *fd*.  This is "
"an alias of the :func:`open` built-in function and accepts the same "
"arguments. The only difference is that the first argument of :func:`fdopen` "
"must always be an integer."
msgstr ""
"Повертає відкритий файловий об'єкт, підключений до файлового дескриптора "
"*fd*. Це псевдонім вбудованої функції :func:`open` і приймає ті самі "
"аргументи. Єдина відмінність полягає в тому, що перший аргумент :func:"
"`fdopen` завжди має бути цілим числом."

msgid "File Descriptor Operations"
msgstr "Операції файлового дескриптора"

msgid ""
"These functions operate on I/O streams referenced using file descriptors."
msgstr ""
"Ці функції працюють із потоками введення/виведення, на які посилаються за "
"допомогою файлових дескрипторів."

msgid ""
"File descriptors are small integers corresponding to a file that has been "
"opened by the current process.  For example, standard input is usually file "
"descriptor 0, standard output is 1, and standard error is 2.  Further files "
"opened by a process will then be assigned 3, 4, 5, and so forth.  The name "
"\"file descriptor\" is slightly deceptive; on Unix platforms, sockets and "
"pipes are also referenced by file descriptors."
msgstr ""
"Дескриптори файлів — це малі цілі числа, що відповідають файлу, відкритому "
"поточним процесом. Наприклад, стандартним введенням зазвичай є дескриптор "
"файлу 0, стандартним виводом є 1, а стандартною помилкою є 2. Іншим файлам, "
"відкритим процесом, буде присвоєно 3, 4, 5 і так далі. Назва \"файловий "
"дескриптор\" трохи оманлива; на платформах Unix на сокети та канали також "
"посилаються дескриптори файлів."

msgid ""
"The :meth:`~io.IOBase.fileno` method can be used to obtain the file "
"descriptor associated with a :term:`file object` when required.  Note that "
"using the file descriptor directly will bypass the file object methods, "
"ignoring aspects such as internal buffering of data."
msgstr ""
"Метод :meth:`~io.IOBase.fileno` можна використовувати для отримання "
"дескриптора файлу, пов’язаного з :term:`file object`, коли це необхідно. "
"Зауважте, що використання безпосередньо файлового дескриптора обійде методи "
"файлового об’єкта, ігноруючи такі аспекти, як внутрішня буферизація даних."

msgid "Close file descriptor *fd*."
msgstr "Закрити файловий дескриптор *fd*."

msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`pipe`.  To close a "
"\"file object\" returned by the built-in function :func:`open` or by :func:"
"`popen` or :func:`fdopen`, use its :meth:`~io.IOBase.close` method."
msgstr ""
"Ця функція призначена для низькорівневого вводу-виводу та має "
"застосовуватися до дескриптора файлу, який повертає :func:`os.open` або :"
"func:`pipe`. Щоб закрити \"файловий об’єкт\", повернутий вбудованою "
"функцією :func:`open` або :func:`popen` або :func:`fdopen`, скористайтеся "
"його методом :meth:`~io.IOBase.close` ."

msgid ""
"Close all file descriptors from *fd_low* (inclusive) to *fd_high* "
"(exclusive), ignoring errors. Equivalent to (but much faster than)::"
msgstr ""
"Закрийте всі файлові дескриптори від *fd_low* (включно) до *fd_high* "
"(виключно), ігноруючи помилки. Еквівалентно (але набагато швидше ніж):"

msgid ""
"Copy *count* bytes from file descriptor *src*, starting from offset "
"*offset_src*, to file descriptor *dst*, starting from offset *offset_dst*. "
"If *offset_src* is None, then *src* is read from the current position; "
"respectively for *offset_dst*. The files pointed by *src* and *dst* must "
"reside in the same filesystem, otherwise an :exc:`OSError` is raised with :"
"attr:`~OSError.errno` set to :data:`errno.EXDEV`."
msgstr ""
"Скопіюйте *count* байтів із файлового дескриптора *src*, починаючи зі зсуву "
"*offset_src*, до файлового дескриптора *dst*, починаючи зі зсуву "
"*offset_dst*. Якщо *offset_src* має значення None, тоді *src* читається з "
"поточної позиції; відповідно для *offset_dst*. Файли, на які вказують *src* "
"і *dst*, повинні знаходитися в одній файловій системі, інакше виникає :exc:"
"`OSError` з :attr:`~OSError.errno`, встановленим на :data:`errno.EXDEV`."

msgid ""
"This copy is done without the additional cost of transferring data from the "
"kernel to user space and then back into the kernel. Additionally, some "
"filesystems could implement extra optimizations. The copy is done as if both "
"files are opened as binary."
msgstr ""
"Ця копія виконується без додаткових витрат на передачу даних із ядра в "
"простір користувача, а потім назад у ядро. Крім того, деякі файлові системи "
"можуть реалізувати додаткові оптимізації. Копіювання виконується так, ніби "
"обидва файли відкриваються як двійкові."

msgid ""
"The return value is the amount of bytes copied. This could be less than the "
"amount requested."
msgstr ""
"Поверненим значенням є кількість скопійованих байтів. Це може бути менше "
"запитаної суми."

msgid ""
":ref:`Availability <availability>`: Linux kernel >= 4.5 or glibc >= 2.27."
msgstr ""
":ref:`Доступність <availability>`: ядро Linux >= 4.5 або glibc >= 2.27."

msgid ""
"Return a string describing the encoding of the device associated with *fd* "
"if it is connected to a terminal; else return :const:`None`."
msgstr ""
"Повертає рядок, що описує кодування пристрою, пов’язаного з *fd*, якщо він "
"підключений до терміналу; інакше повертає :const:`None`."

msgid ""
"On Unix, if the :ref:`Python UTF-8 Mode <utf8-mode>` is enabled, return "
"``'UTF-8'`` rather than the device encoding."
msgstr ""
"В Unix, якщо ввімкнено :ref:`Python UTF-8 Mode <utf8-mode>`, поверніть "
"``'UTF-8''`` замість кодування пристрою."

msgid "On Unix, the function now implements the Python UTF-8 Mode."
msgstr "В Unix функція тепер реалізує режим Python UTF-8."

msgid ""
"Return a duplicate of file descriptor *fd*. The new file descriptor is :ref:"
"`non-inheritable <fd_inheritance>`."
msgstr ""
"Повертає дублікат файлового дескриптора *fd*. Новий файловий дескриптор :ref:"
"`не успадковується <fd_inheritance>`."

msgid ""
"On Windows, when duplicating a standard stream (0: stdin, 1: stdout, 2: "
"stderr), the new file descriptor is :ref:`inheritable <fd_inheritance>`."
msgstr ""
"У Windows під час дублювання стандартного потоку (0: stdin, 1: stdout, 2: "
"stderr) новий дескриптор файлу є :ref:`inheritable <fd_inheritance>`."

msgid "The new file descriptor is now non-inheritable."
msgstr "Новий файловий дескриптор тепер не успадковується."

msgid ""
"Duplicate file descriptor *fd* to *fd2*, closing the latter first if "
"necessary. Return *fd2*. The new file descriptor is :ref:`inheritable "
"<fd_inheritance>` by default or non-inheritable if *inheritable* is "
"``False``."
msgstr ""
"Дублюйте файловий дескриптор *fd* до *fd2*, закриваючи останній, якщо "
"необхідно. Повернути *fd2*. Новий файловий дескриптор :ref:`inheritable "
"<fd_inheritance>` за замовчуванням або не успадковується, якщо *inheritable* "
"має значення ``False``."

msgid "Add the optional *inheritable* parameter."
msgstr "Додайте необов’язковий параметр *inheritable*."

msgid "Return *fd2* on success. Previously, ``None`` was always returned."
msgstr "Повернути *fd2* у разі успіху. Раніше завжди повертався ``None``."

msgid ""
"Change the mode of the file given by *fd* to the numeric *mode*.  See the "
"docs for :func:`chmod` for possible values of *mode*.  As of Python 3.3, "
"this is equivalent to ``os.chmod(fd, mode)``."
msgstr ""
"Змініть режим файлу, заданий *fd*, на числовий *режим*. Перегляньте "
"документацію для :func:`chmod`, щоб дізнатися про можливі значення *mode*. "
"Починаючи з Python 3.3, це еквівалентно ``os.chmod(fd, mode)``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chmod`` with arguments "
"``path``, ``mode``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.chmod`` з аргументами ``path``, "
"``mode``, ``dir_fd``."

msgid ""
"Change the owner and group id of the file given by *fd* to the numeric *uid* "
"and *gid*.  To leave one of the ids unchanged, set it to -1.  See :func:"
"`chown`.  As of Python 3.3, this is equivalent to ``os.chown(fd, uid, gid)``."
msgstr ""
"Змініть ідентифікатор власника та групи файлу, наданий *fd*, на числові "
"*uid* і *gid*. Щоб залишити один із ідентифікаторів без змін, встановіть для "
"нього значення -1. Дивіться :func:`chown`. Починаючи з Python 3.3, це "
"еквівалентно ``os.chown(fd, uid, gid)``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chown`` with arguments "
"``path``, ``uid``, ``gid``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.chown`` з аргументами ``path``, "
"``uid``, ``gid``, ``dir_fd``."

msgid ""
"Force write of file with filedescriptor *fd* to disk. Does not force update "
"of metadata."
msgstr ""
"Примусовий запис файлу з файловим дескриптором *fd* на диск. Не примусово "
"оновлювати метадані."

msgid "This function is not available on MacOS."
msgstr "Ця функція недоступна в MacOS."

msgid ""
"Return system configuration information relevant to an open file. *name* "
"specifies the configuration value to retrieve; it may be a string which is "
"the name of a defined system value; these names are specified in a number of "
"standards (POSIX.1, Unix 95, Unix 98, and others).  Some platforms define "
"additional names as well.  The names known to the host operating system are "
"given in the ``pathconf_names`` dictionary.  For configuration variables not "
"included in that mapping, passing an integer for *name* is also accepted."
msgstr ""
"Повертає інформацію про конфігурацію системи, що стосується відкритого "
"файлу. *name* вказує значення конфігурації для отримання; це може бути "
"рядок, який є назвою визначеного системного значення; ці назви вказані в "
"ряді стандартів (POSIX.1, Unix 95, Unix 98 та інші). Деякі платформи також "
"визначають додаткові імена. Імена, відомі головній операційній системі, "
"наведено у словнику ``pathconf_names``. Для змінних конфігурації, не "
"включених до цього відображення, також допускається передача цілого числа "
"для *name*."

msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If a "
"specific value for *name* is not supported by the host system, even if it is "
"included in ``pathconf_names``, an :exc:`OSError` is raised with :const:"
"`errno.EINVAL` for the error number."
msgstr ""
"Якщо *name* є рядком і невідоме, виникає :exc:`ValueError`. Якщо певне "
"значення для *name* не підтримується хост-системою, навіть якщо воно "
"включено в ``pathconf_names``, виникає :exc:`OSError` з :const:`errno."
"EINVAL` для номера помилки ."

msgid "As of Python 3.3, this is equivalent to ``os.pathconf(fd, name)``."
msgstr "Починаючи з Python 3.3, це еквівалентно ``os.pathconf(fd, name)``."

msgid ""
"Get the status of the file descriptor *fd*. Return a :class:`stat_result` "
"object."
msgstr ""
"Отримати статус дескриптора файлу *fd*. Повертає об’єкт :class:`stat_result`."

msgid "As of Python 3.3, this is equivalent to ``os.stat(fd)``."
msgstr "Починаючи з Python 3.3, це еквівалентно ``os.stat(fd)``."

msgid "The :func:`.stat` function."
msgstr "Функція :func:`.stat`."

msgid ""
"Return information about the filesystem containing the file associated with "
"file descriptor *fd*, like :func:`statvfs`.  As of Python 3.3, this is "
"equivalent to ``os.statvfs(fd)``."
msgstr ""
"Повертає інформацію про файлову систему, яка містить файл, пов’язаний із "
"файловим дескриптором *fd*, наприклад :func:`statvfs`. Починаючи з Python "
"3.3, це еквівалентно ``os.statvfs(fd)``."

msgid ""
"Force write of file with filedescriptor *fd* to disk.  On Unix, this calls "
"the native :c:func:`fsync` function; on Windows, the MS :c:func:`_commit` "
"function."
msgstr ""
"Примусовий запис файлу з файловим дескриптором *fd* на диск. В Unix це "
"викликає власну функцію :c:func:`fsync`; у Windows — функція MS :c:func:"
"`_commit`."

msgid ""
"If you're starting with a buffered Python :term:`file object` *f*, first do "
"``f.flush()``, and then do ``os.fsync(f.fileno())``, to ensure that all "
"internal buffers associated with *f* are written to disk."
msgstr ""
"Якщо ви починаєте з буферизованого :term:`file object` Python *f*, спочатку "
"виконайте ``f.flush()``, а потім виконайте ``os.fsync(f.fileno())``, щоб "
"переконатися, що всі внутрішні буфери, пов’язані з *f*, записуються на диск."

msgid ""
"Truncate the file corresponding to file descriptor *fd*, so that it is at "
"most *length* bytes in size.  As of Python 3.3, this is equivalent to ``os."
"truncate(fd, length)``."
msgstr ""
"Обріжте файл, що відповідає файловому дескриптору *fd*, щоб він мав розмір "
"не більше *length* байтів. Починаючи з Python 3.3, це еквівалентно ``os."
"truncate(fd, length)``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.truncate`` with arguments "
"``fd``, ``length``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.truncate`` з аргументами "
"``fd``, ``length``."

msgid "Added support for Windows"
msgstr "Додана підтримка Windows"

msgid ""
"Get the blocking mode of the file descriptor: ``False`` if the :data:"
"`O_NONBLOCK` flag is set, ``True`` if the flag is cleared."
msgstr ""
"Отримати режим блокування дескриптора файлу: ``False``, якщо встановлено "
"прапорець :data:`O_NONBLOCK`, ``True``, якщо прапорець знято."

msgid "See also :func:`set_blocking` and :meth:`socket.socket.setblocking`."
msgstr ""
"Дивіться також :func:`set_blocking` і :meth:`socket.socket.setblocking`."

msgid ""
"Return ``True`` if the file descriptor *fd* is open and connected to a tty(-"
"like) device, else ``False``."
msgstr ""
"Повертає ``True``, якщо файловий дескриптор *fd* відкрито та підключено до "
"tty(-like) пристрою, інакше ``False``."

msgid ""
"Apply, test or remove a POSIX lock on an open file descriptor. *fd* is an "
"open file descriptor. *cmd* specifies the command to use - one of :data:"
"`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` or :data:`F_TEST`. *len* "
"specifies the section of the file to lock."
msgstr ""
"Застосуйте, перевірте або видаліть блокування POSIX для відкритого файлового "
"дескриптора. *fd* — дескриптор відкритого файлу. *cmd* визначає команду для "
"використання - одну з :data:`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` або :"
"data:`F_TEST`. *len* вказує розділ файлу, який потрібно заблокувати."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.lockf`` with arguments "
"``fd``, ``cmd``, ``len``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.lockf`` з аргументами ``fd``, "
"``cmd``, ``len``."

msgid "Flags that specify what action :func:`lockf` will take."
msgstr "Прапорці, які вказують, яку дію виконуватиме :func:`lockf`."

msgid ""
"Set the current position of file descriptor *fd* to position *pos*, modified "
"by *how*: :const:`SEEK_SET` or ``0`` to set the position relative to the "
"beginning of the file; :const:`SEEK_CUR` or ``1`` to set it relative to the "
"current position; :const:`SEEK_END` or ``2`` to set it relative to the end "
"of the file. Return the new cursor position in bytes, starting from the "
"beginning."
msgstr ""
"Установіть поточну позицію дескриптора файлу *fd* у позицію *pos*, змінену "
"*how*: :const:`SEEK_SET` або ``0``, щоб встановити позицію відносно початку "
"файлу; :const:`SEEK_CUR` або ``1``, щоб встановити його відносно поточної "
"позиції; :const:`SEEK_END` або ``2``, щоб встановити його відносно кінця "
"файлу. Повертає нову позицію курсору в байтах, починаючи з початку."

msgid ""
"Parameters to the :func:`lseek` function. Their values are 0, 1, and 2, "
"respectively."
msgstr ""
"Параметри функції :func:`lseek`. Їх значення дорівнюють 0, 1 і 2 відповідно."

msgid ""
"Some operating systems could support additional values, like :data:`os."
"SEEK_HOLE` or :data:`os.SEEK_DATA`."
msgstr ""
"Деякі операційні системи можуть підтримувати додаткові значення, наприклад :"
"data:`os.SEEK_HOLE` або :data:`os.SEEK_DATA`."

msgid ""
"Open the file *path* and set various flags according to *flags* and possibly "
"its mode according to *mode*.  When computing *mode*, the current umask "
"value is first masked out.  Return the file descriptor for the newly opened "
"file. The new file descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"Відкрийте *шлях* до файлу та встановіть різні позначки відповідно до *flags* "
"і, можливо, його режим відповідно до *mode*. Під час обчислення *режиму* "
"поточне значення umask спочатку маскується. Повертає файловий дескриптор для "
"щойно відкритого файлу. Новий файловий дескриптор :ref:`не успадковується "
"<fd_inheritance>`."

msgid ""
"For a description of the flag and mode values, see the C run-time "
"documentation; flag constants (like :const:`O_RDONLY` and :const:`O_WRONLY`) "
"are defined in the :mod:`os` module.  In particular, on Windows adding :"
"const:`O_BINARY` is needed to open files in binary mode."
msgstr ""
"Для опису значень прапора та режиму дивіться документацію про час виконання "
"C; константи прапорів (наприклад, :const:`O_RDONLY` і :const:`O_WRONLY`) "
"визначені в модулі :mod:`os`. Зокрема, у Windows додавання :const:`O_BINARY` "
"потрібне для відкриття файлів у бінарному режимі."

msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>` with the *dir_fd* parameter."
msgstr ""
"Ця функція може підтримувати :ref:`шляхи відносно дескрипторів каталогу "
"<dir_fd>` з параметром *dir_fd*."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``open`` з аргументами ``path``, "
"``mode``, ``flags``."

msgid ""
"This function is intended for low-level I/O.  For normal usage, use the "
"built-in function :func:`open`, which returns a :term:`file object` with :"
"meth:`~file.read` and :meth:`~file.write` methods (and many more).  To wrap "
"a file descriptor in a file object, use :func:`fdopen`."
msgstr ""
"Ця функція призначена для низькорівневого введення-виведення. Для звичайного "
"використання використовуйте вбудовану функцію :func:`open`, яка повертає "
"об’єкт :term:`file object` з методами :meth:`~file.read` і :meth:`~file."
"write` (і набагато більше). Щоб обернути файловий дескриптор у файловий "
"об’єкт, використовуйте :func:`fdopen`."

msgid "The *dir_fd* argument."
msgstr "Аргумент *dir_fd*."

msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an :"
"exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Якщо системний виклик перервано, а обробник сигналу не викликає виключення, "
"функція тепер повторює системний виклик замість того, щоб викликати виняток :"
"exc:`InterruptedError` (перегляньте :pep:`475` для обґрунтування)."

msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

msgid ""
"The following constants are options for the *flags* parameter to the :func:"
"`~os.open` function.  They can be combined using the bitwise OR operator ``|"
"``.  Some of them are not available on all platforms.  For descriptions of "
"their availability and use, consult the :manpage:`open(2)` manual page on "
"Unix or `the MSDN <https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx>`_ "
"on Windows."
msgstr ""
"Наступні константи є опціями для параметра *flags* функції :func:`~os.open`. "
"Їх можна комбінувати за допомогою порозрядного оператора АБО ``|``. Деякі з "
"них доступні не на всіх платформах. Для опису їх доступності та використання "
"зверніться до :manpage:`open(2)` сторінки посібника для Unix або `MSDN "
"<https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx>`_ для Windows."

msgid "The above constants are available on Unix and Windows."
msgstr "Наведені вище константи доступні в Unix і Windows."

msgid "The above constants are only available on Unix."
msgstr "Наведені вище константи доступні лише в Unix."

msgid "Add :data:`O_CLOEXEC` constant."
msgstr "Додайте константу :data:`O_CLOEXEC`."

msgid "The above constants are only available on Windows."
msgstr "Наведені вище константи доступні лише у Windows."

msgid "The above constants are only available on macOS."
msgstr "Наведені вище константи доступні лише в macOS."

msgid ""
"Add :data:`O_EVTONLY`, :data:`O_FSYNC`, :data:`O_SYMLINK` and :data:"
"`O_NOFOLLOW_ANY` constants."
msgstr ""
"Додайте константи :data:`O_EVTONLY`, :data:`O_FSYNC`, :data:`O_SYMLINK` і :"
"data:`O_NOFOLLOW_ANY`."

msgid ""
"The above constants are extensions and not present if they are not defined "
"by the C library."
msgstr ""
"Наведені вище константи є розширеннями і не присутні, якщо вони не визначені "
"бібліотекою C."

msgid ""
"Add :data:`O_PATH` on systems that support it. Add :data:`O_TMPFILE`, only "
"available on Linux Kernel 3.11   or newer."
msgstr ""
"Додайте :data:`O_PATH` до систем, які його підтримують. Додайте :data:"
"`O_TMPFILE`, доступний лише на ядрі Linux 3.11 або новіших."

msgid ""
"Open a new pseudo-terminal pair. Return a pair of file descriptors "
"``(master, slave)`` for the pty and the tty, respectively. The new file "
"descriptors are :ref:`non-inheritable <fd_inheritance>`. For a (slightly) "
"more portable approach, use the :mod:`pty` module."
msgstr ""
"Відкрийте нову пару псевдотерміналів. Повертає пару файлових дескрипторів "
"``(master, slave)`` для pty і tty відповідно. Нові дескриптори файлів :ref:"
"`не успадковуються <fd_inheritance>`. Для (трохи) більш портативного підходу "
"використовуйте модуль :mod:`pty`."

msgid ":ref:`Availability <availability>`: some flavors of Unix."
msgstr ":ref:`Наявність <availability>`: деякі різновиди Unix."

msgid "The new file descriptors are now non-inheritable."
msgstr "Нові файлові дескриптори тепер не успадковуються."

msgid ""
"Create a pipe.  Return a pair of file descriptors ``(r, w)`` usable for "
"reading and writing, respectively. The new file descriptor is :ref:`non-"
"inheritable <fd_inheritance>`."
msgstr ""
"Створіть трубу. Повертає пару файлових дескрипторів ``(r, w)``, які можна "
"використовувати для читання та запису відповідно. Новий файловий дескриптор :"
"ref:`не успадковується <fd_inheritance>`."

msgid ""
"Create a pipe with *flags* set atomically. *flags* can be constructed by "
"ORing together one or more of these values: :data:`O_NONBLOCK`, :data:"
"`O_CLOEXEC`. Return a pair of file descriptors ``(r, w)`` usable for reading "
"and writing, respectively."
msgstr ""
"Створіть трубу з *прапорцями*, встановленими атомарно. *прапорці* можуть "
"бути створені шляхом об’єднання одного або кількох із цих значень :data:"
"`O_NONBLOCK`, :data:`O_CLOEXEC`. Повертає пару файлових дескрипторів ``(r, "
"w)``, які можна використовувати для читання та запису відповідно."

msgid ""
"Ensures that enough disk space is allocated for the file specified by *fd* "
"starting from *offset* and continuing for *len* bytes."
msgstr ""
"Переконується, що для файлу, указаного *fd*, виділено достатньо місця на "
"диску, починаючи з *offset* і продовжуючи *len* байт."

msgid ""
"Announces an intention to access data in a specific pattern thus allowing "
"the kernel to make optimizations. The advice applies to the region of the "
"file specified by *fd* starting at *offset* and continuing for *len* bytes. "
"*advice* is one of :data:`POSIX_FADV_NORMAL`, :data:"
"`POSIX_FADV_SEQUENTIAL`, :data:`POSIX_FADV_RANDOM`, :data:"
"`POSIX_FADV_NOREUSE`, :data:`POSIX_FADV_WILLNEED` or :data:"
"`POSIX_FADV_DONTNEED`."
msgstr ""
"Оголошує про намір отримати доступ до даних за певним шаблоном, що дозволяє "
"ядру проводити оптимізацію. Порада стосується регіону файлу, визначеного "
"*fd*, починаючи з *offset* і продовжуючи *len* байти. *порада* є одним із :"
"data:`POSIX_FADV_NORMAL`, :data:`POSIX_FADV_SEQUENTIAL`, :data:"
"`POSIX_FADV_RANDOM`, :data:`POSIX_FADV_NOREUSE`, :data:`POSIX_FADV_WILLNEED` "
"або :data:`POSIX_FADV_DONTNEED`."

msgid ""
"Flags that can be used in *advice* in :func:`posix_fadvise` that specify the "
"access pattern that is likely to be used."
msgstr ""
"Прапорці, які можна використовувати в *advice* у :func:`posix_fadvise`, які "
"визначають шаблон доступу, який, імовірно, буде використаний."

msgid ""
"Read at most *n* bytes from file descriptor *fd* at a position of *offset*, "
"leaving the file offset unchanged."
msgstr ""
"Прочитати щонайбільше *n* байт із файлового дескриптора *fd* у позиції "
"*offset*, залишаючи зміщення файлу незмінним."

msgid ""
"Return a bytestring containing the bytes read. If the end of the file "
"referred to by *fd* has been reached, an empty bytes object is returned."
msgstr ""
"Повертає байтовий рядок, що містить прочитані байти. Якщо досягнуто кінця "
"файлу, на який посилається *fd*, повертається порожній об’єкт bytes."

msgid ""
"Read from a file descriptor *fd* at a position of *offset* into mutable :"
"term:`bytes-like objects <bytes-like object>` *buffers*, leaving the file "
"offset unchanged.  Transfer data into each buffer until it is full and then "
"move on to the next buffer in the sequence to hold the rest of the data."
msgstr ""
"Читання з файлового дескриптора *fd* у позиції *offset* у змінні :term:`байт-"
"подібні об’єкти <bytes-like object>` *buffers*, залишаючи зміщення файлу "
"незмінним. Передайте дані в кожен буфер, доки він не заповниться, а потім "
"перейдіть до наступного буфера в послідовності, щоб утримувати решту даних."

msgid ""
"The flags argument contains a bitwise OR of zero or more of the following "
"flags:"
msgstr "Аргумент flags містить порозрядне АБО нуля або більше таких прапорів:"

msgid ":data:`RWF_HIPRI`"
msgstr ":data:`RWF_HIPRI`"

msgid ":data:`RWF_NOWAIT`"
msgstr ":data:`RWF_NOWAIT`"

msgid ""
"Return the total number of bytes actually read which can be less than the "
"total capacity of all the objects."
msgstr ""
"Повертає загальну кількість фактично прочитаних байтів, яка може бути меншою "
"за загальну ємність усіх об’єктів."

msgid ""
"The operating system may set a limit (:func:`sysconf` value "
"``'SC_IOV_MAX'``) on the number of buffers that can be used."
msgstr ""
"Операційна система може встановити обмеження (:func:`sysconf` значення "
"``'SC_IOV_MAX'``) на кількість буферів, які можна використовувати."

msgid "Combine the functionality of :func:`os.readv` and :func:`os.pread`."
msgstr ""
"Поєднайте функціональні можливості :func:`os.readv` і :func:`os.pread`."

msgid ""
":ref:`Availability <availability>`: Linux 2.6.30 and newer, FreeBSD 6.0 and "
"newer, OpenBSD 2.7 and newer, AIX 7.1 and newer. Using flags requires Linux "
"4.6 or newer."
msgstr ""
":ref:`Доступність <availability>`: Linux 2.6.30 і новіші версії, FreeBSD 6.0 "
"і новіші версії, OpenBSD 2.7 і новіші версії, AIX 7.1 і новіші версії. Для "
"використання прапорів потрібна версія Linux 4.6 або новіша."

msgid ""
"Do not wait for data which is not immediately available. If this flag is "
"specified, the system call will return instantly if it would have to read "
"data from the backing storage or wait for a lock."
msgstr ""
"Не чекайте даних, які доступні не відразу. Якщо вказано цей прапорець, "
"системний виклик повернеться миттєво, якщо йому доведеться прочитати дані з "
"резервного сховища або дочекатися блокування."

msgid ""
"If some data was successfully read, it will return the number of bytes read. "
"If no bytes were read, it will return ``-1`` and set errno to :data:`errno."
"EAGAIN`."
msgstr ""
"Якщо деякі дані були успішно прочитані, він поверне кількість прочитаних "
"байтів. Якщо не було прочитано жодного байту, він поверне ``-1`` і "
"встановить errno як :data:`errno.EAGAIN`."

msgid ":ref:`Availability <availability>`: Linux 4.14 and newer."
msgstr ":ref:`Доступність <availability>`: Linux 4.14 і новіші версії."

msgid ""
"High priority read/write. Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources."
msgstr ""
"Високий пріоритет читання/запису. Дозволяє файловим системам на основі "
"блоків використовувати опитування пристрою, що забезпечує меншу затримку, "
"але може використовувати додаткові ресурси."

msgid ""
"Currently, on Linux, this feature is usable only on a file descriptor opened "
"using the :data:`O_DIRECT` flag."
msgstr ""
"Наразі в Linux цю функцію можна використовувати лише для дескриптора файлу, "
"відкритого за допомогою позначки :data:`O_DIRECT`."

msgid ":ref:`Availability <availability>`: Linux 4.6 and newer."
msgstr ":ref:`Наявність <availability>`: Linux 4.6 і новіші версії."

msgid ""
"Write the bytestring in *str* to file descriptor *fd* at position of "
"*offset*, leaving the file offset unchanged."
msgstr ""
"Запишіть байтовий рядок у *str* у файловий дескриптор *fd* у позиції "
"*offset*, залишаючи зміщення файлу без змін."

msgid "Return the number of bytes actually written."
msgstr "Повертає кількість фактично записаних байтів."

msgid ""
"Write the *buffers* contents to file descriptor *fd* at a offset *offset*, "
"leaving the file offset unchanged.  *buffers* must be a sequence of :term:"
"`bytes-like objects <bytes-like object>`. Buffers are processed in array "
"order. Entire contents of the first buffer is written before proceeding to "
"the second, and so on."
msgstr ""
"Запишіть вміст *buffers* у файловий дескриптор *fd* зі зміщенням *offset*, "
"залишаючи зміщення файлу без змін. *буфери* мають бути послідовністю :term:"
"`байт-подібних об’єктів <bytes-like object>`. Буфери обробляються в порядку "
"масиву. Весь вміст першого буфера записується перед переходом до другого і "
"так далі."

msgid ":data:`RWF_DSYNC`"
msgstr ":data:`RWF_DSYNC`"

msgid ":data:`RWF_SYNC`"
msgstr ":data:`RWF_SYNC`"

msgid ":data:`RWF_APPEND`"
msgstr ":data:`RWF_APPEND`"

msgid "Return the total number of bytes actually written."
msgstr "Повертає загальну кількість фактично записаних байтів."

msgid "Combine the functionality of :func:`os.writev` and :func:`os.pwrite`."
msgstr "Поєднайте функції :func:`os.writev` і :func:`os.pwrite`."

msgid ""
":ref:`Availability <availability>`: Linux 2.6.30 and newer, FreeBSD 6.0 and "
"newer, OpenBSD 2.7 and newer, AIX 7.1 and newer. Using flags requires Linux "
"4.7 or newer."
msgstr ""
":ref:`Доступність <availability>`: Linux 2.6.30 і новіші версії, FreeBSD 6.0 "
"і новіші версії, OpenBSD 2.7 і новіші версії, AIX 7.1 і новіші версії. Для "
"використання прапорів потрібна версія Linux 4.7 або новіша."

msgid ""
"Provide a per-write equivalent of the :data:`O_DSYNC` :func:`os.open` flag. "
"This flag effect applies only to the data range written by the system call."
msgstr ""
"Надайте еквівалент для кожного запису прапора :data:`O_DSYNC` :func:`os."
"open`. Цей ефект прапора застосовується лише до діапазону даних, записаного "
"системним викликом."

msgid ":ref:`Availability <availability>`: Linux 4.7 and newer."
msgstr ":ref:`Доступність <availability>`: Linux 4.7 і новіші версії."

msgid ""
"Provide a per-write equivalent of the :data:`O_SYNC` :func:`os.open` flag. "
"This flag effect applies only to the data range written by the system call."
msgstr ""
"Надайте еквівалент для кожного запису прапора :data:`O_SYNC` :func:`os."
"open`. Цей ефект прапора застосовується лише до діапазону даних, записаного "
"системним викликом."

msgid ""
"Provide a per-write equivalent of the :data:`O_APPEND` :func:`os.open` flag. "
"This flag is meaningful only for :func:`os.pwritev`, and its effect applies "
"only to the data range written by the system call. The *offset* argument "
"does not affect the write operation; the data is always appended to the end "
"of the file. However, if the *offset* argument is ``-1``, the current file "
"*offset* is updated."
msgstr ""
"Надайте еквівалент для кожного запису прапора :data:`O_APPEND` :func:`os."
"open`. Цей прапор має значення лише для :func:`os.pwritev`, і його дія "
"стосується лише діапазону даних, записаного системним викликом. Аргумент "
"*offset* не впливає на операцію запису; дані завжди додаються в кінець "
"файлу. Однак, якщо аргумент *offset* дорівнює ``-1``, поточний файл *offset* "
"оновлюється."

msgid ":ref:`Availability <availability>`: Linux 4.16 and newer."
msgstr ":ref:`Наявність <availability>`: Linux 4.16 і новіші версії."

msgid "Read at most *n* bytes from file descriptor *fd*."
msgstr "Прочитати щонайбільше *n* байт із файлового дескриптора *fd*."

msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`pipe`.  To read a \"file "
"object\" returned by the built-in function :func:`open` or by :func:`popen` "
"or :func:`fdopen`, or :data:`sys.stdin`, use its :meth:`~file.read` or :meth:"
"`~file.readline` methods."
msgstr ""
"Ця функція призначена для низькорівневого вводу-виводу та має "
"застосовуватися до дескриптора файлу, який повертає :func:`os.open` або :"
"func:`pipe`. Щоб прочитати \"файловий об’єкт\", повернутий вбудованою "
"функцією :func:`open` або :func:`popen` або :func:`fdopen`, або :data:`sys."
"stdin`, використовуйте його :meth:`~file.read` або :meth:`~file.readline` "
"методи."

msgid ""
"Copy *count* bytes from file descriptor *in_fd* to file descriptor *out_fd* "
"starting at *offset*. Return the number of bytes sent. When EOF is reached "
"return ``0``."
msgstr ""
"Скопіюйте *count* байтів із файлового дескриптора *in_fd* до файлового "
"дескриптора *out_fd*, починаючи зі *offset*. Повертає кількість надісланих "
"байтів. Коли EOF досягнуто, повертає ``0``."

msgid ""
"The first function notation is supported by all platforms that define :func:"
"`sendfile`."
msgstr ""
"Першу нотацію функції підтримують усі платформи, які визначають :func:"
"`sendfile`."

msgid ""
"On Linux, if *offset* is given as ``None``, the bytes are read from the "
"current position of *in_fd* and the position of *in_fd* is updated."
msgstr ""
"У Linux, якщо *offset* задано як ``None``, байти зчитуються з поточної "
"позиції *in_fd*, а позиція *in_fd* оновлюється."

msgid ""
"The second case may be used on macOS and FreeBSD where *headers* and "
"*trailers* are arbitrary sequences of buffers that are written before and "
"after the data from *in_fd* is written. It returns the same as the first "
"case."
msgstr ""
"Другий випадок можна використовувати в macOS і FreeBSD, де *заголовки* і "
"*кінці* є довільними послідовностями буферів, які записуються до і після "
"запису даних з *in_fd*. Він повертає те саме, що й перший випадок."

msgid ""
"On macOS and FreeBSD, a value of ``0`` for *count* specifies to send until "
"the end of *in_fd* is reached."
msgstr ""
"У macOS і FreeBSD значення ``0`` для *count* вказує на надсилання до кінця "
"*in_fd*."

msgid ""
"All platforms support sockets as *out_fd* file descriptor, and some "
"platforms allow other types (e.g. regular file, pipe) as well."
msgstr ""
"Усі платформи підтримують сокети як файловий дескриптор *out_fd*, а деякі "
"платформи також дозволяють інші типи (наприклад, звичайний файл, канал)."

msgid ""
"Cross-platform applications should not use *headers*, *trailers* and *flags* "
"arguments."
msgstr ""
"Міжплатформні програми не повинні використовувати аргументи *headers*, "
"*trailers* і *flags*."

msgid ""
"For a higher-level wrapper of :func:`sendfile`, see :meth:`socket.socket."
"sendfile`."
msgstr ""
"Щоб отримати обгортку вищого рівня :func:`sendfile`, перегляньте :meth:"
"`socket.socket.sendfile`."

msgid "Parameters *out* and *in* was renamed to *out_fd* and *in_fd*."
msgstr "Параметри *out* і *in* перейменовано на *out_fd* і *in_fd*."

msgid ""
"Set the blocking mode of the specified file descriptor. Set the :data:"
"`O_NONBLOCK` flag if blocking is ``False``, clear the flag otherwise."
msgstr ""
"Встановити режим блокування вказаного файлового дескриптора. Установіть "
"прапорець :data:`O_NONBLOCK`, якщо блокування має значення ``False``, "
"зніміть прапорець в іншому випадку."

msgid "See also :func:`get_blocking` and :meth:`socket.socket.setblocking`."
msgstr ""
"Дивіться також :func:`get_blocking` і :meth:`socket.socket.setblocking`."

msgid ""
"Parameters to the :func:`sendfile` function, if the implementation supports "
"them."
msgstr "Параметри функції :func:`sendfile`, якщо реалізація їх підтримує."

msgid ""
"Transfer *count* bytes from file descriptor *src*, starting from offset "
"*offset_src*, to file descriptor *dst*, starting from offset *offset_dst*. "
"At least one of the file descriptors must refer to a pipe. If *offset_src* "
"is None, then *src* is read from the current position; respectively for "
"*offset_dst*. The offset associated to the file descriptor that refers to a "
"pipe must be ``None``. The files pointed by *src* and *dst* must reside in "
"the same filesystem, otherwise an :exc:`OSError` is raised with :attr:"
"`~OSError.errno` set to :data:`errno.EXDEV`."
msgstr ""
"Передайте *count* байт із файлового дескриптора *src*, починаючи зі зміщення "
"*offset_src*, до файлового дескриптора *dst*, починаючи зі зміщення "
"*offset_dst*. Принаймні один із файлових дескрипторів має посилатися на "
"канал. Якщо *offset_src* має значення None, тоді *src* читається з поточної "
"позиції; відповідно для *offset_dst*. Зміщення, пов’язане з дескриптором "
"файлу, який посилається на канал, має бути ``None``. Файли, на які вказують "
"*src* і *dst*, повинні знаходитися в одній файловій системі, інакше виникає :"
"exc:`OSError` з :attr:`~OSError.errno`, встановленим на :data:`errno.EXDEV`."

msgid ""
"Upon successful completion, returns the number of bytes spliced to or from "
"the pipe. A return value of 0 means end of input. If *src* refers to a pipe, "
"then this means that there was no data to transfer, and it would not make "
"sense to block because there are no writers connected to the write end of "
"the pipe."
msgstr ""
"Після успішного завершення повертає кількість байтів, з’єднаних із каналом "
"або з каналу. Повернене значення 0 означає кінець введення. Якщо *src* "
"посилається на канал, це означає, що не було даних для передачі, і не було б "
"сенсу блокувати, оскільки немає записувачів, підключених до кінця каналу для "
"запису."

msgid ""
":ref:`Availability <availability>`: Linux kernel >= 2.6.17 and glibc >= 2.5"
msgstr ":ref:`Доступність <availability>`: ядро Linux >= 2.6.17 і glibc >= 2.5"

msgid ""
"Read from a file descriptor *fd* into a number of mutable :term:`bytes-like "
"objects <bytes-like object>` *buffers*. Transfer data into each buffer until "
"it is full and then move on to the next buffer in the sequence to hold the "
"rest of the data."
msgstr ""
"Читання з файлового дескриптора *fd* у кілька змінних :term:`байт-подібних "
"об’єктів <bytes-like object>` *буферів*. Передайте дані в кожен буфер, доки "
"він не заповниться, а потім перейдіть до наступного буфера в послідовності, "
"щоб утримувати решту даних."

msgid ""
"Return the process group associated with the terminal given by *fd* (an open "
"file descriptor as returned by :func:`os.open`)."
msgstr ""
"Повертає групу процесів, пов’язану з терміналом, задану *fd* (дескриптор "
"відкритого файлу, який повертає :func:`os.open`)."

msgid ""
"Set the process group associated with the terminal given by *fd* (an open "
"file descriptor as returned by :func:`os.open`) to *pg*."
msgstr ""
"Встановіть групу процесів, пов’язану з терміналом, надану *fd* (дескриптор "
"відкритого файлу, який повертає :func:`os.open`), на *pg*."

msgid ""
"Return a string which specifies the terminal device associated with file "
"descriptor *fd*.  If *fd* is not associated with a terminal device, an "
"exception is raised."
msgstr ""
"Повертає рядок, який визначає термінальний пристрій, пов’язаний із файловим "
"дескриптором *fd*. Якщо *fd* не пов’язано з термінальним пристроєм, виникає "
"виняток."

msgid "Write the bytestring in *str* to file descriptor *fd*."
msgstr "Запишіть байтовий рядок у *str* до файлового дескриптора *fd*."

msgid ""
"This function is intended for low-level I/O and must be applied to a file "
"descriptor as returned by :func:`os.open` or :func:`pipe`.  To write a "
"\"file object\" returned by the built-in function :func:`open` or by :func:"
"`popen` or :func:`fdopen`, or :data:`sys.stdout` or :data:`sys.stderr`, use "
"its :meth:`~file.write` method."
msgstr ""
"Ця функція призначена для низькорівневого вводу-виводу та має "
"застосовуватися до дескриптора файлу, який повертає :func:`os.open` або :"
"func:`pipe`. Щоб записати \"файловий об’єкт\", який повертає вбудована "
"функція :func:`open` або :func:`popen` або :func:`fdopen`, або :data:`sys."
"stdout` або :data:`sys.stderr`, використовуйте його метод :meth:`~file."
"write`."

msgid ""
"Write the contents of *buffers* to file descriptor *fd*. *buffers* must be a "
"sequence of :term:`bytes-like objects <bytes-like object>`. Buffers are "
"processed in array order. Entire contents of the first buffer is written "
"before proceeding to the second, and so on."
msgstr ""
"Запишіть вміст *buffers* у файловий дескриптор *fd*. *буфери* мають бути "
"послідовністю :term:`байт-подібних об’єктів <bytes-like object>`. Буфери "
"обробляються в порядку масиву. Весь вміст першого буфера записується перед "
"переходом до другого і так далі."

msgid "Returns the total number of bytes actually written."
msgstr "Повертає загальну кількість фактично записаних байтів."

msgid "Querying the size of a terminal"
msgstr "Запит розміру терміналу"

msgid ""
"Return the size of the terminal window as ``(columns, lines)``, tuple of "
"type :class:`terminal_size`."
msgstr ""
"Повертає розмір вікна терміналу як ``(стовпці, рядки)``, кортеж типу :class:"
"`terminal_size`."

msgid ""
"The optional argument ``fd`` (default ``STDOUT_FILENO``, or standard output) "
"specifies which file descriptor should be queried."
msgstr ""
"Додатковий аргумент ``fd`` (за замовчуванням ``STDOUT_FILENO`` або "
"стандартний вивід) визначає, який дескриптор файлу слід запитувати."

msgid ""
"If the file descriptor is not connected to a terminal, an :exc:`OSError` is "
"raised."
msgstr ""
"Якщо дескриптор файлу не підключено до терміналу, виникає :exc:`OSError`."

msgid ""
":func:`shutil.get_terminal_size` is the high-level function which should "
"normally be used, ``os.get_terminal_size`` is the low-level implementation."
msgstr ""
":func:`shutil.get_terminal_size` — це функція високого рівня, яка зазвичай "
"повинна використовуватися, ``os.get_terminal_size`` — це реалізація низького "
"рівня."

msgid ""
"A subclass of tuple, holding ``(columns, lines)`` of the terminal window "
"size."
msgstr ""
"Підклас кортежу, що містить ``(стовпці, рядки)`` розміру вікна терміналу."

msgid "Width of the terminal window in characters."
msgstr "Ширина вікна терміналу в символах."

msgid "Height of the terminal window in characters."
msgstr "Висота вікна терміналу в символах."

msgid "Inheritance of File Descriptors"
msgstr "Успадкування файлових дескрипторів"

msgid ""
"A file descriptor has an \"inheritable\" flag which indicates if the file "
"descriptor can be inherited by child processes.  Since Python 3.4, file "
"descriptors created by Python are non-inheritable by default."
msgstr ""
"Файловий дескриптор має позначку \"успадковуваний\", яка вказує, чи може "
"файловий дескриптор успадковуватися дочірніми процесами. Починаючи з Python "
"3.4, дескриптори файлів, створені Python, за замовчуванням не успадковуються."

msgid ""
"On UNIX, non-inheritable file descriptors are closed in child processes at "
"the execution of a new program, other file descriptors are inherited."
msgstr ""
"В UNIX неуспадковані файлові дескриптори закриваються в дочірніх процесах "
"під час виконання нової програми, інші файлові дескриптори успадковуються."

msgid ""
"On Windows, non-inheritable handles and file descriptors are closed in child "
"processes, except for standard streams (file descriptors 0, 1 and 2: stdin, "
"stdout and stderr), which are always inherited.  Using :func:`spawn\\* "
"<spawnl>` functions, all inheritable handles and all inheritable file "
"descriptors are inherited. Using the :mod:`subprocess` module, all file "
"descriptors except standard streams are closed, and inheritable handles are "
"only inherited if the *close_fds* parameter is ``False``."
msgstr ""
"У Windows неуспадковані дескриптори та дескриптори файлів закриті в дочірніх "
"процесах, за винятком стандартних потоків (дескриптори файлів 0, 1 і 2: "
"stdin, stdout і stderr), які завжди успадковуються. За допомогою функцій :"
"func:`spawn\\* <spawnl>` успадковуються всі успадковані маркери та всі "
"успадковані дескриптори файлів. За допомогою модуля :mod:`subprocess` усі "
"файлові дескриптори, крім стандартних потоків, закриваються, а успадковані "
"дескриптори успадковуються, лише якщо параметр *close_fds* має значення "
"``False``."

msgid ""
"Get the \"inheritable\" flag of the specified file descriptor (a boolean)."
msgstr ""
"Отримайте позначку \"успадкований\" зазначеного файлового дескриптора "
"(логічне значення)."

msgid "Set the \"inheritable\" flag of the specified file descriptor."
msgstr ""
"Встановіть прапорець \"успадкований\" для зазначеного файлового дескриптора."

msgid "Get the \"inheritable\" flag of the specified handle (a boolean)."
msgstr ""
"Отримайте прапор \"успадкований\" зазначеного маркера (логічне значення)."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid "Set the \"inheritable\" flag of the specified handle."
msgstr "Встановіть прапорець \"успадкований\" для вказаного маркера."

msgid "Files and Directories"
msgstr "Файли та каталоги"

msgid ""
"On some Unix platforms, many of these functions support one or more of these "
"features:"
msgstr ""
"На деяких платформах Unix багато з цих функцій підтримують одну або кілька "
"таких функцій:"

msgid ""
"**specifying a file descriptor:** Normally the *path* argument provided to "
"functions in the :mod:`os` module must be a string specifying a file path.  "
"However, some functions now alternatively accept an open file descriptor for "
"their *path* argument. The function will then operate on the file referred "
"to by the descriptor. (For POSIX systems, Python will call the variant of "
"the function prefixed with ``f`` (e.g. call ``fchdir`` instead of "
"``chdir``).)"
msgstr ""
"**зазначення дескриптора файлу:** Зазвичай аргумент *path*, який надається "
"функціям у модулі :mod:`os`, має бути рядком, що вказує шлях до файлу. Однак "
"деякі функції тепер альтернативно приймають дескриптор відкритого файлу для "
"свого аргументу *path*. Потім функція працюватиме з файлом, на який "
"посилається дескриптор. (Для систем POSIX Python викличе варіант функції з "
"префіксом ``f`` (наприклад, виклик ``fchdir`` замість ``chdir``).)"

msgid ""
"You can check whether or not *path* can be specified as a file descriptor "
"for a particular function on your platform using :data:`os.supports_fd`. If "
"this functionality is unavailable, using it will raise a :exc:"
"`NotImplementedError`."
msgstr ""
"Ви можете перевірити, чи можна вказати *шлях* як дескриптор файлу для певної "
"функції на вашій платформі за допомогою :data:`os.supports_fd`. Якщо ця "
"функція недоступна, її використання призведе до помилки :exc:"
"`NotImplementedError`."

msgid ""
"If the function also supports *dir_fd* or *follow_symlinks* arguments, it's "
"an error to specify one of those when supplying *path* as a file descriptor."
msgstr ""
"Якщо функція також підтримує аргументи *dir_fd* або *follow_symlinks*, буде "
"помилкою вказати один із них під час надання *шляху* як дескриптора файлу."

msgid ""
"**paths relative to directory descriptors:** If *dir_fd* is not ``None``, it "
"should be a file descriptor referring to a directory, and the path to "
"operate on should be relative; path will then be relative to that "
"directory.  If the path is absolute, *dir_fd* is ignored.  (For POSIX "
"systems, Python will call the variant of the function with an ``at`` suffix "
"and possibly prefixed with ``f`` (e.g. call ``faccessat`` instead of "
"``access``)."
msgstr ""
"**шляхи відносно дескрипторів каталогу:** Якщо *dir_fd* не є ``None``, це "
"має бути дескриптор файлу, який посилається на каталог, а шлях для роботи "
"має бути відносним; тоді шлях буде відносним до цього каталогу. Якщо шлях "
"абсолютний, *dir_fd* ігнорується. (Для систем POSIX Python викличе варіант "
"функції з суфіксом ``at`` і, можливо, з префіксом ``f`` (наприклад, виклик "
"``faccessat`` замість ``access``)."

msgid ""
"You can check whether or not *dir_fd* is supported for a particular function "
"on your platform using :data:`os.supports_dir_fd`.  If it's unavailable, "
"using it will raise a :exc:`NotImplementedError`."
msgstr ""
"Ви можете перевірити, чи підтримується *dir_fd* для певної функції на вашій "
"платформі за допомогою :data:`os.supports_dir_fd`. Якщо він недоступний, "
"його використання призведе до помилки :exc:`NotImplementedError`."

msgid ""
"**not following symlinks:** If *follow_symlinks* is ``False``, and the last "
"element of the path to operate on is a symbolic link, the function will "
"operate on the symbolic link itself rather than the file pointed to by the "
"link.  (For POSIX systems, Python will call the ``l...`` variant of the "
"function.)"
msgstr ""
"**не слідувати за символічними посиланнями:** Якщо *follow_symlinks* має "
"значення ``False``, а останнім елементом шляху, з яким потрібно працювати, є "
"символьне посилання, функція працюватиме з самим символічним посиланням, а "
"не з файлом, на який вказує посилання. (Для систем POSIX Python викличе "
"варіант функції ``l...``.)"

msgid ""
"You can check whether or not *follow_symlinks* is supported for a particular "
"function on your platform using :data:`os.supports_follow_symlinks`. If it's "
"unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
"Ви можете перевірити, чи підтримується *follow_symlinks* для певної функції "
"на вашій платформі, використовуючи :data:`os.supports_follow_symlinks`. Якщо "
"він недоступний, його використання викличе :exc:`NotImplementedError`."

msgid ""
"Use the real uid/gid to test for access to *path*.  Note that most "
"operations will use the effective uid/gid, therefore this routine can be "
"used in a suid/sgid environment to test if the invoking user has the "
"specified access to *path*.  *mode* should be :const:`F_OK` to test the "
"existence of *path*, or it can be the inclusive OR of one or more of :const:"
"`R_OK`, :const:`W_OK`, and :const:`X_OK` to test permissions.  Return :const:"
"`True` if access is allowed, :const:`False` if not. See the Unix man page :"
"manpage:`access(2)` for more information."
msgstr ""
"Використовуйте справжній uid/gid, щоб перевірити доступ до *шляху*. "
"Зауважте, що більшість операцій використовуватиме ефективний uid/gid, тому "
"цю підпрограму можна використовувати в середовищі suid/sgid, щоб перевірити, "
"чи має користувач, який викликає, вказаний доступ до *path*. *режим* має "
"бути :const:`F_OK`, щоб перевірити існування *шляху*, або він може бути "
"включним АБО одного чи кількох :const:`R_OK`, :const:`W_OK` і :const:`X_OK`, "
"щоб перевірити дозволи. Повертає :const:`True`, якщо доступ дозволено, :"
"const:`False`, якщо ні. Додаткову інформацію див. на сторінці довідки Unix :"
"manpage:`access(2)`."

msgid ""
"This function can support specifying :ref:`paths relative to directory "
"descriptors <dir_fd>` and :ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"Ця функція може підтримувати вказівку :ref:`шляхів відносно дескрипторів "
"каталогу <dir_fd>` і :ref:`не слідувати символічним посиланням "
"<follow_symlinks>`."

msgid ""
"If *effective_ids* is ``True``, :func:`access` will perform its access "
"checks using the effective uid/gid instead of the real uid/gid. "
"*effective_ids* may not be supported on your platform; you can check whether "
"or not it is available using :data:`os.supports_effective_ids`.  If it is "
"unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
"Якщо *effective_ids* має значення ``True``, :func:`access` виконуватиме "
"перевірку доступу, використовуючи ефективний uid/gid замість справжнього uid/"
"gid. *effective_ids* може не підтримуватися на вашій платформі; ви можете "
"перевірити, чи він доступний, за допомогою :data:`os."
"supports_effective_ids`. Якщо він недоступний, його використання призведе до "
"помилки :exc:`NotImplementedError`."

msgid ""
"Using :func:`access` to check if a user is authorized to e.g. open a file "
"before actually doing so using :func:`open` creates a security hole, because "
"the user might exploit the short time interval between checking and opening "
"the file to manipulate it. It's preferable to use :term:`EAFP` techniques. "
"For example::"
msgstr ""
"Використовуючи :func:`access`, щоб перевірити, чи має користувач право, "
"наприклад, відкрити файл перед тим, як це зробити за допомогою :func:`open` "
"створює діру в безпеці, тому що користувач може використати короткий "
"проміжок часу між перевіркою та відкриттям файлу, щоб маніпулювати ним. "
"Бажано використовувати техніку :term:`EAFP`. Наприклад::"

msgid "is better written as::"
msgstr "краще записати як::"

msgid ""
"I/O operations may fail even when :func:`access` indicates that they would "
"succeed, particularly for operations on network filesystems which may have "
"permissions semantics beyond the usual POSIX permission-bit model."
msgstr ""
"Операції вводу/виводу можуть завершуватися невдачею, навіть якщо :func:"
"`access` вказує, що вони будуть успішними, особливо для операцій у мережевих "
"файлових системах, які можуть мати семантику дозволів за межами звичайної "
"бітової моделі дозволів POSIX."

msgid "Added the *dir_fd*, *effective_ids*, and *follow_symlinks* parameters."
msgstr "Додано параметри *dir_fd*, *effective_ids* і *follow_symlinks*."

msgid ""
"Values to pass as the *mode* parameter of :func:`access` to test the "
"existence, readability, writability and executability of *path*, "
"respectively."
msgstr ""
"Значення, які потрібно передавати як параметр *mode* :func:`access`, щоб "
"перевірити наявність, читабельність, запис і можливість виконання *path* "
"відповідно."

msgid "Change the current working directory to *path*."
msgstr "Змініть поточний робочий каталог на *шлях*."

msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`.  "
"The descriptor must refer to an opened directory, not an open file."
msgstr ""
"Ця функція може підтримувати :ref:`зазначення файлового дескриптора "
"<path_fd>`. Дескриптор має посилатися на відкритий каталог, а не на "
"відкритий файл."

msgid ""
"This function can raise :exc:`OSError` and subclasses such as :exc:"
"`FileNotFoundError`, :exc:`PermissionError`, and :exc:`NotADirectoryError`."
msgstr ""
"Ця функція може викликати :exc:`OSError` і підкласи, такі як :exc:"
"`FileNotFoundError`, :exc:`PermissionError` і :exc:`NotADirectoryError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chdir`` with argument "
"``path``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.chdir`` з аргументом ``path``."

msgid ""
"Added support for specifying *path* as a file descriptor on some platforms."
msgstr ""
"Додано підтримку вказівки *шляху* як дескриптора файлу на деяких платформах."

msgid ""
"Set the flags of *path* to the numeric *flags*. *flags* may take a "
"combination (bitwise OR) of the following values (as defined in the :mod:"
"`stat` module):"
msgstr ""
"Встановіть прапорці *шляху* на числові *прапорці*. *flags* може приймати "
"комбінацію (порозрядне АБО) таких значень (як визначено в модулі :mod:"
"`stat`):"

msgid ":data:`stat.UF_NODUMP`"
msgstr ":data:`stat.UF_NODUMP`"

msgid ":data:`stat.UF_IMMUTABLE`"
msgstr ":data:`stat.UF_IMMUTABLE`"

msgid ":data:`stat.UF_APPEND`"
msgstr ":data:`stat.UF_APPEND`"

msgid ":data:`stat.UF_OPAQUE`"
msgstr ":data:`stat.UF_OPAQUE`"

msgid ":data:`stat.UF_NOUNLINK`"
msgstr ":data:`stat.UF_NOUNLINK`"

msgid ":data:`stat.UF_COMPRESSED`"
msgstr ":data:`stat.UF_COMPRESSED`"

msgid ":data:`stat.UF_HIDDEN`"
msgstr ":data:`stat.UF_HIDDEN`"

msgid ":data:`stat.SF_ARCHIVED`"
msgstr ":data:`stat.SF_ARCHIVED`"

msgid ":data:`stat.SF_IMMUTABLE`"
msgstr ":data:`stat.SF_IMMUTABLE`"

msgid ":data:`stat.SF_APPEND`"
msgstr ":data:`stat.SF_APPEND`"

msgid ":data:`stat.SF_NOUNLINK`"
msgstr ":data:`stat.SF_NOUNLINK`"

msgid ":data:`stat.SF_SNAPSHOT`"
msgstr ":data:`stat.SF_SNAPSHOT`"

msgid ""
"This function can support :ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"Ця функція підтримує :ref:`неперехід за символічними посиланнями "
"<follow_symlinks>`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chflags`` with arguments "
"``path``, ``flags``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.chflags`` з аргументами "
"``path``, ``flags``."

msgid "The *follow_symlinks* argument."
msgstr "Аргумент *follow_symlinks*."

msgid ""
"Change the mode of *path* to the numeric *mode*. *mode* may take one of the "
"following values (as defined in the :mod:`stat` module) or bitwise ORed "
"combinations of them:"
msgstr ""
"Змініть режим *шляху* на числовий *режим*. *mode* може приймати одне з "
"наступних значень (як визначено в модулі :mod:`stat`) або їх комбінації "
"порозрядними АБО:"

msgid ":data:`stat.S_ISUID`"
msgstr ":data:`stat.S_ISUID`"

msgid ":data:`stat.S_ISGID`"
msgstr ":data:`stat.S_ISGID`"

msgid ":data:`stat.S_ENFMT`"
msgstr ":data:`stat.S_ENFMT`"

msgid ":data:`stat.S_ISVTX`"
msgstr ":data:`stat.S_ISVTX`"

msgid ":data:`stat.S_IREAD`"
msgstr ":data:`stat.S_IREAD`"

msgid ":data:`stat.S_IWRITE`"
msgstr ":data:`stat.S_IWRITE`"

msgid ":data:`stat.S_IEXEC`"
msgstr ":data:`stat.S_IEXEC`"

msgid ":data:`stat.S_IRWXU`"
msgstr ":data:`stat.S_IRWXU`"

msgid ":data:`stat.S_IRUSR`"
msgstr ":data:`stat.S_IRUSR`"

msgid ":data:`stat.S_IWUSR`"
msgstr ":data:`stat.S_IWUSR`"

msgid ":data:`stat.S_IXUSR`"
msgstr ":data:`stat.S_IXUSR`"

msgid ":data:`stat.S_IRWXG`"
msgstr ":data:`stat.S_IRWXG`"

msgid ":data:`stat.S_IRGRP`"
msgstr ":data:`stat.S_IRGRP`"

msgid ":data:`stat.S_IWGRP`"
msgstr ":data:`stat.S_IWGRP`"

msgid ":data:`stat.S_IXGRP`"
msgstr ":data:`stat.S_IXGRP`"

msgid ":data:`stat.S_IRWXO`"
msgstr ":data:`stat.S_IRWXO`"

msgid ":data:`stat.S_IROTH`"
msgstr ":data:`stat.S_IROTH`"

msgid ":data:`stat.S_IWOTH`"
msgstr ":data:`stat.S_IWOTH`"

msgid ":data:`stat.S_IXOTH`"
msgstr ":data:`stat.S_IXOTH`"

msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`, :"
"ref:`paths relative to directory descriptors <dir_fd>` and :ref:`not "
"following symlinks <follow_symlinks>`."
msgstr ""
"Ця функція може підтримувати :ref:`зазначення дескриптора файлу <path_fd>`, :"
"ref:`шляхи відносно дескрипторів каталогу <dir_fd>` та :ref:`неперехід за "
"символічними посиланнями <follow_symlinks>`."

msgid ""
"Although Windows supports :func:`chmod`, you can only set the file's read-"
"only flag with it (via the ``stat.S_IWRITE`` and ``stat.S_IREAD`` constants "
"or a corresponding integer value).  All other bits are ignored."
msgstr ""
"Незважаючи на те, що Windows підтримує :func:`chmod`, ви можете встановити "
"для файлу позначку лише для читання (через константи ``stat.S_IWRITE`` і "
"``stat.S_IREAD`` або відповідне ціле значення). Усі інші біти ігноруються."

msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd* and *follow_symlinks* arguments."
msgstr ""
"Додано підтримку вказівки *шляху* як дескриптора відкритого файлу, а також "
"аргументів *dir_fd* і *follow_symlinks*."

msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  To "
"leave one of the ids unchanged, set it to -1."
msgstr ""
"Змініть власника та ідентифікатор групи *path* на числові *uid* і *gid*. Щоб "
"залишити один із ідентифікаторів без змін, встановіть для нього значення -1."

msgid ""
"See :func:`shutil.chown` for a higher-level function that accepts names in "
"addition to numeric ids."
msgstr ""
"Перегляньте :func:`shutil.chown` для функції вищого рівня, яка приймає імена "
"на додаток до числових ідентифікаторів."

msgid "Supports a :term:`path-like object`."
msgstr "Підтримує :term:`path-like object`."

msgid "Change the root directory of the current process to *path*."
msgstr "Змініть кореневий каталог поточного процесу на *шлях*."

msgid ""
"Change the current working directory to the directory represented by the "
"file descriptor *fd*.  The descriptor must refer to an opened directory, not "
"an open file.  As of Python 3.3, this is equivalent to ``os.chdir(fd)``."
msgstr ""
"Змініть поточний робочий каталог на каталог, представлений дескриптором "
"файлу *fd*. Дескриптор має посилатися на відкритий каталог, а не на "
"відкритий файл. Починаючи з Python 3.3, це еквівалентно ``os.chdir(fd)``."

msgid "Return a string representing the current working directory."
msgstr "Повертає рядок, що представляє поточний робочий каталог."

msgid "Return a bytestring representing the current working directory."
msgstr "Повертає байтовий рядок, що представляє поточний робочий каталог."

msgid ""
"The function now uses the UTF-8 encoding on Windows, rather than the ANSI "
"code page: see :pep:`529` for the rationale. The function is no longer "
"deprecated on Windows."
msgstr ""
"Функція тепер використовує кодування UTF-8 у Windows, а не кодову сторінку "
"ANSI: див. :pep:`529` для обґрунтування. Ця функція більше не підтримується "
"в Windows."

msgid ""
"Set the flags of *path* to the numeric *flags*, like :func:`chflags`, but do "
"not follow symbolic links.  As of Python 3.3, this is equivalent to ``os."
"chflags(path, flags, follow_symlinks=False)``."
msgstr ""
"Встановіть прапорці *path* на числові *flags*, наприклад :func:`chflags`, "
"але не переходьте за символічними посиланнями. Починаючи з Python 3.3, це "
"еквівалентно ``os.chflags(path, flags, follow_symlinks=False)``."

msgid ""
"Change the mode of *path* to the numeric *mode*. If path is a symlink, this "
"affects the symlink rather than the target.  See the docs for :func:`chmod` "
"for possible values of *mode*.  As of Python 3.3, this is equivalent to ``os."
"chmod(path, mode, follow_symlinks=False)``."
msgstr ""
"Змініть режим *шляху* на числовий *режим*. Якщо шлях є символічним "
"посиланням, це впливає на символічне посилання, а не на ціль. Перегляньте "
"документацію для :func:`chmod`, щоб дізнатися про можливі значення *mode*. "
"Починаючи з Python 3.3, це еквівалентно ``os.chmod(path, mode, "
"follow_symlinks=False)``."

msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  "
"This function will not follow symbolic links.  As of Python 3.3, this is "
"equivalent to ``os.chown(path, uid, gid, follow_symlinks=False)``."
msgstr ""
"Змініть власника та ідентифікатор групи *path* на числові *uid* і *gid*. Ця "
"функція не переходитиме за символічними посиланнями. Починаючи з Python 3.3, "
"це еквівалентно ``os.chown(path, uid, gid, follow_symlinks=False)``."

msgid "Create a hard link pointing to *src* named *dst*."
msgstr "Створіть жорстке посилання на *src* під назвою *dst*."

msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`, and :ref:"
"`not following symlinks <follow_symlinks>`."
msgstr ""
"Ця функція може підтримувати вказівку *src_dir_fd* та/або *dst_dir_fd* для "
"надання :ref:`шляхів відносно дескрипторів каталогу <dir_fd>`, і :ref:`не "
"слідування за символічними посиланнями <follow_symlinks>`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.link`` with arguments "
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.link`` з аргументами ``src``, "
"``dst``, ``src_dir_fd``, ``dst_dir_fd``."

msgid "Added Windows support."
msgstr "Додана підтримка Windows."

msgid "Added the *src_dir_fd*, *dst_dir_fd*, and *follow_symlinks* arguments."
msgstr "Додано аргументи *src_dir_fd*, *dst_dir_fd* і *follow_symlinks*."

msgid "Accepts a :term:`path-like object` for *src* and *dst*."
msgstr "Приймає :term:`path-like object` для *src* і *dst*."

msgid ""
"Return a list containing the names of the entries in the directory given by "
"*path*.  The list is in arbitrary order, and does not include the special "
"entries ``'.'`` and ``'..'`` even if they are present in the directory. If a "
"file is removed from or added to the directory during the call of this "
"function, whether a name for that file be included is unspecified."
msgstr ""
"Повертає список, що містить імена записів у каталозі, заданому *шляхом*. "
"Список розташований у довільному порядку й не містить спеціальних записів "
"``'.''`` і ``'..''``, навіть якщо вони присутні в каталозі. Якщо файл "
"видалено з каталогу або додано до нього під час виклику цієї функції, не "
"вказано, чи буде включено ім’я цього файлу."

msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes`` "
"(directly or indirectly through the :class:`PathLike` interface), the "
"filenames returned will also be of type ``bytes``; in all other "
"circumstances, they will be of type ``str``."
msgstr ""
"*path* може бути :term:`path-like object`. Якщо *path* має тип ``bytes`` "
"(прямо чи опосередковано через інтерфейс :class:`PathLike`), повернуті імена "
"файлів також будуть типу ``bytes``; за всіх інших обставин вони будуть типу "
"``str``."

msgid ""
"This function can also support :ref:`specifying a file descriptor "
"<path_fd>`; the file descriptor must refer to a directory."
msgstr ""
"Ця функція також може підтримувати :ref:`зазначення файлового дескриптора "
"<path_fd>`; дескриптор файлу повинен посилатися на каталог."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listdir`` with argument "
"``path``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.listdir`` з аргументом ``path``."

msgid "To encode ``str`` filenames to ``bytes``, use :func:`~os.fsencode`."
msgstr ""
"Щоб закодувати ``str`` імена файлів у ``байти``, використовуйте :func:`~os."
"fsencode`."

msgid ""
"The :func:`scandir` function returns directory entries along with file "
"attribute information, giving better performance for many common use cases."
msgstr ""
"Функція :func:`scandir` повертає записи каталогу разом із інформацією про "
"атрибути файлів, забезпечуючи кращу продуктивність у багатьох поширених "
"випадках використання."

msgid "The *path* parameter became optional."
msgstr "Параметр *path* став необов'язковим."

msgid "Added support for specifying *path* as an open file descriptor."
msgstr "Додано підтримку вказівки *шляху* як дескриптора відкритого файлу."

msgid ""
"Perform the equivalent of an :c:func:`lstat` system call on the given path. "
"Similar to :func:`~os.stat`, but does not follow symbolic links. Return a :"
"class:`stat_result` object."
msgstr ""
"Виконайте еквівалент системного виклику :c:func:`lstat` на вказаному шляху. "
"Подібно до :func:`~os.stat`, але не переходить за символічними посиланнями. "
"Повертає об’єкт :class:`stat_result`."

msgid ""
"On platforms that do not support symbolic links, this is an alias for :func:"
"`~os.stat`."
msgstr ""
"На платформах, які не підтримують символічні посилання, це псевдонім для :"
"func:`~os.stat`."

msgid ""
"As of Python 3.3, this is equivalent to ``os.stat(path, dir_fd=dir_fd, "
"follow_symlinks=False)``."
msgstr ""
"Починаючи з Python 3.3, це еквівалентно ``os.stat(path, dir_fd=dir_fd, "
"follow_symlinks=False)``."

msgid ""
"This function can also support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Ця функція також може підтримувати :ref:`шляхи відносно дескрипторів "
"каталогу <dir_fd>`."

msgid "Added support for Windows 6.0 (Vista) symbolic links."
msgstr "Додано підтримку символічних посилань Windows 6.0 (Vista)."

msgid "Added the *dir_fd* parameter."
msgstr "Додано параметр *dir_fd*."

msgid ""
"On Windows, now opens reparse points that represent another path (name "
"surrogates), including symbolic links and directory junctions. Other kinds "
"of reparse points are resolved by the operating system as for :func:`~os."
"stat`."
msgstr ""
"У Windows тепер відкриваються точки повторного аналізу, які представляють "
"інший шлях (сурогати імен), включаючи символічні посилання та з’єднання "
"каталогів. Інші типи точок повторного аналізу вирішуються операційною "
"системою як для :func:`~os.stat`."

msgid "Create a directory named *path* with numeric mode *mode*."
msgstr "Створіть каталог під назвою *path* із числовим режимом *mode*."

msgid ""
"If the directory already exists, :exc:`FileExistsError` is raised. If a "
"parent directory in the path does not exist, :exc:`FileNotFoundError` is "
"raised."
msgstr ""
"Якщо каталог уже існує, виникає :exc:`FileExistsError`. Якщо батьківський "
"каталог у шляху не існує, виникає :exc:`FileNotFoundError`."

msgid ""
"On some systems, *mode* is ignored.  Where it is used, the current umask "
"value is first masked out.  If bits other than the last 9 (i.e. the last 3 "
"digits of the octal representation of the *mode*) are set, their meaning is "
"platform-dependent.  On some platforms, they are ignored and you should "
"call :func:`chmod` explicitly to set them."
msgstr ""
"У деяких системах *режим* ігнорується. Там, де воно використовується, "
"поточне значення umask спочатку маскується. Якщо встановлено інші біти, ніж "
"останні 9 (тобто останні 3 цифри вісімкового представлення *режиму*), їхнє "
"значення залежить від платформи. На деяких платформах вони ігноруються, і "
"вам слід явно викликати :func:`chmod`, щоб встановити їх."

msgid ""
"It is also possible to create temporary directories; see the :mod:`tempfile` "
"module's :func:`tempfile.mkdtemp` function."
msgstr ""
"Також є можливість створювати тимчасові каталоги; подивіться функцію :func:"
"`tempfile.mkdtemp` модуля :mod:`tempfile`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.mkdir`` with arguments "
"``path``, ``mode``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.mkdir`` з аргументами ``path``, "
"``mode``, ``dir_fd``."

msgid ""
"Recursive directory creation function.  Like :func:`mkdir`, but makes all "
"intermediate-level directories needed to contain the leaf directory."
msgstr ""
"Функція рекурсивного створення каталогу. Подібно до :func:`mkdir`, але "
"створює всі каталоги середнього рівня, необхідні для того, щоб містити "
"кінцевий каталог."

msgid ""
"The *mode* parameter is passed to :func:`mkdir` for creating the leaf "
"directory; see :ref:`the mkdir() description <mkdir_modebits>` for how it is "
"interpreted.  To set the file permission bits of any newly-created parent "
"directories you can set the umask before invoking :func:`makedirs`.  The "
"file permission bits of existing parent directories are not changed."
msgstr ""
"Параметр *mode* передається в :func:`mkdir` для створення кінцевого "
"каталогу; див. :ref:`опис mkdir() <mkdir_modebits>` для того, як це "
"інтерпретується. Щоб установити біти прав доступу до будь-яких новостворених "
"батьківських каталогів, ви можете встановити umask перед викликом :func:"
"`makedirs`. Біти дозволів файлів існуючих батьківських каталогів не "
"змінюються."

msgid ""
"If *exist_ok* is ``False`` (the default), an :exc:`FileExistsError` is "
"raised if the target directory already exists."
msgstr ""

msgid ""
":func:`makedirs` will become confused if the path elements to create "
"include :data:`pardir` (eg. \"..\" on UNIX systems)."
msgstr ""
":func:`makedirs` заплутає, якщо елементи шляху, які потрібно створити, "
"включають :data:`pardir` (наприклад, \"..\" у системах UNIX)."

msgid "This function handles UNC paths correctly."
msgstr "Ця функція правильно обробляє шляхи UNC."

msgid "The *exist_ok* parameter."
msgstr "Параметр *exist_ok*."

msgid ""
"Before Python 3.4.1, if *exist_ok* was ``True`` and the directory existed, :"
"func:`makedirs` would still raise an error if *mode* did not match the mode "
"of the existing directory. Since this behavior was impossible to implement "
"safely, it was removed in Python 3.4.1. See :issue:`21082`."
msgstr ""
"До Python 3.4.1, якщо *exist_ok* було ``True`` і каталог існував, :func:"
"`makedirs` все одно викликав помилку, якщо *mode* не відповідав режиму "
"існуючого каталогу. Оскільки таку поведінку було неможливо реалізувати "
"безпечно, її було видалено в Python 3.4.1. Див. :issue:`21082`."

msgid ""
"The *mode* argument no longer affects the file permission bits of newly-"
"created intermediate-level directories."
msgstr ""
"Аргумент *mode* більше не впливає на біти дозволів файлів новостворених "
"каталогів проміжного рівня."

msgid ""
"Create a FIFO (a named pipe) named *path* with numeric mode *mode*. The "
"current umask value is first masked out from the mode."
msgstr ""
"Створіть FIFO (іменований канал) під назвою *path* із числовим режимом "
"*mode*. Поточне значення umask спочатку маскується з режиму."

msgid ""
"FIFOs are pipes that can be accessed like regular files.  FIFOs exist until "
"they are deleted (for example with :func:`os.unlink`). Generally, FIFOs are "
"used as rendezvous between \"client\" and \"server\" type processes: the "
"server opens the FIFO for reading, and the client opens it for writing.  "
"Note that :func:`mkfifo` doesn't open the FIFO --- it just creates the "
"rendezvous point."
msgstr ""
"FIFO — це канали, до яких можна отримати доступ, як до звичайних файлів. "
"FIFO існують, доки їх не буде видалено (наприклад, за допомогою :func:`os."
"unlink`). Зазвичай FIFO використовуються як місце зустрічі між процесами "
"типу \"клієнт\" і \"сервер\": сервер відкриває FIFO для читання, а клієнт "
"відкриває його для запису. Зверніть увагу, що :func:`mkfifo` не відкриває "
"FIFO --- він лише створює точку зустрічі."

msgid ""
"Create a filesystem node (file, device special file or named pipe) named "
"*path*. *mode* specifies both the permissions to use and the type of node to "
"be created, being combined (bitwise OR) with one of ``stat.S_IFREG``, ``stat."
"S_IFCHR``, ``stat.S_IFBLK``, and ``stat.S_IFIFO`` (those constants are "
"available in :mod:`stat`).  For ``stat.S_IFCHR`` and ``stat.S_IFBLK``, "
"*device* defines the newly created device special file (probably using :func:"
"`os.makedev`), otherwise it is ignored."
msgstr ""
"Створіть вузол файлової системи (файл, спеціальний файл пристрою або "
"іменований канал) під назвою *шлях*. *mode* визначає як дозволи для "
"використання, так і тип вузла, який буде створено, поєднуючись (побітове "
"АБО) з одним із ``stat.S_IFREG``, ``stat.S_IFCHR``, ``stat.S_IFBLK`` і "
"``stat.S_IFIFO`` (ці константи доступні в :mod:`stat`). Для ``stat.S_IFCHR`` "
"і ``stat.S_IFBLK`` *device* визначає щойно створений спеціальний файл "
"пристрою (імовірно, використовуючи :func:`os.makedev`), інакше він "
"ігнорується."

msgid ""
"Extract the device major number from a raw device number (usually the :attr:"
"`st_dev` or :attr:`st_rdev` field from :c:type:`stat`)."
msgstr ""
"Витягніть основний номер пристрою з необробленого номера пристрою (зазвичай "
"це поле :attr:`st_dev` або :attr:`st_rdev` з :c:type:`stat`)."

msgid ""
"Extract the device minor number from a raw device number (usually the :attr:"
"`st_dev` or :attr:`st_rdev` field from :c:type:`stat`)."
msgstr ""
"Витягніть другорядний номер пристрою з необробленого номера пристрою "
"(зазвичай це поле :attr:`st_dev` або :attr:`st_rdev` з :c:type:`stat`)."

msgid "Compose a raw device number from the major and minor device numbers."
msgstr ""
"Складіть необроблений номер пристрою з головного та другорядного номерів "
"пристроїв."

msgid ""
"Return system configuration information relevant to a named file. *name* "
"specifies the configuration value to retrieve; it may be a string which is "
"the name of a defined system value; these names are specified in a number of "
"standards (POSIX.1, Unix 95, Unix 98, and others).  Some platforms define "
"additional names as well.  The names known to the host operating system are "
"given in the ``pathconf_names`` dictionary.  For configuration variables not "
"included in that mapping, passing an integer for *name* is also accepted."
msgstr ""
"Повертає інформацію про конфігурацію системи, що стосується названого файлу. "
"*name* вказує значення конфігурації для отримання; це може бути рядок, який "
"є назвою визначеного системного значення; ці назви вказані в ряді стандартів "
"(POSIX.1, Unix 95, Unix 98 та інші). Деякі платформи також визначають "
"додаткові імена. Імена, відомі головній операційній системі, наведено у "
"словнику ``pathconf_names``. Для змінних конфігурації, не включених до цього "
"відображення, також допускається передача цілого числа для *name*."

msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`."
msgstr ""
"Ця функція може підтримувати :ref:`зазначення файлового дескриптора "
"<path_fd>`."

msgid ""
"Dictionary mapping names accepted by :func:`pathconf` and :func:`fpathconf` "
"to the integer values defined for those names by the host operating system.  "
"This can be used to determine the set of names known to the system."
msgstr ""
"Словник зіставляє імена, прийняті :func:`pathconf` і :func:`fpathconf` до "
"цілих значень, визначених для цих імен головною операційною системою. Це "
"можна використовувати для визначення набору імен, відомих системі."

msgid ""
"Return a string representing the path to which the symbolic link points.  "
"The result may be either an absolute or relative pathname; if it is "
"relative, it may be converted to an absolute pathname using ``os.path."
"join(os.path.dirname(path), result)``."
msgstr ""
"Повертає рядок, що представляє шлях, на який вказує символічне посилання. "
"Результатом може бути абсолютний або відносний шлях; якщо він відносний, "
"його можна перетворити на абсолютний шлях за допомогою ``os.path.join(os."
"path.dirname(path), result)``."

msgid ""
"If the *path* is a string object (directly or indirectly through a :class:"
"`PathLike` interface), the result will also be a string object, and the call "
"may raise a UnicodeDecodeError. If the *path* is a bytes object (direct or "
"indirectly), the result will be a bytes object."
msgstr ""
"Якщо *шлях* є рядковим об’єктом (прямо чи опосередковано через інтерфейс :"
"class:`PathLike`), результат також буде рядковим об’єктом, і виклик може "
"викликати UnicodeDecodeError. Якщо *шлях* є об’єктом bytes (прямим чи "
"опосередкованим), результатом буде об’єкт bytes."

msgid ""
"When trying to resolve a path that may contain links, use :func:`~os.path."
"realpath` to properly handle recursion and platform differences."
msgstr ""
"Під час спроби визначити шлях, який може містити посилання, використовуйте :"
"func:`~os.path.realpath` для належної обробки рекурсії та відмінностей "
"платформи."

msgid "Accepts a :term:`path-like object` on Unix."
msgstr "Приймає :term:`path-like object` в Unix."

msgid "Accepts a :term:`path-like object` and a bytes object on Windows."
msgstr "Приймає :term:`path-like object` і об’єкт bytes у Windows."

msgid ""
"Added support for directory junctions, and changed to return the "
"substitution path (which typically includes ``\\\\?\\`` prefix) rather than "
"the optional \"print name\" field that was previously returned."
msgstr ""
"Додано підтримку для з’єднань каталогів і змінено, щоб повертати шлях "
"підстановки (який зазвичай включає префікс ``\\\\?\\``), а не необов’язкове "
"поле \"назви для друку\", яке поверталося раніше."

msgid ""
"Remove (delete) the file *path*.  If *path* is a directory, an :exc:"
"`IsADirectoryError` is raised.  Use :func:`rmdir` to remove directories. If "
"the file does not exist, a :exc:`FileNotFoundError` is raised."
msgstr ""
"Видалити (видалити) *шлях* до файлу. Якщо *path* є каталогом, виникає "
"помилка :exc:`IsADirectoryError`. Використовуйте :func:`rmdir` для видалення "
"каталогів. Якщо файл не існує, виникає помилка :exc:`FileNotFoundError`."

msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Ця функція може підтримувати :ref:`шляхи відносно дескрипторів каталогу "
"<dir_fd>`."

msgid ""
"On Windows, attempting to remove a file that is in use causes an exception "
"to be raised; on Unix, the directory entry is removed but the storage "
"allocated to the file is not made available until the original file is no "
"longer in use."
msgstr ""
"У Windows спроба видалити файл, який використовується, викликає виняток; в "
"Unix запис каталогу видаляється, але сховище, виділене для файлу, не стає "
"доступним, доки оригінальний файл більше не буде використовуватися."

msgid "This function is semantically identical to :func:`unlink`."
msgstr "Ця функція семантично ідентична :func:`unlink`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.remove`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.remove`` з аргументами "
"``path``, ``dir_fd``."

msgid ""
"Remove directories recursively.  Works like :func:`rmdir` except that, if "
"the leaf directory is successfully removed, :func:`removedirs`  tries to "
"successively remove every parent directory mentioned in  *path* until an "
"error is raised (which is ignored, because it generally means that a parent "
"directory is not empty). For example, ``os.removedirs('foo/bar/baz')`` will "
"first remove the directory ``'foo/bar/baz'``, and then remove ``'foo/bar'`` "
"and ``'foo'`` if they are empty. Raises :exc:`OSError` if the leaf directory "
"could not be successfully removed."
msgstr ""
"Видалити каталоги рекурсивно. Працює як :func:`rmdir`, за винятком того, що "
"якщо кінцевий каталог успішно видалено, :func:`removedirs` намагається "
"послідовно видалити кожен батьківський каталог, згаданий у *path*, доки не "
"виникне помилка (яка ігнорується, оскільки зазвичай означає, що батьківський "
"каталог не порожній). Наприклад, ``os.removedirs('foo/bar/baz')`` спочатку "
"видалить каталог ``'foo/bar/baz'``, а потім видалить ``'foo/bar'`` і` "
"`'foo'``, якщо вони порожні. Викликає :exc:`OSError`, якщо кінцевий каталог "
"не вдалося успішно видалити."

msgid ""
"Rename the file or directory *src* to *dst*. If *dst* exists, the operation "
"will fail with an :exc:`OSError` subclass in a number of cases:"
msgstr ""
"Перейменуйте файл або каталог *src* на *dst*. Якщо *dst* існує, операція "
"буде невдалою з підкласом :exc:`OSError` у кількох випадках:"

msgid "On Windows, if *dst* exists a :exc:`FileExistsError` is always raised."
msgstr "У Windows, якщо *dst* існує, завжди виникає :exc:`FileExistsError`."

msgid ""
"On Unix, if *src* is a file and *dst* is a directory or vice-versa, an :exc:"
"`IsADirectoryError` or a :exc:`NotADirectoryError` will be raised "
"respectively.  If both are directories and *dst* is empty, *dst* will be "
"silently replaced.  If *dst* is a non-empty directory, an :exc:`OSError` is "
"raised. If both are files, *dst* will be replaced silently if the user has "
"permission.  The operation may fail on some Unix flavors if *src* and *dst* "
"are on different filesystems.  If successful, the renaming will be an atomic "
"operation (this is a POSIX requirement)."
msgstr ""
"В Unix, якщо *src* є файлом, а *dst* є каталогом або навпаки, виникне :exc:"
"`IsADirectoryError` або :exc:`NotADirectoryError` відповідно. Якщо обидва є "
"каталогами, а *dst* порожній, *dst* буде мовчки замінено. Якщо *dst* є "
"непорожнім каталогом, виникає :exc:`OSError`. Якщо обидва є файлами, *dst* "
"буде замінено мовчки, якщо користувач має дозвіл. Операція може завершитися "
"помилкою в деяких варіантах Unix, якщо *src* і *dst* знаходяться в різних "
"файлових системах. У разі успіху перейменування буде атомарною операцією (це "
"вимога POSIX)."

msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`."
msgstr ""
"Ця функція може підтримувати вказівку *src_dir_fd* та/або *dst_dir_fd* для "
"надання :ref:`шляхів відносно дескрипторів каталогу <dir_fd>`."

msgid ""
"If you want cross-platform overwriting of the destination, use :func:"
"`replace`."
msgstr ""
"Якщо ви бажаєте перезаписати місце призначення на різних платформах, "
"використовуйте :func:`replace`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.rename`` with arguments "
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.rename`` з аргументами ``src``, "
"``dst``, ``src_dir_fd``, ``dst_dir_fd``."

msgid "The *src_dir_fd* and *dst_dir_fd* arguments."
msgstr "Аргументи *src_dir_fd* і *dst_dir_fd*."

msgid ""
"Recursive directory or file renaming function. Works like :func:`rename`, "
"except creation of any intermediate directories needed to make the new "
"pathname good is attempted first. After the rename, directories "
"corresponding to rightmost path segments of the old name will be pruned away "
"using :func:`removedirs`."
msgstr ""
"Функція рекурсивного перейменування каталогу або файлу. Працює як :func:"
"`rename`, за винятком того, що спочатку намагаються створити будь-які "
"проміжні каталоги, необхідні для того, щоб зробити нове ім’я шляху "
"правильним. Після перейменування каталоги, які відповідають крайнім правим "
"сегментам шляху старої назви, будуть видалені за допомогою :func:"
"`removedirs`."

msgid ""
"This function can fail with the new directory structure made if you lack "
"permissions needed to remove the leaf directory or file."
msgstr ""
"Ця функція може вийти з ладу з новою структурою каталогів, якщо у вас немає "
"дозволів, необхідних для видалення кінцевого каталогу або файлу."

msgid "Accepts a :term:`path-like object` for *old* and *new*."
msgstr "Приймає :term:`path-like object` для *old* і *new*."

msgid ""
"Rename the file or directory *src* to *dst*.  If *dst* is a non-empty "
"directory, :exc:`OSError` will be raised.  If *dst* exists and is a file, it "
"will be replaced silently if the user has permission.  The operation may "
"fail if *src* and *dst* are on different filesystems.  If successful, the "
"renaming will be an atomic operation (this is a POSIX requirement)."
msgstr ""
"Перейменуйте файл або каталог *src* на *dst*. Якщо *dst* є непорожнім "
"каталогом, буде викликано :exc:`OSError`. Якщо *dst* існує і є файлом, його "
"буде замінено мовчки, якщо користувач має дозвіл. Операція може завершитися "
"помилкою, якщо *src* і *dst* знаходяться в різних файлових системах. У разі "
"успіху перейменування буде атомарною операцією (це вимога POSIX)."

msgid ""
"Remove (delete) the directory *path*.  If the directory does not exist or is "
"not empty, an :exc:`FileNotFoundError` or an :exc:`OSError` is raised "
"respectively.  In order to remove whole directory trees, :func:`shutil."
"rmtree` can be used."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.rmdir`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.rmdir`` з аргументами ``path``, "
"``dir_fd``."

msgid "The *dir_fd* parameter."
msgstr "Параметр *dir_fd*."

msgid ""
"Return an iterator of :class:`os.DirEntry` objects corresponding to the "
"entries in the directory given by *path*. The entries are yielded in "
"arbitrary order, and the special entries ``'.'`` and ``'..'`` are not "
"included.  If a file is removed from or added to the directory after "
"creating the iterator, whether an entry for that file be included is "
"unspecified."
msgstr ""
"Повертає ітератор об’єктів :class:`os.DirEntry`, що відповідають записам у "
"каталозі, визначеному *path*. Записи надаються в довільному порядку, і "
"спеціальні записи ``'.'`` і ``'..'`` не включені. Якщо файл видалено з "
"каталогу або додано до нього після створення ітератора, чи буде включений "
"запис для цього файлу, не визначено."

msgid ""
"Using :func:`scandir` instead of :func:`listdir` can significantly increase "
"the performance of code that also needs file type or file attribute "
"information, because :class:`os.DirEntry` objects expose this information if "
"the operating system provides it when scanning a directory. All :class:`os."
"DirEntry` methods may perform a system call, but :func:`~os.DirEntry.is_dir` "
"and :func:`~os.DirEntry.is_file` usually only require a system call for "
"symbolic links; :func:`os.DirEntry.stat` always requires a system call on "
"Unix but only requires one for symbolic links on Windows."
msgstr ""
"Використання :func:`scandir` замість :func:`listdir` може значно підвищити "
"продуктивність коду, який також потребує інформації про тип файлу чи "
"атрибути файлу, оскільки об’єкти :class:`os.DirEntry` надають цю інформацію, "
"якщо операційна система надає під час сканування каталогу. Усі методи :class:"
"`os.DirEntry` можуть виконувати системний виклик, але :func:`~os.DirEntry."
"is_dir` і :func:`~os.DirEntry.is_file` зазвичай вимагають лише системного "
"виклику для символічних посилань; :func:`os.DirEntry.stat` завжди вимагає "
"системного виклику в Unix, але вимагає лише один для символічних посилань у "
"Windows."

msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes`` "
"(directly or indirectly through the :class:`PathLike` interface), the type "
"of the :attr:`~os.DirEntry.name` and :attr:`~os.DirEntry.path` attributes of "
"each :class:`os.DirEntry` will be ``bytes``; in all other circumstances, "
"they will be of type ``str``."
msgstr ""
"*path* може бути :term:`path-like object`. Якщо *path* має тип ``bytes`` "
"(прямо чи опосередковано через інтерфейс :class:`PathLike`), тип :attr:`~os."
"DirEntry.name` і Атрибути :attr:`~os.DirEntry.path` кожного :class:`os."
"DirEntry` будуть ``bytes``; за всіх інших обставин вони будуть типу ``str``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.scandir`` with argument "
"``path``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.scandir`` з аргументом ``path``."

msgid ""
"The :func:`scandir` iterator supports the :term:`context manager` protocol "
"and has the following method:"
msgstr ""
"Ітератор :func:`scandir` підтримує протокол :term:`context manager` і має "
"такий метод:"

msgid "Close the iterator and free acquired resources."
msgstr "Закрийте ітератор і звільніть отримані ресурси."

msgid ""
"This is called automatically when the iterator is exhausted or garbage "
"collected, or when an error happens during iterating.  However it is "
"advisable to call it explicitly or use the :keyword:`with` statement."
msgstr ""
"Це викликається автоматично, коли ітератор вичерпано або зібрано сміття, або "
"коли під час ітерації трапляється помилка. Однак бажано викликати його явно "
"або використовувати оператор :keyword:`with`."

msgid ""
"The following example shows a simple use of :func:`scandir` to display all "
"the files (excluding directories) in the given *path* that don't start with "
"``'.'``. The ``entry.is_file()`` call will generally not make an additional "
"system call::"
msgstr ""
"У наступному прикладі показано просте використання :func:`scandir` для "
"відображення всіх файлів (за винятком каталогів) у заданому *шляху*, які не "
"починаються з ``'.'``. Виклик ``entry.is_file()`` зазвичай не здійснить "
"додатковий системний виклик:"

msgid ""
"On Unix-based systems, :func:`scandir` uses the system's `opendir() <http://"
"pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_ and "
"`readdir() <http://pubs.opengroup.org/onlinepubs/009695399/functions/"
"readdir_r.html>`_ functions. On Windows, it uses the Win32 `FindFirstFileW "
"<https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85)."
"aspx>`_ and `FindNextFileW <https://msdn.microsoft.com/en-us/library/windows/"
"desktop/aa364428(v=vs.85).aspx>`_ functions."
msgstr ""
"У системах на основі Unix :func:`scandir` використовує системні функції "
"`opendir() <http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir."
"html>`_ і `readdir() <http://pubs.opengroup.org/onlinepubs/009695399/"
"functions/readdir_r.html>`_. У Windows він використовує функції Win32 "
"`FindFirstFileW <https://msdn.microsoft.com/en-us/library/windows/desktop/"
"aa364418(v=vs.85).aspx>`_ і `FindNextFileW <https://msdn.microsoft.com/en-us/"
"library/windows/desktop/aa364428(v=vs.85).aspx>`_."

msgid ""
"Added support for the :term:`context manager` protocol and the :func:"
"`~scandir.close()` method.  If a :func:`scandir` iterator is neither "
"exhausted nor explicitly closed a :exc:`ResourceWarning` will be emitted in "
"its destructor."
msgstr ""
"Додано підтримку протоколу :term:`context manager` і методу :func:`~scandir."
"close()`. Якщо ітератор :func:`scandir` не вичерпано і не закрито явно, у "
"його деструкторі буде видано :exc:`ResourceWarning`."

msgid "The function accepts a :term:`path-like object`."
msgstr "Функція приймає :term:`path-like object`."

msgid "Added support for :ref:`file descriptors <path_fd>` on Unix."
msgstr "Додано підтримку :ref:`дескрипторів файлів <path_fd>` в Unix."

msgid ""
"Object yielded by :func:`scandir` to expose the file path and other file "
"attributes of a directory entry."
msgstr ""
"Об’єкт, створений :func:`scandir` для показу шляху до файлу та інших "
"атрибутів файлу в записі каталогу."

msgid ""
":func:`scandir` will provide as much of this information as possible without "
"making additional system calls. When a ``stat()`` or ``lstat()`` system call "
"is made, the ``os.DirEntry`` object will cache the result."
msgstr ""
":func:`scandir` надасть якомога більше цієї інформації без додаткових "
"системних викликів. Коли виконується системний виклик ``stat()`` або "
"``lstat()``, об'єкт ``os.DirEntry`` кешує результат."

msgid ""
"``os.DirEntry`` instances are not intended to be stored in long-lived data "
"structures; if you know the file metadata has changed or if a long time has "
"elapsed since calling :func:`scandir`, call ``os.stat(entry.path)`` to fetch "
"up-to-date information."
msgstr ""
"Екземпляри ``os.DirEntry`` не призначені для зберігання в довгострокових "
"структурах даних; якщо ви знаєте, що метадані файлу змінилися, або якщо "
"після виклику :func:`scandir` минуло багато часу, викличте ``os.stat(entry."
"path)``, щоб отримати актуальну інформацію."

msgid ""
"Because the ``os.DirEntry`` methods can make operating system calls, they "
"may also raise :exc:`OSError`. If you need very fine-grained control over "
"errors, you can catch :exc:`OSError` when calling one of the ``os.DirEntry`` "
"methods and handle as appropriate."
msgstr ""
"Оскільки методи ``os.DirEntry`` можуть здійснювати виклики операційної "
"системи, вони також можуть викликати :exc:`OSError`. Якщо вам потрібен дуже "
"точний контроль над помилками, ви можете перехопити :exc:`OSError` під час "
"виклику одного з методів ``os.DirEntry`` і обробити відповідно."

msgid ""
"To be directly usable as a :term:`path-like object`, ``os.DirEntry`` "
"implements the :class:`PathLike` interface."
msgstr ""
"Для безпосереднього використання як :term:`path-like object`, ``os."
"DirEntry`` реалізує інтерфейс :class:`PathLike`."

msgid "Attributes and methods on a ``os.DirEntry`` instance are as follows:"
msgstr "Атрибути та методи екземпляра ``os.DirEntry`` такі:"

msgid ""
"The entry's base filename, relative to the :func:`scandir` *path* argument."
msgstr "Базове ім’я файлу запису відносно аргументу *path* :func:`scandir`."

msgid ""
"The :attr:`name` attribute will be ``bytes`` if the :func:`scandir` *path* "
"argument is of type ``bytes`` and ``str`` otherwise.  Use :func:`~os."
"fsdecode` to decode byte filenames."
msgstr ""
"Атрибут :attr:`name` буде ``bytes``, якщо аргумент :func:`scandir` *path* "
"має тип ``bytes`` та ``str`` інакше. Використовуйте :func:`~os.fsdecode` для "
"декодування байтових імен файлів."

msgid ""
"The entry's full path name: equivalent to ``os.path.join(scandir_path, entry."
"name)`` where *scandir_path* is the :func:`scandir` *path* argument.  The "
"path is only absolute if the :func:`scandir` *path* argument was absolute.  "
"If the :func:`scandir` *path* argument was a :ref:`file descriptor "
"<path_fd>`, the :attr:`path` attribute is the same as the :attr:`name` "
"attribute."
msgstr ""
"Повний шлях до запису: еквівалент ``os.path.join(scandir_path, entry."
"name)``, де *scandir_path* є аргументом :func:`scandir` *path*. Шлях є "
"абсолютним, лише якщо аргумент *path* :func:`scandir` був абсолютним. Якщо "
"аргумент :func:`scandir` *path* був :ref:`дескриптором файлу <path_fd>`, "
"атрибут :attr:`path` буде таким самим, як атрибут :attr:`name`."

msgid ""
"The :attr:`path` attribute will be ``bytes`` if the :func:`scandir` *path* "
"argument is of type ``bytes`` and ``str`` otherwise.  Use :func:`~os."
"fsdecode` to decode byte filenames."
msgstr ""
"Атрибут :attr:`path` матиме значення ``bytes``, якщо аргумент *path* :func:"
"`scandir` має тип ``bytes`` та ``str`` інакше. Використовуйте :func:`~os."
"fsdecode` для декодування байтових імен файлів."

msgid "Return the inode number of the entry."
msgstr "Повертає номер inode запису."

msgid ""
"The result is cached on the ``os.DirEntry`` object. Use ``os.stat(entry."
"path, follow_symlinks=False).st_ino`` to fetch up-to-date information."
msgstr ""
"Результат кешується в об’єкті ``os.DirEntry``. Використовуйте ``os."
"stat(entry.path, follow_symlinks=False).st_ino``, щоб отримати актуальну "
"інформацію."

msgid ""
"On the first, uncached call, a system call is required on Windows but not on "
"Unix."
msgstr ""
"Для першого некешованого виклику потрібен системний виклик у Windows, але не "
"в Unix."

msgid ""
"Return ``True`` if this entry is a directory or a symbolic link pointing to "
"a directory; return ``False`` if the entry is or points to any other kind of "
"file, or if it doesn't exist anymore."
msgstr ""
"Повертає ``True``, якщо цей запис є каталогом або символічним посиланням, що "
"вказує на каталог; повертає ``False``, якщо запис є або вказує на будь-який "
"інший тип файлу, або якщо він більше не існує."

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is a "
"directory (without following symlinks); return ``False`` if the entry is any "
"other kind of file or if it doesn't exist anymore."
msgstr ""
"Якщо *follow_symlinks* має значення ``False``, повертає ``True``, лише якщо "
"цей запис є каталогом (без наступних символічних посилань); повертає "
"``False``, якщо запис є файлом будь-якого іншого типу або якщо він більше не "
"існує."

msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache "
"for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` along "
"with :func:`stat.S_ISDIR` to fetch up-to-date information."
msgstr ""
"Результат кешується в об’єкті ``os.DirEntry`` з окремим кешем для "
"*follow_symlinks* ``True`` і ``False``. Викличте :func:`os.stat` разом із :"
"func:`stat.S_ISDIR`, щоб отримати актуальну інформацію."

msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, for non-symlinks, neither Windows or Unix require a system "
"call, except on certain Unix file systems, such as network file systems, "
"that return ``dirent.d_type == DT_UNKNOWN``. If the entry is a symlink, a "
"system call will be required to follow the symlink unless *follow_symlinks* "
"is ``False``."
msgstr ""
"Під час першого некешованого виклику в більшості випадків системний виклик "
"не потрібен. Зокрема, для несимволічних посилань ні Windows, ні Unix не "
"потребують системного виклику, за винятком певних файлових систем Unix, "
"таких як мережеві файлові системи, які повертають ``dirent.d_type == "
"DT_UNKNOWN``. Якщо запис є символічним посиланням, для переходу за "
"символічним посиланням знадобиться системний виклик, якщо *follow_symlinks* "
"не має значення ``False``."

msgid ""
"This method can raise :exc:`OSError`, such as :exc:`PermissionError`, but :"
"exc:`FileNotFoundError` is caught and not raised."
msgstr ""
"Цей метод може викликати :exc:`OSError`, наприклад :exc:`PermissionError`, "
"але :exc:`FileNotFoundError` перехоплюється і не викликається."

msgid ""
"Return ``True`` if this entry is a file or a symbolic link pointing to a "
"file; return ``False`` if the entry is or points to a directory or other non-"
"file entry, or if it doesn't exist anymore."
msgstr ""
"Повертає ``True``, якщо цей запис є файлом або символічним посиланням, що "
"вказує на файл; повертає ``False``, якщо запис є або вказує на каталог або "
"інший нефайловий запис, або якщо він більше не існує."

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is a "
"file (without following symlinks); return ``False`` if the entry is a "
"directory or other non-file entry, or if it doesn't exist anymore."
msgstr ""
"Якщо *follow_symlinks* має значення ``False``, повертає ``True``, лише якщо "
"цей запис є файлом (без наступних символічних посилань); повертає ``False``, "
"якщо запис є каталогом чи іншим записом, що не є файлом, або якщо він більше "
"не існує."

msgid ""
"The result is cached on the ``os.DirEntry`` object. Caching, system calls "
"made, and exceptions raised are as per :func:`~os.DirEntry.is_dir`."
msgstr ""
"Результат кешується в об’єкті ``os.DirEntry``. Кешування, системні виклики "
"та викликані винятки відповідають :func:`~os.DirEntry.is_dir`."

msgid ""
"Return ``True`` if this entry is a symbolic link (even if broken); return "
"``False`` if the entry points to a directory or any kind of file, or if it "
"doesn't exist anymore."
msgstr ""
"Повертає ``True``, якщо цей запис є символічним посиланням (навіть якщо "
"пошкоджене); повертає ``False``, якщо запис вказує на каталог або будь-який "
"файл, або якщо він більше не існує."

msgid ""
"The result is cached on the ``os.DirEntry`` object. Call :func:`os.path."
"islink` to fetch up-to-date information."
msgstr ""
"Результат кешується в об’єкті ``os.DirEntry``. Викличте :func:`os.path."
"islink`, щоб отримати актуальну інформацію."

msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, neither Windows or Unix require a system call, except on "
"certain Unix file systems, such as network file systems, that return "
"``dirent.d_type == DT_UNKNOWN``."
msgstr ""
"Під час першого некешованого виклику в більшості випадків системний виклик "
"не потрібен. Зокрема, ані Windows, ані Unix не потребують системного "
"виклику, за винятком певних файлових систем Unix, таких як мережеві файлові "
"системи, які повертають ``dirent.d_type == DT_UNKNOWN``."

msgid ""
"Return a :class:`stat_result` object for this entry. This method follows "
"symbolic links by default; to stat a symbolic link add the "
"``follow_symlinks=False`` argument."
msgstr ""
"Повернути об’єкт :class:`stat_result` для цього запису. Цей метод за "
"умовчанням слідує символічним посиланням; щоб стати символічним посиланням, "
"додайте аргумент ``follow_symlinks=False``."

msgid ""
"On Unix, this method always requires a system call. On Windows, it only "
"requires a system call if *follow_symlinks* is ``True`` and the entry is a "
"reparse point (for example, a symbolic link or directory junction)."
msgstr ""
"В Unix цей метод завжди потребує системного виклику. У Windows системний "
"виклик потрібен, лише якщо *follow_symlinks* має значення ``True`` і запис є "
"точкою повторного аналізу (наприклад, символічне посилання або з’єднання "
"каталогу)."

msgid ""
"On Windows, the ``st_ino``, ``st_dev`` and ``st_nlink`` attributes of the :"
"class:`stat_result` are always set to zero. Call :func:`os.stat` to get "
"these attributes."
msgstr ""
"У Windows атрибути ``st_ino``, ``st_dev`` і ``st_nlink`` :class:"
"`stat_result` завжди встановлюються на нуль. Викличте :func:`os.stat`, щоб "
"отримати ці атрибути."

msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache "
"for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` to fetch "
"up-to-date information."
msgstr ""
"Результат кешується в об’єкті ``os.DirEntry`` з окремим кешем для "
"*follow_symlinks* ``True`` і ``False``. Зателефонуйте :func:`os.stat`, щоб "
"отримати актуальну інформацію."

msgid ""
"Note that there is a nice correspondence between several attributes and "
"methods of ``os.DirEntry`` and of :class:`pathlib.Path`.  In particular, the "
"``name`` attribute has the same meaning, as do the ``is_dir()``, "
"``is_file()``, ``is_symlink()`` and ``stat()`` methods."
msgstr ""
"Зауважте, що між декількома атрибутами та методами ``os.DirEntry`` і :class:"
"`pathlib.Path` існує хороша відповідність. Зокрема, атрибут ``name`` має те "
"саме значення, що й методи ``is_dir()``, ``is_file()``, ``is_symlink()`` і "
"``stat()`` ."

msgid ""
"Added support for the :class:`~os.PathLike` interface.  Added support for :"
"class:`bytes` paths on Windows."
msgstr ""
"Додано підтримку інтерфейсу :class:`~os.PathLike`. Додано підтримку шляхів :"
"class:`bytes` у Windows."

msgid ""
"Get the status of a file or a file descriptor. Perform the equivalent of a :"
"c:func:`stat` system call on the given path. *path* may be specified as "
"either a string or bytes -- directly or indirectly through the :class:"
"`PathLike` interface -- or as an open file descriptor. Return a :class:"
"`stat_result` object."
msgstr ""
"Отримати статус файлу або дескриптора файлу. Виконайте еквівалент системного "
"виклику :c:func:`stat` на вказаному шляху. *шлях* можна вказати як рядок або "
"байти — прямо чи опосередковано через інтерфейс :class:`PathLike` — або як "
"дескриптор відкритого файлу. Повертає об’єкт :class:`stat_result`."

msgid ""
"This function normally follows symlinks; to stat a symlink add the argument "
"``follow_symlinks=False``, or use :func:`lstat`."
msgstr ""
"Ця функція зазвичай слідує за символічними посиланнями; щоб стати "
"символічним посиланням, додайте аргумент ``follow_symlinks=False`` або "
"використовуйте :func:`lstat`."

msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>` and :"
"ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"Ця функція може підтримувати :ref:`зазначення файлового дескриптора "
"<path_fd>` і :ref:`неперехід за символічними посиланнями <follow_symlinks>`."

msgid ""
"On Windows, passing ``follow_symlinks=False`` will disable following all "
"name-surrogate reparse points, which includes symlinks and directory "
"junctions. Other types of reparse points that do not resemble links or that "
"the operating system is unable to follow will be opened directly. When "
"following a chain of multiple links, this may result in the original link "
"being returned instead of the non-link that prevented full traversal. To "
"obtain stat results for the final path in this case, use the :func:`os.path."
"realpath` function to resolve the path name as far as possible and call :"
"func:`lstat` on the result. This does not apply to dangling symlinks or "
"junction points, which will raise the usual exceptions."
msgstr ""
"У Windows передача ``follow_symlinks=False`` вимкне відстеження всіх "
"сурогатних точок повторного аналізу імен, включаючи символічні посилання та "
"з’єднання каталогів. Інші типи точок повторного аналізу, які не схожі на "
"посилання або за якими операційна система не може слідувати, будуть відкриті "
"безпосередньо. Під час переходу за ланцюгом із кількох посилань це може "
"призвести до повернення оригінального посилання замість незв’язку, яке "
"перешкоджало повному обходу. Щоб отримати статистичні результати для "
"кінцевого шляху в цьому випадку, скористайтеся :func:`os.path.realpath` "
"функцією, щоб вирішити назву шляху, наскільки це можливо, і викликайте :func:"
"`lstat` для результату. Це не стосується висячих символічних посилань або "
"точок з’єднання, які призведуть до звичайних винятків."

msgid "Example::"
msgstr "Приклад::"

msgid ":func:`fstat` and :func:`lstat` functions."
msgstr "Функції :func:`fstat` і :func:`lstat`."

msgid ""
"Added the *dir_fd* and *follow_symlinks* arguments, specifying a file "
"descriptor instead of a path."
msgstr ""
"Додано аргументи *dir_fd* і *follow_symlinks* із зазначенням дескриптора "
"файлу замість шляху."

msgid ""
"On Windows, all reparse points that can be resolved by the operating system "
"are now followed, and passing ``follow_symlinks=False`` disables following "
"all name surrogate reparse points. If the operating system reaches a reparse "
"point that it is not able to follow, *stat* now returns the information for "
"the original path as if ``follow_symlinks=False`` had been specified instead "
"of raising an error."
msgstr ""
"У Windows усі точки повторного аналізу, які може вирішити операційна "
"система, тепер відстежуються, а передача ``follow_symlinks=False`` вимикає "
"відстеження всіх сурогатних точок повторного аналізу імен. Якщо операційна "
"система досягає точки повторного аналізу, за якою вона не може слідувати, "
"*stat* тепер повертає інформацію для початкового шляху, як якщо б було "
"вказано ``follow_symlinks=False`` замість того, щоб викликати помилку."

msgid ""
"Object whose attributes correspond roughly to the members of the :c:type:"
"`stat` structure. It is used for the result of :func:`os.stat`, :func:`os."
"fstat` and :func:`os.lstat`."
msgstr ""
"Об’єкт, атрибути якого приблизно відповідають членам структури :c:type:"
"`stat`. Він використовується для результату :func:`os.stat`, :func:`os."
"fstat` і :func:`os.lstat`."

msgid "Attributes:"
msgstr "Атрибути:"

msgid "File mode: file type and file mode bits (permissions)."
msgstr "Режим файлу: тип файлу та біти режиму файлу (дозволи)."

msgid ""
"Platform dependent, but if non-zero, uniquely identifies the file for a "
"given value of ``st_dev``. Typically:"
msgstr ""
"Залежить від платформи, але якщо не нуль, унікально ідентифікує файл для "
"заданого значення ``st_dev``. Зазвичай:"

msgid "the inode number on Unix,"
msgstr "номер inode в Unix,"

msgid ""
"the `file index <https://msdn.microsoft.com/en-us/library/aa363788>`_ on "
"Windows"
msgstr ""
"`індекс файлу <https://msdn.microsoft.com/en-us/library/aa363788>`_ у Windows"

msgid "Identifier of the device on which this file resides."
msgstr "Ідентифікатор пристрою, на якому знаходиться цей файл."

msgid "Number of hard links."
msgstr "Кількість жорстких посилань."

msgid "User identifier of the file owner."
msgstr "Ідентифікатор користувача власника файлу."

msgid "Group identifier of the file owner."
msgstr "Груповий ідентифікатор власника файлу."

msgid ""
"Size of the file in bytes, if it is a regular file or a symbolic link. The "
"size of a symbolic link is the length of the pathname it contains, without a "
"terminating null byte."
msgstr ""
"Розмір файлу в байтах, якщо це звичайний файл або символьне посилання. "
"Розмір символічного посилання - це довжина шляху, який воно містить, без "
"кінцевого нульового байта."

msgid "Timestamps:"
msgstr "Мітки часу:"

msgid "Time of most recent access expressed in seconds."
msgstr "Час останнього доступу, виражений у секундах."

msgid "Time of most recent content modification expressed in seconds."
msgstr "Час останньої зміни вмісту, виражений у секундах."

msgid "Platform dependent:"
msgstr "Залежить від платформи:"

msgid "the time of most recent metadata change on Unix,"
msgstr "час останньої зміни метаданих в Unix,"

msgid "the time of creation on Windows, expressed in seconds."
msgstr "час створення в Windows, виражений у секундах."

msgid "Time of most recent access expressed in nanoseconds as an integer."
msgstr "Час останнього доступу, виражений у наносекундах як ціле число."

msgid ""
"Time of most recent content modification expressed in nanoseconds as an "
"integer."
msgstr "Час останньої зміни вмісту, виражений у наносекундах як ціле число."

msgid ""
"the time of creation on Windows, expressed in nanoseconds as an integer."
msgstr "час створення в Windows, виражений у наносекундах як ціле число."

msgid ""
"The exact meaning and resolution of the :attr:`st_atime`, :attr:`st_mtime`, "
"and :attr:`st_ctime` attributes depend on the operating system and the file "
"system. For example, on Windows systems using the FAT or FAT32 file "
"systems, :attr:`st_mtime` has 2-second resolution, and :attr:`st_atime` has "
"only 1-day resolution.  See your operating system documentation for details."
msgstr ""
"Точне значення та роздільна здатність атрибутів :attr:`st_atime`, :attr:"
"`st_mtime` і :attr:`st_ctime` залежать від операційної та файлової системи. "
"Наприклад, у системах Windows, які використовують файлові системи FAT або "
"FAT32, :attr:`st_mtime` має роздільну здатність 2 секунди, а :attr:"
"`st_atime` — лише 1 день. Додаткову інформацію дивіться в документації вашої "
"операційної системи."

msgid ""
"Similarly, although :attr:`st_atime_ns`, :attr:`st_mtime_ns`, and :attr:"
"`st_ctime_ns` are always expressed in nanoseconds, many systems do not "
"provide nanosecond precision.  On systems that do provide nanosecond "
"precision, the floating-point object used to store :attr:`st_atime`, :attr:"
"`st_mtime`, and :attr:`st_ctime` cannot preserve all of it, and as such will "
"be slightly inexact. If you need the exact timestamps you should always use :"
"attr:`st_atime_ns`, :attr:`st_mtime_ns`, and :attr:`st_ctime_ns`."
msgstr ""
"Подібним чином, хоча :attr:`st_atime_ns`, :attr:`st_mtime_ns` і :attr:"
"`st_ctime_ns` завжди виражаються в наносекундах, багато систем не "
"забезпечують точність до наносекунд. У системах, які забезпечують "
"наносекундну точність, об’єкт із плаваючою комою, який використовується для "
"зберігання :attr:`st_atime`, :attr:`st_mtime` і :attr:`st_ctime`, не може "
"зберегти все це, і тому буде трохи неточним . Якщо вам потрібні точні мітки "
"часу, завжди використовуйте :attr:`st_atime_ns`, :attr:`st_mtime_ns` і :attr:"
"`st_ctime_ns`."

msgid ""
"On some Unix systems (such as Linux), the following attributes may also be "
"available:"
msgstr ""
"У деяких системах Unix (таких як Linux) також можуть бути доступні такі "
"атрибути:"

msgid ""
"Number of 512-byte blocks allocated for file. This may be smaller than :attr:"
"`st_size`/512 when the file has holes."
msgstr ""
"Кількість 512-байтних блоків, виділених для файлу. Це може бути менше, ніж :"
"attr:`st_size`/512, якщо файл має отвори."

msgid ""
"\"Preferred\" blocksize for efficient file system I/O. Writing to a file in "
"smaller chunks may cause an inefficient read-modify-rewrite."
msgstr ""
"\"Бажаний\" розмір блоку для ефективного введення/виведення файлової "
"системи. Запис у файл меншими фрагментами може спричинити неефективне "
"читання-змінення-перезапис."

msgid "Type of device if an inode device."
msgstr "Тип пристрою, якщо пристрій inode."

msgid "User defined flags for file."
msgstr "Визначені користувачем позначки для файлу."

msgid ""
"On other Unix systems (such as FreeBSD), the following attributes may be "
"available (but may be only filled out if root tries to use them):"
msgstr ""
"В інших системах Unix (таких як FreeBSD) такі атрибути можуть бути "
"доступними (але можуть бути заповнені, лише якщо root намагається їх "
"використати):"

msgid "File generation number."
msgstr "Номер покоління файлу."

msgid "Time of file creation."
msgstr "Час створення файлу."

msgid ""
"On Solaris and derivatives, the following attributes may also be available:"
msgstr "У Solaris і похідних також можуть бути доступні такі атрибути:"

msgid ""
"String that uniquely identifies the type of the filesystem that contains the "
"file."
msgstr ""
"Рядок, який однозначно визначає тип файлової системи, яка містить файл."

msgid "On macOS systems, the following attributes may also be available:"
msgstr "У системах macOS також можуть бути доступні такі атрибути:"

msgid "Real size of the file."
msgstr "Реальний розмір файлу."

msgid "Creator of the file."
msgstr "Творець файлу."

msgid "File type."
msgstr "Тип файлу."

msgid "On Windows systems, the following attributes are also available:"
msgstr "У системах Windows також доступні такі атрибути:"

msgid ""
"Windows file attributes: ``dwFileAttributes`` member of the "
"``BY_HANDLE_FILE_INFORMATION`` structure returned by :c:func:"
"`GetFileInformationByHandle`. See the ``FILE_ATTRIBUTE_*`` constants in the :"
"mod:`stat` module."
msgstr ""
"Атрибути файлів Windows: ``dwFileAttributes``, член структури "
"``BY_HANDLE_FILE_INFORMATION``, повернений :c:func:"
"`GetFileInformationByHandle`. Перегляньте константи ``FILE_ATTRIBUTE_*`` в "
"модулі :mod:`stat`."

msgid ""
"When :attr:`st_file_attributes` has the ``FILE_ATTRIBUTE_REPARSE_POINT`` "
"set, this field contains the tag identifying the type of reparse point. See "
"the ``IO_REPARSE_TAG_*`` constants in the :mod:`stat` module."
msgstr ""
"Якщо для :attr:`st_file_attributes` встановлено "
"``FILE_ATTRIBUTE_REPARSE_POINT``, це поле містить тег, що визначає тип точки "
"повторного аналізу. Перегляньте константи ``IO_REPARSE_TAG_*`` в модулі :mod:"
"`stat`."

msgid ""
"The standard module :mod:`stat` defines functions and constants that are "
"useful for extracting information from a :c:type:`stat` structure. (On "
"Windows, some items are filled with dummy values.)"
msgstr ""
"Стандартний модуль :mod:`stat` визначає функції та константи, корисні для "
"отримання інформації зі структури :c:type:`stat`. (У Windows деякі елементи "
"заповнюються фіктивними значеннями.)"

msgid ""
"For backward compatibility, a :class:`stat_result` instance is also "
"accessible as a tuple of at least 10 integers giving the most important (and "
"portable) members of the :c:type:`stat` structure, in the order :attr:"
"`st_mode`, :attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`, :attr:"
"`st_uid`, :attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`, :attr:"
"`st_mtime`, :attr:`st_ctime`. More items may be added at the end by some "
"implementations. For compatibility with older Python versions, accessing :"
"class:`stat_result` as a tuple always returns integers."
msgstr ""
"Для зворотної сумісності екземпляр :class:`stat_result` також доступний як "
"кортеж із принаймні 10 цілих чисел, що надає найважливіші (і переносні) "
"члени структури :c:type:`stat` у порядку :attr:`st_mode`, :attr:`st_ino`, :"
"attr:`st_dev`, :attr:`st_nlink`, :attr:`st_uid`, :attr:`st_gid`, :attr:"
"`st_size`, :attr:`st_atime`, :attr:`st_mtime`, :attr:`st_ctime`. Інші "
"елементи можуть бути додані в кінці в деяких реалізаціях. Для сумісності зі "
"старими версіями Python доступ до :class:`stat_result` як кортежу завжди "
"повертає цілі числа."

msgid ""
"Added the :attr:`st_atime_ns`, :attr:`st_mtime_ns`, and :attr:`st_ctime_ns` "
"members."
msgstr ""
"Додано учасників :attr:`st_atime_ns`, :attr:`st_mtime_ns` і :attr:"
"`st_ctime_ns`."

msgid "Added the :attr:`st_file_attributes` member on Windows."
msgstr "Додано член :attr:`st_file_attributes` у Windows."

msgid "Windows now returns the file index as :attr:`st_ino` when available."
msgstr ""
"Тепер Windows повертає індекс файлу як :attr:`st_ino`, якщо він доступний."

msgid "Added the :attr:`st_fstype` member to Solaris/derivatives."
msgstr "Додано член :attr:`st_fstype` до Solaris/derivatives."

msgid "Added the :attr:`st_reparse_tag` member on Windows."
msgstr "Додано член :attr:`st_reparse_tag` у Windows."

msgid ""
"On Windows, the :attr:`st_mode` member now identifies special files as :"
"const:`S_IFCHR`, :const:`S_IFIFO` or :const:`S_IFBLK` as appropriate."
msgstr ""
"У Windows член :attr:`st_mode` тепер ідентифікує спеціальні файли як :const:"
"`S_IFCHR`, :const:`S_IFIFO` або :const:`S_IFBLK` відповідно."

msgid ""
"Perform a :c:func:`statvfs` system call on the given path.  The return value "
"is an object whose attributes describe the filesystem on the given path, and "
"correspond to the members of the :c:type:`statvfs` structure, namely: :attr:"
"`f_bsize`, :attr:`f_frsize`, :attr:`f_blocks`, :attr:`f_bfree`, :attr:"
"`f_bavail`, :attr:`f_files`, :attr:`f_ffree`, :attr:`f_favail`, :attr:"
"`f_flag`, :attr:`f_namemax`, :attr:`f_fsid`."
msgstr ""
"Виконайте системний виклик :c:func:`statvfs` за вказаним шляхом. Повернене "
"значення — це об’єкт, атрибути якого описують файлову систему на заданому "
"шляху та відповідають членам структури :c:type:`statvfs`, а саме: :attr:"
"`f_bsize`, :attr:`f_frsize`,  :attr:`f_blocks`, :attr:`f_bfree`, :attr:"
"`f_bavail`, :attr:`f_files`, :attr:`f_ffree`, :attr:`f_favail`, :attr:"
"`f_flag`, :attr:`f_namemax`, :attr:`f_fsid`."

msgid ""
"Two module-level constants are defined for the :attr:`f_flag` attribute's "
"bit-flags: if :const:`ST_RDONLY` is set, the filesystem is mounted read-"
"only, and if :const:`ST_NOSUID` is set, the semantics of setuid/setgid bits "
"are disabled or not supported."
msgstr ""
"Для бітових прапорів атрибута :attr:`f_flag` визначено дві константи рівня "
"модуля: якщо встановлено :const:`ST_RDONLY`, файлова система монтується лише "
"для читання, а якщо встановлено :const:`ST_NOSUID`, семантика бітів setuid/"
"setgid вимкнена або не підтримується."

msgid ""
"Additional module-level constants are defined for GNU/glibc based systems. "
"These are :const:`ST_NODEV` (disallow access to device special files), :"
"const:`ST_NOEXEC` (disallow program execution), :const:`ST_SYNCHRONOUS` "
"(writes are synced at once), :const:`ST_MANDLOCK` (allow mandatory locks on "
"an FS), :const:`ST_WRITE` (write on file/directory/symlink), :const:"
"`ST_APPEND` (append-only file), :const:`ST_IMMUTABLE` (immutable file), :"
"const:`ST_NOATIME` (do not update access times), :const:`ST_NODIRATIME` (do "
"not update directory access times), :const:`ST_RELATIME` (update atime "
"relative to mtime/ctime)."
msgstr ""
"Для систем на основі GNU/glibc визначено додаткові константи рівня модуля. "
"Це :const:`ST_NODEV` (заборона доступу до спеціальних файлів пристрою), :"
"const:`ST_NOEXEC` (заборона виконання програми), :const:`ST_SYNCHRONOUS` "
"(записи синхронізуються одночасно), :const:`ST_MANDLOCK` ( дозволити "
"обов’язкове блокування FS), :const:`ST_WRITE` (запис у файл/каталог/символне "
"посилання), :const:`ST_APPEND` (файл лише для додавання), :const:"
"`ST_IMMUTABLE` (незмінний файл), :const:`ST_NOATIME` (не оновлювати час "
"доступу), :const:`ST_NODIRATIME` (не оновлювати час доступу до каталогу), :"
"const:`ST_RELATIME` (оновлювати atime відносно mtime/ctime)."

msgid "The :const:`ST_RDONLY` and :const:`ST_NOSUID` constants were added."
msgstr "Додано константи :const:`ST_RDONLY` і :const:`ST_NOSUID`."

msgid ""
"The :const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, :const:"
"`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, :const:"
"`ST_IMMUTABLE`, :const:`ST_NOATIME`, :const:`ST_NODIRATIME`, and :const:"
"`ST_RELATIME` constants were added."
msgstr ""
":const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, :const:"
"`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, :const:`ST_IMMUTABLE`, "
"Додано константи :const:`ST_NOATIME`, :const:`ST_NODIRATIME` і :const:"
"`ST_RELATIME`."

msgid "Added :attr:`f_fsid`."
msgstr "Додано :attr:`f_fsid`."

msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"accept an open file descriptor for their *dir_fd* parameter. Different "
"platforms provide different features, and the underlying functionality "
"Python uses to implement the *dir_fd* parameter is not available on all "
"platforms Python supports.  For consistency's sake, functions that may "
"support *dir_fd* always allow specifying the parameter, but will throw an "
"exception if the functionality is used when it's not locally available. "
"(Specifying ``None`` for *dir_fd* is always supported on all platforms.)"
msgstr ""
"Об’єкт :class:`set`, що вказує, які функції в модулі :mod:`os` приймають "
"дескриптор відкритого файлу для свого параметра *dir_fd*. Різні платформи "
"надають різні функції, а основні функції, які Python використовує для "
"реалізації параметра *dir_fd*, доступні не на всіх платформах, які підтримує "
"Python. Заради узгодженості функції, які можуть підтримувати *dir_fd*, "
"завжди дозволяють вказати параметр, але створять виняток, якщо функція "
"використовується, коли вона недоступна локально. (Визначення ``None`` для "
"*dir_fd* завжди підтримується на всіх платформах.)"

msgid ""
"To check whether a particular function accepts an open file descriptor for "
"its *dir_fd* parameter, use the ``in`` operator on ``supports_dir_fd``. As "
"an example, this expression evaluates to ``True`` if :func:`os.stat` accepts "
"open file descriptors for *dir_fd* on the local platform::"
msgstr ""
"Щоб перевірити, чи певна функція приймає дескриптор відкритого файлу для "
"свого параметра *dir_fd*, використовуйте оператор ``in`` на "
"``supports_dir_fd``. Як приклад, цей вираз оцінюється як ``True``, якщо :"
"func:`os.stat` приймає дескриптори відкритих файлів для *dir_fd* на "
"локальній платформі::"

msgid ""
"Currently *dir_fd* parameters only work on Unix platforms; none of them work "
"on Windows."
msgstr ""
"Наразі параметри *dir_fd* працюють лише на платформах Unix; жоден з них не "
"працює в Windows."

msgid ""
"A :class:`set` object indicating whether :func:`os.access` permits "
"specifying ``True`` for its *effective_ids* parameter on the local platform. "
"(Specifying ``False`` for *effective_ids* is always supported on all "
"platforms.)  If the local platform supports it, the collection will contain :"
"func:`os.access`; otherwise it will be empty."
msgstr ""
"Об’єкт :class:`set`, що вказує, чи дозволяє :func:`os.access` вказувати "
"``True`` для свого параметра *effective_ids* на локальній платформі. "
"(Вказівка ``False`` для *effective_ids* завжди підтримується на всіх "
"платформах.) Якщо локальна платформа підтримує це, колекція міститиме :func:"
"`os.access`; інакше воно буде порожнім."

msgid ""
"This expression evaluates to ``True`` if :func:`os.access` supports "
"``effective_ids=True`` on the local platform::"
msgstr ""
"Цей вираз оцінюється як ``True``, якщо :func:`os.access` підтримує "
"``effective_ids=True`` на локальній платформі::"

msgid ""
"Currently *effective_ids* is only supported on Unix platforms; it does not "
"work on Windows."
msgstr ""
"Наразі *effective_ids* підтримується лише на платформах Unix; це не працює в "
"Windows."

msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"permit specifying their *path* parameter as an open file descriptor on the "
"local platform.  Different platforms provide different features, and the "
"underlying functionality Python uses to accept open file descriptors as "
"*path* arguments is not available on all platforms Python supports."
msgstr ""
"Об’єкт :class:`set`, що вказує, які функції в модулі :mod:`os` дозволяють "
"вказувати свій параметр *path* як дескриптор відкритого файлу на локальній "
"платформі. Різні платформи надають різні функції, а основні функції, які "
"Python використовує для прийняття відкритих файлових дескрипторів як *шлях* "
"аргументів, доступні не на всіх платформах, які підтримує Python."

msgid ""
"To determine whether a particular function permits specifying an open file "
"descriptor for its *path* parameter, use the ``in`` operator on "
"``supports_fd``. As an example, this expression evaluates to ``True`` if :"
"func:`os.chdir` accepts open file descriptors for *path* on your local "
"platform::"
msgstr ""
"Щоб визначити, чи дозволяє певна функція вказувати дескриптор відкритого "
"файлу для свого параметра *path*, використовуйте оператор ``in`` на "
"``supports_fd``. Як приклад, цей вираз має значення ``True``, якщо :func:`os."
"chdir` приймає дескриптори відкритих файлів для *path* на вашій локальній "
"платформі::"

msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"accept ``False`` for their *follow_symlinks* parameter on the local "
"platform. Different platforms provide different features, and the underlying "
"functionality Python uses to implement *follow_symlinks* is not available on "
"all platforms Python supports.  For consistency's sake, functions that may "
"support *follow_symlinks* always allow specifying the parameter, but will "
"throw an exception if the functionality is used when it's not locally "
"available.  (Specifying ``True`` for *follow_symlinks* is always supported "
"on all platforms.)"
msgstr ""
"Об’єкт :class:`set`, що вказує, які функції в модулі :mod:`os` приймають "
"``False`` для свого параметра *follow_symlinks* на локальній платформі. "
"Різні платформи надають різні функції, а основні функції, які Python "
"використовує для реалізації *follow_symlinks*, доступні не на всіх "
"платформах, які підтримує Python. Заради узгодженості функції, які можуть "
"підтримувати *follow_symlinks*, завжди дозволяють вказувати параметр, але "
"викидають виняток, якщо функція використовується, коли вона недоступна "
"локально. (Вказівка ``True`` для *follow_symlinks* завжди підтримується на "
"всіх платформах.)"

msgid ""
"To check whether a particular function accepts ``False`` for its "
"*follow_symlinks* parameter, use the ``in`` operator on "
"``supports_follow_symlinks``.  As an example, this expression evaluates to "
"``True`` if you may specify ``follow_symlinks=False`` when calling :func:`os."
"stat` on the local platform::"
msgstr ""
"Щоб перевірити, чи певна функція приймає ``False`` для свого параметра "
"*follow_symlinks*, використовуйте оператор ``in`` у "
"``supports_follow_symlinks``. Як приклад, цей вираз має значення ``True``, "
"якщо ви можете вказати ``follow_symlinks=False`` під час виклику :func:`os."
"stat` на локальній платформі::"

msgid "Create a symbolic link pointing to *src* named *dst*."
msgstr "Створіть символічне посилання на *src* під назвою *dst*."

msgid ""
"On Windows, a symlink represents either a file or a directory, and does not "
"morph to the target dynamically.  If the target is present, the type of the "
"symlink will be created to match. Otherwise, the symlink will be created as "
"a directory if *target_is_directory* is ``True`` or a file symlink (the "
"default) otherwise.  On non-Windows platforms, *target_is_directory* is "
"ignored."
msgstr ""
"У Windows символічне посилання представляє або файл, або каталог і не "
"перетворюється на ціль динамічно. Якщо ціль присутня, буде створено "
"відповідний тип символічного посилання. В іншому випадку символічне "
"посилання буде створено як каталог, якщо *target_is_directory* має значення "
"``True``, або символічне посилання на файл (за замовчуванням), інакше. На "
"платформах, відмінних від Windows, *target_is_directory* ігнорується."

msgid ""
"On newer versions of Windows 10, unprivileged accounts can create symlinks "
"if Developer Mode is enabled. When Developer Mode is not available/enabled, "
"the *SeCreateSymbolicLinkPrivilege* privilege is required, or the process "
"must be run as an administrator."
msgstr ""
"У новіших версіях Windows 10 непривілейовані облікові записи можуть "
"створювати символічні посилання, якщо ввімкнено режим розробника. Якщо режим "
"розробника недоступний/увімкнено, потрібен привілей "
"*SeCreateSymbolicLinkPrivilege*, або процес потрібно запускати від імені "
"адміністратора."

msgid ""
":exc:`OSError` is raised when the function is called by an unprivileged user."
msgstr ""
":exc:`OSError` виникає, коли функцію викликає непривілейований користувач."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.symlink`` with arguments "
"``src``, ``dst``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.symlink`` з аргументами "
"``src``, ``dst``, ``dir_fd``."

msgid ""
"Added the *dir_fd* argument, and now allow *target_is_directory* on non-"
"Windows platforms."
msgstr ""
"Додано аргумент *dir_fd* і тепер дозволено *target_is_directory* на "
"платформах, відмінних від Windows."

msgid "Added support for unelevated symlinks on Windows with Developer Mode."
msgstr ""
"Додано підтримку непідвищених символічних посилань у Windows із режимом "
"розробника."

msgid "Force write of everything to disk."
msgstr "Примусово записувати все на диск."

msgid ""
"Truncate the file corresponding to *path*, so that it is at most *length* "
"bytes in size."
msgstr ""
"Обріжте файл, що відповідає *шляху*, щоб його розмір не перевищував *length* "
"байтів."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.truncate`` with arguments "
"``path``, ``length``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.truncate`` з аргументами "
"``path``, ``length``."

msgid ""
"Remove (delete) the file *path*.  This function is semantically identical "
"to :func:`remove`; the ``unlink`` name is its traditional Unix name.  Please "
"see the documentation for :func:`remove` for further information."
msgstr ""
"Видалити (видалити) *шлях* до файлу. Ця функція семантично ідентична :func:"
"`remove`; ім'я ``unlink`` є його традиційною назвою Unix. Будь ласка, "
"перегляньте документацію для :func:`remove` для отримання додаткової "
"інформації."

msgid "Set the access and modified times of the file specified by *path*."
msgstr "Встановіть час доступу та час зміни файлу, указаного *шляхом*."

msgid ""
":func:`utime` takes two optional parameters, *times* and *ns*. These specify "
"the times set on *path* and are used as follows:"
msgstr ""
":func:`utime` приймає два необов’язкові параметри, *times* і *ns*. Вони "
"вказують час, встановлений на *path* і використовуються таким чином:"

msgid ""
"If *ns* is specified, it must be a 2-tuple of the form ``(atime_ns, "
"mtime_ns)`` where each member is an int expressing nanoseconds."
msgstr ""
"Якщо вказано *ns*, це має бути 2-кортеж у формі ``(atime_ns, mtime_ns)``, де "
"кожен член є int, що виражає наносекунди."

msgid ""
"If *times* is not ``None``, it must be a 2-tuple of the form ``(atime, "
"mtime)`` where each member is an int or float expressing seconds."
msgstr ""
"Якщо *times* не є ``None``, це має бути 2-кортеж у формі ``(atime, mtime)``, "
"де кожен член є int або float, що виражає секунди."

msgid ""
"If *times* is ``None`` and *ns* is unspecified, this is equivalent to "
"specifying ``ns=(atime_ns, mtime_ns)`` where both times are the current time."
msgstr ""
"Якщо *times* має значення ``None`` і *ns* не вказано, це еквівалентно "
"вказівці ``ns=(atime_ns, mtime_ns)``, де обидва часи є поточним часом."

msgid "It is an error to specify tuples for both *times* and *ns*."
msgstr "Помилково вказувати кортежі як для *times*, так і для *ns*."

msgid ""
"Note that the exact times you set here may not be returned by a subsequent :"
"func:`~os.stat` call, depending on the resolution with which your operating "
"system records access and modification times; see :func:`~os.stat`. The best "
"way to preserve exact times is to use the *st_atime_ns* and *st_mtime_ns* "
"fields from the :func:`os.stat` result object with the *ns* parameter to "
"`utime`."
msgstr ""
"Зауважте, що точний час, який ви встановили тут, може не повертатися "
"наступним викликом :func:`~os.stat`, залежно від роздільної здатності, з "
"якою ваша операційна система записує час доступу та модифікації; див. :func:"
"`~os.stat`. Найкращий спосіб зберегти точний час — використовувати поля "
"*st_atime_ns* і *st_mtime_ns* з об’єкта результату :func:`os.stat` із "
"параметром *ns* для `utime`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.utime`` with arguments "
"``path``, ``times``, ``ns``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.utime`` з аргументами ``path``, "
"``times``, ``ns``, ``dir_fd``."

msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd*, *follow_symlinks*, and *ns* parameters."
msgstr ""
"Додано підтримку для вказівки *шляху* як дескриптора відкритого файлу та "
"параметрів *dir_fd*, *follow_symlinks* і *ns*."

msgid ""
"Generate the file names in a directory tree by walking the tree either top-"
"down or bottom-up. For each directory in the tree rooted at directory *top* "
"(including *top* itself), it yields a 3-tuple ``(dirpath, dirnames, "
"filenames)``."
msgstr ""
"Згенеруйте імена файлів у дереві каталогів, проходячи по дереву зверху вниз "
"або знизу вгору. Для кожного каталогу в дереві, що знаходиться в каталозі "
"*top* (включно з самим *top*), він дає 3-кортеж ``(dirpath, dirnames, "
"filenames)``."

msgid ""
"*dirpath* is a string, the path to the directory.  *dirnames* is a list of "
"the names of the subdirectories in *dirpath* (excluding ``'.'`` and "
"``'..'``). *filenames* is a list of the names of the non-directory files in "
"*dirpath*. Note that the names in the lists contain no path components.  To "
"get a full path (which begins with *top*) to a file or directory in "
"*dirpath*, do ``os.path.join(dirpath, name)``.  Whether or not the lists are "
"sorted depends on the file system.  If a file is removed from or added to "
"the *dirpath* directory during generating the lists, whether a name for that "
"file be included is unspecified."
msgstr ""
"*dirpath* — це рядок, шлях до каталогу. *dirnames* — це список імен "
"підкаталогів у *dirpath* (за винятком ``'.''`` і ``'..''``). *filenaname* — "
"це список імен файлів, які не є каталогами, у *dirpath*. Зауважте, що імена "
"в списках не містять компонентів шляху. Щоб отримати повний шлях (який "
"починається з *top*) до файлу або каталогу в *dirpath*, виконайте ``os.path."
"join(dirpath, name)``. Сортування списків залежить від файлової системи. "
"Якщо файл видаляється або додається до каталогу *dirpath* під час генерації "
"списків, не вказано, чи буде включено ім’я цього файлу."

msgid ""
"If optional argument *topdown* is ``True`` or not specified, the triple for "
"a directory is generated before the triples for any of its subdirectories "
"(directories are generated top-down).  If *topdown* is ``False``, the triple "
"for a directory is generated after the triples for all of its subdirectories "
"(directories are generated bottom-up). No matter the value of *topdown*, the "
"list of subdirectories is retrieved before the tuples for the directory and "
"its subdirectories are generated."
msgstr ""
"Якщо необов’язковий аргумент *topdown* має значення ``True`` або не вказано, "
"трійка для каталогу генерується перед потрійками для будь-якого з його "
"підкаталогів (каталоги генеруються зверху вниз). Якщо *topdown* має значення "
"``False``, трійка для каталогу генерується після трійок для всіх його "
"підкаталогів (каталоги генеруються знизу вгору). Незалежно від значення "
"*topdown*, список підкаталогів витягується до створення кортежів для "
"каталогу та його підкаталогів."

msgid ""
"When *topdown* is ``True``, the caller can modify the *dirnames* list in-"
"place (perhaps using :keyword:`del` or slice assignment), and :func:`walk` "
"will only recurse into the subdirectories whose names remain in *dirnames*; "
"this can be used to prune the search, impose a specific order of visiting, "
"or even to inform :func:`walk` about directories the caller creates or "
"renames before it resumes :func:`walk` again.  Modifying *dirnames* when "
"*topdown* is ``False`` has no effect on the behavior of the walk, because in "
"bottom-up mode the directories in *dirnames* are generated before *dirpath* "
"itself is generated."
msgstr ""
"Коли *topdown* має значення ``True``, абонент може змінювати список "
"*dirnames* на місці (можливо, використовуючи :keyword:`del` або призначення "
"фрагментів), а :func:`walk` повертатиметься лише до підкаталогів чиї імена "
"залишаються в *dirnames*; це можна використовувати для скорочення пошуку, "
"встановлення певного порядку відвідування або навіть для інформування :func:"
"`walk` про каталоги, які абонент створює або перейменовує перед тим, як він "
"знову продовжить :func:`walk`. Зміна *dirnames*, коли *topdown* має значення "
"``False``, не впливає на поведінку обходу, тому що в режимі знизу вгору "
"каталоги в *dirnames* генеруються до того, як буде згенеровано сам *dirpath*."

msgid ""
"By default, errors from the :func:`scandir` call are ignored.  If optional "
"argument *onerror* is specified, it should be a function; it will be called "
"with one argument, an :exc:`OSError` instance.  It can report the error to "
"continue with the walk, or raise the exception to abort the walk.  Note that "
"the filename is available as the ``filename`` attribute of the exception "
"object."
msgstr ""
"За замовчуванням помилки виклику :func:`scandir` ігноруються. Якщо вказано "
"необов’язковий аргумент *onerror*, це має бути функція; він буде викликаний "
"з одним аргументом, екземпляром :exc:`OSError`. Він може повідомити про "
"помилку, щоб продовжити обхід, або викликати виключення, щоб перервати "
"обхід. Зауважте, що назва файлу доступна як атрибут ``filename`` об’єкта "
"винятку."

msgid ""
"By default, :func:`walk` will not walk down into symbolic links that resolve "
"to directories. Set *followlinks* to ``True`` to visit directories pointed "
"to by symlinks, on systems that support them."
msgstr ""
"За замовчуванням :func:`walk` не переходитиме до символічних посилань, які "
"переходять до каталогів. Встановіть *followlinks* на ``True``, щоб "
"відвідувати каталоги, на які вказують символічні посилання, у системах, які "
"їх підтримують."

msgid ""
"Be aware that setting *followlinks* to ``True`` can lead to infinite "
"recursion if a link points to a parent directory of itself. :func:`walk` "
"does not keep track of the directories it visited already."
msgstr ""
"Майте на увазі, що встановлення *followlinks* значення ``True`` може "
"призвести до нескінченної рекурсії, якщо посилання вказує на батьківський "
"каталог самого себе. :func:`walk` не відстежує каталоги, які він уже "
"відвідав."

msgid ""
"If you pass a relative pathname, don't change the current working directory "
"between resumptions of :func:`walk`.  :func:`walk` never changes the current "
"directory, and assumes that its caller doesn't either."
msgstr ""
"Якщо ви передаєте відносний шлях, не змінюйте поточний робочий каталог між "
"відновленням :func:`walk`. :func:`walk` ніколи не змінює поточний каталог і "
"припускає, що його виклик теж не змінює."

msgid ""
"This example displays the number of bytes taken by non-directory files in "
"each directory under the starting directory, except that it doesn't look "
"under any CVS subdirectory::"
msgstr ""
"У цьому прикладі показано кількість байтів, зайнятих файлами, що не є "
"каталогами, у кожному каталозі в початковому каталозі, за винятком того, що "
"він не шукає підкаталог CVS::"

msgid ""
"In the next example (simple implementation of :func:`shutil.rmtree`), "
"walking the tree bottom-up is essential, :func:`rmdir` doesn't allow "
"deleting a directory before the directory is empty::"
msgstr ""
"У наступному прикладі (проста реалізація :func:`shutil.rmtree`) важливий "
"перехід по дереву знизу вгору, :func:`rmdir` не дозволяє видаляти каталог, "
"поки він не стане порожнім::"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.walk`` with arguments "
"``top``, ``topdown``, ``onerror``, ``followlinks``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.walk`` з аргументами ``top``, "
"``topdown``, ``onerror``, ``followlinks``."

msgid ""
"This function now calls :func:`os.scandir` instead of :func:`os.listdir`, "
"making it faster by reducing the number of calls to :func:`os.stat`."
msgstr ""
"Ця функція тепер викликає :func:`os.scandir` замість :func:`os.listdir`, що "
"робить її швидшою завдяки зменшенню кількості викликів до :func:`os.stat`."

msgid ""
"This behaves exactly like :func:`walk`, except that it yields a 4-tuple "
"``(dirpath, dirnames, filenames, dirfd)``, and it supports ``dir_fd``."
msgstr ""
"Це веде себе так само, як :func:`walk`, за винятком того, що дає 4-кортеж "
"``(dirpath, dirnames, filenames, dirfd)``, і підтримує ``dir_fd``."

msgid ""
"*dirpath*, *dirnames* and *filenames* are identical to :func:`walk` output, "
"and *dirfd* is a file descriptor referring to the directory *dirpath*."
msgstr ""
"*dirpath*, *dirnames* і *filenaname* ідентичні виводу :func:`walk`, а "
"*dirfd* є дескриптором файлу, який посилається на каталог *dirpath*."

msgid ""
"This function always supports :ref:`paths relative to directory descriptors "
"<dir_fd>` and :ref:`not following symlinks <follow_symlinks>`.  Note however "
"that, unlike other functions, the :func:`fwalk` default value for "
"*follow_symlinks* is ``False``."
msgstr ""
"Ця функція завжди підтримує :ref:`шляхи відносно дескрипторів каталогу "
"<dir_fd>` і :ref:`не наступні символічні посилання <follow_symlinks>`. Проте "
"зауважте, що, на відміну від інших функцій, значенням за замовчуванням :func:"
"`fwalk` для *follow_symlinks* є ``False``."

msgid ""
"Since :func:`fwalk` yields file descriptors, those are only valid until the "
"next iteration step, so you should duplicate them (e.g. with :func:`dup`) if "
"you want to keep them longer."
msgstr ""
"Оскільки :func:`fwalk` дає дескриптори файлів, вони дійсні лише до "
"наступного кроку ітерації, тому вам слід дублювати їх (наприклад, за "
"допомогою :func:`dup`), якщо ви хочете зберегти їх довше."

msgid ""
"In the next example, walking the tree bottom-up is essential: :func:`rmdir` "
"doesn't allow deleting a directory before the directory is empty::"
msgstr ""
"У наступному прикладі перехід по дереву знизу вгору важливий: :func:`rmdir` "
"не дозволяє видаляти каталог, поки каталог не буде порожнім::"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.fwalk`` with arguments "
"``top``, ``topdown``, ``onerror``, ``follow_symlinks``, ``dir_fd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.fwalk`` з аргументами ``top``, "
"``topdown``, ``onerror``, ``follow_symlinks``, ``dir_fd``."

msgid "Added support for :class:`bytes` paths."
msgstr "Додано підтримку шляхів :class:`bytes`."

msgid ""
"Create an anonymous file and return a file descriptor that refers to it. "
"*flags* must be one of the ``os.MFD_*`` constants available on the system "
"(or a bitwise ORed combination of them).  By default, the new file "
"descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"Створіть анонімний файл і поверніть дескриптор файлу, який посилається на "
"нього. *flags* має бути однією з констант ``os.MFD_*``, доступних у системі "
"(або їх побітовою комбінацією АБО). За замовчуванням новий файловий "
"дескриптор є :ref:`non-inheritable <fd_inheritance>`."

msgid ""
"The name supplied in *name* is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory ``/proc/self/"
"fd/``. The displayed name is always prefixed with ``memfd:`` and serves only "
"for debugging purposes. Names do not affect the behavior of the file "
"descriptor, and as such multiple files can have the same name without any "
"side effects."
msgstr ""
"Ім’я, указане в *name*, використовується як ім’я файлу та відображатиметься "
"як ціль відповідного символічного посилання в каталозі ``/proc/self/fd/``. "
"Ім’я, що відображається, завжди має префікс ``memfd:`` і служить лише для "
"цілей налагодження. Імена не впливають на поведінку файлового дескриптора, "
"тому кілька файлів можуть мати однакові назви без будь-яких побічних ефектів."

msgid ""
":ref:`Availability <availability>`: Linux 3.17 or newer with glibc 2.27 or "
"newer."
msgstr ""
":ref:`Наявність <availability>`: Linux 3.17 або новіша версія з glibc 2.27 "
"або новіша."

msgid "These flags can be passed to :func:`memfd_create`."
msgstr "Ці позначки можна передати в :func:`memfd_create`."

msgid ""
":ref:`Availability <availability>`: Linux 3.17 or newer with glibc 2.27 or "
"newer.  The ``MFD_HUGE*`` flags are only available since Linux 4.14."
msgstr ""
":ref:`Наявність <availability>`: Linux 3.17 або новіша версія з glibc 2.27 "
"або новіша. Прапорці ``MFD_HUGE*`` доступні лише з Linux 4.14."

msgid ""
"Create and return an event file descriptor. The file descriptors supports "
"raw :func:`read` and :func:`write` with a buffer size of 8, :func:`~select."
"select`, :func:`~select.poll` and similar. See man page :manpage:"
"`eventfd(2)` for more information.  By default, the new file descriptor is :"
"ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"Створити та повернути дескриптор файлу подій. Дескриптори файлів підтримують "
"raw :func:`read` і :func:`write` з розміром буфера 8, :func:`~select."
"select`, :func:`~select.poll` тощо. Додаткову інформацію дивіться на "
"сторінці довідки :manpage:`eventfd(2)`. За замовчуванням новий файловий "
"дескриптор є :ref:`non-inheritable <fd_inheritance>`."

msgid ""
"*initval* is the initial value of the event counter. The initial value must "
"be an 32 bit unsigned integer. Please note that the initial value is limited "
"to a 32 bit unsigned int although the event counter is an unsigned 64 bit "
"integer with a maximum value of 2\\ :sup:`64`\\ -\\ 2."
msgstr ""
"*initval* — початкове значення лічильника подій. Початкове значення має бути "
"32-розрядним цілим числом без знаку. Зауважте, що початкове значення "
"обмежене 32-бітним беззнаковим цілим числом, хоча лічильник подій є "
"беззнаковим 64-бітним цілим числом із максимальним значенням 2\\ :sup:`64`\\ "
"-\\ 2."

msgid ""
"*flags* can be constructed from :const:`EFD_CLOEXEC`, :const:`EFD_NONBLOCK`, "
"and :const:`EFD_SEMAPHORE`."
msgstr ""
"*прапори* можуть бути створені з :const:`EFD_CLOEXEC`, :const:`EFD_NONBLOCK` "
"і :const:`EFD_SEMAPHORE`."

msgid ""
"If :const:`EFD_SEMAPHORE` is specified and the event counter is non-zero, :"
"func:`eventfd_read` returns 1 and decrements the counter by one."
msgstr ""
"Якщо вказано :const:`EFD_SEMAPHORE` і лічильник подій ненульовий, :func:"
"`eventfd_read` повертає 1 і зменшує лічильник на одиницю."

msgid ""
"If :const:`EFD_SEMAPHORE` is not specified and the event counter is non-"
"zero, :func:`eventfd_read` returns the current event counter value and "
"resets the counter to zero."
msgstr ""
"Якщо :const:`EFD_SEMAPHORE` не вказано, а лічильник подій ненульовий, :func:"
"`eventfd_read` повертає поточне значення лічильника подій і скидає лічильник "
"до нуля."

msgid ""
"If the event counter is zero and :const:`EFD_NONBLOCK` is not specified, :"
"func:`eventfd_read` blocks."
msgstr ""
"Якщо лічильник подій дорівнює нулю і :const:`EFD_NONBLOCK` не вказано, :func:"
"`eventfd_read` блокує."

msgid ""
":func:`eventfd_write` increments the event counter. Write blocks if the "
"write operation would increment the counter to a value larger than 2\\ :sup:"
"`64`\\ -\\ 2."
msgstr ""
":func:`eventfd_write` збільшує лічильник подій. Блокує запис, якщо операція "
"запису збільшить лічильник до значення, більшого за 2\\ :sup:`64`\\ -\\ 2."

msgid ""
":ref:`Availability <availability>`: Linux 2.6.27 or newer with glibc 2.8 or "
"newer."
msgstr ""
":ref:`Наявність <availability>`: Linux 2.6.27 або новіша версія з glibc 2.8 "
"або новіша."

msgid ""
"Read value from an :func:`eventfd` file descriptor and return a 64 bit "
"unsigned int. The function does not verify that *fd* is an :func:`eventfd`."
msgstr ""
"Зчитування значення з дескриптора файлу :func:`eventfd` і повернення 64-"
"бітного беззнакового int. Функція не перевіряє, що *fd* є :func:`eventfd`."

msgid ":ref:`Availability <availability>`: See :func:`eventfd`"
msgstr ":ref:`Наявність <availability>`: Див. :func:`eventfd`"

msgid ""
"Add value to an :func:`eventfd` file descriptor. *value* must be a 64 bit "
"unsigned int. The function does not verify that *fd* is an :func:`eventfd`."
msgstr ""
"Додайте значення до дескриптора файлу :func:`eventfd`. *значення* має бути "
"64-бітним беззнаковим цілим. Функція не перевіряє, що *fd* є :func:`eventfd`."

msgid "Set close-on-exec flag for new :func:`eventfd` file descriptor."
msgstr ""
"Установіть прапорець close-on-exec для нового файлового дескриптора :func:"
"`eventfd`."

msgid ""
"Set :const:`O_NONBLOCK` status flag for new :func:`eventfd` file descriptor."
msgstr ""
"Установіть позначку статусу :const:`O_NONBLOCK` для нового файлового "
"дескриптора :func:`eventfd`."

msgid ""
"Provide semaphore-like semantics for reads from a :func:`eventfd` file "
"descriptor. On read the internal counter is decremented by one."
msgstr ""
"Забезпечте семантику, подібну до семафора, для читання з дескриптора файлу :"
"func:`eventfd`. Під час читання внутрішній лічильник зменшується на одиницю."

msgid ""
":ref:`Availability <availability>`: Linux 2.6.30 or newer with glibc 2.8 or "
"newer."
msgstr ""
":ref:`Наявність <availability>`: Linux 2.6.30 або новіша версія з glibc 2.8 "
"або новіша."

msgid "Linux extended attributes"
msgstr "Розширені атрибути Linux"

msgid "These functions are all available on Linux only."
msgstr "Усі ці функції доступні лише в Linux."

msgid ""
"Return the value of the extended filesystem attribute *attribute* for "
"*path*. *attribute* can be bytes or str (directly or indirectly through the :"
"class:`PathLike` interface). If it is str, it is encoded with the filesystem "
"encoding."
msgstr ""
"Повертає значення розширеного атрибута файлової системи *attribute* для "
"*path*. *attribute* може бути байтом або str (прямо чи опосередковано через "
"інтерфейс :class:`PathLike`). Якщо це str, воно закодовано з кодуванням "
"файлової системи."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.getxattr`` with arguments "
"``path``, ``attribute``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.getxattr`` з аргументами "
"``path``, ``attribute``."

msgid "Accepts a :term:`path-like object` for *path* and *attribute*."
msgstr "Приймає :term:`path-like object` для *path* і *attribute*."

msgid ""
"Return a list of the extended filesystem attributes on *path*.  The "
"attributes in the list are represented as strings decoded with the "
"filesystem encoding.  If *path* is ``None``, :func:`listxattr` will examine "
"the current directory."
msgstr ""
"Повертає список розширених атрибутів файлової системи за *шляхом*. Атрибути "
"в списку представлені як рядки, декодовані за допомогою кодування файлової "
"системи. Якщо *path* має значення ``None``, :func:`listxattr` перевірить "
"поточний каталог."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listxattr`` with argument "
"``path``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.listxattr`` з аргументом "
"``path``."

msgid ""
"Removes the extended filesystem attribute *attribute* from *path*. "
"*attribute* should be bytes or str (directly or indirectly through the :"
"class:`PathLike` interface). If it is a string, it is encoded with the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Видаляє розширений атрибут файлової системи *attribute* із *path*. "
"*attribute* має бути байтом або str (прямо чи опосередковано через "
"інтерфейс :class:`PathLike`). Якщо це рядок, він кодується за допомогою :"
"term:`filesystem encoding and error handler`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.removexattr`` with arguments "
"``path``, ``attribute``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.removexattr`` з аргументами "
"``path``, ``attribute``."

msgid ""
"Set the extended filesystem attribute *attribute* on *path* to *value*. "
"*attribute* must be a bytes or str with no embedded NULs (directly or "
"indirectly through the :class:`PathLike` interface). If it is a str, it is "
"encoded with the :term:`filesystem encoding and error handler`.  *flags* may "
"be :data:`XATTR_REPLACE` or :data:`XATTR_CREATE`. If :data:`XATTR_REPLACE` "
"is given and the attribute does not exist, ``ENODATA`` will be raised. If :"
"data:`XATTR_CREATE` is given and the attribute already exists, the attribute "
"will not be created and ``EEXISTS`` will be raised."
msgstr ""
"Установіть *attribute* розширеного атрибута файлової системи на *path* у "
"*value*. *атрибут* має бути байтом або рядком без вбудованих NUL (прямо чи "
"опосередковано через інтерфейс :class:`PathLike`). Якщо це str, він "
"закодований за допомогою :term:`filesystem encoding and error handler`. "
"*прапорцями* можуть бути :data:`XATTR_REPLACE` або :data:`XATTR_CREATE`. "
"Якщо задано :data:`XATTR_REPLACE`, а атрибут не існує, буде створено "
"``ENODATA``. Якщо задано :data:`XATTR_CREATE` і атрибут уже існує, атрибут "
"не буде створено, і буде викликано ``EEXISTS``."

msgid ""
"A bug in Linux kernel versions less than 2.6.39 caused the flags argument to "
"be ignored on some filesystems."
msgstr ""
"Помилка у версіях ядра Linux до 2.6.39 спричинила ігнорування аргументу "
"flags у деяких файлових системах."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.setxattr`` with arguments "
"``path``, ``attribute``, ``value``, ``flags``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.setxattr`` з аргументами "
"``path``, ``attribute``, ``value``, ``flags``."

msgid ""
"The maximum size the value of an extended attribute can be. Currently, this "
"is 64 KiB on Linux."
msgstr ""
"Максимальний розмір значення розширеного атрибута. На даний момент це 64 КіБ "
"на Linux."

msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must create an attribute."
msgstr ""
"Це можливе значення для аргументу flags у :func:`setxattr`. Це вказує, що "
"операція повинна створити атрибут."

msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must replace an existing attribute."
msgstr ""
"Це можливе значення для аргументу flags у :func:`setxattr`. Це означає, що "
"операція повинна замінити існуючий атрибут."

msgid "Process Management"
msgstr "Управління процесами"

msgid "These functions may be used to create and manage processes."
msgstr ""
"Ці функції можна використовувати для створення процесів і керування ними."

msgid ""
"The various :func:`exec\\* <execl>` functions take a list of arguments for "
"the new program loaded into the process.  In each case, the first of these "
"arguments is passed to the new program as its own name rather than as an "
"argument a user may have typed on a command line.  For the C programmer, "
"this is the ``argv[0]`` passed to a program's :c:func:`main`.  For example, "
"``os.execv('/bin/echo', ['foo', 'bar'])`` will only print ``bar`` on "
"standard output; ``foo`` will seem to be ignored."
msgstr ""
"Різні функції :func:`exec\\* <execl>` приймають список аргументів для нової "
"програми, завантаженої в процес. У кожному випадку перший із цих аргументів "
"передається новій програмі як її власне ім’я, а не як аргумент, який "
"користувач міг ввести в командному рядку. Для програміста на C це "
"``argv[0]``, що передається до :c:func:`main` програми. Наприклад, ``os."
"execv('/bin/echo', ['foo', 'bar'])`` виведе лише ``bar`` на стандартному "
"виводі; ``foo`` буде проігноровано."

msgid ""
"Generate a :const:`SIGABRT` signal to the current process.  On Unix, the "
"default behavior is to produce a core dump; on Windows, the process "
"immediately returns an exit code of ``3``.  Be aware that calling this "
"function will not call the Python signal handler registered for :const:"
"`SIGABRT` with :func:`signal.signal`."
msgstr ""
"Згенерувати сигнал :const:`SIGABRT` для поточного процесу. В Unix типовою "
"поведінкою є створення дампа ядра; у Windows процес негайно повертає код "
"виходу ``3``. Майте на увазі, що виклик цієї функції не викличе обробник "
"сигналів Python, зареєстрований для :const:`SIGABRT` з :func:`signal.signal`."

msgid "Add a path to the DLL search path."
msgstr "Додайте шлях до шляху пошуку DLL."

msgid ""
"This search path is used when resolving dependencies for imported extension "
"modules (the module itself is resolved through :data:`sys.path`), and also "
"by :mod:`ctypes`."
msgstr ""
"Цей шлях пошуку використовується під час вирішення залежностей для "
"імпортованих модулів розширення (сам модуль вирішується за допомогою :data:"
"`sys.path`), а також за допомогою :mod:`ctypes`."

msgid ""
"Remove the directory by calling **close()** on the returned object or using "
"it in a :keyword:`with` statement."
msgstr ""
"Видаліть каталог, викликавши **close()** для повернутого об’єкта або "
"використовуючи його в операторі :keyword:`with`."

msgid ""
"See the `Microsoft documentation <https://msdn.microsoft."
"com/44228cf2-6306-466c-8f16-f513cd3ba8b5>`_ for more information about how "
"DLLs are loaded."
msgstr ""
"Перегляньте `документацію Microsoft <https://msdn.microsoft."
"com/44228cf2-6306-466c-8f16-f513cd3ba8b5>`_, щоб дізнатися більше про те, як "
"завантажуються DLL."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.add_dll_directory`` with "
"argument ``path``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.add_dll_directory`` з "
"аргументом ``path``."

msgid ""
"Previous versions of CPython would resolve DLLs using the default behavior "
"for the current process. This led to inconsistencies, such as only sometimes "
"searching :envvar:`PATH` or the current working directory, and OS functions "
"such as ``AddDllDirectory`` having no effect."
msgstr ""
"Попередні версії CPython вирішували DLL, використовуючи типову поведінку для "
"поточного процесу. Це призвело до неузгодженості, наприклад лише іноді "
"пошук :envvar:`PATH` або поточного робочого каталогу, а функції ОС, такі як "
"``AddDllDirectory``, не мали ефекту."

msgid ""
"In 3.8, the two primary ways DLLs are loaded now explicitly override the "
"process-wide behavior to ensure consistency. See the :ref:`porting notes "
"<bpo-36085-whatsnew>` for information on updating libraries."
msgstr ""
"У версії 3.8 два основні способи завантаження бібліотек DLL тепер явно "
"замінюють поведінку всього процесу, щоб забезпечити узгодженість. "
"Перегляньте :ref:`нотатки щодо портування <bpo-36085-whatsnew>`, щоб "
"отримати інформацію щодо оновлення бібліотек."

msgid ""
"These functions all execute a new program, replacing the current process; "
"they do not return.  On Unix, the new executable is loaded into the current "
"process, and will have the same process id as the caller.  Errors will be "
"reported as :exc:`OSError` exceptions."
msgstr ""
"Усі ці функції виконують нову програму, замінюючи поточний процес; вони не "
"повертаються. В Unix новий виконуваний файл завантажується в поточний процес "
"і матиме той самий ідентифікатор процесу, що й виклик. Помилки "
"повідомлятимуться як винятки :exc:`OSError`."

msgid ""
"The current process is replaced immediately. Open file objects and "
"descriptors are not flushed, so if there may be data buffered on these open "
"files, you should flush them using :func:`sys.stdout.flush` or :func:`os."
"fsync` before calling an :func:`exec\\* <execl>` function."
msgstr ""
"Поточний процес негайно замінюється. Відкриті файлові об’єкти та дескриптори "
"не скидаються, тому, якщо у цих відкритих файлах можуть бути буферизовані "
"дані, вам слід очистити їх за допомогою :func:`sys.stdout.flush` або :func:"
"`os.fsync` перед викликом :func:`exec\\* <execl>` функція."

msgid ""
"The \"l\" and \"v\" variants of the :func:`exec\\* <execl>` functions differ "
"in how command-line arguments are passed.  The \"l\" variants are perhaps "
"the easiest to work with if the number of parameters is fixed when the code "
"is written; the individual parameters simply become additional parameters to "
"the :func:`execl\\*` functions.  The \"v\" variants are good when the number "
"of parameters is variable, with the arguments being passed in a list or "
"tuple as the *args* parameter.  In either case, the arguments to the child "
"process should start with the name of the command being run, but this is not "
"enforced."
msgstr ""
"Варіанти \"l\" і \"v\" функцій :func:`exec\\* <execl>` відрізняються "
"способом передачі аргументів командного рядка. Варіанти \"l\", мабуть, "
"найлегші для роботи, якщо кількість параметрів фіксована під час написання "
"коду; окремі параметри просто стають додатковими параметрами до функцій :"
"func:`execl\\*`. Варіанти \"v\" хороші, коли кількість параметрів є змінною, "
"а аргументи передаються у списку або кортежі як параметр *args*. У будь-"
"якому випадку аргументи дочірнього процесу мають починатися з назви команди, "
"що виконується, але це не виконується."

msgid ""
"The variants which include a \"p\" near the end (:func:`execlp`, :func:"
"`execlpe`, :func:`execvp`, and :func:`execvpe`) will use the :envvar:`PATH` "
"environment variable to locate the program *file*.  When the environment is "
"being replaced (using one of the :func:`exec\\*e <execl>` variants, "
"discussed in the next paragraph), the new environment is used as the source "
"of the :envvar:`PATH` variable. The other variants, :func:`execl`, :func:"
"`execle`, :func:`execv`, and :func:`execve`, will not use the :envvar:`PATH` "
"variable to locate the executable; *path* must contain an appropriate "
"absolute or relative path."
msgstr ""
"Варіанти, які включають \"p\" у кінці (:func:`execlp`, :func:`execlpe`, :"
"func:`execvp` і :func:`execvpe`) використовуватимуть :envvar:`PATH` змінна "
"середовища, щоб знайти *файл* програми. Коли середовище замінюється (з "
"використанням одного з варіантів :func:`exec\\*e <execl>`, розглянутих у "
"наступному абзаці), нове середовище використовується як джерело змінної :"
"envvar:`PATH`. Інші варіанти, :func:`execl`, :func:`execle`, :func:`execv` "
"і :func:`execve`, не використовуватимуть змінну :envvar:`PATH` для пошуку "
"виконуваного файлу; *path* повинен містити відповідний абсолютний або "
"відносний шлях."

msgid ""
"For :func:`execle`, :func:`execlpe`, :func:`execve`, and :func:`execvpe` "
"(note that these all end in \"e\"), the *env* parameter must be a mapping "
"which is used to define the environment variables for the new process (these "
"are used instead of the current process' environment); the functions :func:"
"`execl`, :func:`execlp`, :func:`execv`, and :func:`execvp` all cause the new "
"process to inherit the environment of the current process."
msgstr ""
"Для :func:`execle`, :func:`execlpe`, :func:`execve` і :func:`execvpe` "
"(зауважте, що всі вони закінчуються на \"e\"), параметр *env* має бути "
"зіставленням який використовується для визначення змінних середовища для "
"нового процесу (вони використовуються замість середовища поточного процесу); "
"функції :func:`execl`, :func:`execlp`, :func:`execv` і :func:`execvp` "
"змушують новий процес успадковувати середовище поточного процесу."

msgid ""
"For :func:`execve` on some platforms, *path* may also be specified as an "
"open file descriptor.  This functionality may not be supported on your "
"platform; you can check whether or not it is available using :data:`os."
"supports_fd`. If it is unavailable, using it will raise a :exc:"
"`NotImplementedError`."
msgstr ""
"Для :func:`execve` на деяких платформах *шлях* також може бути вказаний як "
"дескриптор відкритого файлу. Ця функція може не підтримуватися на вашій "
"платформі; ви можете перевірити, чи він доступний, за допомогою :data:`os."
"supports_fd`. Якщо він недоступний, його використання призведе до помилки :"
"exc:`NotImplementedError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.exec`` with arguments "
"``path``, ``args``, ``env``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.exec`` з аргументами ``path``, "
"``args``, ``env``."

msgid ""
"Added support for specifying *path* as an open file descriptor for :func:"
"`execve`."
msgstr ""
"Додано підтримку вказівки *шляху* як дескриптора відкритого файлу для :func:"
"`execve`."

msgid ""
"Exit the process with status *n*, without calling cleanup handlers, flushing "
"stdio buffers, etc."
msgstr ""
"Вийдіть із процесу зі статусом *n*, без виклику обробників очищення, "
"очищення буферів stdio тощо."

msgid ""
"The standard way to exit is ``sys.exit(n)``.  :func:`_exit` should normally "
"only be used in the child process after a :func:`fork`."
msgstr ""
"Стандартним способом виходу є ``sys.exit(n)``. :func:`_exit` зазвичай слід "
"використовувати лише в дочірньому процесі після :func:`fork`."

msgid ""
"The following exit codes are defined and can be used with :func:`_exit`, "
"although they are not required.  These are typically used for system "
"programs written in Python, such as a mail server's external command "
"delivery program."
msgstr ""
"Наступні коди виходу визначені та можуть використовуватися з :func:`_exit`, "
"хоча вони не є обов’язковими. Зазвичай вони використовуються для системних "
"програм, написаних мовою Python, таких як зовнішня програма доставки команд "
"поштового сервера."

msgid ""
"Some of these may not be available on all Unix platforms, since there is "
"some variation.  These constants are defined where they are defined by the "
"underlying platform."
msgstr ""
"Деякі з них можуть бути недоступні на всіх платформах Unix, оскільки існують "
"певні відмінності. Ці константи визначені там, де вони визначені базовою "
"платформою."

msgid "Exit code that means no error occurred."
msgstr ""

msgid ""
"Exit code that means the command was used incorrectly, such as when the "
"wrong number of arguments are given."
msgstr ""
"Код виходу, який означає, що команда була використана неправильно, "
"наприклад, коли вказано неправильну кількість аргументів."

msgid "Exit code that means the input data was incorrect."
msgstr "Код виходу, який означає, що введені дані були неправильними."

msgid "Exit code that means an input file did not exist or was not readable."
msgstr "Код виходу, який означає, що вхідний файл не існував або не читався."

msgid "Exit code that means a specified user did not exist."
msgstr "Код виходу, який означає, що вказаний користувач не існував."

msgid "Exit code that means a specified host did not exist."
msgstr "Код виходу, який означає, що вказаний хост не існував."

msgid "Exit code that means that a required service is unavailable."
msgstr "Код виходу, який означає, що потрібна послуга недоступна."

msgid "Exit code that means an internal software error was detected."
msgstr ""
"Код виходу, який означає, що виявлено внутрішню помилку програмного "
"забезпечення."

msgid ""
"Exit code that means an operating system error was detected, such as the "
"inability to fork or create a pipe."
msgstr ""
"Код виходу, який означає, що виявлено помилку операційної системи, наприклад "
"неможливість розгалуження або створення каналу."

msgid ""
"Exit code that means some system file did not exist, could not be opened, or "
"had some other kind of error."
msgstr ""
"Код виходу, який означає, що якийсь системний файл не існував, його "
"неможливо відкрити або якийсь інший тип помилки."

msgid "Exit code that means a user specified output file could not be created."
msgstr ""
"Код виходу означає, що вказаний користувачем вихідний файл неможливо "
"створити."

msgid ""
"Exit code that means that an error occurred while doing I/O on some file."
msgstr ""
"Код виходу, який означає, що сталася помилка під час виконання вводу-виводу "
"для деякого файлу."

msgid ""
"Exit code that means a temporary failure occurred.  This indicates something "
"that may not really be an error, such as a network connection that couldn't "
"be made during a retryable operation."
msgstr ""
"Код виходу, який означає, що стався тимчасовий збій. Це вказує на те, що "
"насправді не може бути помилкою, наприклад мережеве підключення, яке не "
"вдалося встановити під час повторної операції."

msgid ""
"Exit code that means that a protocol exchange was illegal, invalid, or not "
"understood."
msgstr ""
"Код виходу, який означає, що обмін протоколом був незаконним, недійсним або "
"незрозумілим."

msgid ""
"Exit code that means that there were insufficient permissions to perform the "
"operation (but not intended for file system problems)."
msgstr ""
"Код виходу, який означає, що було недостатньо дозволів для виконання "
"операції (але не призначений для проблем файлової системи)."

msgid "Exit code that means that some kind of configuration error occurred."
msgstr "Код виходу, який означає, що сталася якась помилка конфігурації."

msgid "Exit code that means something like \"an entry was not found\"."
msgstr "Код виходу, який означає щось на зразок \"запис не знайдено\"."

msgid ""
"Fork a child process.  Return ``0`` in the child and the child's process id "
"in the parent.  If an error occurs :exc:`OSError` is raised."
msgstr ""
"Розгалужуйте дочірній процес. Повертає ``0`` у дочірньому процесі та "
"ідентифікатор дочірнього процесу в батьківському. У разі виникнення помилки "
"виникає :exc:`OSError`."

msgid ""
"Note that some platforms including FreeBSD <= 6.3 and Cygwin have known "
"issues when using ``fork()`` from a thread."
msgstr ""
"Зауважте, що деякі платформи, включаючи FreeBSD <= 6.3 і Cygwin, мають "
"відомі проблеми під час використання ``fork()`` із потоку."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.fork`` with no arguments."
msgstr "Викликає :ref:`подію аудиту <auditing>` ``os.fork`` без аргументів."

msgid ""
"Calling ``fork()`` in a subinterpreter is no longer supported (:exc:"
"`RuntimeError` is raised)."
msgstr ""
"Виклик ``fork()`` у підінтерпретаторі більше не підтримується (виникає :exc:"
"`RuntimeError`)."

msgid "See :mod:`ssl` for applications that use the SSL module with fork()."
msgstr ""
"Перегляньте :mod:`ssl` для програм, які використовують модуль SSL із fork()."

msgid ""
"Fork a child process, using a new pseudo-terminal as the child's controlling "
"terminal. Return a pair of ``(pid, fd)``, where *pid* is ``0`` in the child, "
"the new child's process id in the parent, and *fd* is the file descriptor of "
"the master end of the pseudo-terminal.  For a more portable approach, use "
"the :mod:`pty` module.  If an error occurs :exc:`OSError` is raised."
msgstr ""
"Розгалужуйте дочірній процес, використовуючи новий псевдотермінал як "
"керуючий термінал дочірнього процесу. Повертає пару ``(pid, fd)``, де *pid* "
"є ``0`` у дочірньому, ідентифікатор нового дочірнього процесу в "
"батьківському, а *fd* є дескриптором файлу головного кінця псевдотермінал. "
"Для більш портативного підходу використовуйте модуль :mod:`pty`. У разі "
"виникнення помилки виникає :exc:`OSError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.forkpty`` with no arguments."
msgstr "Викликає :ref:`подію аудиту <auditing>` ``os.forkpty`` без аргументів."

msgid ""
"Calling ``forkpty()`` in a subinterpreter is no longer supported (:exc:"
"`RuntimeError` is raised)."
msgstr ""
"Виклик ``forkpty()`` у підінтерпретаторі більше не підтримується (виникає :"
"exc:`RuntimeError`)."

msgid ""
"Send signal *sig* to the process *pid*.  Constants for the specific signals "
"available on the host platform are defined in the :mod:`signal` module."
msgstr ""
"Надішліть сигнал *sig* процесу *pid*. Константи для конкретних сигналів, "
"доступних на хост-платформі, визначаються в модулі :mod:`signal`."

msgid ""
"Windows: The :data:`signal.CTRL_C_EVENT` and :data:`signal.CTRL_BREAK_EVENT` "
"signals are special signals which can only be sent to console processes "
"which share a common console window, e.g., some subprocesses. Any other "
"value for *sig* will cause the process to be unconditionally killed by the "
"TerminateProcess API, and the exit code will be set to *sig*. The Windows "
"version of :func:`kill` additionally takes process handles to be killed."
msgstr ""
"Windows: Сигнали :data:`signal.CTRL_C_EVENT` і :data:`signal."
"CTRL_BREAK_EVENT` є спеціальними сигналами, які можна надсилати лише "
"процесам консолі, які мають спільне вікно консолі, наприклад, деякі "
"підпроцеси. Будь-яке інше значення для *sig* спричинить безумовне припинення "
"процесу API TerminateProcess, а код виходу буде встановлено на *sig*. "
"Версія :func:`kill` для Windows додатково приймає дескриптори процесу, які "
"потрібно знищити."

msgid "See also :func:`signal.pthread_kill`."
msgstr "Дивіться також :func:`signal.pthread_kill`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.kill`` with arguments "
"``pid``, ``sig``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.kill`` з аргументами ``pid``, "
"``sig``."

msgid "Windows support."
msgstr "Підтримка Windows."

msgid "Send the signal *sig* to the process group *pgid*."
msgstr "Надішліть сигнал *sig* до групи процесів *pgid*."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.killpg`` with arguments "
"``pgid``, ``sig``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.killpg`` з аргументами "
"``pgid``, ``sig``."

msgid ""
"Add *increment* to the process's \"niceness\".  Return the new niceness."
msgstr ""
"Додайте *приріст* до \"витонченості\" процесу. Поверніть нову привабливість."

msgid ""
"Return a file descriptor referring to the process *pid*.  This descriptor "
"can be used to perform process management without races and signals.  The "
"*flags* argument is provided for future extensions; no flag values are "
"currently defined."
msgstr ""
"Повертає дескриптор файлу, який посилається на процес *pid*. Цей дескриптор "
"можна використовувати для керування процесом без перегонів і сигналів. "
"Аргумент *flags* надається для майбутніх розширень; значення прапорів наразі "
"не визначено."

msgid "See the :manpage:`pidfd_open(2)` man page for more details."
msgstr ""
"Додаткову інформацію можна знайти на сторінці довідки :manpage:"
"`pidfd_open(2)`."

msgid ":ref:`Availability <availability>`: Linux 5.3+"
msgstr ":ref:`Доступність <availability>`: Linux 5.3+"

msgid ""
"Lock program segments into memory.  The value of *op* (defined in ``<sys/"
"lock.h>``) determines which segments are locked."
msgstr ""
"Блокування сегментів програми в пам'яті. Значення *op* (визначене в ``<sys/"
"lock.h>``) визначає, які сегменти заблоковано."

msgid ""
"Open a pipe to or from command *cmd*. The return value is an open file "
"object connected to the pipe, which can be read or written depending on "
"whether *mode* is ``'r'`` (default) or ``'w'``. The *buffering* argument has "
"the same meaning as the corresponding argument to the built-in :func:`open` "
"function. The returned file object reads or writes text strings rather than "
"bytes."
msgstr ""

msgid ""
"The ``close`` method returns :const:`None` if the subprocess exited "
"successfully, or the subprocess's return code if there was an error. On "
"POSIX systems, if the return code is positive it represents the return value "
"of the process left-shifted by one byte.  If the return code is negative, "
"the process was terminated by the signal given by the negated value of the "
"return code.  (For example, the return value might be ``- signal.SIGKILL`` "
"if the subprocess was killed.)  On Windows systems, the return value "
"contains the signed integer return code from the child process."
msgstr ""
"Метод ``close`` повертає :const:`None`, якщо підпроцес завершився успішно, "
"або код повернення підпроцесу, якщо сталася помилка. У системах POSIX, якщо "
"код повернення позитивний, він представляє значення, що повертається "
"процесом, зміщене вліво на один байт. Якщо код повернення від’ємний, це "
"означає, що процес було припинено за допомогою сигналу, поданого зведеним "
"значенням коду повернення. (Наприклад, значення, що повертається, може бути "
"``- signal.SIGKILL``, якщо підпроцес було закрито.) У системах Windows "
"значення, що повертається, містить цілочисельний код повернення зі знаком "
"від дочірнього процесу."

msgid ""
"On Unix, :func:`waitstatus_to_exitcode` can be used to convert the ``close`` "
"method result (exit status) into an exit code if it is not ``None``. On "
"Windows, the ``close`` method result is directly the exit code (or ``None``)."
msgstr ""
"В Unix :func:`waitstatus_to_exitcode` можна використовувати для перетворення "
"результату методу ``close`` (статус виходу) у код виходу, якщо він не "
"``None``. У Windows результатом методу ``close`` є безпосередньо код виходу "
"(або ``None``)."

msgid ""
"This is implemented using :class:`subprocess.Popen`; see that class's "
"documentation for more powerful ways to manage and communicate with "
"subprocesses."
msgstr ""
"Це реалізовано за допомогою :class:`subprocess.Popen`; перегляньте "
"документацію цього класу, щоб дізнатися про більш потужні способи керування "
"підпроцесами та спілкування з ними."

msgid "Wraps the :c:func:`posix_spawn` C library API for use from Python."
msgstr ""
"Обгортає API бібліотеки C :c:func:`posix_spawn` для використання з Python."

msgid ""
"Most users should use :func:`subprocess.run` instead of :func:`posix_spawn`."
msgstr ""
"Більшість користувачів повинні використовувати :func:`subprocess.run` "
"замість :func:`posix_spawn`."

msgid ""
"The positional-only arguments *path*, *args*, and *env* are similar to :func:"
"`execve`."
msgstr ""
"Лише позиційні аргументи *path*, *args* і *env* подібні до :func:`execve`."

msgid ""
"The *path* parameter is the path to the executable file.  The *path* should "
"contain a directory.  Use :func:`posix_spawnp` to pass an executable file "
"without directory."
msgstr ""
"Параметр *path* — це шлях до виконуваного файлу. *Шлях* має містити каталог. "
"Використовуйте :func:`posix_spawnp`, щоб передати виконуваний файл без "
"каталогу."

msgid ""
"The *file_actions* argument may be a sequence of tuples describing actions "
"to take on specific file descriptors in the child process between the C "
"library implementation's :c:func:`fork` and :c:func:`exec` steps. The first "
"item in each tuple must be one of the three type indicator listed below "
"describing the remaining tuple elements:"
msgstr ""
"Аргумент *file_actions* може бути послідовністю кортежів, що описують дії, "
"які потрібно виконати над певними дескрипторами файлів у дочірньому процесі "
"між кроками :c:func:`fork` і :c:func:`exec` реалізації бібліотеки C. Перший "
"елемент у кожному кортежі має бути одним із трьох наведених нижче "
"індикаторів типу, що описують інші елементи кортежу:"

msgid "(``os.POSIX_SPAWN_OPEN``, *fd*, *path*, *flags*, *mode*)"
msgstr "(``os.POSIX_SPAWN_OPEN``, *fd*, *шлях*, *прапори*, *режим*)"

msgid "Performs ``os.dup2(os.open(path, flags, mode), fd)``."
msgstr "Виконує ``os.dup2(os.open(path, flags, mode), fd)``."

msgid "(``os.POSIX_SPAWN_CLOSE``, *fd*)"
msgstr "(``os.POSIX_SPAWN_CLOSE``, *fd*)"

msgid "Performs ``os.close(fd)``."
msgstr "Виконує ``os.close(fd)``."

msgid "(``os.POSIX_SPAWN_DUP2``, *fd*, *new_fd*)"
msgstr "(``os.POSIX_SPAWN_DUP2``, *fd*, *new_fd*)"

msgid "Performs ``os.dup2(fd, new_fd)``."
msgstr "Виконує ``os.dup2(fd, new_fd)``."

msgid ""
"These tuples correspond to the C library :c:func:"
"`posix_spawn_file_actions_addopen`, :c:func:"
"`posix_spawn_file_actions_addclose`, and :c:func:"
"`posix_spawn_file_actions_adddup2` API calls used to prepare for the :c:func:"
"`posix_spawn` call itself."
msgstr ""
"Ці кортежі відповідають викликам API бібліотеки C :c:func:"
"`posix_spawn_file_actions_addopen`, :c:func:"
"`posix_spawn_file_actions_addclose` і :c:func:"
"`posix_spawn_file_actions_adddup2`, які використовуються для підготовки до "
"виклику :c:func:`posix_spawn` себе."

msgid ""
"The *setpgroup* argument will set the process group of the child to the "
"value specified. If the value specified is 0, the child's process group ID "
"will be made the same as its process ID. If the value of *setpgroup* is not "
"set, the child will inherit the parent's process group ID. This argument "
"corresponds to the C library :c:data:`POSIX_SPAWN_SETPGROUP` flag."
msgstr ""
"Аргумент *setpgroup* встановить групу дочірніх процесів на вказане значення. "
"Якщо вказане значення дорівнює 0, ідентифікатор групи дочірнього процесу "
"буде таким самим, як ідентифікатор її процесу. Якщо значення *setpgroup* не "
"встановлено, дочірній процес успадкує ідентифікатор групи батьківського "
"процесу. Цей аргумент відповідає позначці бібліотеки C :c:data:"
"`POSIX_SPAWN_SETPGROUP`."

msgid ""
"If the *resetids* argument is ``True`` it will reset the effective UID and "
"GID of the child to the real UID and GID of the parent process. If the "
"argument is ``False``, then the child retains the effective UID and GID of "
"the parent. In either case, if the set-user-ID and set-group-ID permission "
"bits are enabled on the executable file, their effect will override the "
"setting of the effective UID and GID. This argument corresponds to the C "
"library :c:data:`POSIX_SPAWN_RESETIDS` flag."
msgstr ""
"Якщо аргумент *resetids* має значення ``True``, ефективний UID і GID "
"дочірнього процесу буде скинуто до реального UID і GID батьківського "
"процесу. Якщо аргумент ``False``, тоді дочірній елемент зберігає ефективний "
"UID та GID батьківського. У будь-якому випадку, якщо біти дозволу set-user-"
"ID і set-group-ID увімкнуто для виконуваного файлу, їх дія перевизначить "
"налаштування ефективного UID і GID. Цей аргумент відповідає позначці "
"бібліотеки C :c:data:`POSIX_SPAWN_RESETIDS`."

msgid ""
"If the *setsid* argument is ``True``, it will create a new session ID for "
"`posix_spawn`. *setsid* requires :c:data:`POSIX_SPAWN_SETSID` or :c:data:"
"`POSIX_SPAWN_SETSID_NP` flag. Otherwise, :exc:`NotImplementedError` is "
"raised."
msgstr ""
"Якщо аргумент *setsid* має значення ``True``, він створить новий "
"ідентифікатор сеансу для `posix_spawn`. *setsid* потребує позначки :c:data:"
"`POSIX_SPAWN_SETSID` або :c:data:`POSIX_SPAWN_SETSID_NP`. В іншому випадку "
"виникає :exc:`NotImplementedError`."

msgid ""
"The *setsigmask* argument will set the signal mask to the signal set "
"specified. If the parameter is not used, then the child inherits the "
"parent's signal mask. This argument corresponds to the C library :c:data:"
"`POSIX_SPAWN_SETSIGMASK` flag."
msgstr ""
"Аргумент *setsigmask* встановить маску сигналу на вказаний набір сигналів. "
"Якщо параметр не використовується, то нащадок успадковує сигнальну маску "
"батька. Цей аргумент відповідає прапорцю бібліотеки C :c:data:"
"`POSIX_SPAWN_SETSIGMASK`."

msgid ""
"The *sigdef* argument will reset the disposition of all signals in the set "
"specified. This argument corresponds to the C library :c:data:"
"`POSIX_SPAWN_SETSIGDEF` flag."
msgstr ""
"Аргумент *sigdef* скине розташування всіх сигналів у вказаному наборі. Цей "
"аргумент відповідає позначці бібліотеки C :c:data:`POSIX_SPAWN_SETSIGDEF`."

msgid ""
"The *scheduler* argument must be a tuple containing the (optional) scheduler "
"policy and an instance of :class:`sched_param` with the scheduler "
"parameters. A value of ``None`` in the place of the scheduler policy "
"indicates that is not being provided. This argument is a combination of the "
"C library :c:data:`POSIX_SPAWN_SETSCHEDPARAM` and :c:data:"
"`POSIX_SPAWN_SETSCHEDULER` flags."
msgstr ""
"Аргумент *scheduler* має бути кортежем, що містить (необов’язкову) політику "
"планувальника та екземпляр :class:`sched_param` з параметрами планувальника. "
"Значення ``None`` замість політики планувальника вказує, що не надається. "
"Цей аргумент є комбінацією прапорів бібліотеки C :c:data:"
"`POSIX_SPAWN_SETSCHEDPARAM` і :c:data:`POSIX_SPAWN_SETSCHEDULER`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.posix_spawn`` with arguments "
"``path``, ``argv``, ``env``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.posix_spawn`` з аргументами "
"``path``, ``argv``, ``env``."

msgid "Wraps the :c:func:`posix_spawnp` C library API for use from Python."
msgstr ""
"Обгортає API бібліотеки C :c:func:`posix_spawnp` для використання з Python."

msgid ""
"Similar to :func:`posix_spawn` except that the system searches for the "
"*executable* file in the list of directories specified by the :envvar:`PATH` "
"environment variable (in the same way as for ``execvp(3)``)."
msgstr ""
"Подібно до :func:`posix_spawn`, за винятком того, що система шукає "
"*виконуваний* файл у списку каталогів, визначених змінною середовища :envvar:"
"`PATH` (так само, як і для ``execvp(3)`` )."

msgid ""
":ref:`Availability <availability>`: See :func:`posix_spawn` documentation."
msgstr ""
":ref:`Доступність <availability>`: Див. документацію :func:`posix_spawn`."

msgid ""
"Register callables to be executed when a new child process is forked using :"
"func:`os.fork` or similar process cloning APIs. The parameters are optional "
"and keyword-only. Each specifies a different call point."
msgstr ""
"Зареєструйте виклики, які будуть виконуватися, коли новий дочірній процес "
"розгалужується за допомогою :func:`os.fork` або аналогічного API клонування "
"процесу. Параметри є необов’язковими та містять лише ключові слова. Кожен із "
"них визначає окремий пункт виклику."

msgid "*before* is a function called before forking a child process."
msgstr ""
"*before* — це функція, яка викликається перед розгалуженням дочірнього "
"процесу."

msgid ""
"*after_in_parent* is a function called from the parent process after forking "
"a child process."
msgstr ""
"*after_in_parent* — це функція, яка викликається з батьківського процесу "
"після розгалуження дочірнього процесу."

msgid "*after_in_child* is a function called from the child process."
msgstr "*after_in_child* — це функція, яка викликається з дочірнього процесу."

msgid ""
"These calls are only made if control is expected to return to the Python "
"interpreter.  A typical :mod:`subprocess` launch will not trigger them as "
"the child is not going to re-enter the interpreter."
msgstr ""
"Ці виклики здійснюються лише в тому випадку, якщо очікується, що контроль "
"повернеться до інтерпретатора Python. Типовий запуск підпроцесу :mod:"
"`subprocess` не запустить їх, оскільки дитина не збирається повторно входити "
"в інтерпретатор."

msgid ""
"Functions registered for execution before forking are called in reverse "
"registration order.  Functions registered for execution after forking "
"(either in the parent or in the child) are called in registration order."
msgstr ""
"Функції, зареєстровані для виконання перед розгалуженням, викликаються у "
"зворотному порядку реєстрації. Функції, зареєстровані для виконання після "
"розгалуження (або в батьківському, або в дочірньому) викликаються в порядку "
"реєстрації."

msgid ""
"Note that :c:func:`fork` calls made by third-party C code may not call those "
"functions, unless it explicitly calls :c:func:`PyOS_BeforeFork`, :c:func:"
"`PyOS_AfterFork_Parent` and :c:func:`PyOS_AfterFork_Child`."
msgstr ""
"Зауважте, що виклики :c:func:`fork`, здійснені стороннім C-кодом, можуть не "
"викликати ці функції, якщо тільки вони явно не викликають :c:func:"
"`PyOS_BeforeFork`, :c:func:`PyOS_AfterFork_Parent` і :c:func:"
"`PyOS_AfterFork_Child`."

msgid "There is no way to unregister a function."
msgstr "Немає способу скасувати реєстрацію функції."

msgid "Execute the program *path* in a new process."
msgstr "Виконайте *шлях* програми в новому процесі."

msgid ""
"(Note that the :mod:`subprocess` module provides more powerful facilities "
"for spawning new processes and retrieving their results; using that module "
"is preferable to using these functions.  Check especially the :ref:"
"`subprocess-replacements` section.)"
msgstr ""
"(Зверніть увагу, що модуль :mod:`subprocess` надає потужніші можливості для "
"створення нових процесів і отримання їх результатів; використання цього "
"модуля є кращим, ніж використання цих функцій. Особливо перевірте розділ :"
"ref:`subprocess-replacements`.)"

msgid ""
"If *mode* is :const:`P_NOWAIT`, this function returns the process id of the "
"new process; if *mode* is :const:`P_WAIT`, returns the process's exit code "
"if it exits normally, or ``-signal``, where *signal* is the signal that "
"killed the process.  On Windows, the process id will actually be the process "
"handle, so can be used with the :func:`waitpid` function."
msgstr ""
"Якщо *mode* :const:`P_NOWAIT`, ця функція повертає ідентифікатор процесу "
"нового процесу; якщо *mode* дорівнює :const:`P_WAIT`, повертає код виходу "
"процесу, якщо він завершується нормально, або ``-signal``, де *signal* є "
"сигналом, який зупинив процес. У Windows ідентифікатор процесу фактично буде "
"ідентифікатором процесу, тому його можна використовувати з функцією :func:"
"`waitpid`."

msgid ""
"Note on VxWorks, this function doesn't return ``-signal`` when the new "
"process is killed. Instead it raises OSError exception."
msgstr ""
"Зверніть увагу на VxWorks, ця функція не повертає ``-signal``, коли новий "
"процес завершується. Натомість викликає виняток OSError."

msgid ""
"The \"l\" and \"v\" variants of the :func:`spawn\\* <spawnl>` functions "
"differ in how command-line arguments are passed.  The \"l\" variants are "
"perhaps the easiest to work with if the number of parameters is fixed when "
"the code is written; the individual parameters simply become additional "
"parameters to the :func:`spawnl\\*` functions.  The \"v\" variants are good "
"when the number of parameters is variable, with the arguments being passed "
"in a list or tuple as the *args* parameter.  In either case, the arguments "
"to the child process must start with the name of the command being run."
msgstr ""
"Варіанти \"l\" і \"v\" функцій :func:`spawn\\* <spawnl>` відрізняються "
"способом передачі аргументів командного рядка. Варіанти \"l\", мабуть, "
"найлегші для роботи, якщо кількість параметрів фіксована під час написання "
"коду; окремі параметри просто стають додатковими параметрами до функцій :"
"func:`spawnl\\*`. Варіанти \"v\" хороші, коли кількість параметрів є "
"змінною, а аргументи передаються у списку або кортежі як параметр *args*. У "
"будь-якому випадку аргументи дочірнього процесу повинні починатися з назви "
"команди, яка виконується."

msgid ""
"The variants which include a second \"p\" near the end (:func:`spawnlp`, :"
"func:`spawnlpe`, :func:`spawnvp`, and :func:`spawnvpe`) will use the :envvar:"
"`PATH` environment variable to locate the program *file*.  When the "
"environment is being replaced (using one of the :func:`spawn\\*e <spawnl>` "
"variants, discussed in the next paragraph), the new environment is used as "
"the source of the :envvar:`PATH` variable.  The other variants, :func:"
"`spawnl`, :func:`spawnle`, :func:`spawnv`, and :func:`spawnve`, will not use "
"the :envvar:`PATH` variable to locate the executable; *path* must contain an "
"appropriate absolute or relative path."
msgstr ""
"Варіанти, які включають друге \"p\" у кінці (:func:`spawnlp`, :func:"
"`spawnlpe`, :func:`spawnvp` і :func:`spawnvpe`), використовуватимуть :envvar:"
"`PATH` змінна середовища для пошуку *файлу* програми. Під час заміни "
"середовища (з використанням одного з варіантів :func:`spawn\\*e <spawnl>`, "
"розглянутих у наступному параграфі), нове середовище використовується як "
"джерело змінної :envvar:`PATH`. Інші варіанти, :func:`spawnl`, :func:"
"`spawnle`, :func:`spawnv` і :func:`spawnve`, не використовуватимуть змінну :"
"envvar:`PATH` для пошуку виконуваного файлу; *path* повинен містити "
"відповідний абсолютний або відносний шлях."

msgid ""
"For :func:`spawnle`, :func:`spawnlpe`, :func:`spawnve`, and :func:`spawnvpe` "
"(note that these all end in \"e\"), the *env* parameter must be a mapping "
"which is used to define the environment variables for the new process (they "
"are used instead of the current process' environment); the functions :func:"
"`spawnl`, :func:`spawnlp`, :func:`spawnv`, and :func:`spawnvp` all cause the "
"new process to inherit the environment of the current process.  Note that "
"keys and values in the *env* dictionary must be strings; invalid keys or "
"values will cause the function to fail, with a return value of ``127``."
msgstr ""
"Для :func:`spawnle`, :func:`spawnlpe`, :func:`spawnve` і :func:`spawnvpe` "
"(зауважте, що всі вони закінчуються на \"e\"), параметр *env* має бути "
"відображенням який використовується для визначення змінних середовища для "
"нового процесу (вони використовуються замість середовища поточного процесу); "
"функції :func:`spawnl`, :func:`spawnlp`, :func:`spawnv` і :func:`spawnvp` "
"змушують новий процес успадковувати середовище поточного процесу. Зауважте, "
"що ключі та значення у словнику *env* мають бути рядками; недійсні ключі або "
"значення призведуть до помилки функції з поверненням значення ``127``."

msgid ""
"As an example, the following calls to :func:`spawnlp` and :func:`spawnvpe` "
"are equivalent::"
msgstr ""
"Як приклад, наступні виклики :func:`spawnlp` і :func:`spawnvpe` є "
"еквівалентними:"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.spawn`` with arguments "
"``mode``, ``path``, ``args``, ``env``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.spawn`` з аргументами ``mode``, "
"``path``, ``args``, ``env``."

msgid ""
":ref:`Availability <availability>`: Unix, Windows.  :func:`spawnlp`, :func:"
"`spawnlpe`, :func:`spawnvp` and :func:`spawnvpe` are not available on "
"Windows.  :func:`spawnle` and :func:`spawnve` are not thread-safe on "
"Windows; we advise you to use the :mod:`subprocess` module instead."
msgstr ""
":ref:`Наявність <availability>`: Unix, Windows. :func:`spawnlp`, :func:"
"`spawnlpe`, :func:`spawnvp` і :func:`spawnvpe` недоступні в Windows. :func:"
"`spawnle` і :func:`spawnve` не є потокобезпечними у Windows; радимо замість "
"цього використовувати модуль :mod:`subprocess`."

msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  If either of these values is given, the :func:"
"`spawn\\*` functions will return as soon as the new process has been "
"created, with the process id as the return value."
msgstr ""
"Можливі значення для параметра *mode* для сімейства функцій :func:`spawn\\* "
"<spawnl>`. Якщо задано будь-яке з цих значень, функції :func:`spawn\\*` "
"повернуться, щойно буде створено новий процес, з ідентифікатором процесу як "
"значенням, що повертається."

msgid ""
"Possible value for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  If this is given as *mode*, the :func:`spawn\\*` "
"functions will not return until the new process has run to completion and "
"will return the exit code of the process the run is successful, or ``-"
"signal`` if a signal kills the process."
msgstr ""
"Можливе значення для параметра *mode* для сімейства функцій :func:`spawn\\* "
"<spawnl>`. Якщо це вказано як *mode*, функції :func:`spawn\\*` не "
"повернуться, доки новий процес не буде виконано до завершення, і повернеться "
"код виходу процесу, запущений успішно, або ``-signal`` якщо сигнал вбиває "
"процес."

msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  These are less portable than those listed above. :"
"const:`P_DETACH` is similar to :const:`P_NOWAIT`, but the new process is "
"detached from the console of the calling process. If :const:`P_OVERLAY` is "
"used, the current process will be replaced; the :func:`spawn\\* <spawnl>` "
"function will not return."
msgstr ""
"Можливі значення для параметра *mode* для сімейства функцій :func:`spawn\\* "
"<spawnl>`. Вони менш портативні, ніж перелічені вище. :const:`P_DETACH` "
"подібний до :const:`P_NOWAIT`, але новий процес від’єднується від консолі "
"процесу, що викликає. Якщо :const:`P_OVERLAY` використовується, поточний "
"процес буде замінено; функція :func:`spawn\\* <spawnl>` не повернеться."

msgid "Start a file with its associated application."
msgstr "Запустіть файл із пов’язаною програмою."

msgid ""
"When *operation* is not specified or ``'open'``, this acts like double-"
"clicking the file in Windows Explorer, or giving the file name as an "
"argument to the :program:`start` command from the interactive command shell: "
"the file is opened with whatever application (if any) its extension is "
"associated."
msgstr ""
"Якщо *operation* не вказано або ``'open'``, це діє як подвійне клацання "
"файлу в Провіднику Windows або надання імені файлу як аргументу команді :"
"program:`start` з інтерактивної командної оболонки : файл відкривається будь-"
"якою програмою (якщо є), з якою пов’язано його розширення."

msgid ""
"When another *operation* is given, it must be a \"command verb\" that "
"specifies what should be done with the file. Common verbs documented by "
"Microsoft are ``'print'`` and  ``'edit'`` (to be used on files) as well as "
"``'explore'`` and ``'find'`` (to be used on directories)."
msgstr ""
"Коли надана інша *операція*, це має бути \"командне дієслово\", яке вказує, "
"що слід робити з файлом. Поширеними дієсловами, задокументованими Microsoft, "
"є ``'print'`` і ``'edit'`` (для використання у файлах), а також "
"``'explore'`` і ``'find'`` (для використання в довідниках)."

msgid ""
"When launching an application, specify *arguments* to be passed as a single "
"string. This argument may have no effect when using this function to launch "
"a document."
msgstr ""
"Під час запуску програми вкажіть *аргументи*, які передаються як один рядок. "
"Цей аргумент може не мати ефекту під час використання цієї функції для "
"запуску документа."

msgid ""
"The default working directory is inherited, but may be overridden by the "
"*cwd* argument. This should be an absolute path. A relative *path* will be "
"resolved against this argument."
msgstr ""
"Робочий каталог за замовчуванням успадковується, але може бути "
"перевизначений аргументом *cwd*. Це має бути абсолютний шлях. Відносний "
"*шлях* буде вирішено проти цього аргументу."

msgid ""
"Use *show_cmd* to override the default window style. Whether this has any "
"effect will depend on the application being launched. Values are integers as "
"supported by the Win32 :c:func:`ShellExecute` function."
msgstr ""
"Використовуйте *show_cmd*, щоб змінити стиль вікна за замовчуванням. Чи "
"матиме це якийсь ефект, залежатиме від запущеної програми. Значення є цілими "
"числами, що підтримується функцією Win32 :c:func:`ShellExecute`."

msgid ""
":func:`startfile` returns as soon as the associated application is launched. "
"There is no option to wait for the application to close, and no way to "
"retrieve the application's exit status.  The *path* parameter is relative to "
"the current directory or *cwd*.  If you want to use an absolute path, make "
"sure the first character is not a slash (``'/'``)  Use :mod:`pathlib` or "
"the :func:`os.path.normpath` function to ensure that paths are properly "
"encoded for Win32."
msgstr ""
":func:`startfile` повертається, щойно буде запущено відповідну програму. "
"Немає можливості чекати, поки програма закриється, і немає способу отримати "
"статус виходу програми. Параметр *path* відноситься до поточного каталогу "
"або *cwd*. Якщо ви хочете використовувати абсолютний шлях, переконайтеся, що "
"перший символ не є скісною рискою (``'/'``). Використовуйте :mod:`pathlib` "
"або функцію :func:`os.path.normpath`, щоб переконатися, що шляхи правильно "
"закодовані для Win32."

msgid ""
"To reduce interpreter startup overhead, the Win32 :c:func:`ShellExecute` "
"function is not resolved until this function is first called.  If the "
"function cannot be resolved, :exc:`NotImplementedError` will be raised."
msgstr ""
"Щоб зменшити навантаження на запуск інтерпретатора, функція Win32 :c:func:"
"`ShellExecute` не вирішується, доки ця функція не буде викликана вперше. "
"Якщо функцію не вдається розв’язати, виникне :exc:`NotImplementedError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.startfile`` with arguments "
"``path``, ``operation``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.startfile`` з аргументами "
"``path``, ``operation``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.startfile/2`` with arguments "
"``path``, ``operation``, ``arguments``, ``cwd``, ``show_cmd``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.startfile/2`` з аргументами "
"``path``, ``operation``, ``arguments``, ``cwd``, ``show_cmd`` ."

msgid ""
"Added the *arguments*, *cwd* and *show_cmd* arguments, and the ``os."
"startfile/2`` audit event."
msgstr ""
"Додано аргументи *arguments*, *cwd* і *show_cmd* і подію аудиту ``os."
"startfile/2``."

msgid ""
"Execute the command (a string) in a subshell.  This is implemented by "
"calling the Standard C function :c:func:`system`, and has the same "
"limitations. Changes to :data:`sys.stdin`, etc. are not reflected in the "
"environment of the executed command. If *command* generates any output, it "
"will be sent to the interpreter standard output stream. The C standard does "
"not specify the meaning of the return value of the C function, so the return "
"value of the Python function is system-dependent."
msgstr ""
"Виконайте команду (рядок) у підоболонці. Це реалізується шляхом виклику "
"стандартної функції C :c:func:`system` і має ті самі обмеження. Зміни в :"
"data:`sys.stdin` тощо не відображаються в середовищі виконуваної команди. "
"Якщо *команда* генерує будь-який вихід, він буде надісланий до стандартного "
"потоку виводу інтерпретатора. Стандарт C не визначає значення значення, що "
"повертається функцією C, тому значення, що повертається функцією Python, "
"залежить від системи."

msgid ""
"On Unix, the return value is the exit status of the process encoded in the "
"format specified for :func:`wait`."
msgstr ""
"В Unix значення, що повертається, є статусом завершення процесу, закодованим "
"у форматі, указаному для :func:`wait`."

msgid ""
"On Windows, the return value is that returned by the system shell after "
"running *command*.  The shell is given by the Windows environment variable :"
"envvar:`COMSPEC`: it is usually :program:`cmd.exe`, which returns the exit "
"status of the command run; on systems using a non-native shell, consult your "
"shell documentation."
msgstr ""
"У Windows повертається значення, яке повертає системна оболонка після "
"виконання *команди*. Оболонка визначається змінною середовища Windows :"
"envvar:`COMSPEC`: зазвичай це :program:`cmd.exe`, яка повертає статус "
"завершення виконання команди; у системах, які використовують нерідну "
"оболонку, зверніться до документації вашої оболонки."

msgid ""
"The :mod:`subprocess` module provides more powerful facilities for spawning "
"new processes and retrieving their results; using that module is preferable "
"to using this function.  See the :ref:`subprocess-replacements` section in "
"the :mod:`subprocess` documentation for some helpful recipes."
msgstr ""
"Модуль :mod:`subprocess` надає потужніші можливості для створення нових "
"процесів і отримання їх результатів; використовувати цей модуль краще, ніж "
"використовувати цю функцію. Перегляньте розділ :ref:`subprocess-"
"replacements` в документації :mod:`subprocess`, щоб знайти кілька корисних "
"рецептів."

msgid ""
"On Unix, :func:`waitstatus_to_exitcode` can be used to convert the result "
"(exit status) into an exit code. On Windows, the result is directly the exit "
"code."
msgstr ""
"В Unix :func:`waitstatus_to_exitcode` можна використовувати для перетворення "
"результату (статус виходу) у код виходу. У Windows результатом є "
"безпосередньо код виходу."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.system`` with argument "
"``command``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``os.system`` з аргументом "
"``command``."

msgid ""
"Returns the current global process times. The return value is an object with "
"five attributes:"
msgstr ""
"Повертає поточний глобальний час процесу. Повернене значення є об’єктом із "
"п’ятьма атрибутами:"

msgid ":attr:`!user` - user time"
msgstr ":attr:`!user` - час користувача"

msgid ":attr:`!system` - system time"
msgstr ":attr:`!system` - системний час"

msgid ":attr:`!children_user` - user time of all child processes"
msgstr ":attr:`!children_user` - час користувача всіх дочірніх процесів"

msgid ":attr:`!children_system` - system time of all child processes"
msgstr ":attr:`!children_system` - системний час усіх дочірніх процесів"

msgid ":attr:`!elapsed` - elapsed real time since a fixed point in the past"
msgstr ""
":attr:`!elapsed` - реальний час, що минув від фіксованої точки в минулому"

msgid ""
"For backwards compatibility, this object also behaves like a five-tuple "
"containing :attr:`!user`, :attr:`!system`, :attr:`!children_user`, :attr:`!"
"children_system`, and :attr:`!elapsed` in that order."
msgstr ""
"Для зворотної сумісності цей об’єкт також поводиться як п’ять кортежів, що "
"містять :attr:`!user`, :attr:`!system`, :attr:`!children_user`, :attr:`!"
"children_system` і :attr:`!минало` в такому порядку."

msgid ""
"See the Unix manual page :manpage:`times(2)` and :manpage:`times(3)` manual "
"page on Unix or `the GetProcessTimes MSDN <https://docs.microsoft.com/"
"windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes>`_ "
"on Windows. On Windows, only :attr:`!user` and :attr:`!system` are known; "
"the other attributes are zero."
msgstr ""

msgid ""
"Wait for completion of a child process, and return a tuple containing its "
"pid and exit status indication: a 16-bit number, whose low byte is the "
"signal number that killed the process, and whose high byte is the exit "
"status (if the signal number is zero); the high bit of the low byte is set "
"if a core file was produced."
msgstr ""
"Зачекайте на завершення дочірнього процесу та поверніть кортеж, що містить "
"його pid та індикацію статусу виходу: 16-розрядне число, чий молодший байт є "
"номером сигналу, що вбив процес, а старший байт є статусом виходу (якщо "
"сигнал число дорівнює нулю); старший біт молодшого байта встановлюється, "
"якщо було створено основний файл."

msgid ""
":func:`waitstatus_to_exitcode` can be used to convert the exit status into "
"an exit code."
msgstr ""
":func:`waitstatus_to_exitcode` можна використовувати для перетворення "
"статусу виходу в код виходу."

msgid ""
":func:`waitpid` can be used to wait for the completion of a specific child "
"process and has more options."
msgstr ""
":func:`waitpid` можна використовувати для очікування завершення певного "
"дочірнього процесу та має більше параметрів."

msgid ""
"Wait for the completion of one or more child processes. *idtype* can be :"
"data:`P_PID`, :data:`P_PGID`, :data:`P_ALL`, or :data:`P_PIDFD` on Linux. "
"*id* specifies the pid to wait on. *options* is constructed from the ORing "
"of one or more of :data:`WEXITED`, :data:`WSTOPPED` or :data:`WCONTINUED` "
"and additionally may be ORed with :data:`WNOHANG` or :data:`WNOWAIT`. The "
"return value is an object representing the data contained in the :c:type:"
"`siginfo_t` structure, namely: :attr:`si_pid`, :attr:`si_uid`, :attr:"
"`si_signo`, :attr:`si_status`, :attr:`si_code` or ``None`` if :data:"
"`WNOHANG` is specified and there are no children in a waitable state."
msgstr ""
"Дочекайтеся завершення одного або кількох дочірніх процесів. *idtype* може "
"бути :data:`P_PID`, :data:`P_PGID`, :data:`P_ALL` або :data:`P_PIDFD` в "
"Linux. *id* вказує pid, на який потрібно чекати. *параметри* складаються з "
"операції АБО одного чи кількох :data:`WEXITED`, :data:`WSTOPPED` або :data:"
"`WCONTINUED` і додатково можуть бути об’єднані АБО за допомогою :data:"
"`WNOHANG` або :data:`WNOWAIT`. Повернене значення — це об’єкт, що "
"представляє дані, що містяться в структурі :c:type:`siginfo_t`, а саме: :"
"attr:`si_pid`, :attr:`si_uid`, :attr:`si_signo`, :attr:`si_status`, :attr:"
"`si_code` або ``None``, якщо вказано :data:`WNOHANG` і немає дітей у стані "
"очікування."

msgid ""
"These are the possible values for *idtype* in :func:`waitid`. They affect "
"how *id* is interpreted."
msgstr ""
"Це можливі значення для *idtype* у :func:`waitid`. Вони впливають на "
"інтерпретацію *id*."

msgid ""
"This is a Linux-specific *idtype* that indicates that *id* is a file "
"descriptor that refers to a process."
msgstr ""
"Це специфічний *idtype* для Linux, який вказує, що *id* є дескриптором "
"файлу, який посилається на процес."

msgid ":ref:`Availability <availability>`: Linux 5.4+"
msgstr ":ref:`Наявність <availability>`: Linux 5.4+"

msgid ""
"Flags that can be used in *options* in :func:`waitid` that specify what "
"child signal to wait for."
msgstr ""
"Прапорці, які можна використовувати в *параметрах* у :func:`waitid`, які "
"вказують, який дочірній сигнал чекати."

msgid ""
"These are the possible values for :attr:`si_code` in the result returned by :"
"func:`waitid`."
msgstr ""
"Це можливі значення для :attr:`si_code` у результаті, який повертає :func:"
"`waitid`."

msgid "Added :data:`CLD_KILLED` and :data:`CLD_STOPPED` values."
msgstr "Додано значення :data:`CLD_KILLED` і :data:`CLD_STOPPED`."

msgid "The details of this function differ on Unix and Windows."
msgstr "Деталі цієї функції відрізняються в Unix і Windows."

msgid ""
"On Unix: Wait for completion of a child process given by process id *pid*, "
"and return a tuple containing its process id and exit status indication "
"(encoded as for :func:`wait`).  The semantics of the call are affected by "
"the value of the integer *options*, which should be ``0`` for normal "
"operation."
msgstr ""
"В Unix: зачекайте на завершення дочірнього процесу, заданого ідентифікатором "
"процесу *pid*, і поверніть кортеж, що містить ідентифікатор його процесу та "
"вказівку статусу виходу (закодовано як для :func:`wait`). На семантику "
"виклику впливає значення цілого числа *options*, яке має бути ``0`` для "
"нормальної роботи."

msgid ""
"If *pid* is greater than ``0``, :func:`waitpid` requests status information "
"for that specific process.  If *pid* is ``0``, the request is for the status "
"of any child in the process group of the current process.  If *pid* is "
"``-1``, the request pertains to any child of the current process.  If *pid* "
"is less than ``-1``, status is requested for any process in the process "
"group ``-pid`` (the absolute value of *pid*)."
msgstr ""
"Якщо *pid* більший за ``0``, :func:`waitpid` запитує інформацію про статус "
"для цього конкретного процесу. Якщо *pid* дорівнює ``0``, запит стосується "
"статусу будь-якого дочірнього елемента в групі поточного процесу. Якщо *pid* "
"має значення ``-1``, запит стосується будь-якого дочірнього процесу "
"поточного процесу. Якщо *pid* менший за ``-1``, статус запитується для будь-"
"якого процесу в групі процесів ``-pid`` (абсолютне значення *pid*)."

msgid ""
"An :exc:`OSError` is raised with the value of errno when the syscall returns "
"-1."
msgstr ""
"Коли системний виклик повертає -1, виникає :exc:`OSError` зі значенням errno."

msgid ""
"On Windows: Wait for completion of a process given by process handle *pid*, "
"and return a tuple containing *pid*, and its exit status shifted left by 8 "
"bits (shifting makes cross-platform use of the function easier). A *pid* "
"less than or equal to ``0`` has no special meaning on Windows, and raises an "
"exception. The value of integer *options* has no effect. *pid* can refer to "
"any process whose id is known, not necessarily a child process. The :func:"
"`spawn\\* <spawnl>` functions called with :const:`P_NOWAIT` return suitable "
"process handles."
msgstr ""
"У Windows: дочекайтеся завершення процесу, заданого дескриптором процесу "
"*pid*, і поверніть кортеж, що містить *pid*, а його статус виходу зміщений "
"вліво на 8 біт (зміщення полегшує використання функції на різних "
"платформах). *pid* менше або дорівнює ``0`` не має особливого значення в "
"Windows і викликає виключення. Значення цілого *параметра* не впливає. *pid* "
"може посилатися на будь-який процес, ідентифікатор якого відомий, не "
"обов’язково дочірній процес. Функції :func:`spawn\\* <spawnl>`, викликані за "
"допомогою :const:`P_NOWAIT`, повертають відповідні дескриптори процесу."

msgid ""
"Similar to :func:`waitpid`, except no process id argument is given and a 3-"
"element tuple containing the child's process id, exit status indication, and "
"resource usage information is returned.  Refer to :mod:`resource`.\\ :func:"
"`~resource.getrusage` for details on resource usage information.  The option "
"argument is the same as that provided to :func:`waitpid` and :func:`wait4`."
msgstr ""
"Подібно до :func:`waitpid`, за винятком того, що аргумент ідентифікатора "
"процесу не надається, а повертається 3-елементний кортеж, що містить "
"ідентифікатор дочірнього процесу, індикацію статусу виходу та інформацію про "
"використання ресурсів. Зверніться до :mod:`resource`.\\ :func:`~resource."
"getrusage` для отримання детальної інформації про використання ресурсу. "
"Аргумент параметра такий самий, як і той, що надається для :func:`waitpid` "
"і :func:`wait4`."

msgid ""
":func:`waitstatus_to_exitcode` can be used to convert the exit status into "
"an exitcode."
msgstr ""
":func:`waitstatus_to_exitcode` можна використовувати для перетворення "
"статусу виходу в код виходу."

msgid ""
"Similar to :func:`waitpid`, except a 3-element tuple, containing the child's "
"process id, exit status indication, and resource usage information is "
"returned. Refer to :mod:`resource`.\\ :func:`~resource.getrusage` for "
"details on resource usage information.  The arguments to :func:`wait4` are "
"the same as those provided to :func:`waitpid`."
msgstr ""
"Подібно до :func:`waitpid`, за винятком того, що повертається 3-елементний "
"кортеж, який містить ідентифікатор дочірнього процесу, індикацію статусу "
"виходу та інформацію про використання ресурсів. Зверніться до :mod:"
"`resource`.\\ :func:`~resource.getrusage` для отримання детальної інформації "
"про використання ресурсу. Аргументи для :func:`wait4` такі самі, як і для :"
"func:`waitpid`."

msgid "Convert a wait status to an exit code."
msgstr "Перетворення статусу очікування на код виходу."

msgid "On Unix:"
msgstr "В Unix:"

msgid ""
"If the process exited normally (if ``WIFEXITED(status)`` is true), return "
"the process exit status (return ``WEXITSTATUS(status)``): result greater "
"than or equal to 0."
msgstr ""
"Якщо процес закінчився нормально (якщо ``WIFEXITED(статус)`` має значення "
"true), повертає статус виходу процесу (повертає ``WEXITSTATUS(статус)``): "
"результат більше або дорівнює 0."

msgid ""
"If the process was terminated by a signal (if ``WIFSIGNALED(status)`` is "
"true), return ``-signum`` where *signum* is the number of the signal that "
"caused the process to terminate (return ``-WTERMSIG(status)``): result less "
"than 0."
msgstr ""
"Якщо процес було припинено через сигнал (якщо ``WIFSIGNALED(status)`` має "
"значення true), повертає ``-signum``, де *signum* — це номер сигналу, який "
"спричинив завершення процесу (повертає ``- WTERMSIG(статус)``): результат "
"менше 0."

msgid "Otherwise, raise a :exc:`ValueError`."
msgstr "Інакше викличте :exc:`ValueError`."

msgid "On Windows, return *status* shifted right by 8 bits."
msgstr "У Windows повертає *статус*, зміщений праворуч на 8 біт."

msgid ""
"On Unix, if the process is being traced or if :func:`waitpid` was called "
"with :data:`WUNTRACED` option, the caller must first check if "
"``WIFSTOPPED(status)`` is true. This function must not be called if "
"``WIFSTOPPED(status)`` is true."
msgstr ""
"В Unix, якщо процес відстежується або якщо :func:`waitpid` було викликано з "
"опцією :data:`WUNTRACED`, абонент повинен спочатку перевірити, чи "
"``WIFSTOPPED(status)`` є істинним. Цю функцію не можна викликати, якщо "
"``WIFSTOPPED(статус)`` має значення true."

msgid ""
":func:`WIFEXITED`, :func:`WEXITSTATUS`, :func:`WIFSIGNALED`, :func:"
"`WTERMSIG`, :func:`WIFSTOPPED`, :func:`WSTOPSIG` functions."
msgstr ""
"Функції :func:`WIFEXITED`, :func:`WEXITSTATUS`, :func:`WIFSIGNALED`, :func:"
"`WTERMSIG`, :func:`WIFSTOPPED`, :func:`WSTOPSIG`."

msgid ""
"The option for :func:`waitpid` to return immediately if no child process "
"status is available immediately. The function returns ``(0, 0)`` in this "
"case."
msgstr ""
"Опція для :func:`waitpid` негайного повернення, якщо статус дочірнього "
"процесу не доступний негайно. У цьому випадку функція повертає ``(0, 0)``."

msgid ""
"This option causes child processes to be reported if they have been "
"continued from a job control stop since their status was last reported."
msgstr ""
"Цей параметр спричиняє надсилання звітів про дочірні процеси, якщо вони були "
"продовжені після зупинки керування завданнями після останнього повідомлення "
"про їхній статус."

msgid ":ref:`Availability <availability>`: some Unix systems."
msgstr ":ref:`Доступність <availability>`: деякі системи Unix."

msgid ""
"This option causes child processes to be reported if they have been stopped "
"but their current state has not been reported since they were stopped."
msgstr ""
"Ця опція спричиняє надсилання звітів про дочірні процеси, якщо їх було "
"зупинено, але їхній поточний стан не повідомлявся після їх зупинки."

msgid ""
"The following functions take a process status code as returned by :func:"
"`system`, :func:`wait`, or :func:`waitpid` as a parameter.  They may be used "
"to determine the disposition of a process."
msgstr ""
"Наступні функції приймають код стану процесу, який повертає :func:`system`, :"
"func:`wait` або :func:`waitpid` як параметр. Вони можуть бути використані "
"для визначення розташування процесу."

msgid ""
"Return ``True`` if a core dump was generated for the process, otherwise "
"return ``False``."
msgstr ""
"Повертає ``True``, якщо для процесу було створено дамп ядра, інакше повертає "
"``False``."

msgid "This function should be employed only if :func:`WIFSIGNALED` is true."
msgstr ""
"Цю функцію слід використовувати, лише якщо :func:`WIFSIGNALED` має значення "
"true."

msgid ""
"Return ``True`` if a stopped child has been resumed by delivery of :data:"
"`~signal.SIGCONT` (if the process has been continued from a job control "
"stop), otherwise return ``False``."
msgstr ""
"Повертає ``True``, якщо зупинений дочірній елемент було відновлено "
"доставкою :data:`~signal.SIGCONT` (якщо процес було продовжено після зупинки "
"керування завданням), інакше повертає ``False``."

msgid "See :data:`WCONTINUED` option."
msgstr "Перегляньте параметр :data:`WCONTINUED`."

msgid ""
"Return ``True`` if the process was stopped by delivery of a signal, "
"otherwise return ``False``."
msgstr ""
"Повертає ``True``, якщо процес було зупинено доставкою сигналу, інакше "
"повертає ``False``."

msgid ""
":func:`WIFSTOPPED` only returns ``True`` if the :func:`waitpid` call was "
"done using :data:`WUNTRACED` option or when the process is being traced "
"(see :manpage:`ptrace(2)`)."
msgstr ""
":func:`WIFSTOPPED` повертає ``True``, лише якщо виклик :func:`waitpid` було "
"виконано за допомогою параметра :data:`WUNTRACED` або коли процес "
"відстежується (див. :manpage:`ptrace(2)` )."

msgid ""
"Return ``True`` if the process was terminated by a signal, otherwise return "
"``False``."
msgstr ""
"Повертає ``True``, якщо процес було припинено сигналом, інакше повертає "
"``False``."

msgid ""
"Return ``True`` if the process exited terminated normally, that is, by "
"calling ``exit()`` or ``_exit()``, or by returning from ``main()``; "
"otherwise return ``False``."
msgstr ""
"Повертає ``True``, якщо процес завершився нормально, тобто викликом "
"``exit()`` чи ``_exit()``, або шляхом повернення з ``main()``; інакше "
"повертає ``False``."

msgid "Return the process exit status."
msgstr "Повернути статус виходу процесу."

msgid "This function should be employed only if :func:`WIFEXITED` is true."
msgstr ""
"Цю функцію слід використовувати, лише якщо :func:`WIFEXITED` має значення "
"true."

msgid "Return the signal which caused the process to stop."
msgstr "Повернути сигнал, який спричинив зупинку процесу."

msgid "This function should be employed only if :func:`WIFSTOPPED` is true."
msgstr ""
"Цю функцію слід використовувати, лише якщо :func:`WIFSTOPPED` має значення "
"true."

msgid "Return the number of the signal that caused the process to terminate."
msgstr "Повертає номер сигналу, який викликав завершення процесу."

msgid "Interface to the scheduler"
msgstr "Інтерфейс до планувальника"

msgid ""
"These functions control how a process is allocated CPU time by the operating "
"system. They are only available on some Unix platforms. For more detailed "
"information, consult your Unix manpages."
msgstr ""
"Ці функції контролюють, як процес розподіляє процесорний час операційною "
"системою. Вони доступні лише на деяких платформах Unix. Щоб отримати "
"детальнішу інформацію, зверніться до сторінок довідки Unix."

msgid ""
"The following scheduling policies are exposed if they are supported by the "
"operating system."
msgstr ""
"Наведені нижче політики планування доступні, якщо вони підтримуються "
"операційною системою."

msgid "The default scheduling policy."
msgstr "Політика планування за умовчанням."

msgid ""
"Scheduling policy for CPU-intensive processes that tries to preserve "
"interactivity on the rest of the computer."
msgstr ""
"Політика планування процесів із інтенсивним використанням ЦП, яка "
"намагається зберегти інтерактивність решти комп’ютера."

msgid "Scheduling policy for extremely low priority background tasks."
msgstr ""
"Політика планування для фонових завдань із надзвичайно низьким пріоритетом."

msgid "Scheduling policy for sporadic server programs."
msgstr "Політика планування для спорадичних серверних програм."

msgid "A First In First Out scheduling policy."
msgstr "Політика планування за принципом \"перший прийшов - перший вийшов\"."

msgid "A round-robin scheduling policy."
msgstr "Політика циклічного планування."

msgid ""
"This flag can be OR'ed with any other scheduling policy. When a process with "
"this flag set forks, its child's scheduling policy and priority are reset to "
"the default."
msgstr ""
"Цей прапорець можна об’єднати з будь-якою іншою політикою планування. Коли "
"процес із цим прапорцем розгалужується, його політика планування та "
"пріоритет скидаються до стандартних."

msgid ""
"This class represents tunable scheduling parameters used in :func:"
"`sched_setparam`, :func:`sched_setscheduler`, and :func:`sched_getparam`. It "
"is immutable."
msgstr ""
"Цей клас представляє настроювані параметри планування, які використовуються "
"в :func:`sched_setparam`, :func:`sched_setscheduler` і :func:"
"`sched_getparam`. Це незмінно."

msgid "At the moment, there is only one possible parameter:"
msgstr "На даний момент можливий лише один параметр:"

msgid "The scheduling priority for a scheduling policy."
msgstr "Пріоритет планування для політики планування."

msgid ""
"Get the minimum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr ""
"Отримайте мінімальне значення пріоритету для *політики*. *policy* є однією з "
"наведених вище констант політики планування."

msgid ""
"Get the maximum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr ""
"Отримайте максимальне значення пріоритету для *політики*. *policy* є однією "
"з наведених вище констант політики планування."

msgid ""
"Set the scheduling policy for the process with PID *pid*. A *pid* of 0 means "
"the calling process. *policy* is one of the scheduling policy constants "
"above. *param* is a :class:`sched_param` instance."
msgstr ""
"Встановіть політику планування для процесу за допомогою PID *pid*. *pid*, "
"рівний 0, означає процес виклику. *policy* — це одна з наведених вище "
"констант політики планування. *param* є екземпляром :class:`sched_param`."

msgid ""
"Return the scheduling policy for the process with PID *pid*. A *pid* of 0 "
"means the calling process. The result is one of the scheduling policy "
"constants above."
msgstr ""
"Повернути політику планування для процесу з PID *pid*. *pid*, рівний 0, "
"означає процес виклику. Результатом є одна з наведених вище констант "
"політики планування."

msgid ""
"Set the scheduling parameters for the process with PID *pid*. A *pid* of 0 "
"means the calling process. *param* is a :class:`sched_param` instance."
msgstr ""
"Встановіть параметри планування для процесу за допомогою PID *pid*. *pid*, "
"рівний 0, означає процес виклику. *param* є екземпляром :class:`sched_param`."

msgid ""
"Return the scheduling parameters as a :class:`sched_param` instance for the "
"process with PID *pid*. A *pid* of 0 means the calling process."
msgstr ""
"Поверніть параметри планування як екземпляр :class:`sched_param` для процесу "
"з PID *pid*. *pid*, рівний 0, означає процес виклику."

msgid ""
"Return the round-robin quantum in seconds for the process with PID *pid*. A "
"*pid* of 0 means the calling process."
msgstr ""
"Повертайте циклічний квант за секунди для процесу з PID *pid*. *pid*, рівний "
"0, означає процес виклику."

msgid "Voluntarily relinquish the CPU."
msgstr "Добровільно відмовитися від ЦП."

msgid ""
"Restrict the process with PID *pid* (or the current process if zero) to a "
"set of CPUs.  *mask* is an iterable of integers representing the set of CPUs "
"to which the process should be restricted."
msgstr ""
"Обмежте процес за допомогою PID *pid* (або поточного процесу, якщо дорівнює "
"нулю) набору ЦП. *mask* — це ітерація цілих чисел, що представляють набір "
"процесорів, якими має бути обмежений процес."

msgid ""
"Return the set of CPUs the process with PID *pid* (or the current process if "
"zero) is restricted to."
msgstr ""
"Повертає набір процесорів, до яких обмежено процес із PID *pid* (або "
"поточний процес, якщо він нульовий)."

msgid "Miscellaneous System Information"
msgstr "Різна системна інформація"

msgid ""
"Return string-valued system configuration values. *name* specifies the "
"configuration value to retrieve; it may be a string which is the name of a "
"defined system value; these names are specified in a number of standards "
"(POSIX, Unix 95, Unix 98, and others).  Some platforms define additional "
"names as well. The names known to the host operating system are given as the "
"keys of the ``confstr_names`` dictionary.  For configuration variables not "
"included in that mapping, passing an integer for *name* is also accepted."
msgstr ""
"Повертає рядкові значення конфігурації системи. *name* вказує значення "
"конфігурації для отримання; це може бути рядок, який є назвою визначеного "
"системного значення; ці імена вказані в ряді стандартів (POSIX, Unix 95, "
"Unix 98 та ін.). Деякі платформи також визначають додаткові імена. Імена, "
"відомі головній операційній системі, надаються як ключі словника "
"``confstr_names``. Для змінних конфігурації, не включених до цього "
"відображення, також допускається передача цілого числа для *name*."

msgid ""
"If the configuration value specified by *name* isn't defined, ``None`` is "
"returned."
msgstr ""
"Якщо значення конфігурації, указане *name*, не визначено, повертається "
"``None``."

msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If a "
"specific value for *name* is not supported by the host system, even if it is "
"included in ``confstr_names``, an :exc:`OSError` is raised with :const:"
"`errno.EINVAL` for the error number."
msgstr ""
"Якщо *name* є рядком і невідоме, виникає :exc:`ValueError`. Якщо певне "
"значення для *name* не підтримується хост-системою, навіть якщо воно "
"включене в ``confstr_names``, виникає :exc:`OSError` з :const:`errno.EINVAL` "
"для номера помилки ."

msgid ""
"Dictionary mapping names accepted by :func:`confstr` to the integer values "
"defined for those names by the host operating system. This can be used to "
"determine the set of names known to the system."
msgstr ""
"Словник зіставляє імена, прийняті :func:`confstr`, до цілих значень, "
"визначених для цих імен головною операційною системою. Це можна "
"використовувати для визначення набору імен, відомих системі."

msgid ""
"Return the number of CPUs in the system. Returns ``None`` if undetermined."
msgstr ""
"Повертає кількість процесорів у системі. Повертає ``None``, якщо не "
"визначено."

msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"Це число не еквівалентно кількості ЦП, які може використовувати поточний "
"процес. Кількість доступних ЦП можна отримати за допомогою ``len(os."
"sched_getaffinity(0))``"

msgid ""
"Return the number of processes in the system run queue averaged over the "
"last 1, 5, and 15 minutes or raises :exc:`OSError` if the load average was "
"unobtainable."
msgstr ""
"Повертає середню кількість процесів у черзі виконання системи за останні 1, "
"5 і 15 хвилин або викликає :exc:`OSError`, якщо середнє значення "
"завантаження неможливо отримати."

msgid ""
"Return integer-valued system configuration values. If the configuration "
"value specified by *name* isn't defined, ``-1`` is returned.  The comments "
"regarding the *name* parameter for :func:`confstr` apply here as well; the "
"dictionary that provides information on the known names is given by "
"``sysconf_names``."
msgstr ""
"Повертає цілочисельні значення конфігурації системи. Якщо значення "
"конфігурації, указане *name*, не визначено, повертається ``-1``. Коментарі "
"щодо параметра *name* для :func:`confstr` також застосовуються тут; словник, "
"який надає інформацію про відомі імена, надається ``sysconf_names``."

msgid ""
"Dictionary mapping names accepted by :func:`sysconf` to the integer values "
"defined for those names by the host operating system. This can be used to "
"determine the set of names known to the system."
msgstr ""
"Словник зіставляє імена, прийняті :func:`sysconf`, до цілих значень, "
"визначених для цих імен головною операційною системою. Це можна "
"використовувати для визначення набору імен, відомих системі."

msgid ""
"The following data values are used to support path manipulation operations.  "
"These are defined for all platforms."
msgstr ""
"Наступні значення даних використовуються для підтримки операцій "
"маніпулювання шляхом. Вони визначені для всіх платформ."

msgid ""
"Higher-level operations on pathnames are defined in the :mod:`os.path` "
"module."
msgstr ""
"Операції вищого рівня над іменами шляхів визначені в модулі :mod:`os.path`."

msgid ""
"The constant string used by the operating system to refer to the current "
"directory. This is ``'.'`` for Windows and POSIX. Also available via :mod:"
"`os.path`."
msgstr ""
"Постійний рядок, який використовується операційною системою для посилання на "
"поточний каталог. Це ``'.'`` для Windows і POSIX. Також доступний через :mod:"
"`os.path`."

msgid ""
"The constant string used by the operating system to refer to the parent "
"directory. This is ``'..'`` for Windows and POSIX. Also available via :mod:"
"`os.path`."
msgstr ""
"Постійний рядок, який використовується операційною системою для посилання на "
"батьківський каталог. Це \"..\" для Windows і POSIX. Також доступний через :"
"mod:`os.path`."

msgid ""
"The character used by the operating system to separate pathname components. "
"This is ``'/'`` for POSIX and ``'\\\\'`` for Windows.  Note that knowing "
"this is not sufficient to be able to parse or concatenate pathnames --- use :"
"func:`os.path.split` and :func:`os.path.join` --- but it is occasionally "
"useful. Also available via :mod:`os.path`."
msgstr ""
"Символ, який використовується операційною системою для розділення "
"компонентів шляху. Це ``'/'`` для POSIX і ``'\\\\'`` для Windows. Зауважте, "
"що знати це недостатньо, щоб мати змогу розбирати або об’єднувати шляхи --- "
"використовуйте :func:`os.path.split` і :func:`os.path.join` --- але іноді це "
"корисно. Також доступний через :mod:`os.path`."

msgid ""
"An alternative character used by the operating system to separate pathname "
"components, or ``None`` if only one separator character exists.  This is set "
"to ``'/'`` on Windows systems where ``sep`` is a backslash. Also available "
"via :mod:`os.path`."
msgstr ""
"Альтернативний символ, який використовується операційною системою для "
"розділення компонентів шляху, або \"Немає\", якщо існує лише один роздільний "
"символ. У системах Windows встановлено значення ``'/''``, де ``sep`` є "
"зворотною косою рискою. Також доступний через :mod:`os.path`."

msgid ""
"The character which separates the base filename from the extension; for "
"example, the ``'.'`` in :file:`os.py`. Also available via :mod:`os.path`."
msgstr ""
"Символ, який відокремлює базову назву файлу від розширення; наприклад, "
"``'.'`` у :file:`os.py`. Також доступний через :mod:`os.path`."

msgid ""
"The character conventionally used by the operating system to separate search "
"path components (as in :envvar:`PATH`), such as ``':'`` for POSIX or ``';'`` "
"for Windows. Also available via :mod:`os.path`."
msgstr ""
"Символ, який зазвичай використовується операційною системою для розділення "
"компонентів шляху пошуку (як у :envvar:`PATH`), наприклад ``':''`` для POSIX "
"або ``';''`` для Windows. Також доступний через :mod:`os.path`."

msgid ""
"The default search path used by :func:`exec\\*p\\* <execl>` and :func:"
"`spawn\\*p\\* <spawnl>` if the environment doesn't have a ``'PATH'`` key. "
"Also available via :mod:`os.path`."
msgstr ""
"Шлях пошуку за умовчанням, який використовується :func:`exec\\*p\\* <execl>` "
"і :func:`spawn\\*p\\* <spawnl>`, якщо середовище не має ключа ``'PATH'``. "
"Також доступний через :mod:`os.path`."

msgid ""
"The string used to separate (or, rather, terminate) lines on the current "
"platform.  This may be a single character, such as ``'\\n'`` for POSIX, or "
"multiple characters, for example, ``'\\r\\n'`` for Windows. Do not use *os."
"linesep* as a line terminator when writing files opened in text mode (the "
"default); use a single ``'\\n'`` instead, on all platforms."
msgstr ""
"Рядок, який використовується для розділення (точніше, завершення) рядків на "
"поточній платформі. Це може бути один символ, наприклад ``'\\n'`` для POSIX, "
"або кілька символів, наприклад ``'\\r\\n'`` для Windows. Не використовуйте "
"*os.linesep* як символ закінчення рядка під час запису файлів, відкритих у "
"текстовому режимі (за замовчуванням); замість цього використовуйте єдиний "
"``'\\n'`` на всіх платформах."

msgid ""
"The file path of the null device. For example: ``'/dev/null'`` for POSIX, "
"``'nul'`` for Windows.  Also available via :mod:`os.path`."
msgstr ""
"Шлях до файлу нульового пристрою. Наприклад: ``'/dev/null`` для POSIX, "
"``'nul'`` для Windows. Також доступний через :mod:`os.path`."

msgid ""
"Flags for use with the :func:`~sys.setdlopenflags` and :func:`~sys."
"getdlopenflags` functions.  See the Unix manual page :manpage:`dlopen(3)` "
"for what the different flags mean."
msgstr ""
"Прапори для використання з функціями :func:`~sys.setdlopenflags` і :func:"
"`~sys.getdlopenflags`. Що означають різні прапорці, див. сторінку посібника "
"Unix :manpage:`dlopen(3)`."

msgid "Random numbers"
msgstr "Випадкові числа"

msgid ""
"Get up to *size* random bytes. The function can return less bytes than "
"requested."
msgstr ""
"Отримайте до *size* випадкових байтів. Функція може повертати менше байтів, "
"ніж вимагається."

msgid ""
"These bytes can be used to seed user-space random number generators or for "
"cryptographic purposes."
msgstr ""
"Ці байти можна використовувати для заповнення генераторів випадкових чисел у "
"просторі користувача або для криптографічних цілей."

msgid ""
"``getrandom()`` relies on entropy gathered from device drivers and other "
"sources of environmental noise. Unnecessarily reading large quantities of "
"data will have a negative impact on  other users  of the ``/dev/random`` and "
"``/dev/urandom`` devices."
msgstr ""
"``getrandom()`` покладається на ентропію, зібрану з драйверів пристроїв та "
"інших джерел шуму навколишнього середовища. Невиправдане зчитування великої "
"кількості даних матиме негативний вплив на інших користувачів пристроїв ``/"
"dev/random`` і ``/dev/urandom``."

msgid ""
"The flags argument is a bit mask that can contain zero or more of the "
"following values ORed together: :py:data:`os.GRND_RANDOM` and :py:data:"
"`GRND_NONBLOCK`."
msgstr ""
"Аргумент flags — це бітова маска, яка може містити нуль або більше таких "
"значень, об’єднаних АБО: :py:data:`os.GRND_RANDOM` і :py:data:"
"`GRND_NONBLOCK`."

msgid ""
"See also the `Linux getrandom() manual page <http://man7.org/linux/man-pages/"
"man2/getrandom.2.html>`_."
msgstr ""
"Дивіться також сторінку `посібника Linux getrandom() <http://man7.org/linux/"
"man-pages/man2/getrandom.2.html>`_."

msgid ":ref:`Availability <availability>`: Linux 3.17 and newer."
msgstr ":ref:`Наявність <availability>`: Linux 3.17 і новіші версії."

msgid ""
"Return a bytestring of *size* random bytes suitable for cryptographic use."
msgstr ""
"Повертає байтовий рядок *розміру* випадкових байтів, придатних для "
"криптографічного використання."

msgid ""
"This function returns random bytes from an OS-specific randomness source.  "
"The returned data should be unpredictable enough for cryptographic "
"applications, though its exact quality depends on the OS implementation."
msgstr ""
"Ця функція повертає випадкові байти зі специфічного для ОС джерела "
"випадковості. Повернуті дані мають бути досить непередбачуваними для "
"криптографічних програм, хоча їх точна якість залежить від реалізації ОС."

msgid ""
"On Linux, if the ``getrandom()`` syscall is available, it is used in "
"blocking mode: block until the system urandom entropy pool is initialized "
"(128 bits of entropy are collected by the kernel). See the :pep:`524` for "
"the rationale. On Linux, the :func:`getrandom` function can be used to get "
"random bytes in non-blocking mode (using the :data:`GRND_NONBLOCK` flag) or "
"to poll until the system urandom entropy pool is initialized."
msgstr ""
"У Linux, якщо доступний системний виклик ``getrandom()``, він "
"використовується в режимі блокування: блокуйте, доки системний пул "
"випадкової ентропії не буде ініціалізовано (128 біт ентропії збирає ядро). "
"Перегляньте :pep:`524` для обґрунтування. У Linux функція :func:`getrandom` "
"може бути використана для отримання випадкових байтів у неблокуючому режимі "
"(використовуючи прапор :data:`GRND_NONBLOCK`) або для опитування, доки "
"системний пул випадкової ентропії не буде ініціалізовано."

msgid ""
"On a Unix-like system, random bytes are read from the ``/dev/urandom`` "
"device. If the ``/dev/urandom`` device is not available or not readable, "
"the :exc:`NotImplementedError` exception is raised."
msgstr ""
"У Unix-подібній системі випадкові байти зчитуються з пристрою ``/dev/"
"urandom``. Якщо пристрій ``/dev/urandom`` недоступний або не читається, "
"виникає виняток :exc:`NotImplementedError`."

msgid "On Windows, it will use ``CryptGenRandom()``."
msgstr ""

msgid ""
"The :mod:`secrets` module provides higher level functions. For an easy-to-"
"use interface to the random number generator provided by your platform, "
"please see :class:`random.SystemRandom`."
msgstr ""
"Модуль :mod:`secrets` забезпечує функції вищого рівня. Про простий у "
"використанні інтерфейс генератора випадкових чисел, наданий вашою "
"платформою, див. :class:`random.SystemRandom`."

msgid ""
"On Linux, ``getrandom()`` is now used in blocking mode to increase the "
"security."
msgstr ""
"У Linux ``getrandom()`` тепер використовується в режимі блокування для "
"підвищення безпеки."

msgid ""
"On Linux, if the ``getrandom()`` syscall blocks (the urandom entropy pool is "
"not initialized yet), fall back on reading ``/dev/urandom``."
msgstr ""
"У Linux, якщо системний виклик ``getrandom()`` блокує (пул ентропії urandom "
"ще не ініціалізовано), поверніться до читання ``/dev/urandom``."

msgid ""
"On Linux 3.17 and newer, the ``getrandom()`` syscall is now used when "
"available.  On OpenBSD 5.6 and newer, the C ``getentropy()`` function is now "
"used. These functions avoid the usage of an internal file descriptor."
msgstr ""
"У Linux 3.17 і новіших версіях системний виклик ``getrandom()`` тепер "
"використовується, якщо він доступний. У OpenBSD 5.6 і новіших версіях тепер "
"використовується функція C ``getentropy()``. Ці функції уникають "
"використання внутрішнього файлового дескриптора."

msgid ""
"By  default, when reading from ``/dev/random``, :func:`getrandom` blocks if "
"no random bytes are available, and when reading from ``/dev/urandom``, it "
"blocks if the entropy pool has not yet been initialized."
msgstr ""
"За замовчуванням під час читання з ``/dev/random`` :func:`getrandom` блокує, "
"якщо випадкові байти недоступні, а під час читання з ``/dev/urandom`` "
"блокує, якщо пул ентропії не має ще не ініціалізовано."

msgid ""
"If the :py:data:`GRND_NONBLOCK` flag is set, then :func:`getrandom` does not "
"block in these cases, but instead immediately raises :exc:`BlockingIOError`."
msgstr ""
"Якщо встановлено прапорець :py:data:`GRND_NONBLOCK`, то :func:`getrandom` не "
"блокує в цих випадках, а замість цього негайно викликає :exc:"
"`BlockingIOError`."

msgid ""
"If  this  bit  is  set,  then  random bytes are drawn from the ``/dev/"
"random`` pool instead of the ``/dev/urandom`` pool."
msgstr ""
"Якщо цей біт установлено, випадкові байти витягуються з пулу ``/dev/random`` "
"замість пулу ``/dev/urandom``."
