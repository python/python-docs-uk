# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Event Loop"
msgstr "Цикл подій"

msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Вихідний код:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

msgid "Preface"
msgstr "Передмова"

msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"Цикл подій є ядром кожної асинхронної програми. Цикли подій запускають "
"асинхронні завдання та зворотні виклики, виконують мережеві операції вводу-"
"виводу та запускають підпроцеси."

msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Розробникам додатків зазвичай слід використовувати асинхронні функції "
"високого рівня, такі як :func:`asyncio.run`, і їм рідко потрібно посилатися "
"на об’єкт циклу або викликати його методи. Цей розділ призначений переважно "
"для авторів коду нижчого рівня, бібліотек і фреймворків, яким потрібен "
"точніший контроль над поведінкою циклу подій."

msgid "Obtaining the Event Loop"
msgstr "Отримання циклу подій"

msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Наступні функції низького рівня можна використовувати для отримання, "
"встановлення або створення циклу подій:"

msgid "Return the running event loop in the current OS thread."
msgstr "Повернути запущений цикл подій у поточному потоці ОС."

msgid ""
"If there is no running event loop a :exc:`RuntimeError` is raised. This "
"function can only be called from a coroutine or a callback."
msgstr ""
"Якщо немає запущеного циклу подій, виникає :exc:`RuntimeError`. Цю функцію "
"можна викликати лише з співпрограми або зворотного виклику."

msgid "Get the current event loop."
msgstr "Отримати поточний цикл подій."

msgid ""
"If there is no current event loop set in the current OS thread, the OS "
"thread is main, and :func:`set_event_loop` has not yet been called, asyncio "
"will create a new event loop and set it as the current one."
msgstr ""
"Якщо в поточному потоці ОС не встановлено поточний цикл подій, потік ОС є "
"головним, а :func:`set_event_loop` ще не викликано, asyncio створить новий "
"цикл подій і встановить його як поточний."

msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Оскільки ця функція має досить складну поведінку (особливо, коли "
"використовуються користувацькі політики циклу подій), використанню функції :"
"func:`get_running_loop` краще, ніж :func:`get_event_loop` у співпрограмах і "
"зворотних викликах."

msgid ""
"Consider also using the :func:`asyncio.run` function instead of using lower "
"level functions to manually create and close an event loop."
msgstr ""
"Також подумайте про використання функції :func:`asyncio.run` замість "
"використання функцій нижчого рівня для ручного створення та закриття циклу "
"подій."

msgid ""
"Deprecation warning is emitted if there is no running event loop. In future "
"Python releases, this function will be an alias of :func:`get_running_loop`."
msgstr ""
"Попередження про застарілу видається, якщо цикл подій не виконується. У "
"майбутніх випусках Python ця функція буде псевдонімом :func:"
"`get_running_loop`."

msgid "Set *loop* as a current event loop for the current OS thread."
msgstr "Встановіть *loop* як поточний цикл подій для поточного потоку ОС."

msgid "Create and return a new event loop object."
msgstr "Створити та повернути новий об’єкт циклу подій."

msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Зауважте, що поведінку функцій :func:`get_event_loop`, :func:"
"`set_event_loop` і :func:`new_event_loop` можна змінити шляхом :ref:"
"`встановлення спеціальної політики циклу подій <asyncio-policies>`."

msgid "Contents"
msgstr "Зміст"

msgid "This documentation page contains the following sections:"
msgstr "Ця сторінка документації містить такі розділи:"

msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"Розділ `Event Loop Methods`_ є довідковою документацією щодо API циклу подій;"

msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"Розділ `Callback Handles`_ документує екземпляри :class:`Handle` і :class:"
"`TimerHandle`, які повертаються з таких методів планування, як :meth:`loop."
"call_soon` і :meth:`loop.call_later`;"

msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"Розділ `Server Objects`_ документує типи, що повертаються з методів циклу "
"подій, таких як :meth:`loop.create_server`;"

msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"Розділ `Event Loop Implementations`_ документує класи :class:"
"`SelectorEventLoop` і :class:`ProactorEventLoop`;"

msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr "Розділ `Examples`_ демонструє, як працювати з деякими API циклу подій."

msgid "Event Loop Methods"
msgstr "Методи циклу подій"

msgid "Event loops have **low-level** APIs for the following:"
msgstr "Цикли подій мають API **низького рівня** для наступного:"

msgid "Running and stopping the loop"
msgstr "Запуск і зупинка циклу"

msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr "Виконуйте, доки *future* (примірник :class:`Future`) не завершиться."

msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Якщо аргумент є :ref:`об’єктом співпрограми <coroutine>`, він неявно "
"запланований для виконання як :class:`asyncio.Task`."

msgid "Return the Future's result or raise its exception."
msgstr "Повернути результат майбутнього або викликати його виключення."

msgid "Run the event loop until :meth:`stop` is called."
msgstr "Запускайте цикл подій, доки не буде викликано :meth:`stop`."

msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Якщо :meth:`stop` викликається перед викликом :meth:`run_forever()`, цикл "
"опитує селектор вводу-виводу один раз із нульовим тайм-аутом, запускає всі "
"зворотні виклики, заплановані у відповідь на події введення-виведення (і ті, "
"які вже були заплановані), а потім вийдіть."

msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Якщо :meth:`stop` викликається під час роботи :meth:`run_forever`, цикл "
"запустить поточний пакет зворотних викликів, а потім завершить роботу. "
"Зауважте, що нові зворотні виклики, заплановані зворотними викликами, не "
"виконуватимуться в цьому випадку; натомість вони запустяться під час "
"наступного виклику :meth:`run_forever` або :meth:`run_until_complete`."

msgid "Stop the event loop."
msgstr "Зупиніть цикл подій."

msgid "Return ``True`` if the event loop is currently running."
msgstr "Повертає ``True``, якщо цикл подій зараз запущено."

msgid "Return ``True`` if the event loop was closed."
msgstr "Повертає ``True``, якщо цикл події було закрито."

msgid "Close the event loop."
msgstr "Закрийте цикл подій."

msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"Під час виклику цієї функції цикл не повинен працювати. Усі зворотні "
"виклики, що очікують на розгляд, буде відхилено."

msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Цей метод очищає всі черги та вимикає виконавець, але не чекає, поки "
"виконавець завершить роботу."

msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Цей метод є ідемпотентним і необоротним. Ніякі інші методи не повинні "
"викликатися після закриття циклу подій."

msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Заплануйте закриття всіх наразі відкритих об’єктів :term:`asynchronous "
"generator` за допомогою виклику :meth:`~agen.aclose()`. Після виклику цього "
"методу цикл подій видасть попередження, якщо повторюється новий асинхронний "
"генератор. Це слід використовувати для надійного завершення всіх "
"запланованих асинхронних генераторів."

msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Зауважте, що немає потреби викликати цю функцію, коли використовується :func:"
"`asyncio.run`."

msgid "Example::"
msgstr "Приклад::"

msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`ThreadPoolExecutor`. After calling this method, "
"a :exc:`RuntimeError` will be raised if :meth:`loop.run_in_executor` is "
"called while using the default executor."
msgstr ""
"Заплануйте закриття виконавця за замовчуванням і зачекайте, поки він "
"приєднається до всіх потоків у :class:`ThreadPoolExecutor`. Після виклику "
"цього методу виникне :exc:`RuntimeError`, якщо :meth:`loop.run_in_executor` "
"викликається під час використання виконавця за замовчуванням."

msgid "Scheduling callbacks"
msgstr "Планування зворотних дзвінків"

msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Заплануйте виклик *callback* :term:`callback` з аргументами *args* на "
"наступній ітерації циклу подій."

msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Зворотні виклики викликаються в тому порядку, в якому вони зареєстровані. "
"Кожен зворотній виклик буде викликано рівно один раз."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Необов’язковий аргумент *context*, що містить лише ключове слово, дозволяє "
"вказати спеціальний :class:`contextvars.Context` для виконання *зворотного "
"виклику*. Поточний контекст використовується, якщо *контексту* не надано."

msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used later "
"to cancel the callback."
msgstr ""
"Повертається екземпляр :class:`asyncio.Handle`, який можна використати "
"пізніше для скасування зворотного виклику."

msgid "This method is not thread-safe."
msgstr "Цей метод не є потокобезпечним."

msgid ""
"A thread-safe variant of :meth:`call_soon`.  Must be used to schedule "
"callbacks *from another thread*."
msgstr ""
"Потокобезпечний варіант :meth:`call_soon`. Потрібно використовувати для "
"планування зворотних викликів *з іншого потоку*."

msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Викликає :exc:`RuntimeError`, якщо викликається в закритому циклі. Це може "
"статися у вторинному потоці, коли основна програма вимикається."

msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Перегляньте розділ :ref:`паралелізм і багатопотоковість <asyncio-"
"multithreading>` документації."

msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Додано параметр *context* тільки для ключового слова. Дивіться :pep:`567` "
"для більш детальної інформації."

msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"Більшість функцій планування :mod:`asyncio` не дозволяють передавати ключові "
"аргументи. Для цього скористайтеся :func:`functools.partial`::"

msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"Використання часткових об’єктів зазвичай зручніше, ніж використання лямбда-"
"виразів, оскільки asyncio може краще відтворювати часткові об’єкти в "
"повідомленнях про налагодження та помилки."

msgid "Scheduling delayed callbacks"
msgstr "Планування відкладених зворотних викликів"

msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"Цикл подій надає механізми для планування виклику функцій зворотного виклику "
"в певний момент у майбутньому. Цикл подій використовує монотонні годинники "
"для відстеження часу."

msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Розклад *зворотного виклику* для виклику після заданої *затримки* у секундах "
"(може бути як int, так і float)."

msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"Повертається екземпляр :class:`asyncio.TimerHandle`, який можна "
"використовувати для скасування зворотного виклику."

msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* буде передзвонено рівно один раз. Якщо два зворотні виклики "
"заплановано на один і той же час, порядок їх викликів не визначений."

msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"Додатковий позиційний *args* буде передано зворотному виклику під час його "
"виклику. Якщо ви хочете, щоб зворотній виклик викликався з аргументами "
"ключового слова, використовуйте :func:`functools.partial`."

msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"У Python 3.7 і раніше з реалізацією циклу подій за замовчуванням *затримка* "
"не могла перевищувати один день. Це було виправлено в Python 3.8."

msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Заплануйте виклик *callback* у вказану абсолютну позначку часу *when* (int "
"або float), використовуючи те саме посилання на час, що й :meth:`loop.time`."

msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "Поведінка цього методу така ж, як і :meth:`call_later`."

msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"У Python 3.7 і раніше з реалізацією циклу подій за замовчуванням різниця між "
"*when* і поточним часом не могла перевищувати одного дня. Це було виправлено "
"в Python 3.8."

msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Повертає поточний час у вигляді значення :class:`float` відповідно до "
"внутрішнього монотонного годинника циклу подій."

msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"У Python 3.7 та попередніх версіях тайм-аути (відносна *затримка* або "
"абсолютна *коли*) не повинні перевищувати одного дня. Це було виправлено в "
"Python 3.8."

msgid "The :func:`asyncio.sleep` function."
msgstr "Функція :func:`asyncio.sleep`."

msgid "Creating Futures and Tasks"
msgstr "Створення ф'ючерсів і завдань"

msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "Створіть об’єкт :class:`asyncio.Future`, приєднаний до циклу подій."

msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Це найкращий спосіб створення ф’ючерсів в асинхронному режимі. Це дозволяє "
"стороннім циклам подій надавати альтернативні реалізації об’єкта Future (з "
"кращою продуктивністю або інструментарієм)."

msgid ""
"Schedule the execution of a :ref:`coroutine`. Return a :class:`Task` object."
msgstr "Заплануйте виконання :ref:`coroutine`. Повертає об’єкт :class:`Task`."

msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Сторонні цикли подій можуть використовувати власний підклас :class:`Task` "
"для взаємодії. У цьому випадку тип результату є підкласом :class:`Task`."

msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Якщо вказано аргумент *name*, а не ``None``, він встановлюється як назва "
"завдання за допомогою :meth:`Task.set_name`."

msgid "Added the *name* parameter."
msgstr "Додано параметр *name*."

msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Встановіть фабрику завдань, яка використовуватиметься :meth:`loop."
"create_task`."

msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro)``, "
"where *loop* is a reference to the active event loop, and *coro* is a "
"coroutine object.  The callable must return a :class:`asyncio.Future`-"
"compatible object."
msgstr ""

msgid "Return a task factory or ``None`` if the default one is in use."
msgstr "Повертає фабрику завдань або ``None``, якщо використовується типова."

msgid "Opening network connections"
msgstr "Відкриття мережевих підключень"

msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Відкрийте потокове транспортне з’єднання за вказаною адресою, указаною "
"*host* і *port*."

msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or :py:data:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"Сімейство сокетів може бути :py:data:`~socket.AF_INET` або :py:data:`~socket."
"AF_INET6` залежно від *host* (або аргументу *family*, якщо він надається)."

msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr "Тип сокета буде :py:data:`~socket.SOCK_STREAM`."

msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* має бути викликом, що повертає реалізацію :ref:`asyncio "
"protocol <asyncio-protocol>`."

msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Цей метод намагатиметься встановити з’єднання у фоновому режимі. У разі "
"успіху він повертає пару ``(транспорт, протокол)``."

msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "Хронологічний синопсис основної операції такий:"

msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"З’єднання встановлюється та для нього створюється :ref:`транспорт <asyncio-"
"transport>`."

msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* викликається без аргументів і має повернути екземпляр :"
"ref:`protocol <asyncio-protocol>`."

msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"Екземпляр протоколу з’єднується з транспортом шляхом виклику його методу :"
"meth:`~BaseProtocol.connection_made`."

msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "Кортеж ``(транспорт, протокол)`` повертається в разі успіху."

msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"Створений транспорт є двонаправленим потоком, що залежить від реалізації."

msgid "Other arguments:"
msgstr "Інші аргументи:"

msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: якщо задано і не має значення false, створюється транспорт SSL/TLS "
"(за замовчуванням створюється звичайний транспорт TCP). Якщо *ssl* є "
"об’єктом :class:`ssl.SSLContext`, цей контекст використовується для "
"створення транспорту; якщо *ssl* має значення :const:`True`, "
"використовується контекст за замовчуванням, який повертається з :func:`ssl."
"create_default_context`."

msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`Заходи безпеки SSL/TLS <ssl-security>`"

msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* встановлює або замінює ім’я хоста, з яким буде "
"зіставлятися сертифікат цільового сервера. Слід передавати лише якщо *ssl* "
"не є ``None``. За замовчуванням використовується значення аргументу *host*. "
"Якщо *host* порожній, за умовчанням немає, і ви повинні передати значення "
"*server_hostname*. Якщо *server_hostname* є порожнім рядком, збіг імен "
"хостів вимкнено (що є серйозною загрозою безпеці, уможливлюючи потенційні "
"атаки типу \"людина посередині\")."

msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* — це необов’язкове сімейство адрес, протокол і "
"прапорці, які передаються до getaddrinfo() для вирішення *host*. Якщо "
"задано, усі вони мають бути цілими числами з відповідних констант модуля :"
"mod:`socket`."

msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, якщо задано, увімкне Happy Eyeballs для цього "
"підключення. Це має бути число з плаваючою комою, яке представляє кількість "
"часу в секундах, протягом якого потрібно очікувати завершення спроби "
"з’єднання перед початком наступної паралельної спроби. Це \"Затримка спроби "
"підключення\", як визначено в :rfc:`8305`. Розумним стандартним значенням, "
"рекомендованим RFC, є ``0,25`` (250 мілісекунд)."

msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* контролює перевпорядкування адрес, коли ім’я хоста "
"перетворюється на декілька IP-адрес. Якщо ``0`` або не вказано, зміна "
"порядку не виконується, а адреси пробуються в порядку, який повертає :meth:"
"`getaddrinfo`. Якщо вказано додатне ціле число, адреси чергуються за "
"сімейством адрес, і задане ціле число інтерпретується як \"Перша кількість "
"сімейства адрес\", як визначено в :rfc:`8305`. Типовим значенням є ``0``, "
"якщо *happy_eyeballs_delay* не вказано, і ``1``, якщо так."

msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, якщо його надано, має бути існуючим, уже підключеним :class:`socket."
"socket` об’єктом, який буде використовуватися транспортом. Якщо вказано "
"*sock*, жоден з *host*, *port*, *family*, *proto*, *flags*, "
"*happy_eyeballs_delay*, *interleave* і *local_addr* не повинен бути вказаний."

msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, якщо вказано, це кортеж ``(local_host, local_port)``, який "
"використовується для локального зв’язування сокета. *local_host* і "
"*local_port* шукаються за допомогою ``getaddrinfo()``, подібно до *host* і "
"*port*."

msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — це (для з’єднання TLS) час у секундах очікування "
"завершення рукостискання TLS перед перериванням з’єднання. ``60.0`` секунд, "
"якщо ``None`` (за замовчуванням)."

msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Додано підтримку SSL/TLS у :class:`ProactorEventLoop`."

msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for all "
"TCP connections."
msgstr ""
"Параметр сокета :py:data:`~socket.TCP_NODELAY` встановлено за замовчуванням "
"для всіх TCP-з’єднань."

msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Додано параметр *ssl_handshake_timeout*."

msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Додано параметри *happy_eyeballs_delay* і *interleave*."

msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual- stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Алгоритм Happy Eyeballs: успіх із хостами з двома стеками. Коли шлях і "
"протокол IPv4 сервера працюють, але шлях і протокол IPv6 сервера не "
"працюють, клієнтська програма з подвійним стеком відчуває значну затримку "
"підключення порівняно з клієнтом, який підтримує лише IPv4. Це небажано, "
"оскільки це спричиняє гіршу роботу клієнта з подвійним стеком. Цей документ "
"визначає вимоги до алгоритмів, які зменшують видиму користувачем затримку, і "
"надає алгоритм."

msgid "For more information: https://tools.ietf.org/html/rfc6555"
msgstr ""
"Для отримання додаткової інформації: https://tools.ietf.org/html/rfc6555"

msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"Функція :func:`open_connection` є альтернативним API високого рівня. Він "
"повертає пару (:class:`StreamReader`, :class:`StreamWriter`), яку можна "
"використовувати безпосередньо в коді async/await."

msgid ""
"The parameter *reuse_address* is no longer supported, as using :py:data:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""

msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Коли кілька процесів з різними UID призначають сокети ідентичній адресі "
"сокета UDP за допомогою ``SO_REUSEADDR``, вхідні пакети можуть розподілятися "
"між сокетами випадковим чином."

msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:data:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"Для підтримуваних платформ *reuse_port* можна використовувати як заміну "
"подібної функції. За допомогою *reuse_port* замість нього використовується :"
"py:data:`~sockets.SO_REUSEPORT`, що спеціально запобігає процесам з різними "
"UID призначати сокетам ту саму адресу сокета."

msgid "Create a datagram connection."
msgstr "Створіть з'єднання дейтаграми."

msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"Сімейство сокетів може бути :py:data:`~socket.AF_INET`, :py:data:`~socket."
"AF_INET6` або :py:data:`~socket.AF_UNIX`, залежно від *хосту* (або аргумент "
"*сім'я*, якщо він надається)."

msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr "Тип сокета буде :py:data:`~socket.SOCK_DGRAM`."

msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* має бути викликом, що повертає реалізацію :ref:`protocol "
"<asyncio-protocol>`."

msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "Кортеж ``(транспорт, протокол)`` повертається в разі успіху."

msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*, якщо вказано, це кортеж ``(local_host, local_port)``, який "
"використовується для локального зв’язування сокета. *local_host* і "
"*local_port* шукаються за допомогою :meth:`getaddrinfo`."

msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, якщо вказано, це кортеж ``(remote_host, remote_port)``, який "
"використовується для підключення сокета до віддаленої адреси. *remote_host* "
"і *remote_port* шукаються за допомогою :meth:`getaddrinfo`."

msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* – це необов’язкове сімейство адрес, протокол і "
"прапори, які передаються до :meth:`getaddrinfo` для вирішення *host*. Якщо "
"задано, усі вони мають бути цілими числами з відповідних констант модуля :"
"mod:`socket`."

msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* повідомляє ядру дозволити цю кінцеву точку прив’язувати до того "
"самого порту, до якого прив’язані інші існуючі кінцеві точки, за умови, що "
"всі вони встановлюють цей прапор під час створення. Цей параметр не "
"підтримується в Windows і деяких Unix. Якщо константа :py:data:`~socket."
"SO_REUSEPORT` не визначена, ця можливість не підтримується."

msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* повідомляє ядру дозволити цій кінцевій точці надсилати "
"повідомлення на широкомовну адресу."

msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"Опціонально можна вказати *sock*, щоб використовувати існуючий, уже "
"підключений об’єкт :class:`socket.socket`, який буде використовуватися "
"транспортом. Якщо вказано, *local_addr* і *remote_addr* слід опустити (має "
"бути :const:`None`)."

msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Перегляньте приклади :ref:`UDP echo client protocol <asyncio-udp-echo-client-"
"protocol>` і :ref:`UDP echo server protocol <asyncio-udp-echo-server-"
"protocol>` прикладів."

msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""

msgid ""
"The *reuse_address* parameter is no longer supported due to security "
"concerns."
msgstr ""

msgid "Added support for Windows."
msgstr "Додана підтримка Windows."

msgid "Create a Unix connection."
msgstr "Створіть підключення Unix."

msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be :"
"py:data:`~socket.SOCK_STREAM`."
msgstr ""
"Сімейство сокетів буде :py:data:`~socket.AF_UNIX`; тип сокета буде :py:data:"
"`~socket.SOCK_STREAM`."

msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* — це ім’я сокета домену Unix і є обов’язковим, якщо не вказано "
"параметр *sock*. Підтримуються абстрактні сокети Unix, шляхи :class:`str`, :"
"class:`bytes` і :class:`~pathlib.Path`."

msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Перегляньте документацію методу :meth:`loop.create_connection`, щоб отримати "
"інформацію про аргументи цього методу."

msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Наявність <availability>`: Unix."

msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""
"Додано параметр *ssl_handshake_timeout*. Параметр *path* тепер може бути :"
"term:`path-like object`."

msgid "Creating network servers"
msgstr "Створення мережевих серверів"

msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Створіть TCP-сервер (тип сокета :data:`~socket.SOCK_STREAM`), який "
"прослуховує *порт* адреси *хосту*."

msgid "Returns a :class:`Server` object."
msgstr "Повертає об’єкт :class:`Server`."

msgid "Arguments:"
msgstr "Аргументи:"

msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"Для параметра *host* можна встановити кілька типів, які визначають, де "
"сервер буде слухати:"

msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Якщо *host* є рядком, сервер TCP прив’язаний до єдиного мережевого "
"інтерфейсу, визначеного *host*."

msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Якщо *host* є послідовністю рядків, TCP-сервер прив’язаний до всіх мережевих "
"інтерфейсів, визначених цією послідовністю."

msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Якщо *host* є порожнім рядком або ``None``, усі інтерфейси передбачаються, і "
"буде повернено список кількох сокетів (швидше за все, один для IPv4 та інший "
"для IPv6)."

msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"Параметр *port* можна встановити, щоб вказати, який порт сервер повинен "
"слухати. Якщо ``0`` або ``None`` (за замовчуванням), буде вибрано випадковий "
"невикористаний порт (зауважте, що якщо *host* розпізнає кілька мережевих "
"інтерфейсів, для кожного інтерфейсу буде вибрано окремий випадковий порт)."

msgid ""
"*family* can be set to either :data:`socket.AF_INET` or :data:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* можна встановити як :data:`socket.AF_INET` або :data:`~socket."
"AF_INET6`, щоб змусити сокет використовувати IPv4 або IPv6. Якщо не "
"встановлено, *сімейство* буде визначено з імені хоста (за замовчуванням :"
"data:`~socket.AF_UNSPEC`)."

msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* — це бітова маска для :meth:`getaddrinfo`."

msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"За бажанням можна вказати *sock*, щоб використовувати вже існуючий об’єкт "
"socket. Якщо вказано, *host* і *port* не повинні вказуватися."

msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* — це максимальна кількість підключень у черзі, переданих до :meth:"
"`~socket.socket.listen` (за замовчуванням 100)."

msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* можна встановити як екземпляр :class:`~ssl.SSLContext`, щоб увімкнути "
"TLS через прийнятні з’єднання."

msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* повідомляє ядру повторно використовувати локальний сокет у "
"стані ``TIME_WAIT``, не чекаючи закінчення його природного часу очікування. "
"Якщо не вказано, для Unix буде автоматично встановлено значення ``True``."

msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* повідомляє ядру дозволити цю кінцеву точку прив’язувати до того "
"самого порту, до якого прив’язані інші існуючі кінцеві точки, за умови, що "
"всі вони встановлюють цей прапор під час створення. Цей параметр не "
"підтримується в Windows."

msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — це (для TLS-сервера) час у секундах очікування "
"завершення рукостискання TLS перед розривом з’єднання. ``60.0`` секунд, якщо "
"``None`` (за замовчуванням)."

msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* встановлений на ``True`` (за замовчуванням), змушує "
"створений сервер негайно приймати підключення. Якщо встановлено значення "
"``False``, користувач повинен чекати :meth:`Server.start_serving` або :meth:"
"`Server.serve_forever`, щоб змусити сервер почати приймати з’єднання."

msgid "The *host* parameter can be a sequence of strings."
msgstr "Параметр *host* може бути послідовністю рядків."

msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :py:data:`~socket.TCP_NODELAY` is set by default for all TCP "
"connections."
msgstr ""
"Додано параметри *ssl_handshake_timeout* і *start_serving*. Параметр сокета :"
"py:data:`~socket.TCP_NODELAY` встановлено за замовчуванням для всіх TCP-"
"з’єднань."

msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"Функція :func:`start_server` — це альтернативний API вищого рівня, який "
"повертає пару :class:`StreamReader` і :class:`StreamWriter`, які можна "
"використовувати в коді async/await."

msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:data:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Подібно до :meth:`loop.create_server`, але працює з сімейством сокетів :py:"
"data:`~socket.AF_UNIX`."

msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* — це ім’я сокета домену Unix і є обов’язковим, якщо не надано "
"аргумент *sock*. Підтримуються абстрактні сокети Unix, шляхи :class:`str`, :"
"class:`bytes` і :class:`~pathlib.Path`."

msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Перегляньте документацію методу :meth:`loop.create_server` для отримання "
"інформації про аргументи цього методу."

msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"Додано параметри *ssl_handshake_timeout* і *start_serving*. Параметр *path* "
"тепер може бути об’єктом :class:`~pathlib.Path`."

msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "Оберніть уже прийняте підключення до пари транспорт/протокол."

msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Цей метод може використовуватися серверами, які приймають з’єднання за "
"межами asyncio, але використовують asyncio для їх обробки."

msgid "Parameters:"
msgstr "Параметри:"

msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* — це вже існуючий об’єкт сокета, який повертається з :meth:`socket."
"accept <socket.socket.accept>`."

msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* можна встановити як :class:`~ssl.SSLContext`, щоб увімкнути SSL через "
"прийнятні з’єднання."

msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — це (для з’єднання SSL) час у секундах очікування "
"завершення рукостискання SSL перед розривом з’єднання. ``60.0`` секунд, якщо "
"``None`` (за замовчуванням)."

msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Повертає пару ``(транспорт, протокол)``."

msgid "Transferring files"
msgstr "Передача файлів"

msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Надіслати *файл* через *транспорт*. Повертає загальну кількість надісланих "
"байтів."

msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"Метод використовує високопродуктивний :meth:`os.sendfile`, якщо він "
"доступний."

msgid "*file* must be a regular file object opened in binary mode."
msgstr ""
"*file* має бути звичайним файловим об’єктом, відкритим у двійковому режимі."

msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* вказує, звідки почати читання файлу. Якщо вказано, *count* — це "
"загальна кількість байтів для передачі, а не надсилання файлу до досягнення "
"EOF. Позиція файлу завжди оновлюється, навіть якщо цей метод викликає "
"помилку, і :meth:`file.tell() <io.IOBase.tell>` можна використовувати для "
"отримання фактичної кількості надісланих байтів."

msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* встановлений на ``True`` робить asyncio для ручного читання та "
"надсилання файлу, коли платформа не підтримує системний виклик sendfile "
"(наприклад, Windows або SSL-сокет на Unix)."

msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Викликати :exc:`SendfileNotAvailableError`, якщо система не підтримує "
"системний виклик *sendfile* і *fallback* має значення ``False``."

msgid "TLS Upgrade"
msgstr "Оновлення TLS"

msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Оновіть існуюче транспортне підключення до TLS."

msgid ""
"Return a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""
"Повертає новий транспортний екземпляр, який *протокол* повинен почати "
"використовувати відразу після *чекати*. Екземпляр *transport*, переданий у "
"метод *start_tls*, більше ніколи не використовуватиметься."

msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"екземпляри *transport* і *protocol*, які повертають такі методи, як :meth:"
"`~loop.create_server` і :meth:`~loop.create_connection`."

msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: налаштований екземпляр :class:`~ssl.SSLContext`."

msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* передає ``True``, коли з’єднання на стороні сервера "
"оновлюється (наприклад, створене :meth:`~loop.create_server`)."

msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: встановлює або замінює ім’я хоста, з яким буде "
"зіставлятися сертифікат цільового сервера."

msgid "Watching file descriptors"
msgstr "Перегляд дескрипторів файлів"

msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Розпочніть моніторинг дескриптора файлу *fd* на доступність читання та "
"викличте *callback* із зазначеними аргументами, коли *fd* стане доступним "
"для читання."

msgid "Stop monitoring the *fd* file descriptor for read availability."
msgstr "Припиніть моніторинг дескриптора файлу *fd* на доступність читання."

msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Розпочніть моніторинг дескриптора файлу *fd* на доступність запису та "
"викличте *callback* із зазначеними аргументами, коли *fd* стане доступним "
"для запису."

msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Використовуйте :func:`functools.partial` :ref:`, щоб передати аргументи "
"ключового слова <asyncio-pass-keywords>` в *callback*."

msgid "Stop monitoring the *fd* file descriptor for write availability."
msgstr "Припиніть моніторинг дескриптора файлу *fd* для доступності запису."

msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"Перегляньте також розділ :ref:`Підтримка платформи <asyncio-platform-"
"support>`, щоб дізнатися про деякі обмеження цих методів."

msgid "Working with socket objects directly"
msgstr "Безпосередня робота з об'єктами сокетів"

msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"Загалом, реалізації протоколів, які використовують API на основі транспорту, "
"такі як :meth:`loop.create_connection` і :meth:`loop.create_server`, є "
"швидшими, ніж реалізації, які працюють безпосередньо з сокетами. Однак є "
"деякі випадки використання, коли продуктивність не є критичною, і працювати "
"з об’єктами :class:`~socket.socket` напряму зручніше."

msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"Отримайте до *nbytes* від *sock*. Асинхронна версія :meth:`socket.recv() "
"<socket.socket.recv>`."

msgid "Return the received data as a bytes object."
msgstr "Повернути отримані дані як об’єкт bytes."

msgid "*sock* must be a non-blocking socket."
msgstr "*sock* має бути неблокуючим сокетом."

msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"Незважаючи на те, що цей метод завжди документувався як метод співпрограми, "
"випуски до Python 3.7 повертали :class:`Future`. Починаючи з Python 3.7, це "
"метод ``async def``."

msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Отримувати дані з *sock* в буфер *buf*. Створено за методом блокування :meth:"
"`socket.recv_into() <socket.socket.recv_into>`."

msgid "Return the number of bytes written to the buffer."
msgstr "Повертає кількість байтів, записаних у буфер."

msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"Надішліть *дані* в сокет *sock*. Асинхронна версія :meth:`socket.sendall() "
"<socket.socket.sendall>`."

msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Цей метод продовжує надсилати дані в сокет, доки не буде надіслано всі дані "
"в *data* або не станеться помилка. ``None`` повертається в разі успіху. У "
"разі помилки виникає виняток. Крім того, немає способу визначити, скільки "
"даних, якщо такі були, було успішно оброблено приймальною стороною з’єднання."

msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

msgid "Connect *sock* to a remote socket at *address*."
msgstr "Підключіть *sock* до віддаленої розетки за *адресою*."

msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Асинхронна версія :meth:`socket.connect() <socket.socket.connect>`."

msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` більше не потребує вирішення. ``sock_connect`` спробує "
"перевірити, чи *адреса* вже дозволена, викликавши :func:`socket.inet_pton`. "
"Якщо ні, :meth:`loop.getaddrinfo` буде використано для визначення *адреси*."

msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` і :func:`asyncio.open_connection() "
"<open_connection>`."

msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Прийняти підключення. Створено за методом блокування :meth:`socket.accept() "
"<socket.socket.accept>`."

msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"Сокет має бути прив’язаний до адреси та прослуховувати підключення. "
"Поверненим значенням є пара ``(conn, address)``, де *conn* — це *новий* "
"об’єкт сокета, який можна використовувати для надсилання та отримання даних "
"під час з’єднання, а *address* — це адреса, прив’язана до сокета на іншому "
"кінець з'єднання."

msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"Незважаючи на те, що метод завжди документувався як метод співпрограми, до "
"Python 3.7 він повертав :class:`Future`. Починаючи з Python 3.7, це метод "
"``async def``."

msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` і :func:`start_server`."

msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Якщо можливо, надішліть файл за допомогою високопродуктивного :mod:`os."
"sendfile`. Повертає загальну кількість надісланих байтів."

msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr "Асинхронна версія :meth:`socket.sendfile() <socket.socket.sendfile>`."

msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* має бути неблокуючим :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."

msgid "*file* must be a regular file object open in binary mode."
msgstr ""
"*file* має бути звичайним файловим об’єктом, відкритим у двійковому режимі."

msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, якщо встановлено значення ``True``, змушує asyncio читати та "
"надсилати файл вручну, якщо платформа не підтримує системний виклик sendfile "
"(наприклад, Windows або сокет SSL в Unix)."

msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Викликати :exc:`SendfileNotAvailableError`, якщо система не підтримує "
"системний виклик *sendfile* і *fallback* має значення ``False``."

msgid "DNS"
msgstr "DNS"

msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Асинхронна версія :meth:`socket.getaddrinfo`."

msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Асинхронна версія :meth:`socket.getnameinfo`."

msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Обидва методи *getaddrinfo* і *getnameinfo* завжди були задокументовані для "
"повернення співпрограми, але до Python 3.7 вони фактично повертали об’єкти :"
"class:`asyncio.Future`. Починаючи з Python 3.7 обидва методи є "
"співпрограмами."

msgid "Working with pipes"
msgstr "Робота з трубами"

msgid "Register the read end of *pipe* in the event loop."
msgstr "Зареєструйте прочитаний кінець *pipe* у циклі подій."

msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* — це :term:`файлоподібний об’єкт <file object>`."

msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Повернена пара ``(транспорт, протокол)``, де *transport* підтримує "
"інтерфейс :class:`ReadTransport`, а *protocol* є об’єктом, створеним "
"*protocol_factory*."

msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"За допомогою циклу подій :class:`SelectorEventLoop` *pipe* встановлюється в "
"неблокуючий режим."

msgid "Register the write end of *pipe* in the event loop."
msgstr "Зареєструйте кінець запису *pipe* у циклі подій."

msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* — це :term:`файлоподібний об’єкт <file object>`."

msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Повернена пара ``(транспорт, протокол)``, де *transport* підтримує "
"інтерфейс :class:`WriteTransport`, а *protocol* є об’єктом, створеним "
"*protocol_factory*."

msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` не підтримує наведені вище методи в Windows. "
"Використовуйте :class:`ProactorEventLoop` замість цього для Windows."

msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr "Методи :meth:`loop.subprocess_exec` і :meth:`loop.subprocess_shell`."

msgid "Unix signals"
msgstr "Сигнали Unix"

msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Встановіть *callback* як обробник для сигналу *signum*."

msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"Зворотний виклик буде викликаний *циклом* разом з іншими зворотними "
"викликами в черзі та запущеними співпрограмами цього циклу подій. На відміну "
"від обробників сигналів, зареєстрованих за допомогою :func:`signal.signal`, "
"зворотній виклик, зареєстрований у цій функції, може взаємодіяти з циклом "
"подій."

msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Викликайте :exc:`ValueError`, якщо номер сигналу недійсний або не "
"вловлюється. Викликати :exc:`RuntimeError`, якщо є проблема з налаштуванням "
"обробника."

msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
"Подібно до :func:`signal.signal`, ця функція має бути викликана в основному "
"потоці."

msgid "Remove the handler for the *sig* signal."
msgstr "Видаліть обробник для сигналу *sig*."

msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Повертає ``True``, якщо обробник сигналу було видалено, або ``False``, якщо "
"обробник не встановлено для даного сигналу."

msgid "The :mod:`signal` module."
msgstr "Модуль :mod:`signal`."

msgid "Executing code in thread or process pools"
msgstr "Виконання коду в потоках або пулах процесів"

msgid "Arrange for *func* to be called in the specified executor."
msgstr "Організувати виклик *func* у вказаному виконавці."

msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"Аргумент *executor* має бути екземпляром :class:`concurrent.futures."
"Executor`. Виконавець за замовчуванням використовується, якщо *executor* має "
"значення ``None``."

msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Цей метод повертає об’єкт :class:`asyncio.Future`."

msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Використовуйте :func:`functools.partial` :ref:`, щоб передати аргументи "
"ключового слова <asyncio-pass-keywords>` до *func*."

msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` більше не налаштовує ``max_workers`` виконавця "
"пулу потоків, який він створює, натомість залишаючи його виконавцю пулу "
"потоків (:class:`~concurrent.futures.ThreadPoolExecutor`) для встановлення "
"за замовчуванням."

msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* should be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""

msgid ""
"Using an executor that is not an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor` is deprecated and will trigger an error in Python 3.9."
msgstr ""

msgid ""
"*executor* must be an instance of :class:`concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""

msgid "Error Handling API"
msgstr "API обробки помилок"

msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "Дозволяє налаштувати спосіб обробки винятків у циклі подій."

msgid "Set *handler* as the new event loop exception handler."
msgstr "Встановіть *обробник* як новий обробник винятків циклу подій."

msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"Якщо *обробник* має значення ``None``, буде встановлено обробник винятків за "
"умовчанням. В іншому випадку *обробник* має бути викликом із сигнатурою, що "
"відповідає ``(цикл, контекст)``, де ``цикл`` є посиланням на активний цикл "
"подій, а ``контекст`` є ``dict`` об’єкт, що містить деталі винятку "
"(перегляньте документацію :meth:`call_exception_handler`, щоб дізнатися "
"більше про контекст)."

msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Повертає поточний обробник винятків або ``None``, якщо настроюваний обробник "
"винятків не встановлено."

msgid "Default exception handler."
msgstr "Обробник винятків за замовчуванням."

msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Це викликається, коли виникає виняткова ситуація, а обробник винятків не "
"встановлено. Це може бути викликано спеціальним обробником винятків, який "
"хоче відкласти поведінку обробника за замовчуванням."

msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""
"Параметр *context* має те саме значення, що й у :meth:"
"`call_exception_handler`."

msgid "Call the current event loop exception handler."
msgstr "Викликати обробник винятків поточного циклу подій."

msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* — це об’єкт ``dict``, що містить такі ключі (нові ключі можуть "
"бути представлені в наступних версіях Python):"

msgid "'message': Error message;"
msgstr "'message': повідомлення про помилку;"

msgid "'exception' (optional): Exception object;"
msgstr "'exception' (необов'язковий): об'єкт винятку;"

msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'майбутнє' (необов'язково): екземпляр :class:`asyncio.Future`;"

msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (необов'язковий): :class:`asyncio.Task` екземпляр;"

msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (необов'язковий): :class:`asyncio.Handle` екземпляр;"

msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""
"'протокол' (необов'язково): :ref:`примірник протоколу <asyncio-protocol>`;"

msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (необов'язковий): :ref:`Transport <asyncio-transport>` екземпляр;"

msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (необов'язковий): :class:`socket.socket` екземпляр;"

msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "'asyncgen' (необов'язково): асинхронний генератор, який викликав"

msgid "the exception."
msgstr "виняток."

msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr ""
"Цей метод не слід перевантажувати в циклах подій підкласів. Для спеціальної "
"обробки винятків використовуйте метод :meth:`set_exception_handler()`."

msgid "Enabling debug mode"
msgstr "Увімкнення режиму налагодження"

msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Отримати режим налагодження (:class:`bool`) циклу подій."

msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"Значенням за замовчуванням є ``True``, якщо змінна середовища :envvar:"
"`PYTHONASYNCIODEBUG` має значення непорожнього рядка, ``False`` в іншому "
"випадку."

msgid "Set the debug mode of the event loop."
msgstr "Встановіть режим налагодження циклу подій."

msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"Новий :ref:`Режим розробки Python <devmode>` тепер також можна "
"використовувати для ввімкнення режиму налагодження."

msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`режим налагодження asyncio <asyncio-debug-mode>`."

msgid "Running Subprocesses"
msgstr "Запущені підпроцеси"

msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Методи, описані в цьому підрозділі, є низькорівневими. У звичайному коді "
"async/await розгляньте можливість використовувати натомість зручні функції "
"високого рівня :func:`asyncio.create_subprocess_shell` і :func:`asyncio."
"create_subprocess_exec`."

msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""
"У Windows типовий цикл подій :class:`ProactorEventLoop` підтримує "
"підпроцеси, тоді як :class:`SelectorEventLoop` не підтримує. Дивіться :ref:"
"`Підтримку підпроцесів у Windows <asyncio-windows-subprocess>`, щоб "
"дізнатися більше."

msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Створіть підпроцес з одного або кількох рядкових аргументів, визначених "
"*args*."

msgid "*args* must be a list of strings represented by:"
msgstr "*args* має бути списком рядків, представлених:"

msgid ":class:`str`;"
msgstr ":class:`str`;"

msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"або :class:`bytes`, закодований у :ref:`кодування файлової системи "
"<filesystem-encoding>`."

msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"Перший рядок визначає виконуваний файл програми, а решта рядків визначають "
"аргументи. Разом рядкові аргументи утворюють ``argv`` програми."

msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Це схоже на клас стандартної бібліотеки :class:`subprocess.Popen`, "
"викликаний за допомогою ``shell=False`` і списку рядків, переданих як перший "
"аргумент; однак, якщо :class:`~subprocess.Popen` приймає один аргумент, який "
"є списком рядків, *subprocess_exec* приймає кілька рядкових аргументів."

msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* має бути викликаним, що повертає підклас класу :class:"
"`asyncio.SubprocessProtocol`."

msgid "Other parameters:"
msgstr "Інші параметри:"

msgid "*stdin* can be any of these:"
msgstr "*stdin* може бути будь-яким із цих:"

msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"файлоподібний об’єкт, що представляє трубу, яка буде під’єднана до "
"стандартного вхідного потоку підпроцесу за допомогою :meth:`~loop."
"connect_write_pipe`"

msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"константа :const:`subprocess.PIPE` (за замовчуванням), яка створить новий "
"канал і з’єднає його,"

msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"значення ``None``, яке змусить підпроцес успадкувати дескриптор файлу від "
"цього процесу"

msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
"константа :const:`subprocess.DEVNULL`, яка вказує, що буде використовуватися "
"спеціальний файл :data:`os.devnull`"

msgid "*stdout* can be any of these:"
msgstr "*stdout* може бути будь-яким із цього:"

msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"файлоподібний об’єкт, що представляє трубу, яка буде підключена до "
"стандартного потоку виведення підпроцесу за допомогою :meth:`~loop."
"connect_write_pipe`"

msgid "*stderr* can be any of these:"
msgstr "*stderr* може бути будь-яким із цього:"

msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"файлоподібний об’єкт, що представляє трубу, яка буде підключена до "
"стандартного потоку помилок підпроцесу за допомогою :meth:`~loop."
"connect_write_pipe`"

msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"константа :const:`subprocess.STDOUT`, яка підключатиме стандартний потік "
"помилок до стандартного потоку виводу процесу"

msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"Усі інші аргументи ключових слів передаються до :class:`subprocess.Popen` "
"без інтерпретації, за винятком *bufsize*, *universal_newlines*, *shell*, "
"*text*, *encoding* і *errors*, які не слід вказувати в все."

msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"API підпроцесу ``asyncio`` не підтримує декодування потоків як тексту. :func:"
"`bytes.decode` можна використовувати для перетворення байтів, повернутих із "
"потоку, на текст."

msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"Перегляньте конструктор класу :class:`subprocess.Popen` для документації "
"щодо інших аргументів."

msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Повертає пару \"(transport, protocol)\", де *transport* відповідає базовому "
"класу :class:`asyncio.SubprocessTransport`, а *protocol* є об’єктом, "
"створеним *protocol_factory*."

msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Створіть підпроцес із *cmd*, який може бути :class:`str` або :class:`bytes` "
"рядком, закодованим у :ref:`кодуванні файлової системи <filesystem-"
"encoding>`, використовуючи синтаксис \"оболонки\" платформи."

msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Це схоже на клас стандартної бібліотеки :class:`subprocess.Popen`, що "
"викликається за допомогою ``shell=True``."

msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* має бути викликаним, що повертає підклас класу :class:"
"`SubprocessProtocol`."

msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Перегляньте :meth:`~loop.subprocess_exec` для отримання додаткової "
"інформації про інші аргументи."

msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Повертає пару \"(transport, protocol)\", де *transport* відповідає базовому "
"класу :class:`SubprocessTransport`, а *protocol* є об’єктом, створеним "
"*protocol_factory*."

msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"Програма несе відповідальність за те, щоб усі пробіли та спеціальні символи "
"були взяті в лапки належним чином, щоб уникнути вразливості `впровадження "
"оболонки <https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_. "
"Функцію :func:`shlex.quote` можна використати для правильного екранування "
"пробілів і спеціальних символів у рядках, які використовуватимуться для "
"створення команд оболонки."

msgid "Callback Handles"
msgstr "Ручки зворотного виклику"

msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
"Об’єкт оболонки зворотного виклику, повернутий :meth:`loop.call_soon`, :meth:"
"`loop.call_soon_threadsafe`."

msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"Скасувати зворотний дзвінок. Якщо зворотний виклик уже скасовано або "
"виконано, цей метод не має ефекту."

msgid "Return ``True`` if the callback was cancelled."
msgstr "Повертає ``True``, якщо зворотний виклик було скасовано."

msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
"Об’єкт оболонки зворотного виклику, повернутий :meth:`loop.call_later` і :"
"meth:`loop.call_at`."

msgid "This class is a subclass of :class:`Handle`."
msgstr "Цей клас є підкласом :class:`Handle`."

msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""
"Повертає запланований час зворотного виклику як :class:`float` секунди."

msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"Час – це абсолютна позначка часу, яка використовує те саме посилання на час, "
"що й :meth:`loop.time`."

msgid "Server Objects"
msgstr "Серверні об’єкти"

msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Серверні об’єкти створюються функціями :meth:`loop.create_server`, :meth:"
"`loop.create_unix_server`, :func:`start_server` і :func:`start_unix_server`."

msgid "Do not instantiate the class directly."
msgstr "Не створюйте клас безпосередньо."

msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"Об'єкти *Server* є асинхронними менеджерами контексту. При використанні в "
"операторі ``async with`` гарантується, що об’єкт Server закритий і не "
"приймає нових з’єднань після завершення оператора ``async with``::"

msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""
"Серверний об’єкт — це асинхронний менеджер контексту, починаючи з Python 3.7."

msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Зупинити обслуговування: закрийте сокети прослуховування та встановіть для "
"атрибута :attr:`sockets` значення ``None``."

msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"Сокети, які представляють наявні вхідні підключення клієнта, залишаються "
"відкритими."

msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""
"Сервер закривається асинхронно, скористайтеся співпрограмою :meth:"
"`wait_closed`, щоб дочекатися, поки сервер закриється."

msgid "Return the event loop associated with the server object."
msgstr "Повертає цикл подій, пов’язаний з об’єктом сервера."

msgid "Start accepting connections."
msgstr "Почніть приймати підключення."

msgid ""
"This method is idempotent, so it can be called when the server is already "
"being serving."
msgstr ""

msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"Ключовий параметр *start_serving* для :meth:`loop.create_server` і :meth:"
"`asyncio.start_server` дозволяє створити об’єкт сервера, який спочатку не "
"приймає підключення. У цьому випадку ``Server.start_serving()`` або :meth:"
"`Server.serve_forever` можна використати, щоб сервер почав приймати "
"з’єднання."

msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Почніть приймати підключення, доки співпрограму не буде скасовано. "
"Скасування завдання ``serve_forever`` призводить до закриття сервера."

msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Цей метод можна викликати, якщо сервер уже приймає підключення. На один "
"об’єкт *Server* може існувати лише одне завдання ``serve_forever``."

msgid "Return ``True`` if the server is accepting new connections."
msgstr "Повертає ``True``, якщо сервер приймає нові підключення."

msgid "Wait until the :meth:`close` method completes."
msgstr "Зачекайте, поки метод :meth:`close` завершить роботу."

msgid "List of :class:`socket.socket` objects the server is listening on."
msgstr "Список об’єктів :class:`socket.socket`, які прослуховує сервер."

msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"До Python 3.7 ``Server.sockets`` використовувався для безпосереднього "
"повернення внутрішнього списку серверних сокетів. У 3.7 повертається копія "
"цього списку."

msgid "Event Loop Implementations"
msgstr "Реалізації циклу подій"

msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio постачається з двома різними реалізаціями циклу подій: :class:"
"`SelectorEventLoop` і :class:`ProactorEventLoop`."

msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""
"За замовчуванням asyncio налаштовано на використання :class:"
"`SelectorEventLoop` в Unix і :class:`ProactorEventLoop` у Windows."

msgid "An event loop based on the :mod:`selectors` module."
msgstr "Цикл подій на основі модуля :mod:`selectors`."

msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Використовує найефективніший *селектор*, доступний для даної платформи. "
"Також можна вручну налаштувати точну реалізацію селектора, яка буде "
"використовуватися:"

msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Наявність <availability>`: Unix, Windows."

msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""
"Цикл подій для Windows, який використовує \"Порти завершення введення-"
"виведення\" (IOCP)."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`Документація MSDN щодо портів завершення введення-виведення <https://docs."
"microsoft.com/en-ca/windows/desktop/FileIO/i-o-completion-ports>`_."

msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Абстрактний базовий клас для асинційно-сумісних циклів подій."

msgid ""
"The :ref:`Event Loop Methods <asyncio-event-loop>` section lists all methods "
"that an alternative implementation of ``AbstractEventLoop`` should have "
"defined."
msgstr ""
"У розділі :ref:`Методи циклу подій <asyncio-event-loop>` наведено список "
"усіх методів, які повинна була визначити альтернативна реалізація "
"``AbstractEventLoop``."

msgid "Examples"
msgstr "Приклади"

msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"Зверніть увагу, що всі приклади в цьому розділі **цілеспрямовано** "
"показують, як використовувати API циклу подій низького рівня, такі як :meth:"
"`loop.run_forever` і :meth:`loop.call_soon`. Сучасні асинхронні програми "
"рідко потрібно писати таким чином; подумайте про використання функцій "
"високого рівня, таких як :func:`asyncio.run`."

msgid "Hello World with call_soon()"
msgstr "Привіт, світ із call_soon()"

msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Приклад використання методу :meth:`loop.call_soon` для планування зворотного "
"виклику. Зворотний виклик відображає ``\"Hello World\"``, а потім зупиняє "
"цикл подій::"

msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Подібний приклад :ref:`Hello World <coroutine>`, створений за допомогою "
"співпрограми та функції :func:`run`."

msgid "Display the current date with call_later()"
msgstr "Показати поточну дату за допомогою call_later()"

msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Приклад зворотного виклику, що відображає поточну дату кожну секунду. "
"Зворотний виклик використовує метод :meth:`loop.call_later`, щоб "
"перепланувати себе через 5 секунд, а потім зупинити цикл подій::"

msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"Схожий приклад :ref:`current date <asyncio_example_sleep>`, створений за "
"допомогою співпрограми та функції :func:`run`."

msgid "Watch a file descriptor for read events"
msgstr "Спостерігайте за подіями читання файлового дескриптора"

msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"Зачекайте, доки дескриптор файлу не отримає деякі дані за допомогою методу :"
"meth:`loop.add_reader`, а потім закрийте цикл подій::"

msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"Подібний :ref:`приклад <asyncio_example_create_connection>` з використанням "
"транспортів, протоколів і методу :meth:`loop.create_connection`."

msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"Інший подібний :ref:`приклад <asyncio_example_create_connection-streams>` з "
"використанням високорівневої функції :func:`asyncio.open_connection` і "
"потоків."

msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Встановити обробники сигналів для SIGINT і SIGTERM"

msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Цей приклад ``сигналів`` працює лише в Unix.)"

msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Зареєструвати обробники для сигналів :py:data:`SIGINT` і :py:data:`SIGTERM` "
"за допомогою методу :meth:`loop.add_signal_handler`::"
