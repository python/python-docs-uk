# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-12 08:36+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "Цикл подій"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, "
":source:`Lib/asyncio/base_events.py`"
msgstr ""
"**Вихідний код:** :source:`Lib/asyncio/events.py`, "
":source:`Lib/asyncio/base_events.py`"

#: ../../library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "Передмова"

#: ../../library/asyncio-eventloop.rst:17
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"Цикл подій є ядром кожної асинхронної програми. Цикли подій запускають "
"асинхронні завдання та зворотні виклики, виконують мережеві операції вводу-"
"виводу та запускають підпроцеси."

#: ../../library/asyncio-eventloop.rst:21
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Розробникам додатків зазвичай слід використовувати асинхронні функції "
"високого рівня, такі як :func:`asyncio.run`, і їм рідко потрібно посилатися "
"на об’єкт циклу або викликати його методи. Цей розділ призначений переважно "
"для авторів коду нижчого рівня, бібліотек і фреймворків, яким потрібен "
"точніший контроль над поведінкою циклу подій."

#: ../../library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "Отримання циклу подій"

#: ../../library/asyncio-eventloop.rst:29
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Наступні функції низького рівня можна використовувати для отримання, "
"встановлення або створення циклу подій:"

#: ../../library/asyncio-eventloop.rst:34
msgid "Return the running event loop in the current OS thread."
msgstr "Повернути запущений цикл подій у поточному потоці ОС."

#: ../../library/asyncio-eventloop.rst:36
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:38
msgid "This function can only be called from a coroutine or a callback."
msgstr ""

#: ../../library/asyncio-eventloop.rst:44
msgid "Get the current event loop."
msgstr "Отримати поточний цикл подій."

#: ../../library/asyncio-eventloop.rst:46
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or"
" similar API), this function will always return the running event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:50
msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""

#: ../../library/asyncio-eventloop.rst:53
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function"
" is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Оскільки ця функція має досить складну поведінку (особливо, коли "
"використовуються користувацькі політики циклу подій), використанню функції "
":func:`get_running_loop` краще, ніж :func:`get_event_loop` у співпрограмах і"
" зворотних викликах."

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:62
msgid ""
"Deprecation warning is emitted if there is no current event loop. In some "
"future Python release this will become an error."
msgstr ""

#: ../../library/asyncio-eventloop.rst:68
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr ""

#: ../../library/asyncio-eventloop.rst:72
msgid "Create and return a new event loop object."
msgstr "Створити та повернути новий об’єкт циклу подій."

#: ../../library/asyncio-eventloop.rst:74
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Зауважте, що поведінку функцій :func:`get_event_loop`, "
":func:`set_event_loop` і :func:`new_event_loop` можна змінити шляхом "
":ref:`встановлення спеціальної політики циклу подій <asyncio-policies>`."

#: ../../library/asyncio-eventloop.rst:80
msgid "Contents"
msgstr "Зміст"

#: ../../library/asyncio-eventloop.rst:81
msgid "This documentation page contains the following sections:"
msgstr "Ця сторінка документації містить такі розділи:"

#: ../../library/asyncio-eventloop.rst:83
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"Розділ `Event Loop Methods`_ є довідковою документацією щодо API циклу "
"подій;"

#: ../../library/asyncio-eventloop.rst:86
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and "
":class:`TimerHandle` instances which are returned from scheduling methods "
"such as :meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"Розділ `Callback Handles`_ документує екземпляри :class:`Handle` і "
":class:`TimerHandle`, які повертаються з таких методів планування, як "
":meth:`loop.call_soon` і :meth:`loop.call_later`;"

#: ../../library/asyncio-eventloop.rst:90
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"Розділ `Server Objects`_ документує типи, що повертаються з методів циклу "
"подій, таких як :meth:`loop.create_server`;"

#: ../../library/asyncio-eventloop.rst:93
msgid ""
"The `Event Loop Implementations`_ section documents the "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"Розділ `Event Loop Implementations`_ документує класи "
":class:`SelectorEventLoop` і :class:`ProactorEventLoop`;"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"Розділ `Examples`_ демонструє, як працювати з деякими API циклу подій."

#: ../../library/asyncio-eventloop.rst:103
msgid "Event Loop Methods"
msgstr "Методи циклу подій"

#: ../../library/asyncio-eventloop.rst:105
msgid "Event loops have **low-level** APIs for the following:"
msgstr "Цикли подій мають API **низького рівня** для наступного:"

#: ../../library/asyncio-eventloop.rst:113
msgid "Running and stopping the loop"
msgstr "Запуск і зупинка циклу"

#: ../../library/asyncio-eventloop.rst:117
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr "Виконуйте, доки *future* (примірник :class:`Future`) не завершиться."

#: ../../library/asyncio-eventloop.rst:120
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Якщо аргумент є :ref:`об’єктом співпрограми <coroutine>`, він неявно "
"запланований для виконання як :class:`asyncio.Task`."

#: ../../library/asyncio-eventloop.rst:123
msgid "Return the Future's result or raise its exception."
msgstr "Повернути результат майбутнього або викликати його виключення."

#: ../../library/asyncio-eventloop.rst:127
msgid "Run the event loop until :meth:`stop` is called."
msgstr "Запускайте цикл подій, доки не буде викликано :meth:`stop`."

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"If :meth:`stop` is called before :meth:`run_forever` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled),"
" and then exit."
msgstr ""

#: ../../library/asyncio-eventloop.rst:134
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Якщо :meth:`stop` викликається під час роботи :meth:`run_forever`, цикл "
"запустить поточний пакет зворотних викликів, а потім завершить роботу. "
"Зауважте, що нові зворотні виклики, заплановані зворотними викликами, не "
"виконуватимуться в цьому випадку; натомість вони запустяться під час "
"наступного виклику :meth:`run_forever` або :meth:`run_until_complete`."

#: ../../library/asyncio-eventloop.rst:142
msgid "Stop the event loop."
msgstr "Зупиніть цикл подій."

#: ../../library/asyncio-eventloop.rst:146
msgid "Return ``True`` if the event loop is currently running."
msgstr "Повертає ``True``, якщо цикл подій зараз запущено."

#: ../../library/asyncio-eventloop.rst:150
msgid "Return ``True`` if the event loop was closed."
msgstr "Повертає ``True``, якщо цикл події було закрито."

#: ../../library/asyncio-eventloop.rst:154
msgid "Close the event loop."
msgstr "Закрийте цикл подій."

#: ../../library/asyncio-eventloop.rst:156
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"Під час виклику цієї функції цикл не повинен працювати. Усі зворотні "
"виклики, що очікують на розгляд, буде відхилено."

#: ../../library/asyncio-eventloop.rst:159
msgid ""
"This method clears all queues and shuts down the executor, but does not wait"
" for the executor to finish."
msgstr ""
"Цей метод очищає всі черги та вимикає виконавець, але не чекає, поки "
"виконавець завершить роботу."

#: ../../library/asyncio-eventloop.rst:162
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Цей метод є ідемпотентним і необоротним. Ніякі інші методи не повинні "
"викликатися після закриття циклу подій."

#: ../../library/asyncio-eventloop.rst:167
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""

#: ../../library/asyncio-eventloop.rst:173
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is"
" used."
msgstr ""
"Зауважте, що немає потреби викликати цю функцію, коли використовується "
":func:`asyncio.run`."

#: ../../library/asyncio-eventloop.rst:176
#: ../../library/asyncio-eventloop.rst:1269
#: ../../library/asyncio-eventloop.rst:1712
msgid "Example::"
msgstr "Приклад::"

#: ../../library/asyncio-eventloop.rst:178
msgid ""
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:188
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with "
":meth:`loop.run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:194
msgid ""
"The *timeout* parameter specifies the amount of time (in :class:`float` "
"seconds) the executor will be given to finish joining. With the default, "
"``None``, the executor is allowed an unlimited amount of time."
msgstr ""

#: ../../library/asyncio-eventloop.rst:199
msgid ""
"If the *timeout* is reached, a :exc:`RuntimeWarning` is emitted and the "
"default executor is terminated without waiting for its threads to finish "
"joining."
msgstr ""

#: ../../library/asyncio-eventloop.rst:205
msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr ""

#: ../../library/asyncio-eventloop.rst:210
msgid "Added the *timeout* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:214
msgid "Scheduling callbacks"
msgstr "Планування зворотних дзвінків"

#: ../../library/asyncio-eventloop.rst:218
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Заплануйте виклик *callback* :term:`callback` з аргументами *args* на "
"наступній ітерації циклу подій."

#: ../../library/asyncio-eventloop.rst:221
msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr ""

#: ../../library/asyncio-eventloop.rst:224
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Зворотні виклики викликаються в тому порядку, в якому вони зареєстровані. "
"Кожен зворотній виклик буде викликано рівно один раз."

#: ../../library/asyncio-eventloop.rst:227
msgid ""
"The optional keyword-only *context* argument specifies a custom "
":class:`contextvars.Context` for the *callback* to run in. Callbacks use the"
" current context when no *context* is provided."
msgstr ""

#: ../../library/asyncio-eventloop.rst:231
msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr ""

#: ../../library/asyncio-eventloop.rst:235
msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not"
" thread-safe."
msgstr ""

#: ../../library/asyncio-eventloop.rst:239
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Викликає :exc:`RuntimeError`, якщо викликається в закритому циклі. Це може "
"статися у вторинному потоці, коли основна програма вимикається."

#: ../../library/asyncio-eventloop.rst:243
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Перегляньте розділ :ref:`паралелізм і багатопотоковість <asyncio-"
"multithreading>` документації."

#: ../../library/asyncio-eventloop.rst:246
#: ../../library/asyncio-eventloop.rst:296
#: ../../library/asyncio-eventloop.rst:316
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Додано параметр *context* тільки для ключового слова. Дивіться :pep:`567` "
"для більш детальної інформації."

#: ../../library/asyncio-eventloop.rst:254
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"Більшість функцій планування :mod:`asyncio` не дозволяють передавати ключові"
" аргументи. Для цього скористайтеся :func:`functools.partial`::"

#: ../../library/asyncio-eventloop.rst:257
msgid ""
"# will schedule \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"
msgstr ""

#: ../../library/asyncio-eventloop.rst:261
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"Використання часткових об’єктів зазвичай зручніше, ніж використання лямбда-"
"виразів, оскільки asyncio може краще відтворювати часткові об’єкти в "
"повідомленнях про налагодження та помилки."

#: ../../library/asyncio-eventloop.rst:269
msgid "Scheduling delayed callbacks"
msgstr "Планування відкладених зворотних викликів"

#: ../../library/asyncio-eventloop.rst:271
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track "
"time."
msgstr ""
"Цикл подій надає механізми для планування виклику функцій зворотного виклику"
" в певний момент у майбутньому. Цикл подій використовує монотонні годинники "
"для відстеження часу."

#: ../../library/asyncio-eventloop.rst:278
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Розклад *зворотного виклику* для виклику після заданої *затримки* у секундах"
" (може бути як int, так і float)."

#: ../../library/asyncio-eventloop.rst:281
#: ../../library/asyncio-eventloop.rst:313
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to"
" cancel the callback."
msgstr ""
"Повертається екземпляр :class:`asyncio.TimerHandle`, який можна "
"використовувати для скасування зворотного виклику."

#: ../../library/asyncio-eventloop.rst:284
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* буде передзвонено рівно один раз. Якщо два зворотні виклики "
"заплановано на один і той же час, порядок їх викликів не визначений."

#: ../../library/asyncio-eventloop.rst:288
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use "
":func:`functools.partial`."
msgstr ""
"Додатковий позиційний *args* буде передано зворотному виклику під час його "
"виклику. Якщо ви хочете, щоб зворотній виклик викликався з аргументами "
"ключового слова, використовуйте :func:`functools.partial`."

#: ../../library/asyncio-eventloop.rst:292
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Необов’язковий аргумент *context*, що містить лише ключове слово, дозволяє "
"вказати спеціальний :class:`contextvars.Context` для виконання *зворотного "
"виклику*. Поточний контекст використовується, якщо *контексту* не надано."

#: ../../library/asyncio-eventloop.rst:300
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"У Python 3.7 і раніше з реалізацією циклу подій за замовчуванням *затримка* "
"не могла перевищувати один день. Це було виправлено в Python 3.8."

#: ../../library/asyncio-eventloop.rst:307
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Заплануйте виклик *callback* у вказану абсолютну позначку часу *when* (int "
"або float), використовуючи те саме посилання на час, що й :meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:311
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "Поведінка цього методу така ж, як і :meth:`call_later`."

#: ../../library/asyncio-eventloop.rst:320
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"У Python 3.7 і раніше з реалізацією циклу подій за замовчуванням різниця між"
" *when* і поточним часом не могла перевищувати одного дня. Це було "
"виправлено в Python 3.8."

#: ../../library/asyncio-eventloop.rst:327
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Повертає поточний час у вигляді значення :class:`float` відповідно до "
"внутрішнього монотонного годинника циклу подій."

#: ../../library/asyncio-eventloop.rst:331
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"У Python 3.7 та попередніх версіях тайм-аути (відносна *затримка* або "
"абсолютна *коли*) не повинні перевищувати одного дня. Це було виправлено в "
"Python 3.8."

#: ../../library/asyncio-eventloop.rst:337
msgid "The :func:`asyncio.sleep` function."
msgstr "Функція :func:`asyncio.sleep`."

#: ../../library/asyncio-eventloop.rst:341
msgid "Creating Futures and Tasks"
msgstr "Створення ф'ючерсів і завдань"

#: ../../library/asyncio-eventloop.rst:345
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "Створіть об’єкт :class:`asyncio.Future`, приєднаний до циклу подій."

#: ../../library/asyncio-eventloop.rst:347
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Це найкращий спосіб створення ф’ючерсів в асинхронному режимі. Це дозволяє "
"стороннім циклам подій надавати альтернативні реалізації об’єкта Future (з "
"кращою продуктивністю або інструментарієм)."

#: ../../library/asyncio-eventloop.rst:355
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a "
":class:`Task` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:358
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of "
":class:`Task`."
msgstr ""
"Сторонні цикли подій можуть використовувати власний підклас :class:`Task` "
"для взаємодії. У цьому випадку тип результату є підкласом :class:`Task`."

#: ../../library/asyncio-eventloop.rst:362
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Якщо вказано аргумент *name*, а не ``None``, він встановлюється як назва "
"завдання за допомогою :meth:`Task.set_name`."

#: ../../library/asyncio-eventloop.rst:365
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""

#: ../../library/asyncio-eventloop.rst:369
msgid "Added the *name* parameter."
msgstr "Додано параметр *name*."

#: ../../library/asyncio-eventloop.rst:372
msgid "Added the *context* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:377
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Встановіть фабрику завдань, яка використовуватиметься "
":meth:`loop.create_task`."

#: ../../library/asyncio-eventloop.rst:380
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"context=None)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must return a "
":class:`asyncio.Future`-compatible object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:388
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr "Повертає фабрику завдань або ``None``, якщо використовується типова."

#: ../../library/asyncio-eventloop.rst:392
msgid "Opening network connections"
msgstr "Відкриття мережевих підключень"

#: ../../library/asyncio-eventloop.rst:403
msgid ""
"Open a streaming transport connection to a given address specified by *host*"
" and *port*."
msgstr ""
"Відкрийте потокове транспортне з’єднання за вказаною адресою, указаною "
"*host* і *port*."

#: ../../library/asyncio-eventloop.rst:406
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET` or "
":py:const:`~socket.AF_INET6` depending on *host* (or the *family* argument, "
"if provided)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:410
msgid "The socket type will be :py:const:`~socket.SOCK_STREAM`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:412
#: ../../library/asyncio-eventloop.rst:1180
#: ../../library/asyncio-eventloop.rst:1196
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* має бути викликом, що повертає реалізацію :ref:`asyncio "
"protocol <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:415
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Цей метод намагатиметься встановити з’єднання у фоновому режимі. У разі "
"успіху він повертає пару ``(транспорт, протокол)``."

#: ../../library/asyncio-eventloop.rst:418
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "Хронологічний синопсис основної операції такий:"

#: ../../library/asyncio-eventloop.rst:420
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"З’єднання встановлюється та для нього створюється :ref:`транспорт <asyncio-"
"transport>`."

#: ../../library/asyncio-eventloop.rst:423
msgid ""
"*protocol_factory* is called without arguments and is expected to return a "
":ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* викликається без аргументів і має повернути екземпляр "
":ref:`protocol <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:426
msgid ""
"The protocol instance is coupled with the transport by calling its "
":meth:`~BaseProtocol.connection_made` method."
msgstr ""
"Екземпляр протоколу з’єднується з транспортом шляхом виклику його методу "
":meth:`~BaseProtocol.connection_made`."

#: ../../library/asyncio-eventloop.rst:429
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "Кортеж ``(транспорт, протокол)`` повертається в разі успіху."

#: ../../library/asyncio-eventloop.rst:431
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"Створений транспорт є двонаправленим потоком, що залежить від реалізації."

#: ../../library/asyncio-eventloop.rst:434
#: ../../library/asyncio-eventloop.rst:566
msgid "Other arguments:"
msgstr "Інші аргументи:"

#: ../../library/asyncio-eventloop.rst:436
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is "
":const:`True`, a default context returned from "
":func:`ssl.create_default_context` is used."
msgstr ""
"*ssl*: якщо задано і не має значення false, створюється транспорт SSL/TLS "
"(за замовчуванням створюється звичайний транспорт TCP). Якщо *ssl* є "
"об’єктом :class:`ssl.SSLContext`, цей контекст використовується для "
"створення транспорту; якщо *ssl* має значення :const:`True`, "
"використовується контекст за замовчуванням, який повертається з "
":func:`ssl.create_default_context`."

#: ../../library/asyncio-eventloop.rst:442
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`Заходи безпеки SSL/TLS <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:444
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* встановлює або замінює ім’я хоста, з яким буде "
"зіставлятися сертифікат цільового сервера. Слід передавати лише якщо *ssl* "
"не є ``None``. За замовчуванням використовується значення аргументу *host*. "
"Якщо *host* порожній, за умовчанням немає, і ви повинні передати значення "
"*server_hostname*. Якщо *server_hostname* є порожнім рядком, збіг імен "
"хостів вимкнено (що є серйозною загрозою безпеці, уможливлюючи потенційні "
"атаки типу \"людина посередині\")."

#: ../../library/asyncio-eventloop.rst:452
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given,"
" these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* — це необов’язкове сімейство адрес, протокол і "
"прапорці, які передаються до getaddrinfo() для вирішення *host*. Якщо "
"задано, усі вони мають бути цілими числами з відповідних констант модуля "
":mod:`socket`."

#: ../../library/asyncio-eventloop.rst:457
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, якщо задано, увімкне Happy Eyeballs для цього "
"підключення. Це має бути число з плаваючою комою, яке представляє кількість "
"часу в секундах, протягом якого потрібно очікувати завершення спроби "
"з’єднання перед початком наступної паралельної спроби. Це \"Затримка спроби "
"підключення\", як визначено в :rfc:`8305`. Розумним стандартним значенням, "
"рекомендованим RFC, є ``0,25`` (250 мілісекунд)."

#: ../../library/asyncio-eventloop.rst:465
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* контролює перевпорядкування адрес, коли ім’я хоста "
"перетворюється на декілька IP-адрес. Якщо ``0`` або не вказано, зміна "
"порядку не виконується, а адреси пробуються в порядку, який повертає "
":meth:`getaddrinfo`. Якщо вказано додатне ціле число, адреси чергуються за "
"сімейством адрес, і задане ціле число інтерпретується як \"Перша кількість "
"сімейства адрес\", як визначено в :rfc:`8305`. Типовим значенням є ``0``, "
"якщо *happy_eyeballs_delay* не вказано, і ``1``, якщо так."

#: ../../library/asyncio-eventloop.rst:474
msgid ""
"*sock*, if given, should be an existing, already connected "
":class:`socket.socket` object to be used by the transport. If *sock* is "
"given, none of *host*, *port*, *family*, *proto*, *flags*, "
"*happy_eyeballs_delay*, *interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, якщо його надано, має бути існуючим, уже підключеним "
":class:`socket.socket` об’єктом, який буде використовуватися транспортом. "
"Якщо вказано *sock*, жоден з *host*, *port*, *family*, *proto*, *flags*, "
"*happy_eyeballs_delay*, *interleave* і *local_addr* не повинен бути "
"вказаний."

#: ../../library/asyncio-eventloop.rst:482
#: ../../library/asyncio-eventloop.rst:597
#: ../../library/asyncio-eventloop.rst:841
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's "
":meth:`~asyncio.BaseTransport.close` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:486
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, якщо вказано, це кортеж ``(local_host, local_port)``, який "
"використовується для локального зв’язування сокета. *local_host* і "
"*local_port* шукаються за допомогою ``getaddrinfo()``, подібно до *host* і "
"*port*."

#: ../../library/asyncio-eventloop.rst:490
#: ../../library/asyncio-eventloop.rst:935
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — це (для з’єднання TLS) час у секундах очікування "
"завершення рукостискання TLS перед перериванням з’єднання. ``60.0`` секунд, "
"якщо ``None`` (за замовчуванням)."

#: ../../library/asyncio-eventloop.rst:494
#: ../../library/asyncio-eventloop.rst:750
#: ../../library/asyncio-eventloop.rst:852
#: ../../library/asyncio-eventloop.rst:939
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:498
msgid ""
"*all_errors* determines what exceptions are raised when a connection cannot "
"be created. By default, only a single ``Exception`` is raised: the first "
"exception if there is only one or all errors have same message, or a single "
"``OSError`` with the error messages combined. When ``all_errors`` is "
"``True``, an ``ExceptionGroup`` will be raised containing all exceptions "
"(even if there is only one)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:508
#: ../../library/asyncio-eventloop.rst:762
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Додано підтримку SSL/TLS у :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:512
msgid ""
"The socket option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set "
"by default for all TCP connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:517
#: ../../library/asyncio-eventloop.rst:862
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Додано параметр *ssl_handshake_timeout*."

#: ../../library/asyncio-eventloop.rst:521
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Додано параметри *happy_eyeballs_delay* і *interleave*."

#: ../../library/asyncio-eventloop.rst:523
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""

#: ../../library/asyncio-eventloop.rst:532
msgid "For more information: https://datatracker.ietf.org/doc/html/rfc6555"
msgstr ""

#: ../../library/asyncio-eventloop.rst:536
#: ../../library/asyncio-eventloop.rst:660
#: ../../library/asyncio-eventloop.rst:776
#: ../../library/asyncio-eventloop.rst:815
#: ../../library/asyncio-eventloop.rst:866
#: ../../library/asyncio-eventloop.rst:947
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:538
msgid "*all_errors* was added."
msgstr ""

#: ../../library/asyncio-eventloop.rst:543
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be"
" used directly in async/await code."
msgstr ""
"Функція :func:`open_connection` є альтернативним API високого рівня. Він "
"повертає пару (:class:`StreamReader`, :class:`StreamWriter`), яку можна "
"використовувати безпосередньо в коді async/await."

#: ../../library/asyncio-eventloop.rst:553
msgid "Create a datagram connection."
msgstr "Створіть з'єднання дейтаграми."

#: ../../library/asyncio-eventloop.rst:555
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET`, "
":py:const:`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`, depending on "
"*host* (or the *family* argument, if provided)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:559
msgid "The socket type will be :py:const:`~socket.SOCK_DGRAM`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:561
#: ../../library/asyncio-eventloop.rst:686
#: ../../library/asyncio-eventloop.rst:833
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* має бути викликом, що повертає реалізацію :ref:`protocol "
"<asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:564
#: ../../library/asyncio-eventloop.rst:642
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "Кортеж ``(транспорт, протокол)`` повертається в разі успіху."

#: ../../library/asyncio-eventloop.rst:568
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket locally.  The *local_host* and *local_port* are looked up using "
":meth:`getaddrinfo`."
msgstr ""
"*local_addr*, якщо вказано, це кортеж ``(local_host, local_port)``, який "
"використовується для локального зв’язування сокета. *local_host* і "
"*local_port* шукаються за допомогою :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:572
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port*"
" are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, якщо вказано, це кортеж ``(remote_host, remote_port)``, який "
"використовується для підключення сокета до віддаленої адреси. *remote_host* "
"і *remote_port* шукаються за допомогою :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:576
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* – це необов’язкове сімейство адрес, протокол і "
"прапори, які передаються до :meth:`getaddrinfo` для вирішення *host*. Якщо "
"задано, усі вони мають бути цілими числами з відповідних констант модуля "
":mod:`socket`."

#: ../../library/asyncio-eventloop.rst:581
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows and some "
"Unixes. If the :ref:`socket.SO_REUSEPORT <socket-unix-constants>` constant "
"is not defined then this capability is unsupported."
msgstr ""

#: ../../library/asyncio-eventloop.rst:587
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* повідомляє ядру дозволити цій кінцевій точці надсилати "
"повідомлення на широкомовну адресу."

#: ../../library/asyncio-eventloop.rst:590
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be "
":const:`None`)."
msgstr ""
"Опціонально можна вказати *sock*, щоб використовувати існуючий, уже "
"підключений об’єкт :class:`socket.socket`, який буде використовуватися "
"транспортом. Якщо вказано, *local_addr* і *remote_addr* слід опустити (має "
"бути :const:`None`)."

#: ../../library/asyncio-eventloop.rst:601
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and "
":ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Перегляньте приклади :ref:`UDP echo client protocol <asyncio-udp-echo-"
"client-protocol>` і :ref:`UDP echo server protocol <asyncio-udp-echo-server-"
"protocol>` прикладів."

#: ../../library/asyncio-eventloop.rst:604
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""

#: ../../library/asyncio-eventloop.rst:608
msgid "Added support for Windows."
msgstr "Додана підтримка Windows."

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"The *reuse_address* parameter is no longer supported, as using "
":ref:`socket.SO_REUSEADDR <socket-unix-constants>` poses a significant "
"security concern for UDP. Explicitly passing ``reuse_address=True`` will "
"raise an exception."
msgstr ""

#: ../../library/asyncio-eventloop.rst:617
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Коли кілька процесів з різними UID призначають сокети ідентичній адресі "
"сокета UDP за допомогою ``SO_REUSEADDR``, вхідні пакети можуть розподілятися"
" між сокетами випадковим чином."

#: ../../library/asyncio-eventloop.rst:621
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :ref:`socket.SO_REUSEPORT <socket-"
"unix-constants>` is used instead, which specifically prevents processes with"
" differing UIDs from assigning sockets to the same socket address."
msgstr ""

#: ../../library/asyncio-eventloop.rst:628
msgid ""
"The *reuse_address* parameter, disabled since Python 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:637
msgid "Create a Unix connection."
msgstr "Створіть підключення Unix."

#: ../../library/asyncio-eventloop.rst:639
msgid ""
"The socket family will be :py:const:`~socket.AF_UNIX`; socket type will be "
":py:const:`~socket.SOCK_STREAM`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:644
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* — це ім’я сокета домену Unix і є обов’язковим, якщо не вказано "
"параметр *sock*. Підтримуються абстрактні сокети Unix, шляхи :class:`str`, "
":class:`bytes` і :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:649
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Перегляньте документацію методу :meth:`loop.create_connection`, щоб отримати"
" інформацію про аргументи цього методу."

#: ../../library/asyncio-eventloop.rst:652
#: ../../library/asyncio-eventloop.rst:806
#: ../../library/asyncio-eventloop.rst:1249
#: ../../library/asyncio-eventloop.rst:1782
#: ../../library/asyncio-eventloop.rst:1789
msgid "Availability"
msgstr ""

#: ../../library/asyncio-eventloop.rst:654
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be"
" a :term:`path-like object`."
msgstr ""
"Додано параметр *ssl_handshake_timeout*. Параметр *path* тепер може бути "
":term:`path-like object`."

#: ../../library/asyncio-eventloop.rst:664
msgid "Creating network servers"
msgstr "Створення мережевих серверів"

#: ../../library/asyncio-eventloop.rst:679
msgid ""
"Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""

#: ../../library/asyncio-eventloop.rst:682
msgid "Returns a :class:`Server` object."
msgstr "Повертає об’єкт :class:`Server`."

#: ../../library/asyncio-eventloop.rst:684
msgid "Arguments:"
msgstr "Аргументи:"

#: ../../library/asyncio-eventloop.rst:689
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"Для параметра *host* можна встановити кілька типів, які визначають, де "
"сервер буде слухати:"

#: ../../library/asyncio-eventloop.rst:692
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface"
" specified by *host*."
msgstr ""
"Якщо *host* є рядком, сервер TCP прив’язаний до єдиного мережевого "
"інтерфейсу, визначеного *host*."

#: ../../library/asyncio-eventloop.rst:695
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Якщо *host* є послідовністю рядків, TCP-сервер прив’язаний до всіх мережевих"
" інтерфейсів, визначених цією послідовністю."

#: ../../library/asyncio-eventloop.rst:698
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Якщо *host* є порожнім рядком або ``None``, усі інтерфейси передбачаються, і"
" буде повернено список кількох сокетів (швидше за все, один для IPv4 та "
"інший для IPv6)."

#: ../../library/asyncio-eventloop.rst:702
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"Параметр *port* можна встановити, щоб вказати, який порт сервер повинен "
"слухати. Якщо ``0`` або ``None`` (за замовчуванням), буде вибрано випадковий"
" невикористаний порт (зауважте, що якщо *host* розпізнає кілька мережевих "
"інтерфейсів, для кожного інтерфейсу буде вибрано окремий випадковий порт)."

#: ../../library/asyncio-eventloop.rst:707
msgid ""
"*family* can be set to either :const:`socket.AF_INET` or "
":const:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not "
"set, the *family* will be determined from host name (defaults to "
":const:`~socket.AF_UNSPEC`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:712
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* — це бітова маска для :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:714
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"За бажанням можна вказати *sock*, щоб використовувати вже існуючий об’єкт "
"socket. Якщо вказано, *host* і *port* не повинні вказуватися."

#: ../../library/asyncio-eventloop.rst:719
msgid ""
"The *sock* argument transfers ownership of the socket to the server created."
" To close the socket, call the server's :meth:`~asyncio.Server.close` "
"method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:723
msgid ""
"*backlog* is the maximum number of queued connections passed to "
":meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* — це максимальна кількість підключень у черзі, переданих до "
":meth:`~socket.socket.listen` (за замовчуванням 100)."

#: ../../library/asyncio-eventloop.rst:726
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* можна встановити як екземпляр :class:`~ssl.SSLContext`, щоб увімкнути "
"TLS через прийнятні з’єднання."

#: ../../library/asyncio-eventloop.rst:729
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* повідомляє ядру повторно використовувати локальний сокет у "
"стані ``TIME_WAIT``, не чекаючи закінчення його природного часу очікування. "
"Якщо не вказано, для Unix буде автоматично встановлено значення ``True``."

#: ../../library/asyncio-eventloop.rst:734
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* повідомляє ядру дозволити цю кінцеву точку прив’язувати до того"
" самого порту, до якого прив’язані інші існуючі кінцеві точки, за умови, що "
"всі вони встановлюють цей прапор під час створення. Цей параметр не "
"підтримується в Windows."

#: ../../library/asyncio-eventloop.rst:739
msgid ""
"*keep_alive* set to ``True`` keeps connections active by enabling the "
"periodic transmission of messages."
msgstr ""

#: ../../library/asyncio-eventloop.rst:744
msgid "Added the *keep_alive* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:746
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — це (для TLS-сервера) час у секундах очікування "
"завершення рукостискання TLS перед розривом з’єднання. ``60.0`` секунд, якщо"
" ``None`` (за замовчуванням)."

#: ../../library/asyncio-eventloop.rst:754
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever`"
" to make the server to start accepting connections."
msgstr ""
"*start_serving* встановлений на ``True`` (за замовчуванням), змушує "
"створений сервер негайно приймати підключення. Якщо встановлено значення "
"``False``, користувач повинен чекати :meth:`Server.start_serving` або "
":meth:`Server.serve_forever`, щоб змусити сервер почати приймати з’єднання."

#: ../../library/asyncio-eventloop.rst:766
msgid "The *host* parameter can be a sequence of strings."
msgstr "Параметр *host* може бути послідовністю рядків."

#: ../../library/asyncio-eventloop.rst:770
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set by default "
"for all TCP connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:780
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"Функція :func:`start_server` — це альтернативний API вищого рівня, який "
"повертає пару :class:`StreamReader` і :class:`StreamWriter`, які можна "
"використовувати в коді async/await."

#: ../../library/asyncio-eventloop.rst:791
msgid ""
"Similar to :meth:`loop.create_server` but works with the "
":py:const:`~socket.AF_UNIX` socket family."
msgstr ""

#: ../../library/asyncio-eventloop.rst:794
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock*"
" argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`,"
" and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* — це ім’я сокета домену Unix і є обов’язковим, якщо не надано "
"аргумент *sock*. Підтримуються абстрактні сокети Unix, шляхи :class:`str`, "
":class:`bytes` і :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:799
msgid ""
"If *cleanup_socket* is true then the Unix socket will automatically be "
"removed from the filesystem when the server is closed, unless the socket has"
" been replaced after the server has been created."
msgstr ""

#: ../../library/asyncio-eventloop.rst:803
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Перегляньте документацію методу :meth:`loop.create_server` для отримання "
"інформації про аргументи цього методу."

#: ../../library/asyncio-eventloop.rst:810
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path*"
" parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"Додано параметри *ssl_handshake_timeout* і *start_serving*. Параметр *path* "
"тепер може бути об’єктом :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:819
msgid "Added the *cleanup_socket* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:826
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "Оберніть уже прийняте підключення до пари транспорт/протокол."

#: ../../library/asyncio-eventloop.rst:828
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Цей метод може використовуватися серверами, які приймають з’єднання за "
"межами asyncio, але використовують asyncio для їх обробки."

#: ../../library/asyncio-eventloop.rst:831
#: ../../library/asyncio-eventloop.rst:921
msgid "Parameters:"
msgstr "Параметри:"

#: ../../library/asyncio-eventloop.rst:836
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* — це вже існуючий об’єкт сокета, який повертається з "
":meth:`socket.accept <socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:845
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* можна встановити як :class:`~ssl.SSLContext`, щоб увімкнути SSL через "
"прийнятні з’єднання."

#: ../../library/asyncio-eventloop.rst:848
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — це (для з’єднання SSL) час у секундах очікування "
"завершення рукостискання SSL перед розривом з’єднання. ``60.0`` секунд, якщо"
" ``None`` (за замовчуванням)."

#: ../../library/asyncio-eventloop.rst:856
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Повертає пару ``(транспорт, протокол)``."

#: ../../library/asyncio-eventloop.rst:870
msgid "Transferring files"
msgstr "Передача файлів"

#: ../../library/asyncio-eventloop.rst:875
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Надіслати *файл* через *транспорт*. Повертає загальну кількість надісланих "
"байтів."

#: ../../library/asyncio-eventloop.rst:878
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"Метод використовує високопродуктивний :meth:`os.sendfile`, якщо він "
"доступний."

#: ../../library/asyncio-eventloop.rst:880
msgid "*file* must be a regular file object opened in binary mode."
msgstr ""
"*file* має бути звичайним файловим об’єктом, відкритим у двійковому режимі."

#: ../../library/asyncio-eventloop.rst:882
#: ../../library/asyncio-eventloop.rst:1127
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method"
" raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* вказує, звідки почати читання файлу. Якщо вказано, *count* — це "
"загальна кількість байтів для передачі, а не надсилання файлу до досягнення "
"EOF. Позиція файлу завжди оновлюється, навіть якщо цей метод викликає "
"помилку, і :meth:`file.tell() <io.IOBase.tell>` можна використовувати для "
"отримання фактичної кількості надісланих байтів."

#: ../../library/asyncio-eventloop.rst:889
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or"
" SSL socket on Unix)."
msgstr ""
"*fallback* встановлений на ``True`` робить asyncio для ручного читання та "
"надсилання файлу, коли платформа не підтримує системний виклик sendfile "
"(наприклад, Windows або SSL-сокет на Unix)."

#: ../../library/asyncio-eventloop.rst:893
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Викликати :exc:`SendfileNotAvailableError`, якщо система не підтримує "
"системний виклик *sendfile* і *fallback* має значення ``False``."

#: ../../library/asyncio-eventloop.rst:900
msgid "TLS Upgrade"
msgstr "Оновлення TLS"

#: ../../library/asyncio-eventloop.rst:907
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Оновіть існуюче транспортне підключення до TLS."

#: ../../library/asyncio-eventloop.rst:909
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""

#: ../../library/asyncio-eventloop.rst:913
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:918
msgid ""
"In some situations (e.g. when the passed transport is already closing) this "
"may return ``None``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:923
msgid ""
"*transport* and *protocol* instances that methods like "
":meth:`~loop.create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"екземпляри *transport* і *protocol*, які повертають такі методи, як "
":meth:`~loop.create_server` і :meth:`~loop.create_connection`."

#: ../../library/asyncio-eventloop.rst:927
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: налаштований екземпляр :class:`~ssl.SSLContext`."

#: ../../library/asyncio-eventloop.rst:929
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* передає ``True``, коли з’єднання на стороні сервера "
"оновлюється (наприклад, створене :meth:`~loop.create_server`)."

#: ../../library/asyncio-eventloop.rst:932
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: встановлює або замінює ім’я хоста, з яким буде "
"зіставлятися сертифікат цільового сервера."

#: ../../library/asyncio-eventloop.rst:952
msgid "Watching file descriptors"
msgstr "Перегляд дескрипторів файлів"

#: ../../library/asyncio-eventloop.rst:956
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Розпочніть моніторинг дескриптора файлу *fd* на доступність читання та "
"викличте *callback* із зазначеними аргументами, коли *fd* стане доступним "
"для читання."

#: ../../library/asyncio-eventloop.rst:962
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""

#: ../../library/asyncio-eventloop.rst:967
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Розпочніть моніторинг дескриптора файлу *fd* на доступність запису та "
"викличте *callback* із зазначеними аргументами, коли *fd* стане доступним "
"для запису."

#: ../../library/asyncio-eventloop.rst:971
#: ../../library/asyncio-eventloop.rst:1236
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Використовуйте :func:`functools.partial` :ref:`, щоб передати аргументи "
"ключового слова <asyncio-pass-keywords>` в *callback*."

#: ../../library/asyncio-eventloop.rst:976
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""

#: ../../library/asyncio-eventloop.rst:979
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some"
" limitations of these methods."
msgstr ""
"Перегляньте також розділ :ref:`Підтримка платформи <asyncio-platform-"
"support>`, щоб дізнатися про деякі обмеження цих методів."

#: ../../library/asyncio-eventloop.rst:984
msgid "Working with socket objects directly"
msgstr "Безпосередня робота з об'єктами сокетів"

#: ../../library/asyncio-eventloop.rst:986
msgid ""
"In general, protocol implementations that use transport-based APIs such as "
":meth:`loop.create_connection` and :meth:`loop.create_server` are faster "
"than implementations that work with sockets directly. However, there are "
"some use cases when performance is not critical, and working with "
":class:`~socket.socket` objects directly is more convenient."
msgstr ""
"Загалом, реалізації протоколів, які використовують API на основі транспорту,"
" такі як :meth:`loop.create_connection` і :meth:`loop.create_server`, є "
"швидшими, ніж реалізації, які працюють безпосередньо з сокетами. Однак є "
"деякі випадки використання, коли продуктивність не є критичною, і працювати "
"з об’єктами :class:`~socket.socket` напряму зручніше."

#: ../../library/asyncio-eventloop.rst:995
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of "
":meth:`socket.recv() <socket.socket.recv>`."
msgstr ""
"Отримайте до *nbytes* від *sock*. Асинхронна версія :meth:`socket.recv() "
"<socket.socket.recv>`."

#: ../../library/asyncio-eventloop.rst:998
msgid "Return the received data as a bytes object."
msgstr "Повернути отримані дані як об’єкт bytes."

#: ../../library/asyncio-eventloop.rst:1000
#: ../../library/asyncio-eventloop.rst:1014
#: ../../library/asyncio-eventloop.rst:1025
#: ../../library/asyncio-eventloop.rst:1037
#: ../../library/asyncio-eventloop.rst:1052
#: ../../library/asyncio-eventloop.rst:1067
#: ../../library/asyncio-eventloop.rst:1077
#: ../../library/asyncio-eventloop.rst:1103
#: ../../library/asyncio-eventloop.rst:1141
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* має бути неблокуючим сокетом."

#: ../../library/asyncio-eventloop.rst:1002
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this"
" is an ``async def`` method."
msgstr ""
"Незважаючи на те, що цей метод завжди документувався як метод співпрограми, "
"випуски до Python 3.7 повертали :class:`Future`. Починаючи з Python 3.7, це "
"метод ``async def``."

#: ../../library/asyncio-eventloop.rst:1009
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking "
":meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Отримувати дані з *sock* в буфер *buf*. Створено за методом блокування "
":meth:`socket.recv_into() <socket.socket.recv_into>`."

#: ../../library/asyncio-eventloop.rst:1012
msgid "Return the number of bytes written to the buffer."
msgstr "Повертає кількість байтів, записаних у буфер."

#: ../../library/asyncio-eventloop.rst:1020
msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of "
":meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1023
msgid "Return a tuple of (received data, remote address)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1031
msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1035
msgid "Return a tuple of (number of bytes received, remote address)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1043
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of "
":meth:`socket.sendall() <socket.socket.sendall>`."
msgstr ""
"Надішліть *дані* в сокет *sock*. Асинхронна версія :meth:`socket.sendall() "
"<socket.socket.sendall>`."

#: ../../library/asyncio-eventloop.rst:1046
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Цей метод продовжує надсилати дані в сокет, доки не буде надіслано всі дані "
"в *data* або не станеться помилка. ``None`` повертається в разі успіху. У "
"разі помилки виникає виняток. Крім того, немає способу визначити, скільки "
"даних, якщо такі були, було успішно оброблено приймальною стороною "
"з’єднання."

#: ../../library/asyncio-eventloop.rst:1054
#: ../../library/asyncio-eventloop.rst:1105
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"Незважаючи на те, що метод завжди документувався як метод співпрограми, до "
"Python 3.7 він повертав :class:`Future`. Починаючи з Python 3.7, це метод "
"``async def``."

#: ../../library/asyncio-eventloop.rst:1061
msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of "
":meth:`socket.sendto() <socket.socket.sendto>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1065
msgid "Return the number of bytes sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1073
msgid "Connect *sock* to a remote socket at *address*."
msgstr "Підключіть *sock* до віддаленої розетки за *адресою*."

#: ../../library/asyncio-eventloop.rst:1075
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Асинхронна версія :meth:`socket.connect() <socket.socket.connect>`."

#: ../../library/asyncio-eventloop.rst:1079
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling "
":func:`socket.inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to "
"resolve the *address*."
msgstr ""
"``address`` більше не потребує вирішення. ``sock_connect`` спробує "
"перевірити, чи *адреса* вже дозволена, викликавши :func:`socket.inet_pton`. "
"Якщо ні, :meth:`loop.getaddrinfo` буде використано для визначення *адреси*."

#: ../../library/asyncio-eventloop.rst:1088
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` і :func:`asyncio.open_connection() "
"<open_connection>`."

#: ../../library/asyncio-eventloop.rst:1094
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Прийняти підключення. Створено за методом блокування :meth:`socket.accept() "
"<socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:1097
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"Сокет має бути прив’язаний до адреси та прослуховувати підключення. "
"Поверненим значенням є пара ``(conn, address)``, де *conn* — це *новий* "
"об’єкт сокета, який можна використовувати для надсилання та отримання даних "
"під час з’єднання, а *address* — це адреса, прив’язана до сокета на іншому "
"кінець з'єднання."

#: ../../library/asyncio-eventloop.rst:1112
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` і :func:`start_server`."

#: ../../library/asyncio-eventloop.rst:1117
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Якщо можливо, надішліть файл за допомогою високопродуктивного "
":mod:`os.sendfile`. Повертає загальну кількість надісланих байтів."

#: ../../library/asyncio-eventloop.rst:1120
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr "Асинхронна версія :meth:`socket.sendfile() <socket.socket.sendfile>`."

#: ../../library/asyncio-eventloop.rst:1122
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` "
":class:`~socket.socket`."
msgstr ""
"*sock* має бути неблокуючим :const:`socket.SOCK_STREAM` "
":class:`~socket.socket`."

#: ../../library/asyncio-eventloop.rst:1125
msgid "*file* must be a regular file object open in binary mode."
msgstr ""
"*file* має бути звичайним файловим об’єктом, відкритим у двійковому режимі."

#: ../../library/asyncio-eventloop.rst:1134
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, якщо встановлено значення ``True``, змушує asyncio читати та "
"надсилати файл вручну, якщо платформа не підтримує системний виклик sendfile"
" (наприклад, Windows або сокет SSL в Unix)."

#: ../../library/asyncio-eventloop.rst:1138
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Викликати :exc:`SendfileNotAvailableError`, якщо система не підтримує "
"системний виклик *sendfile* і *fallback* має значення ``False``."

#: ../../library/asyncio-eventloop.rst:1147
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:1152
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Асинхронна версія :meth:`socket.getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:1156
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Асинхронна версія :meth:`socket.getnameinfo`."

#: ../../library/asyncio-eventloop.rst:1159
msgid ""
"Both *getaddrinfo* and *getnameinfo* internally utilize their synchronous "
"versions through the loop's default thread pool executor. When this executor"
" is saturated, these methods may experience delays, which higher-level "
"networking libraries may report as increased timeouts. To mitigate this, "
"consider using a custom executor for other user tasks, or setting a default "
"executor with a larger number of workers."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1166
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning "
":class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Обидва методи *getaddrinfo* і *getnameinfo* завжди були задокументовані для "
"повернення співпрограми, але до Python 3.7 вони фактично повертали об’єкти "
":class:`asyncio.Future`. Починаючи з Python 3.7 обидва методи є "
"співпрограмами."

#: ../../library/asyncio-eventloop.rst:1174
msgid "Working with pipes"
msgstr "Робота з трубами"

#: ../../library/asyncio-eventloop.rst:1178
msgid "Register the read end of *pipe* in the event loop."
msgstr "Зареєструйте прочитаний кінець *pipe* у циклі подій."

#: ../../library/asyncio-eventloop.rst:1183
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* — це :term:`файлоподібний об’єкт <file object>`."

#: ../../library/asyncio-eventloop.rst:1185
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the "
":class:`ReadTransport` interface and *protocol* is an object instantiated by"
" the *protocol_factory*."
msgstr ""
"Повернена пара ``(транспорт, протокол)``, де *transport* підтримує інтерфейс"
" :class:`ReadTransport`, а *protocol* є об’єктом, створеним "
"*protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1189
#: ../../library/asyncio-eventloop.rst:1205
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"За допомогою циклу подій :class:`SelectorEventLoop` *pipe* встановлюється в "
"неблокуючий режим."

#: ../../library/asyncio-eventloop.rst:1194
msgid "Register the write end of *pipe* in the event loop."
msgstr "Зареєструйте кінець запису *pipe* у циклі подій."

#: ../../library/asyncio-eventloop.rst:1199
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* — це :term:`файлоподібний об’єкт <file object>`."

#: ../../library/asyncio-eventloop.rst:1201
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports "
":class:`WriteTransport` interface and *protocol* is an object instantiated "
"by the *protocol_factory*."
msgstr ""
"Повернена пара ``(транспорт, протокол)``, де *transport* підтримує інтерфейс"
" :class:`WriteTransport`, а *protocol* є об’єктом, створеним "
"*protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1210
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` не підтримує наведені вище методи в Windows. "
"Використовуйте :class:`ProactorEventLoop` замість цього для Windows."

#: ../../library/asyncio-eventloop.rst:1215
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr "Методи :meth:`loop.subprocess_exec` і :meth:`loop.subprocess_shell`."

#: ../../library/asyncio-eventloop.rst:1220
msgid "Unix signals"
msgstr "Сигнали Unix"

#: ../../library/asyncio-eventloop.rst:1226
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Встановіть *callback* як обробник для сигналу *signum*."

#: ../../library/asyncio-eventloop.rst:1228
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"Зворотний виклик буде викликаний *циклом* разом з іншими зворотними "
"викликами в черзі та запущеними співпрограмами цього циклу подій. На відміну"
" від обробників сигналів, зареєстрованих за допомогою :func:`signal.signal`,"
" зворотній виклик, зареєстрований у цій функції, може взаємодіяти з циклом "
"подій."

#: ../../library/asyncio-eventloop.rst:1233
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Викликайте :exc:`ValueError`, якщо номер сигналу недійсний або не "
"вловлюється. Викликати :exc:`RuntimeError`, якщо є проблема з налаштуванням "
"обробника."

#: ../../library/asyncio-eventloop.rst:1239
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main "
"thread."
msgstr ""
"Подібно до :func:`signal.signal`, ця функція має бути викликана в основному "
"потоці."

#: ../../library/asyncio-eventloop.rst:1244
msgid "Remove the handler for the *sig* signal."
msgstr "Видаліть обробник для сигналу *sig*."

#: ../../library/asyncio-eventloop.rst:1246
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Повертає ``True``, якщо обробник сигналу було видалено, або ``False``, якщо "
"обробник не встановлено для даного сигналу."

#: ../../library/asyncio-eventloop.rst:1253
msgid "The :mod:`signal` module."
msgstr "Модуль :mod:`signal`."

#: ../../library/asyncio-eventloop.rst:1257
msgid "Executing code in thread or process pools"
msgstr "Виконання коду в потоках або пулах процесів"

#: ../../library/asyncio-eventloop.rst:1261
msgid "Arrange for *func* to be called in the specified executor."
msgstr "Організувати виклик *func* у вказаному виконавці."

#: ../../library/asyncio-eventloop.rst:1263
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``. The "
"default executor can be set by :meth:`loop.set_default_executor`, otherwise,"
" a :class:`concurrent.futures.ThreadPoolExecutor` will be lazy-initialized "
"and used by :func:`run_in_executor` if needed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1271
msgid ""
"import asyncio\n"
"import concurrent.futures\n"
"\n"
"def blocking_io():\n"
"    # File operations (such as logging) can block the\n"
"    # event loop: run them in a thread pool.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"def cpu_bound():\n"
"    # CPU-bound operations will block the event loop:\n"
"    # in general it is preferable to run them in a\n"
"    # process pool.\n"
"    return sum(i * i for i in range(10 ** 7))\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    ## Options:\n"
"\n"
"    # 1. Run in the default loop's executor:\n"
"    result = await loop.run_in_executor(\n"
"        None, blocking_io)\n"
"    print('default thread pool', result)\n"
"\n"
"    # 2. Run in a custom thread pool:\n"
"    with concurrent.futures.ThreadPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, blocking_io)\n"
"        print('custom thread pool', result)\n"
"\n"
"    # 3. Run in a custom process pool:\n"
"    with concurrent.futures.ProcessPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('custom process pool', result)\n"
"\n"
"if __name__ == '__main__':\n"
"    asyncio.run(main())"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1311
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1316
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Цей метод повертає об’єкт :class:`asyncio.Future`."

#: ../../library/asyncio-eventloop.rst:1318
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Використовуйте :func:`functools.partial` :ref:`, щоб передати аргументи "
"ключового слова <asyncio-pass-keywords>` до *func*."

#: ../../library/asyncio-eventloop.rst:1321
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the"
" thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` більше не налаштовує ``max_workers`` виконавця "
"пулу потоків, який він створює, натомість залишаючи його виконавцю пулу "
"потоків (:class:`~concurrent.futures.ThreadPoolExecutor`) для встановлення "
"за замовчуванням."

#: ../../library/asyncio-eventloop.rst:1330
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1334
msgid ""
"*executor* must be an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1340
msgid "Error Handling API"
msgstr "API обробки помилок"

#: ../../library/asyncio-eventloop.rst:1342
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "Дозволяє налаштувати спосіб обробки винятків у циклі подій."

#: ../../library/asyncio-eventloop.rst:1346
msgid "Set *handler* as the new event loop exception handler."
msgstr "Встановіть *обробник* як новий обробник винятків циклу подій."

#: ../../library/asyncio-eventloop.rst:1348
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop,"
" context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about "
"context)."
msgstr ""
"Якщо *обробник* має значення ``None``, буде встановлено обробник винятків за"
" умовчанням. В іншому випадку *обробник* має бути викликом із сигнатурою, що"
" відповідає ``(цикл, контекст)``, де ``цикл`` є посиланням на активний цикл "
"подій, а ``контекст`` є ``dict`` об’єкт, що містить деталі винятку "
"(перегляньте документацію :meth:`call_exception_handler`, щоб дізнатися "
"більше про контекст)."

#: ../../library/asyncio-eventloop.rst:1356
msgid ""
"If the handler is called on behalf of a :class:`~asyncio.Task` or "
":class:`~asyncio.Handle`, it is run in the :class:`contextvars.Context` of "
"that task or callback handle."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1362
msgid ""
"The handler may be called in the :class:`~contextvars.Context` of the task "
"or handle where the exception originated."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1367
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Повертає поточний обробник винятків або ``None``, якщо настроюваний обробник"
" винятків не встановлено."

#: ../../library/asyncio-eventloop.rst:1374
msgid "Default exception handler."
msgstr "Обробник винятків за замовчуванням."

#: ../../library/asyncio-eventloop.rst:1376
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Це викликається, коли виникає виняткова ситуація, а обробник винятків не "
"встановлено. Це може бути викликано спеціальним обробником винятків, який "
"хоче відкласти поведінку обробника за замовчуванням."

#: ../../library/asyncio-eventloop.rst:1380
msgid ""
"*context* parameter has the same meaning as in "
":meth:`call_exception_handler`."
msgstr ""
"Параметр *context* має те саме значення, що й у "
":meth:`call_exception_handler`."

#: ../../library/asyncio-eventloop.rst:1385
msgid "Call the current event loop exception handler."
msgstr "Викликати обробник винятків поточного циклу подій."

#: ../../library/asyncio-eventloop.rst:1387
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* — це об’єкт ``dict``, що містить такі ключі (нові ключі можуть "
"бути представлені в наступних версіях Python):"

#: ../../library/asyncio-eventloop.rst:1390
msgid "'message': Error message;"
msgstr "'message': повідомлення про помилку;"

#: ../../library/asyncio-eventloop.rst:1391
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (необов'язковий): об'єкт винятку;"

#: ../../library/asyncio-eventloop.rst:1392
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'майбутнє' (необов'язково): екземпляр :class:`asyncio.Future`;"

#: ../../library/asyncio-eventloop.rst:1393
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (необов'язковий): :class:`asyncio.Task` екземпляр;"

#: ../../library/asyncio-eventloop.rst:1394
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (необов'язковий): :class:`asyncio.Handle` екземпляр;"

#: ../../library/asyncio-eventloop.rst:1395
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""
"'протокол' (необов'язково): :ref:`примірник протоколу <asyncio-protocol>`;"

#: ../../library/asyncio-eventloop.rst:1396
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (необов'язковий): :ref:`Transport <asyncio-transport>` "
"екземпляр;"

#: ../../library/asyncio-eventloop.rst:1397
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (необов'язковий): :class:`socket.socket` екземпляр;"

#: ../../library/asyncio-eventloop.rst:1398
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "'asyncgen' (необов'язково): асинхронний генератор, який викликав"

#: ../../library/asyncio-eventloop.rst:1399
msgid "the exception."
msgstr "виняток."

#: ../../library/asyncio-eventloop.rst:1403
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1408
msgid "Enabling debug mode"
msgstr "Увімкнення режиму налагодження"

#: ../../library/asyncio-eventloop.rst:1412
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Отримати режим налагодження (:class:`bool`) циклу подій."

#: ../../library/asyncio-eventloop.rst:1414
msgid ""
"The default value is ``True`` if the environment variable "
":envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` "
"otherwise."
msgstr ""
"Значенням за замовчуванням є ``True``, якщо змінна середовища "
":envvar:`PYTHONASYNCIODEBUG` має значення непорожнього рядка, ``False`` в "
"іншому випадку."

#: ../../library/asyncio-eventloop.rst:1420
msgid "Set the debug mode of the event loop."
msgstr "Встановіть режим налагодження циклу подій."

#: ../../library/asyncio-eventloop.rst:1424
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"Новий :ref:`Режим розробки Python <devmode>` тепер також можна "
"використовувати для ввімкнення режиму налагодження."

#: ../../library/asyncio-eventloop.rst:1429
msgid ""
"This attribute can be used to set the minimum execution duration in seconds "
"that is considered \"slow\". When debug mode is enabled, \"slow\" callbacks "
"are logged."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1433
msgid "Default value is 100 milliseconds."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1437
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`режим налагодження asyncio <asyncio-debug-mode>`."

#: ../../library/asyncio-eventloop.rst:1441
msgid "Running Subprocesses"
msgstr "Запущені підпроцеси"

#: ../../library/asyncio-eventloop.rst:1443
msgid ""
"Methods described in this subsections are low-level.  In regular async/await"
" code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Методи, описані в цьому підрозділі, є низькорівневими. У звичайному коді "
"async/await розгляньте можливість використовувати натомість зручні функції "
"високого рівня :func:`asyncio.create_subprocess_shell` і "
":func:`asyncio.create_subprocess_exec`."

#: ../../library/asyncio-eventloop.rst:1450
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See "
":ref:`Subprocess Support on Windows <asyncio-windows-subprocess>` for "
"details."
msgstr ""
"У Windows типовий цикл подій :class:`ProactorEventLoop` підтримує "
"підпроцеси, тоді як :class:`SelectorEventLoop` не підтримує. Дивіться "
":ref:`Підтримку підпроцесів у Windows <asyncio-windows-subprocess>`, щоб "
"дізнатися більше."

#: ../../library/asyncio-eventloop.rst:1461
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Створіть підпроцес з одного або кількох рядкових аргументів, визначених "
"*args*."

#: ../../library/asyncio-eventloop.rst:1464
msgid "*args* must be a list of strings represented by:"
msgstr "*args* має бути списком рядків, представлених:"

#: ../../library/asyncio-eventloop.rst:1466
msgid ":class:`str`;"
msgstr ":class:`str`;"

#: ../../library/asyncio-eventloop.rst:1467
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"або :class:`bytes`, закодований у :ref:`кодування файлової системи "
"<filesystem-encoding>`."

#: ../../library/asyncio-eventloop.rst:1470
msgid ""
"The first string specifies the program executable, and the remaining strings"
" specify the arguments.  Together, string arguments form the ``argv`` of the"
" program."
msgstr ""
"Перший рядок визначає виконуваний файл програми, а решта рядків визначають "
"аргументи. Разом рядкові аргументи утворюють ``argv`` програми."

#: ../../library/asyncio-eventloop.rst:1474
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Це схоже на клас стандартної бібліотеки :class:`subprocess.Popen`, "
"викликаний за допомогою ``shell=False`` і списку рядків, переданих як перший"
" аргумент; однак, якщо :class:`~subprocess.Popen` приймає один аргумент, "
"який є списком рядків, *subprocess_exec* приймає кілька рядкових аргументів."

#: ../../library/asyncio-eventloop.rst:1480
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* має бути викликаним, що повертає підклас класу "
":class:`asyncio.SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1483
msgid "Other parameters:"
msgstr "Інші параметри:"

#: ../../library/asyncio-eventloop.rst:1485
msgid "*stdin* can be any of these:"
msgstr "*stdin* може бути будь-яким із цих:"

#: ../../library/asyncio-eventloop.rst:1487
#: ../../library/asyncio-eventloop.rst:1498
#: ../../library/asyncio-eventloop.rst:1508
msgid "a file-like object"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1488
msgid ""
"an existing file descriptor (a positive integer), for example those created "
"with :meth:`os.pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1489
#: ../../library/asyncio-eventloop.rst:1499
#: ../../library/asyncio-eventloop.rst:1509
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe"
" and connect it,"
msgstr ""
"константа :const:`subprocess.PIPE` (за замовчуванням), яка створить новий "
"канал і з’єднає його,"

#: ../../library/asyncio-eventloop.rst:1491
#: ../../library/asyncio-eventloop.rst:1501
#: ../../library/asyncio-eventloop.rst:1511
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"значення ``None``, яке змусить підпроцес успадкувати дескриптор файлу від "
"цього процесу"

#: ../../library/asyncio-eventloop.rst:1493
#: ../../library/asyncio-eventloop.rst:1503
#: ../../library/asyncio-eventloop.rst:1513
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special "
":data:`os.devnull` file will be used"
msgstr ""
"константа :const:`subprocess.DEVNULL`, яка вказує, що буде використовуватися"
" спеціальний файл :data:`os.devnull`"

#: ../../library/asyncio-eventloop.rst:1496
msgid "*stdout* can be any of these:"
msgstr "*stdout* може бути будь-яким із цього:"

#: ../../library/asyncio-eventloop.rst:1506
msgid "*stderr* can be any of these:"
msgstr "*stderr* може бути будь-яким із цього:"

#: ../../library/asyncio-eventloop.rst:1515
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"константа :const:`subprocess.STDOUT`, яка підключатиме стандартний потік "
"помилок до стандартного потоку виводу процесу"

#: ../../library/asyncio-eventloop.rst:1518
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*,"
" *encoding* and *errors*, which should not be specified at all."
msgstr ""
"Усі інші аргументи ключових слів передаються до :class:`subprocess.Popen` "
"без інтерпретації, за винятком *bufsize*, *universal_newlines*, *shell*, "
"*text*, *encoding* і *errors*, які не слід вказувати в все."

#: ../../library/asyncio-eventloop.rst:1523
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"API підпроцесу ``asyncio`` не підтримує декодування потоків як тексту. "
":func:`bytes.decode` можна використовувати для перетворення байтів, "
"повернутих із потоку, на текст."

#: ../../library/asyncio-eventloop.rst:1527
msgid ""
"If a file-like object passed as *stdin*, *stdout* or *stderr* represents a "
"pipe, then the other side of this pipe should be registered with "
":meth:`~loop.connect_write_pipe` or :meth:`~loop.connect_read_pipe` for use "
"with the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1532
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation"
" on other arguments."
msgstr ""
"Перегляньте конструктор класу :class:`subprocess.Popen` для документації "
"щодо інших аргументів."

#: ../../library/asyncio-eventloop.rst:1535
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Повертає пару \"(transport, protocol)\", де *transport* відповідає базовому "
"класу :class:`asyncio.SubprocessTransport`, а *protocol* є об’єктом, "
"створеним *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1543
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a "
":class:`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Створіть підпроцес із *cmd*, який може бути :class:`str` або :class:`bytes` "
"рядком, закодованим у :ref:`кодуванні файлової системи <filesystem-"
"encoding>`, використовуючи синтаксис \"оболонки\" платформи."

#: ../../library/asyncio-eventloop.rst:1548
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Це схоже на клас стандартної бібліотеки :class:`subprocess.Popen`, що "
"викликається за допомогою ``shell=True``."

#: ../../library/asyncio-eventloop.rst:1551
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* має бути викликаним, що повертає підклас класу "
":class:`SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1554
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Перегляньте :meth:`~loop.subprocess_exec` для отримання додаткової "
"інформації про інші аргументи."

#: ../../library/asyncio-eventloop.rst:1557
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Повертає пару \"(transport, protocol)\", де *transport* відповідає базовому "
"класу :class:`SubprocessTransport`, а *protocol* є об’єктом, створеним "
"*protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1562
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"Програма несе відповідальність за те, щоб усі пробіли та спеціальні символи "
"були взяті в лапки належним чином, щоб уникнути вразливості `впровадження "
"оболонки <https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_. "
"Функцію :func:`shlex.quote` можна використати для правильного екранування "
"пробілів і спеціальних символів у рядках, які використовуватимуться для "
"створення команд оболонки."

#: ../../library/asyncio-eventloop.rst:1571
msgid "Callback Handles"
msgstr "Ручки зворотного виклику"

#: ../../library/asyncio-eventloop.rst:1575
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, "
":meth:`loop.call_soon_threadsafe`."
msgstr ""
"Об’єкт оболонки зворотного виклику, повернутий :meth:`loop.call_soon`, "
":meth:`loop.call_soon_threadsafe`."

#: ../../library/asyncio-eventloop.rst:1580
msgid ""
"Return the :class:`contextvars.Context` object associated with the handle."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1587
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed,"
" this method has no effect."
msgstr ""
"Скасувати зворотний дзвінок. Якщо зворотний виклик уже скасовано або "
"виконано, цей метод не має ефекту."

#: ../../library/asyncio-eventloop.rst:1592
msgid "Return ``True`` if the callback was cancelled."
msgstr "Повертає ``True``, якщо зворотний виклик було скасовано."

#: ../../library/asyncio-eventloop.rst:1598
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and "
":meth:`loop.call_at`."
msgstr ""
"Об’єкт оболонки зворотного виклику, повернутий :meth:`loop.call_later` і "
":meth:`loop.call_at`."

#: ../../library/asyncio-eventloop.rst:1601
msgid "This class is a subclass of :class:`Handle`."
msgstr "Цей клас є підкласом :class:`Handle`."

#: ../../library/asyncio-eventloop.rst:1605
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""
"Повертає запланований час зворотного виклику як :class:`float` секунди."

#: ../../library/asyncio-eventloop.rst:1607
msgid ""
"The time is an absolute timestamp, using the same time reference as "
":meth:`loop.time`."
msgstr ""
"Час – це абсолютна позначка часу, яка використовує те саме посилання на час,"
" що й :meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:1614
msgid "Server Objects"
msgstr "Серверні об’єкти"

#: ../../library/asyncio-eventloop.rst:1616
msgid ""
"Server objects are created by :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :func:`start_server`, and "
":func:`start_unix_server` functions."
msgstr ""
"Серверні об’єкти створюються функціями :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :func:`start_server` і "
":func:`start_unix_server`."

#: ../../library/asyncio-eventloop.rst:1620
msgid "Do not instantiate the :class:`Server` class directly."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1624
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async"
" with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"Об'єкти *Server* є асинхронними менеджерами контексту. При використанні в "
"операторі ``async with`` гарантується, що об’єкт Server закритий і не "
"приймає нових з’єднань після завершення оператора ``async with``::"

#: ../../library/asyncio-eventloop.rst:1629
msgid ""
"srv = await loop.create_server(...)\n"
"\n"
"async with srv:\n"
"    # some code\n"
"\n"
"# At this point, srv is closed and no longer accepts new connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1637
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""
"Серверний об’єкт — це асинхронний менеджер контексту, починаючи з Python "
"3.7."

#: ../../library/asyncio-eventloop.rst:1640
msgid ""
"This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, "
"3.10.3 and 3.11."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1645
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Зупинити обслуговування: закрийте сокети прослуховування та встановіть для "
"атрибута :attr:`sockets` значення ``None``."

#: ../../library/asyncio-eventloop.rst:1648
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"Сокети, які представляють наявні вхідні підключення клієнта, залишаються "
"відкритими."

#: ../../library/asyncio-eventloop.rst:1651
msgid ""
"The server is closed asynchronously; use the :meth:`wait_closed` coroutine "
"to wait until the server is closed (and no more connections are active)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1657
msgid "Close all existing incoming client connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1659
msgid ""
"Calls :meth:`~asyncio.BaseTransport.close` on all associated transports."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1662
msgid ""
":meth:`close` should be called before :meth:`close_clients` when closing the"
" server to avoid races with new clients connecting."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1669
msgid ""
"Close all existing incoming client connections immediately, without waiting "
"for pending operations to complete."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1672
msgid ""
"Calls :meth:`~asyncio.WriteTransport.abort` on all associated transports."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1675
msgid ""
":meth:`close` should be called before :meth:`abort_clients` when closing the"
" server to avoid races with new clients connecting."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1682
msgid "Return the event loop associated with the server object."
msgstr "Повертає цикл подій, пов’язаний з об’єктом сервера."

#: ../../library/asyncio-eventloop.rst:1688
msgid "Start accepting connections."
msgstr "Почніть приймати підключення."

#: ../../library/asyncio-eventloop.rst:1690
msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1693
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` and"
" :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"Ключовий параметр *start_serving* для :meth:`loop.create_server` і "
":meth:`asyncio.start_server` дозволяє створити об’єкт сервера, який спочатку"
" не приймає підключення. У цьому випадку ``Server.start_serving()`` або "
":meth:`Server.serve_forever` можна використати, щоб сервер почав приймати "
"з’єднання."

#: ../../library/asyncio-eventloop.rst:1704
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Почніть приймати підключення, доки співпрограму не буде скасовано. "
"Скасування завдання ``serve_forever`` призводить до закриття сервера."

#: ../../library/asyncio-eventloop.rst:1708
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Цей метод можна викликати, якщо сервер уже приймає підключення. На один "
"об’єкт *Server* може існувати лише одне завдання ``serve_forever``."

#: ../../library/asyncio-eventloop.rst:1714
msgid ""
"async def client_connected(reader, writer):\n"
"    # Communicate with the client with\n"
"    # reader/writer streams.  For example:\n"
"    await reader.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1730
msgid "Return ``True`` if the server is accepting new connections."
msgstr "Повертає ``True``, якщо сервер приймає нові підключення."

#: ../../library/asyncio-eventloop.rst:1736
msgid ""
"Wait until the :meth:`close` method completes and all active connections "
"have finished."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1741
msgid ""
"List of socket-like objects, ``asyncio.trsock.TransportSocket``, which the "
"server is listening on."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1744
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"До Python 3.7 ``Server.sockets`` використовувався для безпосереднього "
"повернення внутрішнього списку серверних сокетів. У 3.7 повертається копія "
"цього списку."

#: ../../library/asyncio-eventloop.rst:1754
msgid "Event Loop Implementations"
msgstr "Реалізації циклу подій"

#: ../../library/asyncio-eventloop.rst:1756
msgid ""
"asyncio ships with two different event loop implementations: "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio постачається з двома різними реалізаціями циклу подій: "
":class:`SelectorEventLoop` і :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:1759
msgid "By default asyncio is configured to use :class:`EventLoop`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1764
msgid ""
"A subclass of :class:`AbstractEventLoop` based on the :mod:`selectors` "
"module."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1767
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Використовує найефективніший *селектор*, доступний для даної платформи. "
"Також можна вручну налаштувати точну реалізацію селектора, яка буде "
"використовуватися:"

#: ../../library/asyncio-eventloop.rst:1771
msgid ""
"import asyncio\n"
"import selectors\n"
"\n"
"class MyPolicy(asyncio.DefaultEventLoopPolicy):\n"
"   def new_event_loop(self):\n"
"      selector = selectors.SelectSelector()\n"
"      return asyncio.SelectorEventLoop(selector)\n"
"\n"
"asyncio.set_event_loop_policy(MyPolicy())"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1787
msgid ""
"A subclass of :class:`AbstractEventLoop` for Windows that uses \"I/O "
"Completion Ports\" (IOCP)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1793
msgid ""
"`MSDN documentation on I/O Completion Ports "
"<https://learn.microsoft.com/windows/win32/fileio/i-o-completion-ports>`_."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1798
msgid ""
"An alias to the most efficient available subclass of "
":class:`AbstractEventLoop` for the given platform."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1801
msgid ""
"It is an alias to :class:`SelectorEventLoop` on Unix and "
":class:`ProactorEventLoop` on Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1807
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Абстрактний базовий клас для асинційно-сумісних циклів подій."

#: ../../library/asyncio-eventloop.rst:1809
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1815
msgid "Examples"
msgstr "Приклади"

#: ../../library/asyncio-eventloop.rst:1817
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and "
":meth:`loop.call_soon`.  Modern asyncio applications rarely need to be "
"written this way; consider using the high-level functions like "
":func:`asyncio.run`."
msgstr ""
"Зверніть увагу, що всі приклади в цьому розділі **цілеспрямовано** "
"показують, як використовувати API циклу подій низького рівня, такі як "
":meth:`loop.run_forever` і :meth:`loop.call_soon`. Сучасні асинхронні "
"програми рідко потрібно писати таким чином; подумайте про використання "
"функцій високого рівня, таких як :func:`asyncio.run`."

#: ../../library/asyncio-eventloop.rst:1827
msgid "Hello World with call_soon()"
msgstr "Привіт, світ із call_soon()"

#: ../../library/asyncio-eventloop.rst:1829
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Приклад використання методу :meth:`loop.call_soon` для планування зворотного"
" виклику. Зворотний виклик відображає ``\"Hello World\"``, а потім зупиняє "
"цикл подій::"

#: ../../library/asyncio-eventloop.rst:1833
msgid ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\"\n"
"    print('Hello World')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule a call to hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1853
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Подібний приклад :ref:`Hello World <coroutine>`, створений за допомогою "
"співпрограми та функції :func:`run`."

#: ../../library/asyncio-eventloop.rst:1860
msgid "Display the current date with call_later()"
msgstr "Показати поточну дату за допомогою call_later()"

#: ../../library/asyncio-eventloop.rst:1862
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Приклад зворотного виклику, що відображає поточну дату кожну секунду. "
"Зворотний виклик використовує метод :meth:`loop.call_later`, щоб "
"перепланувати себе через 5 секунд, а потім зупинити цикл подій::"

#: ../../library/asyncio-eventloop.rst:1866
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(end_time, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    else:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule the first call to display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1890
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a"
" coroutine and the :func:`run` function."
msgstr ""
"Схожий приклад :ref:`current date <asyncio_example_sleep>`, створений за "
"допомогою співпрограми та функції :func:`run`."

#: ../../library/asyncio-eventloop.rst:1897
msgid "Watch a file descriptor for read events"
msgstr "Спостерігайте за подіями читання файлового дескриптора"

#: ../../library/asyncio-eventloop.rst:1899
msgid ""
"Wait until a file descriptor received some data using the "
":meth:`loop.add_reader` method and then close the event loop::"
msgstr ""
"Зачекайте, доки дескриптор файлу не отримає деякі дані за допомогою методу "
":meth:`loop.add_reader`, а потім закрийте цикл подій::"

#: ../../library/asyncio-eventloop.rst:1902
msgid ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Create a pair of connected file descriptors\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Received:\", data.decode())\n"
"\n"
"    # We are done: unregister the file descriptor\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Stop the event loop\n"
"    loop.stop()\n"
"\n"
"# Register the file descriptor for read event\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Run the event loop\n"
"    loop.run_forever()\n"
"finally:\n"
"    # We are done. Close sockets and the event loop.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1937
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"Подібний :ref:`приклад <asyncio_example_create_connection>` з використанням "
"транспортів, протоколів і методу :meth:`loop.create_connection`."

#: ../../library/asyncio-eventloop.rst:1941
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"Інший подібний :ref:`приклад <asyncio_example_create_connection-streams>` з "
"використанням високорівневої функції :func:`asyncio.open_connection` і "
"потоків."

#: ../../library/asyncio-eventloop.rst:1949
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Встановити обробники сигналів для SIGINT і SIGTERM"

#: ../../library/asyncio-eventloop.rst:1951
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Цей приклад ``сигналів`` працює лише в Unix.)"

#: ../../library/asyncio-eventloop.rst:1953
msgid ""
"Register handlers for signals :const:`~signal.SIGINT` and "
":const:`~signal.SIGTERM` using the :meth:`loop.add_signal_handler` method::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1956
msgid ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"got signal %s: exit\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Event loop running for 1 hour, press Ctrl+C to interrupt.\")\n"
"print(f\"pid {os.getpid()}: send SIGINT or SIGTERM to exit.\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
