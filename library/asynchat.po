# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ":mod:`asynchat` --- обробник команд/відповідей асинхронного сокета"

msgid "**Source code:** :source:`Lib/asynchat.py`"
msgstr "**Вихідний код:** :source:`Lib/asynchat.py`"

msgid ""
":mod:`asynchat` will be removed in Python 3.12 (see :pep:`PEP 594 "
"<594#asynchat>` for details). Please use :mod:`asyncio` instead."
msgstr ""

msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr ""
"Цей модуль існує лише для зворотної сумісності. Для нового коду ми "
"рекомендуємо використовувати :mod:`asyncio`."

msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data` "
"and :meth:`found_terminator` methods. It uses the same asynchronous loop as :"
"mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher` "
"and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new :"
"class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""
"Цей модуль базується на інфраструктурі :mod:`asyncore`, спрощуючи роботу "
"асинхронних клієнтів і серверів і полегшуючи роботу з протоколами, елементи "
"яких завершуються довільними рядками або мають змінну довжину. :mod:"
"`asynchat` визначає абстрактний клас :class:`async_chat`, підклас якого ви "
"створюєте, надаючи реалізацію методів :meth:`collect_incoming_data` і :meth:"
"`found_terminator`. Він використовує той самий асинхронний цикл, що й :mod:"
"`asyncore`, і два типи каналів, :class:`asyncore.dispatcher` і :class:"
"`asynchat.async_chat`, можна вільно змішувати в карті каналів. Зазвичай "
"канал сервера :class:`asyncore.dispatcher` створює нові об’єкти каналу :"
"class:`asynchat.async_chat`, коли отримує вхідні запити на з’єднання."

msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""
"Цей клас є абстрактним підкласом :class:`asyncore.dispatcher`. Щоб практично "
"використовувати код, ви повинні створити підклас :class:`async_chat`, "
"надаючи значущі методи :meth:`collect_incoming_data` і :meth:"
"`found_terminator`. Методи :class:`asyncore.dispatcher` можна "
"використовувати, хоча не всі мають сенс у контексті повідомлення/відповіді."

msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a :c:"
"func:`select` call. Once the polling loop has been started the :class:"
"`async_chat` object's methods are called by the event-processing framework "
"with no action on the part of the programmer."
msgstr ""
"Як і :class:`asyncore.dispatcher`, :class:`async_chat` визначає набір подій, "
"які генеруються аналізом умов сокета після виклику :c:func:`select`. Після "
"запуску циклу опитування методи об’єкта :class:`async_chat` викликаються "
"структурою обробки подій без жодних дій з боку програміста."

msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr ""
"Два атрибути класу можна змінити, щоб покращити продуктивність або, можливо, "
"навіть зберегти пам'ять."

msgid "The asynchronous input buffer size (default ``4096``)."
msgstr "Розмір буфера асинхронного введення (за замовчуванням ``4096``)."

msgid "The asynchronous output buffer size (default ``4096``)."
msgstr "Розмір буфера асинхронного виводу (за замовчуванням ``4096``)."

msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a :abbr:`FIFO (first-in, first-out)` queue of *producers*. A producer "
"need have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty "
"bytes object. At this point the :class:`async_chat` object removes the "
"producer from the queue and starts using the next producer, if any. When the "
"producer queue is empty the :meth:`handle_write` method does nothing. You "
"use the channel object's :meth:`set_terminator` method to describe how to "
"recognize the end of, or an important breakpoint in, an incoming "
"transmission from the remote endpoint."
msgstr ""
"На відміну від :class:`asyncore.dispatcher`, :class:`async_chat` дозволяє "
"вам визначити чергу :abbr:`FIFO (першим увійшов, першим вийшов)` "
"*виробників*. Продюсеру потрібен лише один метод, :meth:`more`, який має "
"повертати дані для передачі по каналу. Виробник вказує на вичерпання "
"(*тобто*, що він більше не містить даних), за допомогою методу :meth:`more`, "
"який повертає порожній об’єкт bytes. У цей момент об’єкт :class:`async_chat` "
"видаляє виробника з черги та починає використовувати наступного виробника, "
"якщо такий є. Коли черга виробника порожня, метод :meth:`handle_write` "
"нічого не робить. Ви використовуєте метод :meth:`set_terminator` об’єкта "
"каналу, щоб описати, як розпізнати кінець або важливу точку зупину вхідної "
"передачі від віддаленої кінцевої точки."

msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods :"
"meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""
"Щоб побудувати функціонуючий підклас :class:`async_chat`, ваші методи "
"введення :meth:`collect_incoming_data` і :meth:`found_terminator` повинні "
"обробляти дані, які отримує канал асинхронно. Методи описані нижче."

msgid ""
"Pushes a ``None`` on to the producer queue. When this producer is popped off "
"the queue it causes the channel to be closed."
msgstr ""
"Вставляє ``None`` до черги виробника. Коли цього виробника видаляють із "
"черги, канал закривається."

msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a :exc:"
"`NotImplementedError` exception."
msgstr ""
"Викликається з *data*, що містить довільну кількість отриманих даних. Метод "
"за замовчуванням, який потрібно перевизначати, викликає виняток :exc:"
"`NotImplementedError`."

msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer queue."
msgstr ""
"У надзвичайних ситуаціях цей метод скидає будь-які дані, що зберігаються у "
"вхідних та/або вихідних буферах і черзі виробника."

msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""
"Викликається, коли вхідний потік даних відповідає умові завершення, "
"встановленій :meth:`set_terminator`. Метод за замовчуванням, який потрібно "
"перевизначати, викликає виняток :exc:`NotImplementedError`. Буферизовані "
"вхідні дані мають бути доступні через атрибут екземпляра."

msgid "Returns the current terminator for the channel."
msgstr "Повертає поточний термінатор для каналу."

msgid ""
"Pushes data on to the channel's queue to ensure its transmission. This is "
"all you need to do to have the channel write the data out to the network, "
"although it is possible to use your own producers in more complex schemes to "
"implement encryption and chunking, for example."
msgstr ""
"Надсилає дані до черги каналу, щоб забезпечити їх передачу. Це все, що вам "
"потрібно зробити, щоб канал записував дані в мережу, хоча можна "
"використовувати власні виробники в складніших схемах, наприклад, для "
"реалізації шифрування та фрагментації."

msgid ""
"Takes a producer object and adds it to the producer queue associated with "
"the channel.  When all currently-pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method "
"and send the data to the remote endpoint."
msgstr ""
"Бере об’єкт виробника та додає його до черги виробника, пов’язаної з "
"каналом. Коли всі надіслані виробники буде вичерпано, канал споживатиме дані "
"цього виробника, викликаючи його метод :meth:`more` і надсилаючи дані до "
"віддаленої кінцевої точки."

msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to "
"handle incoming protocol data."
msgstr ""
"Встановлює умову завершення, яку буде розпізнано на каналі. ``term`` може "
"бути будь-яким із трьох типів значення, що відповідає трьом різним способам "
"обробки вхідних даних протоколу."

msgid "term"
msgstr "термін"

msgid "Description"
msgstr "опис"

msgid "*string*"
msgstr "*рядок*"

msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr ""
"Викличе :meth:`found_terminator`, коли рядок знайдено у вхідному потоці"

msgid "*integer*"
msgstr "*ціле*"

msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr ""
"Викличе :meth:`found_terminator`, коли буде отримано вказану кількість "
"символів"

msgid "``None``"
msgstr "``Жодного``"

msgid "The channel continues to collect data forever"
msgstr "Канал продовжує збирати дані вічно"

msgid ""
"Note that any data following the terminator will be available for reading by "
"the channel after :meth:`found_terminator` is called."
msgstr ""
"Зауважте, що будь-які дані після термінатора будуть доступні для читання "
"каналом після виклику :meth:`found_terminator`."

msgid "asynchat Example"
msgstr "Приклад асинчат"

msgid ""
"The following partial example shows how HTTP requests can be read with :"
"class:`async_chat`.  A web server might create an :class:"
"`http_request_handler` object for each incoming client connection. Notice "
"that initially the channel terminator is set to match the blank line at the "
"end of the HTTP headers, and a flag indicates that the headers are being "
"read."
msgstr ""
"Наступний частковий приклад показує, як HTTP-запити можна читати за "
"допомогою :class:`async_chat`. Веб-сервер може створити об’єкт :class:"
"`http_request_handler` для кожного вхідного підключення клієнта. Зауважте, "
"що початково термінатор каналу встановлено на відповідність порожньому рядку "
"в кінці заголовків HTTP, а прапорець вказує, що заголовки зчитуються."

msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-Length:"
"`` header is used to set a numeric terminator to read the right amount of "
"data from the channel."
msgstr ""
"Після прочитання заголовків, якщо запит має тип POST (що вказує на наявність "
"додаткових даних у вхідному потоці), тоді заголовок ``Content-Length:`` "
"використовується для встановлення числового термінатора для читання "
"потрібної кількості дані з каналу."

msgid ""
"The :meth:`handle_request` method is called once all relevant input has been "
"marshalled, after setting the channel terminator to ``None`` to ensure that "
"any extraneous data sent by the web client are ignored. ::"
msgstr ""
"Метод :meth:`handle_request` викликається після сортування всіх відповідних "
"вхідних даних після встановлення термінатора каналу на ``None``, щоб "
"гарантувати, що будь-які сторонні дані, надіслані веб-клієнтом, "
"ігноруються. ::"
