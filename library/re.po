# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- Операції регулярних виразів"

msgid "**Source code:** :source:`Lib/re.py`"
msgstr ""

msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Цей модуль забезпечує операції зіставлення регулярних виразів, подібні до "
"тих, які є в Perl."

msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"І шаблони, і рядки для пошуку можуть бути рядками Unicode (:class:`str`), а "
"також 8-бітовими рядками (:class:`bytes`). Однак рядки Unicode та 8-бітові "
"рядки не можна змішувати: тобто ви не можете зіставити рядок Unicode з "
"шаблоном байтів або навпаки; так само, коли запитується заміна, рядок заміни "
"має бути того самого типу, що й шаблон, і рядок пошуку."

msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in "
"the future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"У регулярних виразах використовується символ зворотної косої риски "
"(``'\\'``), щоб позначити спеціальні форми або дозволити використовувати "
"спеціальні символи без виклику їх спеціального значення. Це суперечить "
"використанню Python того самого символу для тієї ж мети в рядкових "
"літералах; наприклад, щоб відповідати буквальному зворотному слешу, можливо, "
"доведеться написати ``'\\\\\\\\'`` як рядок шаблону, оскільки регулярний "
"вираз має бути ``\\\\``, а кожен зворотний слеш має бути виражений як ``\\"
"\\`` всередині звичайного рядкового літералу Python. Також зауважте, що будь-"
"які недійсні керуючі послідовності під час використання Python зворотної "
"косої риски в рядкових літералах тепер генерують :exc:`DeprecationWarning`, "
"а в майбутньому це стане :exc:`SyntaxError`. Така поведінка відбуватиметься, "
"навіть якщо це дійсна керуюча послідовність для регулярного виразу."

msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"Рішення полягає у використанні необробленої рядкової нотації Python для "
"шаблонів регулярних виразів; зворотні косі риски не обробляються жодним "
"особливим чином у рядковому літералі з префіксом ``'r'``. Отже, ``r\"\\n\"`` "
"— це двосимвольний рядок, що містить ``'\\'`` і ``'n'``, тоді як ``\"\\n\"`` "
"є односимвольним рядком, що містить новий рядок. Зазвичай шаблони "
"виражаються в коді Python за допомогою цієї необробленої рядкової нотації."

msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Важливо відзначити, що більшість операцій з регулярними виразами доступні як "
"функції та методи на рівні модуля для :ref:`компільованих регулярних виразів "
"<re-objects>`. Функції — це ярлики, які не потребують компіляції об’єкта "
"регулярного виразу, але пропускають деякі параметри тонкого налаштування."

msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"Сторонній модуль `regex <https://pypi.org/project/regex/>`_, який має API, "
"сумісний із модулем стандартної бібліотеки :mod:`re`, але пропонує додаткові "
"функції та більш повну підтримку Unicode."

msgid "Regular Expression Syntax"
msgstr "Синтаксис регулярного виразу"

msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Регулярний вираз (або RE) визначає набір рядків, який йому відповідає; "
"функції в цьому модулі дозволяють вам перевірити, чи збігається певний рядок "
"з даним регулярним виразом (або чи збігається даний регулярний вираз з "
"певним рядком, що зводиться до того самого)."

msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"Регулярні вирази можна об’єднувати для створення нових регулярних виразів; "
"якщо *A* і *B* є регулярними виразами, то *AB* також є регулярним виразом. "
"Загалом, якщо рядок *p* відповідає *A*, а інший рядок *q* відповідає *B*, "
"рядок *pq* відповідатиме AB. Це справедливо, якщо *A* або *B* не містять "
"операції з низьким пріоритетом; граничні умови між *A* і *B*; або мають "
"пронумеровані посилання на групи. Таким чином, складні вирази можна легко "
"побудувати з простіших примітивних виразів, таких як описані тут. Щоб "
"отримати детальну інформацію про теорію та реалізацію регулярних виразів, "
"зверніться до книги Фрідла [Frie09]_ або майже до будь-якого підручника про "
"побудову компілятора."

msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Нижче наведено коротке пояснення формату регулярних виразів. Для отримання "
"додаткової інформації та більш щадної презентації зверніться до :ref:`regex-"
"howto`."

msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Регулярні вирази можуть містити як спеціальні, так і звичайні символи. "
"Більшість звичайних символів, таких як ``'A'``, ``'a'`` або ``'0'``, є "
"найпростішими регулярними виразами; вони просто збігаються. Ви можете "
"об’єднувати звичайні символи, тому ``last`` збігається з рядком ``'last'``. "
"(У решті цього розділу ми будемо писати RE в ``цим особливим стилі``, як "
"правило, без лапок, а рядки для відповідності ``'в одинарних лапках``.)"

msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Деякі символи, наприклад ``'|'`` або ``'(''``, є спеціальними. Спеціальні "
"символи або позначають класи звичайних символів, або впливають на "
"інтерпретацію регулярних виразів навколо них."

msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""

msgid "The special characters are:"
msgstr "Спеціальними символами є:"

msgid "``.``"
msgstr "``.``"

msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(Точка.) У режимі за замовчуванням це відповідає будь-якому символу, крім "
"символу нового рядка. Якщо вказано прапорець :const:`DOTALL`, він відповідає "
"будь-якому символу, включаючи новий рядок."

msgid "``^``"
msgstr "``^``"

msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Caret.) Збігається з початком рядка, а в режимі :const:`MULTILINE` також "
"збігається одразу після кожного нового рядка."

msgid "``$``"
msgstr "``$``"

msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Збігається з кінцем рядка або безпосередньо перед символом нового рядка в "
"кінці рядка, а в режимі :const:`MULTILINE` також збігається перед символом "
"нового рядка. ``foo`` відповідає як 'foo', так і 'foobar', тоді як "
"регулярний вираз ``foo$`` відповідає лише 'foo'. Що ще цікавіше, пошук ``foo."
"$`` у ``'foo1\\nfoo2\\n''`` зазвичай відповідає 'foo2', але 'foo1' у режимі :"
"const:`MULTILINE`; пошук одного ``$`` у ``'foo\\n'`` знайде два (порожні) "
"збіги: один безпосередньо перед символом нового рядка та один у кінці рядка."

msgid "``*``"
msgstr "``*``"

msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Примушує кінцевий RE відповідати 0 або більше повторень попереднього RE, "
"якомога більше повторень. ``ab*`` відповідатиме 'a', 'ab' або 'a', за якими "
"йде будь-яка кількість 'b'."

msgid "``+``"
msgstr "``+``"

msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Примушує кінцевий RE відповідати 1 або більше повторень попереднього RE. "
"``ab+`` відповідатиме 'a', за яким слідує будь-яке ненульове число 'b'; воно "
"не збігатиметься лише з \"а\"."

msgid "``?``"
msgstr "``?``"

msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Примушує результуюче RE відповідати 0 або 1 повторенням попереднього RE. "
"``ab?`` відповідатиме або 'a', або 'ab'."

msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""

msgid "``{m}``"
msgstr "``{m}``"

msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Вказує, що точно *m* копій попереднього RE мають відповідати; менша "
"кількість збігів призводить до того, що весь RE не збігається. Наприклад, "
"``a{6}`` відповідатиме рівно шести символам ``'a'``, але не п’яти."

msgid "``{m,n}``"
msgstr "``{m,n}``"

msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Примушує результуючий RE відповідати від *m* до *n* повторень попереднього "
"RE, намагаючись зіставити якомога більше повторень. Наприклад, ``a{3,5}`` "
"відповідатиме від 3 до 5 символів ``'a'``. Пропуск *m* визначає нижню межу "
"нуля, а пропуск *n* визначає нескінченну верхню межу. Наприклад, ``a{4,}b`` "
"відповідатиме ``'aaaab'`` або тисячі символів ``'a'``, після яких ``'b'``, "
"але не ``' аааб''``. Кому не можна опускати, інакше модифікатор можна "
"сплутати з попередньо описаною формою."

msgid "``{m,n}?``"
msgstr "``{m,n}?``"

msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""

msgid "``\\``"
msgstr "``\\``"

msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Або екранує спеціальні символи (дозволяючи вам зіставляти такі символи, як "
"``'*'``, ``'?''`` і так далі), або сигналізує про спеціальну послідовність; "
"спеціальні послідовності обговорюються нижче."

msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Якщо ви не використовуєте необроблений рядок для вираження шаблону, "
"пам’ятайте, що Python також використовує зворотну косу риску як керуючу "
"послідовність у рядкових літералах; якщо escape-послідовність не "
"розпізнається синтаксичним аналізатором Python, зворотна коса риска та "
"наступний символ включаються в результуючий рядок. Однак, якщо Python "
"розпізнає отриману послідовність, зворотну косу риску слід повторити двічі. "
"Це складно і важко зрозуміти, тому настійно рекомендується використовувати "
"необроблені рядки для всіх виразів, крім найпростіших."

msgid "``[]``"
msgstr "``[]``"

msgid "Used to indicate a set of characters.  In a set:"
msgstr "Використовується для позначення набору символів. В комплекті:"

msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Символи можуть бути перераховані окремо, напр. \"[amk]\" відповідатиме "
"\"a\", \"m\" або \"k\"."

msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Діапазони символів можна вказати, вказавши два символи та розділивши їх "
"символом ``'-'``, наприклад, ``[a-z]`` відповідатиме будь-якій літері ASCII "
"у нижньому регістрі, ``[0-5][0-9]. ]`` відповідатиме всім двозначним числам "
"від ``00`` до ``59``, а ``[0-9A-Fa-f]`` відповідатиме будь-якій "
"шістнадцятковій цифрі. Якщо ``-`` є екранованим (наприклад, ``[a\\-z]``) або "
"якщо він розміщений як перший чи останній символ (наприклад ``[-a]`` або "
"``[a-]`` ), він відповідатиме літералу ``'-'``."

msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"Спеціальні символи втрачають своє особливе значення в наборах. Наприклад, "
"``[(+*)]`` відповідатиме будь-якому з літеральних символів ``'('``, ``'+'``, "
"``'*'`` або ``')'``."

msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"Класи символів, такі як ``\\w`` або ``\\S`` (визначені нижче), також "
"приймаються всередині набору, хоча символи, яким вони відповідають, залежать "
"від режиму :const:`ASCII` або :const:`LOCALE` є чинним."

msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Символи, які не входять до діапазону, можуть бути зіставлені шляхом :dfn:"
"`complementing` набору. Якщо першим символом набору є ``'^'``, усі символи, "
"яких *не* в наборі, будуть зіставлені. Наприклад, ``[^5]`` відповідатиме "
"будь-якому символу, крім ``'5''``, а ``[^^]`` відповідатиме будь-якому "
"символу, крім ``'^'``. ``^`` не має особливого значення, якщо це не перший "
"символ у наборі."

msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"Щоб відповідати літералу ``']''`` всередині набору, поставте перед ним "
"зворотну косу риску або розмістіть його на початку набору. Наприклад, як "
"``[()[\\]{}]``, так і ``[]()[{}]`` відповідатимуть дужці."

msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"У майбутньому може бути додано підтримку вкладених наборів і операцій із "
"наборами, як у `технічному стандарті Unicode #18`_. Це призведе до зміни "
"синтаксису, тож для полегшення цієї зміни :exc:`FutureWarning` наразі буде "
"викликано у неоднозначних випадках. Це включає в себе набори, що починаються "
"з літерала ``'['`` або містять літеральні послідовності символів ``'--'``, "
"``'&&'``, ``'~~'`` і ``'| |'``. Щоб уникнути попередження, екрануйте їх "
"зворотною скісною рискою."

msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` викликається, якщо набір символів містить конструкції, "
"які семантично зміняться в майбутньому."

msgid "``|``"
msgstr "``|``"

msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, де *A* і *B* можуть бути довільними RE, створює регулярний вираз, "
"який відповідатиме *A* або *B*. Таким чином довільна кількість RE може бути "
"розділена символом ``'|'``. Це також можна використовувати всередині груп "
"(див. нижче). Під час сканування цільового рядка RE, розділені ``'|'``, "
"пробуються зліва направо. Якщо один шаблон повністю збігається, ця гілка "
"приймається. Це означає, що як тільки *A* збігається, *B* більше не "
"перевірятиметься, навіть якщо це призведе до довшого загального збігу. "
"Іншими словами, оператор ``'|''`` ніколи не є жадібним. Щоб відповідати "
"літералу ``'|'``, використовуйте ``\\|`` або вкладіть його в клас символів, "
"як у ``[|]``."

msgid "``(...)``"
msgstr "``(...)``"

msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Збігається з будь-яким регулярним виразом у дужках і вказує на початок і "
"кінець групи; вміст групи може бути отриманий після того, як було виконано "
"збіг, і може бути зіставлений пізніше в рядку за допомогою спеціальної "
"послідовності ``\\number``, описаної нижче. Щоб зіставити літерали ``'('`` "
"або ``')'``, використовуйте ``\\(`` або ``\\)`` або вкладіть їх у клас "
"символів: ``[(]`` , ``[)]``."

msgid "``(?...)``"
msgstr "``(?...)``"

msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Це нотація розширення (``'?''`` після ``' (''`` не має значення інакше). "
"Перший символ після ``'?''`` визначає значення та подальший синтаксис "
"Розширення зазвичай не створюють нову групу; ``(?P <name> ...)`` є єдиним "
"винятком із цього правила. Нижче наведено наразі підтримувані розширення."

msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""
"(Одна або кілька літер із набору ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) Група відповідає порожньому рядку; літери "
"встановлюють відповідні позначки: :const:`re.A` (відповідність лише ASCII), :"
"const:`re.I` (ігнорувати регістр), :const:`re.L` (залежно від локалі), :"
"const:`re.M` (багаторядковий), :const:`re.S` (крапка відповідає всім), :"
"const:`re.U` (відповідність Unicode) і :const:`re.X` (дослівний ), для "
"всього регулярного виразу. (Прапори описано в :ref:`contents-of-module-re`.) "
"Це корисно, якщо ви бажаєте включити прапори як частину регулярного виразу "
"замість передачі аргументу *flag* до функція :func:`re.compile`. Прапори "
"слід використовувати першими в рядку виразу."

msgid "``(?:...)``"
msgstr "``(?:...)``"

msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Версія звичайних круглих дужок без захоплення. Збігається з будь-яким "
"регулярним виразом у дужках, але підрядок, який відповідає групі, "
"*неможливо* отримати після виконання збігу або посилатися на нього пізніше в "
"шаблоні."

msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), :"
"const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` "
"(multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The "
"flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"(Нуль або більше літер із набору ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, необов'язково після ``'-''``, за якою слідує одна "
"або більше літер ``'i'``, ``'m'``, ``'s'``, ``'x'``.) Літери встановлюють "
"або видаляють відповідні позначки: :const:`re.A` (відповідність лише "
"ASCII), :const:`re.I` (ігнорувати регістр ), :const:`re.L` (залежно від "
"локалі), :const:`re.M` (багаторядковий), :const:`re.S` (точка відповідає "
"всім), :const:`re.U` (збіг Юнікоду) і :const:`re.X` (дослівно) для частини "
"виразу. (Прапорці описані в :ref:`contents-of-module-re`.)"

msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"Літери ``'a'``, ``'L'`` і ``'u'`` є взаємовиключними, коли використовуються "
"як вбудовані прапорці, тому їх не можна поєднувати або слідувати за "
"``'-'`` . Натомість, коли один із них з’являється у вбудованій групі, він "
"замінює режим відповідності в охоплюючій групі. У шаблонах Unicode ``(?"
"a:...)`` перемикається на відповідність лише ASCII, а ``(?u:...)`` "
"перемикається на відповідність Unicode (за замовчуванням). У шаблоні байтів "
"``(?L:...)`` перемикається на відповідність залежно від локалі, а ``(?"
"a:...)`` перемикається на відповідність лише ASCII (за замовчуванням). Це "
"перевизначення діє лише для вузької вбудованої групи, а вихідний режим "
"відповідності відновлюється за межами групи."

msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "Літери ``'a'``, ``'L'`` і ``'u'`` також можна використовувати в групі."

msgid "``(?P<name>...)``"
msgstr "``(?P <name> ...)``"

msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Подібно до звичайних дужок, але підрядок, який відповідає групі, доступний "
"через символічне ім’я групи *name*. Імена груп мають бути дійсними "
"ідентифікаторами Python, і кожне ім’я групи має бути визначено лише один раз "
"у регулярному виразі. Символічна група також є пронумерованою групою, так "
"само, якби група не мала імені."

msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"На іменовані групи можна посилатися в трьох контекстах. Якщо шаблон ``(?P "
"<quote> ['\"]).*?(?P=quote)`` (тобто відповідає рядку в одинарних або "
"подвійних лапках):"

msgid "Context of reference to group \"quote\""
msgstr "Контекст посилання на групу \"цитата\""

msgid "Ways to reference it"
msgstr "Способи посилання на нього"

msgid "in the same pattern itself"
msgstr "за таким самим шаблоном"

msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (як показано)"

msgid "``\\1``"
msgstr "``\\1``"

msgid "when processing match object *m*"
msgstr "під час обробки відповідного об'єкта *m*"

msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (і т.д.)"

msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "у рядку, переданому в аргумент *repl* ``re.sub()``"

msgid "``\\g<quote>``"
msgstr "``\\g <quote>``"

msgid "``\\g<1>``"
msgstr "``\\g <1>``"

msgid "``(?P=name)``"
msgstr "``(?P=name)``"

msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Зворотне посилання на іменовану групу; він відповідає будь-якому тексту, "
"який відповідав попередній групі під назвою *name*."

msgid "``(?#...)``"
msgstr "``(?#...)``"

msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "коментар; вміст круглих дужок просто ігнорується."

msgid "``(?=...)``"
msgstr "``(?=...)``"

msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Збігається, якщо ``...`` збігається наступним, але не споживає жоден рядок. "
"Це називається :dfn:`lookahead assertion`. Наприклад, ``Isaac (?=Azimov)`` "
"відповідатиме ``'Isaac ''``, лише якщо за ним йде ``'Azimov'``."

msgid "``(?!...)``"
msgstr "``(?!...)``"

msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Збігається, якщо ``...`` не збігається наступним. Це :dfn:`негативне "
"випереджальне твердження`. Наприклад, ``Isaac (?!Azimov)`` відповідатиме "
"``'Isaac ''``, лише якщо за ним *не* йде ``'Azimov'``."

msgid "``(?<=...)``"
msgstr "``(?<=...)``"

msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Збігається, якщо поточній позиції в рядку передує відповідність для ``...``, "
"яка закінчується на поточній позиції. Це називається :dfn:`позитивним "
"ретроспективним твердженням`. ``(?<=abc)def`` знайде збіг у ``'abcdef'``, "
"оскільки огляд назад створить резервну копію 3 символів і перевірить, чи "
"збігається шаблон, що міститься. Вміщений шаблон має збігатися лише з "
"рядками певної фіксованої довжини, тобто допустимі ``abc`` або ``a|b``, але "
"``a*`` і ``a{3,4}`` заборонені . Зауважте, що шаблони, які починаються з "
"позитивних ретроспективних тверджень, не збігатимуться на початку рядка, що "
"шукається; швидше за все, ви захочете використовувати функцію :func:"
"`search`, а не функцію :func:`match`:"

msgid "This example looks for a word following a hyphen:"
msgstr "У цьому прикладі шукається слово після дефіса:"

msgid "Added support for group references of fixed length."
msgstr "Додано підтримку групових посилань фіксованої довжини."

msgid "``(?<!...)``"
msgstr "``(?<!...)``"

msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Збігається, якщо поточній позиції в рядку не передує збіг для ``...``. Це "
"називається :dfn:`negative lookbehind assertion`. Подібно до позитивних "
"ретроспективних тверджень, шаблон, що міститься, повинен відповідати лише "
"рядкам певної фіксованої довжини. Шаблони, які починаються з негативних "
"ретроспективних тверджень, можуть збігатися на початку рядка, який шукається."

msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Спробує знайти відповідність за допомогою ``yes-pattern``, якщо група з "
"заданим *id* або *name* існує, і за допомогою ``no-pattern``, якщо вона не "
"існує. ``no-pattern`` є необов'язковим і його можна опустити. Наприклад, "
"``( <)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)> |$)`` є поганим шаблоном відповідності "
"електронної пошти, який збігатиметься з ``'<user@host.com>'``, а також "
"``'user@host.com'``, але не з ``'<user@host.com'`` nor ``'user@host.com> '``."

msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"Спеціальні послідовності складаються з ``'\\'`` і символу зі списку нижче. "
"Якщо звичайний символ не є цифрою ASCII або літерою ASCII, тоді результуючий "
"RE відповідатиме другому символу. Наприклад, ``\\$`` відповідає символу "
"``''$'``."

msgid "``\\number``"
msgstr "``\\номер``"

msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Відповідає вмісту групи з тим самим номером. Групи нумеруються, починаючи з "
"1. Наприклад, ``(.+) \\1`` відповідає ``'the'`` або ``'55 55'``, але не "
"``'thethe'`` (примітка пробіл після групи). Цю спеціальну послідовність "
"можна використовувати лише для відповідності одній із перших 99 груп. Якщо "
"перша цифра *числа* дорівнює 0 або *число* складається з 3 вісімкових цифр, "
"це не буде інтерпретовано як збіг групи, а як символ із вісімковим значенням "
"*число*. Усередині ``'['`` і ``']'`` класу символів усі цифрові екрановані "
"символи розглядаються як символи."

msgid "``\\A``"
msgstr "``\\A``"

msgid "Matches only at the start of the string."
msgstr "Збігається лише на початку рядка."

msgid "``\\b``"
msgstr "``\\b``"

msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"Збігається з порожнім рядком, але лише на початку або в кінці слова. Слово "
"визначається як послідовність символів слова. Зауважте, що формально ``\\b`` "
"визначається як межа між символом ``\\w`` і ``\\W`` (або навпаки), або між "
"``\\w`` і початком/ кінець рядка. Це означає, що ``r'\\bfoo\\b'`` відповідає "
"``'foo'``, ``'foo.''``, ``'(foo)'``, ``'bar foo baz'``, але не ``'foobar'`` "
"або ``'foo3'``."

msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"За замовчуванням буквено-цифрові символи Unicode використовуються в шаблонах "
"Unicode, але це можна змінити за допомогою прапорця :const:`ASCII`. Межі "
"слів визначаються поточною мовою, якщо використовується прапорець :const:"
"`LOCALE`. Усередині діапазону символів ``\\b`` представляє символ зворотного "
"пробілу для сумісності з рядковими літералами Python."

msgid "``\\B``"
msgstr "``\\B``"

msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""
"Збігається з порожнім рядком, але лише якщо він *не* на початку або в кінці "
"слова. Це означає, що ``r'py\\B''`` відповідає ``'python'``, ``'py3'``, "
"``'py2'``, але не ``'py'``, ``'py.'`` або ``'py!'``. ``\\B`` є прямою "
"протилежністю ``\\b``, тому символи слів у шаблонах Unicode є буквено-"
"цифровими символами Unicode або підкресленням, хоча це можна змінити за "
"допомогою прапорця :const:`ASCII`. Межі слів визначаються поточною мовою, "
"якщо використовується прапорець :const:`LOCALE`."

msgid "``\\d``"
msgstr "``\\d``"

msgid "For Unicode (str) patterns:"
msgstr "Для шаблонів Unicode (str):"

msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"Відповідає будь-якій десятковій цифрі Unicode (тобто будь-якому символу в "
"категорії символів Unicode [Nd]). Це включає в себе \"[0-9]\", а також "
"багато інших цифрових символів. Якщо використовується прапорець :const:"
"`ASCII`, збігається лише ``[0-9]``."

msgid "For 8-bit (bytes) patterns:"
msgstr "Для 8-бітових (байтових) шаблонів:"

msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "Збігається з будь-якою десятковою цифрою; це еквівалентно ``[0-9]``."

msgid "``\\D``"
msgstr "``\\D``"

msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr ""
"Відповідає будь-якому символу, який не є десятковою цифрою. Це протилежність "
"``\\d``. Якщо використовується прапорець :const:`ASCII`, це стає "
"еквівалентом ``[^0-9]``."

msgid "``\\s``"
msgstr "``\\s``"

msgid ""
"Matches Unicode whitespace characters (which includes "
"``[ \\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the :"
"const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"Відповідає пробілам Юнікоду (зокрема, ``[ \\t\\n\\r\\f\\v]``, а також "
"багатьом іншим символам, наприклад нерозривним пробілам, передбаченим "
"правилами типографіки багатьох мов). Якщо використовується прапорець :const:"
"`ASCII`, збігається лише ``[ \\t\\n\\r\\f\\v]``."

msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає символам, які вважаються пробілами в наборі символів ASCII; це "
"еквівалентно ``[ \\t\\n\\r\\f\\v]``."

msgid "``\\S``"
msgstr "``\\S``"

msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає будь-якому символу, який не є пробілом. Це протилежність ``\\s``. "
"Якщо використовується прапорець :const:`ASCII`, це стає еквівалентом ``[^ "
"\\t\\n\\r\\f\\v]``."

msgid "``\\w``"
msgstr "``\\w``"

msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""
"Відповідає символам слів Unicode; це включає більшість символів, які можуть "
"бути частиною слова будь-якою мовою, а також цифри та підкреслення. Якщо "
"використовується прапорець :const:`ASCII`, збігається лише ``[a-zA-Z0-9_]``."

msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"Відповідає символам, які вважаються буквено-цифровими в наборі символів "
"ASCII; це еквівалентно ``[a-zA-Z0-9_]``. Якщо використовується прапорець :"
"const:`LOCALE`, відповідає символам, які вважаються буквено-цифровими в "
"поточній локалі, і підкресленню."

msgid "``\\W``"
msgstr "``\\W``"

msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""
"Відповідає будь-якому символу, який не є символом слова. Це протилежність "
"``\\w``. Якщо використовується прапорець :const:`ASCII`, це стає "
"еквівалентом ``[^a-zA-Z0-9_]``. Якщо використовується прапорець :const:"
"`LOCALE`, відповідає символам, які не є ані буквено-цифровими в поточній "
"локалі, ані підкресленням."

msgid "``\\Z``"
msgstr "``\\Z``"

msgid "Matches only at the end of the string."
msgstr "Збігається лише в кінці рядка."

msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"Більшість стандартних екранованих символів, які підтримуються рядковими "
"літералами Python, також приймаються аналізатором регулярних виразів::"

msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Зауважте, що ``\\b`` використовується для представлення меж слів і означає "
"\"backspace\" лише всередині класів символів.)"

msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""
"Екран-послідовності ``'\\u'``, ``'\\U'`` і ``'\\N''`` розпізнаються лише в "
"шаблонах Unicode. У шаблонах байтів це помилки. Невідомі вихідні коди літер "
"ASCII зарезервовано для майбутнього використання та розглядаються як помилки."

msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Вісімкові втечі включені в обмеженій формі. Якщо першою цифрою є 0 або є три "
"вісімкові цифри, це вважається вісімковим екрануванням. В іншому випадку це "
"посилання на групу. Що стосується рядкових літералів, вісімкові символи "
"екранування завжди мають не більше трьох цифр."

msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Було додано керуючі послідовності ``'\\u'`` і ``'\\U'``."

msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Невідомі вихідні символи, що складаються з ``'\\'`` і літери ASCII, тепер є "
"помилками."

msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""
"Додано керуючу послідовність ``'\\N{name}''``. Як і в рядкових літералах, "
"він розширюється до названого символу Unicode (наприклад, ``'\\N{EM "
"DASH}''``)."

msgid "Module Contents"
msgstr "Зміст модуля"

msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"Модуль визначає кілька функцій, констант і виключення. Деякі функції є "
"спрощеними версіями повнофункціональних методів для скомпільованих "
"регулярних виразів. Більшість нетривіальних програм завжди використовують "
"скомпільовану форму."

msgid "Flags"
msgstr "Прапори"

msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Константи прапорів тепер є екземплярами :class:`RegexFlag`, який є "
"підкласом :class:`enum.IntFlag`."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"Зробіть ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` і "
"``\\S`` виконує зіставлення тільки ASCII замість повного зіставлення "
"Unicode. Це має значення лише для шаблонів Unicode та ігнорується для "
"шаблонів байтів. Відповідає вбудованому прапору ``(?a)``."

msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"Зауважте, що для зворотної сумісності прапор :const:`re.U` все ще існує (а "
"також його синонім :const:`re.UNICODE` і його вбудований аналог ``(?u)``), "
"але вони зайві. у Python 3, оскільки збіги є Юнікодом за замовчуванням для "
"рядків (і збіги Юнікоду не дозволені для байтів)."

msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr ""
"Відображення налагоджувальної інформації про скомпільований вираз. Немає "
"відповідного вбудованого прапора."

msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"Виконуйте зіставлення без урахування регістру; такі вирази, як ``[A-Z]`` "
"також відповідатимуть малим регістрам. Повна відповідність Юнікоду "
"(наприклад, ``Ü``, яка відповідає ``ü``) також працює, якщо не "
"використовується прапор :const:`re.ASCII`, щоб вимкнути збіги, відмінні від "
"ASCII. Поточна локаль не змінює ефект цього прапорця, якщо також не "
"використовується прапорець :const:`re.LOCALE`. Відповідає вбудованому "
"прапору ``(?i)``."

msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"Зауважте, що коли шаблони Unicode ``[a-z]`` або ``[A-Z]`` використовуються в "
"поєднанні з прапором :const:`IGNORECASE`, вони відповідатимуть 52 літерам "
"ASCII і 4 додатковим літерам, які не належать до ASCII: 'İ' (U+0130, "
"латинська велика літера I з крапкою вгорі), 'ı' (U+0131, латинська мала "
"літера i без крапки), 'ſ' (U+017F, латинська мала літера довга s) і "
"'K' (U+212A, знак Кельвіна). Якщо використовується прапорець :const:`ASCII`, "
"збігаються лише літери від 'a' до 'z' і від 'A' до 'Z'."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"Зробити ``\\w``, ``\\W``, ``\\b``, ``\\B`` і відповідність без урахування "
"регістру залежно від поточної мови. Цей прапорець можна використовувати лише "
"з шаблонами байтів. Використання цього прапорця не рекомендується, оскільки "
"механізм локалізації є дуже ненадійним, він обробляє лише одну \"культуру\" "
"за раз і працює лише з 8-бітними локалізаціями. Зіставлення Unicode вже "
"ввімкнено за замовчуванням у Python 3 для шаблонів Unicode (str), і він "
"здатний обробляти різні локалі/мови. Відповідає вбудованому прапору ``(?L)``."

msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""
":const:`re.LOCALE` можна використовувати лише з шаблонами байтів і "
"несумісний з :const:`re.ASCII`."

msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr ""
"Зкомпільовані регулярні вирази з прапорцем :const:`re.LOCALE` більше не "
"залежать від локалі під час компіляції. Лише локаль під час зіставлення "
"впливає на результат зіставлення."

msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"Якщо вказано, символ шаблону ``'^'`` збігається на початку рядка та на "
"початку кожного рядка (відразу після кожного нового рядка); і символ шаблону "
"``'$'`` збігається в кінці рядка та в кінці кожного рядка (безпосередньо "
"перед кожним новим рядком). За замовчуванням ``'^'`` збігається лише на "
"початку рядка, а ``'$'`` лише в кінці рядка та безпосередньо перед символом "
"нового рядка (якщо є) у кінці рядка. Відповідає вбудованому прапору ``(?m)``."

msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"Зробіть так, щоб спеціальний символ ``'.'`` відповідав будь-якому символу "
"взагалі, включаючи новий рядок; без цього прапорця ``'.'`` відповідатиме "
"будь-чому *крім* нового рядка. Відповідає вбудованому прапору ``(?s)``."

msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""
"Цей прапорець дозволяє писати регулярні вирази, які виглядають привабливіше "
"та легше читаються, дозволяючи візуально відокремлювати логічні частини "
"шаблону та додавати коментарі. Пробіли в шаблоні ігноруються, за винятком "
"випадків, коли вони містяться в класі символів, або коли перед ними стоїть "
"неекранована зворотна скісна риска, або в межах таких токенів, як ``*?``, "
"``(?:`` або ``(?P <...>``. Якщо рядок містить ``#``, який не входить до "
"класу символів і якому не передує неекранована зворотна скісна риска, усі "
"символи від самого лівого, наприклад ``#`` до кінця рядка, ігноруються."

msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Це означає, що два наступних об’єкти регулярного виразу, які відповідають "
"десятковому числу, функціонально однакові:"

msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Відповідає вбудованому прапору ``(?x)``."

msgid "Functions"
msgstr "Функції"

msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"Скомпілюйте шаблон регулярного виразу в :ref:`об’єкт регулярного виразу <re-"
"objects>`, який можна використовувати для зіставлення за допомогою його :"
"func:`~Pattern.match`, :func:`~Pattern.search` та інших методів, описаних "
"нижче ."

msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"Поведінку виразу можна змінити, вказавши значення *flags*. Значеннями можуть "
"бути будь-які з наведених нижче змінних, об’єднаних за допомогою побітового "
"АБО (оператор ``|``)."

msgid "The sequence ::"
msgstr "Послідовність ::"

msgid "is equivalent to ::"
msgstr "еквівалентно ::"

msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"але використання :func:`re.compile` і збереження отриманого об’єкта "
"регулярного виразу для повторного використання ефективніше, якщо вираз "
"використовуватиметься кілька разів в одній програмі."

msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"Зібрані версії найновіших шаблонів, переданих до :func:`re.compile`, і "
"функції відповідності на рівні модуля кешуються, тому програмам, які "
"використовують лише кілька регулярних виразів одночасно, не потрібно "
"турбуватися про компіляцію регулярних виразів."

msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"Перегляньте *рядок*, шукаючи перше розташування, де регулярний вираз "
"*шаблон* створює збіг, і поверніть відповідний :ref:`об’єкт відповідності "
"<match-objects>`. Повертає ``None``, якщо жодна позиція в рядку не "
"відповідає шаблону; зауважте, що це відрізняється від пошуку збігу нульової "
"довжини в деякій точці рядка."

msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"Якщо нуль або більше символів на початку *string* відповідає регулярному "
"виразу *pattern*, поверніть відповідний :ref:`match object <match-objects>`. "
"Повертає ``None``, якщо рядок не відповідає шаблону; зауважте, що це "
"відрізняється від збігу нульової довжини."

msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Зауважте, що навіть у режимі :const:`MULTILINE` :func:`re.match` "
"збігатиметься лише на початку рядка, а не на початку кожного рядка."

msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Якщо ви хочете знайти збіг будь-де в *string*, використовуйте натомість :"
"func:`search` (див. також :ref:`search-vs-match`)."

msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Якщо весь *рядок* відповідає регулярному виразу *шаблону*, поверніть "
"відповідний :ref:`об’єкт відповідності <match-objects>`. Повертає ``None``, "
"якщо рядок не відповідає шаблону; зауважте, що це відрізняється від збігу "
"нульової довжини."

msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Розділіть *рядок* на входження *шаблону*. Якщо в *шаблоні* використовуються "
"дужки для захоплення, тоді текст усіх груп у шаблоні також повертається як "
"частина результуючого списку. Якщо *maxsplit* відмінний від нуля, "
"відбувається не більше ніж *maxsplit*, а залишок рядка повертається як "
"останній елемент списку. ::"

msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Якщо в розділювачі є групи захоплення, і він збігається на початку рядка, "
"результат розпочнеться з порожнього рядка. Те саме стосується кінця рядка::"

msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"Таким чином, компоненти роздільників завжди знаходяться за однаковими "
"відносними індексами в списку результатів."

msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""
"Порожні збіги для шаблону розділяють рядок лише тоді, коли вони не суміжні з "
"попереднім порожнім збігом."

msgid "Added the optional flags argument."
msgstr "Додано необов’язковий аргумент flags."

msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""
"Додано підтримку розбиття на шаблон, який може відповідати порожньому рядку."

msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"Повертає всі неперекриваючі збіги *шаблону* в *рядку* у вигляді списку "
"рядків або кортежів. *Рядок* сканується зліва направо, і збіги повертаються "
"в порядку знайдення. Порожні збіги включаються в результат."

msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"Результат залежить від кількості груп захоплення в шаблоні. Якщо груп немає, "
"поверніть список рядків, які відповідають повному шаблону. Якщо існує рівно "
"одна група, поверніть список рядків, які відповідають цій групі. Якщо "
"присутні кілька груп, поверніть список кортежів рядків, які відповідають "
"групам. Незахоплюючі групи не впливають на форму результату."

msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""
"Непорожні збіги тепер можуть починатися одразу після попереднього порожнього "
"збігу."

msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""
"Повертає :term:`iterator`, що дає :ref:`match об’єкти <match-objects>` над "
"усіма неперекриваючими збігами для *шаблону* RE в *рядку*. *Рядок* "
"сканується зліва направо, і збіги повертаються в порядку знайдення. Порожні "
"збіги включаються в результат."

msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"Повертає рядок, отриманий шляхом заміни крайніх лівих неперекриваючих "
"входжень *pattern* у *string* на заміну *repl*. Якщо шаблон не знайдено, "
"*рядок* повертається без змін. *repl* може бути рядком або функцією; якщо це "
"рядок, будь-які вихідні символи зворотної косої риски в ньому обробляються. "
"Тобто ``\\n`` перетворюється на один символ нового рядка, ``\\r`` "
"перетворюється на повернення каретки і так далі. Невідомі вихідні коди літер "
"ASCII зарезервовано для майбутнього використання та розглядаються як "
"помилки. Інші невідомі вихідні сигнали, такі як ``\\&`` залишаються в "
"спокої. Зворотні посилання, такі як ``\\6``, замінюються підрядком, який "
"відповідає групі 6 у шаблоні. Наприклад::"

msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"Якщо *repl* є функцією, вона викликається для кожного неперекриваючого "
"входження *шаблону*. Функція приймає один аргумент :ref:`match object <match-"
"objects>` і повертає рядок заміни. Наприклад::"

msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "Шаблон може бути рядком або :ref:`об’єктом шаблону <re-objects>`."

msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"Необов’язковий аргумент *count* — це максимальна кількість шаблонів, які "
"потрібно замінити; *count* має бути невід’ємним цілим числом. Якщо опущено "
"або дорівнює нулю, усі входження буде замінено. Порожні збіги для шаблону "
"замінюються лише тоді, коли вони не суміжні з попереднім порожнім збігом, "
"тому ``sub('x*', '-', 'abxd')`` повертає ``'-a-b--d-'`` ."

msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"В аргументах рядкового типу *repl*, на додаток до екранованих символів і "
"зворотних посилань, описаних вище, ``\\g <name>`` використовуватиме "
"підрядок, який відповідає групі з назвою ``name``, як визначено ``(? P "
"<name> ...)`` синтаксис. ``\\g <number>`` використовує відповідний номер "
"групи; ``\\g <2>``, отже, еквівалентний ``\\2``, але не є неоднозначним у "
"заміні, такій як ``\\g <2> 0``. ``\\20`` інтерпретуватиметься як посилання "
"на групу 20, а не як посилання на групу 2, за якою йде літеральний символ "
"``'0'``. Зворотне посилання ``\\g <0>`` замінює весь підрядок, який "
"відповідає RE."

msgid "Unmatched groups are replaced with an empty string."
msgstr "Невідповідні групи замінюються порожнім рядком."

msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Невідомі вихідні коди в *шаблоні*, що складаються з ``'\\'`` і літери ASCII, "
"тепер є помилками."

msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr ""
"Невідомі вихідні символи в *repl*, які складаються з ``'\\'`` і літери "
"ASCII, тепер є помилками."

msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""
"Порожні збіги для шаблону замінюються, якщо вони суміжні з попереднім "
"непорожнім збігом."

msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Виконайте ту саму операцію, що й :func:`sub`, але поверніть кортеж "
"``(new_string, number_of_subs_made)``."

msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"Екранування спеціальних символів у *шаблоні*. Це корисно, якщо ви хочете "
"зіставити довільний рядок літералу, який може містити метасимволи "
"регулярного виразу. Наприклад::"

msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"Цю функцію не можна використовувати для рядка заміни в :func:`sub` і :func:"
"`subn`, слід екранувати лише зворотні косі риски. Наприклад::"

msgid "The ``'_'`` character is no longer escaped."
msgstr "Символ \"_\" більше не екранується."

msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"Екрануються лише символи, які можуть мати спеціальне значення в регулярному "
"виразі. У результаті ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, ``'/'` "
"`, ``':'``, ``';'``, ``' <'``, ``'='``, ``'> '``, ``'@'`` і ``\"`\"`` більше "
"не екрануються."

msgid "Clear the regular expression cache."
msgstr "Очистити кеш регулярних виразів."

msgid "Exceptions"
msgstr "Винятки"

msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""
"Виняток виникає, коли рядок, переданий одній із функцій тут, не є дійсним "
"регулярним виразом (наприклад, він може містити невідповідні дужки) або коли "
"під час компіляції чи зіставлення виникає інша помилка. Ніколи не буде "
"помилкою, якщо рядок не містить збігів для шаблону. Екземпляр помилки має "
"такі додаткові атрибути:"

msgid "The unformatted error message."
msgstr "Неформатне повідомлення про помилку."

msgid "The regular expression pattern."
msgstr "Шаблон регулярного виразу."

msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "Індекс у *шаблоні*, де не вдалося компілювати (може бути ``None``)."

msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "Рядок, що відповідає *pos* (може бути ``None``)."

msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "Стовпець, що відповідає *pos* (може бути ``None``)."

msgid "Added additional attributes."
msgstr "Додані додаткові атрибути."

msgid "Regular Expression Objects"
msgstr "Об’єкти регулярного виразу"

msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""
"Зкомпільовані об’єкти регулярного виразу підтримують наступні методи та "
"атрибути:"

msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"Проскануйте *рядок*, шукаючи перше місце, де цей регулярний вираз створює "
"збіг, і поверніть відповідний :ref:`об’єкт відповідності <match-objects>`. "
"Повертає ``None``, якщо жодна позиція в рядку не відповідає шаблону; "
"зауважте, що це відрізняється від пошуку збігу нульової довжини в деякій "
"точці рядка."

msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"Необов’язковий другий параметр *pos* дає індекс у рядку, з якого має "
"початися пошук; за замовчуванням ``0``. Це не зовсім еквівалентно нарізанню "
"струни; символ шаблону ``'^'`` збігається на справжньому початку рядка та в "
"позиціях одразу після нового рядка, але не обов’язково в індексі, з якого "
"має початися пошук."

msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"Необов'язковий параметр *endpos* обмежує, наскільки далеко буде "
"здійснюватися пошук рядка; це буде так, ніби рядок складається з *endpos* "
"символів, тому шукатимуть збіги лише за символами від *pos* до ``endpos - "
"1``. Якщо *endpos* менше ніж *pos*, збіг не знайдено; інакше, якщо *rx* є "
"скомпільованим об’єктом регулярного виразу, ``rx.search(string, 0, 50)`` "
"еквівалентно ``rx.search(string[:50], 0)``. ::"

msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"Якщо цьому регулярному виразу відповідає нуль або більше символів на "
"*початку* *рядка*, повертається відповідний :ref:`об’єкт відповідності "
"<match-objects>`. Повертає ``None``, якщо рядок не відповідає шаблону; "
"зауважте, що це відрізняється від збігу нульової довжини."

msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""
"Необов’язкові параметри *pos* і *endpos* мають те саме значення, що й для "
"методу :meth:`~Pattern.search`. ::"

msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Якщо ви хочете знайти збіг будь-де в *string*, використовуйте натомість :"
"meth:`~Pattern.search` (див. також :ref:`search-vs-match`)."

msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Якщо весь *рядок* відповідає цьому регулярному виразу, поверніть "
"відповідний :ref:`match object <match-objects>`. Повертає ``None``, якщо "
"рядок не відповідає шаблону; зауважте, що це відрізняється від збігу "
"нульової довжини."

msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "Ідентична функції :func:`split`, використовуючи скомпільований шаблон."

msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Подібно до функції :func:`findall`, використовує скомпільований шаблон, але "
"також приймає додаткові параметри *pos* і *endpos*, які обмежують область "
"пошуку, як для :meth:`search`."

msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Подібно до функції :func:`finditer`, яка використовує скомпільований шаблон, "
"але також приймає додаткові параметри *pos* і *endpos*, які обмежують "
"область пошуку, як для :meth:`search`."

msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "Ідентична функції :func:`sub`, використовуючи скомпільований шаблон."

msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "Ідентична функції :func:`subn`, використовуючи скомпільований шаблон."

msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"Прапори відповідності регулярних виразів. Це комбінація прапорів, наданих :"
"func:`.compile`, будь-яких вбудованих прапорів ``(?...)`` у шаблоні та "
"неявних прапорів, таких як :data:`UNICODE`, якщо шаблон є Рядок Unicode."

msgid "The number of capturing groups in the pattern."
msgstr "Кількість груп захоплення в шаблоні."

msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"Словник, що відображає будь-які символічні назви груп, визначені ``(?P "
"<id> )``, на номери груп. Словник порожній, якщо в шаблоні не "
"використовувалися символічні групи."

msgid "The pattern string from which the pattern object was compiled."
msgstr "Рядок шаблону, з якого було скомпільовано об’єкт шаблону."

msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"Додано підтримку :func:`copy.copy` і :func:`copy.deepcopy`. Зкомпільовані "
"об’єкти регулярного виразу вважаються атомарними."

msgid "Match Objects"
msgstr "Зіставте об’єкти"

msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"Об’єкти відповідності завжди мають логічне значення ``True``. Оскільки :meth:"
"`~Pattern.match` і :meth:`~Pattern.search` повертають ``None`` за "
"відсутності збігу, ви можете перевірити, чи був збіг за допомогою простого "
"оператора ``if``: :"

msgid "Match objects support the following methods and attributes:"
msgstr "Об’єкти відповідності підтримують такі методи й атрибути:"

msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"Повертає рядок, отриманий заміною зворотної похилої риски в рядку шаблону "
"*template*, як це робиться методом :meth:`~Pattern.sub`. Екрани, такі як "
"``\\n``, перетворюються на відповідні символи, а також числові зворотні "
"посилання (``\\1``, ``\\2``) і іменовані зворотні посилання (``\\g <1>``, "
"``\\g <name>``) замінюються вмістом відповідної групи."

msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"Повертає одну або кілька підгруп збігу. Якщо є один аргумент, результатом "
"буде один рядок; якщо є кілька аргументів, результатом є кортеж з одним "
"елементом на аргумент. Без аргументів *group1* за замовчуванням дорівнює "
"нулю (повертається весь збіг). Якщо аргумент *groupN* дорівнює нулю, "
"відповідним значенням, що повертається, є весь відповідний рядок; якщо він "
"знаходиться у включному діапазоні [1..99], це рядок, що відповідає "
"відповідній групі в дужках. Якщо номер групи є від’ємним або перевищує "
"кількість груп, визначених у шаблоні, виникає виняток :exc:`IndexError`. "
"Якщо група міститься в частині шаблону, яка не відповідає, відповідним "
"результатом є ``None``. Якщо група міститься в частині шаблону, яка "
"збігалася кілька разів, повертається останній збіг. ::"

msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"Якщо регулярний вираз використовує синтаксис ``(?P <name> ...)``, аргументи "
"*groupN* також можуть бути рядками, що ідентифікують групи за назвою групи. "
"Якщо рядковий аргумент не використовується як ім’я групи в шаблоні, виникає "
"виняток :exc:`IndexError`."

msgid "A moderately complicated example::"
msgstr "Помірно складний приклад:"

msgid "Named groups can also be referred to by their index::"
msgstr "Іменовані групи також можна посилатися за їх індексом::"

msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"Якщо група збігається кілька разів, доступним буде лише останній збіг::"

msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"Це ідентично ``m.group(g)``. Це дозволяє легше отримати доступ до окремої "
"групи з матчу::"

msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Повертає кортеж, що містить усі підгрупи відповідності, від 1 до будь-якої "
"кількості груп у шаблоні. Аргумент *default* використовується для груп, які "
"не брали участі в матчі; за замовчуванням ``None``."

msgid "For example::"
msgstr "Наприклад::"

msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"Якщо ми зробимо знак після коми необов’язковим, не всі групи можуть брати "
"участь у матчі. Для цих груп за замовчуванням буде ``None``, якщо не вказано "
"аргумент *default*::"

msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"Повертає словник, що містить усі *іменовані* підгрупи збігу, ключ яких "
"містить назву підгрупи. Аргумент *default* використовується для груп, які не "
"брали участі в матчі; за замовчуванням ``None``. Наприклад::"

msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Повертає індекси початку та кінця підрядка, які відповідають *групі*; "
"*group* за замовчуванням дорівнює нулю (це означає весь відповідний "
"підрядок). Повертає ``-1``, якщо *група* існує, але не брала участі в матчі. "
"Для об’єкта збігу *m* і групи *g*, яка внесла свій внесок у збіг, підрядок, "
"який відповідає групі *g* (еквівалент ``m.group(g)``) є ::"

msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Зауважте, що ``m.start(group)`` дорівнюватиме ``m.end(group)``, якщо *group* "
"відповідає нульовому рядку. Наприклад, після ``m = re.search('b(c?)', "
"'cba')``, ``m.start(0)`` дорівнює 1, ``m.end(0)`` дорівнює 2, ``m.start(1)`` "
"і ``m.end(1)`` мають значення 2, а ``m.start(2)`` викликає виняток :exc:"
"`IndexError`."

msgid "An example that will remove *remove_this* from email addresses::"
msgstr "Приклад видалення *remove_this* з електронних адрес::"

msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"Для збігу *m* поверніть 2-кортеж ``(m.start(group), m.end(group))``. "
"Зауважте, що якщо *група* не брала участі в матчі, це ``(-1, -1)``. *група* "
"за замовчуванням дорівнює нулю, весь збіг."

msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"Значення *pos*, яке було передано в метод :meth:`~Pattern.search` або :meth:"
"`~Pattern.match` об’єкта :ref:`regex <re-objects>`. Це індекс у рядку, за "
"яким механізм RE почав шукати збіг."

msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
"Значення *endpos*, яке було передано в метод :meth:`~Pattern.search` або :"
"meth:`~Pattern.match` об’єкта :ref:`regex <re-objects>`. Це індекс у рядку, "
"за який механізм RE не виходить."

msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"Цілочисельний індекс останньої відповідної групи захоплення або ``None``, "
"якщо жодна група не була знайдена взагалі. Наприклад, вирази ``(a)b``, ``((a)"
"(b))`` і ``((ab))`` матимуть ``lastindex == 1``, якщо застосувати до рядок "
"``'ab''``, тоді як вираз ``(a)(b)`` матиме ``lastindex == 2``, якщо "
"застосувати до того самого рядка."

msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"Ім’я останньої відповідної групи захоплення або ``None``, якщо група не мала "
"назви, або якщо жодна група не була знайдена взагалі."

msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
"Об’єкт :ref:`регулярного виразу <re-objects>`, чий метод :meth:`~Pattern."
"match` або :meth:`~Pattern.search` створив цей екземпляр відповідності."

msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
"Рядок передається до :meth:`~Pattern.match` або :meth:`~Pattern.search`."

msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
"Додано підтримку :func:`copy.copy` і :func:`copy.deepcopy`. Об'єкти "
"відповідності вважаються атомарними."

msgid "Regular Expression Examples"
msgstr "Приклади регулярних виразів"

msgid "Checking for a Pair"
msgstr "Перевірка на пару"

msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"У цьому прикладі ми використаємо наступну допоміжну функцію, щоб відобразити "
"об’єкти відповідності трохи витонченіше:"

msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Припустімо, що ви пишете покерну програму, де рука гравця представлена у "
"вигляді рядка з 5 символів, де кожен символ представляє карту, \"a\" — туз, "
"\"k\" — король, \"q\" — дама, \"j\" — валет, \"t\" означає 10 і \"2\" - "
"\"9\", що представляють картку з таким значенням."

msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"Щоб перевірити, чи даний рядок є правильною рукою, можна зробити наступне:"

msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Ця остання роздача, ``\"727ak\"``, містила пару або дві карти однакового "
"значення. Щоб зіставити це з регулярним виразом, можна використовувати "
"зворотні посилання як такі:"

msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"Щоб дізнатися, з якої карти складається пара, можна використати метод :meth:"
"`~Match.group` об’єкта відповідності таким чином:"

msgid "Simulating scanf()"
msgstr "Імітація scanf()"

msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python наразі не має еквівалента :c:func:`scanf`. Регулярні вирази, як "
"правило, потужніші, хоча й більш докладні, ніж рядки формату :c:func:"
"`scanf`. Таблиця нижче пропонує деякі більш-менш еквівалентні відповідності "
"між маркерами формату :c:func:`scanf` і регулярними виразами."

msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` Токен"

msgid "Regular Expression"
msgstr "Регулярний вираз"

msgid "``%c``"
msgstr "``%c``"

msgid "``%5c``"
msgstr "``%5c``"

msgid "``.{5}``"
msgstr "``.{5}``"

msgid "``%d``"
msgstr "``%d``"

msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

msgid "``%i``"
msgstr "``%i``"

msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

msgid "``%o``"
msgstr "``%o``"

msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

msgid "``%s``"
msgstr "``%s``"

msgid "``\\S+``"
msgstr "``\\S+``"

msgid "``%u``"
msgstr "``%u``"

msgid "``\\d+``"
msgstr "``\\d+``"

msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

msgid "To extract the filename and numbers from a string like ::"
msgstr "Щоб витягти назву файлу та номери з рядка на зразок ::"

msgid "you would use a :c:func:`scanf` format like ::"
msgstr "ви б використовували формат :c:func:`scanf`, наприклад ::"

msgid "The equivalent regular expression would be ::"
msgstr "Еквівалентним регулярним виразом буде::"

msgid "search() vs. match()"
msgstr "search() проти match()"

msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python пропонує дві різні примітивні операції на основі регулярних виразів: :"
"func:`re.match` перевіряє збіг лише на початку рядка, тоді як :func:`re."
"search` перевіряє збіг будь-де в рядку (це це те, що Perl робить за "
"замовчуванням)."

msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Регулярні вирази, що починаються з ``'^'``, можна використовувати з :func:"
"`search`, щоб обмежити збіг на початку рядка::"

msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Однак зауважте, що в режимі :const:`MULTILINE` :func:`match` збігається лише "
"на початку рядка, тоді як використання :func:`search` із регулярним виразом, "
"що починається з ``'^'`` збігається на початок кожного рядка. ::"

msgid "Making a Phonebook"
msgstr "Створення телефонної книги"

msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` розбиває рядок на список, розділений переданим шаблоном. Цей "
"метод є безцінним для перетворення текстових даних у структури даних, які "
"можна легко читати та змінювати Python, як показано в наступному прикладі "
"створення телефонної книги."

msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"По-перше, ось вхідні дані. Зазвичай він може надходити з файлу, тут ми "
"використовуємо синтаксис рядка в потрійних лапках"

msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Записи розділені одним або кількома символами нового рядка. Тепер ми "
"перетворюємо рядок на список, у якому кожен непорожній рядок має окремий "
"запис:"

msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Нарешті, розділіть кожен запис на список із іменем, прізвищем, номером "
"телефону та адресою. Ми використовуємо параметр ``maxsplit`` :func:`split`, "
"тому що в адресі є пробіли, наш шаблон поділу:"

msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"Шаблон ``:?`` відповідає двокрапці після прізвища, щоб він не зустрічався в "
"списку результатів. За допомогою ``maxsplit`` ``4`` ми можемо відокремити "
"номер будинку від назви вулиці:"

msgid "Text Munging"
msgstr "Перебирання тексту"

msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` замінює кожне входження шаблону рядком або результатом функції. "
"У цьому прикладі демонструється використання :func:`sub` із функцією для "
"\"переміщення\" тексту або випадкового порядку всіх символів у кожному слові "
"речення, за винятком першого та останнього символів::"

msgid "Finding all Adverbs"
msgstr "Знайти всі прислівники"

msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` відповідає *всім* входженням шаблону, а не лише першому, як "
"це робить :func:`search`. Наприклад, якщо автор хоче знайти всі прислівники "
"в якомусь тексті, він може використати :func:`findall` у такий спосіб:"

msgid "Finding all Adverbs and their Positions"
msgstr "Знайти всі прислівники та їх позиції"

msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""
"Якщо потрібно отримати більше інформації про всі збіги шаблону, ніж "
"відповідний текст, :func:`finditer` буде корисним, оскільки він надає :ref:"
"`match objects <match-objects>` замість рядків. Продовжуючи попередній "
"приклад, якби автор хотів знайти всі прислівники *та їх позиції* в якомусь "
"тексті, він використав би :func:`finditer` таким чином::"

msgid "Raw String Notation"
msgstr "Необроблена рядкова нотація"

msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Необроблена нотація рядка (``r\"текст\"``) зберігає регулярні вирази "
"нормальними. Без нього кожен зворотний слеш (``'\\'``) у регулярному виразі "
"повинен був би мати префікс іншим, щоб уникнути його. Наприклад, два "
"наступних рядки коду функціонально ідентичні:"

msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"Якщо потрібно зіставити літеральний зворотний слеш, його потрібно екранувати "
"у регулярному виразі. У необробленому рядковому записі це означає ``r\"\\\\"
"\"``. Без нотації необробленого рядка потрібно використовувати ``\"\\\\\\\\"
"\"``, роблячи наступні рядки коду функціонально ідентичними::"

msgid "Writing a Tokenizer"
msgstr "Написання токенізера"

msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`Токенизатор або сканер <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"аналізує рядок, щоб класифікувати групи символів. Це корисний перший крок у "
"написанні компілятора чи інтерпретатора."

msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"Текстові категорії вказуються регулярними виразами. Техніка полягає в тому, "
"щоб об’єднати їх у єдиний основний регулярний вираз і виконати цикл "
"послідовних збігів:"

msgid "The tokenizer produces the following output::"
msgstr "Токенізатор видає такий вихід:"

msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Фрідл, Джеффрі. Освоєння регулярних виразів. 3rd ed., O'Reilly Media, 2009. "
"Третє видання книги більше не охоплює Python взагалі, але перше видання "
"охоплювало написання хороших шаблонів регулярних виразів дуже детально."
