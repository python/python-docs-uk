# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Futures"
msgstr "Ф'ючерси"

msgid ""
"**Source code:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"
msgstr ""
"**Вихідний код:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"

msgid ""
"*Future* objects are used to bridge **low-level callback-based code** with "
"high-level async/await code."
msgstr ""
"Об’єкти *Future* використовуються для з’єднання **низькорівневого коду на "
"основі зворотного виклику** з високорівневим асинхронним кодом/кодом "
"очікування."

msgid "Future Functions"
msgstr "Майбутні функції"

msgid "Return ``True`` if *obj* is either of:"
msgstr "Повертає ``True``, якщо *obj* є одним із:"

msgid "an instance of :class:`asyncio.Future`,"
msgstr "екземпляр :class:`asyncio.Future`,"

msgid "an instance of :class:`asyncio.Task`,"
msgstr "екземпляр :class:`asyncio.Task`,"

msgid "a Future-like object with a ``_asyncio_future_blocking`` attribute."
msgstr "Future-подібний об’єкт з атрибутом ``_asyncio_future_blocking``."

msgid "Return:"
msgstr "Повернення:"

msgid ""
"*obj* argument as is, if *obj* is a :class:`Future`, a :class:`Task`, or a "
"Future-like object (:func:`isfuture` is used for the test.)"
msgstr ""
"Аргумент *obj* як є, якщо *obj* є :class:`Future`, :class:`Task` або Future-"
"подібним об’єктом (:func:`isfuture` використовується для перевірки.)"

msgid ""
"a :class:`Task` object wrapping *obj*, if *obj* is a coroutine (:func:"
"`iscoroutine` is used for the test); in this case the coroutine will be "
"scheduled by ``ensure_future()``."
msgstr ""
"об’єкт :class:`Task`, що обгортає *obj*, якщо *obj* є співпрограмою (для "
"тесту використовується :func:`iscoroutine`); у цьому випадку співпрограма "
"буде запланована ``ensure_future()``."

msgid ""
"a :class:`Task` object that would await on *obj*, if *obj* is an awaitable (:"
"func:`inspect.isawaitable` is used for the test.)"
msgstr ""
"об’єкт :class:`Task`, який очікуватиме на *obj*, якщо *obj* є очікуваним (:"
"func:`inspect.isawaitable` використовується для тесту.)"

msgid "If *obj* is neither of the above a :exc:`TypeError` is raised."
msgstr "Якщо *obj* не є жодним із наведених вище, виникає :exc:`TypeError`."

msgid ""
"See also the :func:`create_task` function which is the preferred way for "
"creating new Tasks."
msgstr ""
"Дивіться також функцію :func:`create_task`, яка є кращим способом створення "
"нових завдань."

msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid execution."
msgstr ""
"Збережіть посилання на результат цієї функції, щоб уникнути зникнення "
"завдання під час виконання."

msgid "The function accepts any :term:`awaitable` object."
msgstr "Функція приймає будь-який об’єкт :term:`awaitable`."

msgid ""
"Deprecation warning is emitted if *obj* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Якщо *obj* не є Future-подібним об’єктом і *loop* не вказано, і цикл подій "
"не виконується, видається попередження про застаріле."

msgid ""
"Wrap a :class:`concurrent.futures.Future` object in a :class:`asyncio."
"Future` object."
msgstr ""
"Загорніть об’єкт :class:`concurrent.futures.Future` в об’єкт :class:`asyncio."
"Future`."

msgid ""
"Deprecation warning is emitted if *future* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Якщо *future* не є об’єктом, схожим на Future, і *loop* не вказано, і немає "
"запущеного циклу подій, видається попередження про застаріння."

msgid "Future Object"
msgstr "Майбутній об'єкт"

msgid ""
"A Future represents an eventual result of an asynchronous operation.  Not "
"thread-safe."
msgstr ""
"Future представляє кінцевий результат асинхронної операції. Небезпечно для "
"потоків."

msgid ""
"Future is an :term:`awaitable` object.  Coroutines can await on Future "
"objects until they either have a result or an exception set, or until they "
"are cancelled."
msgstr ""
"Future — це об'єкт :term:`awaitable`. Співпрограми можуть очікувати на "
"об’єктах Future, доки для них не буде отримано результат або встановлено "
"виняток, або поки їх не буде скасовано."

msgid ""
"Typically Futures are used to enable low-level callback-based code (e.g. in "
"protocols implemented using asyncio :ref:`transports <asyncio-transports-"
"protocols>`) to interoperate with high-level async/await code."
msgstr ""
"Зазвичай ф’ючерси використовуються, щоб увімкнути низькорівневий код на "
"основі зворотного виклику (наприклад, у протоколах, реалізованих за "
"допомогою asyncio :ref:`transports <asyncio-transports-protocols>`) для "
"взаємодії з високорівневим асинхронним кодом/кодом очікування."

msgid ""
"The rule of thumb is to never expose Future objects in user-facing APIs, and "
"the recommended way to create a Future object is to call :meth:`loop."
"create_future`.  This way alternative event loop implementations can inject "
"their own optimized implementations of a Future object."
msgstr ""
"Емпіричне правило полягає в тому, щоб ніколи не показувати об’єкти Future в "
"призначених для користувача API, а рекомендований спосіб створити об’єкт "
"Future – це викликати :meth:`loop.create_future`. Таким чином альтернативні "
"реалізації циклу подій можуть вводити власні оптимізовані реалізації об’єкта "
"Future."

msgid "Added support for the :mod:`contextvars` module."
msgstr "Додано підтримку модуля :mod:`contextvars`."

msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Якщо *loop* не вказано і немає запущеного циклу подій, видається "
"попередження про застаріле."

msgid "Return the result of the Future."
msgstr "Повернути результат Future."

msgid ""
"If the Future is *done* and has a result set by the :meth:`set_result` "
"method, the result value is returned."
msgstr ""
"Якщо Future *done* і має результат, встановлений методом :meth:`set_result`, "
"повертається значення результату."

msgid ""
"If the Future is *done* and has an exception set by the :meth:"
"`set_exception` method, this method raises the exception."
msgstr ""
"Якщо Future *done* і має виняток, встановлений методом :meth:"
"`set_exception`, цей метод викликає виняток."

msgid ""
"If the Future has been *cancelled*, this method raises a :exc:"
"`CancelledError` exception."
msgstr ""
"Якщо Future було *скасовано*, цей метод викликає виняток :exc:"
"`CancelledError`."

msgid ""
"If the Future's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Якщо результат Future ще недоступний, цей метод викликає виняток :exc:"
"`InvalidStateError`."

msgid "Mark the Future as *done* and set its result."
msgstr "Позначте майбутнє як *виконане* та встановіть його результат."

msgid ""
"Raises a :exc:`InvalidStateError` error if the Future is already *done*."
msgstr "Викликає помилку :exc:`InvalidStateError`, якщо Future вже *виконано*."

msgid "Mark the Future as *done* and set an exception."
msgstr "Позначте майбутнє як *готове* та встановіть виняток."

msgid "Return ``True`` if the Future is *done*."
msgstr "Повертає ``True``, якщо Future *done*."

msgid ""
"A Future is *done* if it was *cancelled* or if it has a result or an "
"exception set with :meth:`set_result` or :meth:`set_exception` calls."
msgstr ""
"Майбутнє вважається *виконаним*, якщо його було *скасовано* або якщо він має "
"результат чи виняток, встановлений за допомогою викликів :meth:`set_result` "
"або :meth:`set_exception`."

msgid "Return ``True`` if the Future was *cancelled*."
msgstr "Повертає ``True``, якщо Future було *скасовано*."

msgid ""
"The method is usually used to check if a Future is not *cancelled* before "
"setting a result or an exception for it::"
msgstr ""
"Метод зазвичай використовується, щоб перевірити, чи Future не *скасовано* "
"перед встановленням результату або винятку для нього::"

msgid "Add a callback to be run when the Future is *done*."
msgstr ""
"Додайте зворотний виклик, який буде запущено, коли Майбутнє *зроблено*."

msgid "The *callback* is called with the Future object as its only argument."
msgstr ""
"*Зворотний виклик* викликається з об’єктом Future як єдиним аргументом."

msgid ""
"If the Future is already *done* when this method is called, the callback is "
"scheduled with :meth:`loop.call_soon`."
msgstr ""
"Якщо Future вже *done* під час виклику цього методу, зворотний виклик "
"планується за допомогою :meth:`loop.call_soon`."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Необов’язковий аргумент *context*, що містить лише ключове слово, дозволяє "
"вказати спеціальний :class:`contextvars.Context` для виконання *зворотного "
"виклику*. Поточний контекст використовується, якщо *контексту* не надано."

msgid ""
":func:`functools.partial` can be used to pass parameters to the callback, e."
"g.::"
msgstr ""
":func:`functools.partial` можна використовувати для передачі параметрів "
"зворотному виклику, наприклад::"

msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Додано параметр *context* тільки для ключового слова. Дивіться :pep:`567` "
"для більш детальної інформації."

msgid "Remove *callback* from the callbacks list."
msgstr "Видалити *callback* зі списку зворотних викликів."

msgid ""
"Returns the number of callbacks removed, which is typically 1, unless a "
"callback was added more than once."
msgstr ""
"Повертає кількість видалених зворотних викликів, яка зазвичай дорівнює 1, "
"якщо зворотний виклик не було додано кілька разів."

msgid "Cancel the Future and schedule callbacks."
msgstr "Скасувати майбутнє та запланувати зворотні виклики."

msgid ""
"If the Future is already *done* or *cancelled*, return ``False``. Otherwise, "
"change the Future's state to *cancelled*, schedule the callbacks, and return "
"``True``."
msgstr ""
"Якщо Future вже *виконано* або *скасовано*, поверніть ``False``. В іншому "
"випадку змініть стан Future на *cancelled*, заплануйте зворотні виклики та "
"поверніть ``True``."

msgid "Added the *msg* parameter."
msgstr "Додано параметр *msg*."

msgid "Return the exception that was set on this Future."
msgstr "Повертає виняток, встановлений для цього Future."

msgid ""
"The exception (or ``None`` if no exception was set) is returned only if the "
"Future is *done*."
msgstr ""
"Виняток (або ``None``, якщо виключення не було встановлено) повертається, "
"лише якщо Future *done*."

msgid ""
"If the Future isn't *done* yet, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Якщо Future ще не *зроблено*, цей метод викликає виняток :exc:"
"`InvalidStateError`."

msgid "Return the event loop the Future object is bound to."
msgstr "Повертає цикл подій, до якого прив’язаний об’єкт Future."

msgid ""
"This example creates a Future object, creates and schedules an asynchronous "
"Task to set result for the Future, and waits until the Future has a result::"
msgstr ""
"У цьому прикладі створюється об’єкт Future, створюється та планується "
"асинхронне завдання для встановлення результату для Future та очікується, "
"доки Future не отримає результат::"

msgid ""
"The Future object was designed to mimic :class:`concurrent.futures.Future`.  "
"Key differences include:"
msgstr ""
"Об’єкт Future був розроблений для імітації :class:`concurrent.futures."
"Future`. Основні відмінності:"

msgid ""
"unlike asyncio Futures, :class:`concurrent.futures.Future` instances cannot "
"be awaited."
msgstr ""
"на відміну від asyncio Futures, екземпляри :class:`concurrent.futures."
"Future` не можна чекати."

msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` do not "
"accept the *timeout* argument."
msgstr ""
":meth:`asyncio.Future.result` і :meth:`asyncio.Future.exception` не "
"приймають аргумент *timeout*."

msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` raise an :"
"exc:`InvalidStateError` exception when the Future is not *done*."
msgstr ""
":meth:`asyncio.Future.result` і :meth:`asyncio.Future.exception` викликають "
"виняток :exc:`InvalidStateError`, коли Future не *виконано*."

msgid ""
"Callbacks registered with :meth:`asyncio.Future.add_done_callback` are not "
"called immediately.  They are scheduled with :meth:`loop.call_soon` instead."
msgstr ""
"Зворотні виклики, зареєстровані за допомогою :meth:`asyncio.Future."
"add_done_callback`, не викликаються негайно. Натомість вони плануються за "
"допомогою :meth:`loop.call_soon`."

msgid ""
"asyncio Future is not compatible with the :func:`concurrent.futures.wait` "
"and :func:`concurrent.futures.as_completed` functions."
msgstr ""
"asyncio Future несумісний із функціями :func:`concurrent.futures.wait` і :"
"func:`concurrent.futures.as_completed`."

msgid ""
":meth:`asyncio.Future.cancel` accepts an optional ``msg`` argument, but :"
"func:`concurrent.futures.cancel` does not."
msgstr ""
":meth:`asyncio.Future.cancel` приймає необов’язковий аргумент ``msg``, але :"
"func:`concurrent.futures.cancel` не приймає."
