# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:57+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`configparser` --- Configuration file parser"
msgstr ":mod:`configparser` --- Парсер конфігураційного файлу"

msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Вихідний код:** :source:`Lib/configparser.py`"

msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Цей модуль надає клас :class:`ConfigParser`, який реалізує базову мову "
"конфігурації, яка забезпечує структуру, подібну до тієї, що міститься у "
"файлах Microsoft Windows INI. Ви можете використовувати це для написання "
"програм на Python, які можуть бути легко налаштовані кінцевими користувачами."

msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Ця бібліотека *не* інтерпретує та не записує префікси типу значень, які "
"використовуються в розширеній версії синтаксису INI реєстру Windows."

msgid "Module :mod:`shlex`"
msgstr "Модуль :mod:`shlex`"

msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr ""
"Підтримка створення міні-мов Unix, подібних до оболонки, які можна "
"використовувати як альтернативний формат файлів конфігурації програми."

msgid "Module :mod:`json`"
msgstr "Модуль :mod:`json`"

msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr ""
"Модуль json реалізує підмножину синтаксису JavaScript, який також можна "
"використовувати для цієї мети."

msgid "Quick Start"
msgstr "Швидкий початок"

msgid "Let's take a very basic configuration file that looks like this:"
msgstr "Давайте візьмемо простий файл конфігурації, який виглядає так:"

msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"Структура файлів INI описана `в наступному розділі <#supported-ini-file-"
"structure>`_. По суті, файл складається з розділів, кожен з яких містить "
"ключі зі значеннями. :mod:`configparser` класи можуть читати та записувати "
"такі файли. Почнемо зі створення наведеного вище файлу конфігурації "
"програмним шляхом."

msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Як бачите, ми можемо розглядати аналізатор конфігурації так само, як "
"словник. Є відмінності, `викладені пізніше <#mapping-protocol-access>`_, але "
"поведінка дуже близька до того, що ви очікуєте від словника."

msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Тепер, коли ми створили та зберегли файл конфігурації, давайте перечитаємо "
"його та дослідимо дані, які він містить."

msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Як ми бачимо вище, API досить простий. Єдина магія стосується розділу "
"``DEFAULT``, який надає значення за умовчанням для всіх інших розділів [1]_. "
"Зауважте також, що ключі в розділах нечутливі до регістру та зберігаються в "
"нижньому регістрі [1]_."

msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained."
msgstr ""
"Можна прочитати кілька конфігурацій в один :class:`ConfigParser`, де "
"найвищий пріоритет має остання додана конфігурація. Будь-які конфліктні "
"ключі беруться з останньої конфігурації, тоді як існуючі раніше ключі "
"зберігаються."

msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr ""
"Така поведінка еквівалентна виклику :meth:`ConfigParser.read` з кількома "
"файлами, переданими в параметр *filenames*."

msgid "Supported Datatypes"
msgstr "Підтримувані типи даних"

msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Синтаксичні аналізатори конфігурації не вгадують типи даних значень у файлах "
"конфігурації, завжди зберігаючи їх усередині як рядки. Це означає, що якщо "
"вам потрібні інші типи даних, ви повинні конвертувати самостійно:"

msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Оскільки це завдання дуже поширене, аналізатори конфігурації надають ряд "
"зручних методів отримання для обробки цілих чисел, чисел з плаваючою точкою "
"та логічних значень. Останнє є найцікавішим, тому що проста передача "
"значення в ``bool()`` не принесе користі, оскільки ``bool('False')`` все ще "
"``True``. Ось чому аналізатори конфігурації також надають :meth:"
"`~ConfigParser.getboolean`. Цей метод не враховує регістр і розпізнає "
"логічні значення з ``'yes'``/``'no'``, ``'on'``/``'off'``, ``'true'`` /"
"``'false'`` і ``'1'``/``'0'`` [1]_. Наприклад:"

msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Крім :meth:`~ConfigParser.getboolean`, аналізатори конфігурації також "
"надають еквівалентні методи :meth:`~ConfigParser.getint` і :meth:"
"`~ConfigParser.getfloat`. Ви можете зареєструвати власні конвертери та "
"налаштувати надані. [1]_"

msgid "Fallback Values"
msgstr "Запасні значення"

msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr ""
"Як і у випадку зі словником, ви можете використовувати метод розділу :meth:"
"`get` для надання резервних значень:"

msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.com'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Зауважте, що значення за замовчуванням мають пріоритет над резервними "
"значеннями. Наприклад, у нашому прикладі ключ ``'CompressionLevel`` було "
"вказано лише в розділі ``'DEFAULT'``. Якщо ми спробуємо отримати його з "
"розділу ``'topsecret.server.com``, ми завжди отримаємо значення за "
"замовчуванням, навіть якщо ми вкажемо запасний варіант:"

msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via "
"the ``fallback`` keyword-only argument:"
msgstr ""
"Ще одна річ, про яку слід пам’ятати, це те, що метод :meth:`get` на рівні "
"аналізатора надає спеціальний, більш складний інтерфейс, який підтримується "
"для зворотної сумісності. Під час використання цього методу резервне "
"значення може бути надано за допомогою лише ключового аргументу ``fallback``:"

msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"Той самий резервний аргумент можна використовувати з методами :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` і :meth:"
"`~ConfigParser.getboolean`, наприклад:"

msgid "Supported INI File Structure"
msgstr "Підтримувана структура файлу INI"

msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"Файл конфігурації складається з розділів, кожен із яких очолюється "
"заголовком ``[section]``, за яким ідуть записи ключ/значення, розділені "
"певним рядком (``=`` або ``:`` за умовчанням [1]_) . За замовчуванням назви "
"розділів чутливі до регістру, але ключі не [1]_. Пробіли на початку та в "
"кінці видаляються з ключів і значень. Значення можна опустити, якщо "
"синтаксичний аналізатор налаштовано на це дозволено [1]_, у цьому випадку "
"роздільник ключ/значення також може бути пропущений. Значення також можуть "
"охоплювати кілька рядків, якщо вони мають відступ глибший, ніж перший рядок "
"значення. Залежно від режиму аналізатора, порожні рядки можуть розглядатися "
"як частини багаторядкових значень або ігноруватися."

msgid ""
"By default,  a valid section name can be any string that does not contain '\\"
"\\n' or ']'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"За замовчуванням дійсна назва розділу може бути будь-яким рядком, який не "
"містить '\\\\n' або ']'. Щоб змінити це, перегляньте :attr:`ConfigParser."
"SECTCRE`."

msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Файли конфігурації можуть містити коментарі, перед якими стоять певні "
"символи (``#`` і ``;`` за замовчуванням [1]_). Коментарі можуть з’явитися "
"самостійно в порожньому рядку, можливо, з відступом. [1]_"

msgid "For example:"
msgstr "Наприклад:"

msgid "Interpolation of values"
msgstr "Інтерполяція значень"

msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"Окрім основних функцій, :class:`ConfigParser` підтримує інтерполяцію. Це "
"означає, що значення можна попередньо обробити перед поверненням із викликів "
"``get()``."

msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"Стандартна реалізація, яку використовує :class:`ConfigParser`. Це дозволяє "
"значенням містити рядки формату, які посилаються на інші значення в тому "
"самому розділі, або значення в спеціальному розділі за замовчуванням [1]_. "
"Під час ініціалізації можна надати додаткові значення за замовчуванням."

msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"У наведеному вище прикладі :class:`ConfigParser` з *інтерполяцією*, "
"встановленою на ``BasicInterpolation()``, перетворює ``%(home_dir)s`` на "
"значення ``home_dir`` (``/Users`` у цьому випадку ). ``%(my_dir)s`` фактично "
"перетворювався б на ``/Users/lumberjack``. Усі інтерполяції виконуються на "
"вимогу, тому ключі, які використовуються в ланцюжку посилань, не потрібно "
"вказувати в певному порядку у файлі конфігурації."

msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Якщо ``interpolation`` встановлено на ``None``, аналізатор просто "
"повертатиме ``%(my_dir)s`` як значення ``my_pictures`` і ``%(home_dir)s/"
"lumberjack`` як значення ``my_dir``."

msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Альтернативний обробник для інтерполяції, який реалізує розширеніший "
"синтаксис, який використовується, наприклад, у ``zc.buildout``. Розширена "
"інтерполяція використовує ``${section:option}`` для позначення значення з "
"іноземного розділу. Інтерполяція може охоплювати кілька рівнів. Для "
"зручності, якщо частина ``section:`` опущена, інтерполяція за замовчуванням "
"використовується для поточного розділу (і, можливо, до значень за "
"замовчуванням зі спеціального розділу)."

msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Наприклад, зазначена вище конфігурація з базовою інтерполяцією виглядатиме "
"так з розширеною інтерполяцією:"

msgid "Values from other sections can be fetched as well:"
msgstr "Також можна отримати значення з інших розділів:"

msgid "Mapping Protocol Access"
msgstr "Доступ до протоколу відображення"

msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"Доступ до протоколу зіставлення — це загальна назва функціональних "
"можливостей, які дають змогу використовувати спеціальні об’єкти як словники. "
"У випадку :mod:`configparser` реалізація інтерфейсу зіставлення використовує "
"нотацію ``parser['section']['option']``."

msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']`` зокрема повертає проксі для даних розділу в "
"аналізаторі. Це означає, що значення не копіюються, а беруться з "
"оригінального аналізатора на вимогу. Ще важливішим є те, що коли значення "
"змінюються на проксі-сервері розділу, вони фактично змінюються в "
"оригінальному парсері."

msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
":mod:`configparser` об’єкти поводяться якомога ближче до справжніх "
"словників. Інтерфейс зіставлення завершений і відповідає :class:"
"`~collections.abc.MutableMapping` ABC. Однак є кілька відмінностей, які слід "
"взяти до уваги:"

msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"За замовчуванням усі ключі в розділах доступні без урахування регістру [1]_. "
"наприклад ``for option in parser[\"section\"]`` дає лише ``optionxform`` "
"імена ключів опцій. Це означає, що ключі в нижньому регістрі за "
"замовчуванням. Водночас для розділу, який містить ключ ``'a``, обидва вирази "
"повертають ``True``::"

msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Усі розділи також містять значення ``DEFAULTSECT``, що означає, що ``."
"clear()`` у розділі не може залишати розділ видимо порожнім. Це тому, що "
"значення за замовчуванням не можна видалити з розділу (оскільки технічно їх "
"там немає). Якщо їх перевизначено в розділі, видалення призведе до того, що "
"значення за замовчуванням знову стане видимим. Спроба видалити значення за "
"замовчуванням викликає :exc:`KeyError`."

msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` не можна видалити з аналізатора:"

msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "спроба його видалити викликає :exc:`ValueError`,"

msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` залишає його недоторканим,"

msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` ніколи не повертає його."

msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - другий аргумент **не** є "
"резервним значенням. Однак зауважте, що методи ``get()`` на рівні розділу "
"сумісні як з протоколом відображення, так і з класичним API конфігуратора."

msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` сумісний із протоколом відображення (повертає список пар "
"*section_name*, *section_proxy*, включаючи DEFAULTSECT). Однак цей метод "
"також можна викликати за допомогою аргументів: ``parser.items(section, raw, "
"vars)``. Останній виклик повертає список пар *option*, *value* для вказаного "
"``розділу`` з усіма розширеними інтерполяціями (якщо не надано ``raw=True``)."

msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"Протокол відображення реалізовано поверх існуючого застарілого API, так що "
"підкласи, які замінюють вихідний інтерфейс, все ще повинні мати "
"відображення, що працюють належним чином."

msgid "Customizing Parser Behaviour"
msgstr "Налаштування поведінки аналізатора"

msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Існує майже стільки ж варіантів формату INI, скільки програм, які його "
"використовують. :mod:`configparser` робить довгий шлях, щоб забезпечити "
"підтримку найбільшого розумного набору доступних стилів INI. "
"Функціональність за замовчуванням здебільшого продиктована історичним "
"минулим, і дуже ймовірно, що ви захочете налаштувати деякі функції."

msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr ""
"Найпоширеніший спосіб змінити спосіб роботи конкретного парсера конфігурації "
"— це використовувати параметри :meth:`__init__`:"

msgid "*defaults*, default value: ``None``"
msgstr "*за замовчуванням*, значення за замовчуванням: ``None``"

msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Цей параметр приймає словник пар ключ-значення, який спочатку буде розміщено "
"в розділі ``DEFAULT``. Це створює елегантний спосіб підтримки стислих "
"конфігураційних файлів, які не вказують значення, які збігаються з "
"документованими за замовчуванням."

msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`read_dict` before you read the actual file."
msgstr ""
"Підказка: якщо ви хочете вказати значення за замовчуванням для певного "
"розділу, використовуйте :meth:`read_dict` перед тим, як читати фактичний "
"файл."

msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, значення за умовчанням: :class:`dict`"

msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Цей параметр значно впливає на роботу протоколу відображення та вигляд "
"записаних конфігураційних файлів. У стандартному словнику кожен розділ "
"зберігається в порядку їх додавання до синтаксичного аналізатора. Те саме "
"стосується параметрів у розділах."

msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Альтернативний тип словника можна використовувати, наприклад, для сортування "
"розділів і параметрів під час зворотного запису."

msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Зверніть увагу: є способи додати набір пар ключ-значення за одну операцію. "
"Якщо ви використовуєте звичайний словник у цих операціях, порядок ключів "
"буде впорядкованим. Наприклад:"

msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, значення за умовчанням: ``False``"

msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Відомо, що деякі конфігураційні файли містять налаштування без значень, але "
"в іншому випадку вони відповідають синтаксису, який підтримує :mod:"
"`configparser`. Параметр *allow_no_value* для конструктора можна "
"використовувати, щоб вказати, що такі значення повинні бути прийняті:"

msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*роздільники*, значення за умовчанням: ``('=', ':')``"

msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Роздільники — це підрядки, які відокремлюють ключі від значень у розділі. "
"Перше входження розділювального підрядка в рядок вважається роздільником. Це "
"означає, що значення (але не ключі) можуть містити розділювачі."

msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Дивіться також аргумент *space_around_delimiters* для :meth:`ConfigParser."
"write`."

msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, значення за умовчанням: ``('#', ';')``"

msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, значення за умовчанням: ``None``"

msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Префікси коментарів — це рядки, які вказують на початок дійсного коментаря у "
"конфігураційному файлі. *comment_prefixes* використовуються лише в порожніх "
"рядках (необов’язково з відступом), тоді як *inline_comment_prefixes* можна "
"використовувати після кожного дійсного значення (наприклад, назв розділів, "
"параметрів і порожніх рядків). За замовчуванням вбудовані коментарі "
"вимкнено, а ``'#'`` і ``';''`` використовуються як префікси для цілих "
"рядкових коментарів."

msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"У попередніх версіях :mod:`configparser` поведінка відповідала "
"``comment_prefixes=('#',';')`` та ``inline_comment_prefixes=(';',)``."

msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Зауважте, що аналізатори конфігурації не підтримують екранування префіксів "
"коментарів, тому використання *inline_comment_prefixes* може перешкодити "
"користувачам вказувати значення параметрів із символами, які "
"використовуються як префікси коментарів. Якщо сумніваєтеся, уникайте "
"встановлення *inline_comment_prefixes*. За будь-яких обставин єдиний спосіб "
"зберегти символи префікса коментаря на початку рядка в багаторядкових "
"значеннях — це інтерполювати префікс, наприклад::"

msgid "*strict*, default value: ``True``"
msgstr "*строгий*, значення за умовчанням: ``True``"

msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, :"
"meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""
"Якщо встановлено значення ``True``, синтаксичний аналізатор не допускатиме "
"жодних дублікатів розділів чи параметрів під час читання з одного джерела (з "
"використанням :meth:`read_file`, :meth:`read_string` або :meth:`read_dict`). "
"Рекомендується використовувати строгі парсери в нових програмах."

msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"У попередніх версіях :mod:`configparser` поведінка відповідала "
"``strict=False``."

msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, значення за умовчанням: ``True``"

msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"У синтаксичних аналізаторах конфігурації значення можуть охоплювати кілька "
"рядків, якщо вони мають відступ більше, ніж ключ, який їх містить. За "
"замовчуванням аналізатори також дозволяють порожнім рядкам бути частинами "
"значень. У той же час самі клавіші можуть мати довільний відступ для "
"покращення читабельності. Як наслідок, коли файли конфігурації стають "
"великими та складними, користувачеві легко втратити структуру файлу. "
"Візьмемо, наприклад:"

msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Це може бути особливо проблематично для користувача, щоб побачити, чи він "
"використовує пропорційний шрифт для редагування файлу. Ось чому, якщо вашій "
"програмі не потрібні значення з порожніми рядками, вам слід подумати про їх "
"заборону. Це змусить порожні рядки кожного разу розділяти ключі. У "
"наведеному вище прикладі буде створено два ключі, ``key`` і ``this``."

msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, значення за замовчуванням: ``configparser.DEFAULTSECT`` "
"(тобто: ``\"DEFAULT\"``)"

msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"Угода про дозвіл спеціального розділу значень за замовчуванням для інших "
"розділів або для цілей інтерполяції є потужною концепцією цієї бібліотеки, "
"що дозволяє користувачам створювати складні декларативні конфігурації. Цей "
"розділ зазвичай називається ``\"ЗА УМОВЧУВАННЯМ\"``, але його можна "
"налаштувати так, щоб вказувати на будь-яку іншу дійсну назву розділу. Деякі "
"типові значення включають: ``\"загальний\"`` або ``\"загальний\"``. Надана "
"назва використовується для розпізнавання розділів за замовчуванням під час "
"читання з будь-якого джерела та під час запису конфігурації назад у файл. "
"Його поточне значення можна отримати за допомогою атрибута ``parser_instance."
"default_section`` і можна змінити під час виконання (тобто для перетворення "
"файлів з одного формату в інший)."

msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr ""
"*інтерполяція*, значення за умовчанням: ``configparser.BasicInterpolation``"

msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"Поведінку інтерполяції можна налаштувати, надавши спеціальний обробник через "
"аргумент *interpolation*. ``None`` можна використовувати, щоб повністю "
"вимкнути інтерполяцію, ``ExtendedInterpolation()`` надає більш просунутий "
"варіант, натхненний ``zc.buildout``. Більше про цю тему див. у розділі "
"`спеціальної документації <#interpolation-of-values>`_. :class:"
"`RawConfigParser` має значення за замовчуванням ``None``."

msgid "*converters*, default value: not set"
msgstr "*конвертери*, значення за замовчуванням: не встановлено"

msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"Синтаксичні аналізатори конфігурації забезпечують отримання значень "
"параметрів, які виконують перетворення типів. За замовчуванням реалізовано :"
"meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` і :meth:"
"`~ConfigParser.getboolean`. Якщо потрібні інші геттери, користувачі можуть "
"визначити їх у підкласі або передати словник, де кожен ключ є назвою "
"конвертера, а кожне значення є викликом, що реалізує вказане перетворення. "
"Наприклад, передача ``{'decimal': decimal.Decimal}`` додасть :meth:"
"`getdecimal` як до об’єкта аналізатора, так і до всіх проксі-серверів "
"розділів. Іншими словами, можна буде написати як ``parser_instance."
"getdecimal('section', 'key', fallback=0)``, так і "
"``parser_instance['section'].getdecimal('key', 0)``."

msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Якщо конвертеру потрібно отримати доступ до стану аналізатора, його можна "
"реалізувати як метод у підкласі аналізатора конфігурації. Якщо назва цього "
"методу починається з ``get``, він буде доступний на всіх проксі-серверах "
"розділів у формі, сумісній з dict (див. приклад ``getdecimal()`` вище)."

msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Більш просунуте налаштування можна досягти шляхом заміни значень за "
"замовчуванням цих атрибутів аналізатора. Значення за замовчуванням визначені "
"в класах, тому вони можуть бути замінені підкласами або призначенням "
"атрибутів."

msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"За замовчуванням під час використання :meth:`~ConfigParser.getboolean` "
"аналізатори конфігурації враховують такі значення ``True``: ``'1'``, "
"``'yes'``, ``'true'``, ``'on'`` і такі значення ``False``: ``'0'``, "
"``'no'``, ``'false'``, ``'off'``. Ви можете перевизначити це, вказавши "
"спеціальний словник рядків та їхніх логічних результатів. Наприклад:"

msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""
"Інші типові логічні пари включають ``accept``/``reject`` або ``enabled``/"
"``disabled``."

msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"Цей метод перетворює назви параметрів під час кожної операції читання, "
"отримання або встановлення. За замовчуванням ім'я перетворюється на малі "
"літери. Це також означає, що під час запису файлу конфігурації всі ключі "
"будуть малими літерами. Перевизначте цей метод, якщо він не підходить. "
"Наприклад:"

msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"Функція optionxform перетворює назви опцій у канонічну форму. Це має бути "
"ідемпотентна функція: якщо ім’я вже є в канонічній формі, його слід "
"повернути без змін."

msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"Зкомпільований регулярний вираз, який використовується для аналізу "
"заголовків розділів. За умовчанням ``[розділ]`` відповідає назві "
"``\"розділ\"``. Пробіли вважаються частиною назви розділу, тому ``[ arch ]`` "
"читатиметься як розділ назви ``\" arch \"``. Перевизначте цей атрибут, якщо "
"він не підходить. Наприклад:"

msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"Хоча об’єкти ConfigParser також використовують атрибут ``OPTCRE`` для "
"розпізнавання рядків параметрів, не рекомендується перевизначати його, "
"оскільки це заважало б параметрам конструктора *allow_no_value* і "
"*роздільники*."

msgid "Legacy API Examples"
msgstr "Приклади застарілих API"

msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"В основному через проблеми зворотної сумісності :mod:`configparser` також "
"надає застарілий API з явними методами ``get``/``set``. Хоча існують дійсні "
"випадки використання описаних нижче методів, для нових проектів перевагу "
"надають доступу до протоколу відображення. Застарілий API часом є "
"досконалішим, низькорівневим і відверто неінтуїтивним."

msgid "An example of writing to a configuration file::"
msgstr "Приклад запису в конфігураційний файл::"

msgid "An example of reading the configuration file again::"
msgstr "Приклад повторного читання конфігураційного файлу::"

msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "Щоб отримати інтерполяцію, використовуйте :class:`ConfigParser`::"

msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Значення за замовчуванням доступні в обох типах ConfigParsers. Вони "
"використовуються в інтерполяції, якщо використовувана опція не визначена в "
"іншому місці. ::"

msgid "ConfigParser Objects"
msgstr "Об’єкти ConfigParser"

msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"Основний аналізатор конфігурації. Коли задано *defaults*, воно "
"ініціалізується у словнику внутрішніх типових значень. Якщо вказано "
"*dict_type*, він використовуватиметься для створення об’єктів словника для "
"списку розділів, параметрів у розділі та значень за замовчуванням."

msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"Якщо вказано *роздільники*, вони використовуються як набір підрядків, які "
"відділяють ключі від значень. Якщо вказано *comment_prefixes*, він "
"використовуватиметься як набір підрядків, які додають коментарі до порожніх "
"рядків. Коментарі можна робити з відступом. Якщо задано "
"*inline_comment_prefixes*, воно використовуватиметься як набір підрядків, "
"які додають коментарі до непорожніх рядків."

msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"Якщо *strict* має значення ``True`` (за замовчуванням), синтаксичний "
"аналізатор не допускатиме жодних дублікатів розділів або параметрів під час "
"читання з одного джерела (файлу, рядка або словника), викликаючи :exc:"
"`DuplicateSectionError` або  :exc:`DuplicateOptionError`. Коли "
"*empty_lines_in_values* має значення ``False`` (за замовчуванням: ``True``), "
"кожен порожній рядок позначає кінець параметра. В іншому випадку внутрішні "
"порожні рядки багаторядкового параметра зберігаються як частина значення. "
"Якщо *allow_no_value* має значення ``True`` (за замовчуванням: ``False``), "
"параметри без значень приймаються; значенням, яке зберігається для них, є "
"``None``, і вони серіалізуються без кінцевого розділювача."

msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""
"Якщо задано *default_section*, воно вказує ім’я спеціального розділу, що "
"містить значення за замовчуванням для інших розділів і цілей інтерполяції "
"(зазвичай називається ``\"DEFAULT\"``). Це значення можна отримати та "
"змінити під час виконання за допомогою атрибута екземпляра "
"``default_section``."

msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"Поведінку інтерполяції можна налаштувати, надавши спеціальний обробник через "
"аргумент *interpolation*. ``None`` можна використовувати, щоб повністю "
"вимкнути інтерполяцію, ``ExtendedInterpolation()`` надає більш просунутий "
"варіант, натхненний ``zc.buildout``. Більше про цю тему див. у розділі "
"`спеціальної документації <#interpolation-of-values>`_."

msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Усі назви опцій, що використовуються в інтерполяції, будуть передані через "
"метод :meth:`optionxform` так само, як і будь-яке інше посилання на назву "
"опції. Наприклад, використовуючи стандартну реалізацію :meth:`optionxform` "
"(яка перетворює назви опцій у нижній регістр), значення ``foo %(bar)s`` і "
"``foo %(BAR)s`` є еквівалентними."

msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""
"Коли вказано *конвертери*, це має бути словник, у якому кожен ключ "
"представляє ім’я перетворювача типу, а кожне значення є викликом, що "
"реалізує перетворення з рядка в потрібний тип даних. Кожен конвертер отримує "
"власний відповідний метод :meth:`get*()` на об’єкті аналізатора та проксі-"
"серверах розділів."

msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "Типом *dict_type* є :class:`collections.OrderedDict`."

msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"Додано *allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* та *interpolation*."

msgid "The *converters* argument was added."
msgstr "Додано аргумент *конвертери*."

msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr ""
"Аргумент *defaults* зчитується за допомогою :meth:`read_dict()`, "
"забезпечуючи узгоджену поведінку в парсері: нерядкові ключі та значення "
"неявно перетворюються на рядки."

msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"Типом *dict_type* є :class:`dict`, оскільки тепер зберігається порядок "
"вставки."

msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""
"Повертає словник, що містить значення за замовчуванням для всього екземпляра."

msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Повернути список доступних розділів; *розділ за замовчуванням* не включено "
"до списку."

msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Додайте до екземпляра розділ із назвою *section*. Якщо розділ із вказаною "
"назвою вже існує, виникає :exc:`DuplicateSectionError`. Якщо передано назву "
"*розділу за замовчуванням*, виникає помилка :exc:`ValueError`. Назва розділу "
"має бути рядком; якщо ні, виникає :exc:`TypeError`."

msgid "Non-string section names raise :exc:`TypeError`."
msgstr "Нерядкові назви розділів викликають :exc:`TypeError`."

msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Вказує, чи присутній названий *розділ* у конфігурації. Розділ *за "
"замовчуванням* не підтверджується."

msgid "Return a list of options available in the specified *section*."
msgstr "Повернути список опцій, доступних у вказаному *розділі*."

msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Якщо заданий *розділ* існує та містить вказаний *опціон*, поверніть :const:"
"`True`; інакше повертає :const:`False`. Якщо вказаний *розділ* має значення :"
"const:`None` або порожній рядок, передбачається DEFAULT."

msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Спроба прочитати та розібрати ітерацію імен файлів, повертаючи список імен "
"файлів, які були успішно розібрані."

msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Якщо *filenames* є рядком, об’єктом :class:`bytes` або :term:`path-like "
"object`, воно розглядається як одне ім’я файлу. Якщо файл із назвою "
"*filenaname* неможливо відкрити, цей файл буде проігноровано. Це призначено "
"для того, щоб ви могли вказати ітерацію потенційних розташувань файлів "
"конфігурації (наприклад, поточний каталог, домашній каталог користувача та "
"деякий загальносистемний каталог), і всі існуючі файли конфігурації в "
"ітерації будуть прочитані."

msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Якщо жоден із названих файлів не існує, екземпляр :class:`ConfigParser` "
"міститиме порожній набір даних. Програма, яка потребує завантаження "
"початкових значень із файлу, має завантажити необхідний файл або файли за "
"допомогою :meth:`read_file` перед викликом :meth:`read` для будь-яких "
"додаткових файлів::"

msgid ""
"The *encoding* parameter.  Previously, all files were read using the default "
"encoding for :func:`open`."
msgstr ""
"Параметр *кодування*. Раніше всі файли читалися з використанням стандартного "
"кодування для :func:`open`."

msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "Параметр *filenames* приймає :term:`path-like object`."

msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "Параметр *filenames* приймає об’єкт :class:`bytes`."

msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Читати та аналізувати конфігураційні дані з *f*, які мають бути "
"повторюваними рядками Unicode (наприклад, файли, відкриті в текстовому "
"режимі)."

msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"Необов'язковий аргумент *джерело* вказує назву файлу, який читається. Якщо "
"не вказано і *f* має атрибут :attr:`name`, який використовується для "
"*source*; типовим є ``' <???> ''``."

msgid "Replaces :meth:`readfp`."
msgstr "Замінює :meth:`readfp`."

msgid "Parse configuration data from a string."
msgstr "Аналіз даних конфігурації з рядка."

msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"Необов'язковий аргумент *джерело* вказує контекстно-залежну назву переданого "
"рядка. Якщо не вказано, використовується ``' <string>'``. Зазвичай це має "
"бути шлях до файлової системи або URL-адреса."

msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Завантажте конфігурацію з будь-якого об’єкта, який надає dict-подібний метод "
"``items()``. Ключі - це назви розділів, значення - це словники з ключами та "
"значеннями, які повинні бути присутніми в розділі. Якщо використовуваний тип "
"словника зберігає порядок, розділи та їхні ключі будуть додані в порядку. "
"Значення автоматично перетворюються на рядки."

msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"Необов'язковий аргумент *джерело* вказує контекстно-залежну назву переданого "
"словника. Якщо не вказано, використовується ``<dict>``."

msgid "This method can be used to copy state between parsers."
msgstr "Цей метод можна використовувати для копіювання стану між парсерами."

msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Отримайте значення *option* для названого *розділу*. Якщо вказано *vars*, це "
"має бути словник. *Опція* шукається в *vars* (якщо передбачено), *section* і "
"в *DEFAULTSECT* у такому порядку. Якщо ключ не знайдено і надано "
"*резервний*, він використовується як резервне значення. ``None`` можна "
"надати як *резервне* значення."

msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Усі інтерполяції ``'%'`` розгортаються у значеннях, що повертаються, якщо "
"аргумент *raw* не має значення true. Значення для ключів інтерполяції "
"шукаються так само, як і параметр."

msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Аргументи *raw*, *vars* і *fallback* є лише ключовими словами, щоб захистити "
"користувачів від спроб використовувати третій аргумент як *резервний* резерв "
"(особливо під час використання протоколу відображення)."

msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Зручний метод, який приводить *опцію* у вказаному *розділі* до цілого числа. "
"Перегляньте :meth:`get` для пояснення *raw*, *vars* і *fallback*."

msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"Зручний метод, який приводить *опцію* у вказаному *розділі* до числа з "
"плаваючою комою. Перегляньте :meth:`get` для пояснення *raw*, *vars* і "
"*fallback*."

msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Зручний метод, який приводить *параметр* у вказаному *розділі* до логічного "
"значення. Зауважте, що допустимими значеннями параметра є ``'1'``, "
"``'yes'``, ``'true'`` і ``'on'``, через що цей метод повертає ``True`` і "
"``'0'``, ``'no'``, ``'false'`` і ``'off'``, які повертають ``False``. Ці "
"рядкові значення перевіряються без урахування регістру. Будь-яке інше "
"значення призведе до виникнення :exc:`ValueError`. Перегляньте :meth:`get` "
"для пояснення *raw*, *vars* і *fallback*."

msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Якщо *section* не вказано, повертає список пар *section_name*, "
"*section_proxy*, включаючи DEFAULTSECT."

msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"В іншому випадку поверніть список пар *ім’я*, *значення* для опцій у "
"вказаному *розділі*. Необов’язкові аргументи мають те саме значення, що й "
"для методу :meth:`get`."

msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Елементи, присутні в *vars*, більше не відображаються в результатах. "
"Попередня поведінка змішувала фактичні параметри аналізатора зі змінними, "
"наданими для інтерполяції."

msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Якщо даний розділ існує, установіть для даного параметра вказане значення; "
"інакше підняти :exc:`NoSectionError`. *option* і *value* мають бути рядками; "
"якщо ні, виникає :exc:`TypeError`."

msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Запишіть представлення конфігурації у вказаний :term:`file object`, який "
"потрібно відкрити в текстовому режимі (приймаючи рядки). Це представлення "
"може бути проаналізовано майбутнім викликом :meth:`read`. Якщо "
"*space_around_delimiters* має значення true, роздільники між ключами та "
"значеннями оточуються пробілами."

msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Коментарі у вихідному файлі конфігурації не зберігаються під час повторного "
"запису конфігурації. Те, що вважається коментарем, залежить від заданих "
"значень для *comment_prefix* і *inline_comment_prefix*."

msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Видалити вказаний *параметр* із зазначеного *розділу*. Якщо розділ не існує, "
"підніміть :exc:`NoSectionError`. Якщо існувала опція для видалення, "
"поверніть :const:`True`; інакше повертає :const:`False`."

msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Видалити вказаний *розділ* із конфігурації. Якщо розділ дійсно існував, "
"поверніть ``True``. Інакше поверніть ``False``."

msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Перетворює назву параметра *option*, знайдену у вхідному файлі або передану "
"кодом клієнта, у форму, яка має використовуватися у внутрішніх структурах. "
"Реалізація за замовчуванням повертає версію *option* у нижньому регістрі; "
"підкласи можуть замінити це, або код клієнта може встановити атрибут цього "
"імені в екземплярах, щоб вплинути на цю поведінку."

msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"Вам не потрібно створювати підкласи синтаксичного аналізатора, щоб "
"використовувати цей метод, ви також можете встановити його на екземпляр, на "
"функцію, яка приймає рядковий аргумент і повертає рядок. Наприклад, якщо "
"встановити значення ``str``, назви опцій будуть чутливими до регістру:"

msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Зауважте, що під час читання конфігураційних файлів пробіли навколо назв "
"параметрів видаляються перед викликом :meth:`optionxform`."

msgid "Use :meth:`read_file` instead."
msgstr "Натомість використовуйте :meth:`read_file`."

msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ":meth:`readfp` тепер повторює *fp* замість виклику ``fp.readline()``."

msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""
"Для існуючого коду, що викликає :meth:`readfp` з аргументами, які не "
"підтримують ітерацію, наступний генератор може використовуватися як обгортка "
"навколо файлоподібного об’єкта::"

msgid ""
"Instead of ``parser.readfp(fp)`` use ``parser."
"read_file(readline_generator(fp))``."
msgstr ""
"Замість ``parser.readfp(fp)`` використовуйте ``parser."
"read_file(readline_generator(fp))``."

msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only when the default *interpolation* "
"is used."
msgstr ""
"Максимальна глибина для рекурсивної інтерполяції для :meth:`get`, коли "
"параметр *raw* має значення false. Це актуально лише тоді, коли "
"використовується типова *інтерполяція*."

msgid "RawConfigParser Objects"
msgstr "Об’єкти RawConfigParser"

msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"Застарілий варіант :class:`ConfigParser`. Він має інтерполяцію вимкнено за "
"замовчуванням і дозволяє використовувати нерядкові назви розділів, назви "
"параметрів і значення за допомогою небезпечних методів ``add_section`` і "
"``set``, а також застарілої обробки аргументів ключового слова "
"``defaults=``. ."

msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Розгляньте можливість використання :class:`ConfigParser` натомість, який "
"перевіряє типи значень, які зберігатимуться всередині. Якщо вам не потрібна "
"інтерполяція, ви можете використати ``ConfigParser(interpolation=None)``."

msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"Додайте до екземпляра розділ із назвою *section*. Якщо розділ із вказаною "
"назвою вже існує, виникає :exc:`DuplicateSectionError`. Якщо передано назву "
"*розділу за замовчуванням*, виникає помилка :exc:`ValueError`."

msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"Тип *розділу* не позначено, що дозволяє користувачам створювати розділи без "
"рядкових імен. Така поведінка не підтримується та може викликати внутрішні "
"помилки."

msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Якщо даний розділ існує, установіть для даного параметра вказане значення; "
"інакше підняти :exc:`NoSectionError`. Хоча можна використовувати :class:"
"`RawConfigParser` (або :class:`ConfigParser` з *raw* параметрами, "
"встановленими на true) для *внутрішнього* зберігання нерядкових значень, "
"повна функціональність (включно з інтерполяцією та виведенням у файли) можна "
"досягти лише за допомогою рядкових значень."

msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Цей метод дозволяє користувачам внутрішньо призначати нерядкові значення "
"ключам. Така поведінка не підтримується та спричинить помилки під час спроби "
"запису у файл або отримання його в режимі без обробки. **Використовуйте API "
"протоколу зіставлення**, який не дозволяє виконувати такі призначення."

msgid "Exceptions"
msgstr "Винятки"

msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Базовий клас для всіх інших винятків :mod:`configparser`."

msgid "Exception raised when a specified section is not found."
msgstr "Виняток виникає, коли вказаний розділ не знайдено."

msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""
"Виняток виникає, якщо :meth:`add_section` викликається з назвою розділу, "
"який уже присутній, або в строгих синтаксичних аналізаторах, коли розділ "
"знайдено більше одного разу в одному вхідному файлі, рядку чи словнику."

msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to :meth:"
"`__init__` were added."
msgstr ""
"Було додано додаткові атрибути ``source`` і ``lineno`` і аргументи до :meth:"
"`__init__`."

msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Виняток, створений строгими парсерами, якщо одна опція з’являється двічі під "
"час читання з одного файлу, рядка або словника. Це виявляє орфографічні "
"помилки та помилки, пов’язані з регістром, напр. словник може мати два "
"ключі, що представляють один і той же ключ конфігурації без урахування "
"регістру."

msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Виняток виникає, коли вказаний параметр не знайдено у вказаному розділі."

msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Базовий клас для винятків, які виникають, коли виникають проблеми з "
"виконанням інтерполяції рядків."

msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Виняток виникає, коли інтерполяцію рядка неможливо завершити, оскільки "
"кількість ітерацій перевищує :const:`MAX_INTERPOLATION_DEPTH`. Підклас :exc:"
"`InterpolationError`."

msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Виняток виникає, коли параметр, на який посилається значення, не існує. "
"Підклас :exc:`InterpolationError`."

msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Виняток виникає, коли вихідний текст, у якому зроблено заміни, не відповідає "
"необхідному синтаксису. Підклас :exc:`InterpolationError`."

msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Під час спроби проаналізувати файл, який не має заголовків розділів, виникає "
"виняток."

msgid "Exception raised when errors occur attempting to parse a file."
msgstr "Виняток виникає, коли виникають помилки під час спроби аналізу файлу."

msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr ""
"Для узгодженості атрибут ``filename`` і аргумент :meth:`__init__` "
"перейменовано на ``source``."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"Синтаксичні аналізатори конфігурації дозволяють здійснювати серйозні "
"налаштування. Якщо ви зацікавлені в зміні поведінки, окресленої посиланням "
"на виноску, зверніться до розділу \"Налаштування поведінки "
"аналізатора\" (`Customizing Parser Behaviour`_)."
