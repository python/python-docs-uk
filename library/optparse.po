# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-04 14:18+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/optparse.rst:2
msgid ":mod:`!optparse` --- Parser for command line options"
msgstr ""

#: ../../library/optparse.rst:10
msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**Вихідний код:** :source:`Lib/optparse.py`"

#: ../../library/optparse.rst:17
msgid "Choosing an argument parsing library"
msgstr ""

#: ../../library/optparse.rst:19
msgid "The standard library includes three argument parsing libraries:"
msgstr ""

#: ../../library/optparse.rst:21
msgid ""
":mod:`getopt`: a module that closely mirrors the procedural C ``getopt`` "
"API. Included in the standard library since before the initial Python 1.0 "
"release."
msgstr ""

#: ../../library/optparse.rst:23
msgid ""
":mod:`optparse`: a declarative replacement for ``getopt`` that provides "
"equivalent functionality without requiring each application to implement its"
" own procedural option parsing logic. Included in the standard library since"
" the Python 2.3 release."
msgstr ""

#: ../../library/optparse.rst:27
msgid ""
":mod:`argparse`: a more opinionated alternative to ``optparse`` that "
"provides more functionality by default, at the expense of reduced "
"application flexibility in controlling exactly how arguments are processed. "
"Included in the standard library since the Python 2.7 and Python 3.2 "
"releases."
msgstr ""

#: ../../library/optparse.rst:32
msgid ""
"In the absence of more specific argument parsing design constraints, "
":mod:`argparse` is the recommended choice for implementing command line "
"applications, as it offers the highest level of baseline functionality with "
"the least application level code."
msgstr ""

#: ../../library/optparse.rst:36
msgid ""
":mod:`getopt` is retained almost entirely for backwards compatibility "
"reasons. However, it also serves a niche use case as a tool for prototyping "
"and testing command line argument handling in ``getopt``-based C "
"applications."
msgstr ""

#: ../../library/optparse.rst:40
msgid ""
":mod:`optparse` should be considered as an alternative to :mod:`argparse` in"
" the following cases:"
msgstr ""

#: ../../library/optparse.rst:43
msgid ""
"an application is already using :mod:`optparse` and doesn't want to risk the"
" subtle behavioural changes that may arise when migrating to :mod:`argparse`"
msgstr ""

#: ../../library/optparse.rst:45
msgid ""
"the application requires additional control over the way options and "
"positional parameters are interleaved on the command line (including the "
"ability to disable the interleaving feature completely)"
msgstr ""

#: ../../library/optparse.rst:48
msgid ""
"the application requires additional control over the incremental parsing of "
"command line elements (while ``argparse`` does support this, the exact way "
"it works in practice is undesirable for some use cases)"
msgstr ""

#: ../../library/optparse.rst:51
msgid ""
"the application requires additional control over the handling of options "
"which accept parameter values that may start with ``-`` (such as delegated "
"options to be passed to invoked subprocesses)"
msgstr ""

#: ../../library/optparse.rst:54
msgid ""
"the application requires some other command line parameter processing "
"behavior which ``argparse`` does not support, but which can be implemented "
"in terms of the lower level interface offered by ``optparse``"
msgstr ""

#: ../../library/optparse.rst:58
msgid ""
"These considerations also mean that :mod:`optparse` is likely to provide a "
"better foundation for library authors writing third party command line "
"argument processing libraries."
msgstr ""

#: ../../library/optparse.rst:62
msgid ""
"As a concrete example, consider the following two command line argument "
"parsing configurations, the first using ``optparse``, and the second using "
"``argparse``:"
msgstr ""

#: ../../library/optparse.rst:66
msgid ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"
msgstr ""

#: ../../library/optparse.rst:77
msgid ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"
msgstr ""

#: ../../library/optparse.rst:89
msgid ""
"The most obvious difference is that in the ``optparse`` version, the non-"
"option arguments are processed separately by the application after the "
"option processing is complete. In the ``argparse`` version, positional "
"arguments are declared and processed in the same way as the named options."
msgstr ""

#: ../../library/optparse.rst:94
msgid ""
"However, the ``argparse`` version will also handle some parameter "
"combination differently from the way the ``optparse`` version would handle "
"them. For example (amongst other differences):"
msgstr ""

#: ../../library/optparse.rst:98
msgid ""
"supplying ``-o -v`` gives ``output=\"-v\"`` and ``verbose=False`` when using"
" ``optparse``, but a usage error with ``argparse`` (complaining that no "
"value has been supplied for ``-o/--output``, since ``-v`` is interpreted as "
"meaning the verbosity flag)"
msgstr ""

#: ../../library/optparse.rst:102
msgid ""
"similarly, supplying ``-o --`` gives ``output=\"--\"`` and ``args=()`` when "
"using ``optparse``, but a usage error with ``argparse`` (also complaining "
"that no value has been supplied for ``-o/--output``, since ``--`` is "
"interpreted as terminating the option processing and treating all remaining "
"values as positional arguments)"
msgstr ""

#: ../../library/optparse.rst:107
msgid ""
"supplying ``-o=foo`` gives ``output=\"=foo\"`` when using ``optparse``, but "
"gives ``output=\"foo\"`` with ``argparse`` (since ``=`` is special cased as "
"an alternative separator for option parameter values)"
msgstr ""

#: ../../library/optparse.rst:111
msgid ""
"Whether these differing behaviors in the ``argparse`` version are considered"
" desirable or a problem will depend on the specific command line application"
" use case."
msgstr ""

#: ../../library/optparse.rst:117
msgid ""
":pypi:`click` is a third party argument processing library (originally based"
" on ``optparse``), which allows command line applications to be developed as"
" a set of decorated command implementation functions."
msgstr ""

#: ../../library/optparse.rst:121
msgid ""
"Other third party libraries, such as :pypi:`typer` or :pypi:`msgspec-click`,"
" allow command line interfaces to be specified in ways that more effectively"
" integrate with static checking of Python type annotations."
msgstr ""

#: ../../library/optparse.rst:127
msgid "Introduction"
msgstr "Вступ"

#: ../../library/optparse.rst:129
msgid ""
":mod:`optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the minimalist :mod:`getopt` module. "
":mod:`optparse` uses a more declarative style of command-line parsing: you "
"create an instance of :class:`OptionParser`, populate it with options, and "
"parse the command line. :mod:`optparse` allows users to specify options in "
"the conventional GNU/POSIX syntax, and additionally generates usage and help"
" messages for you."
msgstr ""

#: ../../library/optparse.rst:137
msgid "Here's an example of using :mod:`optparse` in a simple script::"
msgstr "Ось приклад використання :mod:`optparse` у простому сценарії::"

#: ../../library/optparse.rst:139
msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"write report to FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"don't print status messages to stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:150
msgid ""
"With these few lines of code, users of your script can now do the \"usual "
"thing\" on the command-line, for example::"
msgstr ""
"За допомогою цих кількох рядків коду користувачі вашого сценарію тепер "
"можуть виконувати \"звичайні дії\" в командному рядку, наприклад:"

#: ../../library/optparse.rst:153
msgid "<yourscript> --file=outfile -q"
msgstr ""

#: ../../library/optparse.rst:155
msgid ""
"As it parses the command line, :mod:`optparse` sets attributes of the "
"``options`` object returned by :meth:`~OptionParser.parse_args` based on "
"user-supplied command-line values.  When :meth:`~OptionParser.parse_args` "
"returns from parsing this command line, ``options.filename`` will be "
"``\"outfile\"`` and ``options.verbose`` will be ``False``.  :mod:`optparse` "
"supports both long and short options, allows short options to be merged "
"together, and allows options to be associated with their arguments in a "
"variety of ways.  Thus, the following command lines are all equivalent to "
"the above example::"
msgstr ""

#: ../../library/optparse.rst:164
msgid ""
"<yourscript> -f outfile --quiet\n"
"<yourscript> --quiet --file outfile\n"
"<yourscript> -q -foutfile\n"
"<yourscript> -qfoutfile"
msgstr ""

#: ../../library/optparse.rst:169
msgid "Additionally, users can run one of the following ::"
msgstr "Крім того, користувачі можуть запустити одну з таких команд:"

#: ../../library/optparse.rst:171
msgid ""
"<yourscript> -h\n"
"<yourscript> --help"
msgstr ""

#: ../../library/optparse.rst:174
msgid ""
"and :mod:`optparse` will print out a brief summary of your script's options:"
msgstr "і :mod:`optparse` виведе короткий опис параметрів вашого сценарію:"

#: ../../library/optparse.rst:176
msgid ""
"Usage: <yourscript> [options]\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -f FILE, --file=FILE  write report to FILE\n"
"  -q, --quiet           don't print status messages to stdout"
msgstr ""

#: ../../library/optparse.rst:185
msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr ""
"де значення *yourscript* визначається під час виконання (зазвичай із "
"``sys.argv[0]``)."

#: ../../library/optparse.rst:192
msgid "Background"
msgstr "Фон"

#: ../../library/optparse.rst:194
msgid ""
":mod:`optparse` was explicitly designed to encourage the creation of "
"programs with straightforward command-line interfaces that follow the "
"conventions established by the :c:func:`!getopt` family of functions "
"available to C developers. To that end, it supports only the most common "
"command-line syntax and semantics conventionally used under Unix.  If you "
"are unfamiliar with these conventions, reading this section will allow you "
"to acquaint yourself with them."
msgstr ""

#: ../../library/optparse.rst:205
msgid "Terminology"
msgstr "Термінологія"

#: ../../library/optparse.rst:207
msgid "argument"
msgstr "аргумент"

#: ../../library/optparse.rst:208
msgid ""
"a string entered on the command-line, and passed by the shell to ``execl()``"
" or ``execv()``.  In Python, arguments are elements of ``sys.argv[1:]`` "
"(``sys.argv[0]`` is the name of the program being executed).  Unix shells "
"also use the term \"word\"."
msgstr ""
"рядок, введений у командному рядку та переданий оболонкою до ``execl()`` або"
" ``execv()``. У Python аргументи є елементами ``sys.argv[1:]`` "
"(``sys.argv[0]`` це ім'я програми, що виконується). Оболонки Unix також "
"використовують термін \"слово\"."

#: ../../library/optparse.rst:213
msgid ""
"It is occasionally desirable to substitute an argument list other than "
"``sys.argv[1:]``, so you should read \"argument\" as \"an element of "
"``sys.argv[1:]``, or of some other list provided as a substitute for "
"``sys.argv[1:]``\"."
msgstr ""
"Час від часу бажано замінити список аргументів іншим, ніж ``sys.argv[1:]``, "
"тому ви повинні читати \"аргумент\" як \"елемент ``sys.argv[1:]`` або деяких"
" інший список надається замість ``sys.argv[1:]``\"."

#: ../../library/optparse.rst:218
msgid "option"
msgstr "варіант"

#: ../../library/optparse.rst:219
msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; the "
"traditional Unix syntax is a hyphen (\"-\") followed by a single letter, "
"e.g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple "
"options to be merged into a single argument, e.g. ``-x -F`` is equivalent to"
" ``-xF``.  The GNU project introduced ``--`` followed by a series of hyphen-"
"separated words, e.g. ``--file`` or ``--dry-run``.  These are the only two "
"option syntaxes provided by :mod:`optparse`."
msgstr ""
"аргумент, який використовується для надання додаткової інформації для "
"керівництва або налаштування виконання програми. Існує багато різних "
"синтаксисів для параметрів; традиційний синтаксис Unix - це дефіс (\"-\"), "
"за яким йде одна літера, напр. ``-x`` або ``-F``. Крім того, традиційний "
"синтаксис Unix дозволяє об’єднати кілька параметрів в один аргумент, "
"наприклад. ``-x -F`` еквівалентно ``-xF``. У проекті GNU було введено "
"``--``, за яким йшов ряд слів, розділених дефісом, напр. ``--file`` або "
"``--dry-run``. Це єдині два синтаксиси параметрів, які надає "
":mod:`optparse`."

#: ../../library/optparse.rst:228
msgid "Some other option syntaxes that the world has seen include:"
msgstr "Деякі інші синтаксиси параметрів, які бачив світ, включають:"

#: ../../library/optparse.rst:230
msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same as "
"multiple options merged into a single argument)"
msgstr ""
"дефіс, за яким слідує кілька літер, напр. ``-pf`` (це *не* те саме, що "
"кілька параметрів, об’єднаних в один аргумент)"

#: ../../library/optparse.rst:233
msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the same "
"program)"
msgstr ""
"дефіс, за яким іде ціле слово, напр. ``-файл`` (технічно це еквівалент "
"попереднього синтаксису, але вони зазвичай не зустрічаються в одній "
"програмі)"

#: ../../library/optparse.rst:237
msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, e.g. "
"``+f``, ``+rgb``"
msgstr ""
"знак плюс, після якого йде одна літера, або кілька літер, або слово, напр. "
"``+f``, ``+rgb``"

#: ../../library/optparse.rst:240
msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, "
"``/file``"
msgstr ""
"косу риску, за якою йде літера, або кілька літер, або слово, напр. ``/f``, "
"``/file``"

#: ../../library/optparse.rst:243
msgid ""
"These option syntaxes are not supported by :mod:`optparse`, and they never "
"will be.  This is deliberate: the first three are non-standard on any "
"environment, and the last only makes sense if you're exclusively targeting "
"Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""
"Ці синтаксиси параметрів не підтримуються :mod:`optparse`, і вони ніколи не "
"будуть. Це зроблено навмисно: перші три є нестандартними для будь-якого "
"середовища, а останній має сенс, лише якщо ви націлені виключно на Windows "
"або певні застарілі платформи (наприклад, VMS, MS-DOS)."

#: ../../library/optparse.rst:248
msgid "option argument"
msgstr "аргумент опції"

#: ../../library/optparse.rst:249
msgid ""
"an argument that follows an option, is closely associated with that option, "
"and is consumed from the argument list when that option is. With "
":mod:`optparse`, option arguments may either be in a separate argument from "
"their option:"
msgstr ""
"аргумент, який слідує за опцією, тісно пов’язаний із цією опцією та "
"споживається зі списку аргументів, коли ця опція є. З :mod:`optparse` "
"аргументи опції можуть бути в окремому аргументі від їхньої опції:"

#: ../../library/optparse.rst:254
msgid ""
"-f foo\n"
"--file foo"
msgstr ""

#: ../../library/optparse.rst:259
msgid "or included in the same argument:"
msgstr "або включено в той самий аргумент:"

#: ../../library/optparse.rst:261
msgid ""
"-ffoo\n"
"--file=foo"
msgstr ""

#: ../../library/optparse.rst:266
msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of "
"people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  This"
" is somewhat controversial, because it makes parsing ambiguous: if ``-a`` "
"takes an optional argument and ``-b`` is another option entirely, how do we "
"interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` does not "
"support this feature."
msgstr ""
"Як правило, певна опція приймає аргумент або ні. Багатьом людям потрібна "
"функція \"необов’язкових аргументів параметрів\", тобто деякі параметри "
"прийматимуть аргумент, якщо вони його бачать, і ні, якщо вони його не "
"бачать. Це дещо суперечливо, оскільки це робить розбір неоднозначним: якщо "
"``-a`` приймає необов’язковий аргумент, а ``-b`` є іншим варіантом, як ми "
"інтерпретуємо ``-ab``? Через цю неоднозначність :mod:`optparse` не підтримує"
" цю функцію."

#: ../../library/optparse.rst:274
msgid "positional argument"
msgstr "позиційний аргумент"

#: ../../library/optparse.rst:275
msgid ""
"something leftover in the argument list after options have been parsed, i.e."
" after options and their arguments have been parsed and removed from the "
"argument list."
msgstr ""
"щось, що залишилося в списку аргументів після аналізу параметрів, тобто "
"після аналізу параметрів і їхніх аргументів і видалення зі списку "
"аргументів."

#: ../../library/optparse.rst:279
msgid "required option"
msgstr "необхідна опція"

#: ../../library/optparse.rst:280
msgid ""
"an option that must be supplied on the command-line; note that the phrase "
"\"required option\" is self-contradictory in English.  :mod:`optparse` "
"doesn't prevent you from implementing required options, but doesn't give you"
" much help at it either."
msgstr ""
"параметр, який необхідно вказати в командному рядку; зауважте, що фраза "
"\"необхідна опція\" є суперечливою англійською мовою. :mod:`optparse` не "
"заважає вам реалізовувати необхідні параметри, але й не дуже допомагає в "
"цьому."

#: ../../library/optparse.rst:285
msgid "For example, consider this hypothetical command-line::"
msgstr "Наприклад, розглянемо цей гіпотетичний командний рядок::"

#: ../../library/optparse.rst:287
msgid "prog -v --report report.txt foo bar"
msgstr ""

#: ../../library/optparse.rst:289
msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` takes "
"one argument, ``report.txt`` is an option argument.  ``foo`` and ``bar`` are"
" positional arguments."
msgstr ""
"``-v`` і ``--report`` є варіантами. Якщо припустити, що ``--report`` приймає"
" один аргумент, ``report.txt`` є аргументом опції. ``foo`` і ``bar`` є "
"позиційними аргументами."

#: ../../library/optparse.rst:297
msgid "What are options for?"
msgstr "Для чого існують варіанти?"

#: ../../library/optparse.rst:299
msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can it "
"run without any options at all and still make sense?  The main exceptions "
"are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant oddballs that"
" have been rightly criticized for their non-standard syntax and confusing "
"interfaces.)"
msgstr ""
"Параметри використовуються для надання додаткової інформації для "
"налаштування або налаштування виконання програми. Якщо це було незрозуміло, "
"параметри зазвичай *необов’язкові*. Програма повинна нормально працювати без"
" будь-яких опцій. (Виберіть випадкову програму з наборів інструментів Unix "
"або GNU. Чи може вона запускатися взагалі без будь-яких параметрів і мати "
"сенс? Основними винятками є ``find``, ``tar`` і ``dd``\\ -- - усі вони є "
"диваками-мутантами, яких справедливо критикували за нестандартний синтаксис "
"і заплутані інтерфейси.)"

#: ../../library/optparse.rst:307
msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a piece "
"of information that your program absolutely requires in order to run "
"successfully, that's what positional arguments are for."
msgstr ""
"Багато людей хочуть, щоб їхні програми мали \"необхідні параметри\". Подумай"
" над цим. Якщо це потрібно, то це *не обов’язково*! Якщо є частина "
"інформації, яка абсолютно необхідна вашій програмі для успішної роботи, це "
"те, для чого потрібні позиційні аргументи."

#: ../../library/optparse.rst:312
msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. Hence, "
"``cp`` fails if you run it with no arguments.  However, it has a flexible, "
"useful syntax that does not require any options at all::"
msgstr ""
"Як приклад гарного дизайну інтерфейсу командного рядка розглянемо скромну "
"утиліту ``cp`` для копіювання файлів. Немає особливого сенсу намагатися "
"скопіювати файли, не вказавши місце призначення та принаймні одне джерело. "
"Отже, ``cp`` не вдається, якщо ви запускаєте його без аргументів. Однак він "
"має гнучкий, корисний синтаксис, який не потребує жодних опцій:"

#: ../../library/optparse.rst:318
msgid ""
"cp SOURCE DEST\n"
"cp SOURCE ... DEST-DIR"
msgstr ""

#: ../../library/optparse.rst:321
msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations provide "
"a bunch of options to tweak exactly how the files are copied: you can "
"preserve mode and modification time, avoid following symlinks, ask before "
"clobbering existing files, etc.  But none of this distracts from the core "
"mission of ``cp``, which is to copy either one file to another, or several "
"files to another directory."
msgstr ""
"Тільки з цим можна зайти досить далеко. Більшість реалізацій ``cp`` надають "
"безліч параметрів для точного налаштування способу копіювання файлів: ви "
"можете зберегти режим і час модифікації, уникати переходу за символічними "
"посиланнями, запитувати перед тим, як затирати існуючі файли, тощо. Але це "
"не відволікає від основної місії ``cp``, який скопіює або один файл до "
"іншого, або декілька файлів до іншого каталогу."

#: ../../library/optparse.rst:332
msgid "What are positional arguments for?"
msgstr "Для чого потрібні позиційні аргументи?"

#: ../../library/optparse.rst:334
msgid ""
"Positional arguments are for those pieces of information that your program "
"absolutely, positively requires to run."
msgstr ""
"Позиційні аргументи призначені для тих фрагментів інформації, які вашій "
"програмі абсолютно необхідні для роботи."

#: ../../library/optparse.rst:337
msgid ""
"A good user interface should have as few absolute requirements as possible."
"  If your program requires 17 distinct pieces of information in order to run"
" successfully, it doesn't much matter *how* you get that information from "
"the user---most people will give up and walk away before they successfully "
"run the program.  This applies whether the user interface is a command-line,"
" a configuration file, or a GUI: if you make that many demands on your "
"users, most of them will simply give up."
msgstr ""
"Хороший інтерфейс користувача повинен мати якомога менше абсолютних вимог. "
"Якщо ваша програма потребує 17 окремих фрагментів інформації для успішної "
"роботи, не має великого значення *як* ви отримуєте цю інформацію від "
"користувача --- більшість людей здадуться та підуть, перш ніж вони успішно "
"запустять програму. Це стосується незалежно від того, чи є інтерфейс "
"користувача командним рядком, файлом конфігурації чи графічним інтерфейсом "
"користувача: якщо ви поставите стільки вимог до своїх користувачів, "
"більшість із них просто здадуться."

#: ../../library/optparse.rst:345
msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible.  Of"
" course, you also want to make your programs reasonably flexible.  That's "
"what options are for.  Again, it doesn't matter if they are entries in a "
"config file, widgets in the \"Preferences\" dialog of a GUI, or command-line"
" options---the more options you implement, the more flexible your program "
"is, and the more complicated its implementation becomes.  Too much "
"flexibility has drawbacks as well, of course; too many options can overwhelm"
" users and make your code much harder to maintain."
msgstr ""
"Коротше кажучи, намагайтеся мінімізувати кількість інформації, яку "
"користувачі абсолютно зобов’язані надавати --- використовуйте розумні "
"значення за замовчуванням, коли це можливо. Звичайно, ви також хочете "
"зробити свої програми досить гнучкими. Для цього і потрібні варіанти. Знову "
"ж таки, не має значення, чи це записи у конфігураційному файлі, віджети в "
"діалоговому вікні \"Параметри\" графічного інтерфейсу користувача чи "
"параметри командного рядка --- чим більше параметрів ви застосовуєте, тим "
"гнучкішою є ваша програма, і ускладнюється його реалізація. Занадто велика "
"гнучкість також має недоліки, звичайно; занадто багато параметрів може "
"перевантажити користувачів і зробити ваш код набагато складнішим для "
"підтримки."

#: ../../library/optparse.rst:358
msgid "Tutorial"
msgstr "Підручник"

#: ../../library/optparse.rst:360
msgid ""
"While :mod:`optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code patterns"
" that are common to any :mod:`optparse`\\ -based program."
msgstr ""
"Хоча :mod:`optparse` досить гнучкий і потужний, він також простий у "
"використанні в більшості випадків. Цей розділ охоплює шаблони коду, які є "
"спільними для будь-якої програми на основі :mod:`optparse`\\."

#: ../../library/optparse.rst:364
msgid ""
"First, you need to import the OptionParser class; then, early in the main "
"program, create an OptionParser instance::"
msgstr ""
"По-перше, вам потрібно імпортувати клас OptionParser; потім на початку "
"основної програми створіть екземпляр OptionParser::"

#: ../../library/optparse.rst:367
msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"
msgstr ""

#: ../../library/optparse.rst:371
msgid "Then you can start defining options.  The basic syntax is::"
msgstr "Потім можна приступати до визначення варіантів. Основний синтаксис::"

#: ../../library/optparse.rst:373
msgid ""
"parser.add_option(opt_str, ...,\n"
"                  attr=value, ...)"
msgstr ""

#: ../../library/optparse.rst:376
msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``, "
"and several option attributes that tell :mod:`optparse` what to expect and "
"what to do when it encounters that option on the command line."
msgstr ""
"Кожна опція має один або більше рядків опції, наприклад ``-f`` або "
"``--file``, і кілька атрибутів опції, які повідомляють :mod:`optparse`, чого"
" очікувати і що робити, коли він зустрічає цю опцію в командному рядку."

#: ../../library/optparse.rst:380
msgid ""
"Typically, each option will have one short option string and one long option"
" string, e.g.::"
msgstr ""
"Як правило, кожен параметр матиме один короткий рядок параметра та один "
"довгий рядок параметра, наприклад::"

#: ../../library/optparse.rst:383
msgid "parser.add_option(\"-f\", \"--file\", ...)"
msgstr ""

#: ../../library/optparse.rst:385
msgid ""
"You're free to define as many short option strings and as many long option "
"strings as you like (including zero), as long as there is at least one "
"option string overall."
msgstr ""
"Ви можете визначати скільки завгодно коротких рядків параметрів і скільки "
"завгодно довгих рядків параметрів (включаючи нуль), за умови, що є принаймні"
" один рядок параметрів."

#: ../../library/optparse.rst:389
msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are effectively"
" labels for the option defined by that call.  For brevity, we will "
"frequently refer to *encountering an option* on the command line; in "
"reality, :mod:`optparse` encounters *option strings* and looks up options "
"from them."
msgstr ""
"Рядки параметрів, передані до :meth:`OptionParser.add_option`, фактично є "
"мітками для параметра, визначеного цим викликом. Для стислості ми будемо "
"часто посилатися на *зустріч параметра* в командному рядку; насправді "
":mod:`optparse` зустрічає *рядки параметрів* і шукає параметри з них."

#: ../../library/optparse.rst:395
msgid ""
"Once all of your options are defined, instruct :mod:`optparse` to parse your"
" program's command line::"
msgstr ""
"Коли всі ваші параметри визначено, дайте команду :mod:`optparse` "
"проаналізувати командний рядок вашої програми:"

#: ../../library/optparse.rst:398
msgid "(options, args) = parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:400
msgid ""
"(If you like, you can pass a custom argument list to "
":meth:`~OptionParser.parse_args`, but that's rarely necessary: by default it"
" uses ``sys.argv[1:]``.)"
msgstr ""

#: ../../library/optparse.rst:403
msgid ":meth:`~OptionParser.parse_args` returns two values:"
msgstr ""

#: ../../library/optparse.rst:405
msgid ""
"``options``, an object containing values for all of your options---e.g. if "
"``--file`` takes a single string argument, then ``options.file`` will be the"
" filename supplied by the user, or ``None`` if the user did not supply that "
"option"
msgstr ""
"``options``, об’єкт, що містить значення для всіх ваших параметрів --- напр."
" якщо ``--file`` приймає один рядковий аргумент, ``options.file`` буде "
"іменем файлу, наданим користувачем, або ``None``, якщо користувач не вказав "
"цей параметр"

#: ../../library/optparse.rst:410
msgid ""
"``args``, the list of positional arguments leftover after parsing options"
msgstr ""
"``args``, список позиційних аргументів, що залишилися після аналізу "
"параметрів"

#: ../../library/optparse.rst:412
msgid ""
"This tutorial section only covers the four most important option attributes:"
" :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option.dest` "
"(destination), and :attr:`~Option.help`. Of these, :attr:`~Option.action` is"
" the most fundamental."
msgstr ""
"Цей розділ посібника охоплює лише чотири найважливіші атрибути параметрів: "
":attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option.dest` "
"(призначення) і :attr:`~Option.help`. З них :attr:`~Option.action` є "
"найбільш фундаментальним."

#: ../../library/optparse.rst:421
msgid "Understanding option actions"
msgstr "Розуміння опціональних дій"

#: ../../library/optparse.rst:423
msgid ""
"Actions tell :mod:`optparse` what to do when it encounters an option on the "
"command line.  There is a fixed set of actions hard-coded into "
":mod:`optparse`; adding new actions is an advanced topic covered in section "
":ref:`optparse-extending-optparse`.  Most actions tell :mod:`optparse` to "
"store a value in some variable---for example, take a string from the command"
" line and store it in an attribute of ``options``."
msgstr ""
"Дії повідомляють :mod:`optparse`, що робити, коли він зустрічає опцію в "
"командному рядку. Існує фіксований набір дій, жорстко закодований у "
":mod:`optparse`; додавання нових дій є розширеною темою, розглянутою в "
"розділі :ref:`optparse-extending-optparse`. Більшість дій говорять "
":mod:`optparse` зберігати значення в деякій змінній --- наприклад, взяти "
"рядок із командного рядка та зберегти його в атрибуті ``options``."

#: ../../library/optparse.rst:430
msgid ""
"If you don't specify an option action, :mod:`optparse` defaults to "
"``store``."
msgstr ""
"Якщо ви не вкажете опцію дії, :mod:`optparse` за замовчуванням буде "
"``store``."

#: ../../library/optparse.rst:436
msgid "The store action"
msgstr "Акція магазину"

#: ../../library/optparse.rst:438
msgid ""
"The most common option action is ``store``, which tells :mod:`optparse` to "
"take the next argument (or the remainder of the current argument), ensure "
"that it is of the correct type, and store it to your chosen destination."
msgstr ""
"Найпоширенішою дією опції є ``store``, яка повідомляє :mod:`optparse` взяти "
"наступний аргумент (або решту поточного аргументу), переконатися, що він має"
" правильний тип, і зберегти його у вибраному призначення."

#: ../../library/optparse.rst:442
msgid "For example::"
msgstr "Наприклад::"

#: ../../library/optparse.rst:444
msgid ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"
msgstr ""

#: ../../library/optparse.rst:447
msgid ""
"Now let's make up a fake command line and ask :mod:`optparse` to parse it::"
msgstr ""
"Тепер давайте створимо фальшивий командний рядок і попросимо :mod:`optparse`"
" розібрати його::"

#: ../../library/optparse.rst:449
msgid ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"
msgstr ""

#: ../../library/optparse.rst:452
msgid ""
"When :mod:`optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`~OptionParser.parse_args`, ``options.filename`` is "
"``\"foo.txt\"``."
msgstr ""

#: ../../library/optparse.rst:456
msgid ""
"Some other option types supported by :mod:`optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ""
"Деякі інші типи опцій, які підтримує :mod:`optparse`, це ``int`` і "
"``float``. Ось варіант, який очікує цілочисельний аргумент::"

#: ../../library/optparse.rst:459
msgid "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"
msgstr ""

#: ../../library/optparse.rst:461
msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is "
"``store``."
msgstr ""
"Зауважте, що цей параметр не має довгого рядка параметрів, що цілком "
"прийнятно. Крім того, немає явної дії, оскільки за замовчуванням є "
"``store``."

#: ../../library/optparse.rst:464
msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr ""
"Давайте розберемо ще один підроблений командний рядок. Цього разу ми "
"зіткнемося з аргументом option прямо проти параметра: оскільки ``-n42`` "
"(один аргумент) еквівалентний ``-n 42`` (два аргументи), код ::"

#: ../../library/optparse.rst:468
msgid ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"
msgstr ""

#: ../../library/optparse.rst:471
msgid "will print ``42``."
msgstr "надрукує ``42``."

#: ../../library/optparse.rst:473
msgid ""
"If you don't specify a type, :mod:`optparse` assumes ``string``.  Combined "
"with the fact that the default action is ``store``, that means our first "
"example can be a lot shorter::"
msgstr ""
"Якщо ви не вкажете тип, :mod:`optparse` припускає ``рядок``. У поєднанні з "
"тим фактом, що типовою дією є ``store``, це означає, що наш перший приклад "
"може бути набагато коротшим:"

#: ../../library/optparse.rst:477
msgid "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"
msgstr ""

#: ../../library/optparse.rst:479
msgid ""
"If you don't supply a destination, :mod:`optparse` figures out a sensible "
"default from the option strings: if the first long option string is ``--foo-"
"bar``, then the default destination is ``foo_bar``.  If there are no long "
"option strings, :mod:`optparse` looks at the first short option string: the "
"default destination for ``-f`` is ``f``."
msgstr ""
"Якщо ви не вкажете призначення, :mod:`optparse` визначає розумне значення за"
" замовчуванням із рядків параметрів: якщо перший довгий рядок параметрів – "
"``--foo-bar``, тоді призначенням за замовчуванням є ``foo_bar``. Якщо довгих"
" рядків параметрів немає, :mod:`optparse` шукає перший короткий рядок "
"параметрів: типовим призначенням для ``-f`` є ``f``."

#: ../../library/optparse.rst:485
msgid ""
":mod:`optparse` also includes the built-in ``complex`` type.  Adding types "
"is covered in section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` також містить вбудований тип ``complex``. Додавання типів "
"описано в розділі :ref:`optparse-extending-optparse`."

#: ../../library/optparse.rst:492
msgid "Handling boolean (flag) options"
msgstr "Обробка логічних параметрів (прапорів)."

#: ../../library/optparse.rst:494
msgid ""
"Flag options---set a variable to true or false when a particular option is "
"seen---are quite common.  :mod:`optparse` supports them with two separate "
"actions, ``store_true`` and ``store_false``.  For example, you might have a "
"``verbose`` flag that is turned on with ``-v`` and off with ``-q``::"
msgstr ""
"Параметри прапорів --- встановлюють для змінної значення true або false, "
"коли відображається певний параметр --- досить поширені. :mod:`optparse` "
"підтримує їх за допомогою двох окремих дій, ``store_true`` і "
"``store_false``. Наприклад, у вас може бути прапорець ``verbose``, який "
"вмикається за допомогою ``-v`` і вимикається ``-q``::"

#: ../../library/optparse.rst:499
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""

#: ../../library/optparse.rst:502
msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr ""
"Тут у нас є два різні варіанти з тим самим пунктом призначення, що цілком "
"нормально. (Це лише означає, що ви повинні бути трохи обережними, "
"встановлюючи значення за замовчуванням --- див. нижче.)"

#: ../../library/optparse.rst:506
msgid ""
"When :mod:`optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, "
"``options.verbose`` is set to ``False``."
msgstr ""
"Коли :mod:`optparse` зустрічає ``-v`` у командному рядку, він встановлює "
"``options.verbose`` на ``True``; коли зустрічається ``-q``, "
"``options.verbose`` встановлюється на ``False``."

#: ../../library/optparse.rst:514
msgid "Other actions"
msgstr "Інші дії"

#: ../../library/optparse.rst:516
msgid "Some other actions supported by :mod:`optparse` are:"
msgstr "Деякі інші дії, які підтримує :mod:`optparse`:"

#: ../../library/optparse.rst:518 ../../library/optparse.rst:1040
msgid "``\"store_const\"``"
msgstr "``\"store_const\"``"

#: ../../library/optparse.rst:519 ../../library/optparse.rst:1041
msgid "store a constant value, pre-set via :attr:`Option.const`"
msgstr ""

#: ../../library/optparse.rst:521 ../../library/optparse.rst:1049
msgid "``\"append\"``"
msgstr "``\"додати\"``"

#: ../../library/optparse.rst:522 ../../library/optparse.rst:1050
msgid "append this option's argument to a list"
msgstr "додати аргумент цього параметра до списку"

#: ../../library/optparse.rst:524 ../../library/optparse.rst:1055
msgid "``\"count\"``"
msgstr "``\"рахувати\"``"

#: ../../library/optparse.rst:525 ../../library/optparse.rst:1056
msgid "increment a counter by one"
msgstr "збільшити лічильник на одиницю"

#: ../../library/optparse.rst:527 ../../library/optparse.rst:1058
msgid "``\"callback\"``"
msgstr "``\"зворотний виклик\"``"

#: ../../library/optparse.rst:528 ../../library/optparse.rst:1059
msgid "call a specified function"
msgstr "викликати вказану функцію"

#: ../../library/optparse.rst:530
msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section "
":ref:`optparse-option-callbacks`."
msgstr ""
"Вони описані в розділі :ref:`optparse-reference-guide` і розділі "
":ref:`optparse-option-callbacks`."

#: ../../library/optparse.rst:537
msgid "Default values"
msgstr "Значення за замовчуванням"

#: ../../library/optparse.rst:539
msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What happens "
"if those options are never seen?  Since we didn't supply any defaults, they "
"are all set to ``None``.  This is usually fine, but sometimes you want more "
"control.  :mod:`optparse` lets you supply a default value for each "
"destination, which is assigned before the command line is parsed."
msgstr ""
"Усі наведені вище приклади включають встановлення деякої змінної "
"(\"призначення\"), коли відображаються певні параметри командного рядка. Що "
"трапиться, якщо ці варіанти ніколи не побачать? Оскільки ми не вказали "
"жодних значень за замовчуванням, для всіх встановлено значення ``None``. "
"Зазвичай це добре, але іноді потрібно більше контролю. :mod:`optparse` "
"дозволяє вказати значення за умовчанням для кожного пункту призначення, яке "
"призначається перед аналізом командного рядка."

#: ../../library/optparse.rst:546
msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`optparse` to "
"set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""
"Спочатку розглянемо багатослівний/тихий приклад. Якщо ми хочемо, щоб "
":mod:`optparse` встановив для ``verbose`` значення ``True``, якщо не видно "
"``-q``, ми можемо зробити це:"

#: ../../library/optparse.rst:549
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""

#: ../../library/optparse.rst:552
msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr ""
"Оскільки значення за замовчуванням застосовуються до *призначення*, а не до "
"будь-якого конкретного параметра, і ці два параметри мають одне призначення,"
" це точно еквівалентно::"

#: ../../library/optparse.rst:556
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", default=True)"
msgstr ""

#: ../../library/optparse.rst:559
msgid "Consider this::"
msgstr "Розглянемо це::"

#: ../../library/optparse.rst:561
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", default=True)"
msgstr ""

#: ../../library/optparse.rst:564
msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last default "
"value supplied for any particular destination is the one that counts."
msgstr ""
"Знову ж таки, значенням за замовчуванням для ``verbose`` буде ``True``: "
"останнє значення за замовчуванням, надане для будь-якого конкретного "
"призначення, є тим, яке враховується."

#: ../../library/optparse.rst:567
msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` method "
"of OptionParser, which you can call at any time before calling "
":meth:`~OptionParser.parse_args`::"
msgstr ""

#: ../../library/optparse.rst:571
msgid ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:575
msgid ""
"As before, the last value specified for a given option destination is the "
"one that counts.  For clarity, try to use one method or the other of setting"
" default values, not both."
msgstr ""
"Як і раніше, зараховується останнє значення, указане для даного призначення "
"опції. Для ясності спробуйте використовувати один або інший метод "
"встановлення значень за замовчуванням, а не обидва."

#: ../../library/optparse.rst:583
msgid "Generating help"
msgstr "Створення довідки"

#: ../../library/optparse.rst:585
msgid ""
":mod:`optparse`'s ability to generate help and usage text automatically is "
"useful for creating user-friendly command-line interfaces.  All you have to "
"do is supply a :attr:`~Option.help` value for each option, and optionally a "
"short usage message for your whole program.  Here's an OptionParser "
"populated with user-friendly (documented) options::"
msgstr ""
"Здатність :mod:`optparse` автоматично генерувати текст довідки та "
"використання корисна для створення зручних інтерфейсів командного рядка. "
"Все, що вам потрібно зробити, це вказати значення :attr:`~Option.help` для "
"кожного параметра та, за бажанням, коротке повідомлення про використання для"
" всієї програми. Ось OptionParser, заповнений зручними (задокументованими) "
"параметрами::"

#: ../../library/optparse.rst:591
msgid ""
"usage = \"usage: %prog [options] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"make lots of noise [default]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"be vewwy quiet (I'm hunting wabbits)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FILE\", help=\"write output to FILE\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermediate\",\n"
"                  help=\"interaction mode: novice, intermediate, \"\n"
"                       \"or expert [default: %default]\")"
msgstr ""

#: ../../library/optparse.rst:606
msgid ""
"If :mod:`optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the following"
" to standard output:"
msgstr ""
"Якщо :mod:`optparse` зустрічає ``-h`` або ``--help`` у командному рядку, або"
" якщо ви просто викликаєте :meth:`parser.print_help`, він виводить наступне "
"у стандартний вивід :"

#: ../../library/optparse.rst:610
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]"
msgstr ""

#: ../../library/optparse.rst:623
msgid ""
"(If the help output is triggered by a help option, :mod:`optparse` exits "
"after printing the help text.)"
msgstr ""
"(Якщо вихід довідки ініціюється опцією довідки, :mod:`optparse` завершує "
"роботу після друку тексту довідки.)"

#: ../../library/optparse.rst:626
msgid ""
"There's a lot going on here to help :mod:`optparse` generate the best "
"possible help message:"
msgstr ""
"Тут багато чого робиться, щоб допомогти :mod:`optparse` створити найкраще "
"довідкове повідомлення:"

#: ../../library/optparse.rst:629
msgid "the script defines its own usage message::"
msgstr "сценарій визначає власне повідомлення про використання::"

#: ../../library/optparse.rst:631
msgid "usage = \"usage: %prog [options] arg1 arg2\""
msgstr ""

#: ../../library/optparse.rst:633
msgid ""
":mod:`optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""
":mod:`optparse` розширює ``%prog`` у рядку використання до назви поточної "
"програми, тобто ``os.path.basename(sys.argv[0])``. Потім розгорнутий рядок "
"друкується перед детальною довідкою параметрів."

#: ../../library/optparse.rst:637
msgid ""
"If you don't supply a usage string, :mod:`optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""
"Якщо ви не вказали рядок використання, :mod:`optparse` використовує м’яке, "
"але розумне значення за умовчанням: ``\"Використання: %prog [параметри]\"``,"
" що добре, якщо ваш сценарій не приймає жодних позиційних аргументів."

#: ../../library/optparse.rst:641
msgid ""
"every option defines a help string, and doesn't worry about line-"
"wrapping---\\ :mod:`optparse` takes care of wrapping lines and making the "
"help output look good."
msgstr ""
"кожен параметр визначає довідковий рядок і не турбується про перенесення "
"рядків---\\ :mod:`optparse` піклується про обтікання рядків і робить вихід "
"довідки гарним."

#: ../../library/optparse.rst:645
msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr ""

#: ../../library/optparse.rst:648
msgid "-m MODE, --mode=MODE"
msgstr ""

#: ../../library/optparse.rst:650
msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument that "
"the user is expected to supply to ``-m``/``--mode``.  By default, "
":mod:`optparse` converts the destination variable name to uppercase and uses"
" that for the meta-variable.  Sometimes, that's not what you want---for "
"example, the ``--filename`` option explicitly sets ``metavar=\"FILE\"``, "
"resulting in this automatically generated option description::"
msgstr ""

#: ../../library/optparse.rst:657
msgid "-f FILE, --filename=FILE"
msgstr ""

#: ../../library/optparse.rst:659
msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in that "
"there's a connection between the semi-formal syntax ``-f FILE`` and the "
"informal semantic description \"write output to FILE\". This is a simple but"
" effective way to make your help text a lot clearer and more useful for end "
"users."
msgstr ""
"Однак це важливо не тільки для економії місця: написаний вручну текст "
"довідки використовує мета-змінну ``FILE``, щоб зрозуміти користувачеві, що "
"існує зв’язок між напівформальним синтаксисом ``-f FILE`` і неформальний "
"семантичний опис \"записати вихід у ФАЙЛ\". Це простий, але ефективний "
"спосіб зробити ваш текст довідки набагато зрозумілішим і кориснішим для "
"кінцевих користувачів."

#: ../../library/optparse.rst:665
msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`optparse` will replace it with :func:`str` of the option's"
" default value.  If an option has no default value (or the default value is "
"``None``), ``%default`` expands to ``none``."
msgstr ""
"параметри, які мають значення за замовчуванням, можуть містити ``%default`` "
"у рядку довідки ---\\ :mod:`optparse` замінить його на :func:`str` значення "
"параметра за замовчуванням. Якщо параметр не має значення за замовчуванням "
"(або стандартним значенням є ``None``), ``%default`` розширюється до "
"``none``."

#: ../../library/optparse.rst:671
msgid "Grouping Options"
msgstr "Параметри групування"

#: ../../library/optparse.rst:673
msgid ""
"When dealing with many options, it is convenient to group these options for "
"better help output.  An :class:`OptionParser` can contain several option "
"groups, each of which can contain several options."
msgstr ""
"Коли ви маєте справу з багатьма параметрами, зручно згрупувати ці параметри "
"для кращого виведення довідки. :class:`OptionParser` може містити кілька "
"груп опцій, кожна з яких може містити кілька опцій."

#: ../../library/optparse.rst:677
msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "Група опцій отримується за допомогою класу :class:`OptionGroup`:"

#: ../../library/optparse.rst:681 ../../library/optparse.rst:1752
msgid "where"
msgstr "де"

#: ../../library/optparse.rst:683
msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted in "
"to"
msgstr ""
"parser — це екземпляр :class:`OptionParser`, до якого буде вставлено групу"

#: ../../library/optparse.rst:685
msgid "title is the group title"
msgstr "title — назва групи"

#: ../../library/optparse.rst:686
msgid "description, optional, is a long description of the group"
msgstr "description, необов'язковий, це довгий опис групи"

#: ../../library/optparse.rst:688
msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like "
":class:`OptionParser`) and so the :meth:`add_option` method can be used to "
"add an option to the group."
msgstr ""
":class:`OptionGroup` успадковує :class:`OptionContainer` (наприклад, "
":class:`OptionParser`), тому метод :meth:`add_option` можна використовувати "
"для додавання опції до групи."

#: ../../library/optparse.rst:692
msgid ""
"Once all the options are declared, using the :class:`OptionParser` method "
":meth:`add_option_group` the group is added to the previously defined "
"parser."
msgstr ""
"Після оголошення всіх опцій за допомогою методу :class:`OptionParser` "
":meth:`add_option_group` група додається до попередньо визначеного "
"аналізатора."

#: ../../library/optparse.rst:695
msgid ""
"Continuing with the parser defined in the previous section, adding an "
":class:`OptionGroup` to a parser is easy::"
msgstr ""
"Продовжуючи роботу з аналізатором, визначеним у попередньому розділі, додати"
" :class:`OptionGroup` до аналізатора легко:"

#: ../../library/optparse.rst:698
msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)"
msgstr ""

#: ../../library/optparse.rst:704
msgid "This would result in the following help output:"
msgstr "Це призведе до наступного результату довідки:"

#: ../../library/optparse.rst:706
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option."
msgstr ""

#: ../../library/optparse.rst:725
msgid ""
"A bit more complete example might involve using more than one group: still "
"extending the previous example::"
msgstr ""
"Трохи повніший приклад може включати використання кількох груп: все ще "
"розширюючи попередній приклад::"

#: ../../library/optparse.rst:728
msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Debug Options\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Print debug information\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Print all SQL statements executed\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Print every action done\")\n"
"parser.add_option_group(group)"
msgstr ""

#: ../../library/optparse.rst:742
msgid "that results in the following output:"
msgstr "що призводить до наступного результату:"

#: ../../library/optparse.rst:744
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert\n"
"                        [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option.\n"
"\n"
"  Debug Options:\n"
"    -d, --debug         Print debug information\n"
"    -s, --sql           Print all SQL statements executed\n"
"    -e                  Print every action done"
msgstr ""

#: ../../library/optparse.rst:768
msgid ""
"Another interesting method, in particular when working programmatically with"
" option groups is:"
msgstr ""
"Ще один цікавий метод, зокрема під час програмної роботи з групами "
"параметрів:"

#: ../../library/optparse.rst:773
msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such "
":class:`OptionGroup`, return ``None``."
msgstr ""
"Повертає :class:`OptionGroup`, до якої належить короткий або довгий рядок "
"параметрів *opt_str* (наприклад, ``'-o'`` або ``'--option'``). Якщо такої "
":class:`OptionGroup` немає, поверніть ``None``."

#: ../../library/optparse.rst:780
msgid "Printing a version string"
msgstr "Друк рядка версії"

#: ../../library/optparse.rst:782
msgid ""
"Similar to the brief usage string, :mod:`optparse` can also print a version "
"string for your program.  You have to supply the string as the ``version`` "
"argument to OptionParser::"
msgstr ""
"Подібно до короткого рядка використання, :mod:`optparse` також може "
"надрукувати рядок версії вашої програми. Ви повинні надати рядок як аргумент"
" ``version`` для OptionParser::"

#: ../../library/optparse.rst:786
msgid "parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"
msgstr ""

#: ../../library/optparse.rst:788
msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, "
":mod:`optparse` automatically adds a ``--version`` option to your parser. If"
" it encounters this option on the command line, it expands your ``version`` "
"string (by replacing ``%prog``), prints it to stdout, and exits."
msgstr ""
"``%prog`` розгортається так само, як і в ``usage``. Окрім цього, ``версія`` "
"може містити все, що завгодно. Коли ви вказуєте його, :mod:`optparse` "
"автоматично додає опцію ``--version`` до вашого аналізатора. Якщо він "
"зустрічає цей параметр у командному рядку, він розгортає ваш рядок "
"``version`` (шляхом заміни ``%prog``), друкує його в stdout і завершує "
"роботу."

#: ../../library/optparse.rst:794
msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "Наприклад, якщо ваш скрипт називається ``/usr/bin/foo``:"

#: ../../library/optparse.rst:796
msgid ""
"$ /usr/bin/foo --version\n"
"foo 1.0"
msgstr ""

#: ../../library/optparse.rst:801
msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr ""
"Наступні два методи можна використати для друку та отримання рядка "
"``version``:"

#: ../../library/optparse.rst:805
msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"Вивести повідомлення про версію для поточної програми (``self.version``) у "
"*файл* (стандартний вивід за замовчуванням). Як і у випадку з "
":meth:`print_usage`, будь-яке входження ``%prog`` у ``self.version`` "
"замінюється назвою поточної програми. Нічого не робить, якщо "
"``self.version`` порожній або невизначений."

#: ../../library/optparse.rst:812
msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr ""
"Те саме, що :meth:`print_version`, але повертає рядок версії замість її "
"друку."

#: ../../library/optparse.rst:819
msgid "How :mod:`optparse` handles errors"
msgstr "Як :mod:`optparse` обробляє помилки"

#: ../../library/optparse.rst:821
msgid ""
"There are two broad classes of errors that :mod:`optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  These "
"are dealt with in the usual way: raise an exception (either "
":exc:`optparse.OptionError` or :exc:`TypeError`) and let the program crash."
msgstr ""
"Є два широких класи помилок, про які :mod:`optparse` має турбуватися: "
"помилки програміста та помилки користувача. Помилки програміста зазвичай є "
"помилковими викликами :func:`OptionParser.add_option`, напр. недійсні рядки "
"опцій, невідомі атрибути опцій, відсутні атрибути опцій тощо. З цими "
"справляються звичайним способом: викликають виняток (або "
":exc:`optparse.OptionError` або :exc:`TypeError`) і дозволяють програмі "
"аварійно завершувати роботу."

#: ../../library/optparse.rst:828
msgid ""
"Handling user errors is much more important, since they are guaranteed to "
"happen no matter how stable your code is.  :mod:`optparse` can automatically"
" detect some user errors, such as bad option arguments (passing ``-n 4x`` "
"where ``-n`` takes an integer argument), missing arguments (``-n`` at the "
"end of the command line, where ``-n`` takes an argument of any type).  Also,"
" you can call :func:`OptionParser.error` to signal an application-defined "
"error condition::"
msgstr ""
"Обробка помилок користувача є набагато важливішою, оскільки вони гарантовано"
" траплятимуться незалежно від того, наскільки стабільним є ваш код. "
":mod:`optparse` може автоматично виявляти деякі помилки користувача, такі як"
" неправильні аргументи параметрів (передача ``-n 4x``, де ``-n`` приймає "
"цілочисельний аргумент), відсутні аргументи (``-n`` у кінець командного "
"рядка, де ``-n`` приймає аргумент будь-якого типу). Крім того, ви можете "
"викликати :func:`OptionParser.error`, щоб повідомити про помилку, визначену "
"програмою:"

#: ../../library/optparse.rst:836
msgid ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"options -a and -b are mutually exclusive\")"
msgstr ""

#: ../../library/optparse.rst:841
msgid ""
"In either case, :mod:`optparse` handles the error the same way: it prints "
"the program's usage message and an error message to standard error and exits"
" with error status 2."
msgstr ""
"У будь-якому випадку :mod:`optparse` обробляє помилку однаково: він друкує "
"повідомлення про використання програми та повідомлення про помилку до "
"стандартної помилки та виходить зі статусом помилки 2."

#: ../../library/optparse.rst:845
msgid ""
"Consider the first example above, where the user passes ``4x`` to an option "
"that takes an integer:"
msgstr ""
"Розглянемо перший приклад вище, де користувач передає ``4x`` опції, яка "
"приймає ціле число:"

#: ../../library/optparse.rst:848
msgid ""
"$ /usr/bin/foo -n 4x\n"
"Usage: foo [options]\n"
"\n"
"foo: error: option -n: invalid integer value: '4x'"
msgstr ""

#: ../../library/optparse.rst:855
msgid "Or, where the user fails to pass a value at all:"
msgstr "Або, коли користувач взагалі не може передати значення:"

#: ../../library/optparse.rst:857
msgid ""
"$ /usr/bin/foo -n\n"
"Usage: foo [options]\n"
"\n"
"foo: error: -n option requires an argument"
msgstr ""

#: ../../library/optparse.rst:864
msgid ""
":mod:`optparse`\\ -generated error messages take care always to mention the "
"option involved in the error; be sure to do the same when calling "
":func:`OptionParser.error` from your application code."
msgstr ""
":mod:`optparse`\\ -згенеровані повідомлення про помилку завжди вказують "
"опцію, пов’язану з помилкою; обов’язково зробіть те саме під час виклику "
":func:`OptionParser.error` із коду програми."

#: ../../library/optparse.rst:868
msgid ""
"If :mod:`optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its "
":meth:`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""
"Якщо стандартна поведінка обробки помилок :mod:`optparse` не відповідає "
"вашим потребам, вам потрібно створити підклас OptionParser і перевизначити "
"його :meth:`~OptionParser.exit` та/або :meth:`~OptionParser.error` методи."

#: ../../library/optparse.rst:876
msgid "Putting it all together"
msgstr "Зібравши все разом"

#: ../../library/optparse.rst:878
msgid "Here's what :mod:`optparse`\\ -based scripts usually look like::"
msgstr "Ось як зазвичай виглядають сценарії на основі :mod:`optparse`\\:"

#: ../../library/optparse.rst:880
msgid ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"usage: %prog [options] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"read data from FILENAME\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"incorrect number of arguments\")\n"
"    if options.verbose:\n"
"        print(\"reading %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""

#: ../../library/optparse.rst:906
msgid "Reference Guide"
msgstr "Довідковий посібник"

#: ../../library/optparse.rst:912
msgid "Creating the parser"
msgstr "Створення аналізатора"

#: ../../library/optparse.rst:914
msgid ""
"The first step in using :mod:`optparse` is to create an OptionParser "
"instance."
msgstr ""
"Першим кроком у використанні :mod:`optparse` є створення екземпляра "
"OptionParser."

#: ../../library/optparse.rst:918
msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are "
"declared."
msgstr ""
"Конструктор OptionParser не має обов’язкових аргументів, але має декілька "
"необов’язкових ключових аргументів. Ви завжди повинні передавати їх як "
"аргументи ключового слова, тобто не покладайтеся на порядок, у якому "
"оголошено аргументи."

#: ../../library/optparse.rst:922
msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``використання`` (за замовчуванням: ``\"%prog [параметри]\"``)"

#: ../../library/optparse.rst:923
msgid ""
"The usage summary to print when your program is run incorrectly or with a "
"help option.  When :mod:`optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you passed"
" that keyword argument).  To suppress a usage message, pass the special "
"value :const:`optparse.SUPPRESS_USAGE`."
msgstr ""

#: ../../library/optparse.rst:929
msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list`` (за замовчуванням: ``[]``)"

#: ../../library/optparse.rst:930
msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` (a "
"class attribute that may be set by OptionParser subclasses), but before any "
"version or help options. Deprecated; use :meth:`add_option` after creating "
"the parser instead."
msgstr ""
"Список об’єктів Option для заповнення аналізатора. Опції в ``option_list`` "
"додаються після будь-яких опцій в ``standard_option_list`` (атрибут класу, "
"який може бути встановлений підкласами OptionParser), але перед будь-якою "
"версією або опціями довідки. Застаріле; замість цього використовуйте "
":meth:`add_option` після створення аналізатора."

#: ../../library/optparse.rst:936
msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class`` (за замовчуванням: optparse.Option)"

#: ../../library/optparse.rst:937
msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr ""
"Клас для використання під час додавання параметрів до аналізатора в "
":meth:`add_option`."

#: ../../library/optparse.rst:939
msgid "``version`` (default: ``None``)"
msgstr "``version`` (за замовчуванням: ``None``)"

#: ../../library/optparse.rst:940
msgid ""
"A version string to print when the user supplies a version option. If you "
"supply a true value for ``version``, :mod:`optparse` automatically adds a "
"version option with the single option string ``--version``.  The substring "
"``%prog`` is expanded the same as for ``usage``."
msgstr ""
"Рядок версії для друку, коли користувач вказує параметр версії. Якщо ви "
"вказуєте справжнє значення для ``version``, :mod:`optparse` автоматично "
"додає опцію версії з єдиним рядком опції ``--version``. Підрядок ``%prog`` "
"розгортається так само, як і ``usage``."

#: ../../library/optparse.rst:945
msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``conflict_handler`` (за замовчуванням: ``\"помилка\"``)"

#: ../../library/optparse.rst:946
msgid ""
"Specifies what to do when options with conflicting option strings are added "
"to the parser; see section :ref:`optparse-conflicts-between-options`."
msgstr ""
"Вказує, що робити, коли параметри з конфліктуючими рядками параметрів "
"додаються до аналізатора; див. розділ :ref:`optparse-conflicts-between-"
"options`."

#: ../../library/optparse.rst:950
msgid "``description`` (default: ``None``)"
msgstr "``опис`` (за замовчуванням: ``None``)"

#: ../../library/optparse.rst:951
msgid ""
"A paragraph of text giving a brief overview of your program. :mod:`optparse`"
" reformats this paragraph to fit the current terminal width and prints it "
"when the user requests help (after ``usage``, but before the list of "
"options)."
msgstr ""
"Абзац тексту, що дає короткий огляд вашої програми. :mod:`optparse` "
"переформатує цей абзац відповідно до поточної ширини терміналу та друкує "
"його, коли користувач запитує допомогу (після ``використання``, але перед "
"списком параметрів)."

#: ../../library/optparse.rst:956
msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr ""
"``formatter`` (за замовчуванням: новий :class:`IndentedHelpFormatter`)"

#: ../../library/optparse.rst:957
msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help "
"text.  :mod:`optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""
"Екземпляр optparse.HelpFormatter, який використовуватиметься для друку "
"тексту довідки. :mod:`optparse` надає два конкретних класи для цієї мети: "
"IndentedHelpFormatter і TitledHelpFormatter."

#: ../../library/optparse.rst:961
msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option`` (за замовчуванням: ``True``)"

#: ../../library/optparse.rst:962
msgid ""
"If true, :mod:`optparse` will add a help option (with option strings ``-h`` "
"and ``--help``) to the parser."
msgstr ""
"Якщо істина, :mod:`optparse` додасть параметр довідки (із рядками параметрів"
" ``-h`` і ``--help``) до аналізатора."

#: ../../library/optparse.rst:965
msgid "``prog``"
msgstr "``програма``"

#: ../../library/optparse.rst:966
msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"Рядок для використання під час розширення ``%prog`` у ``usage`` і "
"``version`` замість ``os.path.basename(sys.argv[0])``."

#: ../../library/optparse.rst:969
msgid "``epilog`` (default: ``None``)"
msgstr "``епілог`` (за замовчуванням: ``None``)"

#: ../../library/optparse.rst:970
msgid "A paragraph of help text to print after the option help."
msgstr "Абзац тексту довідки для друку після довідки параметра."

#: ../../library/optparse.rst:975
msgid "Populating the parser"
msgstr "Заповнення аналізатора"

#: ../../library/optparse.rst:977
msgid ""
"There are several ways to populate the parser with options.  The preferred "
"way is by using :meth:`OptionParser.add_option`, as shown in section "
":ref:`optparse-tutorial`.  :meth:`add_option` can be called in one of two "
"ways:"
msgstr ""
"Є кілька способів заповнити аналізатор параметрами. Кращим способом є "
"використання :meth:`OptionParser.add_option`, як показано в розділі "
":ref:`optparse-tutorial`. :meth:`add_option` можна викликати одним із двох "
"способів:"

#: ../../library/optparse.rst:981
msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr "передати йому екземпляр Option (як повертає :func:`make_option`)"

#: ../../library/optparse.rst:983
msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and it "
"will create the Option instance for you"
msgstr ""
"передайте йому будь-яку комбінацію позиційних і ключових аргументів, які "
"прийнятні для :func:`make_option` (тобто для конструктора Option), і він "
"створить екземпляр Option для вас"

#: ../../library/optparse.rst:987
msgid ""
"The other alternative is to pass a list of pre-constructed Option instances "
"to the OptionParser constructor, as in::"
msgstr ""
"Іншою альтернативою є передача списку попередньо сконструйованих екземплярів"
" Option конструктору OptionParser, як у::"

#: ../../library/optparse.rst:990
msgid ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""

#: ../../library/optparse.rst:998
msgid ""
"(:func:`make_option` is a factory function for creating Option instances; "
"currently it is an alias for the Option constructor.  A future version of "
":mod:`optparse` may split Option into several classes, and "
":func:`make_option` will pick the right class to instantiate.  Do not "
"instantiate Option directly.)"
msgstr ""
"(:func:`make_option` є фабричною функцією для створення екземплярів Option; "
"наразі це псевдонім для конструктора Option. Майбутня версія :mod:`optparse`"
" може розділити Option на кілька класів і :func:`make_option` вибере "
"правильний клас для створення екземпляра. Не створюйте екземпляр Option "
"безпосередньо.)"

#: ../../library/optparse.rst:1007
msgid "Defining options"
msgstr "Визначення варіантів"

#: ../../library/optparse.rst:1009
msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short or"
" long option strings, but you must specify at least one overall option "
"string."
msgstr ""
"Кожен екземпляр Option представляє набір синонімічних рядків параметрів "
"командного рядка, напр. ``-f`` і ``--file``. Ви можете вказати будь-яку "
"кількість коротких або довгих рядків параметрів, але ви повинні вказати "
"принаймні один загальний рядок параметрів."

#: ../../library/optparse.rst:1013
msgid ""
"The canonical way to create an :class:`Option` instance is with the "
":meth:`add_option` method of :class:`OptionParser`."
msgstr ""
"Канонічним способом створення екземпляра :class:`Option` є метод "
":meth:`add_option` :class:`OptionParser`."

#: ../../library/optparse.rst:1019
msgid "To define an option with only a short option string::"
msgstr "Щоб визначити опцію лише за допомогою короткого рядка опції:"

#: ../../library/optparse.rst:1021
msgid "parser.add_option(\"-f\", attr=value, ...)"
msgstr ""

#: ../../library/optparse.rst:1023
msgid "And to define an option with only a long option string::"
msgstr "І щоб визначити опцію лише з довгим рядком опції::"

#: ../../library/optparse.rst:1025
msgid "parser.add_option(\"--foo\", attr=value, ...)"
msgstr ""

#: ../../library/optparse.rst:1027
msgid ""
"The keyword arguments define attributes of the new Option object.  The most "
"important option attribute is :attr:`~Option.action`, and it largely "
"determines which other attributes are relevant or required.  If you pass "
"irrelevant option attributes, or fail to pass required ones, :mod:`optparse`"
" raises an :exc:`OptionError` exception explaining your mistake."
msgstr ""
"Ключові аргументи визначають атрибути нового об’єкта Option. Найважливішим "
"атрибутом параметра є :attr:`~Option.action`, і він значною мірою визначає, "
"які інші атрибути є доречними або необхідними. Якщо ви передаєте "
"нерелевантні атрибути параметрів або не передаєте необхідні, :mod:`optparse`"
" викликає виняток :exc:`OptionError`, пояснюючи вашу помилку."

#: ../../library/optparse.rst:1033
msgid ""
"An option's *action* determines what :mod:`optparse` does when it encounters"
" this option on the command-line.  The standard option actions hard-coded "
"into :mod:`optparse` are:"
msgstr ""
"*Дія* параметра визначає, що робить :mod:`optparse`, коли він зустрічає цей "
"параметр у командному рядку. Стандартні дії параметрів, жорстко закодовані в"
" :mod:`optparse`:"

#: ../../library/optparse.rst:1037
msgid "``\"store\"``"
msgstr "``\"магазин\"``"

#: ../../library/optparse.rst:1038
msgid "store this option's argument (default)"
msgstr "зберегти аргумент цього параметра (за замовчуванням)"

#: ../../library/optparse.rst:1043
msgid "``\"store_true\"``"
msgstr "``\"store_true\"``"

#: ../../library/optparse.rst:1044
msgid "store ``True``"
msgstr "зберігати ``Правда``"

#: ../../library/optparse.rst:1046
msgid "``\"store_false\"``"
msgstr "``\"store_false\"``"

#: ../../library/optparse.rst:1047
msgid "store ``False``"
msgstr "зберігати ``False``"

#: ../../library/optparse.rst:1052
msgid "``\"append_const\"``"
msgstr "``\"append_const\"``"

#: ../../library/optparse.rst:1053
msgid "append a constant value to a list, pre-set via :attr:`Option.const`"
msgstr ""

#: ../../library/optparse.rst:1061 ../../library/optparse.rst:1356
msgid "``\"help\"``"
msgstr "``\"допомога\"``"

#: ../../library/optparse.rst:1062
msgid ""
"print a usage message including all options and the documentation for them"
msgstr ""
"роздрукувати повідомлення про використання, включно з усіма параметрами та "
"документацією до них"

#: ../../library/optparse.rst:1064
msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest` "
"option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"(Якщо ви не вказали дію, за замовчуванням буде ``\"store\"``. Для цієї дії "
"ви також можете вказати атрибути параметрів :attr:`~Option.type` і "
":attr:`~Option.dest` див. :ref:`optparse-standard-option-actions`.)"

#: ../../library/optparse.rst:1068
msgid ""
"As you can see, most actions involve storing or updating a value somewhere. "
":mod:`optparse` always creates a special object for this, conventionally "
"called ``options``, which is an instance of :class:`optparse.Values`."
msgstr ""

#: ../../library/optparse.rst:1074
msgid ""
"An object holding parsed argument names and values as attributes. Normally "
"created by calling when calling :meth:`OptionParser.parse_args`, and can be "
"overridden by a custom subclass passed to the *values* argument of "
":meth:`OptionParser.parse_args` (as described in :ref:`optparse-parsing-"
"arguments`)."
msgstr ""

#: ../../library/optparse.rst:1079
msgid ""
"Option arguments (and various other values) are stored as attributes of this"
" object, according to the :attr:`~Option.dest` (destination) option "
"attribute."
msgstr ""

#: ../../library/optparse.rst:1083
msgid "For example, when you call ::"
msgstr "Наприклад, коли ви дзвоните ::"

#: ../../library/optparse.rst:1085
msgid "parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:1087
msgid ""
"one of the first things :mod:`optparse` does is create the ``options`` "
"object::"
msgstr ""
"одна з перших речей, які робить :mod:`optparse`, це створює об’єкт "
"``options``::"

#: ../../library/optparse.rst:1089
msgid "options = Values()"
msgstr ""

#: ../../library/optparse.rst:1091
msgid "If one of the options in this parser is defined with ::"
msgstr ""
"Якщо один із параметрів цього синтаксичного аналізатора визначено за "
"допомогою ::"

#: ../../library/optparse.rst:1093
msgid ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"
msgstr ""

#: ../../library/optparse.rst:1095
msgid "and the command-line being parsed includes any of the following::"
msgstr "а командний рядок, що аналізується, містить будь-яке з наступного:"

#: ../../library/optparse.rst:1097
msgid ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--file foo"
msgstr ""

#: ../../library/optparse.rst:1102
msgid ""
"then :mod:`optparse`, on seeing this option, will do the equivalent of ::"
msgstr "тоді :mod:`optparse`, побачивши цю опцію, зробить еквівалент::"

#: ../../library/optparse.rst:1104
msgid "options.filename = \"foo\""
msgstr ""

#: ../../library/optparse.rst:1106
msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action` is"
" the only one that makes sense for *all* options."
msgstr ""
"Атрибути :attr:`~Option.type` і :attr:`~Option.dest` майже такі ж важливі, "
"як і :attr:`~Option.action`, але :attr:`~Option.action` є єдиним такий, який"
" має сенс для *всіх* варіантів."

#: ../../library/optparse.rst:1114
msgid "Option attributes"
msgstr "Атрибути варіантів"

#: ../../library/optparse.rst:1118
msgid ""
"A single command line argument, with various attributes passed by keyword to"
" the constructor. Normally created with :meth:`OptionParser.add_option` "
"rather than directly, and can be overridden by a custom class via the "
"*option_class* argument to :class:`OptionParser`."
msgstr ""

#: ../../library/optparse.rst:1124
msgid ""
"The following option attributes may be passed as keyword arguments to "
":meth:`OptionParser.add_option`.  If you pass an option attribute that is "
"not relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`optparse` raises :exc:`OptionError`."
msgstr ""
"Наступні атрибути параметрів можна передати як ключові аргументи до "
":meth:`OptionParser.add_option`. Якщо ви передаєте атрибут опції, який не "
"має відношення до певної опції, або не передаєте потрібний атрибут опції, "
":mod:`optparse` викликає :exc:`OptionError`."

#: ../../library/optparse.rst:1131
msgid "(default: ``\"store\"``)"
msgstr "(за замовчуванням: ``\"магазин\"``)"

#: ../../library/optparse.rst:1133
msgid ""
"Determines :mod:`optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""
"Визначає поведінку :mod:`optparse`, коли цей параметр відображається в "
"командному рядку; доступні параметри задокументовані :ref:`тут <optparse-"
"standard-option-actions>`."

#: ../../library/optparse.rst:1139
msgid "(default: ``\"string\"``)"
msgstr "(за замовчуванням: ``\"рядок\"``)"

#: ../../library/optparse.rst:1141
msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here "
"<optparse-standard-option-types>`."
msgstr ""
"Тип аргументу, очікуваний цією опцією (наприклад, ``\"string\"`` або "
"``\"int\"``); доступні типи опцій задокументовані :ref:`тут <optparse-"
"standard-option-types>`."

#: ../../library/optparse.rst:1147 ../../library/optparse.rst:1197
msgid "(default: derived from option strings)"
msgstr "(за замовчуванням: отримано з рядків параметрів)"

#: ../../library/optparse.rst:1149
msgid ""
"If the option's action implies writing or modifying a value somewhere, this "
"tells :mod:`optparse` where to write it: :attr:`~Option.dest` names an "
"attribute of the ``options`` object that :mod:`optparse` builds as it parses"
" the command line."
msgstr ""
"Якщо дія опції передбачає запис або зміну значення десь, це вказує "
":mod:`optparse`, де його писати: :attr:`~Option.dest` називає атрибут "
"об’єкта ``options``, який :mod:`optparse` збирається, коли аналізує "
"командний рядок."

#: ../../library/optparse.rst:1156
msgid ""
"The value to use for this option's destination if the option is not seen on "
"the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr ""
"Значення для призначення цього параметра, якщо параметр не відображається в "
"командному рядку. Дивіться також :meth:`OptionParser.set_defaults`."

#: ../../library/optparse.rst:1161
msgid "(default: 1)"
msgstr "(за замовчуванням: 1)"

#: ../../library/optparse.rst:1163
msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when this"
" option is seen.  If > 1, :mod:`optparse` will store a tuple of values to "
":attr:`~Option.dest`."
msgstr ""
"Скільки аргументів типу :attr:`~Option.type` має споживатися, коли "
"відображається цей параметр. Якщо > 1, :mod:`optparse` зберігатиме кортеж "
"значень у :attr:`~Option.dest`."

#: ../../library/optparse.rst:1169
msgid "For actions that store a constant value, the constant value to store."
msgstr ""
"Для дій, які зберігають постійне значення, постійне значення для збереження."

#: ../../library/optparse.rst:1173
msgid ""
"For options of type ``\"choice\"``, the list of strings the user may choose "
"from."
msgstr ""
"Для параметрів типу ``\"вибір\"``, список рядків, з яких користувач може "
"вибрати."

#: ../../library/optparse.rst:1178
msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail on "
"the arguments passed to the callable."
msgstr ""
"Для параметрів із дією ``\"callback\"``, виклик якого потрібно викликати, "
"коли цей параметр видно. Дивіться розділ :ref:`optparse-option-callbacks` "
"для детальної інформації про аргументи, які передаються викликаному."

#: ../../library/optparse.rst:1185
msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after "
"the four standard callback arguments."
msgstr ""
"Додаткові позиційні та ключові аргументи для передачі в ``callback`` після "
"чотирьох стандартних аргументів зворотного виклику."

#: ../../library/optparse.rst:1190
msgid ""
"Help text to print for this option when listing all available options after "
"the user supplies a :attr:`~Option.help` option (such as ``--help``).  If no"
" help text is supplied, the option will be listed without help text.  To "
"hide this option, use the special value :const:`optparse.SUPPRESS_HELP`."
msgstr ""

#: ../../library/optparse.rst:1199
msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr ""
"Заміна аргументу(ів) опції для використання під час друку довідкового "
"тексту. Перегляньте розділ :ref:`optparse-tutorial` для прикладу."

#: ../../library/optparse.rst:1206
msgid "Standard option actions"
msgstr "Стандартні опційні дії"

#: ../../library/optparse.rst:1208
msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you may "
"specify to guide :mod:`optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""
"Усі різні опціональні дії мають дещо різні вимоги та наслідки. Більшість дій"
" мають кілька відповідних атрибутів параметрів, які ви можете вказати, щоб "
"керувати поведінкою :mod:`optparse`; деякі з них мають обов’язкові атрибути,"
" які ви повинні вказати для будь-якої опції, що використовує цю дію."

#: ../../library/optparse.rst:1213
msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"магазин\"`` [релевантний: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1216
msgid ""
"The option must be followed by an argument, which is converted to a value "
"according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If "
":attr:`~Option.nargs` > 1, multiple arguments will be consumed from the "
"command line; all will be converted according to :attr:`~Option.type` and "
"stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-standard-"
"option-types` section."
msgstr ""
"За параметром має слідувати аргумент, який перетворюється на значення "
"відповідно до :attr:`~Option.type` і зберігається в :attr:`~Option.dest`. "
"Якщо :attr:`~Option.nargs` > 1, з командного рядка буде використано кілька "
"аргументів; усе буде перетворено відповідно до :attr:`~Option.type` і "
"збережено в :attr:`~Option.dest` як кортеж. Перегляньте розділ "
":ref:`optparse-standard-option-types`."

#: ../../library/optparse.rst:1223
msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr ""
"Якщо надано :attr:`~Option.choices` (список або кортеж рядків), типом за "
"замовчуванням є ``\"choice\"``."

#: ../../library/optparse.rst:1226
msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr ""
"Якщо :attr:`~Option.type` не вказано, за замовчуванням буде ``\"string\"``."

#: ../../library/optparse.rst:1228
msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` implies "
"``foo_bar``). If there are no long option strings, :mod:`optparse` derives a"
" destination from the first short option string (e.g., ``-f`` implies "
"``f``)."
msgstr ""
"Якщо :attr:`~Option.dest` не надано, :mod:`optparse` отримує призначення з "
"першого довгого рядка параметрів (наприклад, ``--foo-bar`` передбачає "
"``foo_bar``). Якщо довгих рядків параметрів немає, :mod:`optparse` отримує "
"адресат із першого короткого рядка параметрів (наприклад, ``-f`` означає "
"``f``)."

#: ../../library/optparse.rst:1233 ../../library/optparse.rst:1253
#: ../../library/optparse.rst:1275 ../../library/optparse.rst:1293
#: ../../library/optparse.rst:1332 ../../library/optparse.rst:1370
msgid "Example::"
msgstr "Приклад::"

#: ../../library/optparse.rst:1235
msgid ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"
msgstr ""

#: ../../library/optparse.rst:1238
msgid "As it parses the command line ::"
msgstr "Під час аналізу командного рядка ::"

#: ../../library/optparse.rst:1240
msgid "-f foo.txt -p 1 -3.5 4 -fbar.txt"
msgstr ""

#: ../../library/optparse.rst:1242
msgid ":mod:`optparse` will set ::"
msgstr ":mod:`optparse` встановить ::"

#: ../../library/optparse.rst:1244
msgid ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""
msgstr ""

#: ../../library/optparse.rst:1248
msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: "
":attr:`~Option.dest`]"
msgstr ""
"``\"store_const\"`` [потрібно: :attr:`~Option.const`; релевантний: "
":attr:`~Option.dest`]"

#: ../../library/optparse.rst:1251
msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "Значення :attr:`~Option.const` зберігається в :attr:`~Option.dest`."

#: ../../library/optparse.rst:1255
msgid ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"
msgstr ""

#: ../../library/optparse.rst:1262
msgid "If ``--noisy`` is seen, :mod:`optparse` will set  ::"
msgstr "Якщо відображається ``--noisy``, :mod:`optparse` встановить ::"

#: ../../library/optparse.rst:1264
msgid "options.verbose = 2"
msgstr ""

#: ../../library/optparse.rst:1266
msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [релевантний: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1268
msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to "
":attr:`~Option.dest`."
msgstr ""
"Особливий випадок ``\"store_const\"``, який зберігає ``True`` у "
":attr:`~Option.dest`."

#: ../../library/optparse.rst:1271
msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [релевантний: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1273
msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "Подібно до ``\"store_true\"``, але зберігає ``False``."

#: ../../library/optparse.rst:1277
msgid ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"
msgstr ""

#: ../../library/optparse.rst:1280
msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"append\"`` [релевантні: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1283
msgid ""
"The option must be followed by an argument, which is appended to the list in"
" :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` is "
"supplied, an empty list is automatically created when :mod:`optparse` first "
"encounters this option on the command-line.  If :attr:`~Option.nargs` > 1, "
"multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs`"
" is appended to :attr:`~Option.dest`."
msgstr ""
"За параметром має слідувати аргумент, який додається до списку в "
":attr:`~Option.dest`. Якщо значення за замовчуванням для "
":attr:`~Option.dest` не вказано, порожній список створюється автоматично, "
"коли :mod:`optparse` вперше зустрічає цей параметр у командному рядку. Якщо "
":attr:`~Option.nargs` > 1, споживаються кілька аргументів, а кортеж довжини "
":attr:`~Option.nargs` додається до :attr:`~Option.dest`."

#: ../../library/optparse.rst:1290
msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same "
"as for the ``\"store\"`` action."
msgstr ""
"Значення за замовчуванням для :attr:`~Option.type` і :attr:`~Option.dest` "
"такі самі, як і для дії ``\"store\"``."

#: ../../library/optparse.rst:1295
msgid "parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"
msgstr ""

#: ../../library/optparse.rst:1297
msgid ""
"If ``-t3`` is seen on the command-line, :mod:`optparse` does the equivalent "
"of::"
msgstr ""
"Якщо в командному рядку відображається ``-t3``, :mod:`optparse` виконує "
"еквівалент:"

#: ../../library/optparse.rst:1300
msgid ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"
msgstr ""

#: ../../library/optparse.rst:1303
msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "Якщо трохи пізніше з’явиться ``--tracks=4``, це так:"

#: ../../library/optparse.rst:1305
msgid "options.tracks.append(int(\"4\"))"
msgstr ""

#: ../../library/optparse.rst:1307
msgid ""
"The ``append`` action calls the ``append`` method on the current value of "
"the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty, "
"the default elements will be present in the parsed value for the option, "
"with any values from the command line appended after those default values::"
msgstr ""
"Дія ``append`` викликає метод ``append`` для поточного значення опції. Це "
"означає, що будь-яке вказане значення за замовчуванням повинно мати метод "
"``додавання``. Це також означає, що якщо значення за замовчуванням не є "
"порожнім, елементи за замовчуванням будуть присутні в розібраному значенні "
"для параметра, а будь-які значення з командного рядка будуть додані після "
"цих значень за замовчуванням::"

#: ../../library/optparse.rst:1313
msgid ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"
msgstr ""

#: ../../library/optparse.rst:1318
msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: "
":attr:`~Option.dest`]"
msgstr ""
"``\"append_const\"`` [потрібно: :attr:`~Option.const`; релевантний: "
":attr:`~Option.dest`]"

#: ../../library/optparse.rst:1321
msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended to"
" :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` defaults"
" to ``None``, and an empty list is automatically created the first time the "
"option is encountered."
msgstr ""
"Як ``\"store_const\"``, але значення :attr:`~Option.const` додається до "
":attr:`~Option.dest`; як і у випадку з ``\"append\"``, :attr:`~Option.dest` "
"за замовчуванням має значення ``None``, і порожній список автоматично "
"створюється, коли вперше зустрічається опція."

#: ../../library/optparse.rst:1326
msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [relevant: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1328
msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default value "
"is supplied, :attr:`~Option.dest` is set to zero before being incremented "
"the first time."
msgstr ""
"Збільшити ціле число, що зберігається в :attr:`~Option.dest`. Якщо значення "
"за замовчуванням не вказано, :attr:`~Option.dest` встановлюється на нуль "
"перед першим збільшенням."

#: ../../library/optparse.rst:1334
msgid "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"
msgstr ""

#: ../../library/optparse.rst:1336
msgid ""
"The first time ``-v`` is seen on the command line, :mod:`optparse` does the "
"equivalent of::"
msgstr ""
"Коли ``-v`` з'являється в командному рядку вперше, :mod:`optparse` виконує "
"еквівалент:"

#: ../../library/optparse.rst:1339
msgid ""
"options.verbosity = 0\n"
"options.verbosity += 1"
msgstr ""

#: ../../library/optparse.rst:1342
msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "Кожне наступне повторення ``-v`` призводить до:"

#: ../../library/optparse.rst:1344
msgid "options.verbosity += 1"
msgstr ""

#: ../../library/optparse.rst:1346
msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: "
":attr:`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, "
":attr:`~Option.callback_kwargs`]"
msgstr ""
"``\"callback\"`` [потрібно: :attr:`~Option.callback`; релевантні: "
":attr:`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, "
":attr:`~Option.callback_kwargs`]"

#: ../../library/optparse.rst:1350
msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called as "
"::"
msgstr ""
"Виклик функції, визначеної :attr:`~Option.callback`, яка викликається як ::"

#: ../../library/optparse.rst:1352 ../../library/optparse.rst:1750
msgid "func(option, opt_str, value, parser, *args, **kwargs)"
msgstr ""

#: ../../library/optparse.rst:1354
msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr ""
"Дивіться розділ :ref:`optparse-option-callbacks` для більш детальної "
"інформації."

#: ../../library/optparse.rst:1358
msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed to"
" OptionParser's constructor and the :attr:`~Option.help` string passed to "
"every option."
msgstr ""
"Друкує повне довідкове повідомлення для всіх параметрів у поточному "
"аналізаторі параметрів. Повідомлення довідки складається з рядка ``usage``, "
"переданого конструктору OptionParser, і рядка :attr:`~Option.help`, "
"переданого кожному параметру."

#: ../../library/optparse.rst:1363
msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will still "
"be listed in the help message.  To omit an option entirely, use the special "
"value :const:`optparse.SUPPRESS_HELP`."
msgstr ""

#: ../../library/optparse.rst:1367
msgid ""
":mod:`optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""
":mod:`optparse` автоматично додає опцію :attr:`~Option.help` до всіх "
"аналізаторів опцій, тому зазвичай вам не потрібно її створювати."

#: ../../library/optparse.rst:1372
msgid ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# usually, a help option is added automatically, but that can\n"
"# be suppressed using the add_help_option argument\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Be moderately verbose\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Input file to read data from\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"
msgstr ""

#: ../../library/optparse.rst:1385
msgid ""
"If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line, it "
"will print something like the following help message to stdout (assuming "
"``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""
"Якщо :mod:`optparse` бачить або ``-h``, або ``--help`` у командному рядку, "
"він надрукує щось на кшталт наступного довідкового повідомлення до stdout "
"(за умови ``sys.argv[0]`).` є ``\"foo.py\"``):"

#: ../../library/optparse.rst:1389
msgid ""
"Usage: foo.py [options]\n"
"\n"
"Options:\n"
"  -h, --help        Show this help message and exit\n"
"  -v                Be moderately verbose\n"
"  --file=FILENAME   Input file to read data from"
msgstr ""

#: ../../library/optparse.rst:1398
msgid ""
"After printing the help message, :mod:`optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr ""
"Після друку довідкового повідомлення :mod:`optparse` завершує ваш процес за "
"допомогою ``sys.exit(0)``."

#: ../../library/optparse.rst:1401
msgid "``\"version\"``"
msgstr "``\"версія\"``"

#: ../../library/optparse.rst:1403
msgid ""
"Prints the version number supplied to the OptionParser to stdout and exits. "
"The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if the "
"``version`` argument is supplied to the OptionParser constructor.  As with "
":attr:`~Option.help` options, you will rarely create ``version`` options, "
"since :mod:`optparse` automatically adds them when needed."
msgstr ""
"Друкує номер версії, наданий OptionParser, у stdout і завершує роботу. Номер"
" версії фактично форматується та друкується методом ``print_version()`` "
"OptionParser. Зазвичай актуально, лише якщо аргумент ``version`` надається "
"конструктору OptionParser. Як і у випадку з параметрами "
":attr:`~Option.help`, ви рідко будете створювати параметри ``version``, "
"оскільки :mod:`optparse` автоматично додає їх за потреби."

#: ../../library/optparse.rst:1414
msgid "Standard option types"
msgstr "Типи стандартних варіантів"

#: ../../library/optparse.rst:1416
msgid ""
":mod:`optparse` has five built-in option types: ``\"string\"``, ``\"int\"``,"
" ``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you need to add new "
"option types, see section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` має п’ять вбудованих типів параметрів: ``\"string\"``, "
"``\"int\"``, ``\"choice\"``, ``\"float\"`` і ``\"complex \"``. Якщо вам "
"потрібно додати нові типи опцій, перегляньте розділ :ref:`optparse-"
"extending-optparse`."

#: ../../library/optparse.rst:1420
msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr ""
"Аргументи параметрів рядка не перевіряються та не перетворюються жодним "
"чином: текст у командному рядку зберігається в місці призначення (або "
"передається зворотному виклику) як є."

#: ../../library/optparse.rst:1423
msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr "Цілі аргументи (тип ``\"int\"``) аналізуються таким чином:"

#: ../../library/optparse.rst:1425
msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr ""
"якщо число починається з ``0x``, воно аналізується як шістнадцяткове число"

#: ../../library/optparse.rst:1427
msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "якщо число починається з ``0``, воно аналізується як вісімкове число"

#: ../../library/optparse.rst:1429
msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr "якщо число починається з ``0b``, воно аналізується як двійкове число"

#: ../../library/optparse.rst:1431
msgid "otherwise, the number is parsed as a decimal number"
msgstr "інакше число аналізується як десяткове число"

#: ../../library/optparse.rst:1434
msgid ""
"The conversion is done by calling :func:`int` with the appropriate base (2, "
"8, 10, or 16).  If this fails, so will :mod:`optparse`, although with a more"
" useful error message."
msgstr ""
"Перетворення виконується викликом :func:`int` із відповідною основою (2, 8, "
"10 або 16). Якщо це не вдасться, не вийде і :mod:`optparse`, хоча з більш "
"корисним повідомленням про помилку."

#: ../../library/optparse.rst:1438
msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly "
"with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"Аргументи параметрів ``\"float\"`` і ``\"complex\"`` перетворюються "
"безпосередньо за допомогою :func:`float` і :func:`complex`, з подібною "
"обробкою помилок."

#: ../../library/optparse.rst:1441
msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The "
":attr:`~Option.choices` option attribute (a sequence of strings) defines the"
" set of allowed option arguments.  :func:`optparse.check_choice` compares "
"user-supplied option arguments against this master list and raises "
":exc:`OptionValueError` if an invalid string is given."
msgstr ""
"Опції ``\"choice\"`` є підтипом опцій ``\"string\"``. Атрибут опції "
":attr:`~Option.choices` (послідовність рядків) визначає набір дозволених "
"аргументів опції. :func:`optparse.check_choice` порівнює аргументи "
"параметрів, надані користувачем, із цим головним списком і викликає "
":exc:`OptionValueError`, якщо вказано недійсний рядок."

#: ../../library/optparse.rst:1451
msgid "Parsing arguments"
msgstr "Розбір аргументів"

#: ../../library/optparse.rst:1453
msgid ""
"The whole point of creating and populating an OptionParser is to call its "
":meth:`~OptionParser.parse_args` method."
msgstr ""

#: ../../library/optparse.rst:1458
msgid "Parse the command-line options found in *args*."
msgstr ""

#: ../../library/optparse.rst:1460
msgid "The input parameters are"
msgstr ""

#: ../../library/optparse.rst:1462 ../../library/optparse.rst:1476
#: ../../library/optparse.rst:1794
msgid "``args``"
msgstr "``args``"

#: ../../library/optparse.rst:1463
msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "список аргументів для обробки (за замовчуванням: ``sys.argv[1:]``)"

#: ../../library/optparse.rst:1465
msgid "``values``"
msgstr "``значення``"

#: ../../library/optparse.rst:1466
msgid ""
"a :class:`Values` object to store option arguments in (default: a new "
"instance of :class:`Values`) -- if you give an existing object, the option "
"defaults will not be initialized on it"
msgstr ""

#: ../../library/optparse.rst:1470
msgid "and the return value is a pair ``(options, args)`` where"
msgstr ""

#: ../../library/optparse.rst:1472
msgid "``options``"
msgstr "``параметри``"

#: ../../library/optparse.rst:1473
msgid ""
"the same object that was passed in as *values*, or the ``optparse.Values`` "
"instance created by :mod:`optparse`"
msgstr ""

#: ../../library/optparse.rst:1477
msgid ""
"the leftover positional arguments after all options have been processed"
msgstr "залишкові позиційні аргументи після обробки всіх опцій"

#: ../../library/optparse.rst:1479
msgid ""
"The most common usage is to supply neither keyword argument.  If you supply "
"``values``, it will be modified with repeated :func:`setattr` calls (roughly"
" one for every option argument stored to an option destination) and returned"
" by :meth:`~OptionParser.parse_args`."
msgstr ""

#: ../../library/optparse.rst:1484
msgid ""
"If :meth:`~OptionParser.parse_args` encounters any errors in the argument "
"list, it calls the OptionParser's :meth:`error` method with an appropriate "
"end-user error message. This ultimately terminates your process with an exit"
" status of 2 (the traditional Unix exit status for command-line errors)."
msgstr ""

#: ../../library/optparse.rst:1493
msgid "Querying and manipulating your option parser"
msgstr "Запити та маніпулювання вашим аналізатором параметрів"

#: ../../library/optparse.rst:1495
msgid ""
"The default behavior of the option parser can be customized slightly, and "
"you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr ""
"Поведінку аналізатора параметрів за замовчуванням можна дещо налаштувати, і "
"ви також можете пошукати свій аналізатор параметрів і подивитися, що там є. "
"OptionParser пропонує кілька методів, які допоможуть вам:"

#: ../../library/optparse.rst:1501
msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and "
"``-b`` are both simple options that take no arguments, :mod:`optparse` "
"normally accepts this syntax::"
msgstr ""
"Встановіть зупинку аналізу на першому варіанті. Наприклад, якщо ``-a`` і "
"``-b`` є простими параметрами, які не приймають аргументів, :mod:`optparse` "
"зазвичай приймає такий синтаксис::"

#: ../../library/optparse.rst:1505
msgid "prog -a arg1 -b arg2"
msgstr ""

#: ../../library/optparse.rst:1507
msgid "and treats it as equivalent to  ::"
msgstr "і розглядає його як еквівалент ::"

#: ../../library/optparse.rst:1509
msgid "prog -a -b arg1 arg2"
msgstr ""

#: ../../library/optparse.rst:1511
msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the first "
"non-option argument."
msgstr ""
"Щоб вимкнути цю функцію, викличте :meth:`disable_interspersed_args`. Це "
"відновлює традиційний синтаксис Unix, де розбір параметрів припиняється з "
"першим аргументом, що не є параметром."

#: ../../library/optparse.rst:1515
msgid ""
"Use this if you have a command processor which runs another command which "
"has options of its own and you want to make sure these options don't get "
"confused.  For example, each command might have a different set of options."
msgstr ""
"Використовуйте це, якщо у вас є командний процесор, який виконує іншу "
"команду, яка має власні параметри, і ви хочете переконатися, що ці параметри"
" не плутаються. Наприклад, кожна команда може мати різний набір параметрів."

#: ../../library/optparse.rst:1521
msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr ""
"Налаштуйте розбір так, щоб він не зупинявся на першому не-параметрі, "
"дозволяючи вставляти перемикачі в аргументи команди. Це типова поведінка."

#: ../../library/optparse.rst:1526
msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None`` if"
" no options have that option string."
msgstr ""
"Повертає екземпляр Option із рядком параметра *opt_str* або ``None``, якщо "
"параметри не мають такого рядка параметра."

#: ../../library/optparse.rst:1531
msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"Повертає ``True``, якщо OptionParser має параметр із рядком параметра "
"*opt_str* (наприклад, ``-q`` або ``--verbose``)."

#: ../../library/optparse.rst:1536
msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, that "
"option is removed.  If that option provided any other option strings, all of"
" those option strings become invalid. If *opt_str* does not occur in any "
"option belonging to this :class:`OptionParser`, raises :exc:`ValueError`."
msgstr ""
"Якщо :class:`OptionParser` має параметр, що відповідає *opt_str*, цей "
"параметр буде видалено. Якщо цей параметр містить будь-які інші рядки "
"параметрів, усі ці рядки параметрів стають недійсними. Якщо *opt_str* не "
"зустрічається в жодному параметрі, що належить цьому :class:`OptionParser`, "
"викликає :exc:`ValueError`."

#: ../../library/optparse.rst:1545
msgid "Conflicts between options"
msgstr "Конфлікти між варіантами"

#: ../../library/optparse.rst:1547
msgid ""
"If you're not careful, it's easy to define options with conflicting option "
"strings::"
msgstr ""
"Якщо ви не будете обережні, можна легко визначити параметри з конфліктуючими"
" рядками параметрів::"

#: ../../library/optparse.rst:1550
msgid ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"
msgstr ""

#: ../../library/optparse.rst:1554
msgid ""
"(This is particularly true if you've defined your own OptionParser subclass "
"with some standard options.)"
msgstr ""
"(Це особливо вірно, якщо ви визначили свій власний підклас OptionParser з "
"деякими стандартними параметрами.)"

#: ../../library/optparse.rst:1557
msgid ""
"Every time you add an option, :mod:`optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-handling"
" mechanism. You can set the conflict-handling mechanism either in the "
"constructor::"
msgstr ""
"Кожного разу, коли ви додаєте опцію, :mod:`optparse` перевіряє наявність "
"конфліктів із існуючими опціями. Якщо він знайде будь-який, він викликає "
"поточний механізм обробки конфліктів. Ви можете встановити механізм обробки "
"конфліктів у конструкторі:"

#: ../../library/optparse.rst:1561
msgid "parser = OptionParser(..., conflict_handler=handler)"
msgstr ""

#: ../../library/optparse.rst:1563
msgid "or with a separate call::"
msgstr "або окремим дзвінком::"

#: ../../library/optparse.rst:1565
msgid "parser.set_conflict_handler(handler)"
msgstr ""

#: ../../library/optparse.rst:1567
msgid "The available conflict handlers are:"
msgstr "Доступні засоби обробки конфліктів:"

#: ../../library/optparse.rst:1569
msgid "``\"error\"`` (default)"
msgstr "``\"помилка\"`` (за замовчуванням)"

#: ../../library/optparse.rst:1570
msgid ""
"assume option conflicts are a programming error and raise "
":exc:`OptionConflictError`"
msgstr ""
"припустити, що конфлікти параметрів є помилкою програмування, і викликати "
":exc:`OptionConflictError`"

#: ../../library/optparse.rst:1573
msgid "``\"resolve\"``"
msgstr "``\"розв'язати\"``"

#: ../../library/optparse.rst:1574
msgid "resolve option conflicts intelligently (see below)"
msgstr "розумно вирішувати конфлікти варіантів (див. нижче)"

#: ../../library/optparse.rst:1577
msgid ""
"As an example, let's define an :class:`OptionParser` that resolves conflicts"
" intelligently and add conflicting options to it::"
msgstr ""
"Як приклад, давайте визначимо :class:`OptionParser`, який розумно вирішує "
"конфлікти, і додамо до нього конфліктуючі параметри::"

#: ../../library/optparse.rst:1580
msgid ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"do no harm\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"be noisy\")"
msgstr ""

#: ../../library/optparse.rst:1584
msgid ""
"At this point, :mod:`optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only way "
"for the user to activate that option.  If the user asks for help, the help "
"message will reflect that::"
msgstr ""

#: ../../library/optparse.rst:1590
msgid ""
"Options:\n"
"  --dry-run     do no harm\n"
"  ...\n"
"  -n, --noisy   be noisy"
msgstr ""

#: ../../library/optparse.rst:1595
msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking that "
"option from the command-line.  In that case, :mod:`optparse` removes that "
"option completely, so it doesn't show up in help text or anywhere else. "
"Carrying on with our existing OptionParser::"
msgstr ""

#: ../../library/optparse.rst:1601
msgid "parser.add_option(\"--dry-run\", ..., help=\"new dry-run option\")"
msgstr ""

#: ../../library/optparse.rst:1603
msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`optparse` removes it, leaving this help text::"
msgstr ""
"На цьому етапі вихідний параметр ``-n``/``--dry-run`` більше не доступний, "
"тому :mod:`optparse` видаляє його, залишаючи цей текст довідки::"

#: ../../library/optparse.rst:1606
msgid ""
"Options:\n"
"  ...\n"
"  -n, --noisy   be noisy\n"
"  --dry-run     new dry-run option"
msgstr ""

#: ../../library/optparse.rst:1615
msgid "Cleanup"
msgstr "Прибирати"

#: ../../library/optparse.rst:1617
msgid ""
"OptionParser instances have several cyclic references.  This should not be a"
" problem for Python's garbage collector, but you may wish to break the "
"cyclic references explicitly by calling :meth:`~OptionParser.destroy` on "
"your OptionParser once you are done with it.  This is particularly useful in"
" long-running applications where large object graphs are reachable from your"
" OptionParser."
msgstr ""
"Екземпляри OptionParser мають кілька циклічних посилань. Це не повинно бути "
"проблемою для збирача сміття Python, але ви можете розірвати циклічні "
"посилання явно, викликавши :meth:`~OptionParser.destroy` на вашому "
"OptionParser, коли ви закінчите з цим. Це особливо корисно в довготривалих "
"програмах, де великі об’єктні графіки доступні з вашого OptionParser."

#: ../../library/optparse.rst:1628
msgid "Other methods"
msgstr "Інші методи"

#: ../../library/optparse.rst:1630
msgid "OptionParser supports several other public methods:"
msgstr "OptionParser підтримує кілька інших публічних методів:"

#: ../../library/optparse.rst:1634
msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the default "
"usage string; use :const:`optparse.SUPPRESS_USAGE` to suppress a usage "
"message."
msgstr ""

#: ../../library/optparse.rst:1640
msgid ""
"Print the usage message for the current program (``self.usage``) to *file* "
"(default stdout).  Any occurrence of the string ``%prog`` in ``self.usage`` "
"is replaced with the name of the current program.  Does nothing if "
"``self.usage`` is empty or not defined."
msgstr ""
"Надрукувати повідомлення про використання для поточної програми "
"(``self.usage``) у *файл* (стандартний вихід за замовчуванням). Будь-яке "
"входження рядка ``%prog`` у ``self.usage`` замінюється назвою поточної "
"програми. Нічого не робить, якщо ``self.usage`` порожній або не визначений."

#: ../../library/optparse.rst:1647
msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of printing"
" it."
msgstr ""
"Те саме, що :meth:`print_usage`, але повертає рядок використання замість "
"його друку."

#: ../../library/optparse.rst:1652
msgid ""
"Set default values for several option destinations at once.  Using "
":meth:`set_defaults` is the preferred way to set default values for options,"
" since multiple options can share the same destination.  For example, if "
"several \"mode\" options all set the same destination, any one of them can "
"set the default, and the last one wins::"
msgstr ""
"Встановіть значення за замовчуванням для кількох пунктів призначення "
"одночасно. Використання :meth:`set_defaults` є кращим способом встановлення "
"значень за замовчуванням для параметрів, оскільки кілька параметрів можуть "
"мати одне призначення. Наприклад, якщо кілька параметрів \"режиму\" "
"встановлюють одне й те саме призначення, будь-який із них може встановити "
"значення за замовчуванням, і виграє останній:"

#: ../../library/optparse.rst:1658
msgid ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # overridden below\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # overrides above setting"
msgstr ""

#: ../../library/optparse.rst:1665
msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "Щоб уникнути цієї плутанини, використовуйте :meth:`set_defaults`::"

#: ../../library/optparse.rst:1667
msgid ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"
msgstr ""

#: ../../library/optparse.rst:1677
msgid "Option Callbacks"
msgstr "Опція зворотних викликів"

#: ../../library/optparse.rst:1679
msgid ""
"When :mod:`optparse`'s built-in actions and types aren't quite enough for "
"your needs, you have two choices: extend :mod:`optparse` or define a "
"callback option. Extending :mod:`optparse` is more general, but overkill for"
" a lot of simple cases.  Quite often a simple callback is all you need."
msgstr ""
"Якщо вбудованих дій і типів :mod:`optparse` недостатньо для ваших потреб, у "
"вас є два варіанти: розширити :mod:`optparse` або визначити опцію зворотного"
" виклику. Розширення :mod:`optparse` є більш загальним, але надмірним для "
"багатьох простих випадків. Досить часто простий зворотний дзвінок - це все, "
"що вам потрібно."

#: ../../library/optparse.rst:1684
msgid "There are two steps to defining a callback option:"
msgstr "Існує два кроки, щоб визначити опцію зворотного виклику:"

#: ../../library/optparse.rst:1686
msgid "define the option itself using the ``\"callback\"`` action"
msgstr "визначте саму опцію за допомогою дії ``\"callback\"``"

#: ../../library/optparse.rst:1688
msgid ""
"write the callback; this is a function (or method) that takes at least four "
"arguments, as described below"
msgstr ""
"написати зворотний дзвінок; це функція (або метод), яка приймає щонайменше "
"чотири аргументи, як описано нижче"

#: ../../library/optparse.rst:1695
msgid "Defining a callback option"
msgstr "Визначення опції зворотного виклику"

#: ../../library/optparse.rst:1697
msgid ""
"As always, the easiest way to define a callback option is by using the "
":meth:`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, "
"the only option attribute you must specify is ``callback``, the function to "
"call::"
msgstr ""
"Як завжди, найпростішим способом визначення опції зворотного виклику є "
"використання методу :meth:`OptionParser.add_option`. Окрім "
":attr:`~Option.action`, єдиним атрибутом параметра, який ви повинні вказати,"
" є ``callback``, функція для виклику::"

#: ../../library/optparse.rst:1701
msgid "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"
msgstr ""

#: ../../library/optparse.rst:1703
msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. In "
"this simple case, :mod:`optparse` doesn't even know if ``-c`` takes any "
"arguments, which usually means that the option takes no arguments---the mere"
" presence of ``-c`` on the command-line is all it needs to know.  In some "
"circumstances, though, you might want your callback to consume an arbitrary "
"number of command-line arguments.  This is where writing callbacks gets "
"tricky; it's covered later in this section."
msgstr ""
"``callback`` є функцією (або іншим викликаним об'єктом), тому ви повинні вже"
" визначати ``my_callback()``, створюючи цю опцію зворотного виклику. У цьому"
" простому випадку :mod:`optparse` навіть не знає, чи ``-c`` приймає будь-які"
" аргументи, що зазвичай означає, що опція не приймає аргументів --- сама "
"наявність ``-c`` на командний рядок — це все, що йому потрібно знати. Проте "
"за деяких обставин ви можете захотіти, щоб ваш зворотній виклик споживав "
"довільну кількість аргументів командного рядка. Тут написання зворотних "
"викликів стає складним; це розглянуто далі в цьому розділі."

#: ../../library/optparse.rst:1712
msgid ""
":mod:`optparse` always passes four particular arguments to your callback, "
"and it will only pass additional arguments if you specify them via "
":attr:`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, "
"the minimal callback function signature is::"
msgstr ""
":mod:`optparse` завжди передає чотири конкретні аргументи вашому зворотному "
"виклику, і він передасть додаткові аргументи, лише якщо ви вкажете їх через "
":attr:`~Option.callback_args` і :attr:`~Option.callback_kwargs`. Таким "
"чином, мінімальна сигнатура функції зворотного виклику:"

#: ../../library/optparse.rst:1717
msgid "def my_callback(option, opt, value, parser):"
msgstr ""

#: ../../library/optparse.rst:1719
msgid "The four arguments to a callback are described below."
msgstr "Чотири аргументи зворотного виклику описані нижче."

#: ../../library/optparse.rst:1721
msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr ""
"Є кілька інших атрибутів опції, які ви можете надати, коли визначаєте опцію "
"зворотного виклику:"

#: ../../library/optparse.rst:1724
msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.type`"

#: ../../library/optparse.rst:1725
msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` actions, "
"it instructs :mod:`optparse` to consume one argument and convert it to "
":attr:`~Option.type`.  Rather than storing the converted value(s) anywhere, "
"though, :mod:`optparse` passes it to your callback function."
msgstr ""
"має своє звичайне значення: як і з діями ``\"store\"`` або ``\"append\"``, "
"воно наказує :mod:`optparse` споживати один аргумент і перетворювати його на"
" :attr:`~Option.type` . Замість того, щоб десь зберігати перетворені "
"значення, :mod:`optparse` передає їх вашій функції зворотного виклику."

#: ../../library/optparse.rst:1730
msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

#: ../../library/optparse.rst:1731
msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`optparse` will "
"consume :attr:`~Option.nargs` arguments, each of which must be convertible "
"to :attr:`~Option.type`.  It then passes a tuple of converted values to your"
" callback."
msgstr ""
"також має своє звичайне значення: якщо його надано та > 1, :mod:`optparse` "
"споживатиме аргументи :attr:`~Option.nargs`, кожен із яких має бути "
"конвертованим у :attr:`~Option.type`. Потім він передає кортеж перетворених "
"значень у ваш зворотній виклик."

#: ../../library/optparse.rst:1736
msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

#: ../../library/optparse.rst:1737
msgid "a tuple of extra positional arguments to pass to the callback"
msgstr ""
"кортеж додаткових позиційних аргументів для передачі зворотному виклику"

#: ../../library/optparse.rst:1739
msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

#: ../../library/optparse.rst:1740
msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr ""
"словник додаткових ключових аргументів для передачі зворотному виклику"

#: ../../library/optparse.rst:1746
msgid "How callbacks are called"
msgstr "Як називаються зворотні виклики"

#: ../../library/optparse.rst:1748
msgid "All callbacks are called as follows::"
msgstr "Усі зворотні виклики викликаються наступним чином:"

#: ../../library/optparse.rst:1754
msgid "``option``"
msgstr "``опція``"

#: ../../library/optparse.rst:1755
msgid "is the Option instance that's calling the callback"
msgstr "це екземпляр Option, який викликає зворотний виклик"

#: ../../library/optparse.rst:1757
msgid "``opt_str``"
msgstr "``opt_str``"

#: ../../library/optparse.rst:1758
msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be the "
"full, canonical option string---e.g. if the user puts ``--foo`` on the "
"command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be "
"``\"--foobar\"``.)"
msgstr ""
"це рядок параметрів, який можна побачити в командному рядку, який запускає "
"зворотний виклик. (Якщо використовувався скорочений довгий параметр, "
"``opt_str`` буде повним, канонічним рядком параметра --- наприклад, якщо "
"користувач розміщує ``--foo`` у командному рядку як скорочення для ``-- "
"foobar``, тоді ``opt_str`` буде ``\"--foobar\"``.)"

#: ../../library/optparse.rst:1764
msgid "``value``"
msgstr "``значення``"

#: ../../library/optparse.rst:1765
msgid ""
"is the argument to this option seen on the command-line.  :mod:`optparse` "
"will only expect an argument if :attr:`~Option.type` is set; the type of "
"``value`` will be the type implied by the option's type.  If "
":attr:`~Option.type` for this option is ``None`` (no argument expected), "
"then ``value`` will be ``None``.  If :attr:`~Option.nargs` > 1, ``value`` "
"will be a tuple of values of the appropriate type."
msgstr ""
"є аргументом цього параметра в командному рядку. :mod:`optparse` очікуватиме"
" аргумент, лише якщо встановлено :attr:`~Option.type`; тип ``значення`` буде"
" типом, який передбачається типом опції. Якщо :attr:`~Option.type` для цього"
" параметра має значення ``None`` (аргумент не очікується), тоді ``value`` "
"буде ``None``. Якщо :attr:`~Option.nargs` > 1, ``value`` буде кортежем "
"значень відповідного типу."

#: ../../library/optparse.rst:1771
msgid "``parser``"
msgstr "``парсер``"

#: ../../library/optparse.rst:1772
msgid ""
"is the OptionParser instance driving the whole thing, mainly useful because "
"you can access some other interesting data through its instance attributes:"
msgstr ""
"це екземпляр OptionParser, який керує всім цим, головним чином корисний, "
"оскільки ви можете отримати доступ до деяких інших цікавих даних через його "
"атрибути екземпляра:"

#: ../../library/optparse.rst:1775
msgid "``parser.largs``"
msgstr "``parser.largs``"

#: ../../library/optparse.rst:1776
msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to modify "
"``parser.largs``, e.g. by adding more arguments to it.  (This list will "
"become ``args``, the second return value of "
":meth:`~OptionParser.parse_args`.)"
msgstr ""

#: ../../library/optparse.rst:1781
msgid "``parser.rargs``"
msgstr "``parser.rargs``"

#: ../../library/optparse.rst:1782
msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and ``value`` "
"(if applicable) removed, and only the arguments following them still there."
"  Feel free to modify ``parser.rargs``, e.g. by consuming more arguments."
msgstr ""
"поточний список аргументів, що залишилися, тобто. з вилученими параметрами "
"``opt_str`` і ``value`` (якщо застосовно), і залишаються лише наступні за "
"ними аргументи. Не соромтеся змінити ``parser.rargs``, напр. споживаючи "
"більше аргументів."

#: ../../library/optparse.rst:1787
msgid "``parser.values``"
msgstr "``parser.values``"

#: ../../library/optparse.rst:1788
msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as the "
"rest of :mod:`optparse` for storing option values; you don't need to mess "
"around with globals or closures.  You can also access or modify the value(s)"
" of any options already encountered on the command-line."
msgstr ""
"об’єкт, де за замовчуванням зберігаються значення параметрів (екземпляр "
"optparse.OptionValues). Це дозволяє зворотним викликам використовувати той "
"самий механізм, що й решта :mod:`optparse` для зберігання значень "
"параметрів; вам не потрібно возитися з глобалами чи закриттями. Ви також "
"можете отримати доступ або змінити значення будь-яких параметрів, які вже "
"зустрічаються в командному рядку."

#: ../../library/optparse.rst:1795
msgid ""
"is a tuple of arbitrary positional arguments supplied via the "
":attr:`~Option.callback_args` option attribute."
msgstr ""
"це кортеж довільних позиційних аргументів, що надаються через атрибут опції "
":attr:`~Option.callback_args`."

#: ../../library/optparse.rst:1798
msgid "``kwargs``"
msgstr "``кварги``"

#: ../../library/optparse.rst:1799
msgid ""
"is a dictionary of arbitrary keyword arguments supplied via "
":attr:`~Option.callback_kwargs`."
msgstr ""
"це словник довільних аргументів ключових слів, які надаються через "
":attr:`~Option.callback_kwargs`."

#: ../../library/optparse.rst:1806
msgid "Raising errors in a callback"
msgstr "Викликання помилок у зворотному виклику"

#: ../../library/optparse.rst:1808
msgid ""
"The callback function should raise :exc:`OptionValueError` if there are any "
"problems with the option or its argument(s).  :mod:`optparse` catches this "
"and terminates the program, printing the error message you supply to stderr."
"  Your message should be clear, concise, accurate, and mention the option at"
" fault. Otherwise, the user will have a hard time figuring out what they did"
" wrong."
msgstr ""
"Функція зворотного виклику має викликати :exc:`OptionValueError`, якщо є "
"проблеми з параметром або його аргументом(ами). :mod:`optparse` вловлює це "
"та завершує програму, друкуючи повідомлення про помилку, яке ви надаєте на "
"stderr. Ваше повідомлення має бути ясним, лаконічним, точним і вказувати на "
"помилковий варіант. В іншому випадку користувачеві буде важко зрозуміти, що "
"він зробив не так."

#: ../../library/optparse.rst:1818
msgid "Callback example 1: trivial callback"
msgstr "Приклад зворотного виклику 1: тривіальний зворотний виклик"

#: ../../library/optparse.rst:1820
msgid ""
"Here's an example of a callback option that takes no arguments, and simply "
"records that the option was seen::"
msgstr ""
"Ось приклад опції зворотного виклику, яка не приймає аргументів і просто "
"записує, що опцію було розглянуто::"

#: ../../library/optparse.rst:1823
msgid ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"
msgstr ""

#: ../../library/optparse.rst:1828
msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "Звичайно, ви можете зробити це за допомогою дії ``\"store_true\"``."

#: ../../library/optparse.rst:1834
msgid "Callback example 2: check option order"
msgstr "Приклад зворотного виклику 2: перевірте порядок варіантів"

#: ../../library/optparse.rst:1836
msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` is "
"seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr ""
"Ось трохи цікавіший приклад: зафіксуйте факт відображення ``-a``, але "
"роздуйте, якщо він стоїть після ``-b`` у командному рядку. ::"

#: ../../library/optparse.rst:1839
msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use -a after -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"
msgstr ""

#: ../../library/optparse.rst:1851
msgid "Callback example 3: check option order (generalized)"
msgstr "Приклад зворотного виклику 3: перевірка порядку опцій (узагальнено)"

#: ../../library/optparse.rst:1853
msgid ""
"If you want to reuse this callback for several similar options (set a flag, "
"but blow up if ``-b`` has already been seen), it needs a bit of work: the "
"error message and the flag that it sets must be generalized.  ::"
msgstr ""

#: ../../library/optparse.rst:1857
msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use %s after -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, dest='c')"
msgstr ""

#: ../../library/optparse.rst:1870
msgid "Callback example 4: check arbitrary condition"
msgstr "Приклад зворотного виклику 4: перевірка довільної умови"

#: ../../library/optparse.rst:1872
msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have "
"options that should not be called when the moon is full, all you have to do "
"is this::"
msgstr ""
"Звичайно, ви можете поставити туди будь-яку умову --- ви не обмежені "
"перевіркою значень уже визначених параметрів. Наприклад, якщо у вас є опції,"
" які не слід викликати в повний місяць, все, що вам потрібно зробити, це:"

#: ../../library/optparse.rst:1876
msgid ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s option invalid when moon is full\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"
msgstr ""

#: ../../library/optparse.rst:1885
msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the "
"reader.)"
msgstr "(Визначення ``is_moon_full()`` залишено як вправа для читача.)"

#: ../../library/optparse.rst:1891
msgid "Callback example 5: fixed arguments"
msgstr "Приклад зворотного виклику 5: фіксовані аргументи"

#: ../../library/optparse.rst:1893
msgid ""
"Things get slightly more interesting when you define callback options that "
"take a fixed number of arguments.  Specifying that a callback option takes "
"arguments is similar to defining a ``\"store\"`` or ``\"append\"`` option: "
"if you define :attr:`~Option.type`, then the option takes one argument that "
"must be convertible to that type; if you further define "
":attr:`~Option.nargs`, then the option takes :attr:`~Option.nargs` "
"arguments."
msgstr ""
"Справи стають трохи цікавішими, коли ви визначаєте параметри зворотного "
"виклику, які приймають фіксовану кількість аргументів. Вказівка того, що "
"опція зворотного виклику приймає аргументи, подібна до визначення опції "
"``\"store\"`` або ``\"append\"``: якщо ви визначаєте :attr:`~Option.type`, "
"тоді опція приймає один аргумент, який повинен бути конвертованим у цей тип;"
" якщо ви далі визначаєте :attr:`~Option.nargs`, тоді параметр приймає "
"аргументи :attr:`~Option.nargs`."

#: ../../library/optparse.rst:1900
msgid "Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "Ось приклад, який просто емулює стандартну дію ``\"store\"``:"

#: ../../library/optparse.rst:1902
msgid ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"
msgstr ""

#: ../../library/optparse.rst:1909
msgid ""
"Note that :mod:`optparse` takes care of consuming 3 arguments and converting"
" them to integers for you; all you have to do is store them.  (Or whatever; "
"obviously you don't need a callback for this example.)"
msgstr ""
"Зауважте, що :mod:`optparse` піклується про споживання 3 аргументів і "
"перетворення їх на цілі числа за вас; все, що вам потрібно зробити, це "
"зберегти їх. (Або що завгодно; очевидно, вам не потрібен зворотний виклик "
"для цього прикладу.)"

#: ../../library/optparse.rst:1917
msgid "Callback example 6: variable arguments"
msgstr "Приклад зворотного виклику 6: змінні аргументи"

#: ../../library/optparse.rst:1919
msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal with"
" certain intricacies of conventional Unix command-line parsing that "
":mod:`optparse` normally handles for you.  In particular, callbacks should "
"implement the conventional rules for bare ``--`` and ``-`` arguments:"
msgstr ""
"Справи стають заплутаними, коли ви хочете, щоб параметр приймав змінну "
"кількість аргументів. У цьому випадку ви повинні написати зворотний виклик, "
"оскільки :mod:`optparse` не надає жодних вбудованих можливостей для нього. І"
" вам доведеться мати справу з певними тонкощами звичайного аналізу "
"командного рядка Unix, який :mod:`optparse` зазвичай обробляє для вас. "
"Зокрема, зворотні виклики мають реалізовувати звичайні правила для голих "
"аргументів ``--`` і ``-``:"

#: ../../library/optparse.rst:1926
msgid "either ``--`` or ``-`` can be option arguments"
msgstr "``--`` або ``-`` можуть бути аргументами опції"

#: ../../library/optparse.rst:1928
msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr ""
"голий ``--`` (якщо не аргумент для якогось параметра): зупинити обробку "
"командного рядка та відкинути ``--``"

#: ../../library/optparse.rst:1931
msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr ""
"голий ``-`` (якщо не аргумент для якогось параметра): зупинити обробку "
"командного рядка, але зберегти ``-`` (додати його до ``parser.largs``)"

#: ../../library/optparse.rst:1934
msgid ""
"If you want an option that takes a variable number of arguments, there are "
"several subtle, tricky issues to worry about.  The exact implementation you "
"choose will be based on which trade-offs you're willing to make for your "
"application (which is why :mod:`optparse` doesn't support this sort of thing"
" directly)."
msgstr ""
"Якщо вам потрібна опція, яка приймає змінну кількість аргументів, є кілька "
"тонких, складних питань, про які варто потурбуватися. Точна реалізація, яку "
"ви виберете, базуватиметься на компромісах, які ви готові зробити для своєї "
"програми (саме тому :mod:`optparse` не підтримує подібні речі напряму)."

#: ../../library/optparse.rst:1940
msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr ""
"Тим не менш, ось спроба зворотного виклику для опції зі змінними "
"аргументами::"

#: ../../library/optparse.rst:1943
msgid ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # stop on --foo like options\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # stop on -a, but not on -3 or -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"
msgstr ""

#: ../../library/optparse.rst:1974
msgid "Extending :mod:`optparse`"
msgstr "Розширення :mod:`optparse`"

#: ../../library/optparse.rst:1976
msgid ""
"Since the two major controlling factors in how :mod:`optparse` interprets "
"command-line options are the action and type of each option, the most likely"
" direction of extension is to add new actions and new types."
msgstr ""
"Оскільки двома основними факторами, що впливають на те, як :mod:`optparse` "
"інтерпретує параметри командного рядка, є дія та тип кожного параметра, "
"найімовірнішим напрямком розширення є додавання нових дій і нових типів."

#: ../../library/optparse.rst:1984
msgid "Adding new types"
msgstr "Додавання нових типів"

#: ../../library/optparse.rst:1986
msgid ""
"To add new types, you need to define your own subclass of :mod:`optparse`'s "
":class:`Option` class.  This class has a couple of attributes that define "
":mod:`optparse`'s types: :attr:`~Option.TYPES` and "
":attr:`~Option.TYPE_CHECKER`."
msgstr ""
"Щоб додати нові типи, вам потрібно визначити власний підклас класу "
":mod:`optparse` :class:`Option`. Цей клас має кілька атрибутів, які "
"визначають типи :mod:`optparse`: :attr:`~Option.TYPES` і "
":attr:`~Option.TYPE_CHECKER`."

#: ../../library/optparse.rst:1992
msgid ""
"A tuple of type names; in your subclass, simply define a new tuple "
":attr:`TYPES` that builds on the standard one."
msgstr ""
"Кортеж імен типів; у своєму підкласі просто визначте новий кортеж "
":attr:`TYPES`, який базується на стандартному."

#: ../../library/optparse.rst:1997
msgid ""
"A dictionary mapping type names to type-checking functions.  A type-checking"
" function has the following signature::"
msgstr ""
"Словник, що зіставляє назви типів із функціями перевірки типу. Функція "
"перевірки типу має такий підпис:"

#: ../../library/optparse.rst:2000
msgid "def check_mytype(option, opt, value)"
msgstr ""

#: ../../library/optparse.rst:2002
msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option string"
" (e.g., ``-f``), and ``value`` is the string from the command line that must"
" be checked and converted to your desired type.  ``check_mytype()`` should "
"return an object of the hypothetical type ``mytype``.  The value returned by"
" a type-checking function will wind up in the OptionValues instance returned"
" by :meth:`OptionParser.parse_args`, or be passed to a callback as the "
"``value`` parameter."
msgstr ""
"де ``option`` - це екземпляр :class:`Option`, ``opt`` - це рядок параметра "
"(наприклад, ``-f``), а ``value`` - це рядок із командного рядка, який "
"необхідно перевірити та перетворити на потрібний тип. ``check_mytype()`` має"
" повертати об’єкт гіпотетичного типу ``mytype``. Значення, повернуте "
"функцією перевірки типу, з’явиться в екземплярі OptionValues, поверненому "
":meth:`OptionParser.parse_args`, або буде передано зворотному виклику як "
"параметр ``value``."

#: ../../library/optparse.rst:2010
msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string "
"``\"error:\"`` and prints everything to stderr before terminating the "
"process."
msgstr ""
"Ваша функція перевірки типу має викликати :exc:`OptionValueError`, якщо вона"
" стикається з будь-якими проблемами. :exc:`OptionValueError` приймає один "
"рядковий аргумент, який передається як є до методу :meth:`error` "
":class:`OptionParser`, який, у свою чергу, додає назву програми та рядок "
"``\"помилка: \"`` і друкує все в stderr перед завершенням процесу."

#: ../../library/optparse.rst:2016
msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is "
"even sillier than it used to be, because :mod:`optparse` 1.3 added built-in "
"support for complex numbers, but never mind.)"
msgstr ""
"Ось дурний приклад, який демонструє додавання типу параметра ``\"complex\"``"
" для аналізу комплексних чисел у стилі Python у командному рядку. (Це ще "
"безглуздіше, ніж було раніше, тому що :mod:`optparse` 1.3 додав вбудовану "
"підтримку комплексних чисел, але нічого.)"

#: ../../library/optparse.rst:2021
msgid "First, the necessary imports::"
msgstr "По-перше, необхідний імпорт::"

#: ../../library/optparse.rst:2023
msgid ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"
msgstr ""

#: ../../library/optparse.rst:2026
msgid ""
"You need to define your type-checker first, since it's referred to later (in"
" the :attr:`~Option.TYPE_CHECKER` class attribute of your Option subclass)::"
msgstr ""
"Спершу вам потрібно визначити свій засіб перевірки типів, оскільки на нього "
"посилатимуться пізніше (в атрибуті класу :attr:`~Option.TYPE_CHECKER` вашого"
" підкласу Option):"

#: ../../library/optparse.rst:2029
msgid ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: invalid complex value: %r\" % (opt, value))"
msgstr ""

#: ../../library/optparse.rst:2036
msgid "Finally, the Option subclass::"
msgstr "Нарешті, підклас Option::"

#: ../../library/optparse.rst:2038
msgid ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"
msgstr ""

#: ../../library/optparse.rst:2043
msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we would "
"end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of "
":mod:`optparse`'s Option class.  This being Python, nothing stops you from "
"doing that except good manners and common sense.)"
msgstr ""
"(Якби ми не зробили :func:`copy` :attr:`Option.TYPE_CHECKER`, ми б завершили"
" зміну атрибута :attr:`~Option.TYPE_CHECKER` параметра :mod:`optparse` "
"Оскільки це Python, ніщо не заважає вам це зробити, крім хороших манер і "
"здорового глузду.)"

#: ../../library/optparse.rst:2048
msgid ""
"That's it!  Now you can write a script that uses the new option type just "
"like any other :mod:`optparse`\\ -based script, except you have to instruct "
"your OptionParser to use MyOption instead of Option::"
msgstr ""
"Це воно! Тепер ви можете написати сценарій, який використовує новий тип "
"опцій, як і будь-який інший сценарій на основі :mod:`optparse`\\, за "
"винятком того, що вам потрібно вказати вашому OptionParser використовувати "
"MyOption замість Option::"

#: ../../library/optparse.rst:2052
msgid ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"
msgstr ""

#: ../../library/optparse.rst:2055
msgid ""
"Alternately, you can build your own option list and pass it to OptionParser;"
" if you don't use :meth:`add_option` in the above way, you don't need to "
"tell OptionParser which option class to use::"
msgstr ""
"Крім того, ви можете створити власний список параметрів і передати його в "
"OptionParser; якщо ви не використовуєте :meth:`add_option` вищезгаданим "
"способом, вам не потрібно вказувати OptionParser, який клас параметрів "
"використовувати::"

#: ../../library/optparse.rst:2059
msgid ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""

#: ../../library/optparse.rst:2066
msgid "Adding new actions"
msgstr "Додавання нових дій"

#: ../../library/optparse.rst:2068
msgid ""
"Adding new actions is a bit trickier, because you have to understand that "
":mod:`optparse` has a couple of classifications for actions:"
msgstr ""
"Додавати нові дії трохи складніше, тому що ви повинні розуміти, що "
":mod:`optparse` має кілька класифікацій для дій:"

#: ../../library/optparse.rst:2071
msgid "\"store\" actions"
msgstr "дії \"магазину\"."

#: ../../library/optparse.rst:2072
msgid ""
"actions that result in :mod:`optparse` storing a value to an attribute of "
"the current OptionValues instance; these options require a "
":attr:`~Option.dest` attribute to be supplied to the Option constructor."
msgstr ""
"дії, які призводять до того, що :mod:`optparse` зберігає значення в атрибуті"
" поточного екземпляра OptionValues; ці параметри вимагають надання атрибута "
":attr:`~Option.dest` конструктору Option."

#: ../../library/optparse.rst:2076
msgid "\"typed\" actions"
msgstr "\"набрані\" дії"

#: ../../library/optparse.rst:2077
msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain type. "
"These options require a :attr:`~Option.type` attribute to the Option "
"constructor."
msgstr ""
"дії, які беруть значення з командного рядка та очікують, що воно буде "
"певного типу; точніше, рядок, який можна перетворити на певний тип. Для цих "
"параметрів потрібен атрибут :attr:`~Option.type` конструктору Option."

#: ../../library/optparse.rst:2082
msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, while"
" the default \"typed\" actions are ``\"store\"``, ``\"append\"``, and "
"``\"callback\"``."
msgstr ""
"Це набори, що перекриваються: деякі дії \"зберігання\" за замовчуванням - це"
" ``\"store\"``, ``\"store_const\"``, ``\"append\"`` і ``\"count\"``, а за "
"замовчуванням \"typed\" \" діями є ``\"зберігати\"``, ``\"додавати\"`` і "
"``\"зворотний виклик\"``."

#: ../../library/optparse.rst:2086
msgid ""
"When you add an action, you need to categorize it by listing it in at least "
"one of the following class attributes of Option (all are lists of strings):"
msgstr ""
"Коли ви додаєте дію, вам потрібно класифікувати її, перерахувавши принаймні "
"в одному з наступних атрибутів класу Option (усі є списками рядків):"

#: ../../library/optparse.rst:2091
msgid "All actions must be listed in ACTIONS."
msgstr "Усі дії мають бути вказані в ACTIONS."

#: ../../library/optparse.rst:2095
msgid "\"store\" actions are additionally listed here."
msgstr "тут додатково перераховані дії \"магазину\"."

#: ../../library/optparse.rst:2099
msgid "\"typed\" actions are additionally listed here."
msgstr "\"введені\" дії додатково перераховані тут."

#: ../../library/optparse.rst:2103
msgid ""
"Actions that always take a type (i.e. whose options always take a value) are"
" additionally listed here.  The only effect of this is that :mod:`optparse` "
"assigns the default type, ``\"string\"``, to options with no explicit type "
"whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""
"Дії, які завжди мають тип (тобто чиї параметри завжди приймають значення), "
"додатково перераховані тут. Єдиним ефектом цього є те, що :mod:`optparse` "
"призначає тип за замовчуванням, ``\"string\"``, параметрам без явного типу, "
"дія яких указана в :attr:`ALWAYS_TYPED_ACTIONS`."

#: ../../library/optparse.rst:2108
msgid ""
"In order to actually implement your new action, you must override Option's "
":meth:`take_action` method and add a case that recognizes your action."
msgstr ""
"Щоб фактично реалізувати вашу нову дію, ви повинні перевизначити метод "
":meth:`take_action` Option і додати регістр, який розпізнає вашу дію."

#: ../../library/optparse.rst:2111
msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from "
"the command-line and appending it to an existing list, ``\"extend\"`` will "
"take multiple values in a single comma-delimited string, and extend an "
"existing list with them.  That is, if ``--names`` is an ``\"extend\"`` "
"option of type ``\"string\"``, the command line ::"
msgstr ""
"Наприклад, давайте додамо дію ``\"розширити\"``. Це схоже на стандартну дію "
"``\"append\"``, але замість того, щоб брати одне значення з командного рядка"
" та додавати його до існуючого списку, ``\"extend\"`` прийматиме кілька "
"значень в одній комі -рядок із роздільниками та розширити ними існуючий "
"список. Тобто, якщо ``--names`` є опцією ``\"extend\"`` типу ``\"string\"``,"
" командний рядок::"

#: ../../library/optparse.rst:2118
msgid "--names=foo,bar --names blah --names ding,dong"
msgstr ""

#: ../../library/optparse.rst:2120
msgid "would result in a list  ::"
msgstr "призведе до списку ::"

#: ../../library/optparse.rst:2122
msgid "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"
msgstr ""

#: ../../library/optparse.rst:2124
msgid "Again we define a subclass of Option::"
msgstr "Знову ми визначаємо підклас Option::"

#: ../../library/optparse.rst:2126
msgid ""
"class MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = value.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        else:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, value, values, parser)"
msgstr ""

#: ../../library/optparse.rst:2141
msgid "Features of note:"
msgstr "Примітка."

#: ../../library/optparse.rst:2143
msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and "
":attr:`~Option.TYPED_ACTIONS`."
msgstr ""
"``\"extend\"`` очікує значення в командному рядку та десь зберігає це "
"значення, тому воно входить і в :attr:`~Option.STORE_ACTIONS`, і в "
":attr:`~Option.TYPED_ACTIONS`."

#: ../../library/optparse.rst:2147
msgid ""
"to ensure that :mod:`optparse` assigns the default type of ``\"string\"`` to"
" ``\"extend\"`` actions, we put the ``\"extend\"`` action in "
":attr:`~Option.ALWAYS_TYPED_ACTIONS` as well."
msgstr ""
"щоб гарантувати, що :mod:`optparse` призначає типовий тип ``\"string\"`` "
"діям ``\"extend\"``, ми додаємо дію ``\"extend\"`` в :attr:`~Option. "
"ALWAYS_TYPED_ACTIONS` також."

#: ../../library/optparse.rst:2151
msgid ""
":meth:`MyOption.take_action` implements just this one new action, and passes"
" control back to :meth:`Option.take_action` for the standard :mod:`optparse`"
" actions."
msgstr ""
":meth:`MyOption.take_action` реалізує лише цю нову дію та передає керування "
"назад :meth:`Option.take_action` для стандартних дій :mod:`optparse`."

#: ../../library/optparse.rst:2155
msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. :meth:`ensure_value` "
"is essentially :func:`getattr` with a safety valve; it is called as ::"
msgstr ""
"``values`` є екземпляром класу optparse_parser.Values, який надає дуже "
"корисний метод :meth:`ensure_value`. :meth:`ensure_value` це по суті "
":func:`getattr` із запобіжним клапаном; це називається як ::"

#: ../../library/optparse.rst:2159
msgid "values.ensure_value(attr, value)"
msgstr ""

#: ../../library/optparse.rst:2161
msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, then "
"ensure_value() first sets it to ``value``, and then returns ``value``. This "
"is very handy for actions like ``\"extend\"``, ``\"append\"``, and "
"``\"count\"``, all of which accumulate data in a variable and expect that "
"variable to be of a certain type (a list for the first two, an integer for "
"the latter).  Using :meth:`ensure_value` means that scripts using your "
"action don't have to worry about setting a default value for the option "
"destinations in question; they can just leave the default as ``None`` and "
":meth:`ensure_value` will take care of getting it right when it's needed."
msgstr ""

#: ../../library/optparse.rst:2172
msgid "Exceptions"
msgstr "Винятки"

#: ../../library/optparse.rst:2176
msgid ""
"Raised if an :class:`Option` instance is created with invalid or "
"inconsistent arguments."
msgstr ""

#: ../../library/optparse.rst:2181
msgid "Raised if conflicting options are added to an :class:`OptionParser`."
msgstr ""

#: ../../library/optparse.rst:2185
msgid "Raised if an invalid option value is encountered on the command line."
msgstr ""

#: ../../library/optparse.rst:2189
msgid "Raised if an invalid option is passed on the command line."
msgstr ""

#: ../../library/optparse.rst:2193
msgid "Raised if an ambiguous option is passed on the command line."
msgstr ""
