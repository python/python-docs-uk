# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Subprocesses"
msgstr "Підпроцеси"

msgid ""
"**Source code:** :source:`Lib/asyncio/subprocess.py`, :source:`Lib/asyncio/"
"base_subprocess.py`"
msgstr ""
"**Вихідний код:** :source:`Lib/asyncio/subprocess.py`, :source:`Lib/asyncio/"
"base_subprocess.py`"

msgid ""
"This section describes high-level async/await asyncio APIs to create and "
"manage subprocesses."
msgstr ""
"У цьому розділі описано високорівневі API async/await asyncio для створення "
"та керування підпроцесами."

msgid ""
"Here's an example of how asyncio can run a shell command and obtain its "
"result::"
msgstr ""
"Ось приклад того, як asyncio може запустити команду оболонки та отримати її "
"результат::"

msgid "will print::"
msgstr "надрукую::"

msgid ""
"Because all asyncio subprocess functions are asynchronous and asyncio "
"provides many tools to work with such functions, it is easy to execute and "
"monitor multiple subprocesses in parallel.  It is indeed trivial to modify "
"the above example to run several commands simultaneously::"
msgstr ""
"Оскільки всі функції підпроцесів asyncio є асинхронними, а asyncio надає "
"багато інструментів для роботи з такими функціями, легко виконувати та "
"контролювати декілька підпроцесів паралельно. Дійсно тривіально змінити "
"наведений вище приклад для одночасного запуску кількох команд:"

msgid "See also the `Examples`_ subsection."
msgstr "Дивіться також підрозділ `Examples`_."

msgid "Creating Subprocesses"
msgstr "Створення підпроцесів"

msgid "Create a subprocess."
msgstr "Створіть підпроцес."

msgid ""
"The *limit* argument sets the buffer limit for :class:`StreamReader` "
"wrappers for :attr:`Process.stdout` and :attr:`Process.stderr` (if :attr:"
"`subprocess.PIPE` is passed to *stdout* and *stderr* arguments)."
msgstr ""
"Аргумент *limit* встановлює обмеження буфера для обгорток :class:"
"`StreamReader` для :attr:`Process.stdout` і :attr:`Process.stderr` (якщо :"
"attr:`subprocess.PIPE` передається в *stdout* і *stderr*)."

msgid "Return a :class:`~asyncio.subprocess.Process` instance."
msgstr "Повертає екземпляр :class:`~asyncio.subprocess.Process`."

msgid ""
"See the documentation of :meth:`loop.subprocess_exec` for other parameters."
msgstr ""
"Перегляньте документацію :meth:`loop.subprocess_exec` для інших параметрів."

msgid "Removed the *loop* parameter."
msgstr "Видалено параметр *loop*."

msgid "Run the *cmd* shell command."
msgstr "Виконайте команду оболонки *cmd*."

msgid ""
"See the documentation of :meth:`loop.subprocess_shell` for other parameters."
msgstr ""
"Перегляньте документацію :meth:`loop.subprocess_shell` для інших параметрів."

msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special shell characters in strings that are going to "
"be used to construct shell commands."
msgstr ""
"Програма несе відповідальність за те, щоб усі пробіли та спеціальні символи "
"були взяті в лапки належним чином, щоб уникнути вразливості `впровадження "
"оболонки <https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_. "
"Функцію :func:`shlex.quote` можна використати для правильного екранування "
"пробілів і спеціальних символів оболонки в рядках, які використовуватимуться "
"для створення команд оболонки."

msgid ""
"Subprocesses are available for Windows if a :class:`ProactorEventLoop` is "
"used. See :ref:`Subprocess Support on Windows <asyncio-windows-subprocess>` "
"for details."
msgstr ""
"Підпроцеси доступні для Windows, якщо використовується :class:"
"`ProactorEventLoop`. Дивіться :ref:`Підтримку підпроцесів у Windows <asyncio-"
"windows-subprocess>`, щоб дізнатися більше."

msgid ""
"asyncio also has the following *low-level* APIs to work with subprocesses: :"
"meth:`loop.subprocess_exec`, :meth:`loop.subprocess_shell`, :meth:`loop."
"connect_read_pipe`, :meth:`loop.connect_write_pipe`, as well as the :ref:"
"`Subprocess Transports <asyncio-subprocess-transports>` and :ref:`Subprocess "
"Protocols <asyncio-subprocess-protocols>`."
msgstr ""
"asyncio також має такі *низькопівневі* API для роботи з підпроцесами: :meth:"
"`loop.subprocess_exec`, :meth:`loop.subprocess_shell`, :meth:`loop."
"connect_read_pipe`, :meth:`loop.connect_write_pipe`, а також :ref:"
"`Транспорти підпроцесів <asyncio-subprocess-transports>` і :ref:`Протоколи "
"підпроцесів <asyncio-subprocess-protocols>`."

msgid "Constants"
msgstr "Константи"

msgid "Can be passed to the *stdin*, *stdout* or *stderr* parameters."
msgstr "Можна передати в параметри *stdin*, *stdout* або *stderr*."

msgid ""
"If *PIPE* is passed to *stdin* argument, the :attr:`Process.stdin <asyncio."
"subprocess.Process.stdin>` attribute will point to a :class:`StreamWriter` "
"instance."
msgstr ""
"Якщо *PIPE* передано аргументу *stdin*, атрибут :attr:`Process.stdin "
"<asyncio.subprocess.Process.stdin>` вказуватиме на примірник :class:"
"`StreamWriter`."

msgid ""
"If *PIPE* is passed to *stdout* or *stderr* arguments, the :attr:`Process."
"stdout <asyncio.subprocess.Process.stdout>` and :attr:`Process.stderr "
"<asyncio.subprocess.Process.stderr>` attributes will point to :class:"
"`StreamReader` instances."
msgstr ""
"Якщо *PIPE* передано аргументам *stdout* або *stderr*, атрибути :attr:"
"`Process.stdout <asyncio.subprocess.Process.stdout>` і :attr:`Process.stderr "
"<asyncio.subprocess.Process.stderr>` вказуватимуть на екземпляри :class:"
"`StreamReader`."

msgid ""
"Special value that can be used as the *stderr* argument and indicates that "
"standard error should be redirected into standard output."
msgstr ""
"Спеціальне значення, яке можна використовувати як аргумент *stderr* і вказує "
"на те, що стандартну помилку слід перенаправляти в стандартний вивід."

msgid ""
"Special value that can be used as the *stdin*, *stdout* or *stderr* argument "
"to process creation functions.  It indicates that the special file :data:`os."
"devnull` will be used for the corresponding subprocess stream."
msgstr ""
"Спеціальне значення, яке можна використовувати як аргумент *stdin*, *stdout* "
"або *stderr* для функцій створення процесу. Це вказує, що спеціальний файл :"
"data:`os.devnull` буде використано для відповідного потоку підпроцесу."

msgid "Interacting with Subprocesses"
msgstr "Взаємодія з підпроцесами"

msgid ""
"Both :func:`create_subprocess_exec` and :func:`create_subprocess_shell` "
"functions return instances of the *Process* class.  *Process* is a high-"
"level wrapper that allows communicating with subprocesses and watching for "
"their completion."
msgstr ""
"Обидві функції :func:`create_subprocess_exec` і :func:"
"`create_subprocess_shell` повертають екземпляри класу *Process*. *Process* — "
"це високорівнева оболонка, яка дозволяє спілкуватися з підпроцесами та "
"спостерігати за їх завершенням."

msgid ""
"An object that wraps OS processes created by the :func:"
"`create_subprocess_exec` and :func:`create_subprocess_shell` functions."
msgstr ""
"Об’єкт, який обгортає процеси ОС, створені функціями :func:"
"`create_subprocess_exec` і :func:`create_subprocess_shell`."

msgid ""
"This class is designed to have a similar API to the :class:`subprocess."
"Popen` class, but there are some notable differences:"
msgstr ""
"Цей клас розроблено таким чином, щоб мати API, подібний до класу :class:"
"`subprocess.Popen`, але є деякі помітні відмінності:"

msgid ""
"unlike Popen, Process instances do not have an equivalent to the :meth:"
"`~subprocess.Popen.poll` method;"
msgstr ""
"на відміну від Popen, екземпляри Process не мають еквівалента методу :meth:"
"`~subprocess.Popen.poll`;"

msgid ""
"the :meth:`~asyncio.subprocess.Process.communicate` and :meth:`~asyncio."
"subprocess.Process.wait` methods don't have a *timeout* parameter: use the :"
"func:`wait_for` function;"
msgstr ""
"методи :meth:`~asyncio.subprocess.Process.communicate` і :meth:`~asyncio."
"subprocess.Process.wait` не мають параметра *timeout*: використовуйте "
"функцію :func:`wait_for`;"

msgid ""
"the :meth:`Process.wait() <asyncio.subprocess.Process.wait>` method is "
"asynchronous, whereas :meth:`subprocess.Popen.wait` method is implemented as "
"a blocking busy loop;"
msgstr ""
"метод :meth:`Process.wait() <asyncio.subprocess.Process.wait>` є "
"асинхронним, тоді як метод :meth:`subprocess.Popen.wait` реалізовано як "
"блокуючий цикл зайнятості;"

msgid "the *universal_newlines* parameter is not supported."
msgstr "параметр *universal_newlines* не підтримується."

msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Цей клас :ref:`не потоково безпечний <asyncio-multithreading>`."

msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ""
"Дивіться також розділ :ref:`Підпроцеси та потоки <asyncio-subprocess-"
"threads>`."

msgid "Wait for the child process to terminate."
msgstr "Дочекайтеся завершення дочірнього процесу."

msgid "Set and return the :attr:`returncode` attribute."
msgstr "Установіть і поверніть атрибут :attr:`returncode`."

msgid ""
"This method can deadlock when using ``stdout=PIPE`` or ``stderr=PIPE`` and "
"the child process generates so much output that it blocks waiting for the OS "
"pipe buffer to accept more data. Use the :meth:`communicate` method when "
"using pipes to avoid this condition."
msgstr ""
"Цей метод може призвести до взаємоблокування під час використання "
"``stdout=PIPE`` або ``stderr=PIPE``, і дочірній процес генерує стільки "
"вихідних даних, що він блокує очікування, поки буфер каналу ОС прийме більше "
"даних. Використовуйте метод :meth:`communicate` під час використання "
"каналів, щоб уникнути цієї ситуації."

msgid "Interact with process:"
msgstr "Взаємодія з процесом:"

msgid "send data to *stdin* (if *input* is not ``None``);"
msgstr "надсилати дані на *stdin* (якщо *input* не ``None``);"

msgid "read data from *stdout* and *stderr*, until EOF is reached;"
msgstr "читати дані з *stdout* і *stderr*, доки не буде досягнуто EOF;"

msgid "wait for process to terminate."
msgstr "дочекайтеся завершення процесу."

msgid ""
"The optional *input* argument is the data (:class:`bytes` object) that will "
"be sent to the child process."
msgstr ""
"Додатковий *вхідний* аргумент — це дані (об’єкт :class:`bytes`), які будуть "
"надіслані дочірньому процесу."

msgid "Return a tuple ``(stdout_data, stderr_data)``."
msgstr "Повертає кортеж ``(stdout_data, stderr_data)``."

msgid ""
"If either :exc:`BrokenPipeError` or :exc:`ConnectionResetError` exception is "
"raised when writing *input* into *stdin*, the exception is ignored.  This "
"condition occurs when the process exits before all data are written into "
"*stdin*."
msgstr ""
"Якщо під час запису *input* у *stdin* виникає виняткова ситуація :exc:"
"`BrokenPipeError` або :exc:`ConnectionResetError`, виняток ігнорується. Ця "
"умова виникає, коли процес завершується до того, як усі дані будуть записані "
"в *stdin*."

msgid ""
"If it is desired to send data to the process' *stdin*, the process needs to "
"be created with ``stdin=PIPE``.  Similarly, to get anything other than "
"``None`` in the result tuple, the process has to be created with "
"``stdout=PIPE`` and/or ``stderr=PIPE`` arguments."
msgstr ""
"Якщо потрібно надіслати дані процесу *stdin*, процес потрібно створити за "
"допомогою ``stdin=PIPE``. Подібним чином, щоб отримати в кортежі результатів "
"щось інше, окрім ``None``, процес має бути створений з аргументами "
"``stdout=PIPE`` та/або ``stderr=PIPE``."

msgid ""
"Note, that the data read is buffered in memory, so do not use this method if "
"the data size is large or unlimited."
msgstr ""
"Зауважте, що зчитані дані буферизуються в пам’яті, тому не використовуйте "
"цей метод, якщо розмір даних великий або необмежений."

msgid "Sends the signal *signal* to the child process."
msgstr "Надсилає сигнал *signal* дочірньому процесу."

msgid ""
"On Windows, :py:data:`SIGTERM` is an alias for :meth:`terminate`. "
"``CTRL_C_EVENT`` and ``CTRL_BREAK_EVENT`` can be sent to processes started "
"with a *creationflags* parameter which includes ``CREATE_NEW_PROCESS_GROUP``."
msgstr ""
"У Windows :py:data:`SIGTERM` є псевдонімом для :meth:`terminate`. "
"``CTRL_C_EVENT`` і ``CTRL_BREAK_EVENT`` можна надсилати процесам, запущеним "
"з параметром *creationflags*, який включає ``CREATE_NEW_PROCESS_GROUP``."

msgid "Stop the child process."
msgstr "Зупиніть дочірній процес."

msgid ""
"On POSIX systems this method sends :py:data:`signal.SIGTERM` to the child "
"process."
msgstr ""
"У системах POSIX цей метод надсилає :py:data:`signal.SIGTERM` дочірньому "
"процесу."

msgid ""
"On Windows the Win32 API function :c:func:`TerminateProcess` is called to "
"stop the child process."
msgstr ""
"У Windows функція Win32 API :c:func:`TerminateProcess` викликається для "
"зупинки дочірнього процесу."

msgid "Kill the child process."
msgstr "Закрийте дочірній процес."

msgid ""
"On POSIX systems this method sends :py:data:`SIGKILL` to the child process."
msgstr ""
"У системах POSIX цей метод надсилає :py:data:`SIGKILL` дочірньому процесу."

msgid "On Windows this method is an alias for :meth:`terminate`."
msgstr "У Windows цей метод є псевдонімом для :meth:`terminate`."

msgid ""
"Standard input stream (:class:`StreamWriter`) or ``None`` if the process was "
"created with ``stdin=None``."
msgstr ""
"Стандартний вхідний потік (:class:`StreamWriter`) або ``None``, якщо процес "
"було створено за допомогою ``stdin=None``."

msgid ""
"Standard output stream (:class:`StreamReader`) or ``None`` if the process "
"was created with ``stdout=None``."
msgstr ""
"Стандартний вихідний потік (:class:`StreamReader`) або ``None``, якщо процес "
"було створено за допомогою ``stdout=None``."

msgid ""
"Standard error stream (:class:`StreamReader`) or ``None`` if the process was "
"created with ``stderr=None``."
msgstr ""
"Стандартний потік помилок (:class:`StreamReader`) або ``None``, якщо процес "
"було створено за допомогою ``stderr=None``."

msgid ""
"Use the :meth:`communicate` method rather than :attr:`process.stdin.write() "
"<stdin>`, :attr:`await process.stdout.read() <stdout>` or :attr:`await "
"process.stderr.read() <stderr>`. This avoids deadlocks due to streams "
"pausing reading or writing and blocking the child process."
msgstr ""
"Використовуйте метод :meth:`communicate` замість :attr:`process.stdin."
"write() <stdin>`, :attr:`await process.stdout.read() <stdout>` або :attr:"
"`await process.stderr.read () <stderr>`. Це дозволяє уникнути "
"взаємоблокувань через те, що потоки призупиняють читання або запис і "
"блокують дочірній процес."

msgid "Process identification number (PID)."
msgstr "Ідентифікаційний номер процесу (PID)."

msgid ""
"Note that for processes created by the :func:`create_subprocess_shell` "
"function, this attribute is the PID of the spawned shell."
msgstr ""
"Зауважте, що для процесів, створених функцією :func:"
"`create_subprocess_shell`, цей атрибут є PID створеної оболонки."

msgid "Return code of the process when it exits."
msgstr "Код повернення процесу під час його завершення."

msgid "A ``None`` value indicates that the process has not terminated yet."
msgstr "Значення ``None`` вказує на те, що процес ще не завершено."

msgid ""
"A negative value ``-N`` indicates that the child was terminated by signal "
"``N`` (POSIX only)."
msgstr ""
"Від’ємне значення ``-N`` вказує на те, що дочірній елемент було завершено "
"сигналом ``N`` (лише POSIX)."

msgid "Subprocess and Threads"
msgstr "Підпроцеси та потоки"

msgid ""
"Standard asyncio event loop supports running subprocesses from different "
"threads by default."
msgstr ""
"Стандартний асинхронний цикл подій за замовчуванням підтримує виконання "
"підпроцесів з різних потоків."

msgid ""
"On Windows subprocesses are provided by :class:`ProactorEventLoop` only "
"(default), :class:`SelectorEventLoop` has no subprocess support."
msgstr ""
"У Windows підпроцеси надаються лише :class:`ProactorEventLoop` (за "
"замовчуванням), :class:`SelectorEventLoop` не підтримує підпроцеси."

msgid ""
"On UNIX *child watchers* are used for subprocess finish waiting, see :ref:"
"`asyncio-watchers` for more info."
msgstr ""
"В UNIX *child watchers* використовуються для очікування завершення "
"підпроцесу, див. :ref:`asyncio-watchers` для отримання додаткової інформації."

msgid ""
"UNIX switched to use :class:`ThreadedChildWatcher` for spawning subprocesses "
"from different threads without any limitation."
msgstr ""
"UNIX перейшла на використання :class:`ThreadedChildWatcher` для створення "
"підпроцесів з різних потоків без будь-яких обмежень."

msgid ""
"Spawning a subprocess with *inactive* current child watcher raises :exc:"
"`RuntimeError`."
msgstr ""
"Створення підпроцесу з *неактивним* поточним дочірнім спостерігачем "
"викликає :exc:`RuntimeError`."

msgid ""
"Note that alternative event loop implementations might have own limitations; "
"please refer to their documentation."
msgstr ""
"Зауважте, що альтернативні реалізації циклу подій можуть мати власні "
"обмеження; зверніться до їх документації."

msgid ""
"The :ref:`Concurrency and multithreading in asyncio <asyncio-"
"multithreading>` section."
msgstr ""
"Розділ :ref:`Параллельність і багатопотоковість в asyncio <asyncio-"
"multithreading>`."

msgid "Examples"
msgstr "Приклади"

msgid ""
"An example using the :class:`~asyncio.subprocess.Process` class to control a "
"subprocess and the :class:`StreamReader` class to read from its standard "
"output."
msgstr ""
"Приклад використання класу :class:`~asyncio.subprocess.Process` для "
"керування підпроцесом і класу :class:`StreamReader` для читання зі "
"стандартного виводу."

msgid ""
"The subprocess is created by the :func:`create_subprocess_exec` function::"
msgstr "Підпроцес створюється функцією :func:`create_subprocess_exec`::"

msgid ""
"See also the :ref:`same example <asyncio_example_subprocess_proto>` written "
"using low-level APIs."
msgstr ""
"Дивіться також :ref:`той же приклад <asyncio_example_subprocess_proto>`, "
"написаний з використанням API низького рівня."
