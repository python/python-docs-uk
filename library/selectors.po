# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-19 01:00+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/selectors.rst:2
msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ""

#: ../../library/selectors.rst:9
msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr "**Вихідний код:** :source:`Lib/selectors.py`"

#: ../../library/selectors.rst:14
msgid "Introduction"
msgstr "Вступ"

#: ../../library/selectors.rst:16
msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon the"
" :mod:`select` module primitives. Users are encouraged to use this module "
"instead, unless they want precise control over the OS-level primitives used."
msgstr ""
"Цей модуль забезпечує високорівневе й ефективне мультиплексування "
"введення/виведення, побудоване на примітивах модуля :mod:`select`. "
"Користувачам рекомендується використовувати замість цього модуль, якщо вони "
"не бажають точного контролю над використовуваними примітивами рівня ОС."

#: ../../library/selectors.rst:20
msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with several "
"concrete implementations (:class:`KqueueSelector`, "
":class:`EpollSelector`...), that can be used to wait for I/O readiness "
"notification on multiple file objects. In the following, \"file object\" "
"refers to any object with a :meth:`~io.IOBase.fileno` method, or a raw file "
"descriptor. See :term:`file object`."
msgstr ""

#: ../../library/selectors.rst:26
msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation "
"available on the current platform: this should be the default choice for "
"most users."
msgstr ""
":class:`DefaultSelector` — це псевдонім найефективнішої реалізації, "
"доступної на поточній платформі: це має бути вибір за умовчанням для "
"більшості користувачів."

#: ../../library/selectors.rst:31
msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported "
"(some other types may be supported as well, such as fifos or special file "
"devices)."
msgstr ""
"Тип підтримуваних файлових об’єктів залежить від платформи: у Windows "
"підтримуються сокети, але не канали, тоді як в Unix підтримуються обидва "
"(можуть підтримуватися й деякі інші типи, наприклад fifos або спеціальні "
"файлові пристрої)."

#: ../../library/selectors.rst:38
msgid ":mod:`select`"
msgstr ":mod:`select`"

#: ../../library/selectors.rst:39
msgid "Low-level I/O multiplexing module."
msgstr "Модуль мультиплексування вводу/виводу низького рівня."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See "
":ref:`wasm-availability` for more information."
msgstr ""

#: ../../library/selectors.rst:44
msgid "Classes"
msgstr "Класи"

#: ../../library/selectors.rst:46
msgid "Classes hierarchy::"
msgstr "Ієрархія класів::"

#: ../../library/selectors.rst:48
msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""

#: ../../library/selectors.rst:56
msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of the "
"modules constants below:"
msgstr ""
"Нижче *події* — це порозрядна маска, що вказує, на які події вводу/виводу "
"слід чекати для певного файлового об’єкта. Це може бути комбінація наведених"
" нижче констант модулів:"

#: ../../library/selectors.rst:61
msgid "Constant"
msgstr "Постійний"

#: ../../library/selectors.rst:61
msgid "Meaning"
msgstr "Значення"

#: ../../library/selectors.rst:63
msgid "Available for read"
msgstr "Доступний для читання"

#: ../../library/selectors.rst:65
msgid "Available for write"
msgstr "Доступний для запису"

#: ../../library/selectors.rst:71
msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event "
"mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""
":class:`SelectorKey` — це :class:`~collections.namedtuple`, який "
"використовується для зв’язування об’єкта файлу з його основним дескриптором "
"файлу, вибраною маскою події та вкладеними даними. Його повертають кілька "
"методів :class:`BaseSelector`."

#: ../../library/selectors.rst:78
msgid "File object registered."
msgstr "Файловий об'єкт зареєстровано."

#: ../../library/selectors.rst:82
msgid "Underlying file descriptor."
msgstr "Базовий файловий дескриптор."

#: ../../library/selectors.rst:86
msgid "Events that must be waited for on this file object."
msgstr "Події, які потрібно очікувати для цього файлового об’єкта."

#: ../../library/selectors.rst:90
msgid ""
"Optional opaque data associated to this file object: for example, this could"
" be used to store a per-client session ID."
msgstr ""
"Додаткові непрозорі дані, пов’язані з цим файловим об’єктом: наприклад, це "
"можна використовувати для зберігання ідентифікатора сеансу кожного клієнта."

#: ../../library/selectors.rst:96
msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on multiple "
"file objects. It supports file stream registration, unregistration, and a "
"method to wait for I/O events on those streams, with an optional timeout. "
"It's an abstract base class, so cannot be instantiated. Use "
":class:`DefaultSelector` instead, or one of :class:`SelectSelector`, "
":class:`KqueueSelector` etc. if you want to specifically use an "
"implementation, and your platform supports it. :class:`BaseSelector` and its"
" concrete implementations support the :term:`context manager` protocol."
msgstr ""
":class:`BaseSelector` використовується для очікування готовності події "
"вводу/виводу для кількох файлових об’єктів. Він підтримує реєстрацію потоку "
"файлів, скасування реєстрації та метод очікування подій введення/виведення в"
" цих потоках із додатковим тайм-аутом. Це абстрактний базовий клас, тому "
"його не можна створити. Замість цього використовуйте "
":class:`DefaultSelector` або один із :class:`SelectSelector`, "
":class:`KqueueSelector` тощо, якщо ви хочете використовувати певну "
"реалізацію, і ваша платформа це підтримує. :class:`BaseSelector` і його "
"конкретні реалізації підтримують протокол :term:`context manager`."

#: ../../library/selectors.rst:108
msgid "Register a file object for selection, monitoring it for I/O events."
msgstr ""
"Зареєструйте файловий об’єкт для вибору, відстежуючи його для подій "
"вводу/виводу."

#: ../../library/selectors.rst:110
msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer file "
"descriptor or an object with a ``fileno()`` method. *events* is a bitwise "
"mask of events to monitor. *data* is an opaque object."
msgstr ""
"*fileobj* — файловий об’єкт для моніторингу. Це може бути цілочисельний "
"файловий дескриптор або об’єкт із методом fileno(). *події* — це побітова "
"маска подій для моніторингу. *data* є непрозорим об’єктом."

#: ../../library/selectors.rst:115
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a "
":exc:`ValueError` in case of invalid event mask or file descriptor, or "
":exc:`KeyError` if the file object is already registered."
msgstr ""
"Це повертає новий екземпляр :class:`SelectorKey` або викликає "
":exc:`ValueError` у разі недійсної маски події чи дескриптора файлу, або "
":exc:`KeyError`, якщо об’єкт файлу вже зареєстровано."

#: ../../library/selectors.rst:121
msgid ""
"Unregister a file object from selection, removing it from monitoring. A file"
" object shall be unregistered prior to being closed."
msgstr ""
"Скасувати реєстрацію файлового об’єкта з вибору, видаливши його з "
"моніторингу. Перед закриттям файлового об’єкта необхідно скасувати "
"реєстрацію."

#: ../../library/selectors.rst:124
msgid "*fileobj* must be a file object previously registered."
msgstr "*fileobj* має бути попередньо зареєстрованим файловим об’єктом."

#: ../../library/selectors.rst:126
msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises a "
":exc:`KeyError` if *fileobj* is not registered.  It will raise "
":exc:`ValueError` if *fileobj* is invalid (e.g. it has no ``fileno()`` "
"method or its ``fileno()`` method has an invalid return value)."
msgstr ""
"Це повертає пов’язаний екземпляр :class:`SelectorKey` або викликає "
":exc:`KeyError`, якщо *fileobj* не зареєстровано. Він викличе "
":exc:`ValueError`, якщо *fileobj* недійсний (наприклад, він не має методу "
"``fileno()`` або його ``fileno()`` метод має недійсне повернуте значення)."

#: ../../library/selectors.rst:133
msgid "Change a registered file object's monitored events or attached data."
msgstr "Змінити події або вкладені дані зареєстрованого файлового об’єкта."

#: ../../library/selectors.rst:135
msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""

#: ../../library/selectors.rst:139
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a "
":exc:`ValueError` in case of invalid event mask or file descriptor, or "
":exc:`KeyError` if the file object is not registered."
msgstr ""
"Це повертає новий екземпляр :class:`SelectorKey` або викликає "
":exc:`ValueError` у разі недійсної маски події чи дескриптора файлу, або "
":exc:`KeyError`, якщо об’єкт файлу не зареєстровано."

#: ../../library/selectors.rst:145
msgid ""
"Wait until some registered file objects become ready, or the timeout "
"expires."
msgstr ""
"Зачекайте, поки деякі зареєстровані файлові об’єкти стануть готовими, або "
"закінчиться час очікування."

#: ../../library/selectors.rst:148
msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently ready "
"file objects. If *timeout* is ``None``, the call will block until a "
"monitored file object becomes ready."
msgstr ""
"Якщо ``timeout > 0``, це визначає максимальний час очікування в секундах. "
"Якщо ``timeout <= 0``, виклик не блокуватиметься, а повідомлятиметься про "
"наразі готові файлові об’єкти. Якщо *timeout* має значення ``None``, виклик "
"блокуватиметься, доки контрольований файловий об’єкт не стане готовим."

#: ../../library/selectors.rst:154
msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr ""
"Це повертає список кортежів ``(ключ, події)``, по одному для кожного "
"готового файлового об’єкта."

#: ../../library/selectors.rst:157
msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""
"*key* — це екземпляр :class:`SelectorKey`, що відповідає готовому файловому "
"об’єкту. *events* — це бітова маска подій, готових для цього файлового "
"об’єкта."

#: ../../library/selectors.rst:162
msgid ""
"This method can return before any file object becomes ready or the timeout "
"has elapsed if the current process receives a signal: in this case, an empty"
" list will be returned."
msgstr ""
"Цей метод може повернутися до того, як будь-який файловий об’єкт стане "
"готовим або мине час очікування, якщо поточний процес отримає сигнал: у "
"цьому випадку буде повернено порожній список."

#: ../../library/selectors.rst:166
msgid ""
"The selector is now retried with a recomputed timeout when interrupted by a "
"signal if the signal handler did not raise an exception (see :pep:`475` for "
"the rationale), instead of returning an empty list of events before the "
"timeout."
msgstr ""
"Тепер селектор виконується повторно з переобчисленим тайм-аутом, коли його "
"перериває сигнал, якщо обробник сигналу не викликав виняткову ситуацію (див."
" :pep:`475` для обґрунтування), замість повернення порожнього списку подій "
"до тайм-ауту."

#: ../../library/selectors.rst:174
msgid "Close the selector."
msgstr "Закрийте селектор."

#: ../../library/selectors.rst:176
msgid ""
"This must be called to make sure that any underlying resource is freed. The "
"selector shall not be used once it has been closed."
msgstr ""
"Це потрібно викликати, щоб переконатися, що будь-який основний ресурс "
"звільнено. Перемикач не можна використовувати після того, як він закритий."

#: ../../library/selectors.rst:181
msgid "Return the key associated with a registered file object."
msgstr "Повертає ключ, пов’язаний із зареєстрованим файловим об’єктом."

#: ../../library/selectors.rst:183
msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""
"Це повертає екземпляр :class:`SelectorKey`, пов’язаний із цим об’єктом "
"файлу, або викликає :exc:`KeyError`, якщо об’єкт файлу не зареєстровано."

#: ../../library/selectors.rst:188
msgid "Return a mapping of file objects to selector keys."
msgstr "Повернути відображення файлових об’єктів на клавіші вибору."

#: ../../library/selectors.rst:190
msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping registered"
" file objects to their associated :class:`SelectorKey` instance."
msgstr ""
"Це повертає екземпляр :class:`~collections.abc.Mapping`, який зіставляє "
"зареєстровані файлові об’єкти з їхнім пов’язаним екземпляром "
":class:`SelectorKey`."

#: ../../library/selectors.rst:197
msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""
"Клас селектора за замовчуванням із використанням найефективнішої реалізації,"
" доступної на поточній платформі. Це має бути вибір за умовчанням для "
"більшості користувачів."

#: ../../library/selectors.rst:204
msgid ":func:`select.select`-based selector."
msgstr "Селектор на основі :func:`select.select`."

#: ../../library/selectors.rst:209
msgid ":func:`select.poll`-based selector."
msgstr "Селектор на основі :func:`select.poll`."

#: ../../library/selectors.rst:214
msgid ":func:`select.epoll`-based selector."
msgstr "Селектор на основі :func:`select.epoll`."

#: ../../library/selectors.rst:218
msgid ""
"This returns the file descriptor used by the underlying :func:`select.epoll`"
" object."
msgstr ""
"Це повертає дескриптор файлу, який використовується базовим об’єктом "
":func:`select.epoll`."

#: ../../library/selectors.rst:223
msgid ":func:`select.devpoll`-based selector."
msgstr "Селектор на основі :func:`select.devpoll`."

#: ../../library/selectors.rst:227
msgid ""
"This returns the file descriptor used by the underlying "
":func:`select.devpoll` object."
msgstr ""
"Це повертає дескриптор файлу, який використовується базовим об’єктом "
":func:`select.devpoll`."

#: ../../library/selectors.rst:234
msgid ":func:`select.kqueue`-based selector."
msgstr ":func:`select.kqueue` селектор."

#: ../../library/selectors.rst:238
msgid ""
"This returns the file descriptor used by the underlying "
":func:`select.kqueue` object."
msgstr ""
"Це повертає дескриптор файлу, який використовується базовим об’єктом "
":func:`select.kqueue`."

#: ../../library/selectors.rst:243
msgid "Examples"
msgstr "Приклади"

#: ../../library/selectors.rst:245
msgid "Here is a simple echo server implementation::"
msgstr "Ось проста реалізація ехо-сервера:"

#: ../../library/selectors.rst:247
msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""
