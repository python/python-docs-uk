# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-12 08:36+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/gc.rst:2
msgid ":mod:`!gc` --- Garbage Collector interface"
msgstr ""

#: ../../library/gc.rst:12
msgid ""
"This module provides an interface to the optional garbage collector.  It "
"provides the ability to disable the collector, tune the collection "
"frequency, and set debugging options.  It also provides access to "
"unreachable objects that the collector found but cannot free.  Since the "
"collector supplements the reference counting already used in Python, you can"
" disable the collector if you are sure your program does not create "
"reference cycles.  Automatic collection can be disabled by calling "
"``gc.disable()``.  To debug a leaking program call "
"``gc.set_debug(gc.DEBUG_LEAK)``. Notice that this includes "
"``gc.DEBUG_SAVEALL``, causing garbage-collected objects to be saved in "
"gc.garbage for inspection."
msgstr ""
"Цей модуль забезпечує інтерфейс для додаткового збирача сміття. Він надає "
"можливість вимкнути збирач, налаштувати частоту збирання та встановити "
"параметри налагодження. Він також надає доступ до недоступних об'єктів, які "
"збирач знайшов, але не може звільнити. Оскільки збирач доповнює підрахунок "
"посилань, який уже використовується в Python, ви можете вимкнути збирач, "
"якщо ви впевнені, що ваша програма не створює цикли посилань. Автоматичний "
"збір можна вимкнути, викликавши ``gc.disable()``. Щоб налагодити витік "
"програми, викличте ``gc.set_debug(gc.DEBUG_LEAK)``. Зверніть увагу, що це "
"включає ``gc.DEBUG_SAVEALL``, змушуючи зібрані об’єкти сміття зберігатися в "
"gc.garbage для перевірки."

#: ../../library/gc.rst:23
msgid "The :mod:`gc` module provides the following functions:"
msgstr "Модуль :mod:`gc` забезпечує такі функції:"

#: ../../library/gc.rst:28
msgid "Enable automatic garbage collection."
msgstr "Увімкнути автоматичний збір сміття."

#: ../../library/gc.rst:33
msgid "Disable automatic garbage collection."
msgstr "Вимкнути автоматичний збір сміття."

#: ../../library/gc.rst:38
msgid "Return ``True`` if automatic collection is enabled."
msgstr "Повертає ``True``, якщо ввімкнено автоматичний збір."

#: ../../library/gc.rst:43
msgid ""
"With no arguments, run a full collection.  The optional argument "
"*generation* may be an integer specifying which generation to collect (from "
"0 to 2).  A :exc:`ValueError` is raised if the generation number is invalid."
" The sum of collected objects and uncollectable objects is returned."
msgstr ""

#: ../../library/gc.rst:48
msgid ""
"The free lists maintained for a number of built-in types are cleared "
"whenever a full collection or collection of the highest generation (2) is "
"run.  Not all items in some free lists may be freed due to the particular "
"implementation, in particular :class:`float`."
msgstr ""
"Безкоштовні списки, які підтримуються для ряду вбудованих типів, очищаються "
"щоразу, коли запускається повна колекція або колекція найвищого покоління "
"(2). Не всі елементи в деяких вільних списках можуть бути звільнені через "
"певну реалізацію, зокрема :class:`float`."

#: ../../library/gc.rst:53
msgid ""
"The effect of calling ``gc.collect()`` while the interpreter is already "
"performing a collection is undefined."
msgstr ""

#: ../../library/gc.rst:59
msgid ""
"Set the garbage collection debugging flags. Debugging information will be "
"written to ``sys.stderr``.  See below for a list of debugging flags which "
"can be combined using bit operations to control debugging."
msgstr ""
"Встановіть позначки налагодження збору сміття. Інформація про налагодження "
"буде записана в ``sys.stderr``. Нижче наведено список прапорів налагодження,"
" які можна комбінувати за допомогою бітових операцій для керування "
"налагодженням."

#: ../../library/gc.rst:66
msgid "Return the debugging flags currently set."
msgstr "Повернути поточні встановлені позначки налагодження."

#: ../../library/gc.rst:71
msgid ""
"Returns a list of all objects tracked by the collector, excluding the list "
"returned. If *generation* is not ``None``, return only the objects tracked "
"by the collector that are in that generation."
msgstr ""

#: ../../library/gc.rst:75
msgid "New *generation* parameter."
msgstr "Новий параметр *generation*."

#: ../../library/gc.rst:78
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_objects`` with argument "
"``generation``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``gc.get_objects`` з аргументом "
"``generation``."

#: ../../library/gc.rst:82
msgid ""
"Return a list of three per-generation dictionaries containing collection "
"statistics since interpreter start.  The number of keys may change in the "
"future, but currently each dictionary will contain the following items:"
msgstr ""
"Повертає список із трьох словників для кожного покоління, що містить "
"статистику збору з моменту запуску інтерпретатора. У майбутньому кількість "
"ключів може змінитися, але наразі кожен словник міститиме такі елементи:"

#: ../../library/gc.rst:87
msgid "``collections`` is the number of times this generation was collected;"
msgstr "``колекції`` — це кількість разів, коли було зібрано це покоління;"

#: ../../library/gc.rst:89
msgid ""
"``collected`` is the total number of objects collected inside this "
"generation;"
msgstr ""
"``collected`` - це загальна кількість об'єктів, зібраних у цій генерації;"

#: ../../library/gc.rst:92
msgid ""
"``uncollectable`` is the total number of objects which were found to be "
"uncollectable (and were therefore moved to the :data:`garbage` list) inside "
"this generation."
msgstr ""
"``uncollectable`` — це загальна кількість об’єктів, які були визнані такими,"
" що неможливо зібрати (і тому були переміщені до списку :data:`garbage`) у "
"цьому поколінні."

#: ../../library/gc.rst:101
msgid ""
"Set the garbage collection thresholds (the collection frequency). Setting "
"*threshold0* to zero disables collection."
msgstr ""
"Встановіть порогові значення збору сміття (частоту збору). Встановлення "
"*threshold0* на нуль вимикає збір."

#: ../../library/gc.rst:104
msgid ""
"The GC classifies objects into three generations depending on how many "
"collection sweeps they have survived.  New objects are placed in the "
"youngest generation (generation ``0``).  If an object survives a collection "
"it is moved into the next older generation.  Since generation ``2`` is the "
"oldest generation, objects in that generation remain there after a "
"collection.  In order to decide when to run, the collector keeps track of "
"the number object allocations and deallocations since the last collection.  "
"When the number of allocations minus the number of deallocations exceeds "
"*threshold0*, collection starts.  Initially only generation ``0`` is "
"examined.  If generation ``0`` has been examined more than *threshold1* "
"times since generation ``1`` has been examined, then generation ``1`` is "
"examined as well. With the third generation, things are a bit more "
"complicated, see `Collecting the oldest generation "
"<https://devguide.python.org/garbage_collector/#collecting-the-oldest-"
"generation>`_ for more information."
msgstr ""
"GC класифікує об’єкти за трьома поколіннями залежно від того, скільки циклів"
" збирання вони пережили. Нові об'єкти поміщаються в наймолодше покоління "
"(генерація ``0``). Якщо об’єкт переживає колекцію, він переміщується до "
"наступного старшого покоління. Оскільки покоління ``2`` є найстарішим "
"поколінням, об'єкти цього покоління залишаються там після колекції. Щоб "
"вирішити, коли запускати, збирач відстежує кількість виділень і звільнень "
"об’єктів з моменту останнього збору. Коли кількість виділень мінус кількість"
" звільнень перевищує *поріг0*, починається збір. Спочатку перевіряється лише"
" покоління ``0``. Якщо покоління ``0`` перевірялося більше ніж *threshold1* "
"разів після перевірки покоління ``1``, тоді також перевіряється покоління "
"``1``. З третім поколінням все трохи складніше, див. `Збір найстарішого "
"покоління <https://devguide.python.org/garbage_collector/#collecting-the-"
"oldest-generation>`_ для отримання додаткової інформації."

#: ../../library/gc.rst:121
msgid ""
"Return the current collection  counts as a tuple of ``(count0, count1, "
"count2)``."
msgstr ""
"Повертає поточну колекцію підрахунків як кортеж ``(count0, count1, "
"count2)``."

#: ../../library/gc.rst:127
msgid ""
"Return the current collection thresholds as a tuple of ``(threshold0, "
"threshold1, threshold2)``."
msgstr ""
"Повертає поточні порогові значення збору як кортеж ``(threshold0, "
"threshold1, threshold2)``."

#: ../../library/gc.rst:133
msgid ""
"Return the list of objects that directly refer to any of objs. This function"
" will only locate those containers which support garbage collection; "
"extension types which do refer to other objects but do not support garbage "
"collection will not be found."
msgstr ""
"Повертає список об’єктів, які безпосередньо посилаються на будь-який з "
"об’єктів. Ця функція знаходитиме лише ті контейнери, які підтримують збір "
"сміття; типи розширень, які посилаються на інші об’єкти, але не підтримують "
"збирання сміття, не будуть знайдені."

#: ../../library/gc.rst:138
msgid ""
"Note that objects which have already been dereferenced, but which live in "
"cycles and have not yet been collected by the garbage collector can be "
"listed among the resulting referrers.  To get only currently live objects, "
"call :func:`collect` before calling :func:`get_referrers`."
msgstr ""
"Зауважте, що об’єкти, які вже було розіменовано, але які живуть у циклах і "
"ще не були зібрані збирачем сміття, можуть бути перераховані серед отриманих"
" посилань. Щоб отримати лише активні об’єкти, викликайте :func:`collect` "
"перед викликом :func:`get_referrers`."

#: ../../library/gc.rst:144
msgid ""
"Care must be taken when using objects returned by :func:`get_referrers` "
"because some of them could still be under construction and hence in a "
"temporarily invalid state. Avoid using :func:`get_referrers` for any purpose"
" other than debugging."
msgstr ""
"Необхідно бути обережним, використовуючи об’єкти, які повертає "
":func:`get_referrers`, тому що деякі з них все ще можуть перебувати в стадії"
" розробки і, отже, у тимчасово недійсному стані. Уникайте використання "
":func:`get_referrers` для будь-яких цілей, окрім налагодження."

#: ../../library/gc.rst:149
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_referrers`` with "
"argument ``objs``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``gc.get_referrers`` з аргументом "
"``objs``."

#: ../../library/gc.rst:154
msgid ""
"Return a list of objects directly referred to by any of the arguments. The "
"referents returned are those objects visited by the arguments' C-level "
":c:member:`~PyTypeObject.tp_traverse` methods (if any), and may not be all "
"objects actually directly reachable.  :c:member:`~PyTypeObject.tp_traverse` "
"methods are supported only by objects that support garbage collection, and "
"are only required to visit objects that may be involved in a cycle.  So, for"
" example, if an integer is directly reachable from an argument, that integer"
" object may or may not appear in the result list."
msgstr ""
"Повертає список об’єктів, на які безпосередньо посилається будь-який з "
"аргументів. Повернуті референти — це ті об’єкти, відвідані методами "
"аргументів C-level :c:member:`~PyTypeObject.tp_traverse` (якщо такі є), і "
"можуть бути не всі об’єкти, фактично доступні безпосередньо. "
":c:member:`~PyTypeObject.tp_traverse` методи підтримуються лише об’єктами, "
"які підтримують збирання сміття, і потрібні лише для відвідування об’єктів, "
"які можуть брати участь у циклі. Так, наприклад, якщо ціле число доступне "
"безпосередньо з аргументу, цей цілочисельний об’єкт може з’явитися або не "
"з’явитися у списку результатів."

#: ../../library/gc.rst:162
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_referents`` with "
"argument ``objs``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``gc.get_referents`` з аргументом "
"``objs``."

#: ../../library/gc.rst:166
msgid ""
"Returns ``True`` if the object is currently tracked by the garbage "
"collector, ``False`` otherwise.  As a general rule, instances of atomic "
"types aren't tracked and instances of non-atomic types (containers, user-"
"defined objects...) are.  However, some type-specific optimizations can be "
"present in order to suppress the garbage collector footprint of simple "
"instances (e.g. dicts containing only atomic keys and values)::"
msgstr ""
"Повертає ``True``, якщо об’єкт наразі відстежується збирачем сміття, "
"``False`` інакше. Як правило, екземпляри атомарних типів не відстежуються, а"
" екземпляри неатомарних типів (контейнери, об’єкти, визначені "
"користувачем...) відстежуються. Проте деякі типи оптимізації можуть бути "
"присутні, щоб придушити слід збирача сміття простих екземплярів (наприклад, "
"dicts, що містять лише атомарні ключі та значення):"

#: ../../library/gc.rst:173
msgid ""
">>> gc.is_tracked(0)\n"
"False\n"
">>> gc.is_tracked(\"a\")\n"
"False\n"
">>> gc.is_tracked([])\n"
"True\n"
">>> gc.is_tracked({})\n"
"False\n"
">>> gc.is_tracked({\"a\": 1})\n"
"False\n"
">>> gc.is_tracked({\"a\": []})\n"
"True"
msgstr ""

#: ../../library/gc.rst:191
msgid ""
"Returns ``True`` if the given object has been finalized by the garbage "
"collector, ``False`` otherwise. ::"
msgstr ""
"Повертає ``True``, якщо даний об’єкт був завершений збирачем сміття, "
"``False`` інакше. ::"

#: ../../library/gc.rst:194
msgid ""
">>> x = None\n"
">>> class Lazarus:\n"
"...     def __del__(self):\n"
"...         global x\n"
"...         x = self\n"
"...\n"
">>> lazarus = Lazarus()\n"
">>> gc.is_finalized(lazarus)\n"
"False\n"
">>> del lazarus\n"
">>> gc.is_finalized(x)\n"
"True"
msgstr ""

#: ../../library/gc.rst:212
msgid ""
"Freeze all the objects tracked by the garbage collector; move them to a "
"permanent generation and ignore them in all the future collections."
msgstr ""

#: ../../library/gc.rst:215
msgid ""
"If a process will ``fork()`` without ``exec()``, avoiding unnecessary copy-"
"on-write in child processes will maximize memory sharing and reduce overall "
"memory usage. This requires both avoiding creation of freed \"holes\" in "
"memory pages in the parent process and ensuring that GC collections in child"
" processes won't touch the ``gc_refs`` counter of long-lived objects "
"originating in the parent process. To accomplish both, call ``gc.disable()``"
" early in the parent process, ``gc.freeze()`` right before ``fork()``, and "
"``gc.enable()`` early in child processes."
msgstr ""

#: ../../library/gc.rst:229
msgid ""
"Unfreeze the objects in the permanent generation, put them back into the "
"oldest generation."
msgstr ""
"Розморозити об’єкти в постійному поколінні, повернути їх у найстаріше "
"покоління."

#: ../../library/gc.rst:237
msgid "Return the number of objects in the permanent generation."
msgstr "Повертає кількість об’єктів у постійній генерації."

#: ../../library/gc.rst:242
msgid ""
"The following variables are provided for read-only access (you can mutate "
"the values but should not rebind them):"
msgstr ""
"Наступні змінні надаються для доступу лише для читання (ви можете змінити "
"значення, але не повинні їх повторно прив’язувати):"

#: ../../library/gc.rst:247
msgid ""
"A list of objects which the collector found to be unreachable but could not "
"be freed (uncollectable objects).  Starting with Python 3.4, this list "
"should be empty most of the time, except when using instances of C extension"
" types with a non-``NULL`` ``tp_del`` slot."
msgstr ""
"Список об’єктів, які збирач виявив недоступними, але не міг звільнити "
"(незбірні об’єкти). Починаючи з Python 3.4, цей список має бути порожнім "
"більшу частину часу, за винятком випадків використання екземплярів типів "
"розширень C із слотом ``tp_del``, відмінним від ``NULL``."

#: ../../library/gc.rst:252
msgid ""
"If :const:`DEBUG_SAVEALL` is set, then all unreachable objects will be added"
" to this list rather than freed."
msgstr ""
"Якщо встановлено :const:`DEBUG_SAVEALL`, усі недоступні об’єкти будуть "
"додані до цього списку, а не звільнені."

#: ../../library/gc.rst:255
msgid ""
"If this list is non-empty at :term:`interpreter shutdown`, a "
":exc:`ResourceWarning` is emitted, which is silent by default.  If "
":const:`DEBUG_UNCOLLECTABLE` is set, in addition all uncollectable objects "
"are printed."
msgstr ""
"Якщо цей список не порожній під час :term:`interpreter shutdown`, видається "
":exc:`ResourceWarning`, яке за замовчуванням мовчить. Якщо встановлено "
":const:`DEBUG_UNCOLLECTABLE`, додатково друкуються всі об’єкти, які "
"неможливо зібрати."

#: ../../library/gc.rst:261
msgid ""
"Following :pep:`442`, objects with a :meth:`~object.__del__` method don't "
"end up in :data:`gc.garbage` anymore."
msgstr ""

#: ../../library/gc.rst:267
msgid ""
"A list of callbacks that will be invoked by the garbage collector before and"
" after collection.  The callbacks will be called with two arguments, *phase*"
" and *info*."
msgstr ""
"Список зворотних викликів, які будуть викликані збирачем сміття до і після "
"збирання. Зворотні виклики будуть викликані з двома аргументами, *phase* та "
"*info*."

#: ../../library/gc.rst:271
msgid "*phase* can be one of two values:"
msgstr "*phase* може бути одним із двох значень:"

#: ../../library/gc.rst:273
msgid "\"start\": The garbage collection is about to start."
msgstr "\"start\": збирання сміття ось-ось розпочнеться."

#: ../../library/gc.rst:275
msgid "\"stop\": The garbage collection has finished."
msgstr "\"стоп\": збирання сміття завершено."

#: ../../library/gc.rst:277
msgid ""
"*info* is a dict providing more information for the callback.  The following"
" keys are currently defined:"
msgstr ""
"*info* — це dict, що надає більше інформації для зворотного виклику. Наразі "
"визначено такі ключі:"

#: ../../library/gc.rst:280
msgid "\"generation\": The oldest generation being collected."
msgstr "\"генерація\": збирається найстаріше покоління."

#: ../../library/gc.rst:282
msgid ""
"\"collected\": When *phase* is \"stop\", the number of objects successfully "
"collected."
msgstr ""
"\"collected\": коли *phase* має значення \"stop\", кількість успішно "
"зібраних об'єктів."

#: ../../library/gc.rst:285
msgid ""
"\"uncollectable\": When *phase* is \"stop\", the number of objects that "
"could not be collected and were put in :data:`garbage`."
msgstr ""
"\"uncollectable\": коли *phase* має значення \"stop\", кількість об'єктів, "
"які не вдалося зібрати та були поміщені в :data:`garbage`."

#: ../../library/gc.rst:288
msgid ""
"Applications can add their own callbacks to this list.  The primary use "
"cases are:"
msgstr ""
"Програми можуть додавати власні зворотні виклики до цього списку. Основні "
"випадки використання:"

#: ../../library/gc.rst:291
msgid ""
"Gathering statistics about garbage collection, such as how often various "
"generations are collected, and how long the collection takes."
msgstr ""
"Збір статистики щодо збирання сміття, наприклад, як часто збираються різні "
"покоління та скільки часу займає збір."

#: ../../library/gc.rst:295
msgid ""
"Allowing applications to identify and clear their own uncollectable types "
"when they appear in :data:`garbage`."
msgstr ""
"Дозволяє програмам ідентифікувати та очищати власні типи, які не можна "
"збирати, коли вони з’являються в :data:`garbage`."

#: ../../library/gc.rst:301
msgid "The following constants are provided for use with :func:`set_debug`:"
msgstr "Наступні константи надаються для використання з :func:`set_debug`:"

#: ../../library/gc.rst:306
msgid ""
"Print statistics during collection.  This information can be useful when "
"tuning the collection frequency."
msgstr ""
"Роздрукувати статистику під час збору. Ця інформація може бути корисною під "
"час налаштування частоти збору."

#: ../../library/gc.rst:312
msgid "Print information on collectable objects found."
msgstr "Роздрукуйте інформацію про знайдені предмети колекціонування."

#: ../../library/gc.rst:317
msgid ""
"Print information of uncollectable objects found (objects which are not "
"reachable but cannot be freed by the collector).  These objects will be "
"added to the ``garbage`` list."
msgstr ""
"Друк інформації про знайдені об’єкти, які не можна збирати (об’єкти, які "
"недоступні, але не можуть бути звільнені колекціонером). Ці об’єкти будуть "
"додані до списку ``сміття``."

#: ../../library/gc.rst:321
msgid ""
"Also print the contents of the :data:`garbage` list at :term:`interpreter "
"shutdown`, if it isn't empty."
msgstr ""
"Також вивести вміст списку :data:`garbage` у :term:`interpreter shutdown`, "
"якщо він не порожній."

#: ../../library/gc.rst:327
msgid ""
"When set, all unreachable objects found will be appended to *garbage* rather"
" than being freed.  This can be useful for debugging a leaking program."
msgstr ""
"Якщо встановлено, усі знайдені недоступні об’єкти будуть додані до *сміття*,"
" а не звільнені. Це може бути корисно для налагодження витоку програми."

#: ../../library/gc.rst:333
msgid ""
"The debugging flags necessary for the collector to print information about a"
" leaking program (equal to ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_SAVEALL``)."
msgstr ""
"Прапори налагодження, необхідні збирачеві для друку інформації про витік "
"програми (рівні ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_SAVEALL``)."
