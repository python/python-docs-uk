# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:04+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`email.contentmanager`: Managing MIME Content"
msgstr ":mod:`email.contentmanager`: Керування вмістом MIME"

msgid "**Source code:** :source:`Lib/email/contentmanager.py`"
msgstr "**Вихідний код:** :source:`Lib/email/contentmanager.py`"

msgid "[1]_"
msgstr "[1]_"

msgid ""
"Base class for content managers.  Provides the standard registry mechanisms "
"to register converters between MIME content and other representations, as "
"well as the ``get_content`` and ``set_content`` dispatch methods."
msgstr ""
"Базовий клас для менеджерів вмісту. Надає стандартні механізми реєстру для "
"реєстрації конвертерів між вмістом MIME та іншими представленнями, а також "
"методи відправлення ``get_content`` і ``set_content``."

msgid ""
"Look up a handler function based on the ``mimetype`` of *msg* (see next "
"paragraph), call it, passing through all arguments, and return the result of "
"the call.  The expectation is that the handler will extract the payload from "
"*msg* and return an object that encodes information about the extracted data."
msgstr ""
"Знайдіть функцію обробки на основі ``mimetype`` *msg* (див. наступний "
"параграф), викличте її, передаючи всі аргументи, і поверніть результат "
"виклику. Очікується, що обробник витягне корисне навантаження з *msg* і "
"поверне об’єкт, який кодує інформацію про витягнуті дані."

msgid ""
"To find the handler, look for the following keys in the registry, stopping "
"with the first one found:"
msgstr ""
"Щоб знайти обробник, знайдіть такі розділи в реєстрі, зупинившись на першому "
"знайденому:"

msgid "the string representing the full MIME type (``maintype/subtype``)"
msgstr "рядок, що представляє повний тип MIME (``maintype/subtype``)"

msgid "the string representing the ``maintype``"
msgstr "рядок, що представляє ``maintype``"

msgid "the empty string"
msgstr "порожній рядок"

msgid ""
"If none of these keys produce a handler, raise a :exc:`KeyError` for the "
"full MIME type."
msgstr ""
"Якщо жоден із цих ключів не створює обробник, викличте :exc:`KeyError` для "
"повного типу MIME."

msgid ""
"If the ``maintype`` is ``multipart``, raise a :exc:`TypeError`; otherwise "
"look up a handler function based on the type of *obj* (see next paragraph), "
"call :meth:`~email.message.EmailMessage.clear_content` on the *msg*, and "
"call the handler function, passing through all arguments.  The expectation "
"is that the handler will transform and store *obj* into *msg*, possibly "
"making other changes to *msg* as well, such as adding various MIME headers "
"to encode information needed to interpret the stored data."
msgstr ""
"Якщо ``maintype`` є ``multipart``, викликати :exc:`TypeError`; інакше "
"знайдіть функцію обробки на основі типу *obj* (див. наступний абзац), "
"викличте :meth:`~email.message.EmailMessage.clear_content` у *msg* та "
"викликайте функцію обробки, передаючи всі аргументи . Очікується, що "
"обробник перетворить і збереже *obj* в *msg*, можливо також вносячи інші "
"зміни в *msg*, наприклад додаючи різні заголовки MIME для кодування "
"інформації, необхідної для інтерпретації збережених даних."

msgid ""
"To find the handler, obtain the type of *obj* (``typ = type(obj)``), and "
"look for the following keys in the registry, stopping with the first one "
"found:"
msgstr ""
"Щоб знайти обробник, отримайте тип *obj* (``typ = type(obj)``) і знайдіть "
"наступні ключі в реєстрі, зупиняючись на першому знайденому:"

msgid "the type itself (``typ``)"
msgstr "сам тип (``typ``)"

msgid ""
"the type's fully qualified name (``typ.__module__ + '.' + typ."
"__qualname__``)."
msgstr "повне ім’я типу (``typ.__module__ + '.' + typ.__qualname__``)."

msgid "the type's qualname (``typ.__qualname__``)"
msgstr "qualname типу (``typ.__qualname__``)"

msgid "the type's name (``typ.__name__``)."
msgstr "назва типу (``typ.__name__``)."

msgid ""
"If none of the above match, repeat all of the checks above for each of the "
"types in the :term:`MRO` (``typ.__mro__``).  Finally, if no other key yields "
"a handler, check for a handler for the key ``None``.  If there is no handler "
"for ``None``, raise a :exc:`KeyError` for the fully qualified name of the "
"type."
msgstr ""
"Якщо нічого з наведеного вище не відповідає, повторіть усі перевірки, "
"наведені вище, для кожного типу в :term:`MRO` (``typ.__mro__``). Нарешті, "
"якщо жоден інший ключ не дає обробника, перевірте наявність обробника для "
"ключа ``None``. Якщо немає обробника для ``None``, підніміть :exc:`KeyError` "
"для повної назви типу."

msgid ""
"Also add a :mailheader:`MIME-Version` header if one is not present (see "
"also :class:`.MIMEPart`)."
msgstr ""
"Також додайте заголовок :mailheader:`MIME-Version`, якщо його немає (див. "
"також :class:`.MIMEPart`)."

msgid ""
"Record the function *handler* as the handler for *key*.  For the possible "
"values of *key*, see :meth:`get_content`."
msgstr ""
"Запишіть функцію *обробник* як обробник для *ключа*. Можливі значення *key* "
"див. у :meth:`get_content`."

msgid ""
"Record *handler* as the function to call when an object of a type matching "
"*typekey* is passed to :meth:`set_content`.  For the possible values of "
"*typekey*, see :meth:`set_content`."
msgstr ""
"Запишіть *обробник* як функцію для виклику, коли об’єкт типу, який "
"відповідає *typekey*, передається до :meth:`set_content`. Можливі значення "
"*typekey* див. у :meth:`set_content`."

msgid "Content Manager Instances"
msgstr "Примірники Content Manager"

msgid ""
"Currently the email package provides only one concrete content manager, :"
"data:`raw_data_manager`, although more may be added in the future. :data:"
"`raw_data_manager` is the :attr:`~email.policy.EmailPolicy.content_manager` "
"provided by :attr:`~email.policy.EmailPolicy` and its derivatives."
msgstr ""
"Наразі пакет електронної пошти містить лише один конкретний менеджер "
"вмісту, :data:`raw_data_manager`, хоча в майбутньому може бути додано "
"більше. :data:`raw_data_manager` — це :attr:`~email.policy.EmailPolicy."
"content_manager`, наданий :attr:`~email.policy.EmailPolicy` та його "
"похідними."

msgid ""
"This content manager provides only a minimum interface beyond that provided "
"by :class:`~email.message.Message` itself:  it deals only with text, raw "
"byte strings, and :class:`~email.message.Message` objects.  Nevertheless, it "
"provides significant advantages compared to the base API: ``get_content`` on "
"a text part will return a unicode string without the application needing to "
"manually decode it, ``set_content`` provides a rich set of options for "
"controlling the headers added to a part and controlling the content transfer "
"encoding, and it enables the use of the various ``add_`` methods, thereby "
"simplifying the creation of multipart messages."
msgstr ""
"Цей менеджер вмісту надає лише мінімальний інтерфейс, окрім того, який надає "
"сам :class:`~email.message.Message`: він має справу лише з текстом, "
"необробленими рядками байтів та об’єктами :class:`~email.message.Message`. "
"Тим не менш, він надає значні переваги порівняно з базовим API: "
"``get_content`` у текстовій частині поверне рядок Unicode без необхідності "
"програми вручну декодувати його, ``set_content`` надає багатий набір "
"параметрів для керування заголовками додається до частини та контролює "
"кодування передачі вмісту, а також дозволяє використовувати різні методи "
"``add_``, тим самим спрощуючи створення багатокомпонентних повідомлень."

msgid ""
"Return the payload of the part as either a string (for ``text`` parts), an :"
"class:`~email.message.EmailMessage` object (for ``message/rfc822`` parts), "
"or a ``bytes`` object (for all other non-multipart types).  Raise a :exc:"
"`KeyError` if called on a ``multipart``.  If the part is a ``text`` part and "
"*errors* is specified, use it as the error handler when decoding the payload "
"to unicode.  The default error handler is ``replace``."
msgstr ""
"Повертає корисне навантаження частини як рядок (для частин ``text``), "
"об’єкт :class:`~email.message.EmailMessage` (для частин ``message/rfc822``) "
"або ``bytes`` об'єкт (для всіх інших нескладних типів). Викликає :exc:"
"`KeyError`, якщо викликається на ``multipart``. Якщо частина є частиною "
"``text`` і вказано *errors*, використовуйте її як обробник помилок під час "
"декодування корисного навантаження в Юнікод. Обробником помилок за "
"замовчуванням є ``replace``."

msgid "Add headers and payload to *msg*:"
msgstr "Додайте заголовки та корисне навантаження до *повідомлення*:"

msgid ""
"Add a :mailheader:`Content-Type` header with a ``maintype/subtype`` value."
msgstr ""
"Додайте заголовок :mailheader:`Content-Type` зі значенням ``maintype/"
"subtype``."

msgid ""
"For ``str``, set the MIME ``maintype`` to ``text``, and set the subtype to "
"*subtype* if it is specified, or ``plain`` if it is not."
msgstr ""
"Для ``str`` встановіть ``maintype`` MIME на ``text`` і встановіть підтип на "
"*subtype*, якщо він указаний, або ``plain``, якщо він не вказано."

msgid ""
"For ``bytes``, use the specified *maintype* and *subtype*, or raise a :exc:"
"`TypeError` if they are not specified."
msgstr ""
"Для ``bytes`` використовуйте вказані *maintype* і *subtype* або викликайте :"
"exc:`TypeError`, якщо вони не вказані."

msgid ""
"For :class:`~email.message.EmailMessage` objects, set the maintype to "
"``message``, and set the subtype to *subtype* if it is specified or "
"``rfc822`` if it is not.  If *subtype* is ``partial``, raise an error "
"(``bytes`` objects must be used to construct ``message/partial`` parts)."
msgstr ""
"Для об’єктів :class:`~email.message.EmailMessage` встановіть основний тип як "
"``message``, а для підтипу встановіть *subtype*, якщо він указаний, або "
"``rfc822``, якщо його немає. Якщо *subtype* має значення ``partial``, "
"виникає помилка (об’єкти ``bytes`` повинні використовуватися для створення "
"частин ``message/partial``)."

msgid ""
"If *charset* is provided (which is valid only for ``str``), encode the "
"string to bytes using the specified character set.  The default is "
"``utf-8``.  If the specified *charset* is a known alias for a standard MIME "
"charset name, use the standard charset instead."
msgstr ""
"Якщо надано *charset* (який дійсний лише для ``str``), закодуйте рядок у "
"байти за допомогою вказаного набору символів. Типовим є ``utf-8``. Якщо "
"вказаний *набір символів* є відомим псевдонімом для назви стандартного "
"набору кодів MIME, замість цього використовуйте стандартний набір символів."

msgid ""
"If *cte* is set, encode the payload using the specified content transfer "
"encoding, and set the :mailheader:`Content-Transfer-Encoding` header to that "
"value.  Possible values for *cte* are ``quoted-printable``, ``base64``, "
"``7bit``, ``8bit``, and ``binary``.  If the input cannot be encoded in the "
"specified encoding (for example, specifying a *cte* of ``7bit`` for an input "
"that contains non-ASCII values), raise a :exc:`ValueError`."
msgstr ""
"Якщо встановлено *cte*, закодуйте корисне навантаження, використовуючи "
"вказане кодування передачі вмісту, і встановіть це значення для заголовка :"
"mailheader:`Content-Transfer-Encoding`. Можливі значення для *cte*: ``quoted-"
"printable``, ``base64``, ``7bit``, ``8bit`` і ``binary``. Якщо вхідні дані "
"не можна закодувати у вказаному кодуванні (наприклад, вказавши *cte* "
"``7bit`` для вхідних даних, які містять значення, відмінні від ASCII), "
"викликайте :exc:`ValueError`."

msgid ""
"For ``str`` objects, if *cte* is not set use heuristics to determine the "
"most compact encoding."
msgstr ""
"Для об’єктів ``str``, якщо *cte* не встановлено, використовуйте евристику "
"для визначення найбільш компактного кодування."

msgid ""
"For :class:`~email.message.EmailMessage`, per :rfc:`2046`, raise an error if "
"a *cte* of ``quoted-printable`` or ``base64`` is requested for *subtype* "
"``rfc822``, and for any *cte* other than ``7bit`` for *subtype* ``external-"
"body``.  For ``message/rfc822``, use ``8bit`` if *cte* is not specified.  "
"For all other values of *subtype*, use ``7bit``."
msgstr ""
"Для :class:`~email.message.EmailMessage`, відповідно до :rfc:`2046`, "
"викликати помилку, якщо *cte* ``quoted-printable`` або ``base64`` "
"запитується для *підтипу* ``rfc822`` і для будь-якого *cte*, крім ``7bit`` "
"для *підтипу* ``external-body``. Для ``message/rfc822`` використовуйте "
"``8bit``, якщо *cte* не вказано. Для всіх інших значень *subtype* "
"використовуйте ``7bit``."

msgid ""
"A *cte* of ``binary`` does not actually work correctly yet. The "
"``EmailMessage`` object as modified by ``set_content`` is correct, but :"
"class:`~email.generator.BytesGenerator` does not serialize it correctly."
msgstr ""
"*cte* ``binary`` насправді ще не працює належним чином. Об’єкт "
"``EmailMessage``, змінений ``set_content`` є правильним, але :class:`~email."
"generator.BytesGenerator` не серіалізує його правильно."

msgid ""
"If *disposition* is set, use it as the value of the :mailheader:`Content-"
"Disposition` header.  If not specified, and *filename* is specified, add the "
"header with the value ``attachment``. If *disposition* is not specified and "
"*filename* is also not specified, do not add the header.  The only valid "
"values for *disposition* are ``attachment`` and ``inline``."
msgstr ""
"Якщо встановлено *disposition*, використовуйте його як значення заголовка :"
"mailheader:`Content-Disposition`. Якщо не вказано, але вказано *filename*, "
"додайте заголовок зі значенням ``attachment``. Якщо *disposition* не вказано "
"і *filename* також не вказано, не додавайте заголовок. Єдиними дійсними "
"значеннями для *disposition* є ``attachment`` і ``inline``."

msgid ""
"If *filename* is specified, use it as the value of the ``filename`` "
"parameter of the :mailheader:`Content-Disposition` header."
msgstr ""
"Якщо вказано *filename*, використовуйте його як значення параметра "
"``filename`` заголовка :mailheader:`Content-Disposition`."

msgid ""
"If *cid* is specified, add a :mailheader:`Content-ID` header with *cid* as "
"its value."
msgstr ""
"Якщо вказано *cid*, додайте заголовок :mailheader:`Content-ID` зі значенням "
"*cid*."

msgid ""
"If *params* is specified, iterate its ``items`` method and use the resulting "
"``(key, value)`` pairs to set additional parameters on the :mailheader:"
"`Content-Type` header."
msgstr ""
"Якщо вказано *params*, повторіть його метод ``items`` і використовуйте "
"отримані пари ``(key, value)``, щоб установити додаткові параметри в "
"заголовку :mailheader:`Content-Type`."

msgid ""
"If *headers* is specified and is a list of strings of the form ``headername: "
"headervalue`` or a list of ``header`` objects (distinguished from strings by "
"having a ``name`` attribute), add the headers to *msg*."
msgstr ""
"Якщо вказано *headers* і це список рядків у формі ``назва заголовка: "
"значення заголовка`` або список об’єктів ``заголовка`` (відрізняються від "
"рядків наявністю атрибута ``назва``), додайте заголовки на *повідомлення*."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional package>`"
msgstr ""
"Спочатку додано в 3.4 як :term:`проміжний модуль <provisional package>`"
