# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Low-level API Index"
msgstr "Індекс API низького рівня"

msgid "This page lists all low-level asyncio APIs."
msgstr "На цій сторінці перераховано всі асинхронні API низького рівня."

msgid "Obtaining the Event Loop"
msgstr "Отримання циклу подій"

msgid ":func:`asyncio.get_running_loop`"
msgstr ":func:`asyncio.get_running_loop`"

msgid "The **preferred** function to get the running event loop."
msgstr "**Переважна** функція для отримання запущеного циклу подій."

msgid ":func:`asyncio.get_event_loop`"
msgstr ":func:`asyncio.get_event_loop`"

msgid "Get an event loop instance (current or via the policy)."
msgstr "Отримати екземпляр циклу подій (поточний або через політику)."

msgid ":func:`asyncio.set_event_loop`"
msgstr ":func:`asyncio.set_event_loop`"

msgid "Set the event loop as current via the current policy."
msgstr "Установіть цикл подій як поточний за допомогою поточної політики."

msgid ":func:`asyncio.new_event_loop`"
msgstr ":func:`asyncio.new_event_loop`"

msgid "Create a new event loop."
msgstr "Створіть новий цикл подій."

msgid "Examples"
msgstr "Приклади"

msgid ":ref:`Using asyncio.get_running_loop() <asyncio_example_future>`."
msgstr ""
":ref:`Використання asyncio.get_running_loop() <asyncio_example_future>`."

msgid "Event Loop Methods"
msgstr "Методи циклу подій"

msgid ""
"See also the main documentation section about the :ref:`event loop methods "
"<asyncio-event-loop>`."
msgstr ""
"Дивіться також розділ основної документації про :ref:`методи циклу подій "
"<asyncio-event-loop>`."

msgid "Lifecycle"
msgstr "Життєвий цикл"

msgid ":meth:`loop.run_until_complete`"
msgstr ":meth:`loop.run_until_complete`"

msgid "Run a Future/Task/awaitable until complete."
msgstr "Запустіть Future/Task/waitable до завершення."

msgid ":meth:`loop.run_forever`"
msgstr ":meth:`loop.run_forever`"

msgid "Run the event loop forever."
msgstr "Запустити цикл подій назавжди."

msgid ":meth:`loop.stop`"
msgstr ":meth:`loop.stop`"

msgid "Stop the event loop."
msgstr "Зупиніть цикл подій."

msgid ":meth:`loop.close`"
msgstr ":meth:`loop.close`"

msgid "Close the event loop."
msgstr "Закрийте цикл подій."

msgid ":meth:`loop.is_running()`"
msgstr ":meth:`loop.is_running()`"

msgid "Return ``True`` if the event loop is running."
msgstr "Повертає ``True``, якщо запущено цикл подій."

msgid ":meth:`loop.is_closed()`"
msgstr ":meth:`loop.is_closed()`"

msgid "Return ``True`` if the event loop is closed."
msgstr "Повертає ``True``, якщо цикл події закрито."

msgid "``await`` :meth:`loop.shutdown_asyncgens`"
msgstr "``чекати`` :meth:`loop.shutdown_asyncgens`"

msgid "Close asynchronous generators."
msgstr "Закрити асинхронні генератори."

msgid "Debugging"
msgstr "Налагодження"

msgid ":meth:`loop.set_debug`"
msgstr ":meth:`loop.set_debug`"

msgid "Enable or disable the debug mode."
msgstr "Увімкніть або вимкніть режим налагодження."

msgid ":meth:`loop.get_debug`"
msgstr ":meth:`loop.get_debug`"

msgid "Get the current debug mode."
msgstr "Отримати поточний режим налагодження."

msgid "Scheduling Callbacks"
msgstr "Планування зворотних викликів"

msgid ":meth:`loop.call_soon`"
msgstr ":meth:`loop.call_soon`"

msgid "Invoke a callback soon."
msgstr "Незабаром викликайте зворотний дзвінок."

msgid ":meth:`loop.call_soon_threadsafe`"
msgstr ":meth:`loop.call_soon_threadsafe`"

msgid "A thread-safe variant of :meth:`loop.call_soon`."
msgstr "Потоково-безпечний варіант :meth:`loop.call_soon`."

msgid ":meth:`loop.call_later`"
msgstr ":meth:`loop.call_later`"

msgid "Invoke a callback *after* the given time."
msgstr "Викликати зворотний виклик *після* вказаного часу."

msgid ":meth:`loop.call_at`"
msgstr ":meth:`loop.call_at`"

msgid "Invoke a callback *at* the given time."
msgstr "Викликати зворотний виклик *у* вказаний час."

msgid "Thread/Process Pool"
msgstr "Пул потоків/процесів"

msgid "``await`` :meth:`loop.run_in_executor`"
msgstr "``чекати`` :meth:`loop.run_in_executor`"

msgid ""
"Run a CPU-bound or other blocking function in a :mod:`concurrent.futures` "
"executor."
msgstr ""
"Запустіть пов’язану з ЦП функцію або іншу функцію блокування у виконавці :"
"mod:`concurrent.futures`."

msgid ":meth:`loop.set_default_executor`"
msgstr ":meth:`loop.set_default_executor`"

msgid "Set the default executor for :meth:`loop.run_in_executor`."
msgstr ""
"Встановити виконавця за замовчуванням для :meth:`loop.run_in_executor`."

msgid "Tasks and Futures"
msgstr "Завдання та майбутнє"

msgid ":meth:`loop.create_future`"
msgstr ":meth:`loop.create_future`"

msgid "Create a :class:`Future` object."
msgstr "Створіть об’єкт :class:`Future`."

msgid ":meth:`loop.create_task`"
msgstr ":meth:`loop.create_task`"

msgid "Schedule coroutine as a :class:`Task`."
msgstr "Розклад співпрограми як :class:`Task`."

msgid ":meth:`loop.set_task_factory`"
msgstr ":meth:`loop.set_task_factory`"

msgid ""
"Set a factory used by :meth:`loop.create_task` to create :class:`Tasks "
"<Task>`."
msgstr ""
"Установіть фабрику, яку використовує :meth:`loop.create_task` для створення :"
"class:`Tasks <Task>`."

msgid ":meth:`loop.get_task_factory`"
msgstr ":meth:`loop.get_task_factory`"

msgid ""
"Get the factory :meth:`loop.create_task` uses to create :class:`Tasks "
"<Task>`."
msgstr ""
"Отримайте фабрику, яку :meth:`loop.create_task` використовує для створення :"
"class:`Tasks <Task>`."

msgid "DNS"
msgstr "DNS"

msgid "``await`` :meth:`loop.getaddrinfo`"
msgstr "``чекати`` :meth:`loop.getaddrinfo`"

msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Асинхронна версія :meth:`socket.getaddrinfo`."

msgid "``await`` :meth:`loop.getnameinfo`"
msgstr "``чекати`` :meth:`loop.getnameinfo`"

msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Асинхронна версія :meth:`socket.getnameinfo`."

msgid "Networking and IPC"
msgstr "Мережа та IPC"

msgid "``await`` :meth:`loop.create_connection`"
msgstr "``чекати`` :meth:`loop.create_connection`"

msgid "Open a TCP connection."
msgstr "Відкрийте TCP-з'єднання."

msgid "``await`` :meth:`loop.create_server`"
msgstr "``чекати`` :meth:`loop.create_server`"

msgid "Create a TCP server."
msgstr "Створіть сервер TCP."

msgid "``await`` :meth:`loop.create_unix_connection`"
msgstr "``чекати`` :meth:`loop.create_unix_connection`"

msgid "Open a Unix socket connection."
msgstr "Відкрийте підключення сокета Unix."

msgid "``await`` :meth:`loop.create_unix_server`"
msgstr "``чекати`` :meth:`loop.create_unix_server`"

msgid "Create a Unix socket server."
msgstr "Створіть сокет-сервер Unix."

msgid "``await`` :meth:`loop.connect_accepted_socket`"
msgstr "``чекати`` :meth:`loop.connect_accepted_socket`"

msgid "Wrap a :class:`~socket.socket` into a ``(transport, protocol)`` pair."
msgstr "Оберніть :class:`~socket.socket` в пару ``(транспорт, протокол)``."

msgid "``await`` :meth:`loop.create_datagram_endpoint`"
msgstr "``чекати`` :meth:`loop.create_datagram_endpoint`"

msgid "Open a datagram (UDP) connection."
msgstr "Відкрийте з'єднання дейтаграми (UDP)."

msgid "``await`` :meth:`loop.sendfile`"
msgstr "``чекати`` :meth:`loop.sendfile`"

msgid "Send a file over a transport."
msgstr "Надіслати файл через транспорт."

msgid "``await`` :meth:`loop.start_tls`"
msgstr "``чекати`` :meth:`loop.start_tls`"

msgid "Upgrade an existing connection to TLS."
msgstr "Оновіть наявне підключення до TLS."

msgid "``await`` :meth:`loop.connect_read_pipe`"
msgstr "``чекати`` :meth:`loop.connect_read_pipe`"

msgid "Wrap a read end of a pipe into a ``(transport, protocol)`` pair."
msgstr "Оберніть зчитований кінець каналу в пару ``(транспорт, протокол)``."

msgid "``await`` :meth:`loop.connect_write_pipe`"
msgstr "``чекати`` :meth:`loop.connect_write_pipe`"

msgid "Wrap a write end of a pipe into a ``(transport, protocol)`` pair."
msgstr "Оберніть кінець каналу для запису в пару ``(транспорт, протокол)``."

msgid "Sockets"
msgstr "Сокети"

msgid "``await`` :meth:`loop.sock_recv`"
msgstr "``чекати`` :meth:`loop.sock_recv`"

msgid "Receive data from the :class:`~socket.socket`."
msgstr "Отримувати дані з :class:`~socket.socket`."

msgid "``await`` :meth:`loop.sock_recv_into`"
msgstr "``чекати`` :meth:`loop.sock_recv_into`"

msgid "Receive data from the :class:`~socket.socket` into a buffer."
msgstr "Отримувати дані з :class:`~socket.socket` в буфер."

msgid "``await`` :meth:`loop.sock_sendall`"
msgstr "``чекати`` :meth:`loop.sock_sendall`"

msgid "Send data to the :class:`~socket.socket`."
msgstr "Надсилайте дані до :class:`~socket.socket`."

msgid "``await`` :meth:`loop.sock_connect`"
msgstr "``чекати`` :meth:`loop.sock_connect`"

msgid "Connect the :class:`~socket.socket`."
msgstr "Підключіть :class:`~socket.socket`."

msgid "``await`` :meth:`loop.sock_accept`"
msgstr "``чекати`` :meth:`loop.sock_accept`"

msgid "Accept a :class:`~socket.socket` connection."
msgstr "Прийміть підключення :class:`~socket.socket`."

msgid "``await`` :meth:`loop.sock_sendfile`"
msgstr "``чекати`` :meth:`loop.sock_sendfile`"

msgid "Send a file over the :class:`~socket.socket`."
msgstr "Надішліть файл через :class:`~socket.socket`."

msgid ":meth:`loop.add_reader`"
msgstr ":meth:`loop.add_reader`"

msgid "Start watching a file descriptor for read availability."
msgstr "Почніть переглядати файловий дескриптор на наявність читання."

msgid ":meth:`loop.remove_reader`"
msgstr ":meth:`loop.remove_reader`"

msgid "Stop watching a file descriptor for read availability."
msgstr "Припиніть перегляд дескриптора файлу на доступність читання."

msgid ":meth:`loop.add_writer`"
msgstr ":meth:`loop.add_writer`"

msgid "Start watching a file descriptor for write availability."
msgstr "Почніть переглядати файловий дескриптор на доступність запису."

msgid ":meth:`loop.remove_writer`"
msgstr ":meth:`loop.remove_writer`"

msgid "Stop watching a file descriptor for write availability."
msgstr "Припиніть стежити за доступністю запису в дескрипторі файлів."

msgid "Unix Signals"
msgstr "Сигнали Unix"

msgid ":meth:`loop.add_signal_handler`"
msgstr ":meth:`loop.add_signal_handler`"

msgid "Add a handler for a :mod:`signal`."
msgstr "Додайте обробник для :mod:`signal`."

msgid ":meth:`loop.remove_signal_handler`"
msgstr ":meth:`loop.remove_signal_handler`"

msgid "Remove a handler for a :mod:`signal`."
msgstr "Видаліть обробник для :mod:`signal`."

msgid "Subprocesses"
msgstr "Підпроцеси"

msgid ":meth:`loop.subprocess_exec`"
msgstr ":meth:`loop.subprocess_exec`"

msgid "Spawn a subprocess."
msgstr "Створити підпроцес."

msgid ":meth:`loop.subprocess_shell`"
msgstr ":meth:`loop.subprocess_shell`"

msgid "Spawn a subprocess from a shell command."
msgstr "Створити підпроцес із команди оболонки."

msgid "Error Handling"
msgstr "Обробка помилок"

msgid ":meth:`loop.call_exception_handler`"
msgstr ":meth:`loop.call_exception_handler`"

msgid "Call the exception handler."
msgstr "Виклик обробника винятків."

msgid ":meth:`loop.set_exception_handler`"
msgstr ":meth:`loop.set_exception_handler`"

msgid "Set a new exception handler."
msgstr "Встановити новий обробник винятків."

msgid ":meth:`loop.get_exception_handler`"
msgstr ":meth:`loop.get_exception_handler`"

msgid "Get the current exception handler."
msgstr "Отримати поточний обробник винятків."

msgid ":meth:`loop.default_exception_handler`"
msgstr ":meth:`loop.default_exception_handler`"

msgid "The default exception handler implementation."
msgstr "Реалізація обробника винятків за замовчуванням."

msgid ""
":ref:`Using asyncio.get_event_loop() and loop.run_forever() "
"<asyncio_example_lowlevel_helloworld>`."
msgstr ""
":ref:`Використання asyncio.get_event_loop() і loop.run_forever() "
"<asyncio_example_lowlevel_helloworld>`."

msgid ":ref:`Using loop.call_later() <asyncio_example_call_later>`."
msgstr ":ref:`Використання loop.call_later() <asyncio_example_call_later>`."

msgid ""
"Using ``loop.create_connection()`` to implement :ref:`an echo-client "
"<asyncio_example_tcp_echo_client_protocol>`."
msgstr ""
"Використання ``loop.create_connection()`` для реалізації :ref:`ехо-клієнта "
"<asyncio_example_tcp_echo_client_protocol>`."

msgid ""
"Using ``loop.create_connection()`` to :ref:`connect a socket "
"<asyncio_example_create_connection>`."
msgstr ""
"Використання ``loop.create_connection()`` для :ref:`підключення сокета "
"<asyncio_example_create_connection>`."

msgid ""
":ref:`Using add_reader() to watch an FD for read events "
"<asyncio_example_watch_fd>`."
msgstr ""
":ref:`Використання add_reader() для перегляду FD для подій читання "
"<asyncio_example_watch_fd>`."

msgid ":ref:`Using loop.add_signal_handler() <asyncio_example_unix_signals>`."
msgstr ""
":ref:`Використання loop.add_signal_handler() <asyncio_example_unix_signals>`."

msgid ":ref:`Using loop.subprocess_exec() <asyncio_example_subprocess_proto>`."
msgstr ""
":ref:`Використання loop.subprocess_exec() "
"<asyncio_example_subprocess_proto>`."

msgid "Transports"
msgstr "Транспорти"

msgid "All transports implement the following methods:"
msgstr "Усі транспорти реалізують такі методи:"

msgid ":meth:`transport.close() <BaseTransport.close>`"
msgstr ":meth:`transport.close() <BaseTransport.close>`"

msgid "Close the transport."
msgstr "Закрити транспорт."

msgid ":meth:`transport.is_closing() <BaseTransport.is_closing>`"
msgstr ":meth:`transport.is_closing() <BaseTransport.is_closing>`"

msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Повертає ``True``, якщо транспорт закривається або закритий."

msgid ":meth:`transport.get_extra_info() <BaseTransport.get_extra_info>`"
msgstr ":meth:`transport.get_extra_info() <BaseTransport.get_extra_info>`"

msgid "Request for information about the transport."
msgstr "Запит інформації про транспорт."

msgid ":meth:`transport.set_protocol() <BaseTransport.set_protocol>`"
msgstr ":meth:`transport.set_protocol() <BaseTransport.set_protocol>`"

msgid "Set a new protocol."
msgstr "Встановіть новий протокол."

msgid ":meth:`transport.get_protocol() <BaseTransport.get_protocol>`"
msgstr ":meth:`transport.get_protocol() <BaseTransport.get_protocol>`"

msgid "Return the current protocol."
msgstr "Повернути поточний протокол."

msgid ""
"Transports that can receive data (TCP and Unix connections, pipes, etc).  "
"Returned from methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_read_pipe`, etc:"
msgstr ""
"Транспорти, які можуть отримувати дані (з’єднання TCP і Unix, канали тощо). "
"Повертається з таких методів, як :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_read_pipe` тощо:"

msgid "Read Transports"
msgstr "Читайте Транспорт"

msgid ":meth:`transport.is_reading() <ReadTransport.is_reading>`"
msgstr ":meth:`transport.is_reading() <ReadTransport.is_reading>`"

msgid "Return ``True`` if the transport is receiving."
msgstr "Повертає ``True``, якщо транспорт отримує."

msgid ":meth:`transport.pause_reading() <ReadTransport.pause_reading>`"
msgstr ":meth:`transport.pause_reading() <ReadTransport.pause_reading>`"

msgid "Pause receiving."
msgstr "Призупинити отримання."

msgid ":meth:`transport.resume_reading() <ReadTransport.resume_reading>`"
msgstr ":meth:`transport.resume_reading() <ReadTransport.resume_reading>`"

msgid "Resume receiving."
msgstr "Відновити прийом."

msgid ""
"Transports that can Send data (TCP and Unix connections, pipes, etc).  "
"Returned from methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_write_pipe`, etc:"
msgstr ""
"Транспорти, які можуть надсилати дані (з’єднання TCP і Unix, канали тощо). "
"Повертається з таких методів, як :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_write_pipe` тощо:"

msgid "Write Transports"
msgstr "Напишіть Транспорти"

msgid ":meth:`transport.write() <WriteTransport.write>`"
msgstr ":meth:`transport.write() <WriteTransport.write>`"

msgid "Write data to the transport."
msgstr "Записати дані в транспорт."

msgid ":meth:`transport.writelines() <WriteTransport.writelines>`"
msgstr ":meth:`transport.writelines() <WriteTransport.writelines>`"

msgid "Write buffers to the transport."
msgstr "Записати буфери в транспорт."

msgid ":meth:`transport.can_write_eof() <WriteTransport.can_write_eof>`"
msgstr ":meth:`transport.can_write_eof() <WriteTransport.can_write_eof>`"

msgid "Return :const:`True` if the transport supports sending EOF."
msgstr "Повертає :const:`True`, якщо транспорт підтримує надсилання EOF."

msgid ":meth:`transport.write_eof() <WriteTransport.write_eof>`"
msgstr ":meth:`transport.write_eof() <WriteTransport.write_eof>`"

msgid "Close and send EOF after flushing buffered data."
msgstr "Закрийте та надішліть EOF після очищення буферизованих даних."

msgid ":meth:`transport.abort() <WriteTransport.abort>`"
msgstr ":meth:`transport.abort() <WriteTransport.abort>`"

msgid "Close the transport immediately."
msgstr "Негайно закрити транспорт."

msgid ""
":meth:`transport.get_write_buffer_size() <WriteTransport."
"get_write_buffer_size>`"
msgstr ""
":meth:`transport.get_write_buffer_size() <WriteTransport."
"get_write_buffer_size>`"

msgid "Return high and low water marks for write flow control."
msgstr ""
"Повернути верхні та нижні водяні позначки для керування потоком запису."

msgid ""
":meth:`transport.set_write_buffer_limits() <WriteTransport."
"set_write_buffer_limits>`"
msgstr ""
":meth:`transport.set_write_buffer_limits() <WriteTransport."
"set_write_buffer_limits>`"

msgid "Set new high and low water marks for write flow control."
msgstr ""
"Встановіть нові позначки верхнього та нижнього рівня для контролю потоку "
"запису."

msgid "Transports returned by :meth:`loop.create_datagram_endpoint`:"
msgstr "Транспорти, повернуті :meth:`loop.create_datagram_endpoint`:"

msgid "Datagram Transports"
msgstr "Транспортування дейтаграм"

msgid ":meth:`transport.sendto() <DatagramTransport.sendto>`"
msgstr ":meth:`transport.sendto() <DatagramTransport.sendto>`"

msgid "Send data to the remote peer."
msgstr "Надсилати дані віддаленому одноранговому пристрою."

msgid ":meth:`transport.abort() <DatagramTransport.abort>`"
msgstr ":meth:`transport.abort() <DatagramTransport.abort>`"

msgid ""
"Low-level transport abstraction over subprocesses. Returned by :meth:`loop."
"subprocess_exec` and :meth:`loop.subprocess_shell`:"
msgstr ""
"Низькорівнева транспортна абстракція над підпроцесами. Повертається :meth:"
"`loop.subprocess_exec` і :meth:`loop.subprocess_shell`:"

msgid "Subprocess Transports"
msgstr "Транспортування підпроцесів"

msgid ":meth:`transport.get_pid() <SubprocessTransport.get_pid>`"
msgstr ":meth:`transport.get_pid() <SubprocessTransport.get_pid>`"

msgid "Return the subprocess process id."
msgstr "Повернути ідентифікатор процесу підпроцесу."

msgid ""
":meth:`transport.get_pipe_transport() <SubprocessTransport."
"get_pipe_transport>`"
msgstr ""
":meth:`transport.get_pipe_transport() <SubprocessTransport."
"get_pipe_transport>`"

msgid ""
"Return the transport for the requested communication pipe (*stdin*, "
"*stdout*, or *stderr*)."
msgstr ""
"Повернути транспорт для запитуваного каналу зв’язку (*stdin*, *stdout* або "
"*stderr*)."

msgid ":meth:`transport.get_returncode() <SubprocessTransport.get_returncode>`"
msgstr ""
":meth:`transport.get_returncode() <SubprocessTransport.get_returncode>`"

msgid "Return the subprocess return code."
msgstr "Повернути код повернення підпроцесу."

msgid ":meth:`transport.kill() <SubprocessTransport.kill>`"
msgstr ":meth:`transport.kill() <SubprocessTransport.kill>`"

msgid "Kill the subprocess."
msgstr "Закрийте підпроцес."

msgid ":meth:`transport.send_signal() <SubprocessTransport.send_signal>`"
msgstr ":meth:`transport.send_signal() <SubprocessTransport.send_signal>`"

msgid "Send a signal to the subprocess."
msgstr "Надішліть сигнал підпроцесу."

msgid ":meth:`transport.terminate() <SubprocessTransport.terminate>`"
msgstr ":meth:`transport.terminate() <SubprocessTransport.terminate>`"

msgid "Stop the subprocess."
msgstr "Зупиніть підпроцес."

msgid ":meth:`transport.close() <SubprocessTransport.close>`"
msgstr ":meth:`transport.close() <SubprocessTransport.close>`"

msgid "Kill the subprocess and close all pipes."
msgstr "Закрийте підпроцес і закрийте всі канали."

msgid "Protocols"
msgstr "Протоколи"

msgid "Protocol classes can implement the following **callback methods**:"
msgstr ""
"Класи протоколів можуть реалізовувати такі **методи зворотного виклику**:"

msgid "``callback`` :meth:`connection_made() <BaseProtocol.connection_made>`"
msgstr ""
"``зворотний виклик`` :meth:`connection_made() <BaseProtocol.connection_made>`"

msgid "Called when a connection is made."
msgstr "Викликається, коли встановлено з'єднання."

msgid "``callback`` :meth:`connection_lost() <BaseProtocol.connection_lost>`"
msgstr ""
"``зворотний виклик`` :meth:`connection_lost() <BaseProtocol.connection_lost>`"

msgid "Called when the connection is lost or closed."
msgstr "Викликається, коли з'єднання втрачено або закрито."

msgid "``callback`` :meth:`pause_writing() <BaseProtocol.pause_writing>`"
msgstr ""
"``зворотний виклик`` :meth:`pause_writing() <BaseProtocol.pause_writing>`"

msgid "Called when the transport's buffer goes over the high water mark."
msgstr "Викликається, коли транспортний буфер перевищує позначку високої води."

msgid "``callback`` :meth:`resume_writing() <BaseProtocol.resume_writing>`"
msgstr ""
"``зворотний виклик`` :meth:`resume_writing() <BaseProtocol.resume_writing>`"

msgid "Called when the transport's buffer drains below the low water mark."
msgstr ""
"Викликається, коли буфер транспорту стікає нижче позначки низького рівня "
"води."

msgid "Streaming Protocols (TCP, Unix Sockets, Pipes)"
msgstr "Протоколи потокової передачі (TCP, Unix-сокети, канали)"

msgid "``callback`` :meth:`data_received() <Protocol.data_received>`"
msgstr "``зворотний виклик`` :meth:`data_received() <Protocol.data_received>`"

msgid "Called when some data is received."
msgstr "Викликається при отриманні деяких даних."

msgid "``callback`` :meth:`eof_received() <Protocol.eof_received>`"
msgstr "``зворотний виклик`` :meth:`eof_received() <Protocol.eof_received>`"

msgid "Called when an EOF is received."
msgstr "Викликається, коли отримано EOF."

msgid "Buffered Streaming Protocols"
msgstr "Буферизовані потокові протоколи"

msgid "``callback`` :meth:`get_buffer() <BufferedProtocol.get_buffer>`"
msgstr ""
"``зворотний виклик`` :meth:`get_buffer() <BufferedProtocol.get_buffer>`"

msgid "Called to allocate a new receive buffer."
msgstr "Викликається для виділення нового буфера отримання."

msgid "``callback`` :meth:`buffer_updated() <BufferedProtocol.buffer_updated>`"
msgstr ""
"``зворотний виклик`` :meth:`buffer_updated() <BufferedProtocol."
"buffer_updated>`"

msgid "Called when the buffer was updated with the received data."
msgstr "Викликається, коли буфер оновлюється отриманими даними."

msgid "``callback`` :meth:`eof_received() <BufferedProtocol.eof_received>`"
msgstr ""
"``зворотний виклик`` :meth:`eof_received() <BufferedProtocol.eof_received>`"

msgid "Datagram Protocols"
msgstr "Протоколи дейтаграм"

msgid ""
"``callback`` :meth:`datagram_received() <DatagramProtocol.datagram_received>`"
msgstr ""
"``зворотний виклик`` :meth:`datagram_received() <DatagramProtocol."
"datagram_received>`"

msgid "Called when a datagram is received."
msgstr "Викликається, коли отримано дейтаграму."

msgid "``callback`` :meth:`error_received() <DatagramProtocol.error_received>`"
msgstr ""
"``зворотний виклик`` :meth:`error_received() <DatagramProtocol."
"error_received>`"

msgid ""
"Called when a previous send or receive operation raises an :class:`OSError`."
msgstr ""
"Викликається, коли попередня операція надсилання чи отримання викликає :"
"class:`OSError`."

msgid "Subprocess Protocols"
msgstr "Протоколи підпроцесів"

msgid ""
"``callback`` :meth:`pipe_data_received() <SubprocessProtocol."
"pipe_data_received>`"
msgstr ""
"``зворотний виклик`` :meth:`pipe_data_received() <SubprocessProtocol."
"pipe_data_received>`"

msgid ""
"Called when the child process writes data into its *stdout* or *stderr* pipe."
msgstr ""
"Викликається, коли дочірній процес записує дані у свій канал *stdout* або "
"*stderr*."

msgid ""
"``callback`` :meth:`pipe_connection_lost() <SubprocessProtocol."
"pipe_connection_lost>`"
msgstr ""
"``зворотний виклик`` :meth:`pipe_connection_lost() <SubprocessProtocol."
"pipe_connection_lost>`"

msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Викликається, коли одна з труб, що спілкуються з дочірнім процесом, закрита."

msgid ""
"``callback`` :meth:`process_exited() <SubprocessProtocol.process_exited>`"
msgstr ""
"``зворотний виклик`` :meth:`process_exited() <SubprocessProtocol."
"process_exited>`"

msgid "Called when the child process has exited."
msgstr "Викликається, коли дочірній процес вийшов."

msgid "Event Loop Policies"
msgstr "Політики циклу подій"

msgid ""
"Policies is a low-level mechanism to alter the behavior of functions like :"
"func:`asyncio.get_event_loop`.  See also the main :ref:`policies section "
"<asyncio-policies>` for more details."
msgstr ""
"Політики — це механізм низького рівня для зміни поведінки таких функцій, як :"
"func:`asyncio.get_event_loop`. Перегляньте також основний :ref:`розділ "
"правил <asyncio-policies>` для отримання додаткової інформації."

msgid "Accessing Policies"
msgstr "Доступ до політик"

msgid ":meth:`asyncio.get_event_loop_policy`"
msgstr ":meth:`asyncio.get_event_loop_policy`"

msgid "Return the current process-wide policy."
msgstr "Повернути поточну політику для всього процесу."

msgid ":meth:`asyncio.set_event_loop_policy`"
msgstr ":meth:`asyncio.set_event_loop_policy`"

msgid "Set a new process-wide policy."
msgstr "Установіть нову політику для всього процесу."

msgid ":class:`AbstractEventLoopPolicy`"
msgstr ":class:`AbstractEventLoopPolicy`"

msgid "Base class for policy objects."
msgstr "Базовий клас для об’єктів політики."
