# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:17+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`urllib.parse` --- Parse URLs into components"
msgstr ":mod:`urllib.parse` --- Розберіть URL-адреси на компоненти"

msgid "**Source code:** :source:`Lib/urllib/parse.py`"
msgstr "**Вихідний код:** :source:`Lib/urllib/parse.py`"

msgid ""
"This module defines a standard interface to break Uniform Resource Locator "
"(URL) strings up in components (addressing scheme, network location, path "
"etc.), to combine the components back into a URL string, and to convert a "
"\"relative URL\" to an absolute URL given a \"base URL.\""
msgstr ""
"Цей модуль визначає стандартний інтерфейс для розбиття рядків Uniform "
"Resource Locator (URL) на компоненти (схема адресації, мережеве "
"розташування, шлях тощо), щоб об’єднати компоненти назад у рядок URL-адреси "
"та перетворити \"відносну URL-адресу\" на абсолютна URL-адреса з \"базовою "
"URL-адресою\"."

msgid ""
"The module has been designed to match the internet RFC on Relative Uniform "
"Resource Locators. It supports the following URL schemes: ``file``, ``ftp``, "
"``gopher``, ``hdl``, ``http``, ``https``, ``imap``, ``mailto``, ``mms``, "
"``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, ``rtspu``, ``sftp``, "
"``shttp``, ``sip``, ``sips``, ``snews``, ``svn``, ``svn+ssh``, ``telnet``, "
"``wais``, ``ws``, ``wss``."
msgstr ""
"Модуль було розроблено відповідно до Інтернет-запиту RFC щодо відносних "
"уніфікованих локаторів ресурсів. Він підтримує такі схеми URL-адрес: "
"``file``, ``ftp``, ``gopher``, ``hdl``, ``http``, ``https``, ``imap``,"
"``mailto``, ``mms``, ``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, "
"``rtspu``, ``sftp``, ``shttp``, ``sip``, ``sips``, ``news``, ``svn``, "
"``svn+ssh``, ``telnet``, ``wais``, ``ws``, ``wss``."

msgid ""
"The :mod:`urllib.parse` module defines functions that fall into two broad "
"categories: URL parsing and URL quoting. These are covered in detail in the "
"following sections."
msgstr ""
"Модуль :mod:`urllib.parse` визначає функції, які поділяються на дві широкі "
"категорії: аналіз URL-адреси та цитування URL-адреси. Вони детально описані "
"в наступних розділах."

msgid "URL Parsing"
msgstr "Розбір URL-адрес"

msgid ""
"The URL parsing functions focus on splitting a URL string into its "
"components, or on combining URL components into a URL string."
msgstr ""
"Функції аналізу URL-адреси зосереджені на розділенні рядка URL-адреси на "
"його компоненти або на об’єднанні компонентів URL-адреси в рядок URL-адреси."

msgid ""
"Parse a URL into six components, returning a 6-item :term:`named tuple`.  "
"This corresponds to the general structure of a URL: ``scheme://netloc/path;"
"parameters?query#fragment``. Each tuple item is a string, possibly empty. "
"The components are not broken up into smaller parts (for example, the "
"network location is a single string), and % escapes are not expanded. The "
"delimiters as shown above are not part of the result, except for a leading "
"slash in the *path* component, which is retained if present.  For example:"
msgstr ""
"Розберіть URL-адресу на шість компонентів, повертаючи 6-елементний :term:"
"`named tuple`. Це відповідає загальній структурі URL: ``scheme://netloc/path;"
"parameters?query#fragment``. Кожен елемент кортежу є рядком, можливо "
"порожнім. Компоненти не розбиваються на більш дрібні частини (наприклад, "
"мережеве розташування є одним рядком), а % екранування не розгортається. "
"Роздільники, як показано вище, не є частиною результату, за винятком "
"початкової скісної риски в компоненті *path*, яка зберігається, якщо є. "
"Наприклад:"

msgid ""
"Following the syntax specifications in :rfc:`1808`, urlparse recognizes a "
"netloc only if it is properly introduced by '//'.  Otherwise the input is "
"presumed to be a relative URL and thus to start with a path component."
msgstr ""
"Дотримуючись специфікації синтаксису в :rfc:`1808`, urlparse розпізнає "
"netloc, лише якщо його правильно введено '//'. Інакше введення вважається "
"відносною URL-адресою і, таким чином, починається з компонента шляху."

msgid ""
"The *scheme* argument gives the default addressing scheme, to be used only "
"if the URL does not specify one.  It should be the same type (text or bytes) "
"as *urlstring*, except that the default value ``''`` is always allowed, and "
"is automatically converted to ``b''`` if appropriate."
msgstr ""
"Аргумент *схема* дає схему адресації за замовчуванням, яка використовується, "
"лише якщо її не вказано в URL-адресі. Він має бути того самого типу (текст "
"або байти), що й *urlstring*, за винятком того, що значення за замовчуванням "
"``''`` завжди допускається та автоматично перетворюється на ``b''``, якщо це "
"необхідно."

msgid ""
"If the *allow_fragments* argument is false, fragment identifiers are not "
"recognized.  Instead, they are parsed as part of the path, parameters or "
"query component, and :attr:`fragment` is set to the empty string in the "
"return value."
msgstr ""
"Якщо аргумент *allow_fragments* має значення false, ідентифікатори "
"фрагментів не розпізнаються. Натомість вони аналізуються як частина шляху, "
"параметрів або компонента запиту, а :attr:`fragment` встановлюється як "
"порожній рядок у поверненому значенні."

msgid ""
"The return value is a :term:`named tuple`, which means that its items can be "
"accessed by index or as named attributes, which are:"
msgstr ""
"Поверненим значенням є :term:`named tuple`, що означає, що до його елементів "
"можна отримати доступ за індексом або як іменовані атрибути, які:"

msgid "Attribute"
msgstr "Атрибут"

msgid "Index"
msgstr "Індекс"

msgid "Value"
msgstr "Значення"

msgid "Value if not present"
msgstr "Значення, якщо його немає"

msgid ":attr:`scheme`"
msgstr ":attr:`scheme`"

msgid "0"
msgstr "0"

msgid "URL scheme specifier"
msgstr "Специфікатор схеми URL"

msgid "*scheme* parameter"
msgstr "Параметр *схема*"

msgid ":attr:`netloc`"
msgstr ":attr:`netloc`"

msgid "1"
msgstr "1"

msgid "Network location part"
msgstr "Розташування мережі"

msgid "empty string"
msgstr "порожній рядок"

msgid ":attr:`path`"
msgstr ":attr:`path`"

msgid "2"
msgstr "2"

msgid "Hierarchical path"
msgstr "Ієрархічний шлях"

msgid ":attr:`params`"
msgstr ":attr:`params`"

msgid "3"
msgstr "3"

msgid "No longer used"
msgstr "Більше не використовується"

msgid "always an empty string"
msgstr "завжди порожній рядок"

msgid ":attr:`query`"
msgstr ":attr:`query`"

msgid "4"
msgstr "4"

msgid "Query component"
msgstr "Компонент запиту"

msgid ":attr:`fragment`"
msgstr ":attr:`fragment`"

msgid "5"
msgstr "5"

msgid "Fragment identifier"
msgstr "Ідентифікатор фрагмента"

msgid ":attr:`username`"
msgstr ":attr:`ім’я користувача`"

msgid "User name"
msgstr "Ім'я користувача"

msgid ":const:`None`"
msgstr ":const:`None`"

msgid ":attr:`password`"
msgstr ":attr:`password`"

msgid "Password"
msgstr "Пароль"

msgid ":attr:`hostname`"
msgstr ":attr:`ім'я хоста`"

msgid "Host name (lower case)"
msgstr "Ім'я хоста (нижній регістр)"

msgid ":attr:`port`"
msgstr ":attr:`port`"

msgid "Port number as integer, if present"
msgstr "Номер порту як ціле число, якщо є"

msgid ""
"Reading the :attr:`port` attribute will raise a :exc:`ValueError` if an "
"invalid port is specified in the URL.  See section :ref:`urlparse-result-"
"object` for more information on the result object."
msgstr ""
"Читання атрибута :attr:`port` викличе :exc:`ValueError`, якщо в URL-адресі "
"вказано недійсний порт. Перегляньте розділ :ref:`urlparse-result-object` для "
"отримання додаткової інформації про об’єкт результату."

msgid ""
"Unmatched square brackets in the :attr:`netloc` attribute will raise a :exc:"
"`ValueError`."
msgstr ""
"Невідповідні квадратні дужки в атрибуті :attr:`netloc` викличуть :exc:"
"`ValueError`."

msgid ""
"Characters in the :attr:`netloc` attribute that decompose under NFKC "
"normalization (as used by the IDNA encoding) into any of ``/``, ``?``, "
"``#``, ``@``, or ``:`` will raise a :exc:`ValueError`. If the URL is "
"decomposed before parsing, no error will be raised."
msgstr ""
"Символи в атрибуті :attr:`netloc`, які розкладаються за нормалізацією NFKC "
"(як використовується кодуванням IDNA) на будь-який із ``/``, ``?``, ``#``, "
"``@``, або ``:`` викличе :exc:`ValueError`. Якщо перед синтаксичним аналізом "
"URL-адресу розкладають, помилка не виникне."

msgid ""
"As is the case with all named tuples, the subclass has a few additional "
"methods and attributes that are particularly useful. One such method is :"
"meth:`_replace`. The :meth:`_replace` method will return a new ParseResult "
"object replacing specified fields with new values."
msgstr ""
"Як і у випадку з усіма іменованими кортежами, підклас має кілька додаткових "
"методів і атрибутів, які є особливо корисними. Одним із таких методів є :"
"meth:`_replace`. Метод :meth:`_replace` поверне новий об’єкт ParseResult, "
"замінюючи вказані поля новими значеннями."

msgid "Added IPv6 URL parsing capabilities."
msgstr "Додано можливості розбору URL-адрес IPv6."

msgid ""
"The fragment is now parsed for all URL schemes (unless *allow_fragment* is "
"false), in accordance with :rfc:`3986`.  Previously, an allowlist of schemes "
"that support fragments existed."
msgstr ""
"Тепер фрагмент аналізується для всіх схем URL-адрес (якщо *allow_fragment* "
"не має значення false), відповідно до :rfc:`3986`. Раніше існував дозволений "
"список схем, які підтримують фрагменти."

msgid ""
"Out-of-range port numbers now raise :exc:`ValueError`, instead of returning :"
"const:`None`."
msgstr ""
"Номери портів поза діапазоном тепер викликають :exc:`ValueError` замість "
"повернення :const:`None`."

msgid ""
"Characters that affect netloc parsing under NFKC normalization will now "
"raise :exc:`ValueError`."
msgstr ""
"Символи, які впливають на аналіз netloc під час нормалізації NFKC, тепер "
"викликатимуть :exc:`ValueError`."

msgid ""
"Parse a query string given as a string argument (data of type :mimetype:"
"`application/x-www-form-urlencoded`).  Data are returned as a dictionary.  "
"The dictionary keys are the unique query variable names and the values are "
"lists of values for each name."
msgstr ""
"Проаналізуйте рядок запиту, заданий як аргумент рядка (дані типу :mimetype:"
"`application/x-www-form-urlencoded`). Дані повертаються як словник. Ключі "
"словника — це унікальні імена змінних запиту, а значення — це списки значень "
"для кожного імені."

msgid ""
"The optional argument *keep_blank_values* is a flag indicating whether blank "
"values in percent-encoded queries should be treated as blank strings. A true "
"value indicates that blanks should be retained as  blank strings.  The "
"default false value indicates that blank values are to be ignored and "
"treated as if they were not included."
msgstr ""
"Необов’язковий аргумент *keep_blank_values* — це позначка, яка вказує, чи "
"слід порожні значення в запитах із відсотковим кодуванням розглядати як "
"порожні рядки. Справжнє значення вказує на те, що пробіли слід зберігати як "
"порожні рядки. Значення false за замовчуванням вказує на те, що порожні "
"значення слід ігнорувати та розглядати їх так, ніби їх не було включено."

msgid ""
"The optional argument *strict_parsing* is a flag indicating what to do with "
"parsing errors.  If false (the default), errors are silently ignored.  If "
"true, errors raise a :exc:`ValueError` exception."
msgstr ""
"Необов’язковий аргумент *strict_parsing* — це позначка, яка вказує, що "
"робити з помилками аналізу. Якщо false (за замовчуванням), помилки мовчки "
"ігноруються. Якщо true, помилки викликають виняток :exc:`ValueError`."

msgid ""
"The optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the :meth:"
"`bytes.decode` method."
msgstr ""
"Необов’язкові параметри *encoding* і *errors* визначають, як декодувати "
"послідовності, закодовані у відсотках, у символи Юнікоду, як це прийнято "
"методом :meth:`bytes.decode`."

msgid ""
"The optional argument *max_num_fields* is the maximum number of fields to "
"read. If set, then throws a :exc:`ValueError` if there are more than "
"*max_num_fields* fields read."
msgstr ""
"Необов’язковий аргумент *max_num_fields* — це максимальна кількість полів "
"для читання. Якщо встановлено, викидає :exc:`ValueError`, якщо прочитано "
"більше ніж *max_num_fields* полів."

msgid ""
"The optional argument *separator* is the symbol to use for separating the "
"query arguments. It defaults to ``&``."
msgstr ""
"Необов’язковий аргумент *роздільник* — це символ, який використовується для "
"розділення аргументів запиту. За замовчуванням ``&``."

msgid ""
"Use the :func:`urllib.parse.urlencode` function (with the ``doseq`` "
"parameter set to ``True``) to convert such dictionaries into query strings."
msgstr ""
"Використовуйте функцію :func:`urllib.parse.urlencode` (з параметром "
"``doseq``, встановленим на ``True``), щоб конвертувати такі словники в рядки "
"запиту."

msgid "Add *encoding* and *errors* parameters."
msgstr "Додайте параметри *encoding* і *errors*."

msgid "Added *max_num_fields* parameter."
msgstr "Додано параметр *max_num_fields*."

msgid ""
"Added *separator* parameter with the default value of ``&``. Python versions "
"earlier than Python 3.10 allowed using both ``;`` and ``&`` as query "
"parameter separator. This has been changed to allow only a single separator "
"key, with ``&`` as the default separator."
msgstr ""
"Додано параметр *роздільник* зі значенням за замовчуванням ``&``. Версії "
"Python, раніші за Python 3.10, дозволяли використовувати як ``;``, так і "
"``&`` як роздільник параметрів запиту. Це було змінено, щоб дозволити лише "
"один роздільний ключ із ``&`` як роздільником за умовчанням."

msgid ""
"Parse a query string given as a string argument (data of type :mimetype:"
"`application/x-www-form-urlencoded`).  Data are returned as a list of name, "
"value pairs."
msgstr ""
"Проаналізуйте рядок запиту, заданий як аргумент рядка (дані типу :mimetype:"
"`application/x-www-form-urlencoded`). Дані повертаються у вигляді списку пар "
"імені та значення."

msgid ""
"Use the :func:`urllib.parse.urlencode` function to convert such lists of "
"pairs into query strings."
msgstr ""
"Використовуйте функцію :func:`urllib.parse.urlencode`, щоб перетворити такі "
"списки пар у рядки запиту."

msgid ""
"Construct a URL from a tuple as returned by ``urlparse()``. The *parts* "
"argument can be any six-item iterable. This may result in a slightly "
"different, but equivalent URL, if the URL that was parsed originally had "
"unnecessary delimiters (for example, a ``?`` with an empty query; the RFC "
"states that these are equivalent)."
msgstr ""
"Створіть URL-адресу з кортежу, який повертає ``urlparse()``. Аргумент "
"*parts* може бути будь-яким ітерованим із шести елементів. Це може призвести "
"до дещо іншої, але еквівалентної URL-адреси, якщо спочатку проаналізована "
"URL-адреса мала непотрібні розділювачі (наприклад, ``?`` із порожнім "
"запитом; у RFC зазначено, що вони еквівалентні)."

msgid ""
"This is similar to :func:`urlparse`, but does not split the params from the "
"URL. This should generally be used instead of :func:`urlparse` if the more "
"recent URL syntax allowing parameters to be applied to each segment of the "
"*path* portion of the URL (see :rfc:`2396`) is wanted.  A separate function "
"is needed to separate the path segments and parameters.  This function "
"returns a 5-item :term:`named tuple`::"
msgstr ""
"Це схоже на :func:`urlparse`, але не відокремлює параметри від URL-адреси. "
"Загалом це слід використовувати замість :func:`urlparse`, якщо потрібний "
"новіший синтаксис URL-адреси, який дозволяє застосовувати параметри до "
"кожного сегменту частини *path* URL-адреси (див. :rfc:`2396`). Для "
"розділення сегментів шляху та параметрів потрібна окрема функція. Ця функція "
"повертає 5-елементний :term:`named tuple`::"

msgid ""
"The return value is a :term:`named tuple`, its items can be accessed by "
"index or as named attributes:"
msgstr ""
"Поверненим значенням є :term:`named tuple`, до його елементів можна отримати "
"доступ за індексом або як іменовані атрибути:"

msgid ""
"Following the `WHATWG spec`_ that updates RFC 3986, ASCII newline ``\\n``, "
"``\\r`` and tab ``\\t`` characters are stripped from the URL."
msgstr ""
"Відповідно до `WHATWG специфікації`_, яка оновлює RFC 3986, символи нового "
"рядка ASCII ``\\n``, ``\\r`` і табуляції ``\\t`` видаляються з URL-адреси."

msgid "ASCII newline and tab characters are stripped from the URL."
msgstr "Символи нового рядка та табуляції ASCII видаляються з URL-адреси."

msgid ""
"Combine the elements of a tuple as returned by :func:`urlsplit` into a "
"complete URL as a string. The *parts* argument can be any five-item "
"iterable. This may result in a slightly different, but equivalent URL, if "
"the URL that was parsed originally had unnecessary delimiters (for example, "
"a ? with an empty query; the RFC states that these are equivalent)."
msgstr ""
"Об’єднайте елементи кортежу, які повертає :func:`urlsplit`, у повну URL-"
"адресу як рядок. Аргументом *parts* може бути будь-який ітерований з п’яти "
"елементів. Це може призвести до дещо іншої, але еквівалентної URL-адреси, "
"якщо спочатку проаналізована URL-адреса мала непотрібні розділювачі "
"(наприклад, ? із порожнім запитом; у RFC зазначено, що вони еквівалентні)."

msgid ""
"Construct a full (\"absolute\") URL by combining a \"base URL\" (*base*) "
"with another URL (*url*).  Informally, this uses components of the base URL, "
"in particular the addressing scheme, the network location and (part of) the "
"path, to provide missing components in the relative URL.  For example:"
msgstr ""
"Створіть повну (\"абсолютну\") URL-адресу, об’єднавши \"базову URL-"
"адресу\" (*base*) з іншою URL-адресою (*url*). Неофіційно тут "
"використовуються компоненти базової URL-адреси, зокрема схема адресації, "
"мережеве розташування та (частина) шляху, щоб забезпечити відсутні "
"компоненти у відносній URL-адресі. Наприклад:"

msgid ""
"The *allow_fragments* argument has the same meaning and default as for :func:"
"`urlparse`."
msgstr ""
"Аргумент *allow_fragments* має те саме значення та типове значення, що й "
"для :func:`urlparse`."

msgid ""
"If *url* is an absolute URL (that is, it starts with ``//`` or ``scheme://"
"``), the *url*'s hostname and/or scheme will be present in the result.  For "
"example:"
msgstr ""
"Якщо *url* є абсолютною URL-адресою (тобто вона починається з ``//`` або "
"``scheme://``), ім'я хосту *url* та/або схема будуть присутні в результаті. "
"Наприклад:"

msgid ""
"If you do not want that behavior, preprocess the *url* with :func:`urlsplit` "
"and :func:`urlunsplit`, removing possible *scheme* and *netloc* parts."
msgstr ""
"Якщо ви не хочете такої поведінки, попередньо обробіть *url* за допомогою :"
"func:`urlsplit` і :func:`urlunsplit`, видаливши можливі частини *scheme* і "
"*netloc*."

msgid "Behavior updated to match the semantics defined in :rfc:`3986`."
msgstr "Поведінку оновлено відповідно до семантики, визначеної в :rfc:`3986`."

msgid ""
"If *url* contains a fragment identifier, return a modified version of *url* "
"with no fragment identifier, and the fragment identifier as a separate "
"string.  If there is no fragment identifier in *url*, return *url* "
"unmodified and an empty string."
msgstr ""
"Якщо *url* містить ідентифікатор фрагмента, поверніть модифіковану версію "
"*url* без ідентифікатора фрагмента та ідентифікатор фрагмента як окремий "
"рядок. Якщо в *url* немає ідентифікатора фрагмента, поверніть *url* без змін "
"і порожній рядок."

msgid ":attr:`url`"
msgstr ":attr:`url`"

msgid "URL with no fragment"
msgstr "URL без фрагмента"

msgid ""
"See section :ref:`urlparse-result-object` for more information on the result "
"object."
msgstr ""
"Перегляньте розділ :ref:`urlparse-result-object` для отримання додаткової "
"інформації про об’єкт результату."

msgid "Result is a structured object rather than a simple 2-tuple."
msgstr "Результат – це структурований об’єкт, а не простий 2-кортеж."

msgid ""
"Extract the url from a wrapped URL (that is, a string formatted as ``<URL:"
"scheme://host/path>``, ``<scheme://host/path>``, ``URL:scheme://host/path`` "
"or ``scheme://host/path``). If *url* is not a wrapped URL, it is returned "
"without changes."
msgstr ""
"Витягніть URL-адресу з упакованої URL-адреси (тобто рядка у форматі ``<URL:"
"scheme://host/path>``, ``<scheme://host/path>``, ``URL:scheme://host/path`` "
"або ``scheme://host/path``). Якщо *url* не є загорнутою URL-адресою, вона "
"повертається без змін."

msgid "Parsing ASCII Encoded Bytes"
msgstr "Розбір байтів, закодованих ASCII"

msgid ""
"The URL parsing functions were originally designed to operate on character "
"strings only. In practice, it is useful to be able to manipulate properly "
"quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL "
"parsing functions in this module all operate on :class:`bytes` and :class:"
"`bytearray` objects in addition to :class:`str` objects."
msgstr ""
"Функції аналізу URL спочатку були розроблені для роботи лише з рядками "
"символів. На практиці корисно мати можливість маніпулювати правильно "
"цитованими та закодованими URL-адресами як послідовностями байтів ASCII. "
"Відповідно, усі функції аналізу URL-адрес у цьому модулі працюють з "
"об’єктами :class:`bytes` і :class:`bytearray` на додаток до об’єктів :class:"
"`str`."

msgid ""
"If :class:`str` data is passed in, the result will also contain only :class:"
"`str` data. If :class:`bytes` or :class:`bytearray` data is passed in, the "
"result will contain only :class:`bytes` data."
msgstr ""
"Якщо передано дані :class:`str`, результат також міститиме лише дані :class:"
"`str`. Якщо передано дані :class:`bytes` або :class:`bytearray`, результат "
"міститиме лише дані :class:`bytes`."

msgid ""
"Attempting to mix :class:`str` data with :class:`bytes` or :class:"
"`bytearray` in a single function call will result in a :exc:`TypeError` "
"being raised, while attempting to pass in non-ASCII byte values will "
"trigger :exc:`UnicodeDecodeError`."
msgstr ""
"Спроба змішати дані :class:`str` із :class:`bytes` або :class:`bytearray` в "
"одному виклику функції призведе до появи :exc:`TypeError` під час спроби "
"передати не-ASCII значення байтів викликатимуть :exc:`UnicodeDecodeError`."

msgid ""
"To support easier conversion of result objects between :class:`str` and :"
"class:`bytes`, all return values from URL parsing functions provide either "
"an :meth:`encode` method (when the result contains :class:`str` data) or a :"
"meth:`decode` method (when the result contains :class:`bytes` data). The "
"signatures of these methods match those of the corresponding :class:`str` "
"and :class:`bytes` methods (except that the default encoding is ``'ascii'`` "
"rather than ``'utf-8'``). Each produces a value of a corresponding type that "
"contains either :class:`bytes` data (for :meth:`encode` methods) or :class:"
"`str` data (for :meth:`decode` methods)."
msgstr ""
"Для підтримки легшого перетворення об’єктів результату між :class:`str` і :"
"class:`bytes`, усі значення, що повертаються функціями парсингу URL-адреси, "
"надають або метод :meth:`encode` (якщо результат містить :class:`str` data) "
"або метод :meth:`decode` (якщо результат містить дані :class:`bytes`). "
"Сигнатури цих методів збігаються з сигнатурами відповідних методів :class:"
"`str` і :class:`bytes` (за винятком того, що стандартним кодуванням є "
"``'ascii'``, а не ``'utf-8'``) . Кожен створює значення відповідного типу, "
"яке містить або дані :class:`bytes` (для методів :meth:`encode`), або дані :"
"class:`str` (для методів :meth:`decode`)."

msgid ""
"Applications that need to operate on potentially improperly quoted URLs that "
"may contain non-ASCII data will need to do their own decoding from bytes to "
"characters before invoking the URL parsing methods."
msgstr ""
"Програми, яким потрібно працювати з потенційно неправильно цитованими URL-"
"адресами, які можуть містити дані, відмінні від ASCII, повинні будуть "
"виконати власне декодування з байтів на символи перед тим, як викликати "
"методи аналізу URL-адрес."

msgid ""
"The behaviour described in this section applies only to the URL parsing "
"functions. The URL quoting functions use their own rules when producing or "
"consuming byte sequences as detailed in the documentation of the individual "
"URL quoting functions."
msgstr ""
"Поведінка, описана в цьому розділі, стосується лише функцій аналізу URL-"
"адреси. Функції цитування URL-адрес використовують власні правила під час "
"створення або споживання послідовностей байтів, як описано в документації "
"окремих функцій цитування URL-адрес."

msgid "URL parsing functions now accept ASCII encoded byte sequences"
msgstr ""
"Функції аналізу URL-адрес тепер приймають послідовності байтів у кодуванні "
"ASCII"

msgid "Structured Parse Results"
msgstr "Структуровані результати аналізу"

msgid ""
"The result objects from the :func:`urlparse`, :func:`urlsplit`  and :func:"
"`urldefrag` functions are subclasses of the :class:`tuple` type. These "
"subclasses add the attributes listed in the documentation for those "
"functions, the encoding and decoding support described in the previous "
"section, as well as an additional method:"
msgstr ""
"Об’єкти результатів функцій :func:`urlparse`, :func:`urlsplit` і :func:"
"`urldefrag` є підкласами типу :class:`tuple`. Ці підкласи додають атрибути, "
"перелічені в документації для цих функцій, підтримку кодування та "
"декодування, описану в попередньому розділі, а також додатковий метод:"

msgid ""
"Return the re-combined version of the original URL as a string. This may "
"differ from the original URL in that the scheme may be normalized to lower "
"case and empty components may be dropped. Specifically, empty parameters, "
"queries, and fragment identifiers will be removed."
msgstr ""
"Повертає повторно об’єднану версію вихідної URL-адреси у вигляді рядка. Це "
"може відрізнятися від вихідної URL-адреси тим, що схема може бути "
"нормалізована до нижнього регістру, а порожні компоненти можуть бути "
"видалені. Зокрема, порожні параметри, запити та ідентифікатори фрагментів "
"буде видалено."

msgid ""
"For :func:`urldefrag` results, only empty fragment identifiers will be "
"removed. For :func:`urlsplit` and :func:`urlparse` results, all noted "
"changes will be made to the URL returned by this method."
msgstr ""
"Для результатів :func:`urldefrag` буде видалено лише порожні ідентифікатори "
"фрагментів. Для результатів :func:`urlsplit` і :func:`urlparse` усі "
"зазначені зміни буде внесено до URL-адреси, яку повертає цей метод."

msgid ""
"The result of this method remains unchanged if passed back through the "
"original parsing function:"
msgstr ""
"Результат цього методу залишається незмінним, якщо передати його через "
"вихідну функцію аналізу:"

msgid ""
"The following classes provide the implementations of the structured parse "
"results when operating on :class:`str` objects:"
msgstr ""
"Наступні класи забезпечують реалізацію результатів структурованого аналізу "
"під час роботи з об’єктами :class:`str`:"

msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`DefragResultBytes` instance."
msgstr ""
"Конкретний клас для результатів :func:`urldefrag`, що містять дані :class:"
"`str`. Метод :meth:`encode` повертає екземпляр :class:`DefragResultBytes`."

msgid ""
"Concrete class for :func:`urlparse` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`ParseResultBytes` instance."
msgstr ""
"Конкретний клас для результатів :func:`urlparse`, що містять дані :class:"
"`str`. Метод :meth:`encode` повертає екземпляр :class:`ParseResultBytes`."

msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`str` data. "
"The :meth:`encode` method returns a :class:`SplitResultBytes` instance."
msgstr ""
"Конкретний клас для результатів :func:`urlsplit`, що містять дані :class:"
"`str`. Метод :meth:`encode` повертає екземпляр :class:`SplitResultBytes`."

msgid ""
"The following classes provide the implementations of the parse results when "
"operating on :class:`bytes` or :class:`bytearray` objects:"
msgstr ""
"Наступні класи забезпечують реалізацію результатів аналізу під час роботи з "
"об’єктами :class:`bytes` або :class:`bytearray`:"

msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`DefragResult` instance."
msgstr ""
"Конкретний клас для результатів :func:`urldefrag`, що містять дані :class:"
"`bytes`. Метод :meth:`decode` повертає екземпляр :class:`DefragResult`."

msgid ""
"Concrete class for :func:`urlparse` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`ParseResult` instance."
msgstr ""
"Конкретний клас для результатів :func:`urlparse`, що містять дані :class:"
"`bytes`. Метод :meth:`decode` повертає екземпляр :class:`ParseResult`."

msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`bytes` data. "
"The :meth:`decode` method returns a :class:`SplitResult` instance."
msgstr ""
"Конкретний клас для результатів :func:`urlsplit`, що містять дані :class:"
"`bytes`. Метод :meth:`decode` повертає екземпляр :class:`SplitResult`."

msgid "URL Quoting"
msgstr "Цитування URL"

msgid ""
"The URL quoting functions focus on taking program data and making it safe "
"for use as URL components by quoting special characters and appropriately "
"encoding non-ASCII text. They also support reversing these operations to "
"recreate the original data from the contents of a URL component if that task "
"isn't already covered by the URL parsing functions above."
msgstr ""
"Функції цитування URL-адреси зосереджені на тому, щоб отримати програмні "
"дані та зробити їх безпечними для використання як компонентів URL-адреси "
"шляхом цитування спеціальних символів і відповідного кодування тексту, "
"відмінного від ASCII. Вони також підтримують реверсування цих операцій, щоб "
"відтворити вихідні дані з вмісту компонента URL-адреси, якщо це завдання ще "
"не охоплено функціями аналізу URL-адреси вище."

msgid ""
"Replace special characters in *string* using the ``%xx`` escape. Letters, "
"digits, and the characters ``'_.-~'`` are never quoted. By default, this "
"function is intended for quoting the path section of a URL. The optional "
"*safe* parameter specifies additional ASCII characters that should not be "
"quoted --- its default value is ``'/'``."
msgstr ""
"Замініть спеціальні символи в *рядку*, використовуючи ``%xx`` екранування. "
"Літери, цифри та символи ``'_.-~''`` ніколи не беруться в лапки. За "
"замовчуванням ця функція призначена для цитування розділу шляху URL-адреси. "
"Необов’язковий параметр *safe* визначає додаткові символи ASCII, які не слід "
"брати в лапки --- його значенням за замовчуванням є ``'/'``."

msgid "*string* may be either a :class:`str` or a :class:`bytes` object."
msgstr "*string* може бути об’єктом :class:`str` або :class:`bytes`."

msgid ""
"Moved from :rfc:`2396` to :rfc:`3986` for quoting URL strings. \"~\" is now "
"included in the set of unreserved characters."
msgstr ""
"Переміщено з :rfc:`2396` до :rfc:`3986` для цитування рядків URL. \"~\" "
"тепер включено до набору незарезервованих символів."

msgid ""
"The optional *encoding* and *errors* parameters specify how to deal with non-"
"ASCII characters, as accepted by the :meth:`str.encode` method. *encoding* "
"defaults to ``'utf-8'``. *errors* defaults to ``'strict'``, meaning "
"unsupported characters raise a :class:`UnicodeEncodeError`. *encoding* and "
"*errors* must not be supplied if *string* is a :class:`bytes`, or a :class:"
"`TypeError` is raised."
msgstr ""
"Необов’язкові параметри *encoding* і *errors* вказують, як працювати з "
"символами, відмінними від ASCII, як прийнято методом :meth:`str.encode`. "
"*кодування* за замовчуванням ``'utf-8'``. *errors* за умовчанням має "
"значення ``'strict'``, тобто непідтримувані символи викликають :class:"
"`UnicodeEncodeError`. *кодування* та *помилки* не повинні надаватися, якщо "
"*рядок* є :class:`bytes` або виникає :class:`TypeError`."

msgid ""
"Note that ``quote(string, safe, encoding, errors)`` is equivalent to "
"``quote_from_bytes(string.encode(encoding, errors), safe)``."
msgstr ""
"Зауважте, що ``quote(string, safe, encoding, errors)`` еквівалентно "
"``quote_from_bytes(string.encode(encoding, errors), safe)``."

msgid "Example: ``quote('/El Niño/')`` yields ``'/El%20Ni%C3%B1o/'``."
msgstr "Приклад: ``quote('/El Niño/')`` дає ``'/El%20Ni%C3%B1o/''``."

msgid ""
"Like :func:`quote`, but also replace spaces with plus signs, as required for "
"quoting HTML form values when building up a query string to go into a URL. "
"Plus signs in the original string are escaped unless they are included in "
"*safe*.  It also does not have *safe* default to ``'/'``."
msgstr ""
"Подібно до :func:`quote`, але також замініть пробіли знаками плюса, як це "
"потрібно для цитування значень HTML-форми під час створення рядка запиту для "
"переходу до URL-адреси. Знаки \"плюс\" у вихідному рядку екрануються, якщо "
"вони не включені в *safe*. Він також не має *safe* типового значення ``'/'``."

msgid "Example: ``quote_plus('/El Niño/')`` yields ``'%2FEl+Ni%C3%B1o%2F'``."
msgstr "Приклад: ``quote_plus('/El Niño/')`` дає ``'%2FEl+Ni%C3%B1o%2F''``."

msgid ""
"Like :func:`quote`, but accepts a :class:`bytes` object rather than a :class:"
"`str`, and does not perform string-to-bytes encoding."
msgstr ""
"Подібно до :func:`quote`, але приймає об’єкт :class:`bytes`, а не :class:"
"`str`, і не виконує кодування рядок-байт."

msgid "Example: ``quote_from_bytes(b'a&\\xef')`` yields ``'a%26%EF'``."
msgstr "Приклад: ``quote_from_bytes(b'a&\\xef')`` дає ``'a%26%EF''``."

msgid ""
"Replace ``%xx`` escapes with their single-character equivalent. The optional "
"*encoding* and *errors* parameters specify how to decode percent-encoded "
"sequences into Unicode characters, as accepted by the :meth:`bytes.decode` "
"method."
msgstr ""
"Замініть екрановані символи ``%xx`` їх односимвольним еквівалентом. "
"Необов’язкові параметри *encoding* і *errors* визначають, як декодувати "
"послідовності, закодовані у відсотках, у символи Юнікоду, як це прийнято "
"методом :meth:`bytes.decode`."

msgid ""
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'replace'``, "
"meaning invalid sequences are replaced by a placeholder character."
msgstr ""
"*кодування* за замовчуванням ``'utf-8'``. *errors* за умовчанням має "
"значення ``'replace'``, тобто недійсні послідовності замінюються символом-"
"заповнювачем."

msgid "Example: ``unquote('/El%20Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "Приклад: ``unquote('/El%20Ni%C3%B1o/')`` дає ``'/El Niño/''``."

msgid ""
"*string* parameter supports bytes and str objects (previously only str)."
msgstr "Параметр *string* підтримує об’єкти bytes і str (раніше лише str)."

msgid ""
"Like :func:`unquote`, but also replace plus signs with spaces, as required "
"for unquoting HTML form values."
msgstr ""
"Подібно до :func:`unquote`, але також замініть знаки \"плюс\" пробілами, як "
"це потрібно для зняття лапок значень форми HTML."

msgid "*string* must be a :class:`str`."
msgstr "*рядок* має бути :class:`str`."

msgid "Example: ``unquote_plus('/El+Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "Приклад: ``unquote_plus('/El+Ni%C3%B1o/')`` дає ``'/El Niño/''``."

msgid ""
"Replace ``%xx`` escapes with their single-octet equivalent, and return a :"
"class:`bytes` object."
msgstr ""
"Замініть екрановані символи ``%xx`` їх однооктетним еквівалентом і поверніть "
"об’єкт :class:`bytes`."

msgid ""
"If it is a :class:`str`, unescaped non-ASCII characters in *string* are "
"encoded into UTF-8 bytes."
msgstr ""
"Якщо це :class:`str`, неекрановані не-ASCII символи в *string* кодуються в "
"UTF-8 байтах."

msgid "Example: ``unquote_to_bytes('a%26%EF')`` yields ``b'a&\\xef'``."
msgstr "Приклад: ``unquote_to_bytes('a%26%EF')`` дає ``b'a&\\xef'``."

msgid ""
"Convert a mapping object or a sequence of two-element tuples, which may "
"contain :class:`str` or :class:`bytes` objects, to a percent-encoded ASCII "
"text string.  If the resultant string is to be used as a *data* for POST "
"operation with the :func:`~urllib.request.urlopen` function, then it should "
"be encoded to bytes, otherwise it would result in a :exc:`TypeError`."
msgstr ""
"Перетворіть об’єкт зіставлення або послідовність двоелементних кортежів, які "
"можуть містити об’єкти :class:`str` або :class:`bytes`, у текстовий рядок "
"ASCII у відсотковому кодуванні. Якщо результуючий рядок має "
"використовуватись як *дані* для операції POST із функцією :func:`~urllib."
"request.urlopen`, тоді його слід закодувати в байти, інакше це призведе до :"
"exc:`TypeError`."

msgid ""
"The resulting string is a series of ``key=value`` pairs separated by ``'&'`` "
"characters, where both *key* and *value* are quoted using the *quote_via* "
"function.  By default, :func:`quote_plus` is used to quote the values, which "
"means spaces are quoted as a ``'+'`` character and '/' characters are "
"encoded as ``%2F``, which follows the standard for GET requests "
"(``application/x-www-form-urlencoded``).  An alternate function that can be "
"passed as *quote_via* is :func:`quote`, which will encode spaces as ``%20`` "
"and not encode '/' characters.  For maximum control of what is quoted, use "
"``quote`` and specify a value for *safe*."
msgstr ""
"Отриманий рядок є серією пар ``ключ=значення``, розділених символами "
"``'&''``, де *ключ* і *значення* взяті в лапки за допомогою функції "
"*quote_via*. За замовчуванням :func:`quote_plus` використовується для взяття "
"значень у лапки, що означає, що пробіли беруться в лапки як символ ``'+'``, "
"а символи '/' кодуються як ``%2F``, що відповідає стандарту для Запити GET "
"(``application/x-www-form-urlencoded``). Альтернативною функцією, яку можна "
"передати як *quote_via*, є :func:`quote`, яка кодуватиме пробіли як ``%20`` "
"і не кодуватиме символи '/'. Для максимального контролю над тим, що "
"цитується, використовуйте ``quote`` і вкажіть значення для *safe*."

msgid ""
"When a sequence of two-element tuples is used as the *query* argument, the "
"first element of each tuple is a key and the second is a value. The value "
"element in itself can be a sequence and in that case, if the optional "
"parameter *doseq* evaluates to ``True``, individual ``key=value`` pairs "
"separated by ``'&'`` are generated for each element of the value sequence "
"for the key.  The order of parameters in the encoded string will match the "
"order of parameter tuples in the sequence."
msgstr ""
"Коли послідовність двоелементних кортежів використовується як аргумент "
"*запиту*, перший елемент кожного кортежу є ключем, а другий — значенням. "
"Елемент значення сам по собі може бути послідовністю, і в такому випадку, "
"якщо необов’язковий параметр *doseq* оцінюється як ``True``, окремі пари "
"``ключ=значення`` генеруються для кожен елемент послідовності значень для "
"ключа. Порядок параметрів у закодованому рядку відповідатиме порядку "
"кортежів параметрів у послідовності."

msgid ""
"The *safe*, *encoding*, and *errors* parameters are passed down to "
"*quote_via* (the *encoding* and *errors* parameters are only passed when a "
"query element is a :class:`str`)."
msgstr ""
"Параметри *safe*, *encoding* і *errors* передаються до *quote_via* "
"(параметри *encoding* і *errors* передаються лише тоді, коли елемент запиту "
"є :class:`str`)."

msgid ""
"To reverse this encoding process, :func:`parse_qs` and :func:`parse_qsl` are "
"provided in this module to parse query strings into Python data structures."
msgstr ""
"Щоб змінити цей процес кодування, у цьому модулі передбачено :func:"
"`parse_qs` і :func:`parse_qsl` для аналізу рядків запиту в структурах даних "
"Python."

msgid ""
"Refer to :ref:`urllib examples <urllib-examples>` to find out how the :func:"
"`urllib.parse.urlencode` method can be used for generating the query string "
"of a URL or data for a POST request."
msgstr ""
"Зверніться до :ref:`urllib examples <urllib-examples>`, щоб дізнатися, як "
"метод :func:`urllib.parse.urlencode` можна використовувати для генерації "
"рядка запиту URL-адреси або даних для запиту POST."

msgid "*query* supports bytes and string objects."
msgstr "*query* підтримує байти та рядкові об’єкти."

msgid "*quote_via* parameter."
msgstr "*quote_via* параметр."

msgid "`WHATWG`_ -  URL Living standard"
msgstr "`WHATWG`_ - URL Життєвий рівень"

msgid ""
"Working Group for the URL Standard that defines URLs, domains, IP addresses, "
"the application/x-www-form-urlencoded format, and their API."
msgstr ""
"Робоча група для стандарту URL-адрес, яка визначає URL-адреси, домени, IP-"
"адреси, формат application/x-www-form-urlencoded та їх API."

msgid ":rfc:`3986` - Uniform Resource Identifiers"
msgstr ":rfc:`3986` - Уніфіковані ідентифікатори ресурсів"

msgid ""
"This is the current standard (STD66). Any changes to urllib.parse module "
"should conform to this. Certain deviations could be observed, which are "
"mostly for backward compatibility purposes and for certain de-facto parsing "
"requirements as commonly observed in major browsers."
msgstr ""
"Це поточний стандарт (STD66). Будь-які зміни в модулі urllib.parse мають "
"відповідати цьому. Можуть спостерігатися певні відхилення, які здебільшого "
"пов’язані з цілями зворотної сумісності та певними де-факто вимогами до "
"аналізу, які зазвичай спостерігаються в основних браузерах."

msgid ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."
msgstr ":rfc:`2732` - Формат буквальних IPv6-адрес в URL-адресах."

msgid "This specifies the parsing requirements of IPv6 URLs."
msgstr "Це визначає вимоги до аналізу URL-адрес IPv6."

msgid ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"
msgstr ""
":rfc:`2396` - Уніфіковані ідентифікатори ресурсів (URI): загальний синтаксис"

msgid ""
"Document describing the generic syntactic requirements for both Uniform "
"Resource Names (URNs) and Uniform Resource Locators (URLs)."
msgstr ""
"Документ, що описує загальні синтаксичні вимоги як для уніфікованих імен "
"ресурсів (URN), так і для уніфікованих покажчиків ресурсів (URL)."

msgid ":rfc:`2368` - The mailto URL scheme."
msgstr ":rfc:`2368` - Схема URL-адреси електронної пошти."

msgid "Parsing requirements for mailto URL schemes."
msgstr "Вимоги до розбору URL-схем mailto."

msgid ":rfc:`1808` - Relative Uniform Resource Locators"
msgstr ":rfc:`1808` - Відносні уніфіковані локатори ресурсів"

msgid ""
"This Request For Comments includes the rules for joining an absolute and a "
"relative URL, including a fair number of \"Abnormal Examples\" which govern "
"the treatment of border cases."
msgstr ""
"Цей Запит на коментарі містить правила об’єднання абсолютної та відносної "
"URL-адрес, включаючи чималу кількість \"ненормальних прикладів\", які "
"регулюють обробку прикордонних випадків."

msgid ":rfc:`1738` - Uniform Resource Locators (URL)"
msgstr ":rfc:`1738` - Уніфіковані покажчики ресурсів (URL)"

msgid "This specifies the formal syntax and semantics of absolute URLs."
msgstr "Це визначає формальний синтаксис і семантику абсолютних URL-адрес."
