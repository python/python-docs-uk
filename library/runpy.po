# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`runpy` --- Locating and executing Python modules"
msgstr ":mod:`runpy` --- Розташування та виконання модулів Python"

msgid "**Source code:** :source:`Lib/runpy.py`"
msgstr "**Вихідний код:** :source:`Lib/runpy.py`"

msgid ""
"The :mod:`runpy` module is used to locate and run Python modules without "
"importing them first. Its main use is to implement the :option:`-m` command "
"line switch that allows scripts to be located using the Python module "
"namespace rather than the filesystem."
msgstr ""
"Модуль :mod:`runpy` використовується для пошуку та запуску модулів Python "
"без їх попереднього імпорту. Його головне використання полягає в реалізації "
"перемикача командного рядка :option:`-m`, який дозволяє розташовувати "
"сценарії за допомогою простору імен модуля Python, а не файлової системи."

msgid ""
"Note that this is *not* a sandbox module - all code is executed in the "
"current process, and any side effects (such as cached imports of other "
"modules) will remain in place after the functions have returned."
msgstr ""
"Зауважте, що це *не* модуль пісочниці – весь код виконується в поточному "
"процесі, і будь-які побічні ефекти (такі як кешований імпорт інших модулів) "
"залишаться на місці після повернення функцій."

msgid ""
"Furthermore, any functions and classes defined by the executed code are not "
"guaranteed to work correctly after a :mod:`runpy` function has returned. If "
"that limitation is not acceptable for a given use case, :mod:`importlib` is "
"likely to be a more suitable choice than this module."
msgstr ""
"Крім того, не гарантується коректна робота будь-яких функцій і класів, "
"визначених виконуваним кодом після повернення функції :mod:`runpy`. Якщо це "
"обмеження неприйнятне для певного випадку використання, :mod:`importlib`, "
"швидше за все, буде більш прийнятним вибором, ніж цей модуль."

msgid "The :mod:`runpy` module provides two functions:"
msgstr "Модуль :mod:`runpy` забезпечує дві функції:"

msgid ""
"Execute the code of the specified module and return the resulting module "
"globals dictionary. The module's code is first located using the standard "
"import mechanism (refer to :pep:`302` for details) and then executed in a "
"fresh module namespace."
msgstr ""
"Виконайте код зазначеного модуля та поверніть отриманий словник globals "
"модуля. Код модуля спочатку знаходить за допомогою стандартного механізму "
"імпорту (докладніше див. :pep:`302`), а потім виконується у новому просторі "
"імен модуля."

msgid ""
"The *mod_name* argument should be an absolute module name. If the module "
"name refers to a package rather than a normal module, then that package is "
"imported and the ``__main__`` submodule within that package is then executed "
"and the resulting module globals dictionary returned."
msgstr ""
"Аргумент *mod_name* має бути абсолютним ім’ям модуля. Якщо ім’я модуля "
"посилається на пакет, а не на звичайний модуль, тоді цей пакет імпортується, "
"а підмодуль ``__main__`` у цьому пакеті потім виконується, а отриманий "
"словник глобальних модулів повертається."

msgid ""
"The optional dictionary argument *init_globals* may be used to pre-populate "
"the module's globals dictionary before the code is executed. The supplied "
"dictionary will not be modified. If any of the special global variables "
"below are defined in the supplied dictionary, those definitions are "
"overridden by :func:`run_module`."
msgstr ""
"Додатковий аргумент словника *init_globals* може бути використаний для "
"попереднього заповнення глобального словника модуля перед виконанням коду. "
"Наданий словник не буде змінено. Якщо будь-яка зі спеціальних глобальних "
"змінних, наведених нижче, визначена в наданому словнику, ці визначення "
"замінюються :func:`run_module`."

msgid ""
"The special global variables ``__name__``, ``__spec__``, ``__file__``, "
"``__cached__``, ``__loader__`` and ``__package__`` are set in the globals "
"dictionary before the module code is executed (Note that this is a minimal "
"set of variables - other variables may be set implicitly as an interpreter "
"implementation detail)."
msgstr ""
"Спеціальні глобальні змінні ``__name__``, ``__spec__``, ``__file__``, "
"``__cached__``, ``__loader__`` і ``__package__`` встановлюються в "
"глобальному словнику перед кодом модуля виконується (Зверніть увагу, що це "
"мінімальний набір змінних - інші змінні можуть бути встановлені неявно як "
"деталь реалізації інтерпретатора)."

msgid ""
"``__name__`` is set to *run_name* if this optional argument is not :const:"
"`None`, to ``mod_name + '.__main__'`` if the named module is a package and "
"to the *mod_name* argument otherwise."
msgstr ""
"``__name__`` встановлено на *run_name*, якщо цей необов’язковий аргумент не "
"є :const:`None`, на ``mod_name + '.__main__``, якщо названий модуль є "
"пакетом, і на аргумент *mod_name* в іншому випадку ."

msgid ""
"``__spec__`` will be set appropriately for the *actually* imported module "
"(that is, ``__spec__.name`` will always be *mod_name* or ``mod_name + '."
"__main__``, never *run_name*)."
msgstr ""
"``__spec__`` буде встановлено належним чином для *фактично* імпортованого "
"модуля (тобто ``__spec__.name`` завжди буде *mod_name* або ``mod_name + '."
"__main__``, ніколи не *run_name*)."

msgid ""
"``__file__``, ``__cached__``, ``__loader__`` and ``__package__`` are :ref:"
"`set as normal <import-mod-attrs>` based on the module spec."
msgstr ""
"``__file__``, ``__cached__``, ``__loader__`` і ``__package__`` :ref:"
"`встановлені як звичайні <import-mod-attrs>` на основі специфікації модуля."

msgid ""
"If the argument *alter_sys* is supplied and evaluates to :const:`True`, then "
"``sys.argv[0]`` is updated with the value of ``__file__`` and ``sys."
"modules[__name__]`` is updated with a temporary module object for the module "
"being executed. Both ``sys.argv[0]`` and ``sys.modules[__name__]`` are "
"restored to their original values before the function returns."
msgstr ""
"Якщо вказано аргумент *alter_sys* і він має значення :const:`True`, тоді "
"``sys.argv[0]`` оновлюється значенням ``__file__`` і ``sys."
"modules[__name__]`` оновлюється тимчасовим об’єктом модуля для модуля, що "
"виконується. І ``sys.argv[0]``, і ``sys.modules[__name__]`` відновлюються до "
"своїх початкових значень перед поверненням функції."

msgid ""
"Note that this manipulation of :mod:`sys` is not thread-safe. Other threads "
"may see the partially initialised module, as well as the altered list of "
"arguments. It is recommended that the :mod:`sys` module be left alone when "
"invoking this function from threaded code."
msgstr ""
"Зауважте, що ця маніпуляція :mod:`sys` не є потокобезпечною. Інші потоки "
"можуть бачити частково ініціалізований модуль, а також змінений список "
"аргументів. Рекомендовано залишати модуль :mod:`sys` окремо під час виклику "
"цієї функції з потокового коду."

msgid ""
"The :option:`-m` option offering equivalent functionality from the command "
"line."
msgstr "Опція :option:`-m` пропонує еквівалентні функції з командного рядка."

msgid ""
"Added ability to execute packages by looking for a ``__main__`` submodule."
msgstr "Додано можливість виконувати пакети, шукаючи субмодуль ``__main__``."

msgid "Added ``__cached__`` global variable (see :pep:`3147`)."
msgstr "Додано глобальну змінну ``__cached__`` (див. :pep:`3147`)."

msgid ""
"Updated to take advantage of the module spec feature added by :pep:`451`. "
"This allows ``__cached__`` to be set correctly for modules run this way, as "
"well as ensuring the real module name is always accessible as ``__spec__."
"name``."
msgstr ""
"Оновлено, щоб скористатися перевагами функції специфікації модуля, доданої :"
"pep:`451`. Це дозволяє правильно встановити ``__cached__`` для модулів, що "
"запускаються таким чином, а також гарантує, що справжня назва модуля завжди "
"доступна як ``__spec__.name``."

msgid ""
"Execute the code at the named filesystem location and return the resulting "
"module globals dictionary. As with a script name supplied to the CPython "
"command line, the supplied path may refer to a Python source file, a "
"compiled bytecode file or a valid sys.path entry containing a ``__main__`` "
"module (e.g. a zipfile containing a top-level ``__main__.py`` file)."
msgstr ""
"Виконайте код у вказаному місці файлової системи та поверніть отриманий "
"словник глобальних модулів. Як і ім’я сценарію, яке надається в командному "
"рядку CPython, наданий шлях може посилатися на вихідний файл Python, "
"скомпільований файл байт-коду або дійсний запис sys.path, що містить модуль "
"``__main__`` (наприклад, zip-файл, що містить top- рівень ``__main__.py`` "
"файл)."

msgid ""
"For a simple script, the specified code is simply executed in a fresh module "
"namespace. For a valid sys.path entry (typically a zipfile or directory), "
"the entry is first added to the beginning of ``sys.path``. The function then "
"looks for and executes a :mod:`__main__` module using the updated path. Note "
"that there is no special protection against invoking an existing :mod:"
"`__main__` entry located elsewhere on ``sys.path`` if there is no such "
"module at the specified location."
msgstr ""
"Для простого сценарію вказаний код просто виконується у новому просторі імен "
"модуля. Для правильного запису sys.path (зазвичай це файл zip або каталог), "
"запис спочатку додається на початку ``sys.path``. Потім функція шукає та "
"виконує модуль :mod:`__main__`, використовуючи оновлений шлях. Зверніть "
"увагу, що немає спеціального захисту від виклику існуючого запису :mod:"
"`__main__`, розташованого в іншому місці ``sys.path``, якщо такого модуля "
"немає у вказаному місці."

msgid ""
"The optional dictionary argument *init_globals* may be used to pre-populate "
"the module's globals dictionary before the code is executed. The supplied "
"dictionary will not be modified. If any of the special global variables "
"below are defined in the supplied dictionary, those definitions are "
"overridden by :func:`run_path`."
msgstr ""
"Додатковий аргумент словника *init_globals* може бути використаний для "
"попереднього заповнення глобального словника модуля перед виконанням коду. "
"Наданий словник не буде змінено. Якщо будь-яка зі спеціальних глобальних "
"змінних, наведених нижче, визначена в наданому словнику, ці визначення "
"замінюються :func:`run_path`."

msgid ""
"``__name__`` is set to *run_name* if this optional argument is not :const:"
"`None` and to ``'<run_path>'`` otherwise."
msgstr ""
"``__name__`` встановлено на *run_name*, якщо цей необов’язковий аргумент не "
"є :const:`None`, і на ``' <run_path> ''`` в іншому випадку."

msgid ""
"If the supplied path directly references a script file (whether as source or "
"as precompiled byte code), then ``__file__`` will be set to the supplied "
"path, and ``__spec__``, ``__cached__``, ``__loader__`` and ``__package__`` "
"will all be set to :const:`None`."
msgstr ""
"Якщо наданий шлях безпосередньо посилається на файл сценарію (як джерело, "
"так і попередньо скомпільований байт-код), тоді ``__file__`` буде "
"встановлено на наданий шлях, а ``__spec__``, ``__cached__``, ``__loader__`` "
"і ``__package__`` буде встановлено на :const:`None`."

msgid ""
"If the supplied path is a reference to a valid sys.path entry, then "
"``__spec__`` will be set appropriately for the imported ``__main__`` module "
"(that is, ``__spec__.name`` will always be ``__main__``). ``__file__``, "
"``__cached__``, ``__loader__`` and ``__package__`` will be :ref:`set as "
"normal <import-mod-attrs>` based on the module spec."
msgstr ""
"Якщо наданий шлях є посиланням на дійсний запис sys.path, тоді ``__spec__`` "
"буде встановлено належним чином для імпортованого модуля ``__main__`` (тобто "
"``__spec__.name`` завжди буде ``__main__``). ``__file__``, ``__cached__``, "
"``__loader__`` і ``__package__`` будуть :ref:`встановлені як звичайні "
"<import-mod-attrs>` на основі специфікації модуля."

msgid ""
"A number of alterations are also made to the :mod:`sys` module. Firstly, "
"``sys.path`` may be altered as described above. ``sys.argv[0]`` is updated "
"with the value of ``path_name`` and ``sys.modules[__name__]`` is updated "
"with a temporary module object for the module being executed. All "
"modifications to items in :mod:`sys` are reverted before the function "
"returns."
msgstr ""
"Деякі зміни також внесено до модуля :mod:`sys`. По-перше, ``sys.path`` можна "
"змінити, як описано вище. ``sys.argv[0]`` оновлюється за допомогою значення "
"``path_name``, а ``sys.modules[__name__]`` оновлюється за допомогою "
"тимчасового об’єкта модуля для модуля, що виконується. Усі зміни до "
"елементів у :mod:`sys` повертаються до повернення функції."

msgid ""
"Note that, unlike :func:`run_module`, the alterations made to :mod:`sys` are "
"not optional in this function as these adjustments are essential to allowing "
"the execution of sys.path entries. As the thread-safety limitations still "
"apply, use of this function in threaded code should be either serialised "
"with the import lock or delegated to a separate process."
msgstr ""
"Зауважте, що, на відміну від :func:`run_module`, зміни, внесені до :mod:"
"`sys`, не є необов’язковими для цієї функції, оскільки ці налаштування є "
"важливими для виконання записів sys.path. Оскільки обмеження потокової "
"безпеки все ще застосовуються, використання цієї функції в багатопотоковому "
"коді має бути або серіалізовано за допомогою блокування імпорту, або "
"делеговано окремому процесу."

msgid ""
":ref:`using-on-interface-options` for equivalent functionality on the "
"command line (``python path/to/script``)."
msgstr ""
":ref:`using-on-interface-options` для еквівалентної функції в командному "
"рядку (``python path/to/script``)."

msgid ""
"Updated to take advantage of the module spec feature added by :pep:`451`. "
"This allows ``__cached__`` to be set correctly in the case where "
"``__main__`` is imported from a valid sys.path entry rather than being "
"executed directly."
msgstr ""
"Оновлено, щоб скористатися перевагами функції специфікації модуля, доданої :"
"pep:`451`. Це дозволяє правильно встановити ``__cached__`` у випадку, коли "
"``__main__`` імпортується з дійсного запису sys.path, а не виконується "
"безпосередньо."

msgid ":pep:`338` -- Executing modules as scripts"
msgstr ":pep:`338` -- Виконання модулів як скриптів"

msgid "PEP written and implemented by Nick Coghlan."
msgstr "PEP написав і реалізував Нік Коглан."

msgid ":pep:`366` -- Main module explicit relative imports"
msgstr ":pep:`366` -- Явний відносний імпорт основного модуля"

msgid ":pep:`451` -- A ModuleSpec Type for the Import System"
msgstr ":pep:`451` -- Тип ModuleSpec для системи імпорту"

msgid "PEP written and implemented by Eric Snow"
msgstr "PEP написав і реалізував Ерік Сноу"

msgid ":ref:`using-on-general` - CPython command line details"
msgstr ":ref:`using-on-general` - деталі командного рядка CPython"

msgid "The :func:`importlib.import_module` function"
msgstr "Функція :func:`importlib.import_module`"
