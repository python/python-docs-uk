# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`fcntl` --- The ``fcntl`` and ``ioctl`` system calls"
msgstr ":mod:`fcntl` --- Системні виклики ``fcntl`` і ``ioctl``"

msgid ""
"This module performs file control and I/O control on file descriptors. It is "
"an interface to the :c:func:`fcntl` and :c:func:`ioctl` Unix routines.  For "
"a complete description of these calls, see :manpage:`fcntl(2)` and :manpage:"
"`ioctl(2)` Unix manual pages."
msgstr ""
"Цей модуль виконує керування файлами та керування введенням/виведенням "
"файлових дескрипторів. Це інтерфейс до процедур Unix :c:func:`fcntl` і :c:"
"func:`ioctl`. Щоб отримати повний опис цих викликів, перегляньте :manpage:"
"`fcntl(2)` і :manpage:`ioctl(2)` сторінки посібника Unix."

msgid ""
"All functions in this module take a file descriptor *fd* as their first "
"argument.  This can be an integer file descriptor, such as returned by ``sys."
"stdin.fileno()``, or an :class:`io.IOBase` object, such as ``sys.stdin`` "
"itself, which provides a :meth:`~io.IOBase.fileno` that returns a genuine "
"file descriptor."
msgstr ""
"Усі функції в цьому модулі приймають файловий дескриптор *fd* як перший "
"аргумент. Це може бути цілочисельний файловий дескриптор, наприклад, "
"повернутий ``sys.stdin.fileno()``, або об’єкт :class:`io.IOBase`, як-от сам "
"``sys.stdin``, який надає :meth:`~io.IOBase.fileno`, який повертає справжній "
"дескриптор файлу."

msgid ""
"Operations in this module used to raise an :exc:`IOError` where they now "
"raise an :exc:`OSError`."
msgstr ""
"Раніше операції в цьому модулі викликали :exc:`IOError`, а тепер вони "
"викликають :exc:`OSError`."

msgid ""
"The fcntl module now contains ``F_ADD_SEALS``, ``F_GET_SEALS``, and "
"``F_SEAL_*`` constants for sealing of :func:`os.memfd_create` file "
"descriptors."
msgstr ""
"Модуль fcntl тепер містить константи ``F_ADD_SEALS``, ``F_GET_SEALS`` і "
"``F_SEAL_*`` для запечатування дескрипторів файлів :func:`os.memfd_create`."

msgid ""
"On macOS, the fcntl module exposes the ``F_GETPATH`` constant, which obtains "
"the path of a file from a file descriptor. On Linux(>=3.15), the fcntl "
"module exposes the ``F_OFD_GETLK``, ``F_OFD_SETLK`` and ``F_OFD_SETLKW`` "
"constants, which are used when working with open file description locks."
msgstr ""
"У macOS модуль fcntl надає константу ``F_GETPATH``, яка отримує шлях до "
"файлу з дескриптора файлу. У Linux (>=3.15) модуль fcntl надає константи "
"``F_OFD_GETLK``, ``F_OFD_SETLK`` і ``F_OFD_SETLKW``, які використовуються "
"під час роботи з відкритими блокуваннями опису файлу."

msgid ""
"On Linux >= 2.6.11, the fcntl module exposes the ``F_GETPIPE_SZ`` and "
"``F_SETPIPE_SZ`` constants, which allow to check and modify a pipe's size "
"respectively."
msgstr ""
"У Linux >= 2.6.11 модуль fcntl надає константи ``F_GETPIPE_SZ`` і "
"``F_SETPIPE_SZ``, які дозволяють перевіряти та змінювати розмір каналу "
"відповідно."

msgid "The module defines the following functions:"
msgstr "Модуль визначає такі функції:"

msgid ""
"Perform the operation *cmd* on file descriptor *fd* (file objects providing "
"a :meth:`~io.IOBase.fileno` method are accepted as well).  The values used "
"for *cmd* are operating system dependent, and are available as constants in "
"the :mod:`fcntl` module, using the same names as used in the relevant C "
"header files. The argument *arg* can either be an integer value, or a :class:"
"`bytes` object. With an integer value, the return value of this function is "
"the integer return value of the C :c:func:`fcntl` call.  When the argument "
"is bytes it represents a binary structure, e.g. created by :func:`struct."
"pack`. The binary data is copied to a buffer whose address is passed to the "
"C :c:func:`fcntl` call.  The return value after a successful call is the "
"contents of the buffer, converted to a :class:`bytes` object. The length of "
"the returned object will be the same as the length of the *arg* argument. "
"This is limited to 1024 bytes. If the information returned in the buffer by "
"the operating system is larger than 1024 bytes, this is most likely to "
"result in a segmentation violation or a more subtle data corruption."
msgstr ""
"Виконайте операцію *cmd* над файловим дескриптором *fd* (також приймаються "
"файлові об’єкти, що містять метод :meth:`~io.IOBase.fileno`). Значення, які "
"використовуються для *cmd*, залежать від операційної системи та доступні як "
"константи в модулі :mod:`fcntl`, використовуючи ті самі імена, що "
"використовуються у відповідних файлах заголовків C. Аргумент *arg* може бути "
"або цілим значенням, або об’єктом :class:`bytes`. З цілим значенням "
"значення, що повертається цією функцією, є цілим значенням, що повертається "
"викликом C :c:func:`fcntl`. Коли аргумент є байтами, він представляє "
"двійкову структуру, наприклад. створено :func:`struct.pack`. Двійкові дані "
"копіюються в буфер, адреса якого передається виклику C :c:func:`fcntl`. "
"Значення, що повертається після успішного виклику, є вмістом буфера, "
"перетвореним на об’єкт :class:`bytes`. Довжина повернутого об’єкта буде "
"такою ж, як і довжина аргументу *arg*. Це обмежено 1024 байтами. Якщо "
"інформація, яку операційна система повертає в буфер, перевищує 1024 байти, "
"це, швидше за все, призведе до порушення сегментації або більш тонкого "
"пошкодження даних."

msgid "If the :c:func:`fcntl` fails, an :exc:`OSError` is raised."
msgstr "Якщо :c:func:`fcntl` не вдається, виникає :exc:`OSError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.fcntl`` with arguments "
"``fd``, ``cmd``, ``arg``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``fcntl.fcntl`` з аргументами "
"``fd``, ``cmd``, ``arg``."

msgid ""
"This function is identical to the :func:`~fcntl.fcntl` function, except that "
"the argument handling is even more complicated."
msgstr ""
"Ця функція ідентична функції :func:`~fcntl.fcntl`, за винятком того, що "
"обробка аргументів ще складніша."

msgid ""
"The *request* parameter is limited to values that can fit in 32-bits. "
"Additional constants of interest for use as the *request* argument can be "
"found in the :mod:`termios` module, under the same names as used in the "
"relevant C header files."
msgstr ""
"Параметр *request* обмежується значеннями, які можуть вміститися в 32-бітах. "
"Додаткові цікаві константи для використання як аргументу *request* можна "
"знайти в модулі :mod:`termios` під тими самими назвами, які використовуються "
"у відповідних файлах заголовків C."

msgid ""
"The parameter *arg* can be one of an integer, an object supporting the read-"
"only buffer interface (like :class:`bytes`) or an object supporting the read-"
"write buffer interface (like :class:`bytearray`)."
msgstr ""
"Параметр *arg* може бути цілим числом, об’єктом, що підтримує інтерфейс "
"буфера лише для читання (наприклад, :class:`bytes`), або об’єктом, що "
"підтримує інтерфейс буфера для читання та запису (наприклад, :class:"
"`bytearray`)."

msgid ""
"In all but the last case, behaviour is as for the :func:`~fcntl.fcntl` "
"function."
msgstr ""
"У всіх випадках, крім останнього, поведінка така ж, як у функції :func:"
"`~fcntl.fcntl`."

msgid ""
"If a mutable buffer is passed, then the behaviour is determined by the value "
"of the *mutate_flag* parameter."
msgstr ""
"Якщо передається змінний буфер, поведінка визначається значенням параметра "
"*mutate_flag*."

msgid ""
"If it is false, the buffer's mutability is ignored and behaviour is as for a "
"read-only buffer, except that the 1024 byte limit mentioned above is avoided "
"-- so long as the buffer you pass is at least as long as what the operating "
"system wants to put there, things should work."
msgstr ""
"Якщо значення false, мінливість буфера ігнорується, а поведінка така ж, як і "
"для буфера лише для читання, за винятком того, що обмеження у 1024 байти, "
"згадане вище, уникає — доки переданий буфер має принаймні таку довжину, як і "
"операційна система. хоче поставити туди, речі повинні працювати."

msgid ""
"If *mutate_flag* is true (the default), then the buffer is (in effect) "
"passed to the underlying :func:`ioctl` system call, the latter's return code "
"is passed back to the calling Python, and the buffer's new contents reflect "
"the action of the :func:`ioctl`.  This is a slight simplification, because "
"if the supplied buffer is less than 1024 bytes long it is first copied into "
"a static buffer 1024 bytes long which is then passed to :func:`ioctl` and "
"copied back into the supplied buffer."
msgstr ""
"Якщо *mutate_flag* має значення true (за замовчуванням), тоді буфер "
"(фактично) передається базовому системному виклику :func:`ioctl`, код "
"повернення останнього передається назад викликаючому Python, а новий вміст "
"буфера відображає дія :func:`ioctl`. Це невелике спрощення, тому що якщо "
"довжина наданого буфера менша за 1024 байти, він спочатку копіюється в "
"статичний буфер довжиною 1024 байти, який потім передається до :func:`ioctl` "
"і копіюється назад у наданий буфер."

msgid "If the :c:func:`ioctl` fails, an :exc:`OSError` exception is raised."
msgstr "Якщо :c:func:`ioctl` не вдається, виникає виняток :exc:`OSError`."

msgid "An example::"
msgstr "Приклад::"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.ioctl`` with arguments "
"``fd``, ``request``, ``arg``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``fcntl.ioctl`` з аргументами "
"``fd``, ``request``, ``arg``."

msgid ""
"Perform the lock operation *operation* on file descriptor *fd* (file objects "
"providing a :meth:`~io.IOBase.fileno` method are accepted as well). See the "
"Unix manual :manpage:`flock(2)` for details.  (On some systems, this "
"function is emulated using :c:func:`fcntl`.)"
msgstr ""
"Виконайте операцію блокування *operation* для файлового дескриптора *fd* "
"(також приймаються файлові об’єкти, що містять метод :meth:`~io.IOBase."
"fileno`). Перегляньте посібник Unix :manpage:`flock(2)` для отримання "
"детальної інформації. (У деяких системах ця функція емулюється за допомогою :"
"c:func:`fcntl`.)"

msgid "If the :c:func:`flock` fails, an :exc:`OSError` exception is raised."
msgstr "Якщо :c:func:`flock` не вдається, виникає виняток :exc:`OSError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.flock`` with arguments "
"``fd``, ``operation``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``fcntl.flock`` з аргументами "
"``fd``, ``operation``."

msgid ""
"This is essentially a wrapper around the :func:`~fcntl.fcntl` locking calls. "
"*fd* is the file descriptor (file objects providing a :meth:`~io.IOBase."
"fileno` method are accepted as well) of the file to lock or unlock, and "
"*cmd* is one of the following values:"
msgstr ""
"По суті, це обгортка викликів блокування :func:`~fcntl.fcntl`. *fd* — це "
"дескриптор файлу (також приймаються об’єкти файлу, що містять метод :meth:"
"`~io.IOBase.fileno`) файлу, який потрібно заблокувати або розблокувати, а "
"*cmd* — одне з таких значень:"

msgid ":const:`LOCK_UN` -- unlock"
msgstr ":const:`LOCK_UN` -- розблокувати"

msgid ":const:`LOCK_SH` -- acquire a shared lock"
msgstr ":const:`LOCK_SH` -- отримання спільного блокування"

msgid ":const:`LOCK_EX` -- acquire an exclusive lock"
msgstr ":const:`LOCK_EX` -- отримати ексклюзивне блокування"

msgid ""
"When *cmd* is :const:`LOCK_SH` or :const:`LOCK_EX`, it can also be bitwise "
"ORed with :const:`LOCK_NB` to avoid blocking on lock acquisition. If :const:"
"`LOCK_NB` is used and the lock cannot be acquired, an :exc:`OSError` will be "
"raised and the exception will have an *errno* attribute set to :const:"
"`EACCES` or :const:`EAGAIN` (depending on the operating system; for "
"portability, check for both values).  On at least some systems, :const:"
"`LOCK_EX` can only be used if the file descriptor refers to a file opened "
"for writing."
msgstr ""
"Якщо *cmd* має значення :const:`LOCK_SH` або :const:`LOCK_EX`, його також "
"можна об’єднати порозрядним АБО за допомогою :const:`LOCK_NB`, щоб уникнути "
"блокування при отриманні блокування. Якщо :const:`LOCK_NB` використовується "
"і блокування не може бути отримано, буде викликано :exc:`OSError` і виняток "
"матиме атрибут *errno* зі значенням :const:`EACCES` або :const:`EAGAIN` "
"(залежно від операційної системи; для переносимості перевірте обидва "
"значення). Принаймні в деяких системах :const:`LOCK_EX` можна "
"використовувати, лише якщо дескриптор файлу посилається на файл, відкритий "
"для запису."

msgid ""
"*len* is the number of bytes to lock, *start* is the byte offset at which "
"the lock starts, relative to *whence*, and *whence* is as with :func:`io."
"IOBase.seek`, specifically:"
msgstr ""
"*len* — це кількість байтів для блокування, *start* — зсув у байтах, з якого "
"починається блокування, відносно *whence*, а *whence* — як у :func:`io."
"IOBase.seek`, зокрема:"

msgid ":const:`0` -- relative to the start of the file (:data:`os.SEEK_SET`)"
msgstr ":const:`0` -- відносно початку файлу (:data:`os.SEEK_SET`)"

msgid ""
":const:`1` -- relative to the current buffer position (:data:`os.SEEK_CUR`)"
msgstr ":const:`1` -- відносно поточної позиції буфера (:data:`os.SEEK_CUR`)"

msgid ":const:`2` -- relative to the end of the file (:data:`os.SEEK_END`)"
msgstr ":const:`2` -- відносно кінця файлу (:data:`os.SEEK_END`)"

msgid ""
"The default for *start* is 0, which means to start at the beginning of the "
"file. The default for *len* is 0 which means to lock to the end of the "
"file.  The default for *whence* is also 0."
msgstr ""
"Типовим значенням для *початку* є 0, що означає початок на початку файлу. "
"Типовим значенням для *len* є 0, що означає блокування до кінця файлу. За "
"замовчуванням для *whence* також дорівнює 0."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.lockf`` with arguments "
"``fd``, ``cmd``, ``len``, ``start``, ``whence``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``fcntl.lockf`` з аргументами "
"``fd``, ``cmd``, ``len``, ``start``, ``whence``."

msgid "Examples (all on a SVR4 compliant system)::"
msgstr "Приклади (усі в системі, сумісній з SVR4):"

msgid ""
"Note that in the first example the return value variable *rv* will hold an "
"integer value; in the second example it will hold a :class:`bytes` object.  "
"The structure lay-out for the *lockdata* variable is system dependent --- "
"therefore using the :func:`flock` call may be better."
msgstr ""
"Зверніть увагу, що в першому прикладі змінна *rv* буде мати ціле значення; у "
"другому прикладі він буде містити об’єкт :class:`bytes`. Схема структури для "
"змінної *lockdata* залежить від системи --- тому використання виклику :func:"
"`flock` може бути кращим."

msgid "Module :mod:`os`"
msgstr "Модуль :mod:`os`"

msgid ""
"If the locking flags :data:`~os.O_SHLOCK` and :data:`~os.O_EXLOCK` are "
"present in the :mod:`os` module (on BSD only), the :func:`os.open` function "
"provides an alternative to the :func:`lockf` and :func:`flock` functions."
msgstr ""
"Якщо прапорці блокування :data:`~os.O_SHLOCK` і :data:`~os.O_EXLOCK` "
"присутні в модулі :mod:`os` (лише в BSD), функція :func:`os.open` надає "
"альтернативу функціям :func:`lockf` і :func:`flock`."
